{"file_name": "/home/qj213/afp-2021-10-22/thys/Subresultants/Subresultant.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Subresultants", "problem_names": ["lemma basic_div_exp: assumes \"(to_fract x)^n / (to_fract y)^(n-1) \\<in> range to_fract\"\n  shows \"to_fract (basic_div_exp x y n) = (to_fract x)^n / (to_fract y)^(n-1)\"", "lemma even_sum_list: assumes \"\\<And> x. x \\<in> set xs \\<Longrightarrow> even (f x) = even (g x)\"\n  shows \"even (sum_list (map f xs)) = even (sum_list (map g xs))\"", "lemma for_all_Suc: \"P i \\<Longrightarrow> (\\<forall> j \\<ge> Suc i. P j) = (\\<forall> j \\<ge> i. P j)\" for P", "lemma pseudo_mod_left_0[simp]: \"pseudo_mod 0 x = 0\"", "lemma pseudo_mod_right_0[simp]: \"pseudo_mod x 0 = x\"", "lemma snd_pseudo_divmod_main_cong:\n  assumes \"a1 = b1\" \"a3 = b3\" \"a4 = b4\" \"a5 = b5\" \"a6 = b6\" (* note that a2 = b2 is not required! *)\n  shows \"snd (pseudo_divmod_main a1 a2 a3 a4 a5 a6) = snd (pseudo_divmod_main b1 b2 b3 b4 b5 b6)\"", "lemma snd_pseudo_mod_smult_invar_right:\n  shows \"(snd (pseudo_divmod_main (x * lc) q r (smult x d) dr n))\n         = snd (pseudo_divmod_main lc q' (smult (x^n) r) d dr n)\"", "lemma snd_pseudo_mod_smult_invar_left:\n  shows \"snd (pseudo_divmod_main lc q (smult x r) d dr n)\n       = smult x (snd (pseudo_divmod_main lc q' r d dr n))\"", "lemma snd_pseudo_mod_smult_left[simp]:\n  shows \"snd (pseudo_divmod (smult (x::'a::idom) p) q) = (smult x (snd (pseudo_divmod p q)))\"", "lemma pseudo_mod_smult_right:\n  assumes \"(x::'a::idom)\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"(pseudo_mod p (smult (x::'a::idom) q)) = (smult (x^(Suc (length (coeffs p)) - length (coeffs q))) (pseudo_mod p q))\"", "lemma pseudo_mod_zero[simp]:\n\"pseudo_mod 0 f = (0::'a :: {idom} poly)\"\n\"pseudo_mod f 0 = f\"", "lemma prod_combine:\n  assumes \"j \\<le> i\"\n  shows \"f i * (\\<Prod>l\\<leftarrow>[j..<i]. (f l :: 'a::comm_monoid_mult)) = prod_list (map f [j..<Suc i])\"", "lemma prod_list_minus_1_exp: \"prod_list (map (\\<lambda> i. (-1)^(f i)) xs)\n  = (-1)^(sum_list (map f xs))\"", "lemma minus_1_power_even: \"(- (1 :: 'b :: comm_ring_1))^ k = (if even k then 1 else (-1))\"", "lemma minus_1_even_eqI: assumes \"even k = even l\" shows\n    \"(- (1 :: 'b :: comm_ring_1))^k = (- 1)^l\"", "lemma (in comm_monoid_mult) prod_list_multf:\n  \"(\\<Prod>x\\<leftarrow>xs. f x * g x) = prod_list (map f xs) * prod_list (map g xs)\"", "lemma inverse_prod_list: \"inverse (prod_list xs) = prod_list (map inverse (xs :: 'a :: field list))\"", "lemma pow_int_0[simp]: \"pow_int x 0 = 1\"", "lemma pow_int_1[simp]: \"pow_int x 1 = x\"", "lemma exp_pow_int: \"x ^ n = pow_int x n\"", "lemma pow_int_add: assumes x: \"x \\<noteq> 0\" shows \"pow_int x (a + b) = pow_int x a * pow_int x b\"", "lemma pow_int_mult: \"pow_int (x * y) a = pow_int x a * pow_int y a\"", "lemma pow_int_base_1[simp]: \"pow_int 1 a = 1\"", "lemma pow_int_divide: \"a / pow_int x b = a * pow_int x (-b)\"", "lemma divide_prod_assoc: \"x / (y * z :: 'a :: field) = x / y / z\"", "lemma minus_1_inverse_pow[simp]: \"x / (-1)^n = (x :: 'a :: field) * (-1)^n\"", "lemma subresultant_mat_dim[simp]:\n  fixes j p q\n  defines \"S \\<equiv> subresultant_mat j p q\"\n  shows \"dim_row S = (degree p - j) + (degree q - j)\" and \"dim_col S = (degree p - j) + (degree q - j)\"", "lemma subresultant_index_mat:\n  fixes F G\n  assumes i: \"i < (degree F - J) + (degree G - J)\" and j: \"j < (degree F - J) + (degree G - J)\"\n  shows \"subresultant_mat J F G $$ (i,j) =\n    (if j < degree G - J then\n       if i = (degree F - J) + (degree G - J) - 1 then monom 1 (degree G - J - 1 - j) * F else ([: coeff_int F ( degree F - int i + int j) :])\n      else let jj = j - (degree G - J) in\n       if i = (degree F - J) + (degree G - J) - 1 then monom 1 ( degree F - J - 1 - jj) * G else ([: coeff_int G (degree G - int i + int jj) :]))\"", "lemma subresultant_smult_left: assumes \"(c :: 'a :: {comm_ring_1, semiring_no_zero_divisors}) \\<noteq> 0\"\n  shows \"subresultant J (smult c f) g = smult (c ^ (degree g - J)) (subresultant J f g)\"", "lemma subresultant_swap:\n  shows \"subresultant J f g = smult ((- 1) ^ ((degree f - J) * (degree g - J))) (subresultant J g f)\"", "lemma subresultant_smult_right:assumes \"(c :: 'a :: {comm_ring_1, semiring_no_zero_divisors}) \\<noteq> 0\"\n  shows \"subresultant J f (smult c g) = smult (c ^ (degree f - J)) (subresultant J f g)\"", "lemma coeff_subresultant: \"coeff (subresultant J F G) l =\n  (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0 else det (subresultant'_mat J l F G))\"", "lemma subresultant'_zero_ge: assumes \"(degree f - J) + (degree g - J) \\<noteq> 0\" and \"k \\<ge> degree f + (degree g - J)\"\n  shows \"det (subresultant'_mat J k f g) = 0\"", "lemma subresultant'_zero_lt: assumes\n  J: \"J \\<le> degree f\" \"J \\<le> degree g\" \"J < k\"\n  and k: \"k < degree f + (degree g - J)\"\n  shows \"det (subresultant'_mat J k f g) = 0\"", "lemma subresultant'_mat_sylvester_mat: \"transpose_mat (subresultant'_mat 0 0 f g) = sylvester_mat f g\"", "lemma coeff_subresultant_0_0_resultant: \"coeff (subresultant 0 f g) 0 = resultant f g\"", "lemma subresultant_zero_ge: assumes \"k \\<ge> degree f + (degree g - J)\"\n  and \"(degree f - J) + (degree g - J) \\<noteq> 0\"\n  shows \"coeff (subresultant J f g) k = 0\"", "lemma subresultant_zero_lt: assumes \"k < degree f + (degree g - J)\"\n  and \"J \\<le> degree f\" \"J \\<le> degree g\" \"J < k\"\n  shows \"coeff (subresultant J f g) k = 0\"", "lemma subresultant_resultant: \"subresultant 0 f g = [: resultant f g :]\"", "lemma (in inj_comm_ring_hom) subresultant_hom:\n  \"map_poly hom (subresultant J f g) = subresultant J (map_poly hom f) (map_poly hom g)\"", "lemma resultant_smult_left: assumes \"(c :: 'a :: idom) \\<noteq> 0\"\n  shows \"resultant (smult c f) g = c ^ degree g * resultant f g\"", "lemma resultant_smult_right: assumes \"(c :: 'a :: idom) \\<noteq> 0\"\n  shows \"resultant f (smult c g) = c ^ degree f * resultant f g\"", "lemma resultant_swap: \"resultant f g = (-1)^(degree f * degree g) * (resultant g f)\"", "lemma  fixes F B G H :: \"'a :: idom poly\" and J :: nat\n       defines df: \"df \\<equiv> degree F\"\n  and dg: \"dg \\<equiv> degree G\"\n  and dh: \"dh \\<equiv> degree H\"\n  and db: \"db \\<equiv> degree B\"\n  defines\n    n: \"n \\<equiv> (df - J) + (dg - J)\"\n  and f: \"f \\<equiv> coeff_int F\"\n  and b: \"b \\<equiv> coeff_int B\"\n  and g: \"g \\<equiv> coeff_int G\"\n  and h: \"h \\<equiv> coeff_int H\"\n  assumes FGH: \"F + B * G = H\"\n  and dfg: \"df \\<ge> dg\"\n  and choice: \"dg > dh \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\"\nshows BT_eq_18: \"subresultant J F G = smult ((-1)^((df - J) * (dg - J))) (det (mat n n\n  (\\<lambda> (i,j).\n              if j < df - J\n              then if i = n - 1 then monom 1 ((df - J) - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom 1 ((dg - J) - 1 - (j - (df - J))) * H\n                   else [:h (int df - int i + int (j - (df - J))):])))\"\n   (is \"_ = smult ?m1 ?right\")\n  and BT_eq_19: \"dh \\<le> J \\<Longrightarrow> J < dg \\<Longrightarrow> subresultant J F G = smult (\n    (-1)^((df - J) * (dg - J)) * lead_coeff G ^ (df - J) * coeff H J ^ (dg - J - 1)) H\"\n    (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> _ = smult (_ * ?G * ?H) H\")\n  and BT_lemma_1_12: \"J < dh \\<Longrightarrow> subresultant J F G = smult (\n    (-1)^((df - J) * (dg - J)) * lead_coeff G ^ (df - dh)) (subresultant J G H)\"\n  and BT_lemma_1_13': \"J = dh \\<Longrightarrow> dg > dh \\<or> H \\<noteq> 0 \\<Longrightarrow> subresultant dh F G = smult (\n    (-1)^((df - dh) * (dg - dh)) * lead_coeff G ^ (df - dh) * lead_coeff H ^ (dg - dh - 1)) H\"\n  and BT_lemma_1_14: \"dh < J \\<Longrightarrow> J < dg - 1 \\<Longrightarrow> subresultant J F G = 0\"\n  and BT_lemma_1_15': \"J = dg - 1 \\<Longrightarrow> dg > dh \\<or> H \\<noteq> 0 \\<Longrightarrow> subresultant (dg - 1) F G = smult (\n    (-1)^(df - dg + 1) * lead_coeff G ^ (df - dg + 1)) H\"", "lemmas BT_lemma_1_13 = BT_lemma_1_13'[OF _ _ _ refl]", "lemmas BT_lemma_1_15 = BT_lemma_1_15'[OF _ _ _ refl]", "lemma subresultant_product: fixes F :: \"'a :: idom poly\"\n  assumes \"F = B * G\"\n  and FG: \"degree F \\<ge> degree G\"\nshows \"subresultant J F G = (if J < degree G then 0 else\n   if J < degree F then smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\"", "lemma resultant_pseudo_mod_0: assumes \"pseudo_mod f g = (0 :: 'a :: idom_divide poly)\"\n  and dfg: \"degree f \\<ge> degree g\"\n  and f: \"f \\<noteq> 0\" and g: \"g \\<noteq> 0\"\n  shows \"resultant f g = (if degree g = 0 then lead_coeff g^degree f else 0)\"", "lemma f10: \"f 1 \\<noteq> 0\" and f20: \"f 2 \\<noteq> 0\"", "lemma f0: \"i \\<noteq> 0 \\<Longrightarrow> f i = 0 \\<longleftrightarrow> i > k\"", "lemma n_gt: assumes \"2 \\<le> i\" \"i < k\"\n  shows \"n i > n (Suc i)\"", "lemma n_ge: assumes \"1 \\<le> i\" \"i < k\"\n  shows \"n i \\<ge> n (Suc i)\"", "lemma n_ge_trans: assumes \"1 \\<le> i\" \"i \\<le> j\" \"j \\<le> k\"\n  shows \"n i \\<ge> n j\"", "lemma delta_gt: assumes \"2 \\<le> i\" \"i < k\"\n  shows \"\\<delta> i > 0\"", "lemma k2:\"2 \\<le> k\"", "lemma k0: \"k \\<noteq> 0\"", "lemma ni2:\"3 \\<le> i \\<Longrightarrow> i \\<le> k \\<Longrightarrow> n i \\<noteq> n 2\"", "lemma \\<alpha>0: \"i > 1 \\<Longrightarrow> \\<alpha> i = 0 \\<longleftrightarrow> (i - 1) > k\"", "lemma \\<alpha>_char:\nassumes \"3 \\<le> i\" \"i < k + 2\"\n  shows \"\\<alpha> i = (f (i - 1)) ^ (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\"", "lemma beta_F_as_sum:\n  assumes \"3 \\<le> i\" \"i \\<le> Suc k\"\n  shows \"smult (\\<beta> i) (F i) = smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)\" (is ?t1)", "lemma assumes \"3 \\<le> i\" \"i \\<le> k\" shows\n  BT_lemma_2_21: \"j < n i \\<Longrightarrow> smult (\\<alpha> i ^ (n (i - 1) - j)) (subresultant j (F (i - 2)) (F (i - 1)))\n  = smult ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) * (f (i - 1)) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) * (\\<beta> i) ^ (n (i - 1) - j)) (subresultant j (F (i - 1)) (F i))\"\n    (is \"_ \\<Longrightarrow> ?eq_21\") and\n  BT_lemma_2_22: \"smult (\\<alpha> i ^ (\\<delta> (i - 1))) (subresultant (n i) (F (i - 2)) (F (i - 1)))\n  = smult ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) * f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) * f i ^ (\\<delta> (i - 1) - 1) * (\\<beta> i) ^ \\<delta> (i - 1)) (F i)\"\n    (is \"?eq_22\") and\n  BT_lemma_2_23: \"n i < j \\<Longrightarrow> j < n (i - 1) - 1 \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\"\n    (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> ?eq_23\") and\n  BT_lemma_2_24: \"smult (\\<alpha> i) (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)))\n  = smult ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) (F i)\" (is \"?eq_24\")", "lemma BT_eq_30: \"3 \\<le> i \\<Longrightarrow> i \\<le> k + 1 \\<Longrightarrow> j < n (i - 1) \\<Longrightarrow>\n    smult (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) (subresultant j (F 1) (F 2))\n  = smult (\\<Prod>l\\<leftarrow>[3..<i]. \\<beta> l ^ (n (l - 1) - j) * f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1))\n        * (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))) (subresultant j (F (i - 2)) (F (i - 1)))\"", "lemma nonzero_alphaprod: assumes \"i \\<le> k + 1\" shows \"(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (p l)) \\<noteq> 0\"", "lemma BT_eq_30': assumes i: \"3 \\<le> i\" \"i \\<le> k + 1\" \"j < n (i - 1)\"\nshows \"subresultant j (F 1) (F 2)\n  = smult ((- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j))\n     * (\\<Prod>l\\<leftarrow>[3..<i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) * (\\<Prod>l\\<leftarrow>[3..<i]. f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)))) (subresultant j (F (i - 2)) (F (i - 1)))\"\n  (is \"_ = smult (?mm * ?b * ?f) _\")", "lemma fundamental_theorem_eq_4: assumes i: \"3 \\<le> i\" \"i \\<le> k\"\n  shows \"ffp (R (n (i - 1) - 1)) = smult (\\<gamma> i) (F i)\"", "lemma fundamental_theorem_eq_5: assumes i: \"3 \\<le> i\" \"i \\<le> k\" \"n i < j\" \"j < n (i - 1) - 1\"\n  shows \"R j = 0\"", "lemma fundamental_theorem_eq_6: assumes \"3 \\<le> i\" \"i \\<le> k\" shows \"ffp (R (n i)) = smult (\\<Theta> i) (F i)\"\n  (is \"?lhs=?rhs\")", "lemma fundamental_theorem_eq_7: assumes j: \"j < n k\" shows \"R j = 0\"", "lemma gamma_delta_beta_3: \"\\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3\"", "lemma smult_inverse_sdiv_poly: assumes ffp: \"p \\<in> range ffp\"\n  and p: \"p = smult (inverse x) q\"\n  and p': \"p' = sdiv_poly q' x'\"\n  and xx: \"x = ff x'\"\n  and qq: \"q = ffp q'\"\nshows \"p = ffp p'\"", "lemma B_eq_17_main: \"2 \\<le> i \\<Longrightarrow> i \\<le> k \\<Longrightarrow>\n    h i = (-1) ^ (n 1 + n i + i + 1) / f i\n   * (\\<Prod>l\\<leftarrow>[3..< Suc (Suc i)]. (\\<alpha> l / \\<beta> l)) \\<and> h i \\<noteq> 0\"", "lemma B_eq_17: \"2 \\<le> i \\<Longrightarrow> i \\<le> k \\<Longrightarrow>\n    h i = (-1) ^ (n 1 + n i + i + 1) / f i * (\\<Prod>l\\<leftarrow>[3..< Suc (Suc i)]. (\\<alpha> l / \\<beta> l))\"", "lemma B_theorem_2: \"3 \\<le> i \\<Longrightarrow> i \\<le> Suc k \\<Longrightarrow> \\<gamma> i = 1\"", "lemma B_theorem_3_b: \"\\<Theta> i * f i = ff (lead_coeff (H i))\"", "lemma B_theorem_3_main: \"\\<Theta> i * f i / \\<gamma> (i + 1) = (-1)^(n 1 + n i + i + 1) / f i * (\\<Prod>l\\<leftarrow>[3..< Suc (Suc i)]. (\\<alpha> l / \\<beta> l))\"", "lemma B_theorem_3: \"h i = \\<Theta> i * f i\" \"h i = ff (lead_coeff (H i))\"", "lemma h0: \"i \\<le> k \\<Longrightarrow> h i \\<noteq> 0\"", "lemma deg_G12: \"degree G1 \\<ge> degree G2\"", "lemma R0: shows \"R 0 = [: resultant G1 G2 :]\"", "lemma subresultant_prs_main: assumes \"subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk)\"\n  and \"F i = ffp Gi\"\n  and \"F (i - 1) = ffp Gi_1\"\n  and \"h (i - 1) = ff hi_1\"\n  and \"i \\<ge> 3\" \"i \\<le> k\"\nshows \"F k = ffp Gk \\<and> h k = ff hk \\<and> (\\<forall> j. i \\<le> j \\<longrightarrow> j \\<le> k \\<longrightarrow> F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\"", "lemma subresultant_prs: assumes res: \"subresultant_prs div_exp G1 G2 = (Gk, hk)\"\n  shows \"F k = ffp Gk \\<and> h k = ff hk \\<and> (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and> (3 \\<le> i \\<longrightarrow> i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)\"", "lemma resultant_impl_main: \"resultant_impl_main div_exp G1 G2 = resultant G1 G2\"", "lemma Fb0: assumes base: \"G1 \\<noteq> 0\" \"G2 \\<noteq> 0\"\n  shows \"(F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and> b i \\<noteq> 0 \\<and> h i \\<noteq> 0\"", "lemma k_exists: \"\\<exists> i. F (Suc i) = 0\"", "lemma k: \"F (Suc k) = 0\" \"i < k \\<Longrightarrow> F (Suc i) \\<noteq> 0\"", "lemma enter_subresultant_prs: assumes len: \"length (coeffs G1) \\<ge> length (coeffs G2)\"\n  and G2: \"G2 \\<noteq> 0\"\nshows \"\\<exists> F n d f k b. subresultant_prs_locale2 F n d f k b G1 G2\"", "lemma resultant_impl_main: assumes len: \"length (coeffs G1) \\<ge> length (coeffs G2)\"\n  shows \"resultant_impl_main div_exp G1 G2 = resultant G1 G2\"", "theorem resultant_impl_generic: \"resultant_impl_generic div_exp = resultant\"", "lemma resultant_impl[simp]: \"resultant_impl = resultant\"", "lemma resultant_impl_idom_divide[simp]: \"resultant_impl_idom_divide = resultant\"", "lemma subresultant_prs_impl: \"subresultant_prs_impl f G1 G2 = f (subresultant_prs dichotomous_Lazard G1 G2)\"", "lemma resultant_impl_start_code[code]:\n  \"resultant_impl_start G1 G2 =\n     (let pmod = pseudo_mod G1 G2;\n          n2 = degree G2;\n          n1 = degree G1;\n          g2 = lead_coeff G2;\n          d1 = n1 - n2\n         in if pmod = 0 then if n2 = 0 then if d1 = 0 then 1 else if d1 = 1 then g2 else g2 ^ d1 else 0\n            else let\n                 G3 = if even d1 then - pmod else pmod;\n                 n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n                 in if pmod = 0\n                    then if n3 = 0 then\n                     let d2 = n2 - n3;\n                         g3 = lead_coeff G3\n                        in (if d2 = 1 then g3 else\n                            dichotomous_Lazard g3 (if d1 = 1 then g2 else g2 ^ d1) d2) else 0\n                    else let\n                           h2 = (if d1 = 1 then g2 else g2 ^ d1);\n                           d2 = n2 - n3;\n                           divisor = (if d2 = 1 then g2 * h2 else if even d2 then - g2 * h2 ^ d2 else g2 * h2 ^ d2);\n                           G4 = sdiv_poly pmod divisor\n                         in resultant_impl_rec G3 G4 n3 d2 h2)\"", "lemma resultant_impl_rec_code[code]:\n  \"resultant_impl_rec Gi_1 Gi ni_1 d1_1 hi_2 = (\n    let ni = degree Gi;\n        pmod = pseudo_mod Gi_1 Gi\n     in\n     if pmod = 0\n        then if ni = 0\n          then\n            let\n              d1 = ni_1 - ni;\n              gi = lead_coeff Gi\n            in if d1 = 1 then gi else\n              let gi_1 = lead_coeff Gi_1;\n                  hi_1 = (if d1_1 = 1 then gi_1 else dichotomous_Lazard gi_1 hi_2 d1_1) in\n                dichotomous_Lazard gi hi_1 d1\n          else 0\n        else let\n           d1 = ni_1 - ni;\n           gi_1 = lead_coeff Gi_1;\n           hi_1 = (if d1_1 = 1 then gi_1 else dichotomous_Lazard gi_1 hi_2 d1_1);\n           divisor = if d1 = 1 then gi_1 * hi_1 else if even d1 then - gi_1 * hi_1 ^ d1 else gi_1 * hi_1 ^ d1;\n           Gi_p1 = sdiv_poly pmod divisor\n       in resultant_impl_rec Gi Gi_p1 ni d1 hi_1)\"", "lemma resultant_impl_Lazard_code[code]: \"resultant_impl_Lazard G1 G2 =\n  (if G2 = 0 then if degree G1 = 0 then 1 else 0\n     else resultant_impl_start G1 G2)\"", "lemma resultant_impl_code[code]: \"resultant_impl f g =\n  (if length (coeffs f) \\<ge> length (coeffs g) then resultant_impl_Lazard f g\n     else let res = resultant_impl_Lazard g f in\n      if even (degree f) \\<or> even (degree g) then res else - res)\"", "lemma resultant_code[code]: \"resultant f g = resultant_impl f g\""], "translations": [["", "lemma basic_div_exp: assumes \"(to_fract x)^n / (to_fract y)^(n-1) \\<in> range to_fract\"\n  shows \"to_fract (basic_div_exp x y n) = (to_fract x)^n / (to_fract y)^(n-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_fract (basic_div_exp x y n) = to_fract x ^ n / to_fract y ^ (n - 1)", "unfolding basic_div_exp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_fract (x ^ n div y ^ (n - 1)) = to_fract x ^ n / to_fract y ^ (n - 1)", "by (rule sym, rule div_divide_to_fract[OF assms refl refl], auto simp: hom_distribs)"], ["", "abbreviation pdivmod :: \"'a::field poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly \\<times> 'a poly\"\nwhere\n  \"pdivmod p q \\<equiv> (p div q, p mod q)\""], ["", "lemma even_sum_list: assumes \"\\<And> x. x \\<in> set xs \\<Longrightarrow> even (f x) = even (g x)\"\n  shows \"even (sum_list (map f xs)) = even (sum_list (map g xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sum_list (map f xs)) = even (sum_list (map g xs))", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> even (f ?x) = even (g ?x)\n\ngoal (1 subgoal):\n 1. even (sum_list (map f xs)) = even (sum_list (map g xs))", "by (induct xs, auto)"], ["", "lemma for_all_Suc: \"P i \\<Longrightarrow> (\\<forall> j \\<ge> Suc i. P j) = (\\<forall> j \\<ge> i. P j)\" for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P i \\<Longrightarrow>\n    (\\<forall>j\\<ge>Suc i. P j) = (\\<forall>j\\<ge>i. P j)", "by (metis (full_types) Suc_le_eq less_le)"], ["", "(* part on pseudo_divmod *)"], ["", "lemma pseudo_mod_left_0[simp]: \"pseudo_mod 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod 0 x = 0", "unfolding pseudo_mod_def pseudo_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if x = 0 then (0, 0)\n         else pseudo_divmod_main (lead_coeff x) 0 0 x (degree 0)\n               (1 + length (coeffs 0) - length (coeffs x))) =\n    0", "by (cases \"x = 0\"; cases \"length (coeffs x)\", auto)"], ["", "lemma pseudo_mod_right_0[simp]: \"pseudo_mod x 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod x 0 = x", "unfolding pseudo_mod_def pseudo_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if 0 = 0 then (0, x)\n         else pseudo_divmod_main (lead_coeff 0) 0 x 0 (degree x)\n               (1 + length (coeffs x) - length (coeffs 0))) =\n    x", "by simp"], ["", "lemma snd_pseudo_divmod_main_cong:\n  assumes \"a1 = b1\" \"a3 = b3\" \"a4 = b4\" \"a5 = b5\" \"a6 = b6\" (* note that a2 = b2 is not required! *)\n  shows \"snd (pseudo_divmod_main a1 a2 a3 a4 a5 a6) = snd (pseudo_divmod_main b1 b2 b3 b4 b5 b6)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main a1 a2 a3 a4 a5 a6) =\n    snd (pseudo_divmod_main b1 b2 b3 b4 b5 b6)", "using assms snd_pseudo_divmod_main"], ["proof (prove)\nusing this:\n  a1 = b1\n  a3 = b3\n  a4 = b4\n  a5 = b5\n  a6 = b6\n  snd (pseudo_divmod_main ?lc ?q ?r ?d ?dr ?n) =\n  snd (pseudo_divmod_main ?lc ?q' ?r ?d ?dr ?n)\n\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main a1 a2 a3 a4 a5 a6) =\n    snd (pseudo_divmod_main b1 b2 b3 b4 b5 b6)", "by metis"], ["", "lemma snd_pseudo_mod_smult_invar_right:\n  shows \"(snd (pseudo_divmod_main (x * lc) q r (smult x d) dr n))\n         = snd (pseudo_divmod_main lc q' (smult (x^n) r) d dr n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr n) =\n    snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr n)", "proof(induct n arbitrary: q q' r dr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main (x * lc) ?q ?r (Polynomial.smult x d) ?dr n) =\n  snd (pseudo_divmod_main lc ?q' (Polynomial.smult (x ^ n) ?r) d ?dr n)\n\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "let ?q = \"smult (x * lc) q + monom (coeff r dr) n\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "let ?r = \"smult (x * lc) r - (smult x (monom (coeff r dr) n * d))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "let ?dr = \"dr - 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "let ?rec_lhs = \"pseudo_divmod_main (x * lc) ?q ?r (smult x d) ?dr n\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "let ?rec_rhs = \"pseudo_divmod_main lc q' (smult (x^n) ?r) d ?dr n\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "have [simp]: \"\\<And> n. x ^ n * (x * lc) = lc * (x * x ^ n)\"\n               \"\\<And> n c. x ^ n * (x * c) = x * x ^ n * c\"\n               \"\\<And> n. x * x ^ n * lc = lc * (x * x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. x ^ n * (x * lc) = lc * (x * x ^ n)) &&&\n    (\\<And>n c. x ^ n * (x * c) = x * x ^ n * c) &&&\n    (\\<And>n. x * x ^ n * lc = lc * (x * x ^ n))", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  x ^ ?n * (x * lc) = lc * (x * x ^ ?n)\n  x ^ ?n * (x * ?c) = x * x ^ ?n * ?c\n  x * x ^ ?n * lc = lc * (x * x ^ ?n)\n\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "have \"snd (pseudo_divmod_main (x * lc) q r (smult x d) dr (Suc n)) = snd ?rec_lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n          (Suc n)) =\n    snd (pseudo_divmod_main (x * lc)\n          (Polynomial.smult (x * lc) q + monom (coeff r dr) n)\n          (Polynomial.smult (x * lc) r -\n           Polynomial.smult x (monom (coeff r dr) n * d))\n          (Polynomial.smult x d) (dr - 1) n)", "by (auto simp:Let_def)"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr (Suc n)) =\n  snd (pseudo_divmod_main (x * lc)\n        (Polynomial.smult (x * lc) q + monom (coeff r dr) n)\n        (Polynomial.smult (x * lc) r -\n         Polynomial.smult x (monom (coeff r dr) n * d))\n        (Polynomial.smult x d) (dr - 1) n)\n\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "also"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr (Suc n)) =\n  snd (pseudo_divmod_main (x * lc)\n        (Polynomial.smult (x * lc) q + monom (coeff r dr) n)\n        (Polynomial.smult (x * lc) r -\n         Polynomial.smult x (monom (coeff r dr) n * d))\n        (Polynomial.smult x d) (dr - 1) n)\n\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "have \"\\<dots> = snd ?rec_rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main (x * lc)\n          (Polynomial.smult (x * lc) q + monom (coeff r dr) n)\n          (Polynomial.smult (x * lc) r -\n           Polynomial.smult x (monom (coeff r dr) n * d))\n          (Polynomial.smult x d) (dr - 1) n) =\n    snd (pseudo_divmod_main lc q'\n          (Polynomial.smult (x ^ n)\n            (Polynomial.smult (x * lc) r -\n             Polynomial.smult x (monom (coeff r dr) n * d)))\n          d (dr - 1) n)", "using Suc"], ["proof (prove)\nusing this:\n  snd (pseudo_divmod_main (x * lc) ?q ?r (Polynomial.smult x d) ?dr n) =\n  snd (pseudo_divmod_main lc ?q' (Polynomial.smult (x ^ n) ?r) d ?dr n)\n\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main (x * lc)\n          (Polynomial.smult (x * lc) q + monom (coeff r dr) n)\n          (Polynomial.smult (x * lc) r -\n           Polynomial.smult x (monom (coeff r dr) n * d))\n          (Polynomial.smult x d) (dr - 1) n) =\n    snd (pseudo_divmod_main lc q'\n          (Polynomial.smult (x ^ n)\n            (Polynomial.smult (x * lc) r -\n             Polynomial.smult x (monom (coeff r dr) n * d)))\n          d (dr - 1) n)", "by auto"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main (x * lc)\n        (Polynomial.smult (x * lc) q + monom (coeff r dr) n)\n        (Polynomial.smult (x * lc) r -\n         Polynomial.smult x (monom (coeff r dr) n * d))\n        (Polynomial.smult x d) (dr - 1) n) =\n  snd (pseudo_divmod_main lc q'\n        (Polynomial.smult (x ^ n)\n          (Polynomial.smult (x * lc) r -\n           Polynomial.smult x (monom (coeff r dr) n * d)))\n        d (dr - 1) n)\n\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "also"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main (x * lc)\n        (Polynomial.smult (x * lc) q + monom (coeff r dr) n)\n        (Polynomial.smult (x * lc) r -\n         Polynomial.smult x (monom (coeff r dr) n * d))\n        (Polynomial.smult x d) (dr - 1) n) =\n  snd (pseudo_divmod_main lc q'\n        (Polynomial.smult (x ^ n)\n          (Polynomial.smult (x * lc) r -\n           Polynomial.smult x (monom (coeff r dr) n * d)))\n        d (dr - 1) n)\n\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "have \"\\<dots> = snd (pseudo_divmod_main lc q' (smult (x^Suc n) r) d dr (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main lc q'\n          (Polynomial.smult (x ^ n)\n            (Polynomial.smult (x * lc) r -\n             Polynomial.smult x (monom (coeff r dr) n * d)))\n          d (dr - 1) n) =\n    snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n          (Suc n))", "unfolding pseudo_divmod_main.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main lc q'\n          (Polynomial.smult (x ^ n)\n            (Polynomial.smult (x * lc) r -\n             Polynomial.smult x (monom (coeff r dr) n * d)))\n          d (dr - 1) n) =\n    snd (pseudo_divmod_main lc\n          (Polynomial.smult lc q' +\n           monom (coeff (Polynomial.smult (x ^ Suc n) r) dr) n)\n          (Polynomial.smult lc (Polynomial.smult (x ^ Suc n) r) -\n           monom (coeff (Polynomial.smult (x ^ Suc n) r) dr) n * d)\n          d (dr - 1) n)", "proof(rule snd_pseudo_divmod_main_cong,goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. lc = lc\n 2. Polynomial.smult (x ^ n)\n     (Polynomial.smult (x * lc) r -\n      Polynomial.smult x (monom (coeff r dr) n * d)) =\n    Polynomial.smult lc (Polynomial.smult (x ^ Suc n) r) -\n    monom (coeff (Polynomial.smult (x ^ Suc n) r) dr) n * d\n 3. d = d\n 4. dr - 1 = dr - 1\n 5. n = n", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. lc = lc\n 2. Polynomial.smult (x ^ n)\n     (Polynomial.smult (x * lc) r -\n      Polynomial.smult x (monom (coeff r dr) n * d)) =\n    Polynomial.smult lc (Polynomial.smult (x ^ Suc n) r) -\n    monom (coeff (Polynomial.smult (x ^ Suc n) r) dr) n * d\n 3. d = d\n 4. dr - 1 = dr - 1\n 5. n = n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (x ^ n)\n     (Polynomial.smult (x * lc) r -\n      Polynomial.smult x (monom (coeff r dr) n * d)) =\n    Polynomial.smult lc (Polynomial.smult (x ^ Suc n) r) -\n    monom (coeff (Polynomial.smult (x ^ Suc n) r) dr) n * d", "by (auto simp:smult_add_right smult_diff_right smult_monom smult_monom_mult)"], ["proof (state)\nthis:\n  Polynomial.smult (x ^ n)\n   (Polynomial.smult (x * lc) r -\n    Polynomial.smult x (monom (coeff r dr) n * d)) =\n  Polynomial.smult lc (Polynomial.smult (x ^ Suc n) r) -\n  monom (coeff (Polynomial.smult (x ^ Suc n) r) dr) n * d\n\ngoal (4 subgoals):\n 1. lc = lc\n 2. d = d\n 3. dr - 1 = dr - 1\n 4. n = n", "qed auto"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main lc q'\n        (Polynomial.smult (x ^ n)\n          (Polynomial.smult (x * lc) r -\n           Polynomial.smult x (monom (coeff r dr) n * d)))\n        d (dr - 1) n) =\n  snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n        (Suc n))\n\ngoal (2 subgoals):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)\n 2. \\<And>n q q' r dr.\n       (\\<And>q q' r dr.\n           snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n                 n) =\n           snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ n) r) d dr\n                 n)) \\<Longrightarrow>\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n             (Suc n)) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n             (Suc n))", "finally"], ["proof (chain)\npicking this:\n  snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr (Suc n)) =\n  snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n        (Suc n))", "show ?case"], ["proof (prove)\nusing this:\n  snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr (Suc n)) =\n  snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n        (Suc n))\n\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr\n          (Suc n)) =\n    snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n          (Suc n))", "by auto"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr (Suc n)) =\n  snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ Suc n) r) d dr\n        (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>q q' r dr.\n       snd (pseudo_divmod_main (x * lc) q r (Polynomial.smult x d) dr 0) =\n       snd (pseudo_divmod_main lc q' (Polynomial.smult (x ^ 0) r) d dr 0)", "qed auto"], ["", "lemma snd_pseudo_mod_smult_invar_left:\n  shows \"snd (pseudo_divmod_main lc q (smult x r) d dr n)\n       = smult x (snd (pseudo_divmod_main lc q' r d dr n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr n) =\n    Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr n))", "proof(induct n arbitrary:x lc q q' r d dr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x lc q q' r d dr.\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr 0) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr 0))\n 2. \\<And>n x lc q q' r d dr.\n       (\\<And>x lc q q' r d dr.\n           snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr n) =\n           Polynomial.smult x\n            (snd (pseudo_divmod_main lc q' r d dr n))) \\<Longrightarrow>\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr (Suc n)) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr (Suc n)))", "case (Suc n)"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main ?lc ?q (Polynomial.smult ?x ?r) ?d ?dr n) =\n  Polynomial.smult ?x (snd (pseudo_divmod_main ?lc ?q' ?r ?d ?dr n))\n\ngoal (2 subgoals):\n 1. \\<And>x lc q q' r d dr.\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr 0) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr 0))\n 2. \\<And>n x lc q q' r d dr.\n       (\\<And>x lc q q' r d dr.\n           snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr n) =\n           Polynomial.smult x\n            (snd (pseudo_divmod_main lc q' r d dr n))) \\<Longrightarrow>\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr (Suc n)) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr (Suc n)))", "have sm:\"smult lc (smult x r) - monom (coeff (smult x r) dr) n * d\n          =smult x (smult lc r - monom (coeff r dr) n * d) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult lc (Polynomial.smult x r) -\n    monom (coeff (Polynomial.smult x r) dr) n * d =\n    Polynomial.smult x (Polynomial.smult lc r - monom (coeff r dr) n * d)", "by (auto simp:smult_diff_right smult_monom smult_monom_mult mult.commute[of lc x])"], ["proof (state)\nthis:\n  Polynomial.smult lc (Polynomial.smult x r) -\n  monom (coeff (Polynomial.smult x r) dr) n * d =\n  Polynomial.smult x (Polynomial.smult lc r - monom (coeff r dr) n * d)\n\ngoal (2 subgoals):\n 1. \\<And>x lc q q' r d dr.\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr 0) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr 0))\n 2. \\<And>n x lc q q' r d dr.\n       (\\<And>x lc q q' r d dr.\n           snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr n) =\n           Polynomial.smult x\n            (snd (pseudo_divmod_main lc q' r d dr n))) \\<Longrightarrow>\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr (Suc n)) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr (Suc n)))", "let ?q' = \"smult lc q' + monom (coeff r dr) n\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x lc q q' r d dr.\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr 0) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr 0))\n 2. \\<And>n x lc q q' r d dr.\n       (\\<And>x lc q q' r d dr.\n           snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr n) =\n           Polynomial.smult x\n            (snd (pseudo_divmod_main lc q' r d dr n))) \\<Longrightarrow>\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr (Suc n)) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr (Suc n)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr (Suc n)) =\n    Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr (Suc n)))", "unfolding pseudo_divmod_main.simps Let_def Suc(1)[of lc _ _ _ _ _ ?q'] sm"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult x\n     (snd (pseudo_divmod_main lc\n            (Polynomial.smult lc q' + monom (coeff r dr) n)\n            (Polynomial.smult lc r - monom (coeff r dr) n * d) d (dr - 1)\n            n)) =\n    Polynomial.smult x\n     (snd (pseudo_divmod_main lc\n            (Polynomial.smult lc q' + monom (coeff r dr) n)\n            (Polynomial.smult lc r - monom (coeff r dr) n * d) d (dr - 1)\n            n))", "by auto"], ["proof (state)\nthis:\n  snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr (Suc n)) =\n  Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<And>x lc q q' r d dr.\n       snd (pseudo_divmod_main lc q (Polynomial.smult x r) d dr 0) =\n       Polynomial.smult x (snd (pseudo_divmod_main lc q' r d dr 0))", "qed auto"], ["", "lemma snd_pseudo_mod_smult_left[simp]:\n  shows \"snd (pseudo_divmod (smult (x::'a::idom) p) q) = (smult x (snd (pseudo_divmod p q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (pseudo_divmod (Polynomial.smult x p) q) =\n    Polynomial.smult x (snd (pseudo_divmod p q))", "unfolding pseudo_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if q = 0 then (0, Polynomial.smult x p)\n         else pseudo_divmod_main (lead_coeff q) 0 (Polynomial.smult x p) q\n               (degree (Polynomial.smult x p))\n               (1 + length (coeffs (Polynomial.smult x p)) -\n                length (coeffs q))) =\n    Polynomial.smult x\n     (snd (if q = 0 then (0, p)\n           else pseudo_divmod_main (lead_coeff q) 0 p q (degree p)\n                 (1 + length (coeffs p) - length (coeffs q))))", "by (auto simp:snd_pseudo_mod_smult_invar_left[of _ _ _ _ _ _ _ 0] Polynomial.coeffs_smult)"], ["", "lemma pseudo_mod_smult_right:\n  assumes \"(x::'a::idom)\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"(pseudo_mod p (smult (x::'a::idom) q)) = (smult (x^(Suc (length (coeffs p)) - length (coeffs q))) (pseudo_mod p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod p (Polynomial.smult x q) =\n    Polynomial.smult (x ^ (Suc (length (coeffs p)) - length (coeffs q)))\n     (pseudo_mod p q)", "unfolding pseudo_divmod_def pseudo_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if Polynomial.smult x q = 0 then (0, p)\n         else pseudo_divmod_main (lead_coeff (Polynomial.smult x q)) 0 p\n               (Polynomial.smult x q) (degree p)\n               (1 + length (coeffs p) -\n                length (coeffs (Polynomial.smult x q)))) =\n    Polynomial.smult (x ^ (Suc (length (coeffs p)) - length (coeffs q)))\n     (snd (if q = 0 then (0, p)\n           else pseudo_divmod_main (lead_coeff q) 0 p q (degree p)\n                 (1 + length (coeffs p) - length (coeffs q))))", "by (auto simp:snd_pseudo_mod_smult_invar_right[of _ _ _ _ _ _ _ 0]\n                  snd_pseudo_mod_smult_invar_left[of _ _ _ _ _ _ _ 0] Polynomial.coeffs_smult assms)"], ["", "lemma pseudo_mod_zero[simp]:\n\"pseudo_mod 0 f = (0::'a :: {idom} poly)\"\n\"pseudo_mod f 0 = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod 0 f = 0 &&& pseudo_mod f 0 = f", "unfolding pseudo_mod_def snd_pseudo_mod_smult_left[of 0 _ f,simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0 &&& snd (pseudo_divmod f 0) = f", "unfolding pseudo_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0 &&&\n    snd (if 0 = 0 then (0, f)\n         else pseudo_divmod_main (lead_coeff 0) 0 f 0 (degree f)\n               (1 + length (coeffs f) - length (coeffs 0))) =\n    f", "by auto"], ["", "(* part on prod_list *)"], ["", "lemma prod_combine:\n  assumes \"j \\<le> i\"\n  shows \"f i * (\\<Prod>l\\<leftarrow>[j..<i]. (f l :: 'a::comm_monoid_mult)) = prod_list (map f [j..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i * prod_list (map f [j..<i]) = prod_list (map f [j..<Suc i])", "proof(subst prod_list_map_remove1[of i \"[j..<Suc i]\" f],goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> set [j..<Suc i]\n 2. f i * prod_list (map f [j..<i]) =\n    f i * prod_list (map f (remove1 i [j..<Suc i]))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. i \\<in> set [j..<Suc i]\n 2. f i * prod_list (map f [j..<i]) =\n    f i * prod_list (map f (remove1 i [j..<Suc i]))", "have \"remove1 i ([j..<i] @ [i]) = [j..<i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1 i ([j..<i] @ [i]) = [j..<i]", "by (simp add: remove1_append)"], ["proof (state)\nthis:\n  remove1 i ([j..<i] @ [i]) = [j..<i]\n\ngoal (2 subgoals):\n 1. i \\<in> set [j..<Suc i]\n 2. f i * prod_list (map f [j..<i]) =\n    f i * prod_list (map f (remove1 i [j..<Suc i]))", "thus ?case"], ["proof (prove)\nusing this:\n  remove1 i ([j..<i] @ [i]) = [j..<i]\n\ngoal (1 subgoal):\n 1. f i * prod_list (map f [j..<i]) =\n    f i * prod_list (map f (remove1 i [j..<Suc i]))", "by auto"], ["proof (state)\nthis:\n  f i * prod_list (map f [j..<i]) =\n  f i * prod_list (map f (remove1 i [j..<Suc i]))\n\ngoal (1 subgoal):\n 1. i \\<in> set [j..<Suc i]", "qed (insert assms, auto)"], ["", "lemma prod_list_minus_1_exp: \"prod_list (map (\\<lambda> i. (-1)^(f i)) xs)\n  = (-1)^(sum_list (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<leftarrow>xs. (- (1::'a)) ^ f i) =\n    (- (1::'a)) ^ sum_list (map f xs)", "by (induct xs, auto simp: power_add)"], ["", "lemma minus_1_power_even: \"(- (1 :: 'b :: comm_ring_1))^ k = (if even k then 1 else (-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'b)) ^ k = (if even k then 1::'b else - (1::'b))", "by auto"], ["", "lemma minus_1_even_eqI: assumes \"even k = even l\" shows\n    \"(- (1 :: 'b :: comm_ring_1))^k = (- 1)^l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'b)) ^ k = (- (1::'b)) ^ l", "unfolding minus_1_power_even assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even l then 1::'b else - (1::'b)) =\n    (if even l then 1::'b else - (1::'b))", "by auto"], ["", "lemma (in comm_monoid_mult) prod_list_multf:\n  \"(\\<Prod>x\\<leftarrow>xs. f x * g x) = prod_list (map f xs) * prod_list (map g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>xs. f x * g x) =\n    prod_list (map f xs) * prod_list (map g xs)", "by (induct xs) (simp_all add: algebra_simps)"], ["", "lemma inverse_prod_list: \"inverse (prod_list xs) = prod_list (map inverse (xs :: 'a :: field list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (prod_list xs) = prod_list (map inverse xs)", "by (induct xs, auto)"], ["", "(* part on pow_int, i.e., exponentiation with integer exponent *)"], ["", "definition pow_int :: \"'a :: field \\<Rightarrow> int \\<Rightarrow> 'a\" where\n  \"pow_int x e = (if e < 0 then 1 / (x ^ (nat (-e))) else x ^ (nat e))\""], ["", "lemma pow_int_0[simp]: \"pow_int x 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int x 0 = (1::'a)", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < 0 then (1::'a) / x ^ nat (- 0) else x ^ nat 0) = (1::'a)", "by auto"], ["", "lemma pow_int_1[simp]: \"pow_int x 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int x 1 = x", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 1 < 0 then (1::'a) / x ^ nat (- 1) else x ^ nat 1) = x", "by auto"], ["", "lemma exp_pow_int: \"x ^ n = pow_int x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ n = pow_int x (int n)", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ n =\n    (if int n < 0 then (1::'a) / x ^ nat (- int n) else x ^ nat (int n))", "by auto"], ["", "lemma pow_int_add: assumes x: \"x \\<noteq> 0\" shows \"pow_int x (a + b) = pow_int x a * pow_int x b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int x (a + b) = pow_int x a * pow_int x b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pow_int x (a + b) = pow_int x a * pow_int x b", "have *:\n    \"\\<not> a + b < 0 \\<Longrightarrow> a < 0 \\<Longrightarrow> nat b = nat (a + b) + nat (-a)\"\n    \"\\<not> a + b < 0 \\<Longrightarrow> b < 0 \\<Longrightarrow> nat a = nat (a + b) + nat (-b)\"\n    \"a + b < 0 \\<Longrightarrow> \\<not> a < 0 \\<Longrightarrow> nat (-b) = nat a + nat (-a -b) \"\n    \"a + b < 0 \\<Longrightarrow> \\<not> b < 0 \\<Longrightarrow> nat (-a) = nat b + nat (-a -b) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>\\<not> a + b < 0; a < 0\\<rbrakk>\n      \\<Longrightarrow> nat b = nat (a + b) + nat (- a)) &&&\n     (\\<lbrakk>\\<not> a + b < 0; b < 0\\<rbrakk>\n      \\<Longrightarrow> nat a = nat (a + b) + nat (- b))) &&&\n    (\\<lbrakk>a + b < 0; \\<not> a < 0\\<rbrakk>\n     \\<Longrightarrow> nat (- b) = nat a + nat (- a - b)) &&&\n    (\\<lbrakk>a + b < 0; \\<not> b < 0\\<rbrakk>\n     \\<Longrightarrow> nat (- a) = nat b + nat (- a - b))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a + b < 0; a < 0\\<rbrakk>\n  \\<Longrightarrow> nat b = nat (a + b) + nat (- a)\n  \\<lbrakk>\\<not> a + b < 0; b < 0\\<rbrakk>\n  \\<Longrightarrow> nat a = nat (a + b) + nat (- b)\n  \\<lbrakk>a + b < 0; \\<not> a < 0\\<rbrakk>\n  \\<Longrightarrow> nat (- b) = nat a + nat (- a - b)\n  \\<lbrakk>a + b < 0; \\<not> b < 0\\<rbrakk>\n  \\<Longrightarrow> nat (- a) = nat b + nat (- a - b)\n\ngoal (1 subgoal):\n 1. pow_int x (a + b) = pow_int x a * pow_int x b", "have pow_eq: \"l = m \\<Longrightarrow> (x ^ l = x ^ m)\" for l m"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = m \\<Longrightarrow> x ^ l = x ^ m", "by auto"], ["proof (state)\nthis:\n  ?l = ?m \\<Longrightarrow> x ^ ?l = x ^ ?m\n\ngoal (1 subgoal):\n 1. pow_int x (a + b) = pow_int x a * pow_int x b", "from x"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. pow_int x (a + b) = pow_int x a * pow_int x b", "unfolding pow_int_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (if a + b < 0 then (1::'a) / x ^ nat (- (a + b)) else x ^ nat (a + b)) =\n    (if a < 0 then (1::'a) / x ^ nat (- a) else x ^ nat a) *\n    (if b < 0 then (1::'a) / x ^ nat (- b) else x ^ nat b)", "by (auto split: if_splits simp: power_add[symmetric] simp: * intro!: pow_eq, auto simp: power_add)"], ["proof (state)\nthis:\n  pow_int x (a + b) = pow_int x a * pow_int x b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pow_int_mult: \"pow_int (x * y) a = pow_int x a * pow_int y a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (x * y) a = pow_int x a * pow_int y a", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a < 0 then (1::'a) / (x * y) ^ nat (- a) else (x * y) ^ nat a) =\n    (if a < 0 then (1::'a) / x ^ nat (- a) else x ^ nat a) *\n    (if a < 0 then (1::'a) / y ^ nat (- a) else y ^ nat a)", "by (cases \"a < 0\", auto simp: power_mult_distrib)"], ["", "lemma pow_int_base_1[simp]: \"pow_int 1 a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (1::'a) a = (1::'a)", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a < 0 then (1::'a) / (1::'a) ^ nat (- a) else (1::'a) ^ nat a) =\n    (1::'a)", "by (cases \"a < 0\", auto)"], ["", "lemma pow_int_divide: \"a / pow_int x b = a * pow_int x (-b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a / pow_int x b = a * pow_int x (- b)", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a / (if b < 0 then (1::'a) / x ^ nat (- b) else x ^ nat b) =\n    a * (if - b < 0 then (1::'a) / x ^ nat (- (- b)) else x ^ nat (- b))", "by (cases b rule: linorder_cases[of _ 0], auto)"], ["", "lemma divide_prod_assoc: \"x / (y * z :: 'a :: field) = x / y / z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / (y * z) = x / y / z", "by (simp add: field_simps)"], ["", "lemma minus_1_inverse_pow[simp]: \"x / (-1)^n = (x :: 'a :: field) * (-1)^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / (- (1::'a)) ^ n = x * (- (1::'a)) ^ n", "by (simp add: minus_1_power_even)"], ["", "(* part on subresultants *)"], ["", "definition subresultant_mat :: \"nat \\<Rightarrow> 'a :: comm_ring_1 poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly mat\" where\n  \"subresultant_mat J F G = (let\n     dg = degree G; df = degree F; f = coeff_int F; g = coeff_int G; n = (df - J) + (dg - J)\n     in mat n n (\\<lambda> (i,j). if j < dg - J then\n       if i = n - 1 then monom 1 (dg - J - 1 - j) * F else [: f (df - int i + int j) :]\n      else let jj = j - (dg - J) in\n       if i = n - 1 then monom 1 (df - J - 1 - jj) * G else [: g (dg - int i + int jj) :]))\""], ["", "lemma subresultant_mat_dim[simp]:\n  fixes j p q\n  defines \"S \\<equiv> subresultant_mat j p q\"\n  shows \"dim_row S = (degree p - j) + (degree q - j)\" and \"dim_col S = (degree p - j) + (degree q - j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row S = degree p - j + (degree q - j) &&&\n    dim_col S = degree p - j + (degree q - j)", "unfolding S_def subresultant_mat_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (degree p - j + (degree q - j)) (degree p - j + (degree q - j))\n       (\\<lambda>(i, ja).\n           if ja < degree q - j\n           then if i = degree p - j + (degree q - j) - 1\n                then monom (1::'a) (degree q - j - 1 - ja) * p\n                else [:coeff_int p (int (degree p) - int i + int ja):]\n           else if i = degree p - j + (degree q - j) - 1\n                then monom (1::'a)\n                      (degree p - j - 1 - (ja - (degree q - j))) *\n                     q\n                else [:coeff_int q\n                        (int (degree q) - int i +\n                         int (ja - (degree q - j))):])) =\n    degree p - j + (degree q - j) &&&\n    dim_col\n     (mat (degree p - j + (degree q - j)) (degree p - j + (degree q - j))\n       (\\<lambda>(i, ja).\n           if ja < degree q - j\n           then if i = degree p - j + (degree q - j) - 1\n                then monom (1::'a) (degree q - j - 1 - ja) * p\n                else [:coeff_int p (int (degree p) - int i + int ja):]\n           else if i = degree p - j + (degree q - j) - 1\n                then monom (1::'a)\n                      (degree p - j - 1 - (ja - (degree q - j))) *\n                     q\n                else [:coeff_int q\n                        (int (degree q) - int i +\n                         int (ja - (degree q - j))):])) =\n    degree p - j + (degree q - j)", "by auto"], ["", "definition subresultant'_mat :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a :: comm_ring_1 poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a mat\" where\n  \"subresultant'_mat J l F G = (let\n     \\<gamma> = degree G; \\<phi> = degree F; f = coeff_int F; g = coeff_int G; n = (\\<phi> - J) + (\\<gamma> - J)\n     in mat n n (\\<lambda> (i,j). if j < \\<gamma> - J then\n       if i = n - 1 then (f (l - int (\\<gamma> - J - 1) + int j)) else (f (\\<phi> - int i + int j))\n      else let jj = j - (\\<gamma> - J) in\n       if i = n - 1 then (g (l - int (\\<phi> - J - 1) + int jj)) else (g (\\<gamma> - int i + int jj))))\""], ["", "lemma subresultant_index_mat:\n  fixes F G\n  assumes i: \"i < (degree F - J) + (degree G - J)\" and j: \"j < (degree F - J) + (degree G - J)\"\n  shows \"subresultant_mat J F G $$ (i,j) =\n    (if j < degree G - J then\n       if i = (degree F - J) + (degree G - J) - 1 then monom 1 (degree G - J - 1 - j) * F else ([: coeff_int F ( degree F - int i + int j) :])\n      else let jj = j - (degree G - J) in\n       if i = (degree F - J) + (degree G - J) - 1 then monom 1 ( degree F - J - 1 - jj) * G else ([: coeff_int G (degree G - int i + int jj) :]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_mat J F G $$ (i, j) =\n    (if j < degree G - J\n     then if i = degree F - J + (degree G - J) - 1\n          then monom (1::'a) (degree G - J - 1 - j) * F\n          else [:coeff_int F (int (degree F) - int i + int j):]\n     else let jj = j - (degree G - J)\n          in if i = degree F - J + (degree G - J) - 1\n             then monom (1::'a) (degree F - J - 1 - jj) * G\n             else [:coeff_int G (int (degree G) - int i + int jj):])", "unfolding subresultant_mat_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (degree F - J + (degree G - J)) (degree F - J + (degree G - J))\n     (\\<lambda>(i, j).\n         if j < degree G - J\n         then if i = degree F - J + (degree G - J) - 1\n              then monom (1::'a) (degree G - J - 1 - j) * F\n              else [:coeff_int F (int (degree F) - int i + int j):]\n         else if i = degree F - J + (degree G - J) - 1\n              then monom (1::'a) (degree F - J - 1 - (j - (degree G - J))) *\n                   G\n              else [:coeff_int G\n                      (int (degree G) - int i +\n                       int (j - (degree G - J))):]) $$\n    (i, j) =\n    (if j < degree G - J\n     then if i = degree F - J + (degree G - J) - 1\n          then monom (1::'a) (degree G - J - 1 - j) * F\n          else [:coeff_int F (int (degree F) - int i + int j):]\n     else if i = degree F - J + (degree G - J) - 1\n          then monom (1::'a) (degree F - J - 1 - (j - (degree G - J))) * G\n          else [:coeff_int G\n                  (int (degree G) - int i + int (j - (degree G - J))):])", "unfolding index_mat(1)[OF i j] split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < degree G - J\n     then if i = degree F - J + (degree G - J) - 1\n          then monom (1::'a) (degree G - J - 1 - j) * F\n          else [:coeff_int F (int (degree F) - int i + int j):]\n     else if i = degree F - J + (degree G - J) - 1\n          then monom (1::'a) (degree F - J - 1 - (j - (degree G - J))) * G\n          else [:coeff_int G\n                  (int (degree G) - int i + int (j - (degree G - J))):]) =\n    (if j < degree G - J\n     then if i = degree F - J + (degree G - J) - 1\n          then monom (1::'a) (degree G - J - 1 - j) * F\n          else [:coeff_int F (int (degree F) - int i + int j):]\n     else if i = degree F - J + (degree G - J) - 1\n          then monom (1::'a) (degree F - J - 1 - (j - (degree G - J))) * G\n          else [:coeff_int G\n                  (int (degree G) - int i + int (j - (degree G - J))):])", "by auto"], ["", "definition subresultant :: \"nat \\<Rightarrow> 'a :: comm_ring_1 poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\" where\n  \"subresultant J F G = det (subresultant_mat J F G)\""], ["", "lemma subresultant_smult_left: assumes \"(c :: 'a :: {comm_ring_1, semiring_no_zero_divisors}) \\<noteq> 0\"\n  shows \"subresultant J (smult c f) g = smult (c ^ (degree g - J)) (subresultant J f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "let ?df = \"degree f\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "let ?dg = \"degree g\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "let ?n = \"(?df - J) + (?dg - J)\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "let ?m = \"?dg - J\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "let ?M = \"mat ?n ?n (\\<lambda> (i,j). if i = j then if i < ?m then [:c:] else 1 else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "from \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "have deg: \"degree (smult c f) = ?df\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult c f) = degree f", "by simp"], ["proof (state)\nthis:\n  degree (Polynomial.smult c f) = degree f\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "let ?S = \"subresultant_mat J f g\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "let ?cS = \"subresultant_mat J (smult c f) g\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "have dim: \"dim_row ?S = ?n\" \"dim_col ?S = ?n\"  \"dim_row ?cS = ?n\" \"dim_col ?cS = ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dim_row (subresultant_mat J f g) = degree f - J + (degree g - J) &&&\n     dim_col (subresultant_mat J f g) = degree f - J + (degree g - J)) &&&\n    dim_row (subresultant_mat J (Polynomial.smult c f) g) =\n    degree f - J + (degree g - J) &&&\n    dim_col (subresultant_mat J (Polynomial.smult c f) g) =\n    degree f - J + (degree g - J)", "using deg"], ["proof (prove)\nusing this:\n  degree (Polynomial.smult c f) = degree f\n\ngoal (1 subgoal):\n 1. (dim_row (subresultant_mat J f g) = degree f - J + (degree g - J) &&&\n     dim_col (subresultant_mat J f g) = degree f - J + (degree g - J)) &&&\n    dim_row (subresultant_mat J (Polynomial.smult c f) g) =\n    degree f - J + (degree g - J) &&&\n    dim_col (subresultant_mat J (Polynomial.smult c f) g) =\n    degree f - J + (degree g - J)", "by auto"], ["proof (state)\nthis:\n  dim_row (subresultant_mat J f g) = degree f - J + (degree g - J)\n  dim_col (subresultant_mat J f g) = degree f - J + (degree g - J)\n  dim_row (subresultant_mat J (Polynomial.smult c f) g) =\n  degree f - J + (degree g - J)\n  dim_col (subresultant_mat J (Polynomial.smult c f) g) =\n  degree f - J + (degree g - J)\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "hence C: \"?S \\<in> carrier_mat ?n ?n\" \"?cS \\<in> carrier_mat ?n ?n\" \"?M \\<in> carrier_mat ?n ?n\""], ["proof (prove)\nusing this:\n  dim_row (subresultant_mat J f g) = degree f - J + (degree g - J)\n  dim_col (subresultant_mat J f g) = degree f - J + (degree g - J)\n  dim_row (subresultant_mat J (Polynomial.smult c f) g) =\n  degree f - J + (degree g - J)\n  dim_col (subresultant_mat J (Polynomial.smult c f) g) =\n  degree f - J + (degree g - J)\n\ngoal (1 subgoal):\n 1. subresultant_mat J f g\n    \\<in> carrier_mat (degree f - J + (degree g - J))\n           (degree f - J + (degree g - J)) &&&\n    subresultant_mat J (Polynomial.smult c f) g\n    \\<in> carrier_mat (degree f - J + (degree g - J))\n           (degree f - J + (degree g - J)) &&&\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0)\n    \\<in> carrier_mat (degree f - J + (degree g - J))\n           (degree f - J + (degree g - J))", "by auto"], ["proof (state)\nthis:\n  subresultant_mat J f g\n  \\<in> carrier_mat (degree f - J + (degree g - J))\n         (degree f - J + (degree g - J))\n  subresultant_mat J (Polynomial.smult c f) g\n  \\<in> carrier_mat (degree f - J + (degree g - J))\n         (degree f - J + (degree g - J))\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0)\n  \\<in> carrier_mat (degree f - J + (degree g - J))\n         (degree f - J + (degree g - J))\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "have dim': \"dim_row (?S * ?M) = ?n\" \"dim_col (?S * ?M) = ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (subresultant_mat J f g *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n    degree f - J + (degree g - J) &&&\n    dim_col\n     (subresultant_mat J f g *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n    degree f - J + (degree g - J)", "using dim (1,2)"], ["proof (prove)\nusing this:\n  dim_row (subresultant_mat J f g) = degree f - J + (degree g - J)\n  dim_col (subresultant_mat J f g) = degree f - J + (degree g - J)\n\ngoal (1 subgoal):\n 1. dim_row\n     (subresultant_mat J f g *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n    degree f - J + (degree g - J) &&&\n    dim_col\n     (subresultant_mat J f g *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n    degree f - J + (degree g - J)", "by simp_all"], ["proof (state)\nthis:\n  dim_row\n   (subresultant_mat J f g *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n  degree f - J + (degree g - J)\n  dim_col\n   (subresultant_mat J f g *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n  degree f - J + (degree g - J)\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "define S where \"S = ?S\""], ["proof (state)\nthis:\n  S = subresultant_mat J f g\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "have \"?cS = ?S * ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_mat J (Polynomial.smult c f) g =\n    subresultant_mat J f g *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0)", "proof (rule eq_matI, unfold dim' dim)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "assume ij: \"i < ?n\" \"j < ?n\""], ["proof (state)\nthis:\n  i < degree f - J + (degree g - J)\n  j < degree f - J + (degree g - J)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "have \"(?S * ?M) $$ (i,j) = row ?S i \\<bullet> col ?M j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subresultant_mat J f g *\n     mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n      (\\<lambda>(i, j).\n          if i = j then if i < degree g - J then [:c:] else 1 else 0)) $$\n    (i, j) =\n    row (subresultant_mat J f g) i \\<bullet>\n    col (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              if i = j then if i < degree g - J then [:c:] else 1 else 0))\n     j", "by (rule index_mult_mat, insert ij dim, auto)"], ["proof (state)\nthis:\n  (subresultant_mat J f g *\n   mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n    (\\<lambda>(i, j).\n        if i = j then if i < degree g - J then [:c:] else 1 else 0)) $$\n  (i, j) =\n  row (subresultant_mat J f g) i \\<bullet>\n  col (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n   j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "also"], ["proof (state)\nthis:\n  (subresultant_mat J f g *\n   mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n    (\\<lambda>(i, j).\n        if i = j then if i < degree g - J then [:c:] else 1 else 0)) $$\n  (i, j) =\n  row (subresultant_mat J f g) i \\<bullet>\n  col (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n   j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "have \"\\<dots> = (\\<Sum>k = 0..<?n. row S i $ k * col ?M j $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (subresultant_mat J f g) i \\<bullet>\n    col (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              if i = j then if i < degree g - J then [:c:] else 1 else 0))\n     j =\n    (\\<Sum>k = 0..<degree f - J + (degree g - J).\n        row S i $ k *\n        col (mat (degree f - J + (degree g - J))\n              (degree f - J + (degree g - J))\n              (\\<lambda>(i, j).\n                  if i = j then if i < degree g - J then [:c:] else 1\n                  else 0))\n         j $\n        k)", "unfolding scalar_prod_def S_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec\n                     (col (mat (degree f - J + (degree g - J))\n                            (degree f - J + (degree g - J))\n                            (\\<lambda>(i, j).\n                                if i = j\n                                then if i < degree g - J then [:c:] else 1\n                                else 0))\n                       j).\n        row S i $ ia *\n        col (mat (degree f - J + (degree g - J))\n              (degree f - J + (degree g - J))\n              (\\<lambda>(i, j).\n                  if i = j then if i < degree g - J then [:c:] else 1\n                  else 0))\n         j $\n        ia) =\n    (\\<Sum>k = 0..<degree f - J + (degree g - J).\n        row S i $ k *\n        col (mat (degree f - J + (degree g - J))\n              (degree f - J + (degree g - J))\n              (\\<lambda>(i, j).\n                  if i = j then if i < degree g - J then [:c:] else 1\n                  else 0))\n         j $\n        k)", "by simp"], ["proof (state)\nthis:\n  row (subresultant_mat J f g) i \\<bullet>\n  col (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n   j =\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      row S i $ k *\n      col (mat (degree f - J + (degree g - J))\n            (degree f - J + (degree g - J))\n            (\\<lambda>(i, j).\n                if i = j then if i < degree g - J then [:c:] else 1 else 0))\n       j $\n      k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "also"], ["proof (state)\nthis:\n  row (subresultant_mat J f g) i \\<bullet>\n  col (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n   j =\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      row S i $ k *\n      col (mat (degree f - J + (degree g - J))\n            (degree f - J + (degree g - J))\n            (\\<lambda>(i, j).\n                if i = j then if i < degree g - J then [:c:] else 1 else 0))\n       j $\n      k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "have \"\\<dots> = (\\<Sum>k = 0..<?n. S $$ (i,k) * ?M $$ (k,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<degree f - J + (degree g - J).\n        row S i $ k *\n        col (mat (degree f - J + (degree g - J))\n              (degree f - J + (degree g - J))\n              (\\<lambda>(i, j).\n                  if i = j then if i < degree g - J then [:c:] else 1\n                  else 0))\n         j $\n        k) =\n    (\\<Sum>k = 0..<degree f - J + (degree g - J).\n        S $$ (i, k) *\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, j))", "by (rule sum.cong, insert ij, auto simp: S_def)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      row S i $ k *\n      col (mat (degree f - J + (degree g - J))\n            (degree f - J + (degree g - J))\n            (\\<lambda>(i, j).\n                if i = j then if i < degree g - J then [:c:] else 1 else 0))\n       j $\n      k) =\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      S $$ (i, k) *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, j))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      row S i $ k *\n      col (mat (degree f - J + (degree g - J))\n            (degree f - J + (degree g - J))\n            (\\<lambda>(i, j).\n                if i = j then if i < degree g - J then [:c:] else 1 else 0))\n       j $\n      k) =\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      S $$ (i, k) *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, j))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "have \"\\<dots> = S $$ (i,j) * ?M $$ (j,j) + sum (\\<lambda> k. S $$ (i,k) * ?M $$ (k,j)) ({0..<?n} - {j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<degree f - J + (degree g - J).\n        S $$ (i, k) *\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, j)) =\n    S $$ (i, j) *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n    (j, j) +\n    (\\<Sum>k\\<in>{0..<degree f - J + (degree g - J)} - {j}.\n       S $$ (i, k) *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n       (k, j))", "by (rule sum.remove, insert ij, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      S $$ (i, k) *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, j)) =\n  S $$ (i, j) *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n  (j, j) +\n  (\\<Sum>k\\<in>{0..<degree f - J + (degree g - J)} - {j}.\n     S $$ (i, k) *\n     mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n      (\\<lambda>(i, j).\n          if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n     (k, j))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<degree f - J + (degree g - J).\n      S $$ (i, k) *\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, j)) =\n  S $$ (i, j) *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n  (j, j) +\n  (\\<Sum>k\\<in>{0..<degree f - J + (degree g - J)} - {j}.\n     S $$ (i, k) *\n     mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n      (\\<lambda>(i, j).\n          if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n     (k, j))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "have \"\\<dots> = S $$ (i,j) * ?M $$ (j,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S $$ (i, j) *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n    (j, j) +\n    (\\<Sum>k\\<in>{0..<degree f - J + (degree g - J)} - {j}.\n       S $$ (i, k) *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n       (k, j)) =\n    S $$ (i, j) *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n    (j, j)", "by (subst sum.neutral, insert ij, auto)"], ["proof (state)\nthis:\n  S $$ (i, j) *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n  (j, j) +\n  (\\<Sum>k\\<in>{0..<degree f - J + (degree g - J)} - {j}.\n     S $$ (i, k) *\n     mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n      (\\<lambda>(i, j).\n          if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n     (k, j)) =\n  S $$ (i, j) *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n  (j, j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "also"], ["proof (state)\nthis:\n  S $$ (i, j) *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n  (j, j) +\n  (\\<Sum>k\\<in>{0..<degree f - J + (degree g - J)} - {j}.\n     S $$ (i, k) *\n     mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n      (\\<lambda>(i, j).\n          if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n     (k, j)) =\n  S $$ (i, j) *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n  (j, j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "have \"\\<dots> = ?cS $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S $$ (i, j) *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n    (j, j) =\n    subresultant_mat J (Polynomial.smult c f) g $$ (i, j)", "unfolding subresultant_index_mat[OF ij] S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < degree g - J\n     then if i = degree f - J + (degree g - J) - 1\n          then monom (1::'a) (degree g - J - 1 - j) * f\n          else [:coeff_int f (int (degree f) - int i + int j):]\n     else let jj = j - (degree g - J)\n          in if i = degree f - J + (degree g - J) - 1\n             then monom (1::'a) (degree f - J - 1 - jj) * g\n             else [:coeff_int g (int (degree g) - int i + int jj):]) *\n    mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n    (j, j) =\n    subresultant_mat J (Polynomial.smult c f) g $$ (i, j)", "by (subst subresultant_index_mat, unfold deg, insert ij, auto)"], ["proof (state)\nthis:\n  S $$ (i, j) *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n  (j, j) =\n  subresultant_mat J (Polynomial.smult c f) g $$ (i, j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < degree f - J + (degree g - J);\n        j < degree f - J + (degree g - J)\\<rbrakk>\n       \\<Longrightarrow> subresultant_mat J (Polynomial.smult c f) g $$\n                         (i, j) =\n                         (subresultant_mat J f g *\n                          mat (degree f - J + (degree g - J))\n                           (degree f - J + (degree g - J))\n                           (\\<lambda>(i, j).\n                               if i = j\n                               then if i < degree g - J then [:c:] else 1\n                               else 0)) $$\n                         (i, j)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 3. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "finally"], ["proof (chain)\npicking this:\n  (subresultant_mat J f g *\n   mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n    (\\<lambda>(i, j).\n        if i = j then if i < degree g - J then [:c:] else 1 else 0)) $$\n  (i, j) =\n  subresultant_mat J (Polynomial.smult c f) g $$ (i, j)", "show \"?cS $$ (i,j) = (?S * ?M) $$ (i,j)\""], ["proof (prove)\nusing this:\n  (subresultant_mat J f g *\n   mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n    (\\<lambda>(i, j).\n        if i = j then if i < degree g - J then [:c:] else 1 else 0)) $$\n  (i, j) =\n  subresultant_mat J (Polynomial.smult c f) g $$ (i, j)\n\ngoal (1 subgoal):\n 1. subresultant_mat J (Polynomial.smult c f) g $$ (i, j) =\n    (subresultant_mat J f g *\n     mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n      (\\<lambda>(i, j).\n          if i = j then if i < degree g - J then [:c:] else 1 else 0)) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  subresultant_mat J (Polynomial.smult c f) g $$ (i, j) =\n  (subresultant_mat J f g *\n   mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n    (\\<lambda>(i, j).\n        if i = j then if i < degree g - J then [:c:] else 1 else 0)) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. degree f - J + (degree g - J) = degree f - J + (degree g - J)\n 2. degree f - J + (degree g - J) = degree f - J + (degree g - J)", "qed auto"], ["proof (state)\nthis:\n  subresultant_mat J (Polynomial.smult c f) g =\n  subresultant_mat J f g *\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       if i = j then if i < degree g - J then [:c:] else 1 else 0)\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "from arg_cong[OF this, of det] det_mult[OF C(1) C(3)]"], ["proof (chain)\npicking this:\n  det (subresultant_mat J (Polynomial.smult c f) g) =\n  det (subresultant_mat J f g *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n  det (subresultant_mat J f g *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n  det (subresultant_mat J f g) *\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))", "have \"subresultant J (smult c f) g = subresultant J f g * det ?M\""], ["proof (prove)\nusing this:\n  det (subresultant_mat J (Polynomial.smult c f) g) =\n  det (subresultant_mat J f g *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n  det (subresultant_mat J f g *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n  det (subresultant_mat J f g) *\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    subresultant J f g *\n    det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              if i = j then if i < degree g - J then [:c:] else 1 else 0))", "unfolding subresultant_def"], ["proof (prove)\nusing this:\n  det (subresultant_mat J (Polynomial.smult c f) g) =\n  det (subresultant_mat J f g *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n  det (subresultant_mat J f g *\n       mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n  det (subresultant_mat J f g) *\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n\ngoal (1 subgoal):\n 1. det (subresultant_mat J (Polynomial.smult c f) g) =\n    det (subresultant_mat J f g) *\n    det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              if i = j then if i < degree g - J then [:c:] else 1 else 0))", "by auto"], ["proof (state)\nthis:\n  subresultant J (Polynomial.smult c f) g =\n  subresultant J f g *\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "also"], ["proof (state)\nthis:\n  subresultant J (Polynomial.smult c f) g =\n  subresultant J f g *\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0))\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "have \"det ?M = [:c ^ ?m :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n    [:c ^ (degree g - J):]", "proof (subst det_upper_triangular[OF _ C(3)])"], ["proof (state)\ngoal (2 subgoals):\n 1. upper_triangular\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0))\n 2. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "show \"upper_triangular ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0))", "by (rule upper_triangularI, auto)"], ["proof (state)\nthis:\n  upper_triangular\n   (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if i = j then if i < degree g - J then [:c:] else 1 else 0))\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "have \"prod_list (diag_mat ?M) = (\\<Prod>k = 0..<?n. (?M $$ (k,k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    (\\<Prod>k = 0..<degree f - J + (degree g - J).\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, k))", "unfolding prod_list_diag_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_row\n                     (mat (degree f - J + (degree g - J))\n                       (degree f - J + (degree g - J))\n                       (\\<lambda>(i, j).\n                           if i = j\n                           then if i < degree g - J then [:c:] else 1\n                           else 0)).\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (i, i)) =\n    (\\<Prod>k = 0..<degree f - J + (degree g - J).\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, k))", "by simp"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n  (\\<Prod>k = 0..<degree f - J + (degree g - J).\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k))\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "also"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n  (\\<Prod>k = 0..<degree f - J + (degree g - J).\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k))\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "have \"\\<dots> = (\\<Prod>k = 0..<?m. ?M $$ (k,k)) * (\\<Prod>k = ?m..<?n. ?M $$ (k,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k = 0..<degree f - J + (degree g - J).\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, k)) =\n    (\\<Prod>k = 0..<degree g - J.\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, k)) *\n    (\\<Prod>k = degree g - J..<degree f - J + (degree g - J).\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, k))", "by (subst prod.union_disjoint[symmetric], (auto)[3], rule prod.cong, auto)"], ["proof (state)\nthis:\n  (\\<Prod>k = 0..<degree f - J + (degree g - J).\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k)) =\n  (\\<Prod>k = 0..<degree g - J.\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k)) *\n  (\\<Prod>k = degree g - J..<degree f - J + (degree g - J).\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k))\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "also"], ["proof (state)\nthis:\n  (\\<Prod>k = 0..<degree f - J + (degree g - J).\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k)) =\n  (\\<Prod>k = 0..<degree g - J.\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k)) *\n  (\\<Prod>k = degree g - J..<degree f - J + (degree g - J).\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k))\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "have \"(\\<Prod>k = 0..<?m. ?M $$ (k,k)) = (\\<Prod>k = 0..<?m. [: c :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k = 0..<degree g - J.\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, k)) =\n    (\\<Prod>k = 0..<degree g - J. [:c:])", "by (rule prod.cong, auto)"], ["proof (state)\nthis:\n  (\\<Prod>k = 0..<degree g - J.\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k)) =\n  (\\<Prod>k = 0..<degree g - J. [:c:])\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "also"], ["proof (state)\nthis:\n  (\\<Prod>k = 0..<degree g - J.\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k)) =\n  (\\<Prod>k = 0..<degree g - J. [:c:])\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "have \"(\\<Prod>k = 0..<?m. [: c :]) = [: c :] ^ ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k = 0..<degree g - J. [:c:]) = [:c:] ^ (degree g - J)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>k = 0..<degree g - J. [:c:]) = [:c:] ^ (degree g - J)\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "also"], ["proof (state)\nthis:\n  (\\<Prod>k = 0..<degree g - J. [:c:]) = [:c:] ^ (degree g - J)\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "have \"(\\<Prod>k = ?m..<?n. ?M $$ (k,k)) = (\\<Prod>k = ?m..<?n. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k = degree g - J..<degree f - J + (degree g - J).\n        mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n        (k, k)) =\n    (\\<Prod>k = degree g - J..<degree f - J + (degree g - J). 1)", "by (rule prod.cong, auto)"], ["proof (state)\nthis:\n  (\\<Prod>k = degree g - J..<degree f - J + (degree g - J).\n      mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0) $$\n      (k, k)) =\n  (\\<Prod>k = degree g - J..<degree f - J + (degree g - J). 1)\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "finally"], ["proof (chain)\npicking this:\n  prod_list\n   (diag_mat\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>a.\n           case a of\n           (i, j) \\<Rightarrow>\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n  [:c:] ^ (degree g - J) *\n  (\\<Prod>k = degree g - J..<degree f - J + (degree g - J). 1)", "show \"prod_list (diag_mat ?M) = [: c^?m :]\""], ["proof (prove)\nusing this:\n  prod_list\n   (diag_mat\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>a.\n           case a of\n           (i, j) \\<Rightarrow>\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n  [:c:] ^ (degree g - J) *\n  (\\<Prod>k = degree g - J..<degree f - J + (degree g - J). 1)\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "unfolding poly_const_pow"], ["proof (prove)\nusing this:\n  prod_list\n   (diag_mat\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>a.\n           case a of\n           (i, j) \\<Rightarrow>\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n  [:c ^ (degree g - J):] *\n  (\\<Prod>k = degree g - J..<degree f - J + (degree g - J). 1)\n\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n         (\\<lambda>(i, j).\n             if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n    [:c ^ (degree g - J):]", "by simp"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n       (\\<lambda>(i, j).\n           if i = j then if i < degree g - J then [:c:] else 1 else 0))) =\n  [:c ^ (degree g - J):]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            if i = j then if i < degree g - J then [:c:] else 1 else 0)) =\n  [:c ^ (degree g - J):]\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "finally"], ["proof (chain)\npicking this:\n  subresultant J (Polynomial.smult c f) g =\n  subresultant J f g * [:c ^ (degree g - J):]", "show ?thesis"], ["proof (prove)\nusing this:\n  subresultant J (Polynomial.smult c f) g =\n  subresultant J f g * [:c ^ (degree g - J):]\n\ngoal (1 subgoal):\n 1. subresultant J (Polynomial.smult c f) g =\n    Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)", "by simp"], ["proof (state)\nthis:\n  subresultant J (Polynomial.smult c f) g =\n  Polynomial.smult (c ^ (degree g - J)) (subresultant J f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subresultant_swap:\n  shows \"subresultant J f g = smult ((- 1) ^ ((degree f - J) * (degree g - J))) (subresultant J g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "let ?A = \"subresultant_mat J f g\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "let ?k = \"degree f - J\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "let ?n = \"degree g - J\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have nk: \"?n + ?k = ?k + ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g - J + (degree f - J) = degree f - J + (degree g - J)", "by simp"], ["proof (state)\nthis:\n  degree g - J + (degree f - J) = degree f - J + (degree g - J)\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have change: \"j < ?k + ?n \\<Longrightarrow> ((if j < ?k then j + ?n else j - ?k) < ?n)\n    = (\\<not> (j < ?k))\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < degree f - J + (degree g - J) \\<Longrightarrow>\n    ((if j < degree f - J then j + (degree g - J) else j - (degree f - J))\n     < degree g - J) =\n    (\\<not> j < degree f - J)", "by auto"], ["proof (state)\nthis:\n  ?j < degree f - J + (degree g - J) \\<Longrightarrow>\n  ((if ?j < degree f - J then ?j + (degree g - J) else ?j - (degree f - J))\n   < degree g - J) =\n  (\\<not> ?j < degree f - J)\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have \"subresultant J f g = det ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J f g = det (subresultant_mat J f g)", "unfolding subresultant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant_mat J f g) = det (subresultant_mat J f g)", "by simp"], ["proof (state)\nthis:\n  subresultant J f g = det (subresultant_mat J f g)\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "also"], ["proof (state)\nthis:\n  subresultant J f g = det (subresultant_mat J f g)\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have \"\\<dots> = (-1)^(?k * ?n) * det (mat (?k + ?n) (?k + ?n) (\\<lambda> (i,j).\n    ?A $$ (i,(if j < ?k then j + ?n else j - ?k))))\" (is \"_ = _ * det ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant_mat J f g) =\n    (- 1) ^ ((degree f - J) * (degree g - J)) *\n    det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              subresultant_mat J f g $$\n              (i, if j < degree f - J then j + (degree g - J)\n                  else j - (degree f - J))))", "by (rule det_swap_cols, auto simp: subresultant_mat_def Let_def)"], ["proof (state)\nthis:\n  det (subresultant_mat J f g) =\n  (- 1) ^ ((degree f - J) * (degree g - J)) *\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            subresultant_mat J f g $$\n            (i, if j < degree f - J then j + (degree g - J)\n                else j - (degree f - J))))\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "also"], ["proof (state)\nthis:\n  det (subresultant_mat J f g) =\n  (- 1) ^ ((degree f - J) * (degree g - J)) *\n  det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n        (\\<lambda>(i, j).\n            subresultant_mat J f g $$\n            (i, if j < degree f - J then j + (degree g - J)\n                else j - (degree f - J))))\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have \"?B = subresultant_mat J g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         subresultant_mat J f g $$\n         (i, if j < degree f - J then j + (degree g - J)\n             else j - (degree f - J))) =\n    subresultant_mat J g f", "unfolding subresultant_mat_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              if j < degree g - J\n              then if i = degree f - J + (degree g - J) - 1\n                   then monom (1::'a) (degree g - J - 1 - j) * f\n                   else [:coeff_int f (int (degree f) - int i + int j):]\n              else if i = degree f - J + (degree g - J) - 1\n                   then monom (1::'a)\n                         (degree f - J - 1 - (j - (degree g - J))) *\n                        g\n                   else [:coeff_int g\n                           (int (degree g) - int i +\n                            int (j - (degree g - J))):]) $$\n         (i, if j < degree f - J then j + (degree g - J)\n             else j - (degree f - J))) =\n    mat (degree g - J + (degree f - J)) (degree g - J + (degree f - J))\n     (\\<lambda>(i, j).\n         if j < degree f - J\n         then if i = degree g - J + (degree f - J) - 1\n              then monom (1::'a) (degree f - J - 1 - j) * g\n              else [:coeff_int g (int (degree g) - int i + int j):]\n         else if i = degree g - J + (degree f - J) - 1\n              then monom (1::'a) (degree g - J - 1 - (j - (degree f - J))) *\n                   f\n              else [:coeff_int f\n                      (int (degree f) - int i + int (j - (degree f - J))):])", "by (rule eq_matI, unfold dim_row_mat dim_col_mat nk index_mat split,\n      subst index_mat, (auto)[2], unfold split, subst change, force,\n      unfold if_conn, rule if_cong[OF refl if_cong if_cong], auto)"], ["proof (state)\nthis:\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       subresultant_mat J f g $$\n       (i, if j < degree f - J then j + (degree g - J)\n           else j - (degree f - J))) =\n  subresultant_mat J g f\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "also"], ["proof (state)\nthis:\n  mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n   (\\<lambda>(i, j).\n       subresultant_mat J f g $$\n       (i, if j < degree f - J then j + (degree g - J)\n           else j - (degree f - J))) =\n  subresultant_mat J g f\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have \"det \\<dots> = subresultant J g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant_mat J g f) = subresultant J g f", "unfolding subresultant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant_mat J g f) = det (subresultant_mat J g f)", ".."], ["proof (state)\nthis:\n  det (subresultant_mat J g f) = subresultant J g f\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "also"], ["proof (state)\nthis:\n  det (subresultant_mat J g f) = subresultant J g f\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have \"(-1)^(?k * ?n) * \\<dots> = [: (-1)^(?k * ?n) :] * \\<dots> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ ((degree f - J) * (degree g - J)) * subresultant J g f =\n    [:(- (1::'a)) ^ ((degree f - J) * (degree g - J)):] * subresultant J g f", "by (unfold hom_distribs, simp)"], ["proof (state)\nthis:\n  (- 1) ^ ((degree f - J) * (degree g - J)) * subresultant J g f =\n  [:(- (1::'a)) ^ ((degree f - J) * (degree g - J)):] * subresultant J g f\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "also"], ["proof (state)\nthis:\n  (- 1) ^ ((degree f - J) * (degree g - J)) * subresultant J g f =\n  [:(- (1::'a)) ^ ((degree f - J) * (degree g - J)):] * subresultant J g f\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "have \"\\<dots> = smult ((-1)^(?k * ?n)) (subresultant J g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:(- (1::'a)) ^ ((degree f - J) * (degree g - J)):] *\n    subresultant J g f =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "by simp"], ["proof (state)\nthis:\n  [:(- (1::'a)) ^ ((degree f - J) * (degree g - J)):] * subresultant J g f =\n  Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n   (subresultant J g f)\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "finally"], ["proof (chain)\npicking this:\n  subresultant J f g =\n  Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n   (subresultant J g f)", "show ?thesis"], ["proof (prove)\nusing this:\n  subresultant J f g =\n  Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n   (subresultant J g f)\n\ngoal (1 subgoal):\n 1. subresultant J f g =\n    Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n     (subresultant J g f)", "."], ["proof (state)\nthis:\n  subresultant J f g =\n  Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n   (subresultant J g f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subresultant_smult_right:assumes \"(c :: 'a :: {comm_ring_1, semiring_no_zero_divisors}) \\<noteq> 0\"\n  shows \"subresultant J f (smult c g) = smult (c ^ (degree f - J)) (subresultant J f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J f (Polynomial.smult c g) =\n    Polynomial.smult (c ^ (degree f - J)) (subresultant J f g)", "unfolding subresultant_swap[of _ f] subresultant_smult_left[OF assms]\n    degree_smult_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- (1::'a)) ^\n      ((degree f - J) * ((if c = (0::'a) then 0 else degree g) - J)))\n     (Polynomial.smult (c ^ (degree f - J)) (subresultant J g f)) =\n    Polynomial.smult (c ^ (degree f - J))\n     (Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n       (subresultant J g f))", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- (1::'a)) ^\n      ((degree f - J) * ((if c = (0::'a) then 0 else degree g) - J)))\n     (Polynomial.smult (c ^ (degree f - J)) (subresultant J g f)) =\n    Polynomial.smult (c ^ (degree f - J))\n     (Polynomial.smult ((- (1::'a)) ^ ((degree f - J) * (degree g - J)))\n       (subresultant J g f))", "by (simp add: ac_simps)"], ["", "lemma coeff_subresultant: \"coeff (subresultant J F G) l =\n  (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0 else det (subresultant'_mat J l F G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "proof (cases \"degree F - J + (degree G - J) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree F - J + (degree G - J) = 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))\n 2. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "case True"], ["proof (state)\nthis:\n  degree F - J + (degree G - J) = 0\n\ngoal (2 subgoals):\n 1. degree F - J + (degree G - J) = 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))\n 2. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "unfolding subresultant_def subresultant_mat_def subresultant'_mat_def Let_def True"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff\n     (det (mat 0 0\n            (\\<lambda>(i, j).\n                if j < degree G - J\n                then if i = 0 - 1\n                     then monom (1::'a) (degree G - J - 1 - j) * F\n                     else [:coeff_int F (int (degree F) - int i + int j):]\n                else if i = 0 - 1\n                     then monom (1::'a)\n                           (degree F - J - 1 - (j - (degree G - J))) *\n                          G\n                     else [:coeff_int G\n                             (int (degree G) - int i +\n                              int (j - (degree G - J))):])))\n     l =\n    (if 0 = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (mat 0 0\n                (\\<lambda>(i, j).\n                    if j < degree G - J\n                    then if i = 0 - 1\n                         then coeff_int F\n                               (int l - int (degree G - J - 1) + int j)\n                         else coeff_int F (int (degree F) - int i + int j)\n                    else if i = 0 - 1\n                         then coeff_int G\n                               (int l - int (degree F - J - 1) +\n                                int (j - (degree G - J)))\n                         else coeff_int G\n                               (int (degree G) - int i +\n                                int (j - (degree G - J))))))", "by simp"], ["proof (state)\nthis:\n  coeff (subresultant J F G) l =\n  (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n   else det (subresultant'_mat J l F G))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "case False"], ["proof (state)\nthis:\n  degree F - J + (degree G - J) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "let ?n = \"degree F - J + (degree G - J)\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "define n where \"n = ?n\""], ["proof (state)\nthis:\n  n = degree F - J + (degree G - J)\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "from False"], ["proof (chain)\npicking this:\n  degree F - J + (degree G - J) \\<noteq> 0", "have n: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree F - J + (degree G - J) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "unfolding n_def"], ["proof (prove)\nusing this:\n  degree F - J + (degree G - J) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "hence id: \"{0..<n} = insert (n - 1) {0..< (n - 1)}\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {0..<n} = insert (n - 1) {0..<n - 1}", "by (cases n, auto)"], ["proof (state)\nthis:\n  {0..<n} = insert (n - 1) {0..<n - 1}\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have idn: \"(x = x) = True\" for x :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x) = True", "by simp"], ["proof (state)\nthis:\n  (?x = ?x) = True\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "let ?M = \"subresultant_mat J F G\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "define M where \"M = ?M\""], ["proof (state)\nthis:\n  M = subresultant_mat J F G\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "let ?L = \"subresultant'_mat J l F G\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "define L where \"L = ?L\""], ["proof (state)\nthis:\n  L = subresultant'_mat J l F G\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "{"], ["proof (state)\nthis:\n  L = subresultant'_mat J l F G\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "assume p: \"p permutes {0..<n}\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "from n p"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  p permutes {0..<n}", "have n1: \"n - 1 < n\" \"p (n - 1) < n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. n - 1 < n &&& p (n - 1) < n", "by auto"], ["proof (state)\nthis:\n  n - 1 < n\n  p (n - 1) < n\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) l =\n      (\\<Prod>i = 0 ..< (n - 1). coeff_int (M $$ (i, p i)) 0) * coeff_int (M $$ (n - 1, p (n - 1))) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) =\n    (\\<Prod>i = 0..<n - 1. coeff_int (M $$ (i, p i)) 0) *\n    coeff_int (M $$ (n - 1, p (n - 1))) (int l)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int (\\<Prod>i\\<in>insert (n - 1) {0..<n - 1}. M $$ (i, p i))\n     (int l) =\n    (\\<Prod>i = 0..<n - 1. coeff_int (M $$ (i, p i)) 0) *\n    coeff_int (M $$ (n - 1, p (n - 1))) (int l)", "proof (rule coeff_int_prod_const, (auto)[2])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow> degree (M $$ (i, p i)) = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow> degree (M $$ (i, p i)) = 0", "assume \"i \\<in> {0 ..< n - 1}\""], ["proof (state)\nthis:\n  i \\<in> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow> degree (M $$ (i, p i)) = 0", "with p"], ["proof (chain)\npicking this:\n  p permutes {0..<n}\n  i \\<in> {0..<n - 1}", "have i: \"i \\<noteq> n - 1\" and \"i < n\" \"p i < n\""], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  i \\<in> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. i \\<noteq> n - 1 &&& i < n &&& p i < n", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  i \\<noteq> n - 1\n  i < n\n  p i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow> degree (M $$ (i, p i)) = 0", "note id = subresultant_index_mat[OF this(2-3)[unfolded n_def], folded M_def n_def]"], ["proof (state)\nthis:\n  M $$ (i, p i) =\n  (if p i < degree G - J\n   then if i = n - 1 then monom (1::'a) (degree G - J - 1 - p i) * F\n        else [:coeff_int F (int (degree F) - int i + int (p i)):]\n   else let jj = p i - (degree G - J)\n        in if i = n - 1 then monom (1::'a) (degree F - J - 1 - jj) * G\n           else [:coeff_int G (int (degree G) - int i + int jj):])\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow> degree (M $$ (i, p i)) = 0", "show \"degree (M $$ (i, p i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (M $$ (i, p i)) = 0", "unfolding id Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (if p i < degree G - J\n      then if i = n - 1 then monom (1::'a) (degree G - J - 1 - p i) * F\n           else [:coeff_int F (int (degree F) - int i + int (p i)):]\n      else if i = n - 1\n           then monom (1::'a) (degree F - J - 1 - (p i - (degree G - J))) *\n                G\n           else [:coeff_int G\n                   (int (degree G) - int i +\n                    int (p i - (degree G - J))):]) =\n    0", "using i"], ["proof (prove)\nusing this:\n  i \\<noteq> n - 1\n\ngoal (1 subgoal):\n 1. degree\n     (if p i < degree G - J\n      then if i = n - 1 then monom (1::'a) (degree G - J - 1 - p i) * F\n           else [:coeff_int F (int (degree F) - int i + int (p i)):]\n      else if i = n - 1\n           then monom (1::'a) (degree F - J - 1 - (p i - (degree G - J))) *\n                G\n           else [:coeff_int G\n                   (int (degree G) - int i +\n                    int (p i - (degree G - J))):]) =\n    0", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  degree (M $$ (i, p i)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) =\n  (\\<Prod>i = 0..<n - 1. coeff_int (M $$ (i, p i)) 0) *\n  coeff_int (M $$ (n - 1, p (n - 1))) (int l)\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) =\n  (\\<Prod>i = 0..<n - 1. coeff_int (M $$ (i, p i)) 0) *\n  coeff_int (M $$ (n - 1, p (n - 1))) (int l)\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"(\\<Prod>i = 0 ..< (n - 1). coeff_int (M $$ (i, p i)) 0)\n       = (\\<Prod>i = 0 ..< (n - 1). L $$ (i, p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n - 1. coeff_int (M $$ (i, p i)) 0) =\n    (\\<Prod>i = 0..<n - 1. L $$ (i, p i))", "proof (rule prod.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n - 1} \\<Longrightarrow>\n       coeff_int (M $$ (x, p x)) 0 = L $$ (x, p x)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n - 1} \\<Longrightarrow>\n       coeff_int (M $$ (x, p x)) 0 = L $$ (x, p x)", "assume \"i \\<in> {0 ..< n - 1}\""], ["proof (state)\nthis:\n  i \\<in> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n - 1} \\<Longrightarrow>\n       coeff_int (M $$ (x, p x)) 0 = L $$ (x, p x)", "with p"], ["proof (chain)\npicking this:\n  p permutes {0..<n}\n  i \\<in> {0..<n - 1}", "have i: \"i \\<noteq> n - 1\" and ii: \"i < n\" \"p i < n\""], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  i \\<in> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. i \\<noteq> n - 1 &&& i < n &&& p i < n", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  i \\<noteq> n - 1\n  i < n\n  p i < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n - 1} \\<Longrightarrow>\n       coeff_int (M $$ (x, p x)) 0 = L $$ (x, p x)", "note id = subresultant_index_mat[OF this(2-3)[unfolded n_def], folded M_def n_def]"], ["proof (state)\nthis:\n  M $$ (i, p i) =\n  (if p i < degree G - J\n   then if i = n - 1 then monom (1::'a) (degree G - J - 1 - p i) * F\n        else [:coeff_int F (int (degree F) - int i + int (p i)):]\n   else let jj = p i - (degree G - J)\n        in if i = n - 1 then monom (1::'a) (degree F - J - 1 - jj) * G\n           else [:coeff_int G (int (degree G) - int i + int jj):])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n - 1} \\<Longrightarrow>\n       coeff_int (M $$ (x, p x)) 0 = L $$ (x, p x)", "note id' = L_def[unfolded subresultant'_mat_def Let_def, folded n_def] index_mat[OF ii]"], ["proof (state)\nthis:\n  L =\n  mat n n\n   (\\<lambda>(i, j).\n       if j < degree G - J\n       then if i = n - 1\n            then coeff_int F (int l - int (degree G - J - 1) + int j)\n            else coeff_int F (int (degree F) - int i + int j)\n       else if i = n - 1\n            then coeff_int G\n                  (int l - int (degree F - J - 1) +\n                   int (j - (degree G - J)))\n            else coeff_int G\n                  (int (degree G) - int i + int (j - (degree G - J))))\n  mat n n ?f $$ (i, p i) = ?f (i, p i)\n  mat\\<^sub>r n n ?g $$ (i, p i) = ?g i $ p i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n - 1} \\<Longrightarrow>\n       coeff_int (M $$ (x, p x)) 0 = L $$ (x, p x)", "show \"coeff_int (M $$ (i, p i)) 0 = L $$ (i, p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int (M $$ (i, p i)) 0 = L $$ (i, p i)", "unfolding id id' split"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int\n     (if p i < degree G - J\n      then if i = n - 1 then monom (1::'a) (degree G - J - 1 - p i) * F\n           else [:coeff_int F (int (degree F) - int i + int (p i)):]\n      else let jj = p i - (degree G - J)\n           in if i = n - 1 then monom (1::'a) (degree F - J - 1 - jj) * G\n              else [:coeff_int G (int (degree G) - int i + int jj):])\n     0 =\n    (if p i < degree G - J\n     then if i = n - 1\n          then coeff_int F (int l - int (degree G - J - 1) + int (p i))\n          else coeff_int F (int (degree F) - int i + int (p i))\n     else if i = n - 1\n          then coeff_int G\n                (int l - int (degree F - J - 1) +\n                 int (p i - (degree G - J)))\n          else coeff_int G\n                (int (degree G) - int i + int (p i - (degree G - J))))", "using i"], ["proof (prove)\nusing this:\n  i \\<noteq> n - 1\n\ngoal (1 subgoal):\n 1. coeff_int\n     (if p i < degree G - J\n      then if i = n - 1 then monom (1::'a) (degree G - J - 1 - p i) * F\n           else [:coeff_int F (int (degree F) - int i + int (p i)):]\n      else let jj = p i - (degree G - J)\n           in if i = n - 1 then monom (1::'a) (degree F - J - 1 - jj) * G\n              else [:coeff_int G (int (degree G) - int i + int jj):])\n     0 =\n    (if p i < degree G - J\n     then if i = n - 1\n          then coeff_int F (int l - int (degree G - J - 1) + int (p i))\n          else coeff_int F (int (degree F) - int i + int (p i))\n     else if i = n - 1\n          then coeff_int G\n                (int l - int (degree F - J - 1) +\n                 int (p i - (degree G - J)))\n          else coeff_int G\n                (int (degree G) - int i + int (p i - (degree G - J))))", "proof (simp add: if_splits Let_def)"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff_int (M $$ (i, p i)) 0 = L $$ (i, p i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n - 1. coeff_int (M $$ (i, p i)) 0) =\n  (\\<Prod>i = 0..<n - 1. L $$ (i, p i))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n - 1. coeff_int (M $$ (i, p i)) 0) =\n  (\\<Prod>i = 0..<n - 1. L $$ (i, p i))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"coeff_int (M $$ (n - 1, p (n - 1))) l =\n      (if p (n - 1) < degree G - J then\n         coeff_int (monom 1 (degree G - J - 1 - p (n - 1)) * F) l\n         else coeff_int (monom 1 (degree F - J - 1 - (p (n - 1) - (degree G - J))) * G) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int (M $$ (n - 1, p (n - 1))) (int l) =\n    (if p (n - 1) < degree G - J\n     then coeff_int (monom (1::'a) (degree G - J - 1 - p (n - 1)) * F)\n           (int l)\n     else coeff_int\n           (monom (1::'a)\n             (degree F - J - 1 - (p (n - 1) - (degree G - J))) *\n            G)\n           (int l))", "using subresultant_index_mat[OF n1[unfolded n_def], folded M_def n_def, unfolded idn if_True Let_def]"], ["proof (prove)\nusing this:\n  M $$ (n - 1, p (n - 1)) =\n  (if p (n - 1) < degree G - J\n   then monom (1::'a) (degree G - J - 1 - p (n - 1)) * F\n   else monom (1::'a) (degree F - J - 1 - (p (n - 1) - (degree G - J))) * G)\n\ngoal (1 subgoal):\n 1. coeff_int (M $$ (n - 1, p (n - 1))) (int l) =\n    (if p (n - 1) < degree G - J\n     then coeff_int (monom (1::'a) (degree G - J - 1 - p (n - 1)) * F)\n           (int l)\n     else coeff_int\n           (monom (1::'a)\n             (degree F - J - 1 - (p (n - 1) - (degree G - J))) *\n            G)\n           (int l))", "by simp"], ["proof (state)\nthis:\n  coeff_int (M $$ (n - 1, p (n - 1))) (int l) =\n  (if p (n - 1) < degree G - J\n   then coeff_int (monom (1::'a) (degree G - J - 1 - p (n - 1)) * F) (int l)\n   else coeff_int\n         (monom (1::'a) (degree F - J - 1 - (p (n - 1) - (degree G - J))) *\n          G)\n         (int l))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  coeff_int (M $$ (n - 1, p (n - 1))) (int l) =\n  (if p (n - 1) < degree G - J\n   then coeff_int (monom (1::'a) (degree G - J - 1 - p (n - 1)) * F) (int l)\n   else coeff_int\n         (monom (1::'a) (degree F - J - 1 - (p (n - 1) - (degree G - J))) *\n          G)\n         (int l))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"\\<dots> = (if p (n - 1) < degree G - J\n      then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n      else coeff_int G (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int (monom (1::'a) (degree G - J - 1 - p (n - 1)) * F)\n           (int l)\n     else coeff_int\n           (monom (1::'a)\n             (degree F - J - 1 - (p (n - 1) - (degree G - J))) *\n            G)\n           (int l)) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J)))))", "unfolding coeff_int_monom_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then (1::'a) * coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else (1::'a) *\n          coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J)))))", "by simp"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int (monom (1::'a) (degree G - J - 1 - p (n - 1)) * F) (int l)\n   else coeff_int\n         (monom (1::'a) (degree F - J - 1 - (p (n - 1) - (degree G - J))) *\n          G)\n         (int l)) =\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J)))))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int (monom (1::'a) (degree G - J - 1 - p (n - 1)) * F) (int l)\n   else coeff_int\n         (monom (1::'a) (degree F - J - 1 - (p (n - 1) - (degree G - J))) *\n          G)\n         (int l)) =\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J)))))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"\\<dots> = (if p (n - 1) < degree G - J\n      then coeff_int F (int l - int (degree G - J - 1) + p (n - 1))\n      else coeff_int G (int l - int (degree F - J - 1) + (p (n - 1) - (degree G - J))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "proof (cases \"p (n - 1) < degree G - J\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))\n 2. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "case True"], ["proof (state)\nthis:\n  p (n - 1) < degree G - J\n\ngoal (2 subgoals):\n 1. p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))\n 2. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "hence \"int (degree G - J - 1 - p (n - 1)) = int (degree G - J - 1) - p (n - 1)\""], ["proof (prove)\nusing this:\n  p (n - 1) < degree G - J\n\ngoal (1 subgoal):\n 1. int (degree G - J - 1 - p (n - 1)) =\n    int (degree G - J - 1) - int (p (n - 1))", "by simp"], ["proof (state)\nthis:\n  int (degree G - J - 1 - p (n - 1)) =\n  int (degree G - J - 1) - int (p (n - 1))\n\ngoal (2 subgoals):\n 1. p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))\n 2. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "hence id: \"int l - int (degree G - J - 1 - p (n - 1)) = int l - int (degree G - J - 1) + p (n - 1)\""], ["proof (prove)\nusing this:\n  int (degree G - J - 1 - p (n - 1)) =\n  int (degree G - J - 1) - int (p (n - 1))\n\ngoal (1 subgoal):\n 1. int l - int (degree G - J - 1 - p (n - 1)) =\n    int l - int (degree G - J - 1) + int (p (n - 1))", "by simp"], ["proof (state)\nthis:\n  int l - int (degree G - J - 1 - p (n - 1)) =\n  int l - int (degree G - J - 1) + int (p (n - 1))\n\ngoal (2 subgoals):\n 1. p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))\n 2. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "using True"], ["proof (prove)\nusing this:\n  p (n - 1) < degree G - J\n\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "unfolding id"], ["proof (prove)\nusing this:\n  p (n - 1) < degree G - J\n\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "by simp"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1) +\n          int (p (n - 1) - (degree G - J))))\n\ngoal (1 subgoal):\n 1. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "case False"], ["proof (state)\nthis:\n  \\<not> p (n - 1) < degree G - J\n\ngoal (1 subgoal):\n 1. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "from n1 False"], ["proof (chain)\npicking this:\n  n - 1 < n\n  p (n - 1) < n\n  \\<not> p (n - 1) < degree G - J", "have \"degree F - J - 1 \\<ge> p (n - 1) - (degree G - J)\""], ["proof (prove)\nusing this:\n  n - 1 < n\n  p (n - 1) < n\n  \\<not> p (n - 1) < degree G - J\n\ngoal (1 subgoal):\n 1. p (n - 1) - (degree G - J) \\<le> degree F - J - 1", "unfolding n_def"], ["proof (prove)\nusing this:\n  degree F - J + (degree G - J) - 1 < degree F - J + (degree G - J)\n  p (degree F - J + (degree G - J) - 1) < degree F - J + (degree G - J)\n  \\<not> p (degree F - J + (degree G - J) - 1) < degree G - J\n\ngoal (1 subgoal):\n 1. p (degree F - J + (degree G - J) - 1) - (degree G - J)\n    \\<le> degree F - J - 1", "by linarith"], ["proof (state)\nthis:\n  p (n - 1) - (degree G - J) \\<le> degree F - J - 1\n\ngoal (1 subgoal):\n 1. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "hence \"int (degree F - J - 1 - (p (n - 1) - (degree G - J))) = int (degree F - J - 1) - (p (n - 1) - (degree G - J))\""], ["proof (prove)\nusing this:\n  p (n - 1) - (degree G - J) \\<le> degree F - J - 1\n\ngoal (1 subgoal):\n 1. int (degree F - J - 1 - (p (n - 1) - (degree G - J))) =\n    int (degree F - J - 1) - int (p (n - 1) - (degree G - J))", "by linarith"], ["proof (state)\nthis:\n  int (degree F - J - 1 - (p (n - 1) - (degree G - J))) =\n  int (degree F - J - 1) - int (p (n - 1) - (degree G - J))\n\ngoal (1 subgoal):\n 1. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "hence id: \"int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J))) =\n       int l - int (degree F - J - 1) + (p (n - 1) - (degree G - J))\""], ["proof (prove)\nusing this:\n  int (degree F - J - 1 - (p (n - 1) - (degree G - J))) =\n  int (degree F - J - 1) - int (p (n - 1) - (degree G - J))\n\ngoal (1 subgoal):\n 1. int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J))) =\n    int l - int (degree F - J - 1) + int (p (n - 1) - (degree G - J))", "by simp"], ["proof (state)\nthis:\n  int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J))) =\n  int l - int (degree F - J - 1) + int (p (n - 1) - (degree G - J))\n\ngoal (1 subgoal):\n 1. \\<not> p (n - 1) < degree G - J \\<Longrightarrow>\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l -\n            int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J)))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "using False"], ["proof (prove)\nusing this:\n  \\<not> p (n - 1) < degree G - J\n\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J)))) =\n    (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J))))", "by simp"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1) +\n          int (p (n - 1) - (degree G - J))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1) +\n          int (p (n - 1) - (degree G - J))))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1 - p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1 - (p (n - 1) - (degree G - J))))) =\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1) +\n          int (p (n - 1) - (degree G - J))))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"\\<dots> = L $$ (n - 1, p (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J)))) =\n    L $$ (n - 1, p (n - 1))", "unfolding L_def subresultant'_mat_def Let_def n_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J)))) =\n    mat n n\n     (\\<lambda>(i, j).\n         if j < degree G - J\n         then if i = n - 1\n              then coeff_int F (int l - int (degree G - J - 1) + int j)\n              else coeff_int F (int (degree F) - int i + int j)\n         else if i = n - 1\n              then coeff_int G\n                    (int l - int (degree F - J - 1) +\n                     int (j - (degree G - J)))\n              else coeff_int G\n                    (int (degree G) - int i + int (j - (degree G - J)))) $$\n    (n - 1, p (n - 1))", "using n1"], ["proof (prove)\nusing this:\n  n - 1 < n\n  p (n - 1) < n\n\ngoal (1 subgoal):\n 1. (if p (n - 1) < degree G - J\n     then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n     else coeff_int G\n           (int l - int (degree F - J - 1) +\n            int (p (n - 1) - (degree G - J)))) =\n    mat n n\n     (\\<lambda>(i, j).\n         if j < degree G - J\n         then if i = n - 1\n              then coeff_int F (int l - int (degree G - J - 1) + int j)\n              else coeff_int F (int (degree F) - int i + int j)\n         else if i = n - 1\n              then coeff_int G\n                    (int l - int (degree F - J - 1) +\n                     int (j - (degree G - J)))\n              else coeff_int G\n                    (int (degree G) - int i + int (j - (degree G - J)))) $$\n    (n - 1, p (n - 1))", "by simp"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1) +\n          int (p (n - 1) - (degree G - J)))) =\n  L $$ (n - 1, p (n - 1))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  (if p (n - 1) < degree G - J\n   then coeff_int F (int l - int (degree G - J - 1) + int (p (n - 1)))\n   else coeff_int G\n         (int l - int (degree F - J - 1) +\n          int (p (n - 1) - (degree G - J)))) =\n  L $$ (n - 1, p (n - 1))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"(\\<Prod>i = 0..<n - 1. L $$ (i, p i)) * \\<dots> = (\\<Prod>i = 0..<n. L $$ (i, p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n - 1. L $$ (i, p i)) * L $$ (n - 1, p (n - 1)) =\n    (\\<Prod>i = 0..<n. L $$ (i, p i))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n - 1. L $$ (i, p i)) * L $$ (n - 1, p (n - 1)) =\n    (\\<Prod>i\\<in>insert (n - 1) {0..<n - 1}. L $$ (i, p i))", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n - 1. L $$ (i, p i)) * L $$ (n - 1, p (n - 1)) =\n  (\\<Prod>i = 0..<n. L $$ (i, p i))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "finally"], ["proof (chain)\npicking this:\n  coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) =\n  (\\<Prod>i = 0..<n. L $$ (i, p i))", "have \"coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) = (\\<Prod>i = 0..<n. L $$ (i, p i))\""], ["proof (prove)\nusing this:\n  coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) =\n  (\\<Prod>i = 0..<n. L $$ (i, p i))\n\ngoal (1 subgoal):\n 1. coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) =\n    (\\<Prod>i = 0..<n. L $$ (i, p i))", "."], ["proof (state)\nthis:\n  coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l) =\n  (\\<Prod>i = 0..<n. L $$ (i, p i))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "}"], ["proof (state)\nthis:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  coeff_int (\\<Prod>i = 0..<n. M $$ (i, ?p2 i)) (int l) =\n  (\\<Prod>i = 0..<n. L $$ (i, ?p2 i))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "note * = this"], ["proof (state)\nthis:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  coeff_int (\\<Prod>i = 0..<n. M $$ (i, ?p2 i)) (int l) =\n  (\\<Prod>i = 0..<n. L $$ (i, ?p2 i))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"coeff_int (subresultant J F G) l =\n    (\\<Sum>p\\<in>{p. p permutes {0..<n}}. signof p * coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int (subresultant J F G) (int l) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l))", "unfolding subresultant_def det_def subresultant_mat_dim idn if_True n_def[symmetric] M_def\n      coeff_int_sum coeff_int_signof_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{p. p permutes {0..<n}}.\n       signof x *\n       coeff_int (\\<Prod>i = 0..<n. subresultant_mat J F G $$ (i, x i))\n        (int l)) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       coeff_int (\\<Prod>i = 0..<n. subresultant_mat J F G $$ (i, p i))\n        (int l))", "by simp"], ["proof (state)\nthis:\n  coeff_int (subresultant J F G) (int l) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  coeff_int (subresultant J F G) (int l) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"\\<dots> = (\\<Sum>p\\<in>{p. p permutes {0..<n}}. signof p * (\\<Prod>i = 0..<n. L $$ (i, p i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l)) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. L $$ (i, p i)))", "by (rule sum.cong[OF refl], insert *, simp)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l)) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. L $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * coeff_int (\\<Prod>i = 0..<n. M $$ (i, p i)) (int l)) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. L $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "have \"\\<dots> = det L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. L $$ (i, p i))) =\n    det L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. L $$ (i, p i))) =\n    det L", "have id: \"dim_row (subresultant'_mat J l F G) = n\"\n      \"dim_col (subresultant'_mat J l F G) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (subresultant'_mat J l F G) = n &&&\n    dim_col (subresultant'_mat J l F G) = n", "unfolding subresultant'_mat_def Let_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (degree F - J + (degree G - J)) (degree F - J + (degree G - J))\n       (\\<lambda>(i, j).\n           if j < degree G - J\n           then if i = degree F - J + (degree G - J) - 1\n                then coeff_int F (int l - int (degree G - J - 1) + int j)\n                else coeff_int F (int (degree F) - int i + int j)\n           else if i = degree F - J + (degree G - J) - 1\n                then coeff_int G\n                      (int l - int (degree F - J - 1) +\n                       int (j - (degree G - J)))\n                else coeff_int G\n                      (int (degree G) - int i +\n                       int (j - (degree G - J))))) =\n    degree F - J + (degree G - J) &&&\n    dim_col\n     (mat (degree F - J + (degree G - J)) (degree F - J + (degree G - J))\n       (\\<lambda>(i, j).\n           if j < degree G - J\n           then if i = degree F - J + (degree G - J) - 1\n                then coeff_int F (int l - int (degree G - J - 1) + int j)\n                else coeff_int F (int (degree F) - int i + int j)\n           else if i = degree F - J + (degree G - J) - 1\n                then coeff_int G\n                      (int l - int (degree F - J - 1) +\n                       int (j - (degree G - J)))\n                else coeff_int G\n                      (int (degree G) - int i +\n                       int (j - (degree G - J))))) =\n    degree F - J + (degree G - J)", "by auto"], ["proof (state)\nthis:\n  dim_row (subresultant'_mat J l F G) = n\n  dim_col (subresultant'_mat J l F G) = n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. L $$ (i, p i))) =\n    det L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. L $$ (i, p i))) =\n    det L", "unfolding det_def L_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n. subresultant'_mat J l F G $$ (i, p i))) =\n    (if n = n\n     then \\<Sum>p | p permutes {0..<n}.\n            signof p *\n            (\\<Prod>i = 0..<n. subresultant'_mat J l F G $$ (i, p i))\n     else (0::'a))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. L $$ (i, p i))) =\n  det L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. L $$ (i, p i))) =\n  det L\n\ngoal (1 subgoal):\n 1. degree F - J + (degree G - J) \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "finally"], ["proof (chain)\npicking this:\n  coeff_int (subresultant J F G) (int l) = det L", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff_int (subresultant J F G) (int l) = det L\n\ngoal (1 subgoal):\n 1. coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "unfolding L_def coeff_int_def"], ["proof (prove)\nusing this:\n  (if int l < 0 then 0::'a else coeff (subresultant J F G) (nat (int l))) =\n  det (subresultant'_mat J l F G)\n\ngoal (1 subgoal):\n 1. coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "using False"], ["proof (prove)\nusing this:\n  (if int l < 0 then 0::'a else coeff (subresultant J F G) (nat (int l))) =\n  det (subresultant'_mat J l F G)\n  degree F - J + (degree G - J) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff (subresultant J F G) l =\n    (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J l F G))", "by auto"], ["proof (state)\nthis:\n  coeff (subresultant J F G) l =\n  (if degree F - J + (degree G - J) = 0 \\<and> l \\<noteq> 0 then 0::'a\n   else det (subresultant'_mat J l F G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subresultant'_zero_ge: assumes \"(degree f - J) + (degree g - J) \\<noteq> 0\" and \"k \\<ge> degree f + (degree g - J)\"\n  shows \"det (subresultant'_mat J k f g) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "(* last row is zero *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "obtain dg where dg: \"degree g - J = dg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dg. degree g - J = dg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  degree g - J = dg\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "obtain df where df: \"degree f - J = df\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>df. degree f - J = df \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  degree f - J = df\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "obtain ddf where ddf: \"degree f = ddf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ddf. degree f = ddf \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  degree f = ddf\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "note * = assms(2)[unfolded ddf dg] assms(1)"], ["proof (state)\nthis:\n  ddf + dg \\<le> k\n  degree f - J + (degree g - J) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "define M where \"M = (\\<lambda> i j. if j < dg\n            then coeff_int f (degree f - int i + int j)\n            else coeff_int g (degree g - int i + int (j - dg)))\""], ["proof (state)\nthis:\n  M =\n  (\\<lambda>i j.\n      if j < dg then coeff_int f (int (degree f) - int i + int j)\n      else coeff_int g (int (degree g) - int i + int (j - dg)))\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "let ?M = \"subresultant'_mat J k f g\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have M: \"det ?M = det (mat (df + dg) (df + dg)\n    (\\<lambda>(i, j).\n        if i = df + dg - 1 then\n          if j < dg\n            then coeff_int f (int k - int (dg - 1) + int j)\n            else coeff_int g (int k - int (df - 1) + int (j - dg))\n        else M i j))\" (is \"_ = det ?N\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) =\n    det (mat (df + dg) (df + dg)\n          (\\<lambda>(i, j).\n              if i = df + dg - 1\n              then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n                   else coeff_int g (int k - int (df - 1) + int (j - dg))\n              else M i j))", "unfolding subresultant'_mat_def Let_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n          (\\<lambda>(i, j).\n              if j < degree g - J\n              then if i = degree f - J + (degree g - J) - 1\n                   then coeff_int f (int k - int (degree g - J - 1) + int j)\n                   else coeff_int f (int (degree f) - int i + int j)\n              else if i = degree f - J + (degree g - J) - 1\n                   then coeff_int g\n                         (int k - int (degree f - J - 1) +\n                          int (j - (degree g - J)))\n                   else coeff_int g\n                         (int (degree g) - int i +\n                          int (j - (degree g - J))))) =\n    det (mat (df + dg) (df + dg)\n          (\\<lambda>(i, j).\n              if i = df + dg - 1\n              then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n                   else coeff_int g (int k - int (df - 1) + int (j - dg))\n              else if j < dg\n                   then coeff_int f (int (degree f) - int i + int j)\n                   else coeff_int g\n                         (int (degree g) - int i + int (j - dg))))", "by (rule arg_cong[of _ _ det], rule eq_matI, auto simp: df dg)"], ["proof (state)\nthis:\n  det (subresultant'_mat J k f g) =\n  det (mat (df + dg) (df + dg)\n        (\\<lambda>(i, j).\n            if i = df + dg - 1\n            then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n                 else coeff_int g (int k - int (df - 1) + int (j - dg))\n            else M i j))\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "also"], ["proof (state)\nthis:\n  det (subresultant'_mat J k f g) =\n  det (mat (df + dg) (df + dg)\n        (\\<lambda>(i, j).\n            if i = df + dg - 1\n            then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n                 else coeff_int g (int k - int (df - 1) + int (j - dg))\n            else M i j))\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have \"?N = mat (df + dg) (df + dg)\n    (\\<lambda>(i, j).\n        if i = df + dg - 1 then 0\n        else M i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (df + dg) (df + dg)\n     (\\<lambda>(i, j).\n         if i = df + dg - 1\n         then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n              else coeff_int g (int k - int (df - 1) + int (j - dg))\n         else M i j) =\n    mat (df + dg) (df + dg)\n     (\\<lambda>(i, j). if i = df + dg - 1 then 0::'a else M i j)", "by (rule cong_mat[OF refl refl], unfold split, rule if_cong[OF refl _ refl],\n      auto simp add: coeff_int_def df dg ddf intro!: coeff_eq_0, insert *(1),\n      unfold ddf[symmetric] dg[symmetric] df[symmetric], linarith+)"], ["proof (state)\nthis:\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j).\n       if i = df + dg - 1\n       then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n            else coeff_int g (int k - int (df - 1) + int (j - dg))\n       else M i j) =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j). if i = df + dg - 1 then 0::'a else M i j)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "also"], ["proof (state)\nthis:\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j).\n       if i = df + dg - 1\n       then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n            else coeff_int g (int k - int (df - 1) + int (j - dg))\n       else M i j) =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j). if i = df + dg - 1 then 0::'a else M i j)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have \"\\<dots> = mat\\<^sub>r (df + dg) (df + dg) (\\<lambda>i. if i = df + dg - 1 then 0\\<^sub>v (df + dg) else\n    vec (df + dg) (\\<lambda> j. M i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (df + dg) (df + dg)\n     (\\<lambda>(i, j). if i = df + dg - 1 then 0::'a else M i j) =\n    mat\\<^sub>r (df + dg) (df + dg)\n     (\\<lambda>i.\n         if i = df + dg - 1 then 0\\<^sub>v (df + dg)\n         else vec (df + dg) (M i))", "by (rule eq_matI, auto)"], ["proof (state)\nthis:\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j). if i = df + dg - 1 then 0::'a else M i j) =\n  mat\\<^sub>r (df + dg) (df + dg)\n   (\\<lambda>i.\n       if i = df + dg - 1 then 0\\<^sub>v (df + dg) else vec (df + dg) (M i))\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "also"], ["proof (state)\nthis:\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j). if i = df + dg - 1 then 0::'a else M i j) =\n  mat\\<^sub>r (df + dg) (df + dg)\n   (\\<lambda>i.\n       if i = df + dg - 1 then 0\\<^sub>v (df + dg) else vec (df + dg) (M i))\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have \"det \\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r (df + dg) (df + dg)\n          (\\<lambda>i.\n              if i = df + dg - 1 then 0\\<^sub>v (df + dg)\n              else vec (df + dg) (M i))) =\n    (0::'a)", "by (rule det_row_0, insert *, auto simp: df[symmetric] dg[symmetric] ddf[symmetric])"], ["proof (state)\nthis:\n  det (mat\\<^sub>r (df + dg) (df + dg)\n        (\\<lambda>i.\n            if i = df + dg - 1 then 0\\<^sub>v (df + dg)\n            else vec (df + dg) (M i))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  det (subresultant'_mat J k f g) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (subresultant'_mat J k f g) = (0::'a)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "."], ["proof (state)\nthis:\n  det (subresultant'_mat J k f g) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subresultant'_zero_lt: assumes\n  J: \"J \\<le> degree f\" \"J \\<le> degree g\" \"J < k\"\n  and k: \"k < degree f + (degree g - J)\"\n  shows \"det (subresultant'_mat J k f g) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "(* last row is identical to last row - k *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "obtain dg where dg: \"dg = degree g - J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dg. dg = degree g - J \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  dg = degree g - J\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "obtain df where df: \"df = degree f - J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>df. df = degree f - J \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  df = degree f - J\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "note * = assms[folded df dg]"], ["proof (state)\nthis:\n  J \\<le> degree f\n  J \\<le> degree g\n  J < k\n  k < degree f + dg\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "define M where \"M = (\\<lambda> i j. if j < dg\n            then coeff_int f (degree f - int i + int j)\n            else coeff_int g (degree g - int i + int (j - dg)))\""], ["proof (state)\nthis:\n  M =\n  (\\<lambda>i j.\n      if j < dg then coeff_int f (int (degree f) - int i + int j)\n      else coeff_int g (int (degree g) - int i + int (j - dg)))\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "define N where \"N = (\\<lambda> j. if j < dg\n            then coeff_int f (int k - int (dg - 1) + int j)\n            else coeff_int g (int k - int (df - 1) + int (j - dg)))\""], ["proof (state)\nthis:\n  N =\n  (\\<lambda>j.\n      if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n      else coeff_int g (int k - int (df - 1) + int (j - dg)))\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "let ?M = \"subresultant'_mat J k f g\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have M: \"?M = mat (df + dg) (df + dg)\n    (\\<lambda>(i, j).\n        if i = df + dg - 1 then N j\n        else M i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant'_mat J k f g =\n    mat (df + dg) (df + dg)\n     (\\<lambda>(i, j). if i = df + dg - 1 then N j else M i j)", "unfolding subresultant'_mat_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (degree f - J + (degree g - J)) (degree f - J + (degree g - J))\n     (\\<lambda>(i, j).\n         if j < degree g - J\n         then if i = degree f - J + (degree g - J) - 1\n              then coeff_int f (int k - int (degree g - J - 1) + int j)\n              else coeff_int f (int (degree f) - int i + int j)\n         else if i = degree f - J + (degree g - J) - 1\n              then coeff_int g\n                    (int k - int (degree f - J - 1) +\n                     int (j - (degree g - J)))\n              else coeff_int g\n                    (int (degree g) - int i + int (j - (degree g - J)))) =\n    mat (df + dg) (df + dg)\n     (\\<lambda>(i, j). if i = df + dg - 1 then N j else M i j)", "by (rule eq_matI, auto simp: df dg M_def N_def)"], ["proof (state)\nthis:\n  subresultant'_mat J k f g =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j). if i = df + dg - 1 then N j else M i j)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "also"], ["proof (state)\nthis:\n  subresultant'_mat J k f g =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j). if i = df + dg - 1 then N j else M i j)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have \"\\<dots> = mat (df + dg) (df + dg)\n    (\\<lambda>(i, j).\n        if i = df + dg - 1 then N j\n        else if i = degree f + dg - 1 - k then N j else M i j)\" (is \"_ = ?N\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (df + dg) (df + dg)\n     (\\<lambda>(i, j). if i = df + dg - 1 then N j else M i j) =\n    mat (df + dg) (df + dg)\n     (\\<lambda>(i, j).\n         if i = df + dg - 1 then N j\n         else if i = degree f + dg - 1 - k then N j else M i j)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (df + dg) (df + dg)\n     (\\<lambda>(i, j).\n         if i = df + dg - 1\n         then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n              else coeff_int g (int k - int (df - 1) + int (j - dg))\n         else M i j) =\n    mat (df + dg) (df + dg)\n     (\\<lambda>(i, j).\n         if i = df + dg - 1\n         then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n              else coeff_int g (int k - int (df - 1) + int (j - dg))\n         else if i = degree f + dg - 1 - k\n              then if j < dg then coeff_int f (int k - int (dg - 1) + int j)\n                   else coeff_int g (int k - int (df - 1) + int (j - dg))\n              else M i j)", "by (rule cong_mat[OF refl refl], unfold split, rule if_cong[OF refl refl], unfold M_def N_def,\n      insert J k, auto simp: df dg intro!: arg_cong[of _ _ \"coeff_int _\"])"], ["proof (state)\nthis:\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j). if i = df + dg - 1 then N j else M i j) =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j).\n       if i = df + dg - 1 then N j\n       else if i = degree f + dg - 1 - k then N j else M i j)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  subresultant'_mat J k f g =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j).\n       if i = df + dg - 1 then N j\n       else if i = degree f + dg - 1 - k then N j else M i j)", "have id: \"?M = ?N\""], ["proof (prove)\nusing this:\n  subresultant'_mat J k f g =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j).\n       if i = df + dg - 1 then N j\n       else if i = degree f + dg - 1 - k then N j else M i j)\n\ngoal (1 subgoal):\n 1. subresultant'_mat J k f g =\n    mat (df + dg) (df + dg)\n     (\\<lambda>(i, j).\n         if i = df + dg - 1 then N j\n         else if i = degree f + dg - 1 - k then N j else M i j)", "."], ["proof (state)\nthis:\n  subresultant'_mat J k f g =\n  mat (df + dg) (df + dg)\n   (\\<lambda>(i, j).\n       if i = df + dg - 1 then N j\n       else if i = degree f + dg - 1 - k then N j else M i j)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have deg: \"degree f + dg - 1 - k < df + dg\" \"df + dg - 1 < df + dg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f + dg - 1 - k < df + dg &&& df + dg - 1 < df + dg", "using k J"], ["proof (prove)\nusing this:\n  k < degree f + (degree g - J)\n  J \\<le> degree f\n  J \\<le> degree g\n  J < k\n\ngoal (1 subgoal):\n 1. degree f + dg - 1 - k < df + dg &&& df + dg - 1 < df + dg", "unfolding df dg"], ["proof (prove)\nusing this:\n  k < degree f + (degree g - J)\n  J \\<le> degree f\n  J \\<le> degree g\n  J < k\n\ngoal (1 subgoal):\n 1. degree f + (degree g - J) - 1 - k < degree f - J + (degree g - J) &&&\n    degree f - J + (degree g - J) - 1 < degree f - J + (degree g - J)", "by auto"], ["proof (state)\nthis:\n  degree f + dg - 1 - k < df + dg\n  df + dg - 1 < df + dg\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "have id: \"row ?M (degree f + dg - 1 - k) = row ?M (df + dg - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (subresultant'_mat J k f g) (degree f + dg - 1 - k) =\n    row (subresultant'_mat J k f g) (df + dg - 1)", "unfolding arg_cong[OF id, of row]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat (df + dg) (df + dg)\n          (\\<lambda>(i, j).\n              if i = df + dg - 1 then N j\n              else if i = degree f + dg - 1 - k then N j else M i j))\n     (degree f + dg - 1 - k) =\n    row (mat (df + dg) (df + dg)\n          (\\<lambda>(i, j).\n              if i = df + dg - 1 then N j\n              else if i = degree f + dg - 1 - k then N j else M i j))\n     (df + dg - 1)", "by (rule eq_vecI, insert deg, auto)"], ["proof (state)\nthis:\n  row (subresultant'_mat J k f g) (degree f + dg - 1 - k) =\n  row (subresultant'_mat J k f g) (df + dg - 1)\n\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant'_mat J k f g) = (0::'a)", "by (rule det_identical_rows[OF _ _ _ _ id, of \"df + dg\"], insert deg assms,\n      auto simp: subresultant'_mat_def Let_def df dg)"], ["proof (state)\nthis:\n  det (subresultant'_mat J k f g) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subresultant'_mat_sylvester_mat: \"transpose_mat (subresultant'_mat 0 0 f g) = sylvester_mat f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "obtain dg where dg: \"degree g = dg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dg. degree g = dg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  degree g = dg\n\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "obtain df where df: \"degree f = df\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>df. degree f = df \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  degree f = df\n\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "let ?M = \"transpose_mat (subresultant'_mat 0 0 f g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "let ?n = \"degree f + degree g\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "have dim: \"dim_row ?M = ?n\" \"dim_col ?M = ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (subresultant'_mat 0 0 f g)\\<^sup>T = degree f + degree g &&&\n    dim_col (subresultant'_mat 0 0 f g)\\<^sup>T = degree f + degree g", "by (auto simp: subresultant'_mat_def Let_def)"], ["proof (state)\nthis:\n  dim_row (subresultant'_mat 0 0 f g)\\<^sup>T = degree f + degree g\n  dim_col (subresultant'_mat 0 0 f g)\\<^sup>T = degree f + degree g\n\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "proof (rule eq_matI, unfold sylvester_mat_dim dim df dg, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df + dg; j < df + dg\\<rbrakk>\n       \\<Longrightarrow> (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n                         sylvester_mat f g $$ (i, j)\n 2. df + dg = df + dg\n 3. df + dg = df + dg", "case ij: (1 i j)"], ["proof (state)\nthis:\n  i < df + dg\n  j < df + dg\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df + dg; j < df + dg\\<rbrakk>\n       \\<Longrightarrow> (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n                         sylvester_mat f g $$ (i, j)\n 2. df + dg = df + dg\n 3. df + dg = df + dg", "have \"?M $$ (i,j) = (if i < dg\n         then if j = df + dg - 1\n              then coeff_int f (- int (dg - 1) + int i)\n              else coeff_int f (int df - int j + int i)\n         else if j = df + dg - 1\n              then coeff_int g (- int (df - 1) + int (i - dg))\n              else coeff_int g (int dg - int j + int (i - dg)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n    (if i < dg\n     then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n          else coeff_int f (int df - int j + int i)\n     else if j = df + dg - 1\n          then coeff_int g (- int (df - 1) + int (i - dg))\n          else coeff_int g (int dg - int j + int (i - dg)))", "using ij"], ["proof (prove)\nusing this:\n  i < df + dg\n  j < df + dg\n\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n    (if i < dg\n     then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n          else coeff_int f (int df - int j + int i)\n     else if j = df + dg - 1\n          then coeff_int g (- int (df - 1) + int (i - dg))\n          else coeff_int g (int dg - int j + int (i - dg)))", "unfolding subresultant'_mat_def Let_def"], ["proof (prove)\nusing this:\n  i < df + dg\n  j < df + dg\n\ngoal (1 subgoal):\n 1. (mat (degree f - 0 + (degree g - 0)) (degree f - 0 + (degree g - 0))\n      (\\<lambda>(i, j).\n          if j < degree g - 0\n          then if i = degree f - 0 + (degree g - 0) - 1\n               then coeff_int f (int 0 - int (degree g - 0 - 1) + int j)\n               else coeff_int f (int (degree f) - int i + int j)\n          else if i = degree f - 0 + (degree g - 0) - 1\n               then coeff_int g\n                     (int 0 - int (degree f - 0 - 1) +\n                      int (j - (degree g - 0)))\n               else coeff_int g\n                     (int (degree g) - int i +\n                      int (j - (degree g - 0)))))\\<^sup>T $$\n    (i, j) =\n    (if i < dg\n     then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n          else coeff_int f (int df - int j + int i)\n     else if j = df + dg - 1\n          then coeff_int g (- int (df - 1) + int (i - dg))\n          else coeff_int g (int dg - int j + int (i - dg)))", "by (simp add: if_splits df dg)"], ["proof (state)\nthis:\n  (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n  (if i < dg\n   then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n        else coeff_int f (int df - int j + int i)\n   else if j = df + dg - 1 then coeff_int g (- int (df - 1) + int (i - dg))\n        else coeff_int g (int dg - int j + int (i - dg)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df + dg; j < df + dg\\<rbrakk>\n       \\<Longrightarrow> (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n                         sylvester_mat f g $$ (i, j)\n 2. df + dg = df + dg\n 3. df + dg = df + dg", "also"], ["proof (state)\nthis:\n  (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n  (if i < dg\n   then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n        else coeff_int f (int df - int j + int i)\n   else if j = df + dg - 1 then coeff_int g (- int (df - 1) + int (i - dg))\n        else coeff_int g (int dg - int j + int (i - dg)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df + dg; j < df + dg\\<rbrakk>\n       \\<Longrightarrow> (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n                         sylvester_mat f g $$ (i, j)\n 2. df + dg = df + dg\n 3. df + dg = df + dg", "have \"\\<dots> = (if i < dg\n         then coeff_int f (int df - int j + int i)\n         else coeff_int g (int dg - int j + int (i - dg)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dg\n     then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n          else coeff_int f (int df - int j + int i)\n     else if j = df + dg - 1\n          then coeff_int g (- int (df - 1) + int (i - dg))\n          else coeff_int g (int dg - int j + int (i - dg))) =\n    (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if i < dg\n     then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n          else coeff_int f (int df - int j + int i)\n     else if j = df + dg - 1\n          then coeff_int g (- int (df - 1) + int (i - dg))\n          else coeff_int g (int dg - int j + int (i - dg))) =\n    (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg)))", "have cong: \"(b \\<Longrightarrow> x = z) \\<Longrightarrow> (\\<not> b \\<Longrightarrow> y = z) \\<Longrightarrow> (if b then coeff_int f x else coeff_int f y) = coeff_int f z\"\n        for b x y z and f :: \"'a poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<Longrightarrow> x = z;\n     \\<not> b \\<Longrightarrow> y = z\\<rbrakk>\n    \\<Longrightarrow> (if b then coeff_int f x else coeff_int f y) =\n                      coeff_int f z", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<Longrightarrow> ?x = ?z;\n   \\<not> ?b \\<Longrightarrow> ?y = ?z\\<rbrakk>\n  \\<Longrightarrow> (if ?b then coeff_int ?f ?x else coeff_int ?f ?y) =\n                    coeff_int ?f ?z\n\ngoal (1 subgoal):\n 1. (if i < dg\n     then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n          else coeff_int f (int df - int j + int i)\n     else if j = df + dg - 1\n          then coeff_int g (- int (df - 1) + int (i - dg))\n          else coeff_int g (int dg - int j + int (i - dg))) =\n    (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dg\n     then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n          else coeff_int f (int df - int j + int i)\n     else if j = df + dg - 1\n          then coeff_int g (- int (df - 1) + int (i - dg))\n          else coeff_int g (int dg - int j + int (i - dg))) =\n    (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg)))", "by (rule if_cong[OF refl cong cong], insert ij, auto)"], ["proof (state)\nthis:\n  (if i < dg\n   then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n        else coeff_int f (int df - int j + int i)\n   else if j = df + dg - 1 then coeff_int g (- int (df - 1) + int (i - dg))\n        else coeff_int g (int dg - int j + int (i - dg))) =\n  (if i < dg then coeff_int f (int df - int j + int i)\n   else coeff_int g (int dg - int j + int (i - dg)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < dg\n   then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n        else coeff_int f (int df - int j + int i)\n   else if j = df + dg - 1 then coeff_int g (- int (df - 1) + int (i - dg))\n        else coeff_int g (int dg - int j + int (i - dg))) =\n  (if i < dg then coeff_int f (int df - int j + int i)\n   else coeff_int g (int dg - int j + int (i - dg)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df + dg; j < df + dg\\<rbrakk>\n       \\<Longrightarrow> (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n                         sylvester_mat f g $$ (i, j)\n 2. df + dg = df + dg\n 3. df + dg = df + dg", "also"], ["proof (state)\nthis:\n  (if i < dg\n   then if j = df + dg - 1 then coeff_int f (- int (dg - 1) + int i)\n        else coeff_int f (int df - int j + int i)\n   else if j = df + dg - 1 then coeff_int g (- int (df - 1) + int (i - dg))\n        else coeff_int g (int dg - int j + int (i - dg))) =\n  (if i < dg then coeff_int f (int df - int j + int i)\n   else coeff_int g (int dg - int j + int (i - dg)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df + dg; j < df + dg\\<rbrakk>\n       \\<Longrightarrow> (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n                         sylvester_mat f g $$ (i, j)\n 2. df + dg = df + dg\n 3. df + dg = df + dg", "have \"\\<dots> = sylvester_mat f g $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg))) =\n    sylvester_mat f g $$ (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg))) =\n    sylvester_mat f g $$ (i, j)", "have *: \"i \\<le> j \\<Longrightarrow> j - i \\<le> df \\<Longrightarrow> nat (int df - int j + int i) = df - (j - i)\" for j i df"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j - i \\<le> df\\<rbrakk>\n    \\<Longrightarrow> nat (int df - int j + int i) = df - (j - i)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> ?j; ?j - ?i \\<le> ?df\\<rbrakk>\n  \\<Longrightarrow> nat (int ?df - int ?j + int ?i) = ?df - (?j - ?i)\n\ngoal (1 subgoal):\n 1. (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg))) =\n    sylvester_mat f g $$ (i, j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg))) =\n    sylvester_mat f g $$ (i, j)", "unfolding sylvester_index_mat[OF ij[folded df dg]] df dg"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dg then coeff_int f (int df - int j + int i)\n     else coeff_int g (int dg - int j + int (i - dg))) =\n    (if i < dg\n     then if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j)\n          else (0::'a)\n     else if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n          else (0::'a))", "proof (rule if_cong[OF refl])"], ["proof (state)\ngoal (2 subgoals):\n 1. i < dg \\<Longrightarrow>\n    coeff_int f (int df - int j + int i) =\n    (if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j)\n     else (0::'a))\n 2. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "assume i: \"i < dg\""], ["proof (state)\nthis:\n  i < dg\n\ngoal (2 subgoals):\n 1. i < dg \\<Longrightarrow>\n    coeff_int f (int df - int j + int i) =\n    (if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j)\n     else (0::'a))\n 2. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "have \"int df - int j + int i < 0 \\<longrightarrow> \\<not> j - i \\<le> df\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int df - int j + int i < 0 \\<longrightarrow> \\<not> j - i \\<le> df", "by auto"], ["proof (state)\nthis:\n  int df - int j + int i < 0 \\<longrightarrow> \\<not> j - i \\<le> df\n\ngoal (2 subgoals):\n 1. i < dg \\<Longrightarrow>\n    coeff_int f (int df - int j + int i) =\n    (if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j)\n     else (0::'a))\n 2. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "thus \"coeff_int f (int df - int j + int i) = (if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j) else 0)\""], ["proof (prove)\nusing this:\n  int df - int j + int i < 0 \\<longrightarrow> \\<not> j - i \\<le> df\n\ngoal (1 subgoal):\n 1. coeff_int f (int df - int j + int i) =\n    (if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j)\n     else (0::'a))", "using i ij"], ["proof (prove)\nusing this:\n  int df - int j + int i < 0 \\<longrightarrow> \\<not> j - i \\<le> df\n  i < dg\n  i < df + dg\n  j < df + dg\n\ngoal (1 subgoal):\n 1. coeff_int f (int df - int j + int i) =\n    (if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j)\n     else (0::'a))", "by (simp add: coeff_int_def *, intro impI  coeff_eq_0[of f, unfolded df], linarith)"], ["proof (state)\nthis:\n  coeff_int f (int df - int j + int i) =\n  (if i \\<le> j \\<and> j - i \\<le> df then coeff f (df + i - j)\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "assume i: \"\\<not> i < dg\""], ["proof (state)\nthis:\n  \\<not> i < dg\n\ngoal (1 subgoal):\n 1. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "hence **: \"i - dg \\<le> j \\<Longrightarrow> dg - (j + dg - i) = i - j\""], ["proof (prove)\nusing this:\n  \\<not> i < dg\n\ngoal (1 subgoal):\n 1. i - dg \\<le> j \\<Longrightarrow> dg - (j + dg - i) = i - j", "using ij"], ["proof (prove)\nusing this:\n  \\<not> i < dg\n  i < df + dg\n  j < df + dg\n\ngoal (1 subgoal):\n 1. i - dg \\<le> j \\<Longrightarrow> dg - (j + dg - i) = i - j", "by linarith"], ["proof (state)\nthis:\n  i - dg \\<le> j \\<Longrightarrow> dg - (j + dg - i) = i - j\n\ngoal (1 subgoal):\n 1. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "have \"int dg - int j + int (i - dg) < 0 \\<longrightarrow> \\<not> j \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int dg - int j + int (i - dg) < 0 \\<longrightarrow> \\<not> j \\<le> i", "by auto"], ["proof (state)\nthis:\n  int dg - int j + int (i - dg) < 0 \\<longrightarrow> \\<not> j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> i < dg \\<Longrightarrow>\n    coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "thus \"coeff_int g (int dg - int j + int (i - dg)) = (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else 0)\""], ["proof (prove)\nusing this:\n  int dg - int j + int (i - dg) < 0 \\<longrightarrow> \\<not> j \\<le> i\n\ngoal (1 subgoal):\n 1. coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "using ij i"], ["proof (prove)\nusing this:\n  int dg - int j + int (i - dg) < 0 \\<longrightarrow> \\<not> j \\<le> i\n  i < df + dg\n  j < df + dg\n  \\<not> i < dg\n\ngoal (1 subgoal):\n 1. coeff_int g (int dg - int j + int (i - dg)) =\n    (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))", "by (simp add: coeff_int_def * **, intro impI  coeff_eq_0[of g, unfolded dg], linarith)"], ["proof (state)\nthis:\n  coeff_int g (int dg - int j + int (i - dg)) =\n  (if i - dg \\<le> j \\<and> j \\<le> i then coeff g (i - j) else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < dg then coeff_int f (int df - int j + int i)\n   else coeff_int g (int dg - int j + int (i - dg))) =\n  sylvester_mat f g $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < dg then coeff_int f (int df - int j + int i)\n   else coeff_int g (int dg - int j + int (i - dg))) =\n  sylvester_mat f g $$ (i, j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df + dg; j < df + dg\\<rbrakk>\n       \\<Longrightarrow> (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n                         sylvester_mat f g $$ (i, j)\n 2. df + dg = df + dg\n 3. df + dg = df + dg", "finally"], ["proof (chain)\npicking this:\n  (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n  sylvester_mat f g $$ (i, j)", "show ?case"], ["proof (prove)\nusing this:\n  (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n  sylvester_mat f g $$ (i, j)\n\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n    sylvester_mat f g $$ (i, j)", "."], ["proof (state)\nthis:\n  (subresultant'_mat 0 0 f g)\\<^sup>T $$ (i, j) =\n  sylvester_mat f g $$ (i, j)\n\ngoal (2 subgoals):\n 1. df + dg = df + dg\n 2. df + dg = df + dg", "qed auto"], ["proof (state)\nthis:\n  (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_subresultant_0_0_resultant: \"coeff (subresultant 0 f g) 0 = resultant f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 = resultant f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 = resultant f g", "let ?M = \"transpose_mat (subresultant'_mat 0 0 f g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 = resultant f g", "have \"det (subresultant'_mat 0 0 f g) = det ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant'_mat 0 0 f g) =\n    det (subresultant'_mat 0 0 f g)\\<^sup>T", "by (subst det_transpose, auto simp: subresultant'_mat_def Let_def)"], ["proof (state)\nthis:\n  det (subresultant'_mat 0 0 f g) = det (subresultant'_mat 0 0 f g)\\<^sup>T\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 = resultant f g", "also"], ["proof (state)\nthis:\n  det (subresultant'_mat 0 0 f g) = det (subresultant'_mat 0 0 f g)\\<^sup>T\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 = resultant f g", "have \"?M = sylvester_mat f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g", "by (rule subresultant'_mat_sylvester_mat)"], ["proof (state)\nthis:\n  (subresultant'_mat 0 0 f g)\\<^sup>T = sylvester_mat f g\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 = resultant f g", "finally"], ["proof (chain)\npicking this:\n  det (subresultant'_mat 0 0 f g) = det (sylvester_mat f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (subresultant'_mat 0 0 f g) = det (sylvester_mat f g)\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 = resultant f g", "by (simp add: coeff_subresultant resultant_def)"], ["proof (state)\nthis:\n  coeff (subresultant 0 f g) 0 = resultant f g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subresultant_zero_ge: assumes \"k \\<ge> degree f + (degree g - J)\"\n  and \"(degree f - J) + (degree g - J) \\<noteq> 0\"\n  shows \"coeff (subresultant J f g) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (subresultant J f g) k = (0::'a)", "unfolding coeff_subresultant"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree f - J + (degree g - J) = 0 \\<and> k \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J k f g)) =\n    (0::'a)", "by (subst subresultant'_zero_ge[OF assms(2,1)], simp)"], ["", "lemma subresultant_zero_lt: assumes \"k < degree f + (degree g - J)\"\n  and \"J \\<le> degree f\" \"J \\<le> degree g\" \"J < k\"\n  shows \"coeff (subresultant J f g) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (subresultant J f g) k = (0::'a)", "unfolding coeff_subresultant"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree f - J + (degree g - J) = 0 \\<and> k \\<noteq> 0 then 0::'a\n     else det (subresultant'_mat J k f g)) =\n    (0::'a)", "by (subst subresultant'_zero_lt[OF assms(2,3,4,1)], simp)"], ["", "lemma subresultant_resultant: \"subresultant 0 f g = [: resultant f g :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant 0 f g = [:resultant f g:]", "proof (cases \"degree f + degree g = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree f + degree g = 0 \\<Longrightarrow>\n    subresultant 0 f g = [:resultant f g:]\n 2. degree f + degree g \\<noteq> 0 \\<Longrightarrow>\n    subresultant 0 f g = [:resultant f g:]", "case True"], ["proof (state)\nthis:\n  degree f + degree g = 0\n\ngoal (2 subgoals):\n 1. degree f + degree g = 0 \\<Longrightarrow>\n    subresultant 0 f g = [:resultant f g:]\n 2. degree f + degree g \\<noteq> 0 \\<Longrightarrow>\n    subresultant 0 f g = [:resultant f g:]", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree f + degree g = 0\n\ngoal (1 subgoal):\n 1. subresultant 0 f g = [:resultant f g:]", "unfolding subresultant_def subresultant_mat_def resultant_def Let_def\n      sylvester_mat_def sylvester_mat_sub_def"], ["proof (prove)\nusing this:\n  degree f + degree g = 0\n\ngoal (1 subgoal):\n 1. det (mat (degree f - 0 + (degree g - 0)) (degree f - 0 + (degree g - 0))\n          (\\<lambda>(i, j).\n              if j < degree g - 0\n              then if i = degree f - 0 + (degree g - 0) - 1\n                   then monom (1::'a) (degree g - 0 - 1 - j) * f\n                   else [:coeff_int f (int (degree f) - int i + int j):]\n              else if i = degree f - 0 + (degree g - 0) - 1\n                   then monom (1::'a)\n                         (degree f - 0 - 1 - (j - (degree g - 0))) *\n                        g\n                   else [:coeff_int g\n                           (int (degree g) - int i +\n                            int (j - (degree g - 0))):])) =\n    [:det (mat (degree f + degree g) (degree f + degree g)\n            (\\<lambda>(i, j).\n                if i < degree g\n                then if i \\<le> j \\<and> j - i \\<le> degree f\n                     then coeff f (degree f + i - j) else (0::'a)\n                else if i - degree g \\<le> j \\<and> j \\<le> i\n                     then coeff g (i - j) else (0::'a))):]", "by simp"], ["proof (state)\nthis:\n  subresultant 0 f g = [:resultant f g:]\n\ngoal (1 subgoal):\n 1. degree f + degree g \\<noteq> 0 \\<Longrightarrow>\n    subresultant 0 f g = [:resultant f g:]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree f + degree g \\<noteq> 0 \\<Longrightarrow>\n    subresultant 0 f g = [:resultant f g:]", "case 0: False"], ["proof (state)\nthis:\n  degree f + degree g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f + degree g \\<noteq> 0 \\<Longrightarrow>\n    subresultant 0 f g = [:resultant f g:]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant 0 f g = [:resultant f g:]", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff (subresultant 0 f g) n = coeff [:resultant f g:] n", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff (subresultant 0 f g) n = coeff [:resultant f g:] n", "show \"coeff (subresultant 0 f g) k = coeff [:resultant f g:] k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "using coeff_subresultant_0_0_resultant[of f g]"], ["proof (prove)\nusing this:\n  k = 0\n  coeff (subresultant 0 f g) 0 = resultant f g\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "by auto"], ["proof (state)\nthis:\n  coeff (subresultant 0 f g) k = coeff [:resultant f g:] k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "hence \"0 < k \\<and> k < degree f + degree g \\<or> k \\<ge> degree f + degree g\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < k \\<and> k < degree f + degree g \\<or> degree f + degree g \\<le> k", "by auto"], ["proof (state)\nthis:\n  0 < k \\<and> k < degree f + degree g \\<or> degree f + degree g \\<le> k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < k \\<and> k < degree f + degree g \\<or> degree f + degree g \\<le> k\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "using subresultant_zero_ge[of f g 0 k] 0\n        subresultant_zero_lt[of k f g 0] 0 False"], ["proof (prove)\nusing this:\n  0 < k \\<and> k < degree f + degree g \\<or> degree f + degree g \\<le> k\n  \\<lbrakk>degree f + (degree g - 0) \\<le> k;\n   degree f - 0 + (degree g - 0) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coeff (subresultant 0 f g) k = (0::'a)\n  degree f + degree g \\<noteq> 0\n  \\<lbrakk>k < degree f + (degree g - 0); 0 \\<le> degree f;\n   0 \\<le> degree g; 0 < k\\<rbrakk>\n  \\<Longrightarrow> coeff (subresultant 0 f g) k = (0::'a)\n  degree f + degree g \\<noteq> 0\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) k = coeff [:resultant f g:] k", "by (cases k, auto)"], ["proof (state)\nthis:\n  coeff (subresultant 0 f g) k = coeff [:resultant f g:] k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (subresultant 0 f g) k = coeff [:resultant f g:] k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subresultant 0 f g = [:resultant f g:]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in inj_comm_ring_hom) subresultant_hom:\n  \"map_poly hom (subresultant J f g) = subresultant J (map_poly hom f) (map_poly hom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (subresultant J f g) =\n    subresultant J (map_poly hom f) (map_poly hom g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (subresultant J f g) =\n    subresultant J (map_poly hom f) (map_poly hom g)", "note d = subresultant_mat_def Let_def"], ["proof (state)\nthis:\n  subresultant_mat ?J ?F ?G =\n  (let dg = degree ?G; df = degree ?F; f = coeff_int ?F; g = coeff_int ?G;\n       n = df - ?J + (dg - ?J)\n   in mat n n\n       (\\<lambda>(i, j).\n           if j < dg - ?J\n           then if i = n - 1 then monom (1::?'a) (dg - ?J - 1 - j) * ?F\n                else [:f (int df - int i + int j):]\n           else let jj = j - (dg - ?J)\n                in if i = n - 1 then monom (1::?'a) (df - ?J - 1 - jj) * ?G\n                   else [:g (int dg - int i + int jj):]))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. map_poly hom (subresultant J f g) =\n    subresultant J (map_poly hom f) (map_poly hom g)", "interpret p: map_poly_inj_comm_ring_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (subresultant J f g) =\n    subresultant J (map_poly hom f) (map_poly hom g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (subresultant J f g) =\n    subresultant J (map_poly hom f) (map_poly hom g)", "unfolding subresultant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (det (subresultant_mat J f g)) =\n    det (subresultant_mat J (map_poly hom f) (map_poly hom g))", "unfolding p.hom_det[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (p.mat_hom (subresultant_mat J f g)) =\n    det (subresultant_mat J (map_poly hom f) (map_poly hom g))", "proof (rule arg_cong[of _ _ det])"], ["proof (state)\ngoal (1 subgoal):\n 1. p.mat_hom (subresultant_mat J f g) =\n    subresultant_mat J (map_poly hom f) (map_poly hom g)", "show \"p.mat_hom (subresultant_mat J f g) =\n      subresultant_mat J (map_poly hom f) (map_poly hom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.mat_hom (subresultant_mat J f g) =\n    subresultant_mat J (map_poly hom f) (map_poly hom g)", "proof (rule eq_matI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (subresultant_mat J (map_poly hom f) (map_poly hom g));\n        j < dim_col\n             (subresultant_mat J (map_poly hom f) (map_poly hom g))\\<rbrakk>\n       \\<Longrightarrow> p.mat_hom (subresultant_mat J f g) $$ (i, j) =\n                         subresultant_mat J (map_poly hom f)\n                          (map_poly hom g) $$\n                         (i, j)\n 2. dim_row (p.mat_hom (subresultant_mat J f g)) =\n    dim_row (subresultant_mat J (map_poly hom f) (map_poly hom g))\n 3. dim_col (p.mat_hom (subresultant_mat J f g)) =\n    dim_col (subresultant_mat J (map_poly hom f) (map_poly hom g))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row (subresultant_mat J (map_poly hom f) (map_poly hom g))\n  j < dim_col (subresultant_mat J (map_poly hom f) (map_poly hom g))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (subresultant_mat J (map_poly hom f) (map_poly hom g));\n        j < dim_col\n             (subresultant_mat J (map_poly hom f) (map_poly hom g))\\<rbrakk>\n       \\<Longrightarrow> p.mat_hom (subresultant_mat J f g) $$ (i, j) =\n                         subresultant_mat J (map_poly hom f)\n                          (map_poly hom g) $$\n                         (i, j)\n 2. dim_row (p.mat_hom (subresultant_mat J f g)) =\n    dim_row (subresultant_mat J (map_poly hom f) (map_poly hom g))\n 3. dim_col (p.mat_hom (subresultant_mat J f g)) =\n    dim_col (subresultant_mat J (map_poly hom f) (map_poly hom g))", "hence ij: \"i < degree f - J + (degree g - J)\" \"j < degree f - J + (degree g - J)\""], ["proof (prove)\nusing this:\n  i < dim_row (subresultant_mat J (map_poly hom f) (map_poly hom g))\n  j < dim_col (subresultant_mat J (map_poly hom f) (map_poly hom g))\n\ngoal (1 subgoal):\n 1. i < degree f - J + (degree g - J) &&& j < degree f - J + (degree g - J)", "unfolding d degree_map_poly"], ["proof (prove)\nusing this:\n  i < dim_row\n       (mat (degree (map_poly hom f) - J + (degree (map_poly hom g) - J))\n         (degree (map_poly hom f) - J + (degree (map_poly hom g) - J))\n         (\\<lambda>(i, j).\n             if j < degree (map_poly hom g) - J\n             then if i =\n                     degree (map_poly hom f) - J +\n                     (degree (map_poly hom g) - J) -\n                     1\n                  then monom (1::'b) (degree (map_poly hom g) - J - 1 - j) *\n                       map_poly hom f\n                  else [:coeff_int (map_poly hom f)\n                          (int (degree (map_poly hom f)) - int i + int j):]\n             else if i =\n                     degree (map_poly hom f) - J +\n                     (degree (map_poly hom g) - J) -\n                     1\n                  then monom (1::'b)\n                        (degree (map_poly hom f) - J - 1 -\n                         (j - (degree (map_poly hom g) - J))) *\n                       map_poly hom g\n                  else [:coeff_int (map_poly hom g)\n                          (int (degree (map_poly hom g)) - int i +\n                           int (j - (degree (map_poly hom g) - J))):]))\n  j < dim_col\n       (mat (degree (map_poly hom f) - J + (degree (map_poly hom g) - J))\n         (degree (map_poly hom f) - J + (degree (map_poly hom g) - J))\n         (\\<lambda>(i, j).\n             if j < degree (map_poly hom g) - J\n             then if i =\n                     degree (map_poly hom f) - J +\n                     (degree (map_poly hom g) - J) -\n                     1\n                  then monom (1::'b) (degree (map_poly hom g) - J - 1 - j) *\n                       map_poly hom f\n                  else [:coeff_int (map_poly hom f)\n                          (int (degree (map_poly hom f)) - int i + int j):]\n             else if i =\n                     degree (map_poly hom f) - J +\n                     (degree (map_poly hom g) - J) -\n                     1\n                  then monom (1::'b)\n                        (degree (map_poly hom f) - J - 1 -\n                         (j - (degree (map_poly hom g) - J))) *\n                       map_poly hom g\n                  else [:coeff_int (map_poly hom g)\n                          (int (degree (map_poly hom g)) - int i +\n                           int (j - (degree (map_poly hom g) - J))):]))\n\ngoal (1 subgoal):\n 1. i < degree f - J + (degree g - J) &&& j < degree f - J + (degree g - J)", "by auto"], ["proof (state)\nthis:\n  i < degree f - J + (degree g - J)\n  j < degree f - J + (degree g - J)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (subresultant_mat J (map_poly hom f) (map_poly hom g));\n        j < dim_col\n             (subresultant_mat J (map_poly hom f) (map_poly hom g))\\<rbrakk>\n       \\<Longrightarrow> p.mat_hom (subresultant_mat J f g) $$ (i, j) =\n                         subresultant_mat J (map_poly hom f)\n                          (map_poly hom g) $$\n                         (i, j)\n 2. dim_row (p.mat_hom (subresultant_mat J f g)) =\n    dim_row (subresultant_mat J (map_poly hom f) (map_poly hom g))\n 3. dim_col (p.mat_hom (subresultant_mat J f g)) =\n    dim_col (subresultant_mat J (map_poly hom f) (map_poly hom g))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p.mat_hom (subresultant_mat J f g) $$ (i, j) =\n    subresultant_mat J (map_poly hom f) (map_poly hom g) $$ (i, j)", "by (auto simp add: coeff_int_def d map_mat_def index_mat(1)[OF ij] hom_distribs)"], ["proof (state)\nthis:\n  p.mat_hom (subresultant_mat J f g) $$ (i, j) =\n  subresultant_mat J (map_poly hom f) (map_poly hom g) $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row (p.mat_hom (subresultant_mat J f g)) =\n    dim_row (subresultant_mat J (map_poly hom f) (map_poly hom g))\n 2. dim_col (p.mat_hom (subresultant_mat J f g)) =\n    dim_col (subresultant_mat J (map_poly hom f) (map_poly hom g))", "qed (auto simp: d)"], ["proof (state)\nthis:\n  p.mat_hom (subresultant_mat J f g) =\n  subresultant_mat J (map_poly hom f) (map_poly hom g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_poly hom (subresultant J f g) =\n  subresultant J (map_poly hom f) (map_poly hom g)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now derive properties of the resultant via the connection to subresultants.\\<close>"], ["", "lemma resultant_smult_left: assumes \"(c :: 'a :: idom) \\<noteq> 0\"\n  shows \"resultant (smult c f) g = c ^ degree g * resultant f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant (Polynomial.smult c f) g = c ^ degree g * resultant f g", "unfolding coeff_subresultant_0_0_resultant[symmetric] subresultant_smult_left[OF assms] coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. c ^ (degree g - 0) * coeff (subresultant 0 f g) 0 =\n    c ^ degree g * coeff (subresultant 0 f g) 0", "by simp"], ["", "lemma resultant_smult_right: assumes \"(c :: 'a :: idom) \\<noteq> 0\"\n  shows \"resultant f (smult c g) = c ^ degree f * resultant f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant f (Polynomial.smult c g) = c ^ degree f * resultant f g", "unfolding coeff_subresultant_0_0_resultant[symmetric] subresultant_smult_right[OF assms] coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. c ^ (degree f - 0) * coeff (subresultant 0 f g) 0 =\n    c ^ degree f * coeff (subresultant 0 f g) 0", "by simp"], ["", "lemma resultant_swap: \"resultant f g = (-1)^(degree f * degree g) * (resultant g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant f g = (- (1::'a)) ^ (degree f * degree g) * resultant g f", "unfolding coeff_subresultant_0_0_resultant[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (subresultant 0 f g) 0 =\n    (- (1::'a)) ^ (degree f * degree g) * coeff (subresultant 0 g f) 0", "unfolding arg_cong[OF subresultant_swap[of 0 f g], of \"\\<lambda> x. coeff x 0\"] coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ ((degree f - 0) * (degree g - 0)) *\n    coeff (subresultant 0 g f) 0 =\n    (- (1::'a)) ^ (degree f * degree g) * coeff (subresultant 0 g f) 0", "by simp"], ["", "text \\<open>The following equations are taken from Brown-Traub ``On Euclid's Algorithm and\nthe Theory of Subresultant'' (BT)\\<close>"], ["", "lemma  fixes F B G H :: \"'a :: idom poly\" and J :: nat\n       defines df: \"df \\<equiv> degree F\"\n  and dg: \"dg \\<equiv> degree G\"\n  and dh: \"dh \\<equiv> degree H\"\n  and db: \"db \\<equiv> degree B\"\n  defines\n    n: \"n \\<equiv> (df - J) + (dg - J)\"\n  and f: \"f \\<equiv> coeff_int F\"\n  and b: \"b \\<equiv> coeff_int B\"\n  and g: \"g \\<equiv> coeff_int G\"\n  and h: \"h \\<equiv> coeff_int H\"\n  assumes FGH: \"F + B * G = H\"\n  and dfg: \"df \\<ge> dg\"\n  and choice: \"dg > dh \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\"\nshows BT_eq_18: \"subresultant J F G = smult ((-1)^((df - J) * (dg - J))) (det (mat n n\n  (\\<lambda> (i,j).\n              if j < df - J\n              then if i = n - 1 then monom 1 ((df - J) - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom 1 ((dg - J) - 1 - (j - (df - J))) * H\n                   else [:h (int df - int i + int (j - (df - J))):])))\"\n   (is \"_ = smult ?m1 ?right\")\n  and BT_eq_19: \"dh \\<le> J \\<Longrightarrow> J < dg \\<Longrightarrow> subresultant J F G = smult (\n    (-1)^((df - J) * (dg - J)) * lead_coeff G ^ (df - J) * coeff H J ^ (dg - J - 1)) H\"\n    (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> _ = smult (_ * ?G * ?H) H\")\n  and BT_lemma_1_12: \"J < dh \\<Longrightarrow> subresultant J F G = smult (\n    (-1)^((df - J) * (dg - J)) * lead_coeff G ^ (df - dh)) (subresultant J G H)\"\n  and BT_lemma_1_13': \"J = dh \\<Longrightarrow> dg > dh \\<or> H \\<noteq> 0 \\<Longrightarrow> subresultant dh F G = smult (\n    (-1)^((df - dh) * (dg - dh)) * lead_coeff G ^ (df - dh) * lead_coeff H ^ (dg - dh - 1)) H\"\n  and BT_lemma_1_14: \"dh < J \\<Longrightarrow> J < dg - 1 \\<Longrightarrow> subresultant J F G = 0\"\n  and BT_lemma_1_15': \"J = dg - 1 \\<Longrightarrow> dg > dh \\<or> H \\<noteq> 0 \\<Longrightarrow> subresultant (dg - 1) F G = smult (\n    (-1)^(df - dg + 1) * lead_coeff G ^ (df - dg + 1)) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subresultant J F G =\n     Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n      (det (mat n n\n             (\\<lambda>(i, j).\n                 if j < df - J\n                 then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                      else [:h (int df - int i +\n                                int (j - (df - J))):]))) &&&\n     (\\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n      \\<Longrightarrow> subresultant J F G =\n                        Polynomial.smult\n                         ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                          lead_coeff G ^ (df - J) *\n                          coeff H J ^ (dg - J - 1))\n                         H) &&&\n     (J < dh \\<Longrightarrow>\n      subresultant J F G =\n      Polynomial.smult\n       ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n       (subresultant J G H))) &&&\n    (\\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> subresultant dh F G =\n                       Polynomial.smult\n                        ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                         lead_coeff G ^ (df - dh) *\n                         lead_coeff H ^ (dg - dh - 1))\n                        H) &&&\n    (\\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n     \\<Longrightarrow> subresultant J F G = 0) &&&\n    (\\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> subresultant (dg - 1) F G =\n                       Polynomial.smult\n                        ((- (1::'a)) ^ (df - dg + 1) *\n                         lead_coeff G ^ (df - dg + 1))\n                        H)", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "define dfj where \"dfj = df - J\""], ["proof (state)\nthis:\n  dfj = df - J\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "define dgj where \"dgj = dg - J\""], ["proof (state)\nthis:\n  dgj = dg - J\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note d = df dg dh db"], ["proof (state)\nthis:\n  df \\<equiv> degree F\n  dg \\<equiv> degree G\n  dh \\<equiv> degree H\n  db \\<equiv> degree B\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have F0: \"F \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<noteq> 0", "using dfg choice df"], ["proof (prove)\nusing this:\n  dg \\<le> df\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  df \\<equiv> degree F\n\ngoal (1 subgoal):\n 1. F \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F \\<noteq> 0\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have G0: \"G \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "using choice dg"], ["proof (prove)\nusing this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  dg \\<equiv> degree G\n\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  G \\<noteq> 0\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have dgh: \"dg \\<ge> dh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dh \\<le> dg", "using choice"], ["proof (prove)\nusing this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dh \\<le> dg", "unfolding dh"], ["proof (prove)\nusing this:\n  degree H < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree H \\<le> dg", "by auto"], ["proof (state)\nthis:\n  dh \\<le> dg\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have B0: \"B \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<noteq> 0", "using FGH dfg dgh choice F0 G0"], ["proof (prove)\nusing this:\n  F + B * G = H\n  dg \\<le> df\n  dh \\<le> dg\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  F \\<noteq> 0\n  G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B \\<noteq> 0", "unfolding d"], ["proof (prove)\nusing this:\n  F + B * G = H\n  degree G \\<le> degree F\n  degree H \\<le> degree G\n  degree H < degree G \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  F \\<noteq> 0\n  G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  B \\<noteq> 0\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have dfh: \"df \\<ge> dh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dh \\<le> df", "using dfg dgh"], ["proof (prove)\nusing this:\n  dg \\<le> df\n  dh \\<le> dg\n\ngoal (1 subgoal):\n 1. dh \\<le> df", "by auto"], ["proof (state)\nthis:\n  dh \\<le> df\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"df = degree (B * G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. df = degree (B * G)", "proof (cases \"H = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. H = 0 \\<Longrightarrow> df = degree (B * G)\n 2. H \\<noteq> 0 \\<Longrightarrow> df = degree (B * G)", "case False"], ["proof (state)\nthis:\n  H \\<noteq> 0\n\ngoal (2 subgoals):\n 1. H = 0 \\<Longrightarrow> df = degree (B * G)\n 2. H \\<noteq> 0 \\<Longrightarrow> df = degree (B * G)", "with choice dfg"], ["proof (chain)\npicking this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  dg \\<le> df\n  H \\<noteq> 0", "have dfh: \"df > dh\""], ["proof (prove)\nusing this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  dg \\<le> df\n  H \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dh < df", "by auto"], ["proof (state)\nthis:\n  dh < df\n\ngoal (2 subgoals):\n 1. H = 0 \\<Longrightarrow> df = degree (B * G)\n 2. H \\<noteq> 0 \\<Longrightarrow> df = degree (B * G)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. df = degree (B * G)", "using dfh[folded arg_cong[OF FGH, of degree, folded dh]] choice"], ["proof (prove)\nusing this:\n  degree (F + B * G) < df\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. df = degree (B * G)", "unfolding df"], ["proof (prove)\nusing this:\n  degree (F + B * G) < degree F\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree F = degree (B * G)", "by (metis \\<open>degree (F + B * G) < df\\<close> degree_add_eq_left degree_add_eq_right df nat_neq_iff)"], ["proof (state)\nthis:\n  df = degree (B * G)\n\ngoal (1 subgoal):\n 1. H = 0 \\<Longrightarrow> df = degree (B * G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H = 0 \\<Longrightarrow> df = degree (B * G)", "case True"], ["proof (state)\nthis:\n  H = 0\n\ngoal (1 subgoal):\n 1. H = 0 \\<Longrightarrow> df = degree (B * G)", "have \"F = - B * G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = - B * G", "using arg_cong[OF FGH[unfolded True], of \"\\<lambda> x. x - B * G\"]"], ["proof (prove)\nusing this:\n  F + B * G - B * G = 0 - B * G\n\ngoal (1 subgoal):\n 1. F = - B * G", "by auto"], ["proof (state)\nthis:\n  F = - B * G\n\ngoal (1 subgoal):\n 1. H = 0 \\<Longrightarrow> df = degree (B * G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  F = - B * G\n\ngoal (1 subgoal):\n 1. df = degree (B * G)", "using F0 G0 B0"], ["proof (prove)\nusing this:\n  F = - B * G\n  F \\<noteq> 0\n  G \\<noteq> 0\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. df = degree (B * G)", "unfolding df"], ["proof (prove)\nusing this:\n  F = - B * G\n  F \\<noteq> 0\n  G \\<noteq> 0\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree F = degree (B * G)", "by simp"], ["proof (state)\nthis:\n  df = degree (B * G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  df = degree (B * G)\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "hence dfbg: \"df = db + dg\""], ["proof (prove)\nusing this:\n  df = degree (B * G)\n\ngoal (1 subgoal):\n 1. df = db + dg", "using degree_mult_eq[OF B0 G0]"], ["proof (prove)\nusing this:\n  df = degree (B * G)\n  degree (B * G) = degree B + degree G\n\ngoal (1 subgoal):\n 1. df = db + dg", "by (simp add: d)"], ["proof (state)\nthis:\n  df = db + dg\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "hence dbfg: \"db = df - dg\""], ["proof (prove)\nusing this:\n  df = db + dg\n\ngoal (1 subgoal):\n 1. db = df - dg", "by simp"], ["proof (state)\nthis:\n  db = df - dg\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?dfj = \"df - J\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?dgj = \"dg - J\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have norm: \"?dgj + ?dfj = ?dfj + ?dgj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dg - J + (df - J) = df - J + (dg - J)", "by simp"], ["proof (state)\nthis:\n  dg - J + (df - J) = df - J + (dg - J)\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?bij = \"\\<lambda> i j. b (db - int i + int (j - dfj))\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?M = \"mat n n (\\<lambda> (i,j). if i = j then 1 else if j < dfj then 0 else if i < j\n    then [:  ?bij i j :] else 0)\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "(* this is the matrix which contains all the column-operations\n     that are required to transform the subresultant-matrix of F and G into the one of G and H (\n     the matrix depicted in equation (18) in BT *)"], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?GF = \"\\<lambda> i j.\n              if j < dfj\n              then if i = n - 1 then monom 1 (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom 1 (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?G_F = \"mat n n (\\<lambda> (i,j). ?GF i j)\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?GH = \"\\<lambda> i j.\n              if j < dfj\n              then if i = n - 1 then monom 1 (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom 1 (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):]\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?G_H = \"mat n n (\\<lambda> (i,j). ?GH i j)\""], ["proof (state)\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have hfg: \"h i = f i + coeff_int (B * G) i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. h i = f i + coeff_int (B * G) i", "unfolding FGH[symmetric] f g h"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int (F + B * G) i = coeff_int F i + coeff_int (B * G) i", "unfolding coeff_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < 0 then 0::'a else coeff (F + B * G) (nat i)) =\n    (if i < 0 then 0::'a else coeff F (nat i)) +\n    (if i < 0 then 0::'a else coeff (B * G) (nat i))", "by simp"], ["proof (state)\nthis:\n  h ?i = f ?i + coeff_int (B * G) ?i\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have dM1: \"det ?M = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0)) =\n    1", "by (subst det_upper_triangular, (auto)[2], subst prod_list_diag_prod, auto)"], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0)) =\n  1\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"subresultant J F G = smult ?m1 (subresultant J G F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (subresultant J G F)", "unfolding subresultant_swap[of _ F] d"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ ((degree F - J) * (degree G - J)))\n     (subresultant J G F) =\n    Polynomial.smult ((- (1::'a)) ^ ((degree F - J) * (degree G - J)))\n     (subresultant J G F)", "by simp"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (subresultant J G F)\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (subresultant J G F)\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"subresultant J G F = det ?G_F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J G F =\n    det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))", "unfolding subresultant_def n norm subresultant_mat_def g f Let_def d[symmetric] dfj_def dgj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (df - J + (dg - J)) (df - J + (dg - J))\n          (\\<lambda>(i, j).\n              if j < df - J\n              then if i = df - J + (dg - J) - 1\n                   then monom (1::'a) (df - J - 1 - j) * G\n                   else [:coeff_int G (int dg - int i + int j):]\n              else if i = df - J + (dg - J) - 1\n                   then monom (1::'a) (dg - J - 1 - (j - (df - J))) * F\n                   else [:coeff_int F\n                           (int df - int i + int (j - (df - J))):])) =\n    det (mat (df - J + (dg - J)) (df - J + (dg - J))\n          (\\<lambda>(i, j).\n              if j < df - J\n              then if i = df - J + (dg - J) - 1\n                   then monom (1::'a) (df - J - 1 - j) * G\n                   else [:coeff_int G (int dg - int i + int j):]\n              else if i = df - J + (dg - J) - 1\n                   then monom (1::'a) (dg - J - 1 - (j - (df - J))) * F\n                   else [:coeff_int F\n                           (int df - int i + int (j - (df - J))):]))", "by simp"], ["proof (state)\nthis:\n  subresultant J G F =\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  subresultant J G F =\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = det (?G_F * ?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):])) =\n    det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]) *\n         mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))", "by (subst det_mult[of _ n], unfold dM1, auto)"], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):])) =\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]) *\n       mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):])) =\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]) *\n       mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"?G_F * ?M = ?G_H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n              else [:f (int df - int i + int (j - dfj)):]) *\n    mat n n\n     (\\<lambda>(i, j).\n         if i = j then 1\n         else if j < dfj then 0\n              else if i < j then [:b (int db - int i + int (j - dfj)):]\n                   else 0) =\n    mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])", "proof (rule eq_matI, unfold dim_col_mat dim_row_mat)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "assume i: \"i < n\" and j: \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "have \"(?G_F * ?M) $$ (i,j) = row (?G_F) i \\<bullet> col ?M j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat n n\n      (\\<lambda>(i, j).\n          if j < dfj\n          then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n               else [:g (int dg - int i + int j):]\n          else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n               else [:f (int df - int i + int (j - dfj)):]) *\n     mat n n\n      (\\<lambda>(i, j).\n          if i = j then 1\n          else if j < dfj then 0\n               else if i < j then [:b (int db - int i + int (j - dfj)):]\n                    else 0)) $$\n    (i, j) =\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j", "using i j"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. (mat n n\n      (\\<lambda>(i, j).\n          if j < dfj\n          then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n               else [:g (int dg - int i + int j):]\n          else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n               else [:f (int df - int i + int (j - dfj)):]) *\n     mat n n\n      (\\<lambda>(i, j).\n          if i = j then 1\n          else if j < dfj then 0\n               else if i < j then [:b (int db - int i + int (j - dfj)):]\n                    else 0)) $$\n    (i, j) =\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j", "by simp"], ["proof (state)\nthis:\n  (mat n n\n    (\\<lambda>(i, j).\n        if j < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n             else [:g (int dg - int i + int j):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n             else [:f (int df - int i + int (j - dfj)):]) *\n   mat n n\n    (\\<lambda>(i, j).\n        if i = j then 1\n        else if j < dfj then 0\n             else if i < j then [:b (int db - int i + int (j - dfj)):]\n                  else 0)) $$\n  (i, j) =\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "also"], ["proof (state)\nthis:\n  (mat n n\n    (\\<lambda>(i, j).\n        if j < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n             else [:g (int dg - int i + int j):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n             else [:f (int df - int i + int (j - dfj)):]) *\n   mat n n\n    (\\<lambda>(i, j).\n        if i = j then 1\n        else if j < dfj then 0\n             else if i < j then [:b (int db - int i + int (j - dfj)):]\n                  else 0)) $$\n  (i, j) =\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "have \"\\<dots> = ?GH i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "proof (cases \"j < dfj\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])\n 2. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "case True"], ["proof (state)\nthis:\n  j < dfj\n\ngoal (2 subgoals):\n 1. j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])\n 2. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have id: \"col ?M j = unit_vec n j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    unit_vec n j", "by (rule eq_vecI, insert True i j, auto)"], ["proof (state)\nthis:\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  unit_vec n j\n\ngoal (2 subgoals):\n 1. j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])\n 2. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    unit_vec n j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "using True i j"], ["proof (prove)\nusing this:\n  j < dfj\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    unit_vec n j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "by simp"], ["proof (state)\nthis:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "case False"], ["proof (state)\nthis:\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "define d where \"d = j - dfj\""], ["proof (state)\nthis:\n  d = j - dfj\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "from False"], ["proof (chain)\npicking this:\n  \\<not> j < dfj", "have jd: \"j = d + dfj\""], ["proof (prove)\nusing this:\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. j = d + dfj", "unfolding d_def"], ["proof (prove)\nusing this:\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. j = j - dfj + dfj", "by auto"], ["proof (state)\nthis:\n  j = d + dfj\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "hence idj: \"{0 ..< j} = {0 ..< dfj} \\<union> {dfj ..< dfj + d}\""], ["proof (prove)\nusing this:\n  j = d + dfj\n\ngoal (1 subgoal):\n 1. {0..<j} = {0..<dfj} \\<union> {dfj..<dfj + d}", "by auto"], ["proof (state)\nthis:\n  {0..<j} = {0..<dfj} \\<union> {dfj..<dfj + d}\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?H = \"(if i = n - 1 then monom 1 (dgj - Suc d) * H else [:h (int df - int i + int d):])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have idr: \"?GH i j = ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n     else [:h (int df - int i + int d):])", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    (if i = n - 1 then monom (1::'a) (dgj - Suc (j - dfj)) * H\n     else [:h (int df - int i + int (j - dfj)):])", "using jd"], ["proof (prove)\nusing this:\n  j = d + dfj\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    (if i = n - 1 then monom (1::'a) (dgj - Suc (j - dfj)) * H\n     else [:h (int df - int i + int (j - dfj)):])", "by auto"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n   else [:h (int df - int i + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?bi = \"\\<lambda> i. b (db - int i + int d)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?m = \"\\<lambda> i. if i = j then 1 else if i < j then [:?bij i j:] else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?P = \"\\<lambda> k. (?GF i k * ?m k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?Q = \"\\<lambda> k. ?GF i k * [: ?bi k :]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?G = \"\\<lambda> k. if i = n - 1 then monom 1 (dfj - 1 - k) * G else [:g (int dg - int i + int k):]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?Gb = \"\\<lambda> k. ?G k * [:?bi k:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?off = \"- (int db - int dfj + 1 + int d)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have off0: \"?off \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> - (int db - int dfj + 1 + int d)", "using False dfg j"], ["proof (prove)\nusing this:\n  \\<not> j < dfj\n  dg \\<le> df\n  j < n\n\ngoal (1 subgoal):\n 1. 0 \\<le> - (int db - int dfj + 1 + int d)", "unfolding dfj_def d_def dbfg n"], ["proof (prove)\nusing this:\n  \\<not> j < df - J\n  dg \\<le> df\n  j < df - J + (dg - J)\n\ngoal (1 subgoal):\n 1. 0 \\<le> - (int (df - dg) - int (df - J) + 1 + int (j - (df - J)))", "by simp"], ["proof (state)\nthis:\n  0 \\<le> - (int db - int dfj + 1 + int d)\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "from nat_0_le[OF this]"], ["proof (chain)\npicking this:\n  int (nat (- (int db - int dfj + 1 + int d))) =\n  - (int db - int dfj + 1 + int d)", "obtain off where off: \"int off = ?off\""], ["proof (prove)\nusing this:\n  int (nat (- (int db - int dfj + 1 + int d))) =\n  - (int db - int dfj + 1 + int d)\n\ngoal (1 subgoal):\n 1. (\\<And>off.\n        int off = - (int db - int dfj + 1 + int d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  int off = - (int db - int dfj + 1 + int d)\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"int off \\<le> int dfj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int off \\<le> int dfj", "unfolding off"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (int db - int dfj + 1 + int d) \\<le> int dfj", "by auto"], ["proof (state)\nthis:\n  int off \\<le> int dfj\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "hence \"off \\<le> dfj\""], ["proof (prove)\nusing this:\n  int off \\<le> int dfj\n\ngoal (1 subgoal):\n 1. off \\<le> dfj", "by simp"], ["proof (state)\nthis:\n  off \\<le> dfj\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "hence split1: \"{0 ..< dfj} = {0 ..< off} \\<union> {off ..< dfj}\""], ["proof (prove)\nusing this:\n  off \\<le> dfj\n\ngoal (1 subgoal):\n 1. {0..<dfj} = {0..<off} \\<union> {off..<dfj}", "by auto"], ["proof (state)\nthis:\n  {0..<dfj} = {0..<off} \\<union> {off..<dfj}\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"int off + Suc db \\<le> dfj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int off + int (Suc db) \\<le> int dfj", "unfolding off"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (int db - int dfj + 1 + int d) + int (Suc db) \\<le> int dfj", "by auto"], ["proof (state)\nthis:\n  int off + int (Suc db) \\<le> int dfj\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "hence split2: \"{off ..< dfj} = {off .. off + db} \\<union> {off + Suc db ..< dfj} \""], ["proof (prove)\nusing this:\n  int off + int (Suc db) \\<le> int dfj\n\ngoal (1 subgoal):\n 1. {off..<dfj} = {off..off + db} \\<union> {off + Suc db..<dfj}", "by auto"], ["proof (state)\nthis:\n  {off..<dfj} = {off..off + db} \\<union> {off + Suc db..<dfj}\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?g_b = \"\\<lambda>k. (if i = n - 1 then monom 1 k * G else [:g (int dg - int i + int (dfj - Suc k)):]) *\n            [:b (k - int off):]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?gb = \"\\<lambda>k. (if i = n - 1 then monom 1 (k + off) * G else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n            [:coeff B k:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?F = \"\\<lambda> k. if i = n - 1 then monom 1 (dgj - 1 - (k - dfj)) * F\n                   else [:f (int df - int i + int (k - dfj)):]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?Fb = \"\\<lambda> k. ?F k * [:?bi k:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?Pj = \"if i = n - 1 then  monom 1 (dgj - Suc d) * F else [:f (int df - int i + int d):]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "from False"], ["proof (chain)\npicking this:\n  \\<not> j < dfj", "have id: \"col ?M j = vec n ?m\""], ["proof (prove)\nusing this:\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    vec n\n     (\\<lambda>i.\n         if i = j then 1\n         else if i < j then [:b (int db - int i + int (j - dfj)):] else 0)", "using j i"], ["proof (prove)\nusing this:\n  \\<not> j < dfj\n  j < n\n  i < n\n\ngoal (1 subgoal):\n 1. col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    vec n\n     (\\<lambda>i.\n         if i = j then 1\n         else if i < j then [:b (int db - int i + int (j - dfj)):] else 0)", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  vec n\n   (\\<lambda>i.\n       if i = j then 1\n       else if i < j then [:b (int db - int i + int (j - dfj)):] else 0)\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"row ?G_F i \\<bullet> col ?M j = sum ?P {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (\\<Sum>k = 0..<n.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        (if k = j then 1\n         else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))", "using i j"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (\\<Sum>k = 0..<n.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        (if k = j then 1\n         else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))", "unfolding id"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    vec n\n     (\\<lambda>i.\n         if i = j then 1\n         else if i < j then [:b (int db - int i + int (j - dfj)):] else 0) =\n    (\\<Sum>k = 0..<n.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        (if k = j then 1\n         else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))", "by (simp add: scalar_prod_def)"], ["proof (state)\nthis:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  (\\<Sum>k = 0..<n.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  (\\<Sum>k = 0..<n.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"{0 ..< n} = {0 ..< j} \\<union> {j} \\<union> {Suc j ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} = {0..<j} \\<union> {j} \\<union> {Suc j..<n}", "using j"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. {0..<n} = {0..<j} \\<union> {j} \\<union> {Suc j..<n}", "by auto"], ["proof (state)\nthis:\n  {0..<n} = {0..<j} \\<union> {j} \\<union> {Suc j..<n}\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  {0..<n} = {0..<j} \\<union> {j} \\<union> {Suc j..<n}\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?P \\<dots> = sum ?P {0 ..< j} + ?P j + sum ?P {Suc j ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{0..<j} \\<union> {j} \\<union> {Suc j..<n}.\n       (if k < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n             else [:g (int dg - int i + int k):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n             else [:f (int df - int i + int (k - dfj)):]) *\n       (if k = j then 1\n        else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) =\n    (\\<Sum>k = 0..<j.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        (if k = j then 1\n         else if k < j then [:b (int db - int k + int (j - dfj)):]\n              else 0)) +\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n          else [:f (int df - int i + int (j - dfj)):]) *\n    (if j = j then 1\n     else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) +\n    (\\<Sum>k = Suc j..<n.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        (if k = j then 1\n         else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))", "by (simp add: sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{0..<j} \\<union> {j} \\<union> {Suc j..<n}.\n     (if k < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n           else [:g (int dg - int i + int k):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n           else [:f (int df - int i + int (k - dfj)):]) *\n     (if k = j then 1\n      else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) =\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) +\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n        else [:f (int df - int i + int (j - dfj)):]) *\n  (if j = j then 1\n   else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) +\n  (\\<Sum>k = Suc j..<n.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{0..<j} \\<union> {j} \\<union> {Suc j..<n}.\n     (if k < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n           else [:g (int dg - int i + int k):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n           else [:f (int df - int i + int (k - dfj)):]) *\n     (if k = j then 1\n      else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) =\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) +\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n        else [:f (int df - int i + int (j - dfj)):]) *\n  (if j = j then 1\n   else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) +\n  (\\<Sum>k = Suc j..<n.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0))\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?P {Suc j ..< n} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = Suc j..<n.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        (if k = j then 1\n         else if k < j then [:b (int db - int k + int (j - dfj)):]\n              else 0)) =\n    0", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = Suc j..<n.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = Suc j..<n.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"?P j = ?Pj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n          else [:f (int df - int i + int (j - dfj)):]) *\n    (if j = j then 1\n     else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) =\n    (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n     else [:f (int df - int i + int d):])", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n          else [:f (int df - int i + int (j - dfj)):]) *\n    (if j = j then 1\n     else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) =\n    (if i = n - 1 then monom (1::'a) (dgj - Suc (j - dfj)) * F\n     else [:f (int df - int i + int (j - dfj)):])", "using jd"], ["proof (prove)\nusing this:\n  j = d + dfj\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n          else [:f (int df - int i + int (j - dfj)):]) *\n    (if j = j then 1\n     else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) =\n    (if i = n - 1 then monom (1::'a) (dgj - Suc (j - dfj)) * F\n     else [:f (int df - int i + int (j - dfj)):])", "by simp"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n        else [:f (int df - int i + int (j - dfj)):]) *\n  (if j = j then 1\n   else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) =\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n   else [:f (int df - int i + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n        else [:f (int df - int i + int (j - dfj)):]) *\n  (if j = j then 1\n   else if j < j then [:b (int db - int j + int (j - dfj)):] else 0) =\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n   else [:f (int df - int i + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?P {0 ..< j} = sum ?Q {0 ..< j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<j.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        (if k = j then 1\n         else if k < j then [:b (int db - int k + int (j - dfj)):]\n              else 0)) =\n    (\\<Sum>k = 0..<j.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):])", "by (rule sum.cong[OF refl], unfold d_def, insert jd, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) =\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      (if k = j then 1\n       else if k < j then [:b (int db - int k + int (j - dfj)):] else 0)) =\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?Q {0 ..< j} = sum ?Q {0 ..< dfj} + sum ?Q {dfj ..< dfj+d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<j.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):]) =\n    (\\<Sum>k = 0..<dfj.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):]) +\n    (\\<Sum>k = dfj..<dfj + d.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):])", "unfolding idj"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{0..<dfj} \\<union> {dfj..<dfj + d}.\n       (if k < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n             else [:g (int dg - int i + int k):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n             else [:f (int df - int i + int (k - dfj)):]) *\n       [:b (int db - int k + int d):]) =\n    (\\<Sum>k = 0..<dfj.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):]) +\n    (\\<Sum>k = dfj..<dfj + d.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):])", "by (simp add: sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = 0..<dfj.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) +\n  (\\<Sum>k = dfj..<dfj + d.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<j.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = 0..<dfj.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) +\n  (\\<Sum>k = dfj..<dfj + d.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?Q {0 ..< dfj} = sum ?Gb {0 ..< dfj}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<dfj.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):]) =\n    (\\<Sum>k = 0..<dfj.\n        (if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n         else [:g (int dg - int i + int k):]) *\n        [:b (int db - int k + int d):])", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<dfj.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n       else [:g (int dg - int i + int k):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<dfj.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n       else [:g (int dg - int i + int k):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?Q {dfj ..< dfj+d} = sum ?Fb {dfj ..< dfj+d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = dfj..<dfj + d.\n        (if k < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n              else [:g (int dg - int i + int k):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n              else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):]) =\n    (\\<Sum>k = dfj..<dfj + d.\n        (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n         else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):])", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = dfj..<dfj + d.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = dfj..<dfj + d.\n      (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n       else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = dfj..<dfj + d.\n      (if k < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n            else [:g (int dg - int i + int k):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n            else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = dfj..<dfj + d.\n      (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n       else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = dfj..<dfj + d.\n        (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n         else [:f (int df - int i + int (k - dfj)):]) *\n        [:b (int db - int k + int d):]) =\n    0", "proof (rule sum.neutral, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dfj..<dfj + d} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dgj - 1 - (x - dfj)) * F\n        else [:f (int df - int i + int (x - dfj)):]) *\n       [:b (int db - int x + int d):] =\n       0", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dfj..<dfj + d} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dgj - 1 - (x - dfj)) * F\n        else [:f (int df - int i + int (x - dfj)):]) *\n       [:b (int db - int x + int d):] =\n       0", "assume k: \"k \\<in> {dfj ..< dfj+d}\""], ["proof (state)\nthis:\n  k \\<in> {dfj..<dfj + d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dfj..<dfj + d} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dgj - 1 - (x - dfj)) * F\n        else [:f (int df - int i + int (x - dfj)):]) *\n       [:b (int db - int x + int d):] =\n       0", "hence k: \"db + d < k\""], ["proof (prove)\nusing this:\n  k \\<in> {dfj..<dfj + d}\n\ngoal (1 subgoal):\n 1. db + d < k", "using k j False"], ["proof (prove)\nusing this:\n  k \\<in> {dfj..<dfj + d}\n  k \\<in> {dfj..<dfj + d}\n  j < n\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. db + d < k", "unfolding n db[symmetric] dfbg dfj_def d_def"], ["proof (prove)\nusing this:\n  k \\<in> {db + dg - J..<db + dg - J + (j - (db + dg - J))}\n  k \\<in> {db + dg - J..<db + dg - J + (j - (db + dg - J))}\n  j < db + dg - J + (dg - J)\n  \\<not> j < db + dg - J\n\ngoal (1 subgoal):\n 1. db + (j - (db + dg - J)) < k", "by auto"], ["proof (state)\nthis:\n  db + d < k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dfj..<dfj + d} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dgj - 1 - (x - dfj)) * F\n        else [:f (int df - int i + int (x - dfj)):]) *\n       [:b (int db - int x + int d):] =\n       0", "let ?k = \"(int db - int k + int d)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dfj..<dfj + d} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dgj - 1 - (x - dfj)) * F\n        else [:f (int df - int i + int (x - dfj)):]) *\n       [:b (int db - int x + int d):] =\n       0", "have \"?k < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int db - int k + int d < 0", "using k"], ["proof (prove)\nusing this:\n  db + d < k\n\ngoal (1 subgoal):\n 1. int db - int k + int d < 0", "by auto"], ["proof (state)\nthis:\n  int db - int k + int d < 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dfj..<dfj + d} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dgj - 1 - (x - dfj)) * F\n        else [:f (int df - int i + int (x - dfj)):]) *\n       [:b (int db - int x + int d):] =\n       0", "hence \"b ?k = 0\""], ["proof (prove)\nusing this:\n  int db - int k + int d < 0\n\ngoal (1 subgoal):\n 1. b (int db - int k + int d) = (0::'a)", "unfolding b"], ["proof (prove)\nusing this:\n  int db - int k + int d < 0\n\ngoal (1 subgoal):\n 1. coeff_int B (int db - int k + int d) = (0::'a)", "by (intro coeff_int_eq_0, auto)"], ["proof (state)\nthis:\n  b (int db - int k + int d) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dfj..<dfj + d} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dgj - 1 - (x - dfj)) * F\n        else [:f (int df - int i + int (x - dfj)):]) *\n       [:b (int db - int x + int d):] =\n       0", "thus \"?Fb k = 0\""], ["proof (prove)\nusing this:\n  b (int db - int k + int d) = (0::'a)\n\ngoal (1 subgoal):\n 1. (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n     else [:f (int df - int i + int (k - dfj)):]) *\n    [:b (int db - int k + int d):] =\n    0", "by simp"], ["proof (state)\nthis:\n  (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n   else [:f (int df - int i + int (k - dfj)):]) *\n  [:b (int db - int k + int d):] =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = dfj..<dfj + d.\n      (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n       else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = dfj..<dfj + d.\n      (if i = n - 1 then monom (1::'a) (dgj - 1 - (k - dfj)) * F\n       else [:f (int df - int i + int (k - dfj)):]) *\n      [:b (int db - int k + int d):]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?Gb {0 ..< dfj} = sum ?g_b {0 ..< dfj}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<dfj.\n        (if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n         else [:g (int dg - int i + int k):]) *\n        [:b (int db - int k + int d):]) =\n    (\\<Sum>k = 0..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):])", "proof (rule sum.reindex_cong[of \"\\<lambda> k. dfj - Suc k\"], (auto simp: inj_on_def off)[2], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x < dfj \\<Longrightarrow>\n       x \\<in> (\\<lambda>k. dfj - Suc k) ` {0..<dfj}\n 2. \\<And>x.\n       x \\<in> {0..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc x)) * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int db - int (dfj - Suc x) + int d):] =\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):]", "case (1 k)"], ["proof (state)\nthis:\n  k < dfj\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x < dfj \\<Longrightarrow>\n       x \\<in> (\\<lambda>k. dfj - Suc k) ` {0..<dfj}\n 2. \\<And>x.\n       x \\<in> {0..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc x)) * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int db - int (dfj - Suc x) + int d):] =\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):]", "hence \"k = dfj - (Suc (dfj - Suc k))\" and \"(dfj - Suc k) \\<in> {0..<dfj}\""], ["proof (prove)\nusing this:\n  k < dfj\n\ngoal (1 subgoal):\n 1. k = dfj - Suc (dfj - Suc k) &&& dfj - Suc k \\<in> {0..<dfj}", "by auto"], ["proof (state)\nthis:\n  k = dfj - Suc (dfj - Suc k)\n  dfj - Suc k \\<in> {0..<dfj}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x < dfj \\<Longrightarrow>\n       x \\<in> (\\<lambda>k. dfj - Suc k) ` {0..<dfj}\n 2. \\<And>x.\n       x \\<in> {0..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc x)) * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int db - int (dfj - Suc x) + int d):] =\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):]", "thus ?case"], ["proof (prove)\nusing this:\n  k = dfj - Suc (dfj - Suc k)\n  dfj - Suc k \\<in> {0..<dfj}\n\ngoal (1 subgoal):\n 1. k \\<in> (\\<lambda>k. dfj - Suc k) ` {0..<dfj}", "by blast"], ["proof (state)\nthis:\n  k \\<in> (\\<lambda>k. dfj - Suc k) ` {0..<dfj}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc x)) * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int db - int (dfj - Suc x) + int d):] =\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc x)) * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int db - int (dfj - Suc x) + int d):] =\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):]", "case (2 k)"], ["proof (state)\nthis:\n  k \\<in> {0..<dfj}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc x)) * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int db - int (dfj - Suc x) + int d):] =\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):]", "hence [simp]: \"dfj - Suc (dfj - Suc k) = k\"\n          \"int db - int (dfj - Suc k) + int d = int k - off\""], ["proof (prove)\nusing this:\n  k \\<in> {0..<dfj}\n\ngoal (1 subgoal):\n 1. dfj - Suc (dfj - Suc k) = k &&&\n    int db - int (dfj - Suc k) + int d = int k - int off", "by (auto simp: off)"], ["proof (state)\nthis:\n  dfj - Suc (dfj - Suc k) = k\n  int db - int (dfj - Suc k) + int d = int k - int off\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc x)) * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int db - int (dfj - Suc x) + int d):] =\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc k)) * G\n     else [:g (int dg - int i + int (dfj - Suc k)):]) *\n    [:b (int db - int (dfj - Suc k) + int d):] =\n    (if i = n - 1 then monom (1::'a) k * G\n     else [:g (int dg - int i + int (dfj - Suc k)):]) *\n    [:b (int k - int off):]", "by auto"], ["proof (state)\nthis:\n  (if i = n - 1 then monom (1::'a) (dfj - 1 - (dfj - Suc k)) * G\n   else [:g (int dg - int i + int (dfj - Suc k)):]) *\n  [:b (int db - int (dfj - Suc k) + int d):] =\n  (if i = n - 1 then monom (1::'a) k * G\n   else [:g (int dg - int i + int (dfj - Suc k)):]) *\n  [:b (int k - int off):]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n       else [:g (int dg - int i + int k):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) (dfj - 1 - k) * G\n       else [:g (int dg - int i + int k):]) *\n      [:b (int db - int k + int d):]) =\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"\\<dots>  = sum ?g_b {0 ..< off} + sum ?g_b {off ..< dfj}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) =\n    (\\<Sum>k = 0..<off.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) +\n    (\\<Sum>k = off..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):])", "unfolding split1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{0..<off} \\<union> {off..<dfj}.\n       (if i = n - 1 then monom (1::'a) k * G\n        else [:g (int dg - int i + int (dfj - Suc k)):]) *\n       [:b (int k - int off):]) =\n    (\\<Sum>k = 0..<off.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) +\n    (\\<Sum>k = off..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):])", "by (simp add: sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  (\\<Sum>k = 0..<off.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) +\n  (\\<Sum>k = off..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  (\\<Sum>k = 0..<off.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) +\n  (\\<Sum>k = off..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?g_b {0 ..< off} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<off.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) =\n    0", "by (rule sum.neutral, intro ballI, auto simp: b coeff_int_def)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<off.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<off.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?g_b {off ..< dfj} = sum ?g_b {off .. off + db} + sum ?g_b {off + Suc db ..< dfj}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = off..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) =\n    (\\<Sum>k = off..off + db.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) +\n    (\\<Sum>k = off + Suc db..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):])", "unfolding split2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{off..off + db} \\<union> {off + Suc db..<dfj}.\n       (if i = n - 1 then monom (1::'a) k * G\n        else [:g (int dg - int i + int (dfj - Suc k)):]) *\n       [:b (int k - int off):]) =\n    (\\<Sum>k = off..off + db.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) +\n    (\\<Sum>k = off + Suc db..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):])", "by (rule sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = off..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  (\\<Sum>k = off..off + db.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) +\n  (\\<Sum>k = off + Suc db..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = off..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  (\\<Sum>k = off..off + db.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) +\n  (\\<Sum>k = off + Suc db..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?g_b {off + Suc db ..< dfj} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = off + Suc db..<dfj.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) =\n    0", "proof (rule sum.neutral, intro ballI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {off + Suc db..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):] =\n       0", "case (1 k)"], ["proof (state)\nthis:\n  k \\<in> {off + Suc db..<dfj}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {off + Suc db..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):] =\n       0", "hence \"b (int k - int off) = 0\""], ["proof (prove)\nusing this:\n  k \\<in> {off + Suc db..<dfj}\n\ngoal (1 subgoal):\n 1. b (int k - int off) = (0::'a)", "unfolding b db"], ["proof (prove)\nusing this:\n  k \\<in> {off + Suc (degree B)..<dfj}\n\ngoal (1 subgoal):\n 1. coeff_int B (int k - int off) = (0::'a)", "by (intro coeff_int_eq_0, auto)"], ["proof (state)\nthis:\n  b (int k - int off) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {off + Suc db..<dfj} \\<Longrightarrow>\n       (if i = n - 1 then monom (1::'a) x * G\n        else [:g (int dg - int i + int (dfj - Suc x)):]) *\n       [:b (int x - int off):] =\n       0", "thus ?case"], ["proof (prove)\nusing this:\n  b (int k - int off) = (0::'a)\n\ngoal (1 subgoal):\n 1. (if i = n - 1 then monom (1::'a) k * G\n     else [:g (int dg - int i + int (dfj - Suc k)):]) *\n    [:b (int k - int off):] =\n    0", "by simp"], ["proof (state)\nthis:\n  (if i = n - 1 then monom (1::'a) k * G\n   else [:g (int dg - int i + int (dfj - Suc k)):]) *\n  [:b (int k - int off):] =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = off + Suc db..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = off + Suc db..<dfj.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"sum ?g_b {off .. off + db} = sum ?gb {0 .. db}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = off..off + db.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) =\n    (\\<Sum>k = 0..db.\n        (if i = n - 1 then monom (1::'a) (k + off) * G\n         else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n        [:coeff B k:])", "using sum.atLeastAtMost_shift_bounds [of ?g_b 0 off db]"], ["proof (prove)\nusing this:\n  (\\<Sum>k = 0 + off..db + off.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  sum ((\\<lambda>k.\n           (if i = n - 1 then monom (1::'a) k * G\n            else [:g (int dg - int i + int (dfj - Suc k)):]) *\n           [:b (int k - int off):]) \\<circ>\n       (+) off)\n   {0..db}\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = off..off + db.\n        (if i = n - 1 then monom (1::'a) k * G\n         else [:g (int dg - int i + int (dfj - Suc k)):]) *\n        [:b (int k - int off):]) =\n    (\\<Sum>k = 0..db.\n        (if i = n - 1 then monom (1::'a) (k + off) * G\n         else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n        [:coeff B k:])", "by (auto intro: sum.cong simp add: b ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k = off..off + db.\n      (if i = n - 1 then monom (1::'a) k * G\n       else [:g (int dg - int i + int (dfj - Suc k)):]) *\n      [:b (int k - int off):]) =\n  (\\<Sum>k = 0..db.\n      (if i = n - 1 then monom (1::'a) (k + off) * G\n       else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n      [:coeff B k:])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "finally"], ["proof (chain)\npicking this:\n  row (mat n n\n        (\\<lambda>a.\n            case a of\n            (i, j) \\<Rightarrow>\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>a.\n            case a of\n            (i, j) \\<Rightarrow>\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n   j =\n  0 +\n  ((\\<Sum>k = 0..db.\n       (if i = n - 1 then monom (1::'a) (k + off) * G\n        else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n       [:coeff B k:]) +\n   0) +\n  0 +\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n   else [:f (int df - int i + int d):]) +\n  0", "have id: \"row ?G_F i \\<bullet> col ?M j - ?H = ?Pj + sum ?gb {0 .. db} - ?H\"\n        (is \"_ = ?E\")"], ["proof (prove)\nusing this:\n  row (mat n n\n        (\\<lambda>a.\n            case a of\n            (i, j) \\<Rightarrow>\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>a.\n            case a of\n            (i, j) \\<Rightarrow>\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n   j =\n  0 +\n  ((\\<Sum>k = 0..db.\n       (if i = n - 1 then monom (1::'a) (k + off) * G\n        else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n       [:coeff B k:]) +\n   0) +\n  0 +\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n   else [:f (int df - int i + int d):]) +\n  0\n\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j -\n    (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n     else [:h (int df - int i + int d):]) =\n    (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n     else [:f (int df - int i + int d):]) +\n    (\\<Sum>k = 0..db.\n        (if i = n - 1 then monom (1::'a) (k + off) * G\n         else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n        [:coeff B k:]) -\n    (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n     else [:h (int df - int i + int d):])", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j -\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n   else [:h (int df - int i + int d):]) =\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n   else [:f (int df - int i + int d):]) +\n  (\\<Sum>k = 0..db.\n      (if i = n - 1 then monom (1::'a) (k + off) * G\n       else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n      [:coeff B k:]) -\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n   else [:h (int df - int i + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "define E where \"E = ?E\""], ["proof (state)\nthis:\n  E =\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n   else [:f (int df - int i + int d):]) +\n  (\\<Sum>k = 0..db.\n      (if i = n - 1 then monom (1::'a) (k + off) * G\n       else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n      [:coeff B k:]) -\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n   else [:h (int df - int i + int d):])\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "let ?b = \"coeff B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have Bsum: \"(\\<Sum>k = 0..db. monom (?b k) k) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db. monom (coeff B k) k) = B", "unfolding db"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..degree B. monom (coeff B k) k) = B", "using atMost_atLeast0 poly_as_sum_of_monoms"], ["proof (prove)\nusing this:\n  {..?n} = {0..?n}\n  (\\<Sum>i\\<le>degree ?p. monom (coeff ?p i) i) = ?p\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..degree B. monom (coeff B k) k) = B", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (coeff B k) k) = B\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "have \"E = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E = 0", "proof (cases \"i = n - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "case i_n: False"], ["proof (state)\nthis:\n  i \\<noteq> n - 1\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "hence id: \"(i = n - 1) = False\""], ["proof (prove)\nusing this:\n  i \\<noteq> n - 1\n\ngoal (1 subgoal):\n 1. (i = n - 1) = False", "by simp"], ["proof (state)\nthis:\n  (i = n - 1) = False\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "with i"], ["proof (chain)\npicking this:\n  i < n\n  (i = n - 1) = False", "have i: \"i < n - 1\""], ["proof (prove)\nusing this:\n  i < n\n  (i = n - 1) = False\n\ngoal (1 subgoal):\n 1. i < n - 1", "by auto"], ["proof (state)\nthis:\n  i < n - 1\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "let ?ii = \"int df - int i + int d\""], ["proof (state)\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"?thesis = ([:f ?ii:] +\n         (\\<Sum>k = 0..db.\n          [:g (int dg - int i + int (dfj - Suc k - off)):] * [:?b k:]) -\n          [:h ?ii:] = 0)\" (is \"_ = (?e = 0)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (E = 0) =\n    ([:f (int df - int i + int d):] +\n     (\\<Sum>k = 0..db.\n         [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n     [:h (int df - int i + int d):] =\n     0)", "unfolding E_def id if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:f (int df - int i + int d):] +\n     (\\<Sum>k = 0..db.\n         [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n     [:h (int df - int i + int d):] =\n     0) =\n    ([:f (int df - int i + int d):] +\n     (\\<Sum>k = 0..db.\n         [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n     [:h (int df - int i + int d):] =\n     0)", "by simp"], ["proof (state)\nthis:\n  (E = 0) =\n  ([:f (int df - int i + int d):] +\n   (\\<Sum>k = 0..db.\n       [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n   [:h (int df - int i + int d):] =\n   0)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  (E = 0) =\n  ([:f (int df - int i + int d):] +\n   (\\<Sum>k = 0..db.\n       [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n   [:h (int df - int i + int d):] =\n   0)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"?e = [: f ?ii +\n         (\\<Sum>k = 0..db.\n          g (int dg - int i + int (dfj - Suc k - off)) * ?b k) -\n          h ?ii:]\" (is \"_ = [: ?e :]\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:f (int df - int i + int d):] +\n    (\\<Sum>k = 0..db.\n        [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n    [:h (int df - int i + int d):] =\n    [:f (int df - int i + int d) +\n      (\\<Sum>k = 0..db.\n          g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n      h (int df - int i + int d):]", "proof (rule poly_eqI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff\n        ([:f (int df - int i + int d):] +\n         (\\<Sum>k = 0..db.\n             [:g (int dg - int i + int (dfj - Suc k - off)):] *\n             [:coeff B k:]) -\n         [:h (int df - int i + int d):])\n        n =\n       coeff\n        [:f (int df - int i + int d) +\n          (\\<Sum>k = 0..db.\n              g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n          h (int df - int i + int d):]\n        n", "case (1 n)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff\n        ([:f (int df - int i + int d):] +\n         (\\<Sum>k = 0..db.\n             [:g (int dg - int i + int (dfj - Suc k - off)):] *\n             [:coeff B k:]) -\n         [:h (int df - int i + int d):])\n        n =\n       coeff\n        [:f (int df - int i + int d) +\n          (\\<Sum>k = 0..db.\n              g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n          h (int df - int i + int d):]\n        n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff\n     ([:f (int df - int i + int d):] +\n      (\\<Sum>k = 0..db.\n          [:g (int dg - int i + int (dfj - Suc k - off)):] *\n          [:coeff B k:]) -\n      [:h (int df - int i + int d):])\n     n =\n    coeff\n     [:f (int df - int i + int d) +\n       (\\<Sum>k = 0..db.\n           g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n       h (int df - int i + int d):]\n     n", "unfolding coeff_diff coeff_add coeff_sum coeff_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n = 0 then f (int df - int i + int d) else (0::'a)) +\n    (\\<Sum>x = 0..db.\n        coeff\n         ([:g (int dg - int i + int (dfj - Suc x - off)):] * [:coeff B x:])\n         n) -\n    (if n = 0 then h (int df - int i + int d) else (0::'a)) =\n    (if n = 0\n     then f (int df - int i + int d) +\n          (\\<Sum>k = 0..db.\n              g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n          h (int df - int i + int d)\n     else (0::'a))", "by (cases n, auto simp: ac_simps)"], ["proof (state)\nthis:\n  coeff\n   ([:f (int df - int i + int d):] +\n    (\\<Sum>k = 0..db.\n        [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n    [:h (int df - int i + int d):])\n   n =\n  coeff\n   [:f (int df - int i + int d) +\n     (\\<Sum>k = 0..db.\n         g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n     h (int df - int i + int d):]\n   n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [:f (int df - int i + int d):] +\n  (\\<Sum>k = 0..db.\n      [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n  [:h (int df - int i + int d):] =\n  [:f (int df - int i + int d) +\n    (\\<Sum>k = 0..db.\n        g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n    h (int df - int i + int d):]\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  [:f (int df - int i + int d):] +\n  (\\<Sum>k = 0..db.\n      [:g (int dg - int i + int (dfj - Suc k - off)):] * [:coeff B k:]) -\n  [:h (int df - int i + int d):] =\n  [:f (int df - int i + int d) +\n    (\\<Sum>k = 0..db.\n        g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n    h (int df - int i + int d):]\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"[: ?e :] = 0 \\<longleftrightarrow> ?e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:f (int df - int i + int d) +\n       (\\<Sum>k = 0..db.\n           g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n       h (int df - int i + int d):] =\n     0) =\n    (f (int df - int i + int d) +\n     (\\<Sum>k = 0..db.\n         g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n     h (int df - int i + int d) =\n     (0::'a))", "by simp"], ["proof (state)\nthis:\n  ([:f (int df - int i + int d) +\n     (\\<Sum>k = 0..db.\n         g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n     h (int df - int i + int d):] =\n   0) =\n  (f (int df - int i + int d) +\n   (\\<Sum>k = 0..db.\n       g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n   h (int df - int i + int d) =\n   (0::'a))\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  ([:f (int df - int i + int d) +\n     (\\<Sum>k = 0..db.\n         g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n     h (int df - int i + int d):] =\n   0) =\n  (f (int df - int i + int d) +\n   (\\<Sum>k = 0..db.\n       g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n   h (int df - int i + int d) =\n   (0::'a))\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"?e = (\\<Sum>k = 0..db. g (int dg - int i + int (dfj - Suc k - off)) * ?b k)\n          - coeff_int (B * G) ?ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (int df - int i + int d) +\n    (\\<Sum>k = 0..db.\n        g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n    h (int df - int i + int d) =\n    (\\<Sum>k = 0..db.\n        g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n    coeff_int (B * G) (int df - int i + int d)", "unfolding hfg"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (int df - int i + int d) +\n    (\\<Sum>k = 0..db.\n        g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n    (f (int df - int i + int d) +\n     coeff_int (B * G) (int df - int i + int d)) =\n    (\\<Sum>k = 0..db.\n        g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n    coeff_int (B * G) (int df - int i + int d)", "by simp"], ["proof (state)\nthis:\n  f (int df - int i + int d) +\n  (\\<Sum>k = 0..db.\n      g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n  h (int df - int i + int d) =\n  (\\<Sum>k = 0..db.\n      g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n  coeff_int (B * G) (int df - int i + int d)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  f (int df - int i + int d) +\n  (\\<Sum>k = 0..db.\n      g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n  h (int df - int i + int d) =\n  (\\<Sum>k = 0..db.\n      g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n  coeff_int (B * G) (int df - int i + int d)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"(B * G) = (\\<Sum>k = 0..db. monom (?b k) k) * G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * G = (\\<Sum>k = 0..db. monom (coeff B k) k) * G", "unfolding Bsum"], ["proof (prove)\ngoal (1 subgoal):\n 1. B * G = B * G", "by simp"], ["proof (state)\nthis:\n  B * G = (\\<Sum>k = 0..db. monom (coeff B k) k) * G\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  B * G = (\\<Sum>k = 0..db. monom (coeff B k) k) * G\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"\\<dots> = (\\<Sum>k = 0..db. monom (?b k) k * G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db. monom (coeff B k) k) * G =\n    (\\<Sum>k = 0..db. monom (coeff B k) k * G)", "by (rule sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (coeff B k) k) * G =\n  (\\<Sum>k = 0..db. monom (coeff B k) k * G)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (coeff B k) k) * G =\n  (\\<Sum>k = 0..db. monom (coeff B k) k * G)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"coeff_int \\<dots> ?ii = (\\<Sum>k = 0..db. g (?ii - k) * ?b k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int (\\<Sum>k = 0..db. monom (coeff B k) k * G)\n     (int df - int i + int d) =\n    (\\<Sum>k = 0..db. g (int df - int i + int d - int k) * coeff B k)", "unfolding coeff_int_sum coeff_int_monom_mult g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..db.\n        coeff B x * coeff_int G (int df - int i + int d - int x)) =\n    (\\<Sum>k = 0..db.\n        coeff_int G (int df - int i + int d - int k) * coeff B k)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  coeff_int (\\<Sum>k = 0..db. monom (coeff B k) k * G)\n   (int df - int i + int d) =\n  (\\<Sum>k = 0..db. g (int df - int i + int d - int k) * coeff B k)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  coeff_int (\\<Sum>k = 0..db. monom (coeff B k) k * G)\n   (int df - int i + int d) =\n  (\\<Sum>k = 0..db. g (int df - int i + int d - int k) * coeff B k)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "have \"\\<dots> = (\\<Sum>k = 0..db. g (int dg - int i + int (dfj - Suc k - off)) * ?b k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db. g (int df - int i + int d - int k) * coeff B k) =\n    (\\<Sum>k = 0..db.\n        g (int dg - int i + int (dfj - Suc k - off)) * coeff B k)", "proof (rule sum.cong[OF refl], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       g (int df - int i + int d - int x) * coeff B x =\n       g (int dg - int i + int (dfj - Suc x - off)) * coeff B x", "case (1 k)"], ["proof (state)\nthis:\n  k \\<in> {0..db}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       g (int df - int i + int d - int x) * coeff B x =\n       g (int dg - int i + int (dfj - Suc x - off)) * coeff B x", "hence \"k \\<le> db\""], ["proof (prove)\nusing this:\n  k \\<in> {0..db}\n\ngoal (1 subgoal):\n 1. k \\<le> db", "by simp"], ["proof (state)\nthis:\n  k \\<le> db\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       g (int df - int i + int d - int x) * coeff B x =\n       g (int dg - int i + int (dfj - Suc x - off)) * coeff B x", "hence id: \"int dg - int i + int (dfj - Suc k - off) = ?ii - k\""], ["proof (prove)\nusing this:\n  k \\<le> db\n\ngoal (1 subgoal):\n 1. int dg - int i + int (dfj - Suc k - off) =\n    int df - int i + int d - int k", "using False i j off dfg"], ["proof (prove)\nusing this:\n  k \\<le> db\n  \\<not> j < dfj\n  i < n - 1\n  j < n\n  int off = - (int db - int dfj + 1 + int d)\n  dg \\<le> df\n\ngoal (1 subgoal):\n 1. int dg - int i + int (dfj - Suc k - off) =\n    int df - int i + int d - int k", "unfolding dbfg d_def dfj_def n"], ["proof (prove)\nusing this:\n  k \\<le> df - dg\n  \\<not> j < df - J\n  i < df - J + (dg - J) - 1\n  j < df - J + (dg - J)\n  int off = - (int (df - dg) - int (df - J) + 1 + int (j - (df - J)))\n  dg \\<le> df\n\ngoal (1 subgoal):\n 1. int dg - int i + int (df - J - Suc k - off) =\n    int df - int i + int (j - (df - J)) - int k", "by linarith"], ["proof (state)\nthis:\n  int dg - int i + int (dfj - Suc k - off) = int df - int i + int d - int k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       g (int df - int i + int d - int x) * coeff B x =\n       g (int dg - int i + int (dfj - Suc x - off)) * coeff B x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (int df - int i + int d - int k) * coeff B k =\n    g (int dg - int i + int (dfj - Suc k - off)) * coeff B k", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (int df - int i + int d - int k) * coeff B k =\n    g (int df - int i + int d - int k) * coeff B k", ".."], ["proof (state)\nthis:\n  g (int df - int i + int d - int k) * coeff B k =\n  g (int dg - int i + int (dfj - Suc k - off)) * coeff B k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. g (int df - int i + int d - int k) * coeff B k) =\n  (\\<Sum>k = 0..db.\n      g (int dg - int i + int (dfj - Suc k - off)) * coeff B k)\n\ngoal (2 subgoals):\n 1. i = n - 1 \\<Longrightarrow> E = 0\n 2. i \\<noteq> n - 1 \\<Longrightarrow> E = 0", "finally"], ["proof (chain)\npicking this:\n  (E = 0) =\n  ((\\<Sum>k = 0..db.\n       g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n   (\\<Sum>k = 0..db.\n       g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) =\n   (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (E = 0) =\n  ((\\<Sum>k = 0..db.\n       g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) -\n   (\\<Sum>k = 0..db.\n       g (int dg - int i + int (dfj - Suc k - off)) * coeff B k) =\n   (0::'a))\n\ngoal (1 subgoal):\n 1. E = 0", "by simp"], ["proof (state)\nthis:\n  E = 0\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "case True"], ["proof (state)\nthis:\n  i = n - 1\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "let ?jj = \"dgj - Suc d\""], ["proof (state)\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have zero: \"int off - (dgj - Suc d) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int off - int (dgj - Suc d) = 0", "using dfg False j"], ["proof (prove)\nusing this:\n  dg \\<le> df\n  \\<not> j < dfj\n  j < n\n\ngoal (1 subgoal):\n 1. int off - int (dgj - Suc d) = 0", "unfolding off dbfg dfj_def d_def dgj_def n"], ["proof (prove)\nusing this:\n  dg \\<le> df\n  \\<not> j < df - J\n  j < df - J + (dg - J)\n\ngoal (1 subgoal):\n 1. - (int (df - dg) - int (df - J) + 1 + int (j - (df - J))) -\n    int (dg - J - Suc (j - (df - J))) =\n    0", "by linarith"], ["proof (state)\nthis:\n  int off - int (dgj - Suc d) = 0\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "from True"], ["proof (chain)\npicking this:\n  i = n - 1", "have \"E = monom 1 ?jj * F + (\\<Sum>k = 0.. db.\n          monom 1 (k + off) * G * [: ?b k :]) - monom 1 ?jj * H\"\n          (is \"_ = ?A + ?sum - ?mon\")"], ["proof (prove)\nusing this:\n  i = n - 1\n\ngoal (1 subgoal):\n 1. E =\n    monom (1::'a) (dgj - Suc d) * F +\n    (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n    monom (1::'a) (dgj - Suc d) * H", "unfolding id E_def"], ["proof (prove)\nusing this:\n  i = n - 1\n\ngoal (1 subgoal):\n 1. (if i = n - 1 then monom (1::'a) (dgj - Suc d) * F\n     else [:f (int df - int i + int d):]) +\n    (\\<Sum>k = 0..db.\n        (if i = n - 1 then monom (1::'a) (k + off) * G\n         else [:g (int dg - int i + int (dfj - Suc k - off)):]) *\n        [:coeff B k:]) -\n    (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n     else [:h (int df - int i + int d):]) =\n    monom (1::'a) (dgj - Suc d) * F +\n    (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n    monom (1::'a) (dgj - Suc d) * H", "by simp"], ["proof (state)\nthis:\n  E =\n  monom (1::'a) (dgj - Suc d) * F +\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n  monom (1::'a) (dgj - Suc d) * H\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  E =\n  monom (1::'a) (dgj - Suc d) * F +\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n  monom (1::'a) (dgj - Suc d) * H\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"?mon = monom 1 ?jj * F + monom 1 ?jj * (B * G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (dgj - Suc d) * H =\n    monom (1::'a) (dgj - Suc d) * F + monom (1::'a) (dgj - Suc d) * (B * G)", "unfolding FGH[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (dgj - Suc d) * (F + B * G) =\n    monom (1::'a) (dgj - Suc d) * F + monom (1::'a) (dgj - Suc d) * (B * G)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  monom (1::'a) (dgj - Suc d) * H =\n  monom (1::'a) (dgj - Suc d) * F + monom (1::'a) (dgj - Suc d) * (B * G)\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  monom (1::'a) (dgj - Suc d) * H =\n  monom (1::'a) (dgj - Suc d) * F + monom (1::'a) (dgj - Suc d) * (B * G)\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"?A + ?sum - \\<dots> = ?sum - (monom 1 ?jj * G) * B\" (is \"_ = _ - ?GB * B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (dgj - Suc d) * F +\n    (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n    (monom (1::'a) (dgj - Suc d) * F +\n     monom (1::'a) (dgj - Suc d) * (B * G)) =\n    (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n    monom (1::'a) (dgj - Suc d) * G * B", "by simp"], ["proof (state)\nthis:\n  monom (1::'a) (dgj - Suc d) * F +\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n  (monom (1::'a) (dgj - Suc d) * F +\n   monom (1::'a) (dgj - Suc d) * (B * G)) =\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n  monom (1::'a) (dgj - Suc d) * G * B\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  monom (1::'a) (dgj - Suc d) * F +\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n  (monom (1::'a) (dgj - Suc d) * F +\n   monom (1::'a) (dgj - Suc d) * (B * G)) =\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) -\n  monom (1::'a) (dgj - Suc d) * G * B\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"?sum = (\\<Sum>k = 0..db.\n          (monom 1 ?jj * G) * (monom 1 (k + off - ?jj) * [: ?b k :]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) =\n    (\\<Sum>k = 0..db.\n        monom (1::'a) (dgj - Suc d) * G *\n        (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]))", "proof (rule sum.cong[OF refl], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       monom (1::'a) (x + off) * G * [:coeff B x:] =\n       monom (1::'a) (dgj - Suc d) * G *\n       (monom (1::'a) (x + off - (dgj - Suc d)) * [:coeff B x:])", "case (1 k)"], ["proof (state)\nthis:\n  k \\<in> {0..db}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       monom (1::'a) (x + off) * G * [:coeff B x:] =\n       monom (1::'a) (dgj - Suc d) * G *\n       (monom (1::'a) (x + off - (dgj - Suc d)) * [:coeff B x:])", "let ?one = \"1 :: 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       monom (1::'a) (x + off) * G * [:coeff B x:] =\n       monom (1::'a) (dgj - Suc d) * G *\n       (monom (1::'a) (x + off - (dgj - Suc d)) * [:coeff B x:])", "have \"int off \\<ge> int ?jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (dgj - Suc d) \\<le> int off", "using j False i True"], ["proof (prove)\nusing this:\n  j < n\n  \\<not> j < dfj\n  i < n\n  i = n - 1\n\ngoal (1 subgoal):\n 1. int (dgj - Suc d) \\<le> int off", "unfolding off d_def dfj_def dgj_def dfbg n"], ["proof (prove)\nusing this:\n  j < db + dg - J + (dg - J)\n  \\<not> j < db + dg - J\n  i < db + dg - J + (dg - J)\n  i = db + dg - J + (dg - J) - 1\n\ngoal (1 subgoal):\n 1. int (dg - J - Suc (j - (db + dg - J)))\n    \\<le> - (int db - int (db + dg - J) + 1 + int (j - (db + dg - J)))", "by linarith"], ["proof (state)\nthis:\n  int (dgj - Suc d) \\<le> int off\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       monom (1::'a) (x + off) * G * [:coeff B x:] =\n       monom (1::'a) (dgj - Suc d) * G *\n       (monom (1::'a) (x + off - (dgj - Suc d)) * [:coeff B x:])", "hence \"k + off = ?jj + (k + off - ?jj)\""], ["proof (prove)\nusing this:\n  int (dgj - Suc d) \\<le> int off\n\ngoal (1 subgoal):\n 1. k + off = dgj - Suc d + (k + off - (dgj - Suc d))", "by linarith"], ["proof (state)\nthis:\n  k + off = dgj - Suc d + (k + off - (dgj - Suc d))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       monom (1::'a) (x + off) * G * [:coeff B x:] =\n       monom (1::'a) (dgj - Suc d) * G *\n       (monom (1::'a) (x + off - (dgj - Suc d)) * [:coeff B x:])", "hence id: \"monom ?one (k + off) = monom (1 * 1) (?jj + (k + off - ?jj))\""], ["proof (prove)\nusing this:\n  k + off = dgj - Suc d + (k + off - (dgj - Suc d))\n\ngoal (1 subgoal):\n 1. monom (1::'a) (k + off) =\n    monom ((1::'a) * (1::'a)) (dgj - Suc d + (k + off - (dgj - Suc d)))", "by simp"], ["proof (state)\nthis:\n  monom (1::'a) (k + off) =\n  monom ((1::'a) * (1::'a)) (dgj - Suc d + (k + off - (dgj - Suc d)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..db} \\<Longrightarrow>\n       monom (1::'a) (x + off) * G * [:coeff B x:] =\n       monom (1::'a) (dgj - Suc d) * G *\n       (monom (1::'a) (x + off - (dgj - Suc d)) * [:coeff B x:])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (k + off) * G * [:coeff B k:] =\n    monom (1::'a) (dgj - Suc d) * G *\n    (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])", "unfolding id[folded mult_monom]"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (dgj - Suc d) * monom (1::'a) (k + off - (dgj - Suc d)) *\n    G *\n    [:coeff B k:] =\n    monom (1::'a) (dgj - Suc d) * G *\n    (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  monom (1::'a) (k + off) * G * [:coeff B k:] =\n  monom (1::'a) (dgj - Suc d) * G *\n  (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) =\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (dgj - Suc d) * G *\n      (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]))\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off) * G * [:coeff B k:]) =\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (dgj - Suc d) * G *\n      (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]))\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"\\<dots> = (monom 1 ?jj * G) * (\\<Sum>k = 0..db.  monom 1 (k + off - ?jj) * [:?b k:])\"\n          (is \"_ = _ * ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db.\n        monom (1::'a) (dgj - Suc d) * G *\n        (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])) =\n    monom (1::'a) (dgj - Suc d) * G *\n    (\\<Sum>k = 0..db.\n        monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])", "unfolding sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db.\n        monom (1::'a) (dgj - Suc d) * G *\n        (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])) =\n    (\\<Sum>n = 0..db.\n        monom (1::'a) (dgj - Suc d) * G *\n        (monom (1::'a) (n + off - (dgj - Suc d)) * [:coeff B n:]))", ".."], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (dgj - Suc d) * G *\n      (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])) =\n  monom (1::'a) (dgj - Suc d) * G *\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (dgj - Suc d) * G *\n      (monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])) =\n  monom (1::'a) (dgj - Suc d) * G *\n  (\\<Sum>k = 0..db. monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:])\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"\\<dots> - (monom 1 ?jj * G) * B = (monom 1 ?jj * G) * (?sum - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (dgj - Suc d) * G *\n    (\\<Sum>k = 0..db.\n        monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) -\n    monom (1::'a) (dgj - Suc d) * G * B =\n    monom (1::'a) (dgj - Suc d) * G *\n    ((\\<Sum>k = 0..db.\n         monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) -\n     B)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  monom (1::'a) (dgj - Suc d) * G *\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) -\n  monom (1::'a) (dgj - Suc d) * G * B =\n  monom (1::'a) (dgj - Suc d) * G *\n  ((\\<Sum>k = 0..db.\n       monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) -\n   B)\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  monom (1::'a) (dgj - Suc d) * G *\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) -\n  monom (1::'a) (dgj - Suc d) * G * B =\n  monom (1::'a) (dgj - Suc d) * G *\n  ((\\<Sum>k = 0..db.\n       monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) -\n   B)\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"?sum = (\\<Sum>k = 0..db.  monom 1 k * [:?b k:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db.\n        monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) =\n    (\\<Sum>k = 0..db. monom (1::'a) k * [:coeff B k:])", "by (rule sum.cong[OF refl], insert zero, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) =\n  (\\<Sum>k = 0..db. monom (1::'a) k * [:coeff B k:])\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db.\n      monom (1::'a) (k + off - (dgj - Suc d)) * [:coeff B k:]) =\n  (\\<Sum>k = 0..db. monom (1::'a) k * [:coeff B k:])\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"\\<dots> = (\\<Sum>k = 0..db.  monom (?b k) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db. monom (1::'a) k * [:coeff B k:]) =\n    (\\<Sum>k = 0..db. monom (coeff B k) k)", "by (rule sum.cong[OF refl], rule poly_eqI, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (1::'a) k * [:coeff B k:]) =\n  (\\<Sum>k = 0..db. monom (coeff B k) k)\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (1::'a) k * [:coeff B k:]) =\n  (\\<Sum>k = 0..db. monom (coeff B k) k)\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "have \"\\<dots> = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..db. monom (coeff B k) k) = B", "unfolding Bsum"], ["proof (prove)\ngoal (1 subgoal):\n 1. B = B", ".."], ["proof (state)\nthis:\n  (\\<Sum>k = 0..db. monom (coeff B k) k) = B\n\ngoal (1 subgoal):\n 1. i = n - 1 \\<Longrightarrow> E = 0", "finally"], ["proof (chain)\npicking this:\n  E = monom (1::'a) (dgj - Suc d) * G * (B - B)", "show ?thesis"], ["proof (prove)\nusing this:\n  E = monom (1::'a) (dgj - Suc d) * G * (B - B)\n\ngoal (1 subgoal):\n 1. E = 0", "by simp"], ["proof (state)\nthis:\n  E = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E = 0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "from id[folded E_def, unfolded this]"], ["proof (chain)\npicking this:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j -\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n   else [:h (int df - int i + int d):]) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j -\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n   else [:h (int df - int i + int d):]) =\n  0\n\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "using False"], ["proof (prove)\nusing this:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j -\n  (if i = n - 1 then monom (1::'a) (dgj - Suc d) * H\n   else [:h (int df - int i + int d):]) =\n  0\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "unfolding d_def"], ["proof (prove)\nusing this:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j -\n  (if i = n - 1 then monom (1::'a) (dgj - Suc (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):]) =\n  0\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. row (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                   else [:f (int df - int i + int (j - dfj)):]))\n     i \\<bullet>\n    col (mat n n\n          (\\<lambda>(i, j).\n              if i = j then 1\n              else if j < dfj then 0\n                   else if i < j then [:b (int db - int i + int (j - dfj)):]\n                        else 0))\n     j =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "by simp"], ["proof (state)\nthis:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):])\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "also"], ["proof (state)\nthis:\n  row (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                 else [:f (int df - int i + int (j - dfj)):]))\n   i \\<bullet>\n  col (mat n n\n        (\\<lambda>(i, j).\n            if i = j then 1\n            else if j < dfj then 0\n                 else if i < j then [:b (int db - int i + int (j - dfj)):]\n                      else 0))\n   j =\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):])\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "have \"\\<dots> = ?G_H $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) $$\n    (i, j)", "using i j"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (mat n n\n                           (\\<lambda>(i, j).\n                               if j < dfj\n                               then if i = n - 1\n                                    then monom (1::'a) (dfj - 1 - j) * G\n                                    else [:g (int dg - int i + int j):]\n                               else if i = n - 1\n                                    then monom (1::'a)\n    (dgj - 1 - (j - dfj)) *\n   F\n                                    else [:f\n      (int df - int i + int (j - dfj)):]) *\n                          mat n n\n                           (\\<lambda>(i, j).\n                               if i = j then 1\n                               else if j < dfj then 0\n                                    else if i < j\n   then [:b (int db - int i + int (j - dfj)):] else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j)\n 2. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 3. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "finally"], ["proof (chain)\npicking this:\n  (mat n n\n    (\\<lambda>(i, j).\n        if j < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n             else [:g (int dg - int i + int j):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n             else [:f (int df - int i + int (j - dfj)):]) *\n   mat n n\n    (\\<lambda>(i, j).\n        if i = j then 1\n        else if j < dfj then 0\n             else if i < j then [:b (int db - int i + int (j - dfj)):]\n                  else 0)) $$\n  (i, j) =\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j)", "show \"(?G_F * ?M) $$ (i,j) = ?G_H $$ (i,j)\""], ["proof (prove)\nusing this:\n  (mat n n\n    (\\<lambda>(i, j).\n        if j < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n             else [:g (int dg - int i + int j):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n             else [:f (int df - int i + int (j - dfj)):]) *\n   mat n n\n    (\\<lambda>(i, j).\n        if i = j then 1\n        else if j < dfj then 0\n             else if i < j then [:b (int db - int i + int (j - dfj)):]\n                  else 0)) $$\n  (i, j) =\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. (mat n n\n      (\\<lambda>(i, j).\n          if j < dfj\n          then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n               else [:g (int dg - int i + int j):]\n          else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n               else [:f (int df - int i + int (j - dfj)):]) *\n     mat n n\n      (\\<lambda>(i, j).\n          if i = j then 1\n          else if j < dfj then 0\n               else if i < j then [:b (int db - int i + int (j - dfj)):]\n                    else 0)) $$\n    (i, j) =\n    mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) $$\n    (i, j)", "."], ["proof (state)\nthis:\n  (mat n n\n    (\\<lambda>(i, j).\n        if j < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n             else [:g (int dg - int i + int j):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n             else [:f (int df - int i + int (j - dfj)):]) *\n   mat n n\n    (\\<lambda>(i, j).\n        if i = j then 1\n        else if j < dfj then 0\n             else if i < j then [:b (int db - int i + int (j - dfj)):]\n                  else 0)) $$\n  (i, j) =\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n\n 2. dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n                else [:f (int df - int i + int (j - dfj)):]) *\n      mat n n\n       (\\<lambda>(i, j).\n           if i = j then 1\n           else if j < dfj then 0\n                else if i < j then [:b (int db - int i + int (j - dfj)):]\n                     else 0)) =\n    n", "qed auto"], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * F\n            else [:f (int df - int i + int (j - dfj)):]) *\n  mat n n\n   (\\<lambda>(i, j).\n       if i = j then 1\n       else if j < dfj then 0\n            else if i < j then [:b (int db - int i + int (j - dfj)):]\n                 else 0) =\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):])\n\ngoal (6 subgoals):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))\n 2. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 3. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 4. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 5. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 6. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "finally"], ["proof (chain)\npicking this:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])))", "show eq_18: \"subresultant J F G = smult ?m1 (det ?G_H)\""], ["proof (prove)\nusing this:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < dfj\n                then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                     else [:h (int df - int i + int (j - dfj)):])))", "unfolding dfj_def dgj_def"], ["proof (prove)\nusing this:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (det (mat n n\n          (\\<lambda>(i, j).\n              if j < df - J\n              then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1\n                   then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                   else [:h (int df - int i + int (j - (df - J))):])))\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     (det (mat n n\n            (\\<lambda>(i, j).\n                if j < df - J\n                then if i = n - 1 then monom (1::'a) (df - J - 1 - j) * G\n                     else [:g (int dg - int i + int j):]\n                else if i = n - 1\n                     then monom (1::'a) (dg - J - 1 - (j - (df - J))) * H\n                     else [:h (int df - int i + int (j - (df - J))):])))", "."], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "{"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "fix i j"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "assume ij: \"i < j\" and j: \"j < n\""], ["proof (state)\nthis:\n  i < j\n  j < n\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "with dgh"], ["proof (chain)\npicking this:\n  dh \\<le> dg\n  i < j\n  j < n", "have \"int dg - int i + int j > int dg\""], ["proof (prove)\nusing this:\n  dh \\<le> dg\n  i < j\n  j < n\n\ngoal (1 subgoal):\n 1. int dg < int dg - int i + int j", "by auto"], ["proof (state)\nthis:\n  int dg < int dg - int i + int j\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "hence \"g (int dg - int i + int j) = 0\""], ["proof (prove)\nusing this:\n  int dg < int dg - int i + int j\n\ngoal (1 subgoal):\n 1. g (int dg - int i + int j) = (0::'a)", "unfolding g dg"], ["proof (prove)\nusing this:\n  int (degree G) < int (degree G) - int i + int j\n\ngoal (1 subgoal):\n 1. coeff_int G (int (degree G) - int i + int j) = (0::'a)", "by (intro coeff_int_eq_0, auto)"], ["proof (state)\nthis:\n  g (int dg - int i + int j) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < ?j2; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> g (int dg - int ?i2 + int ?j2) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note g0 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < ?j2; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> g (int dg - int ?i2 + int ?j2) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < ?j2; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> g (int dg - int ?i2 + int ?j2) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "assume *: \"dh \\<le> J\" \"J < dg\""], ["proof (state)\nthis:\n  dh \\<le> J\n  J < dg\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have n_dfj: \"n > dfj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfj < n", "using *"], ["proof (prove)\nusing this:\n  dh \\<le> J\n  J < dg\n\ngoal (1 subgoal):\n 1. dfj < n", "unfolding n dfj_def"], ["proof (prove)\nusing this:\n  dh \\<le> J\n  J < dg\n\ngoal (1 subgoal):\n 1. df - J < df - J + (dg - J)", "by auto"], ["proof (state)\nthis:\n  dfj < n\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note eq_18"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   (det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"det ?G_H = prod_list (diag_mat ?G_H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])) =\n    prod_list\n     (diag_mat\n       (mat n n\n         (\\<lambda>(i, j).\n             if j < dfj\n             then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                  else [:g (int dg - int i + int j):]\n             else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                  else [:h (int df - int i + int (j - dfj)):])))", "proof (rule det_lower_triangular[of n])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j) =\n                         0\n 2. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j) =\n                         0\n 2. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "assume ij: \"i < j\" and j: \"j < n\""], ["proof (state)\nthis:\n  i < j\n  j < n\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j) =\n                         0\n 2. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "from ij j"], ["proof (chain)\npicking this:\n  i < j\n  j < n", "have if_e: \"i = n - 1 \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  i < j\n  j < n\n\ngoal (1 subgoal):\n 1. (i = n - 1) = False", "by auto"], ["proof (state)\nthis:\n  (i = n - 1) = False\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j) =\n                         0\n 2. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "have \"?G_H $$ (i,j) = ?GH i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) $$\n    (i, j) =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "using ij j"], ["proof (prove)\nusing this:\n  i < j\n  j < n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) $$\n    (i, j) =\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):])", "by auto"], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j) =\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):])\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j) =\n                         0\n 2. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "also"], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j) =\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):])\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j) =\n                         0\n 2. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "proof (cases \"j < dfj\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0\n 2. \\<not> j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "case True"], ["proof (state)\nthis:\n  j < dfj\n\ngoal (2 subgoals):\n 1. j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0\n 2. \\<not> j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "with True g0[OF ij j]"], ["proof (chain)\npicking this:\n  j < dfj\n  g (int dg - int i + int j) = (0::'a)\n  j < dfj", "show ?thesis"], ["proof (prove)\nusing this:\n  j < dfj\n  g (int dg - int i + int j) = (0::'a)\n  j < dfj\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "unfolding if_e"], ["proof (prove)\nusing this:\n  j < dfj\n  g (int dg - int i + int j) = (0::'a)\n  j < dfj\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if False then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if False then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "by simp"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "case False"], ["proof (state)\nthis:\n  \\<not> j < dfj\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "have \"h (int df - int i + int (j - dfj)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (int df - int i + int (j - dfj)) = (0::'a)", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_int H (int df - int i + int (j - dfj)) = (0::'a)", "by (rule coeff_int_eq_0, insert False * ij j dfg, unfold dfj_def dh[symmetric], auto)"], ["proof (state)\nthis:\n  h (int df - int i + int (j - dfj)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> j < dfj \\<Longrightarrow>\n    (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "with False"], ["proof (chain)\npicking this:\n  \\<not> j < dfj\n  h (int df - int i + int (j - dfj)) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> j < dfj\n  h (int df - int i + int (j - dfj)) = (0::'a)\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "unfolding if_e"], ["proof (prove)\nusing this:\n  \\<not> j < dfj\n  h (int df - int i + int (j - dfj)) = (0::'a)\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if False then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if False then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    0", "by auto"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  0\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> mat n n\n                          (\\<lambda>(i, j).\n                              if j < dfj\n                              then if i = n - 1\n                                   then monom (1::'a) (dfj - 1 - j) * G\n                                   else [:g (int dg - int i + int j):]\n                              else if i = n - 1\n                                   then monom (1::'a)\n   (dgj - 1 - (j - dfj)) *\n  H\n                                   else [:h\n     (int df - int i + int (j - dfj)):]) $$\n                         (i, j) =\n                         0\n 2. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "finally"], ["proof (chain)\npicking this:\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j) =\n  0", "show \"?G_H $$ (i,j) = 0\""], ["proof (prove)\nusing this:\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j) =\n  0\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) $$\n    (i, j) =\n    0", "."], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) $$\n  (i, j) =\n  0\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])\n    \\<in> carrier_mat n n", "qed auto"], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  prod_list\n   (diag_mat\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  prod_list\n   (diag_mat\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = (\\<Prod>i = 0..<n. ?GH i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat n n\n         (\\<lambda>(i, j).\n             if j < dfj\n             then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                  else [:g (int dg - int i + int j):]\n             else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                  else [:h (int df - int i + int (j - dfj)):]))) =\n    (\\<Prod>i = 0..<n.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):])", "by (subst prod_list_diag_prod, simp)"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):]))) =\n  (\\<Prod>i = 0..<n.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):]))) =\n  (\\<Prod>i = 0..<n.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"{0 ..< n} = {0 ..< dfj} \\<union> {dfj ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} = {0..<dfj} \\<union> {dfj..<n}", "unfolding n dfj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<df - J + (dg - J)} =\n    {0..<df - J} \\<union> {df - J..<df - J + (dg - J)}", "by auto"], ["proof (state)\nthis:\n  {0..<n} = {0..<dfj} \\<union> {dfj..<n}\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  {0..<n} = {0..<dfj} \\<union> {dfj..<n}\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"prod (\\<lambda> i. ?GH i i) \\<dots> = prod (\\<lambda> i. ?GH i i) {0 ..< dfj} * prod (\\<lambda> i. ?GH i i) {dfj ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<dfj} \\<union> {dfj..<n}.\n       if i < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n            else [:g (int dg - int i + int i):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n            else [:h (int df - int i + int (i - dfj)):]) =\n    (\\<Prod>i = 0..<dfj.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):]) *\n    (\\<Prod>i = dfj..<n.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):])", "by (simp add: prod.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<dfj} \\<union> {dfj..<n}.\n     if i < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n          else [:g (int dg - int i + int i):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n          else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = 0..<dfj.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) *\n  (\\<Prod>i = dfj..<n.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<dfj} \\<union> {dfj..<n}.\n     if i < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n          else [:g (int dg - int i + int i):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n          else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = 0..<dfj.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) *\n  (\\<Prod>i = dfj..<n.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"prod (\\<lambda> i. ?GH i i) {0 ..< dfj} = prod (\\<lambda> i. [: lead_coeff G :]) {0 ..< dfj}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dfj.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):]) =\n    (\\<Prod>i = 0..<dfj. [:lead_coeff G:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dfj.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):]) =\n    (\\<Prod>i = 0..<dfj. [:lead_coeff G:])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dfj.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):]) =\n    (\\<Prod>i = 0..<dfj. [:lead_coeff G:])", "by (rule prod.cong[OF refl], insert n_dfj, auto simp: g coeff_int_def dg)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<dfj.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = 0..<dfj. [:lead_coeff G:])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<dfj.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = 0..<dfj. [:lead_coeff G:])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<dfj.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = 0..<dfj. [:lead_coeff G:])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = [: (lead_coeff G)^dfj :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dfj. [:lead_coeff G:]) = [:lead_coeff G ^ dfj:]", "by (simp add: poly_const_pow)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<dfj. [:lead_coeff G:]) = [:lead_coeff G ^ dfj:]\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<dfj. [:lead_coeff G:]) = [:lead_coeff G ^ dfj:]\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"{dfj ..< n} = {dfj ..< n-1} \\<union> {n - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {dfj..<n} = {dfj..<n - 1} \\<union> {n - 1}", "using n_dfj"], ["proof (prove)\nusing this:\n  dfj < n\n\ngoal (1 subgoal):\n 1. {dfj..<n} = {dfj..<n - 1} \\<union> {n - 1}", "by auto"], ["proof (state)\nthis:\n  {dfj..<n} = {dfj..<n - 1} \\<union> {n - 1}\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  {dfj..<n} = {dfj..<n - 1} \\<union> {n - 1}\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"prod (\\<lambda> i. ?GH i i) \\<dots> = prod (\\<lambda> i. ?GH i i) {dfj ..< n-1} * ?GH (n - 1) (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{dfj..<n - 1} \\<union> {n - 1}.\n       if i < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n            else [:g (int dg - int i + int i):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n            else [:h (int df - int i + int (i - dfj)):]) =\n    (\\<Prod>i = dfj..<n - 1.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):]) *\n    (if n - 1 < dfj\n     then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n          else [:g (int dg - int (n - 1) + int (n - 1)):]\n     else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n          else [:h (int df - int (n - 1) + int (n - 1 - dfj)):])", "by (simp add: prod.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{dfj..<n - 1} \\<union> {n - 1}.\n     if i < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n          else [:g (int dg - int i + int i):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n          else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = dfj..<n - 1.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) *\n  (if n - 1 < dfj\n   then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n        else [:g (int dg - int (n - 1) + int (n - 1)):]\n   else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n        else [:h (int df - int (n - 1) + int (n - 1 - dfj)):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{dfj..<n - 1} \\<union> {n - 1}.\n     if i < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n          else [:g (int dg - int i + int i):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n          else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = dfj..<n - 1.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) *\n  (if n - 1 < dfj\n   then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n        else [:g (int dg - int (n - 1) + int (n - 1)):]\n   else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n        else [:h (int df - int (n - 1) + int (n - 1 - dfj)):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"?GH (n - 1) (n - 1) = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n - 1 < dfj\n     then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n          else [:g (int dg - int (n - 1) + int (n - 1)):]\n     else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n          else [:h (int df - int (n - 1) + int (n - 1 - dfj)):]) =\n    H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if n - 1 < dfj\n     then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n          else [:g (int dg - int (n - 1) + int (n - 1)):]\n     else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n          else [:h (int df - int (n - 1) + int (n - 1 - dfj)):]) =\n    H", "have \"dgj - 1 - (n - 1 - dfj) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgj - 1 - (n - 1 - dfj) = 0", "using n_dfj"], ["proof (prove)\nusing this:\n  dfj < n\n\ngoal (1 subgoal):\n 1. dgj - 1 - (n - 1 - dfj) = 0", "unfolding dgj_def dfj_def n"], ["proof (prove)\nusing this:\n  df - J < df - J + (dg - J)\n\ngoal (1 subgoal):\n 1. dg - J - 1 - (df - J + (dg - J) - 1 - (df - J)) = 0", "by auto"], ["proof (state)\nthis:\n  dgj - 1 - (n - 1 - dfj) = 0\n\ngoal (1 subgoal):\n 1. (if n - 1 < dfj\n     then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n          else [:g (int dg - int (n - 1) + int (n - 1)):]\n     else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n          else [:h (int df - int (n - 1) + int (n - 1 - dfj)):]) =\n    H", "with n_dfj"], ["proof (chain)\npicking this:\n  dfj < n\n  dgj - 1 - (n - 1 - dfj) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  dfj < n\n  dgj - 1 - (n - 1 - dfj) = 0\n\ngoal (1 subgoal):\n 1. (if n - 1 < dfj\n     then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n          else [:g (int dg - int (n - 1) + int (n - 1)):]\n     else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n          else [:h (int df - int (n - 1) + int (n - 1 - dfj)):]) =\n    H", "by auto"], ["proof (state)\nthis:\n  (if n - 1 < dfj\n   then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n        else [:g (int dg - int (n - 1) + int (n - 1)):]\n   else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n        else [:h (int df - int (n - 1) + int (n - 1 - dfj)):]) =\n  H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if n - 1 < dfj\n   then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n        else [:g (int dg - int (n - 1) + int (n - 1)):]\n   else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n        else [:h (int df - int (n - 1) + int (n - 1 - dfj)):]) =\n  H\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  (if n - 1 < dfj\n   then if n - 1 = n - 1 then monom (1::'a) (dfj - 1 - (n - 1)) * G\n        else [:g (int dg - int (n - 1) + int (n - 1)):]\n   else if n - 1 = n - 1 then monom (1::'a) (dgj - 1 - (n - 1 - dfj)) * H\n        else [:h (int df - int (n - 1) + int (n - 1 - dfj)):]) =\n  H\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"prod (\\<lambda> i. ?GH i i) {dfj ..< n-1} = prod (\\<lambda> i. [:h (int df - dfj):]) {dfj ..< n-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = dfj..<n - 1.\n        if i < dfj\n        then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n             else [:g (int dg - int i + int i):]\n        else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n             else [:h (int df - int i + int (i - dfj)):]) =\n    (\\<Prod>i = dfj..<n - 1. [:h (int df - int dfj):])", "by (rule prod.cong[OF refl], auto intro!: arg_cong[of _ _ h])"], ["proof (state)\nthis:\n  (\\<Prod>i = dfj..<n - 1.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = dfj..<n - 1. [:h (int df - int dfj):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = dfj..<n - 1.\n      if i < dfj\n      then if i = n - 1 then monom (1::'a) (dfj - 1 - i) * G\n           else [:g (int dg - int i + int i):]\n      else if i = n - 1 then monom (1::'a) (dgj - 1 - (i - dfj)) * H\n           else [:h (int df - int i + int (i - dfj)):]) =\n  (\\<Prod>i = dfj..<n - 1. [:h (int df - int dfj):])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = [: h (int df - dfj) ^ (n - 1 - dfj) :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = dfj..<n - 1. [:h (int df - int dfj):]) =\n    [:h (int df - int dfj) ^ (n - 1 - dfj):]", "unfolding prod_constant"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:h (int df - int dfj):] ^ card {dfj..<n - 1} =\n    [:h (int df - int dfj) ^ (n - 1 - dfj):]", "by (simp add: poly_const_pow)"], ["proof (state)\nthis:\n  (\\<Prod>i = dfj..<n - 1. [:h (int df - int dfj):]) =\n  [:h (int df - int dfj) ^ (n - 1 - dfj):]\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = dfj..<n - 1. [:h (int df - int dfj):]) =\n  [:h (int df - int dfj) ^ (n - 1 - dfj):]\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"n - 1 - dfj = dg - J - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 1 - dfj = dg - J - 1", "unfolding n dfj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. df - J + (dg - J) - 1 - (df - J) = dg - J - 1", "by simp"], ["proof (state)\nthis:\n  n - 1 - dfj = dg - J - 1\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  n - 1 - dfj = dg - J - 1\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"int df - dfj = J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int df - int dfj = int J", "using * dfg"], ["proof (prove)\nusing this:\n  dh \\<le> J\n  J < dg\n  dg \\<le> df\n\ngoal (1 subgoal):\n 1. int df - int dfj = int J", "unfolding dfj_def"], ["proof (prove)\nusing this:\n  dh \\<le> J\n  J < dg\n  dg \\<le> df\n\ngoal (1 subgoal):\n 1. int df - int (df - J) = int J", "by auto"], ["proof (state)\nthis:\n  int df - int dfj = int J\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  int df - int dfj = int J\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"h J = coeff H J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (int J) = coeff H J", "unfolding h coeff_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if int J < 0 then 0::'a else coeff H (nat (int J))) = coeff H J", "by simp"], ["proof (state)\nthis:\n  h (int J) = coeff H J\n\ngoal (5 subgoals):\n 1. \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                        lead_coeff G ^ (df - J) *\n                        coeff H J ^ (dg - J - 1))\n                       H\n 2. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 3. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 4. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 5. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "finally"], ["proof (chain)\npicking this:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   ([:lead_coeff G ^ dfj:] * ([:coeff H J ^ (dg - J - 1):] * H))", "show \"subresultant J F G = smult (?m1 * ?G * ?H) H\""], ["proof (prove)\nusing this:\n  subresultant J F G =\n  Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n   ([:lead_coeff G ^ dfj:] * ([:coeff H J ^ (dg - J - 1):] * H))\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) *\n      coeff H J ^ (dg - J - 1))\n     H", "by (simp add: dfj_def ac_simps)"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) *\n    coeff H J ^ (dg - J - 1))\n   H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "}"], ["proof (state)\nthis:\n  \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n  \\<Longrightarrow> subresultant J F G =\n                    Polynomial.smult\n                     ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                      lead_coeff G ^ (df - J) *\n                      coeff H J ^ (dg - J - 1))\n                     H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note eq_19 = this"], ["proof (state)\nthis:\n  \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n  \\<Longrightarrow> subresultant J F G =\n                    Polynomial.smult\n                     ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                      lead_coeff G ^ (df - J) *\n                      coeff H J ^ (dg - J - 1))\n                     H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "{"], ["proof (state)\nthis:\n  \\<lbrakk>dh \\<le> J; J < dg\\<rbrakk>\n  \\<Longrightarrow> subresultant J F G =\n                    Polynomial.smult\n                     ((- (1::'a)) ^ ((df - J) * (dg - J)) *\n                      lead_coeff G ^ (df - J) *\n                      coeff H J ^ (dg - J - 1))\n                     H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "assume J: \"J < dh\""], ["proof (state)\nthis:\n  J < dh\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "define dhj where \"dhj = dh - J\""], ["proof (state)\nthis:\n  dhj = dh - J\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have n_add: \"n = (df - dh) + (dhj + dgj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = df - dh + (dhj + dgj)", "unfolding dhj_def dgj_def n"], ["proof (prove)\ngoal (1 subgoal):\n 1. df - J + (dg - J) = df - dh + (dh - J + (dg - J))", "using J dfg dgh"], ["proof (prove)\nusing this:\n  J < dh\n  dg \\<le> df\n  dh \\<le> dg\n\ngoal (1 subgoal):\n 1. df - J + (dg - J) = df - dh + (dh - J + (dg - J))", "by auto"], ["proof (state)\nthis:\n  n = df - dh + (dhj + dgj)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?split = \"split_block ?G_H (df - dh) (df - dh)\""], ["proof (state)\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have dim: \"dim_row ?G_H = (df - dh) + (dhj + dgj)\"\n      \"dim_col ?G_H = (df - dh) + (dhj + dgj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):])) =\n    df - dh + (dhj + dgj) &&&\n    dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):])) =\n    df - dh + (dhj + dgj)", "unfolding n_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (df - dh + (dhj + dgj)) (df - dh + (dhj + dgj))\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = df - dh + (dhj + dgj) - 1\n                then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = df - dh + (dhj + dgj) - 1\n                then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):])) =\n    df - dh + (dhj + dgj) &&&\n    dim_col\n     (mat (df - dh + (dhj + dgj)) (df - dh + (dhj + dgj))\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = df - dh + (dhj + dgj) - 1\n                then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = df - dh + (dhj + dgj) - 1\n                then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):])) =\n    df - dh + (dhj + dgj)", "by auto"], ["proof (state)\nthis:\n  dim_row\n   (mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])) =\n  df - dh + (dhj + dgj)\n  dim_col\n   (mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])) =\n  df - dh + (dhj + dgj)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "obtain UL UR LL LR where spl: \"?split = (UL,UR,LL,LR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>UL UR LL LR.\n        split_block\n         (mat n n\n           (\\<lambda>(i, j).\n               if j < dfj\n               then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                    else [:g (int dg - int i + int j):]\n               else if i = n - 1\n                    then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                    else [:h (int df - int i + int (j - dfj)):]))\n         (df - dh) (df - dh) =\n        (UL, UR, LL, LR) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?split, auto)"], ["proof (state)\nthis:\n  split_block\n   (mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]))\n   (df - dh) (df - dh) =\n  (UL, UR, LL, LR)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note spl' = spl[unfolded split_block_def Let_def, simplified]"], ["proof (state)\nthis:\n  mat (df - dh) (df - dh)\n   (($$)\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):]))) =\n  UL \\<and>\n  mat (df - dh) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i, j + (df - dh))) =\n  UR \\<and>\n  mat (n - (df - dh)) (df - dh)\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j)) =\n  LL \\<and>\n  mat (n - (df - dh)) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j + (df - dh))) =\n  LR\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?LR = \"subresultant_mat J G H\""], ["proof (state)\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"LR = mat (dgj + dhj) (dgj + dhj)\n       (\\<lambda> (i,j). ?GH (i + (df - dh)) (j + (df - dh)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LR =\n    mat (dgj + dhj) (dgj + dhj)\n     (\\<lambda>(i, j).\n         if j + (df - dh) < dfj\n         then if i + (df - dh) = n - 1\n              then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n              else [:g (int dg - int (i + (df - dh)) +\n                        int (j + (df - dh))):]\n         else if i + (df - dh) = n - 1\n              then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n              else [:h (int df - int (i + (df - dh)) +\n                        int (j + (df - dh) - dfj)):])", "using spl'"], ["proof (prove)\nusing this:\n  mat (df - dh) (df - dh)\n   (($$)\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):]))) =\n  UL \\<and>\n  mat (df - dh) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i, j + (df - dh))) =\n  UR \\<and>\n  mat (n - (df - dh)) (df - dh)\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j)) =\n  LL \\<and>\n  mat (n - (df - dh)) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j + (df - dh))) =\n  LR\n\ngoal (1 subgoal):\n 1. LR =\n    mat (dgj + dhj) (dgj + dhj)\n     (\\<lambda>(i, j).\n         if j + (df - dh) < dfj\n         then if i + (df - dh) = n - 1\n              then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n              else [:g (int dg - int (i + (df - dh)) +\n                        int (j + (df - dh))):]\n         else if i + (df - dh) = n - 1\n              then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n              else [:h (int df - int (i + (df - dh)) +\n                        int (j + (df - dh) - dfj)):])", "by (auto simp: n_add)"], ["proof (state)\nthis:\n  LR =\n  mat (dgj + dhj) (dgj + dhj)\n   (\\<lambda>(i, j).\n       if j + (df - dh) < dfj\n       then if i + (df - dh) = n - 1\n            then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n            else [:g (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n       else if i + (df - dh) = n - 1\n            then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n            else [:h (int df - int (i + (df - dh)) +\n                      int (j + (df - dh) - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  LR =\n  mat (dgj + dhj) (dgj + dhj)\n   (\\<lambda>(i, j).\n       if j + (df - dh) < dfj\n       then if i + (df - dh) = n - 1\n            then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n            else [:g (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n       else if i + (df - dh) = n - 1\n            then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n            else [:h (int df - int (i + (df - dh)) +\n                      int (j + (df - dh) - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = ?LR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dgj + dhj) (dgj + dhj)\n     (\\<lambda>(i, j).\n         if j + (df - dh) < dfj\n         then if i + (df - dh) = n - 1\n              then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n              else [:g (int dg - int (i + (df - dh)) +\n                        int (j + (df - dh))):]\n         else if i + (df - dh) = n - 1\n              then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n              else [:h (int df - int (i + (df - dh)) +\n                        int (j + (df - dh) - dfj)):]) =\n    subresultant_mat J G H", "unfolding subresultant_mat_def Let_def dhj_def dgj_def d[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dg - J + (dh - J)) (dg - J + (dh - J))\n     (\\<lambda>(i, j).\n         if j + (df - dh) < dfj\n         then if i + (df - dh) = n - 1\n              then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n              else [:g (int dg - int (i + (df - dh)) +\n                        int (j + (df - dh))):]\n         else if i + (df - dh) = n - 1\n              then monom (1::'a) (dg - J - 1 - (j + (df - dh) - dfj)) * H\n              else [:h (int df - int (i + (df - dh)) +\n                        int (j + (df - dh) - dfj)):]) =\n    mat (dg - J + (dh - J)) (dg - J + (dh - J))\n     (\\<lambda>(i, j).\n         if j < dh - J\n         then if i = dg - J + (dh - J) - 1\n              then monom (1::'a) (dh - J - 1 - j) * G\n              else [:coeff_int G (int dg - int i + int j):]\n         else if i = dg - J + (dh - J) - 1\n              then monom (1::'a) (dg - J - 1 - (j - (dh - J))) * H\n              else [:coeff_int H (int dh - int i + int (j - (dh - J))):])", "proof (rule eq_matI, unfold dim_row_mat dim_col_mat index_mat split dfj_def, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dg - J + (dh - J); j < dg - J + (dh - J)\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n                          else if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J))):]) =\n                         (if j < dh - J\n                          then if i = dg - J + (dh - J) - 1\n                               then monom (1::'a) (dh - J - 1 - j) * G\n                               else [:coeff_int G (int dg - int i + int j):]\n                          else if i = dg - J + (dh - J) - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 - (j - (dh - J))) *\n                                    H\n                               else [:coeff_int H\n (int dh - int i + int (j - (dh - J))):])\n 2. dg - J + (dh - J) = dg - J + (dh - J)\n 3. dg - J + (dh - J) = dg - J + (dh - J)", "case (1 i j)"], ["proof (state)\nthis:\n  i < dg - J + (dh - J)\n  j < dg - J + (dh - J)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dg - J + (dh - J); j < dg - J + (dh - J)\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n                          else if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J))):]) =\n                         (if j < dh - J\n                          then if i = dg - J + (dh - J) - 1\n                               then monom (1::'a) (dh - J - 1 - j) * G\n                               else [:coeff_int G (int dg - int i + int j):]\n                          else if i = dg - J + (dh - J) - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 - (j - (dh - J))) *\n                                    H\n                               else [:coeff_int H\n (int dh - int i + int (j - (dh - J))):])\n 2. dg - J + (dh - J) = dg - J + (dh - J)\n 3. dg - J + (dh - J) = dg - J + (dh - J)", "hence id1: \"(j + (df - dh) < df - J) = (j < dh - J)\""], ["proof (prove)\nusing this:\n  i < dg - J + (dh - J)\n  j < dg - J + (dh - J)\n\ngoal (1 subgoal):\n 1. (j + (df - dh) < df - J) = (j < dh - J)", "using dgh dfg J"], ["proof (prove)\nusing this:\n  i < dg - J + (dh - J)\n  j < dg - J + (dh - J)\n  dh \\<le> dg\n  dg \\<le> df\n  J < dh\n\ngoal (1 subgoal):\n 1. (j + (df - dh) < df - J) = (j < dh - J)", "by auto"], ["proof (state)\nthis:\n  (j + (df - dh) < df - J) = (j < dh - J)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dg - J + (dh - J); j < dg - J + (dh - J)\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n                          else if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J))):]) =\n                         (if j < dh - J\n                          then if i = dg - J + (dh - J) - 1\n                               then monom (1::'a) (dh - J - 1 - j) * G\n                               else [:coeff_int G (int dg - int i + int j):]\n                          else if i = dg - J + (dh - J) - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 - (j - (dh - J))) *\n                                    H\n                               else [:coeff_int H\n (int dh - int i + int (j - (dh - J))):])\n 2. dg - J + (dh - J) = dg - J + (dh - J)\n 3. dg - J + (dh - J) = dg - J + (dh - J)", "have id2: \"(i + (df - dh) = n - 1) = (i = dg - J + (dh - J) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i + (df - dh) = n - 1) = (i = dg - J + (dh - J) - 1)", "unfolding n_add dhj_def dgj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i + (df - dh) = df - dh + (dh - J + (dg - J)) - 1) =\n    (i = dg - J + (dh - J) - 1)", "using dgh dfg J"], ["proof (prove)\nusing this:\n  dh \\<le> dg\n  dg \\<le> df\n  J < dh\n\ngoal (1 subgoal):\n 1. (i + (df - dh) = df - dh + (dh - J + (dg - J)) - 1) =\n    (i = dg - J + (dh - J) - 1)", "by auto"], ["proof (state)\nthis:\n  (i + (df - dh) = n - 1) = (i = dg - J + (dh - J) - 1)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dg - J + (dh - J); j < dg - J + (dh - J)\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n                          else if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J))):]) =\n                         (if j < dh - J\n                          then if i = dg - J + (dh - J) - 1\n                               then monom (1::'a) (dh - J - 1 - j) * G\n                               else [:coeff_int G (int dg - int i + int j):]\n                          else if i = dg - J + (dh - J) - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 - (j - (dh - J))) *\n                                    H\n                               else [:coeff_int H\n (int dh - int i + int (j - (dh - J))):])\n 2. dg - J + (dh - J) = dg - J + (dh - J)\n 3. dg - J + (dh - J) = dg - J + (dh - J)", "have id3: \"(df - J - 1 - (j + (df - dh))) = (dh - J - 1 - j)\"\n        and id4: \"(int dg - int (i + (df - dh)) + int (j + (df - dh))) = (int dg - int i + int j)\"\n        and id5: \"(dg - J - 1 - (j + (df - dh) - (df - J))) = (dg - J - 1 - (j - (dh - J)))\"\n        and id6: \"(int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J))) = (int dh - int i + int (j - (dh - J)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (df - J - 1 - (j + (df - dh)) = dh - J - 1 - j &&&\n     int dg - int (i + (df - dh)) + int (j + (df - dh)) =\n     int dg - int i + int j) &&&\n    dg - J - 1 - (j + (df - dh) - (df - J)) =\n    dg - J - 1 - (j - (dh - J)) &&&\n    int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J)) =\n    int dh - int i + int (j - (dh - J))", "using dgh dfg J"], ["proof (prove)\nusing this:\n  dh \\<le> dg\n  dg \\<le> df\n  J < dh\n\ngoal (1 subgoal):\n 1. (df - J - 1 - (j + (df - dh)) = dh - J - 1 - j &&&\n     int dg - int (i + (df - dh)) + int (j + (df - dh)) =\n     int dg - int i + int j) &&&\n    dg - J - 1 - (j + (df - dh) - (df - J)) =\n    dg - J - 1 - (j - (dh - J)) &&&\n    int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J)) =\n    int dh - int i + int (j - (dh - J))", "by auto"], ["proof (state)\nthis:\n  df - J - 1 - (j + (df - dh)) = dh - J - 1 - j\n  int dg - int (i + (df - dh)) + int (j + (df - dh)) =\n  int dg - int i + int j\n  dg - J - 1 - (j + (df - dh) - (df - J)) = dg - J - 1 - (j - (dh - J))\n  int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J)) =\n  int dh - int i + int (j - (dh - J))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dg - J + (dh - J); j < dg - J + (dh - J)\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n                          else if i + (df - dh) = n - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int (i + (df - dh)) + int (j + (df - dh) - (df - J))):]) =\n                         (if j < dh - J\n                          then if i = dg - J + (dh - J) - 1\n                               then monom (1::'a) (dh - J - 1 - j) * G\n                               else [:coeff_int G (int dg - int i + int j):]\n                          else if i = dg - J + (dh - J) - 1\n                               then monom (1::'a)\n                                     (dg - J - 1 - (j - (dh - J))) *\n                                    H\n                               else [:coeff_int H\n (int dh - int i + int (j - (dh - J))):])\n 2. dg - J + (dh - J) = dg - J + (dh - J)\n 3. dg - J + (dh - J) = dg - J + (dh - J)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j + (df - dh) < df - J\n     then if i + (df - dh) = n - 1\n          then monom (1::'a) (df - J - 1 - (j + (df - dh))) * G\n          else [:g (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n     else if i + (df - dh) = n - 1\n          then monom (1::'a) (dg - J - 1 - (j + (df - dh) - (df - J))) * H\n          else [:h (int df - int (i + (df - dh)) +\n                    int (j + (df - dh) - (df - J))):]) =\n    (if j < dh - J\n     then if i = dg - J + (dh - J) - 1\n          then monom (1::'a) (dh - J - 1 - j) * G\n          else [:coeff_int G (int dg - int i + int j):]\n     else if i = dg - J + (dh - J) - 1\n          then monom (1::'a) (dg - J - 1 - (j - (dh - J))) * H\n          else [:coeff_int H (int dh - int i + int (j - (dh - J))):])", "unfolding g[symmetric] h[symmetric] id3 id4 id5 id6"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j + (df - dh) < df - J\n     then if i + (df - dh) = n - 1 then monom (1::'a) (dh - J - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i + (df - dh) = n - 1\n          then monom (1::'a) (dg - J - 1 - (j - (dh - J))) * H\n          else [:h (int dh - int i + int (j - (dh - J))):]) =\n    (if j < dh - J\n     then if i = dg - J + (dh - J) - 1\n          then monom (1::'a) (dh - J - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = dg - J + (dh - J) - 1\n          then monom (1::'a) (dg - J - 1 - (j - (dh - J))) * H\n          else [:h (int dh - int i + int (j - (dh - J))):])", "by (rule if_cong[OF id1 if_cong[OF id2 refl refl] if_cong[OF id2 refl refl]])"], ["proof (state)\nthis:\n  (if j + (df - dh) < df - J\n   then if i + (df - dh) = n - 1\n        then monom (1::'a) (df - J - 1 - (j + (df - dh))) * G\n        else [:g (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n   else if i + (df - dh) = n - 1\n        then monom (1::'a) (dg - J - 1 - (j + (df - dh) - (df - J))) * H\n        else [:h (int df - int (i + (df - dh)) +\n                  int (j + (df - dh) - (df - J))):]) =\n  (if j < dh - J\n   then if i = dg - J + (dh - J) - 1 then monom (1::'a) (dh - J - 1 - j) * G\n        else [:coeff_int G (int dg - int i + int j):]\n   else if i = dg - J + (dh - J) - 1\n        then monom (1::'a) (dg - J - 1 - (j - (dh - J))) * H\n        else [:coeff_int H (int dh - int i + int (j - (dh - J))):])\n\ngoal (2 subgoals):\n 1. dg - J + (dh - J) = dg - J + (dh - J)\n 2. dg - J + (dh - J) = dg - J + (dh - J)", "qed auto"], ["proof (state)\nthis:\n  mat (dgj + dhj) (dgj + dhj)\n   (\\<lambda>(i, j).\n       if j + (df - dh) < dfj\n       then if i + (df - dh) = n - 1\n            then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n            else [:g (int dg - int (i + (df - dh)) + int (j + (df - dh))):]\n       else if i + (df - dh) = n - 1\n            then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n            else [:h (int df - int (i + (df - dh)) +\n                      int (j + (df - dh) - dfj)):]) =\n  subresultant_mat J G H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "finally"], ["proof (chain)\npicking this:\n  LR = subresultant_mat J G H", "have \"LR = ?LR\""], ["proof (prove)\nusing this:\n  LR = subresultant_mat J G H\n\ngoal (1 subgoal):\n 1. LR = subresultant_mat J G H", "."], ["proof (state)\nthis:\n  LR = subresultant_mat J G H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note spl = spl[unfolded this]"], ["proof (state)\nthis:\n  split_block\n   (mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]))\n   (df - dh) (df - dh) =\n  (UL, UR, LL, subresultant_mat J G H)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?UR = \"0\\<^sub>m (df - dh) (dgj + dhj)\""], ["proof (state)\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"UR = mat (df - dh) (dgj + dhj)\n       (\\<lambda> (i,j). ?GH i (j + (df - dh)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UR =\n    mat (df - dh) (dgj + dhj)\n     (\\<lambda>(i, j).\n         if j + (df - dh) < dfj\n         then if i = n - 1\n              then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n              else [:g (int dg - int i + int (j + (df - dh))):]\n         else if i = n - 1\n              then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n              else [:h (int df - int i + int (j + (df - dh) - dfj)):])", "using spl'"], ["proof (prove)\nusing this:\n  mat (df - dh) (df - dh)\n   (($$)\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):]))) =\n  UL \\<and>\n  mat (df - dh) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i, j + (df - dh))) =\n  UR \\<and>\n  mat (n - (df - dh)) (df - dh)\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j)) =\n  LL \\<and>\n  mat (n - (df - dh)) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j + (df - dh))) =\n  LR\n\ngoal (1 subgoal):\n 1. UR =\n    mat (df - dh) (dgj + dhj)\n     (\\<lambda>(i, j).\n         if j + (df - dh) < dfj\n         then if i = n - 1\n              then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n              else [:g (int dg - int i + int (j + (df - dh))):]\n         else if i = n - 1\n              then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n              else [:h (int df - int i + int (j + (df - dh) - dfj)):])", "by (auto simp: n_add)"], ["proof (state)\nthis:\n  UR =\n  mat (df - dh) (dgj + dhj)\n   (\\<lambda>(i, j).\n       if j + (df - dh) < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n            else [:g (int dg - int i + int (j + (df - dh))):]\n       else if i = n - 1\n            then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n            else [:h (int df - int i + int (j + (df - dh) - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  UR =\n  mat (df - dh) (dgj + dhj)\n   (\\<lambda>(i, j).\n       if j + (df - dh) < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n            else [:g (int dg - int i + int (j + (df - dh))):]\n       else if i = n - 1\n            then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n            else [:h (int df - int i + int (j + (df - dh) - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = ?UR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (df - dh) (dgj + dhj)\n     (\\<lambda>(i, j).\n         if j + (df - dh) < dfj\n         then if i = n - 1\n              then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n              else [:g (int dg - int i + int (j + (df - dh))):]\n         else if i = n - 1\n              then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n              else [:h (int df - int i + int (j + (df - dh) - dfj)):]) =\n    0\\<^sub>m (df - dh) (dgj + dhj)", "proof (rule eq_matI, unfold dim_row_mat dim_col_mat index_mat split dfj_def index_zero_mat, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "case (1 i j)"], ["proof (state)\nthis:\n  i < df - dh\n  j < dgj + dhj\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "hence in1: \"i \\<noteq> n - 1\""], ["proof (prove)\nusing this:\n  i < df - dh\n  j < dgj + dhj\n\ngoal (1 subgoal):\n 1. i \\<noteq> n - 1", "using J"], ["proof (prove)\nusing this:\n  i < df - dh\n  j < dgj + dhj\n  J < dh\n\ngoal (1 subgoal):\n 1. i \\<noteq> n - 1", "unfolding dgj_def dhj_def n_add"], ["proof (prove)\nusing this:\n  i < df - dh\n  j < dg - J + (dh - J)\n  J < dh\n\ngoal (1 subgoal):\n 1. i \\<noteq> df - dh + (dh - J + (dg - J)) - 1", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> n - 1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "{"], ["proof (state)\nthis:\n  i \\<noteq> n - 1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "assume \"j + (df - dh) < df - J\""], ["proof (state)\nthis:\n  j + (df - dh) < df - J\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "hence \"dg < int dg - int i + int (j + (df - dh))\""], ["proof (prove)\nusing this:\n  j + (df - dh) < df - J\n\ngoal (1 subgoal):\n 1. int dg < int dg - int i + int (j + (df - dh))", "using 1 J"], ["proof (prove)\nusing this:\n  j + (df - dh) < df - J\n  i < df - dh\n  j < dgj + dhj\n  J < dh\n\ngoal (1 subgoal):\n 1. int dg < int dg - int i + int (j + (df - dh))", "unfolding dgj_def dhj_def"], ["proof (prove)\nusing this:\n  j + (df - dh) < df - J\n  i < df - dh\n  j < dg - J + (dh - J)\n  J < dh\n\ngoal (1 subgoal):\n 1. int dg < int dg - int i + int (j + (df - dh))", "by auto"], ["proof (state)\nthis:\n  int dg < int dg - int i + int (j + (df - dh))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "hence \"g \\<dots> = 0\""], ["proof (prove)\nusing this:\n  int dg < int dg - int i + int (j + (df - dh))\n\ngoal (1 subgoal):\n 1. g (int dg - int i + int (j + (df - dh))) = (0::'a)", "unfolding dg g"], ["proof (prove)\nusing this:\n  int (degree G) < int (degree G) - int i + int (j + (df - dh))\n\ngoal (1 subgoal):\n 1. coeff_int G (int (degree G) - int i + int (j + (df - dh))) = (0::'a)", "by (intro coeff_int_eq_0, auto)"], ["proof (state)\nthis:\n  g (int dg - int i + int (j + (df - dh))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "}"], ["proof (state)\nthis:\n  j + (df - dh) < df - J \\<Longrightarrow>\n  g (int dg - int i + int (j + (df - dh))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "note g = this"], ["proof (state)\nthis:\n  j + (df - dh) < df - J \\<Longrightarrow>\n  g (int dg - int i + int (j + (df - dh))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "{"], ["proof (state)\nthis:\n  j + (df - dh) < df - J \\<Longrightarrow>\n  g (int dg - int i + int (j + (df - dh))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "assume \"\\<not> (j + (df - dh) < df - J)\""], ["proof (state)\nthis:\n  \\<not> j + (df - dh) < df - J\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "hence \"dh < int df - int i + int (j + (df - dh) - (df - J))\""], ["proof (prove)\nusing this:\n  \\<not> j + (df - dh) < df - J\n\ngoal (1 subgoal):\n 1. int dh < int df - int i + int (j + (df - dh) - (df - J))", "using 1 J"], ["proof (prove)\nusing this:\n  \\<not> j + (df - dh) < df - J\n  i < df - dh\n  j < dgj + dhj\n  J < dh\n\ngoal (1 subgoal):\n 1. int dh < int df - int i + int (j + (df - dh) - (df - J))", "unfolding dgj_def dhj_def"], ["proof (prove)\nusing this:\n  \\<not> j + (df - dh) < df - J\n  i < df - dh\n  j < dg - J + (dh - J)\n  J < dh\n\ngoal (1 subgoal):\n 1. int dh < int df - int i + int (j + (df - dh) - (df - J))", "by auto"], ["proof (state)\nthis:\n  int dh < int df - int i + int (j + (df - dh) - (df - J))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "hence \"h \\<dots> = 0\""], ["proof (prove)\nusing this:\n  int dh < int df - int i + int (j + (df - dh) - (df - J))\n\ngoal (1 subgoal):\n 1. h (int df - int i + int (j + (df - dh) - (df - J))) = (0::'a)", "unfolding dh h"], ["proof (prove)\nusing this:\n  int (degree H) < int df - int i + int (j + (df - degree H) - (df - J))\n\ngoal (1 subgoal):\n 1. coeff_int H (int df - int i + int (j + (df - degree H) - (df - J))) =\n    (0::'a)", "by (intro coeff_int_eq_0, auto)"], ["proof (state)\nthis:\n  h (int df - int i + int (j + (df - dh) - (df - J))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "}"], ["proof (state)\nthis:\n  \\<not> j + (df - dh) < df - J \\<Longrightarrow>\n  h (int df - int i + int (j + (df - dh) - (df - J))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "note h = this"], ["proof (state)\nthis:\n  \\<not> j + (df - dh) < df - J \\<Longrightarrow>\n  h (int df - int i + int (j + (df - dh) - (df - J))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < dgj + dhj\\<rbrakk>\n       \\<Longrightarrow> (if j + (df - dh) < df - J\n                          then if i = n - 1\n                               then monom (1::'a)\n                                     (df - J - 1 - (j + (df - dh))) *\n                                    G\n                               else [:g\n (int dg - int i + int (j + (df - dh))):]\n                          else if i = n - 1\n                               then monom (1::'a)\n                                     (dgj - 1 -\n(j + (df - dh) - (df - J))) *\n                                    H\n                               else [:h\n (int df - int i + int (j + (df - dh) - (df - J))):]) =\n                         0\n 2. df - dh = df - dh\n 3. dgj + dhj = dgj + dhj", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j + (df - dh) < df - J\n     then if i = n - 1 then monom (1::'a) (df - J - 1 - (j + (df - dh))) * G\n          else [:g (int dg - int i + int (j + (df - dh))):]\n     else if i = n - 1\n          then monom (1::'a) (dgj - 1 - (j + (df - dh) - (df - J))) * H\n          else [:h (int df - int i + int (j + (df - dh) - (df - J))):]) =\n    0", "using in1 g h"], ["proof (prove)\nusing this:\n  i \\<noteq> n - 1\n  j + (df - dh) < df - J \\<Longrightarrow>\n  g (int dg - int i + int (j + (df - dh))) = (0::'a)\n  \\<not> j + (df - dh) < df - J \\<Longrightarrow>\n  h (int df - int i + int (j + (df - dh) - (df - J))) = (0::'a)\n\ngoal (1 subgoal):\n 1. (if j + (df - dh) < df - J\n     then if i = n - 1 then monom (1::'a) (df - J - 1 - (j + (df - dh))) * G\n          else [:g (int dg - int i + int (j + (df - dh))):]\n     else if i = n - 1\n          then monom (1::'a) (dgj - 1 - (j + (df - dh) - (df - J))) * H\n          else [:h (int df - int i + int (j + (df - dh) - (df - J))):]) =\n    0", "by auto"], ["proof (state)\nthis:\n  (if j + (df - dh) < df - J\n   then if i = n - 1 then monom (1::'a) (df - J - 1 - (j + (df - dh))) * G\n        else [:g (int dg - int i + int (j + (df - dh))):]\n   else if i = n - 1\n        then monom (1::'a) (dgj - 1 - (j + (df - dh) - (df - J))) * H\n        else [:h (int df - int i + int (j + (df - dh) - (df - J))):]) =\n  0\n\ngoal (2 subgoals):\n 1. df - dh = df - dh\n 2. dgj + dhj = dgj + dhj", "qed auto"], ["proof (state)\nthis:\n  mat (df - dh) (dgj + dhj)\n   (\\<lambda>(i, j).\n       if j + (df - dh) < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - (j + (df - dh))) * G\n            else [:g (int dg - int i + int (j + (df - dh))):]\n       else if i = n - 1\n            then monom (1::'a) (dgj - 1 - (j + (df - dh) - dfj)) * H\n            else [:h (int df - int i + int (j + (df - dh) - dfj)):]) =\n  0\\<^sub>m (df - dh) (dgj + dhj)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "finally"], ["proof (chain)\npicking this:\n  UR = 0\\<^sub>m (df - dh) (dgj + dhj)", "have \"UR = ?UR\""], ["proof (prove)\nusing this:\n  UR = 0\\<^sub>m (df - dh) (dgj + dhj)\n\ngoal (1 subgoal):\n 1. UR = 0\\<^sub>m (df - dh) (dgj + dhj)", "."], ["proof (state)\nthis:\n  UR = 0\\<^sub>m (df - dh) (dgj + dhj)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note spl = spl[unfolded this]"], ["proof (state)\nthis:\n  split_block\n   (mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]))\n   (df - dh) (df - dh) =\n  (UL, 0\\<^sub>m (df - dh) (dgj + dhj), LL, subresultant_mat J G H)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?G = \"\\<lambda> (i,j). if i = j then [:lead_coeff G:] else if i < j then 0 else ?GH i j\""], ["proof (state)\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "let ?UL = \"mat (df - dh) (df - dh) ?G\""], ["proof (state)\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"UL = mat (df - dh) (df - dh) (\\<lambda> (i,j). ?GH i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UL =\n    mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])", "using spl'"], ["proof (prove)\nusing this:\n  mat (df - dh) (df - dh)\n   (($$)\n     (mat n n\n       (\\<lambda>(i, j).\n           if j < dfj\n           then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                else [:g (int dg - int i + int j):]\n           else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                else [:h (int df - int i + int (j - dfj)):]))) =\n  UL \\<and>\n  mat (df - dh) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i, j + (df - dh))) =\n  UR \\<and>\n  mat (n - (df - dh)) (df - dh)\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j)) =\n  LL \\<and>\n  mat (n - (df - dh)) (n - (df - dh))\n   (\\<lambda>(i, j).\n       mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]) $$\n       (i + (df - dh), j + (df - dh))) =\n  LR\n\ngoal (1 subgoal):\n 1. UL =\n    mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):])", "by (auto simp: n_add)"], ["proof (state)\nthis:\n  UL =\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  UL =\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = ?UL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) =\n    mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if i = j then [:lead_coeff G:]\n         else if i < j then 0\n              else if j < dfj\n                   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                        else [:g (int dg - int i + int j):]\n                   else if i = n - 1\n                        then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                        else [:h (int df - int i + int (j - dfj)):])", "proof (rule eq_matI, unfold dim_row_mat dim_col_mat index_mat split, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "case (1 i j)"], ["proof (state)\nthis:\n  i < df - dh\n  j < df - dh\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "{"], ["proof (state)\nthis:\n  i < df - dh\n  j < df - dh\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "hence \"int dg - int i + int j = dg\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. int dg - int i + int j = int dg", "using 1"], ["proof (prove)\nusing this:\n  i = j\n  i < df - dh\n  j < df - dh\n\ngoal (1 subgoal):\n 1. int dg - int i + int j = int dg", "by auto"], ["proof (state)\nthis:\n  int dg - int i + int j = int dg\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "hence \"g (int dg - int i + int j) = lead_coeff G\""], ["proof (prove)\nusing this:\n  int dg - int i + int j = int dg\n\ngoal (1 subgoal):\n 1. g (int dg - int i + int j) = lead_coeff G", "unfolding g dg coeff_int_def"], ["proof (prove)\nusing this:\n  int (degree G) - int i + int j = int (degree G)\n\ngoal (1 subgoal):\n 1. (if int (degree G) - int i + int j < 0 then 0::'a\n     else coeff G (nat (int (degree G) - int i + int j))) =\n    lead_coeff G", "by simp"], ["proof (state)\nthis:\n  g (int dg - int i + int j) = lead_coeff G\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "}"], ["proof (state)\nthis:\n  i = j \\<Longrightarrow> g (int dg - int i + int j) = lead_coeff G\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "note eq = this"], ["proof (state)\nthis:\n  i = j \\<Longrightarrow> g (int dg - int i + int j) = lead_coeff G\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "{"], ["proof (state)\nthis:\n  i = j \\<Longrightarrow> g (int dg - int i + int j) = lead_coeff G\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "hence \"dg < int dg - int i + int j\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. int dg < int dg - int i + int j", "using 1"], ["proof (prove)\nusing this:\n  i < j\n  i < df - dh\n  j < df - dh\n\ngoal (1 subgoal):\n 1. int dg < int dg - int i + int j", "by auto"], ["proof (state)\nthis:\n  int dg < int dg - int i + int j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "hence \"g (int dg - int i + int j) = 0\""], ["proof (prove)\nusing this:\n  int dg < int dg - int i + int j\n\ngoal (1 subgoal):\n 1. g (int dg - int i + int j) = (0::'a)", "unfolding g dg"], ["proof (prove)\nusing this:\n  int (degree G) < int (degree G) - int i + int j\n\ngoal (1 subgoal):\n 1. coeff_int G (int (degree G) - int i + int j) = (0::'a)", "by (intro coeff_int_eq_0, auto)"], ["proof (state)\nthis:\n  g (int dg - int i + int j) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "}"], ["proof (state)\nthis:\n  i < j \\<Longrightarrow> g (int dg - int i + int j) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "note lt = this"], ["proof (state)\nthis:\n  i < j \\<Longrightarrow> g (int dg - int i + int j) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "from 1"], ["proof (chain)\npicking this:\n  i < df - dh\n  j < df - dh", "have *: \"j < dfj\" \"i \\<noteq> n - 1\""], ["proof (prove)\nusing this:\n  i < df - dh\n  j < df - dh\n\ngoal (1 subgoal):\n 1. j < dfj &&& i \\<noteq> n - 1", "using J"], ["proof (prove)\nusing this:\n  i < df - dh\n  j < df - dh\n  J < dh\n\ngoal (1 subgoal):\n 1. j < dfj &&& i \\<noteq> n - 1", "unfolding n_add dhj_def dgj_def dfj_def"], ["proof (prove)\nusing this:\n  i < df - dh\n  j < df - dh\n  J < dh\n\ngoal (1 subgoal):\n 1. j < df - J &&& i \\<noteq> df - dh + (dh - J + (dg - J)) - 1", "by auto"], ["proof (state)\nthis:\n  j < dfj\n  i \\<noteq> n - 1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "hence \"?GH i j = [:g (int dg - int i + int j):]\""], ["proof (prove)\nusing this:\n  j < dfj\n  i \\<noteq> n - 1\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    [:g (int dg - int i + int j):]", "by simp"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  [:g (int dg - int i + int j):]\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "also"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  [:g (int dg - int i + int j):]\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "have \"\\<dots> = (if i = j then [: lead_coeff G :] else if i < j then 0 else ?GH i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:g (int dg - int i + int j):] =\n    (if i = j then [:lead_coeff G:]\n     else if i < j then 0\n          else if j < dfj\n               then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                    else [:g (int dg - int i + int j):]\n               else if i = n - 1\n                    then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                    else [:h (int df - int i + int (j - dfj)):])", "using eq lt *"], ["proof (prove)\nusing this:\n  i = j \\<Longrightarrow> g (int dg - int i + int j) = lead_coeff G\n  i < j \\<Longrightarrow> g (int dg - int i + int j) = (0::'a)\n  j < dfj\n  i \\<noteq> n - 1\n\ngoal (1 subgoal):\n 1. [:g (int dg - int i + int j):] =\n    (if i = j then [:lead_coeff G:]\n     else if i < j then 0\n          else if j < dfj\n               then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                    else [:g (int dg - int i + int j):]\n               else if i = n - 1\n                    then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                    else [:h (int df - int i + int (j - dfj)):])", "by auto"], ["proof (state)\nthis:\n  [:g (int dg - int i + int j):] =\n  (if i = j then [:lead_coeff G:]\n   else if i < j then 0\n        else if j < dfj\n             then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                  else [:g (int dg - int i + int j):]\n             else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                  else [:h (int df - int i + int (j - dfj)):])\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < df - dh; j < df - dh\\<rbrakk>\n       \\<Longrightarrow> (if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h\n (int df - int i + int (j - dfj)):]) =\n                         (if i = j then [:lead_coeff G:]\n                          else if i < j then 0\n                               else if j < dfj\n                                    then if i = n - 1\n   then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                    else if i = n - 1\n   then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n   else [:h (int df - int i + int (j - dfj)):])\n 2. df - dh = df - dh\n 3. df - dh = df - dh", "finally"], ["proof (chain)\npicking this:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  (if i = j then [:lead_coeff G:]\n   else if i < j then 0\n        else if j < dfj\n             then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                  else [:g (int dg - int i + int j):]\n             else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                  else [:h (int df - int i + int (j - dfj)):])", "show ?case"], ["proof (prove)\nusing this:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  (if i = j then [:lead_coeff G:]\n   else if i < j then 0\n        else if j < dfj\n             then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                  else [:g (int dg - int i + int j):]\n             else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                  else [:h (int df - int i + int (j - dfj)):])\n\ngoal (1 subgoal):\n 1. (if j < dfj\n     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n          else [:g (int dg - int i + int j):]\n     else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n          else [:h (int df - int i + int (j - dfj)):]) =\n    (if i = j then [:lead_coeff G:]\n     else if i < j then 0\n          else if j < dfj\n               then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                    else [:g (int dg - int i + int j):]\n               else if i = n - 1\n                    then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                    else [:h (int df - int i + int (j - dfj)):])", "by simp"], ["proof (state)\nthis:\n  (if j < dfj\n   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n        else [:g (int dg - int i + int j):]\n   else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n        else [:h (int df - int i + int (j - dfj)):]) =\n  (if i = j then [:lead_coeff G:]\n   else if i < j then 0\n        else if j < dfj\n             then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                  else [:g (int dg - int i + int j):]\n             else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                  else [:h (int df - int i + int (j - dfj)):])\n\ngoal (2 subgoals):\n 1. df - dh = df - dh\n 2. df - dh = df - dh", "qed auto"], ["proof (state)\nthis:\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) =\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if i = j then [:lead_coeff G:]\n       else if i < j then 0\n            else if j < dfj\n                 then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                      else [:h (int df - int i + int (j - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "finally"], ["proof (chain)\npicking this:\n  UL =\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if i = j then [:lead_coeff G:]\n       else if i < j then 0\n            else if j < dfj\n                 then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                      else [:h (int df - int i + int (j - dfj)):])", "have \"UL = ?UL\""], ["proof (prove)\nusing this:\n  UL =\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if i = j then [:lead_coeff G:]\n       else if i < j then 0\n            else if j < dfj\n                 then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                      else [:h (int df - int i + int (j - dfj)):])\n\ngoal (1 subgoal):\n 1. UL =\n    mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if i = j then [:lead_coeff G:]\n         else if i < j then 0\n              else if j < dfj\n                   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                        else [:g (int dg - int i + int j):]\n                   else if i = n - 1\n                        then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                        else [:h (int df - int i + int (j - dfj)):])", "."], ["proof (state)\nthis:\n  UL =\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if i = j then [:lead_coeff G:]\n       else if i < j then 0\n            else if j < dfj\n                 then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                      else [:h (int df - int i + int (j - dfj)):])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "note spl = spl[unfolded this]"], ["proof (state)\nthis:\n  split_block\n   (mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]))\n   (df - dh) (df - dh) =\n  (mat (df - dh) (df - dh)\n    (\\<lambda>(i, j).\n        if i = j then [:lead_coeff G:]\n        else if i < j then 0\n             else if j < dfj\n                  then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                       else [:g (int dg - int i + int j):]\n                  else if i = n - 1\n                       then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                       else [:h (int df - int i + int (j - dfj)):]),\n   0\\<^sub>m (df - dh) (dgj + dhj), LL, subresultant_mat J G H)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "from split_block[OF spl dim]"], ["proof (chain)\npicking this:\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if i = j then [:lead_coeff G:]\n       else if i < j then 0\n            else if j < dfj\n                 then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                      else [:h (int df - int i + int (j - dfj)):])\n  \\<in> carrier_mat (df - dh) (df - dh)\n  0\\<^sub>m (df - dh) (dgj + dhj) \\<in> carrier_mat (df - dh) (dhj + dgj)\n  LL \\<in> carrier_mat (dhj + dgj) (df - dh)\n  subresultant_mat J G H \\<in> carrier_mat (dhj + dgj) (dhj + dgj)\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) =\n  four_block_mat\n   (mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if i = j then [:lead_coeff G:]\n         else if i < j then 0\n              else if j < dfj\n                   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                        else [:g (int dg - int i + int j):]\n                   else if i = n - 1\n                        then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                        else [:h (int df - int i + int (j - dfj)):]))\n   (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H)", "have GH: \"?G_H = four_block_mat ?UL ?UR LL ?LR\"\n      and C: \"?UL \\<in> carrier_mat (df - dh) (df - dh)\"\n      \"?UR \\<in> carrier_mat (df - dh) (dhj + dgj)\"\n      \"LL \\<in> carrier_mat (dhj + dgj) (df - dh)\"\n      \"?LR \\<in> carrier_mat (dhj + dgj) (dhj + dgj)\""], ["proof (prove)\nusing this:\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if i = j then [:lead_coeff G:]\n       else if i < j then 0\n            else if j < dfj\n                 then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                      else [:h (int df - int i + int (j - dfj)):])\n  \\<in> carrier_mat (df - dh) (df - dh)\n  0\\<^sub>m (df - dh) (dgj + dhj) \\<in> carrier_mat (df - dh) (dhj + dgj)\n  LL \\<in> carrier_mat (dhj + dgj) (df - dh)\n  subresultant_mat J G H \\<in> carrier_mat (dhj + dgj) (dhj + dgj)\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) =\n  four_block_mat\n   (mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if i = j then [:lead_coeff G:]\n         else if i < j then 0\n              else if j < dfj\n                   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                        else [:g (int dg - int i + int j):]\n                   else if i = n - 1\n                        then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                        else [:h (int df - int i + int (j - dfj)):]))\n   (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if j < dfj\n         then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n              else [:g (int dg - int i + int j):]\n         else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n              else [:h (int df - int i + int (j - dfj)):]) =\n    four_block_mat\n     (mat (df - dh) (df - dh)\n       (\\<lambda>(i, j).\n           if i = j then [:lead_coeff G:]\n           else if i < j then 0\n                else if j < dfj\n                     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                          else [:g (int dg - int i + int j):]\n                     else if i = n - 1\n                          then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                          else [:h (int df - int i + int (j - dfj)):]))\n     (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H) &&&\n    (mat (df - dh) (df - dh)\n      (\\<lambda>(i, j).\n          if i = j then [:lead_coeff G:]\n          else if i < j then 0\n               else if j < dfj\n                    then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                         else [:g (int dg - int i + int j):]\n                    else if i = n - 1\n                         then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                         else [:h (int df - int i + int (j - dfj)):])\n     \\<in> carrier_mat (df - dh) (df - dh) &&&\n     0\\<^sub>m (df - dh) (dgj + dhj)\n     \\<in> carrier_mat (df - dh) (dhj + dgj)) &&&\n    LL \\<in> carrier_mat (dhj + dgj) (df - dh) &&&\n    subresultant_mat J G H \\<in> carrier_mat (dhj + dgj) (dhj + dgj)", "by auto"], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i, j).\n       if j < dfj\n       then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n            else [:g (int dg - int i + int j):]\n       else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n            else [:h (int df - int i + int (j - dfj)):]) =\n  four_block_mat\n   (mat (df - dh) (df - dh)\n     (\\<lambda>(i, j).\n         if i = j then [:lead_coeff G:]\n         else if i < j then 0\n              else if j < dfj\n                   then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                        else [:g (int dg - int i + int j):]\n                   else if i = n - 1\n                        then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                        else [:h (int df - int i + int (j - dfj)):]))\n   (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H)\n  mat (df - dh) (df - dh)\n   (\\<lambda>(i, j).\n       if i = j then [:lead_coeff G:]\n       else if i < j then 0\n            else if j < dfj\n                 then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                      else [:g (int dg - int i + int j):]\n                 else if i = n - 1\n                      then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                      else [:h (int df - int i + int (j - dfj)):])\n  \\<in> carrier_mat (df - dh) (df - dh)\n  0\\<^sub>m (df - dh) (dgj + dhj) \\<in> carrier_mat (df - dh) (dhj + dgj)\n  LL \\<in> carrier_mat (dhj + dgj) (df - dh)\n  subresultant_mat J G H \\<in> carrier_mat (dhj + dgj) (dhj + dgj)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "from arg_cong[OF GH, of det]"], ["proof (chain)\npicking this:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  det (four_block_mat\n        (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):]))\n        (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H))", "have \"det ?G_H = det (four_block_mat ?UL ?UR LL ?LR)\""], ["proof (prove)\nusing this:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  det (four_block_mat\n        (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):]))\n        (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H))\n\ngoal (1 subgoal):\n 1. det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])) =\n    det (four_block_mat\n          (mat (df - dh) (df - dh)\n            (\\<lambda>(i, j).\n                if i = j then [:lead_coeff G:]\n                else if i < j then 0\n                     else if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h (int df - int i + int (j - dfj)):]))\n          (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H))", "unfolding GH[symmetric]"], ["proof (prove)\nusing this:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):]))\n\ngoal (1 subgoal):\n 1. det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])) =\n    det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):]))", ".."], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  det (four_block_mat\n        (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):]))\n        (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H))\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  det (four_block_mat\n        (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):]))\n        (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H))\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = det ?UL * det ?LR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat\n          (mat (df - dh) (df - dh)\n            (\\<lambda>(i, j).\n                if i = j then [:lead_coeff G:]\n                else if i < j then 0\n                     else if j < dfj\n                          then if i = n - 1\n                               then monom (1::'a) (dfj - 1 - j) * G\n                               else [:g (int dg - int i + int j):]\n                          else if i = n - 1\n                               then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                               else [:h (int df - int i + int (j - dfj)):]))\n          (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H)) =\n    det (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):])) *\n    det (subresultant_mat J G H)", "by (rule det_four_block_mat_upper_right_zero[OF _ refl], insert C, auto simp: ac_simps)"], ["proof (state)\nthis:\n  det (four_block_mat\n        (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):]))\n        (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H)) =\n  det (mat (df - dh) (df - dh)\n        (\\<lambda>(i, j).\n            if i = j then [:lead_coeff G:]\n            else if i < j then 0\n                 else if j < dfj\n                      then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                           else [:g (int dg - int i + int j):]\n                      else if i = n - 1\n                           then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                           else [:h (int df - int i + int (j - dfj)):])) *\n  det (subresultant_mat J G H)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  det (four_block_mat\n        (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):]))\n        (0\\<^sub>m (df - dh) (dgj + dhj)) LL (subresultant_mat J G H)) =\n  det (mat (df - dh) (df - dh)\n        (\\<lambda>(i, j).\n            if i = j then [:lead_coeff G:]\n            else if i < j then 0\n                 else if j < dfj\n                      then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                           else [:g (int dg - int i + int j):]\n                      else if i = n - 1\n                           then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                           else [:h (int df - int i + int (j - dfj)):])) *\n  det (subresultant_mat J G H)\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"det ?LR = subresultant J G H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant_mat J G H) = subresultant J G H", "unfolding subresultant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (subresultant_mat J G H) = det (subresultant_mat J G H)", "by simp"], ["proof (state)\nthis:\n  det (subresultant_mat J G H) = subresultant J G H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  det (subresultant_mat J G H) = subresultant J G H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"det ?UL = prod_list (diag_mat ?UL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (df - dh) (df - dh)\n          (\\<lambda>(i, j).\n              if i = j then [:lead_coeff G:]\n              else if i < j then 0\n                   else if j < dfj\n                        then if i = n - 1\n                             then monom (1::'a) (dfj - 1 - j) * G\n                             else [:g (int dg - int i + int j):]\n                        else if i = n - 1\n                             then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                             else [:h (int df - int i + int (j - dfj)):])) =\n    prod_list\n     (diag_mat\n       (mat (df - dh) (df - dh)\n         (\\<lambda>(i, j).\n             if i = j then [:lead_coeff G:]\n             else if i < j then 0\n                  else if j < dfj\n                       then if i = n - 1\n                            then monom (1::'a) (dfj - 1 - j) * G\n                            else [:g (int dg - int i + int j):]\n                       else if i = n - 1\n                            then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                            else [:h (int df - int i + int (j - dfj)):])))", "by (rule det_lower_triangular[of \"df - dh\"], auto)"], ["proof (state)\nthis:\n  det (mat (df - dh) (df - dh)\n        (\\<lambda>(i, j).\n            if i = j then [:lead_coeff G:]\n            else if i < j then 0\n                 else if j < dfj\n                      then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                           else [:g (int dg - int i + int j):]\n                      else if i = n - 1\n                           then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                           else [:h (int df - int i + int (j - dfj)):])) =\n  prod_list\n   (diag_mat\n     (mat (df - dh) (df - dh)\n       (\\<lambda>(i, j).\n           if i = j then [:lead_coeff G:]\n           else if i < j then 0\n                else if j < dfj\n                     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                          else [:g (int dg - int i + int j):]\n                     else if i = n - 1\n                          then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                          else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  det (mat (df - dh) (df - dh)\n        (\\<lambda>(i, j).\n            if i = j then [:lead_coeff G:]\n            else if i < j then 0\n                 else if j < dfj\n                      then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                           else [:g (int dg - int i + int j):]\n                      else if i = n - 1\n                           then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                           else [:h (int df - int i + int (j - dfj)):])) =\n  prod_list\n   (diag_mat\n     (mat (df - dh) (df - dh)\n       (\\<lambda>(i, j).\n           if i = j then [:lead_coeff G:]\n           else if i < j then 0\n                else if j < dfj\n                     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                          else [:g (int dg - int i + int j):]\n                     else if i = n - 1\n                          then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                          else [:h (int df - int i + int (j - dfj)):])))\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = (\\<Prod>i = 0..< (df - dh). [: lead_coeff G :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (df - dh) (df - dh)\n         (\\<lambda>(i, j).\n             if i = j then [:lead_coeff G:]\n             else if i < j then 0\n                  else if j < dfj\n                       then if i = n - 1\n                            then monom (1::'a) (dfj - 1 - j) * G\n                            else [:g (int dg - int i + int j):]\n                       else if i = n - 1\n                            then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                            else [:h (int df - int i + int (j - dfj)):]))) =\n    (\\<Prod>i = 0..<df - dh. [:lead_coeff G:])", "unfolding prod_list_diag_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_row\n                     (mat (df - dh) (df - dh)\n                       (\\<lambda>(i, j).\n                           if i = j then [:lead_coeff G:]\n                           else if i < j then 0\n                                else if j < dfj\n                                     then if i = n - 1\n    then monom (1::'a) (dfj - 1 - j) * G else [:g (int dg - int i + int j):]\n                                     else if i = n - 1\n    then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n    else [:h (int df - int i + int (j - dfj)):])).\n        mat (df - dh) (df - dh)\n         (\\<lambda>(i, j).\n             if i = j then [:lead_coeff G:]\n             else if i < j then 0\n                  else if j < dfj\n                       then if i = n - 1\n                            then monom (1::'a) (dfj - 1 - j) * G\n                            else [:g (int dg - int i + int j):]\n                       else if i = n - 1\n                            then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                            else [:h (int df - int i + int (j - dfj)):]) $$\n        (i, i)) =\n    (\\<Prod>i = 0..<df - dh. [:lead_coeff G:])", "by simp"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat (df - dh) (df - dh)\n       (\\<lambda>(i, j).\n           if i = j then [:lead_coeff G:]\n           else if i < j then 0\n                else if j < dfj\n                     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                          else [:g (int dg - int i + int j):]\n                     else if i = n - 1\n                          then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                          else [:h (int df - int i + int (j - dfj)):]))) =\n  (\\<Prod>i = 0..<df - dh. [:lead_coeff G:])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat (df - dh) (df - dh)\n       (\\<lambda>(i, j).\n           if i = j then [:lead_coeff G:]\n           else if i < j then 0\n                else if j < dfj\n                     then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                          else [:g (int dg - int i + int j):]\n                     else if i = n - 1\n                          then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                          else [:h (int df - int i + int (j - dfj)):]))) =\n  (\\<Prod>i = 0..<df - dh. [:lead_coeff G:])\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> = [: lead_coeff G ^ (df - dh) :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<df - dh. [:lead_coeff G:]) =\n    [:lead_coeff G ^ (df - dh):]", "by (simp add: poly_const_pow)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<df - dh. [:lead_coeff G:]) = [:lead_coeff G ^ (df - dh):]\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "finally"], ["proof (chain)\npicking this:\n  det (mat n n\n        (\\<lambda>a.\n            case a of\n            (i, j) \\<Rightarrow>\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])) =\n  [:lead_coeff G ^ (df - dh):] * subresultant J G H", "have det: \"det ?G_H = [:lead_coeff G ^ (df - dh):] * subresultant J G H\""], ["proof (prove)\nusing this:\n  det (mat n n\n        (\\<lambda>a.\n            case a of\n            (i, j) \\<Rightarrow>\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])) =\n  [:lead_coeff G ^ (df - dh):] * subresultant J G H\n\ngoal (1 subgoal):\n 1. det (mat n n\n          (\\<lambda>(i, j).\n              if j < dfj\n              then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                   else [:g (int dg - int i + int j):]\n              else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                   else [:h (int df - int i + int (j - dfj)):])) =\n    [:lead_coeff G ^ (df - dh):] * subresultant J G H", "by auto"], ["proof (state)\nthis:\n  det (mat n n\n        (\\<lambda>(i, j).\n            if j < dfj\n            then if i = n - 1 then monom (1::'a) (dfj - 1 - j) * G\n                 else [:g (int dg - int i + int j):]\n            else if i = n - 1 then monom (1::'a) (dgj - 1 - (j - dfj)) * H\n                 else [:h (int df - int i + int (j - dfj)):])) =\n  [:lead_coeff G ^ (df - dh):] * subresultant J G H\n\ngoal (4 subgoals):\n 1. J < dh \\<Longrightarrow>\n    subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)\n 2. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 3. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 4. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "show \"subresultant J F G = smult (?m1 * lead_coeff G ^ (df - dh)) (subresultant J G H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)", "unfolding eq_18 det"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ ((df - J) * (dg - J)))\n     ([:lead_coeff G ^ (df - dh):] * subresultant J G H) =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n     (subresultant J G H)", "by simp"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n   (subresultant J G H)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "}"], ["proof (state)\nthis:\n  J < dh \\<Longrightarrow>\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n   (subresultant J G H)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "{"], ["proof (state)\nthis:\n  J < dh \\<Longrightarrow>\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - dh))\n   (subresultant J G H)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "assume J: \"dh < J\" \"J < dg - 1\""], ["proof (state)\nthis:\n  dh < J\n  J < dg - 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "hence \"dh \\<le> J\" \"J < dg\""], ["proof (prove)\nusing this:\n  dh < J\n  J < dg - 1\n\ngoal (1 subgoal):\n 1. dh \\<le> J &&& J < dg", "by auto"], ["proof (state)\nthis:\n  dh \\<le> J\n  J < dg\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "from eq_19[OF this]"], ["proof (chain)\npicking this:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) *\n    coeff H J ^ (dg - J - 1))\n   H", "have \"subresultant J F G = smult ((- 1) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) * coeff H J ^ (dg - J - 1)) H\""], ["proof (prove)\nusing this:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) *\n    coeff H J ^ (dg - J - 1))\n   H\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) *\n      coeff H J ^ (dg - J - 1))\n     H", "by simp"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) *\n    coeff H J ^ (dg - J - 1))\n   H\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) *\n    coeff H J ^ (dg - J - 1))\n   H\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"coeff H J = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff H J = (0::'a)", "by (rule coeff_eq_0, insert J, auto simp: dh)"], ["proof (state)\nthis:\n  coeff H J = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "also"], ["proof (state)\nthis:\n  coeff H J = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have \"\\<dots> ^ (dg - J - 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) ^ (dg - J - 1) = (0::'a)", "using J"], ["proof (prove)\nusing this:\n  dh < J\n  J < dg - 1\n\ngoal (1 subgoal):\n 1. (0::'a) ^ (dg - J - 1) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (0::'a) ^ (dg - J - 1) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant J F G = 0\n 3. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "finally"], ["proof (chain)\npicking this:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) * (0::'a))\n   H", "show \"subresultant J F G = 0\""], ["proof (prove)\nusing this:\n  subresultant J F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - J) * (dg - J)) * lead_coeff G ^ (df - J) * (0::'a))\n   H\n\ngoal (1 subgoal):\n 1. subresultant J F G = 0", "by simp"], ["proof (state)\nthis:\n  subresultant J F G = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "}"], ["proof (state)\nthis:\n  \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n  \\<Longrightarrow> subresultant J F G = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "{"], ["proof (state)\nthis:\n  \\<lbrakk>dh < J; J < dg - 1\\<rbrakk>\n  \\<Longrightarrow> subresultant J F G = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "assume J: \"J = dh\" and \"dg > dh \\<or> H \\<noteq> 0\""], ["proof (state)\nthis:\n  J = dh\n  dh < dg \\<or> H \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "with choice"], ["proof (chain)\npicking this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  J = dh\n  dh < dg \\<or> H \\<noteq> 0", "have dgh: \"dg > dh\""], ["proof (prove)\nusing this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  J = dh\n  dh < dg \\<or> H \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dh < dg", "by auto"], ["proof (state)\nthis:\n  dh < dg\n\ngoal (2 subgoals):\n 1. \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant dh F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                        lead_coeff G ^ (df - dh) *\n                        lead_coeff H ^ (dg - dh - 1))\n                       H\n 2. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "show \"subresultant dh F G = smult (\n      (-1)^((df - dh) * (dg - dh)) * lead_coeff G ^ (df - dh) * lead_coeff H ^ (dg - dh - 1)) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant dh F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - dh) * (dg - dh)) * lead_coeff G ^ (df - dh) *\n      lead_coeff H ^ (dg - dh - 1))\n     H", "unfolding eq_19[unfolded J, OF le_refl dgh]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- (1::'a)) ^ ((df - dh) * (dg - dh)) * lead_coeff G ^ (df - dh) *\n      coeff H dh ^ (dg - dh - 1))\n     H =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - dh) * (dg - dh)) * lead_coeff G ^ (df - dh) *\n      lead_coeff H ^ (dg - dh - 1))\n     H", "unfolding dh"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- (1::'a)) ^ ((df - degree H) * (dg - degree H)) *\n      lead_coeff G ^ (df - degree H) *\n      lead_coeff H ^ (dg - degree H - 1))\n     H =\n    Polynomial.smult\n     ((- (1::'a)) ^ ((df - degree H) * (dg - degree H)) *\n      lead_coeff G ^ (df - degree H) *\n      lead_coeff H ^ (dg - degree H - 1))\n     H", "by simp"], ["proof (state)\nthis:\n  subresultant dh F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((df - dh) * (dg - dh)) * lead_coeff G ^ (df - dh) *\n    lead_coeff H ^ (dg - dh - 1))\n   H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "}"], ["proof (state)\nthis:\n  \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> subresultant dh F G =\n                    Polynomial.smult\n                     ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                      lead_coeff G ^ (df - dh) *\n                      lead_coeff H ^ (dg - dh - 1))\n                     H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "{"], ["proof (state)\nthis:\n  \\<lbrakk>J = dh; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> subresultant dh F G =\n                    Polynomial.smult\n                     ((- (1::'a)) ^ ((df - dh) * (dg - dh)) *\n                      lead_coeff G ^ (df - dh) *\n                      lead_coeff H ^ (dg - dh - 1))\n                     H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "assume J: \"J = dg - 1\" and \"dg > dh \\<or> H \\<noteq> 0\""], ["proof (state)\nthis:\n  J = dg - 1\n  dh < dg \\<or> H \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "with choice"], ["proof (chain)\npicking this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  J = dg - 1\n  dh < dg \\<or> H \\<noteq> 0", "have dgh: \"dg > dh\""], ["proof (prove)\nusing this:\n  dh < dg \\<or> H = 0 \\<and> F \\<noteq> 0 \\<and> G \\<noteq> 0\n  J = dg - 1\n  dh < dg \\<or> H \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dh < dg", "by auto"], ["proof (state)\nthis:\n  dh < dg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have *: \"dh \\<le> dg - 1\" \"dg - 1 < dg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dh \\<le> dg - 1 &&& dg - 1 < dg", "using dgh"], ["proof (prove)\nusing this:\n  dh < dg\n\ngoal (1 subgoal):\n 1. dh \\<le> dg - 1 &&& dg - 1 < dg", "by auto"], ["proof (state)\nthis:\n  dh \\<le> dg - 1\n  dg - 1 < dg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "have **: \"df - (dg - 1) = df - dg + 1\" \"dg - (dg - 1) - 1 = 0\" \"dg - (dg - 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. df - (dg - 1) = df - dg + 1 &&&\n    dg - (dg - 1) - 1 = 0 &&& dg - (dg - 1) = 1", "using dfg dgh"], ["proof (prove)\nusing this:\n  dg \\<le> df\n  dh < dg\n\ngoal (1 subgoal):\n 1. df - (dg - 1) = df - dg + 1 &&&\n    dg - (dg - 1) - 1 = 0 &&& dg - (dg - 1) = 1", "by linarith+"], ["proof (state)\nthis:\n  df - (dg - 1) = df - dg + 1\n  dg - (dg - 1) - 1 = 0\n  dg - (dg - 1) = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant (dg - 1) F G =\n                      Polynomial.smult\n                       ((- (1::'a)) ^ (df - dg + 1) *\n                        lead_coeff G ^ (df - dg + 1))\n                       H", "show \"subresultant (dg - 1) F G = smult (\n      (-1)^(df - dg + 1) * lead_coeff G ^ (df - dg + 1)) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant (dg - 1) F G =\n    Polynomial.smult\n     ((- (1::'a)) ^ (df - dg + 1) * lead_coeff G ^ (df - dg + 1)) H", "unfolding eq_19[unfolded J, OF *]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- (1::'a)) ^ ((df - (dg - 1)) * (dg - (dg - 1))) *\n      lead_coeff G ^ (df - (dg - 1)) *\n      coeff H (dg - 1) ^ (dg - (dg - 1) - 1))\n     H =\n    Polynomial.smult\n     ((- (1::'a)) ^ (df - dg + 1) * lead_coeff G ^ (df - dg + 1)) H", "unfolding **"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- (1::'a)) ^ ((df - dg + 1) * 1) * lead_coeff G ^ (df - dg + 1) *\n      coeff H (dg - 1) ^ (1 - 1))\n     H =\n    Polynomial.smult\n     ((- (1::'a)) ^ (df - dg + 1) * lead_coeff G ^ (df - dg + 1)) H", "by simp"], ["proof (state)\nthis:\n  subresultant (dg - 1) F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ (df - dg + 1) * lead_coeff G ^ (df - dg + 1)) H\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>J = dg - 1; dh < dg \\<or> H \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> subresultant (dg - 1) F G =\n                    Polynomial.smult\n                     ((- (1::'a)) ^ (df - dg + 1) *\n                      lead_coeff G ^ (df - dg + 1))\n                     H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas BT_lemma_1_13 = BT_lemma_1_13'[OF _ _ _ refl]"], ["", "lemmas BT_lemma_1_15 = BT_lemma_1_15'[OF _ _ _ refl]"], ["", "lemma subresultant_product: fixes F :: \"'a :: idom poly\"\n  assumes \"F = B * G\"\n  and FG: \"degree F \\<ge> degree G\"\nshows \"subresultant J F G = (if J < degree G then 0 else\n   if J < degree F then smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "proof (cases \"J < degree G\")"], ["proof (state)\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "case J: True"], ["proof (state)\nthis:\n  J < degree G\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "from assms"], ["proof (chain)\npicking this:\n  F = B * G\n  degree G \\<le> degree F", "have eq: \"F + (-B) * G = 0\""], ["proof (prove)\nusing this:\n  F = B * G\n  degree G \\<le> degree F\n\ngoal (1 subgoal):\n 1. F + - B * G = 0", "by auto"], ["proof (state)\nthis:\n  F + - B * G = 0\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "from J"], ["proof (chain)\npicking this:\n  J < degree G", "have lt: \"degree 0 < degree G \\<or> b\" for b"], ["proof (prove)\nusing this:\n  J < degree G\n\ngoal (1 subgoal):\n 1. degree 0 < degree G \\<or> b", "by auto"], ["proof (state)\nthis:\n  degree 0 < degree G \\<or> ?b1\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "from BT_lemma_1_13[OF eq FG lt lt]"], ["proof (chain)\npicking this:\n  subresultant (degree 0) F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((degree F - degree 0) * (degree G - degree 0)) *\n    lead_coeff G ^ (degree F - degree 0) *\n    lead_coeff 0 ^ (degree G - degree 0 - 1))\n   0", "have \"subresultant 0 F G = 0\""], ["proof (prove)\nusing this:\n  subresultant (degree 0) F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((degree F - degree 0) * (degree G - degree 0)) *\n    lead_coeff G ^ (degree F - degree 0) *\n    lead_coeff 0 ^ (degree G - degree 0 - 1))\n   0\n\ngoal (1 subgoal):\n 1. subresultant 0 F G = 0", "using J"], ["proof (prove)\nusing this:\n  subresultant (degree 0) F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ ((degree F - degree 0) * (degree G - degree 0)) *\n    lead_coeff G ^ (degree F - degree 0) *\n    lead_coeff 0 ^ (degree G - degree 0 - 1))\n   0\n  J < degree G\n\ngoal (1 subgoal):\n 1. subresultant 0 F G = 0", "by auto"], ["proof (state)\nthis:\n  subresultant 0 F G = 0\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "with BT_lemma_1_14[OF eq FG lt, of J]"], ["proof (chain)\npicking this:\n  \\<lbrakk>degree 0 < J; J < degree G - 1\\<rbrakk>\n  \\<Longrightarrow> subresultant J F G = 0\n  subresultant 0 F G = 0", "have 00: \"J = 0 \\<or> J < degree G - 1 \\<Longrightarrow> subresultant J F G = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>degree 0 < J; J < degree G - 1\\<rbrakk>\n  \\<Longrightarrow> subresultant J F G = 0\n  subresultant 0 F G = 0\n\ngoal (1 subgoal):\n 1. J = 0 \\<or> J < degree G - 1 \\<Longrightarrow> subresultant J F G = 0", "by auto"], ["proof (state)\nthis:\n  J = 0 \\<or> J < degree G - 1 \\<Longrightarrow> subresultant J F G = 0\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "from BT_lemma_1_15[OF eq FG lt lt] J"], ["proof (chain)\npicking this:\n  subresultant (degree G - 1) F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ (degree F - degree G + 1) *\n    lead_coeff G ^ (degree F - degree G + 1))\n   0\n  J < degree G", "have 01: \"subresultant (degree G - 1) F G = 0\""], ["proof (prove)\nusing this:\n  subresultant (degree G - 1) F G =\n  Polynomial.smult\n   ((- (1::'a)) ^ (degree F - degree G + 1) *\n    lead_coeff G ^ (degree F - degree G + 1))\n   0\n  J < degree G\n\ngoal (1 subgoal):\n 1. subresultant (degree G - 1) F G = 0", "by simp"], ["proof (state)\nthis:\n  subresultant (degree G - 1) F G = 0\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "from J"], ["proof (chain)\npicking this:\n  J < degree G", "have \"(J = 0 \\<or> J < degree G - 1) \\<or> J = degree G - 1\""], ["proof (prove)\nusing this:\n  J < degree G\n\ngoal (1 subgoal):\n 1. (J = 0 \\<or> J < degree G - 1) \\<or> J = degree G - 1", "by linarith"], ["proof (state)\nthis:\n  (J = 0 \\<or> J < degree G - 1) \\<or> J = degree G - 1\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "with 00 01"], ["proof (chain)\npicking this:\n  J = 0 \\<or> J < degree G - 1 \\<Longrightarrow> subresultant J F G = 0\n  subresultant (degree G - 1) F G = 0\n  (J = 0 \\<or> J < degree G - 1) \\<or> J = degree G - 1", "have \"subresultant J F G = 0\""], ["proof (prove)\nusing this:\n  J = 0 \\<or> J < degree G - 1 \\<Longrightarrow> subresultant J F G = 0\n  subresultant (degree G - 1) F G = 0\n  (J = 0 \\<or> J < degree G - 1) \\<or> J = degree G - 1\n\ngoal (1 subgoal):\n 1. subresultant J F G = 0", "by auto"], ["proof (state)\nthis:\n  subresultant J F G = 0\n\ngoal (2 subgoals):\n 1. J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)\n 2. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  subresultant J F G = 0\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "using J"], ["proof (prove)\nusing this:\n  subresultant J F G = 0\n  J < degree G\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "by simp"], ["proof (state)\nthis:\n  subresultant J F G =\n  (if J < degree G then 0\n   else if J < degree F\n        then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "case J: False"], ["proof (state)\nthis:\n  \\<not> J < degree G\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "hence dg: \"degree G - J = 0\""], ["proof (prove)\nusing this:\n  \\<not> J < degree G\n\ngoal (1 subgoal):\n 1. degree G - J = 0", "by simp"], ["proof (state)\nthis:\n  degree G - J = 0\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "let ?n = \"degree F - J\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "have *: \"(j :: nat) < 0 \\<longleftrightarrow> False\" \"j - 0 = j\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (j < 0) = False &&& j - 0 = j", "by auto"], ["proof (state)\nthis:\n  (?j < 0) = False\n  ?j - 0 = ?j\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "let ?M = \"mat ?n ?n\n          (\\<lambda>(i, j).\n              if i = ?n - 1 then monom 1 (?n - 1 - j) * G\n              else [:coeff_int G (int (degree G) - int i + int j):])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "have \"subresultant J F G = det ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant J F G =\n    det (mat (degree F - J) (degree F - J)\n          (\\<lambda>(i, j).\n              if i = degree F - J - 1\n              then monom (1::'a) (degree F - J - 1 - j) * G\n              else [:coeff_int G (int (degree G) - int i + int j):]))", "unfolding subresultant_def subresultant_mat_def Let_def dg *"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (degree F - J + 0) (degree F - J + 0)\n          (\\<lambda>(i, j).\n              if False\n              then if i = degree F - J + 0 - 1\n                   then monom (1::'a) (0 - 1 - j) * F\n                   else [:coeff_int F (int (degree F) - int i + int j):]\n              else if i = degree F - J + 0 - 1\n                   then monom (1::'a) (degree F - J - 1 - j) * G\n                   else [:coeff_int G (int (degree G) - int i + int j):])) =\n    det (mat (degree F - J) (degree F - J)\n          (\\<lambda>(i, j).\n              if i = degree F - J - 1\n              then monom (1::'a) (degree F - J - 1 - j) * G\n              else [:coeff_int G (int (degree G) - int i + int j):]))", "by auto"], ["proof (state)\nthis:\n  subresultant J F G =\n  det (mat (degree F - J) (degree F - J)\n        (\\<lambda>(i, j).\n            if i = degree F - J - 1\n            then monom (1::'a) (degree F - J - 1 - j) * G\n            else [:coeff_int G (int (degree G) - int i + int j):]))\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "also"], ["proof (state)\nthis:\n  subresultant J F G =\n  det (mat (degree F - J) (degree F - J)\n        (\\<lambda>(i, j).\n            if i = degree F - J - 1\n            then monom (1::'a) (degree F - J - 1 - j) * G\n            else [:coeff_int G (int (degree G) - int i + int j):]))\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "have \"det ?M = prod_list (diag_mat ?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (degree F - J) (degree F - J)\n          (\\<lambda>(i, j).\n              if i = degree F - J - 1\n              then monom (1::'a) (degree F - J - 1 - j) * G\n              else [:coeff_int G (int (degree G) - int i + int j):])) =\n    prod_list\n     (diag_mat\n       (mat (degree F - J) (degree F - J)\n         (\\<lambda>(i, j).\n             if i = degree F - J - 1\n             then monom (1::'a) (degree F - J - 1 - j) * G\n             else [:coeff_int G (int (degree G) - int i + int j):])))", "by (rule det_lower_triangular[of ?n], auto intro: coeff_int_eq_0)"], ["proof (state)\nthis:\n  det (mat (degree F - J) (degree F - J)\n        (\\<lambda>(i, j).\n            if i = degree F - J - 1\n            then monom (1::'a) (degree F - J - 1 - j) * G\n            else [:coeff_int G (int (degree G) - int i + int j):])) =\n  prod_list\n   (diag_mat\n     (mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):])))\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "also"], ["proof (state)\nthis:\n  det (mat (degree F - J) (degree F - J)\n        (\\<lambda>(i, j).\n            if i = degree F - J - 1\n            then monom (1::'a) (degree F - J - 1 - j) * G\n            else [:coeff_int G (int (degree G) - int i + int j):])) =\n  prod_list\n   (diag_mat\n     (mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):])))\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "have \"\\<dots> = (\\<Prod>i = 0..< ?n. ?M $$ (i,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (diag_mat\n       (mat (degree F - J) (degree F - J)\n         (\\<lambda>(i, j).\n             if i = degree F - J - 1\n             then monom (1::'a) (degree F - J - 1 - j) * G\n             else [:coeff_int G (int (degree G) - int i + int j):]))) =\n    (\\<Prod>i = 0..<degree F - J.\n        mat (degree F - J) (degree F - J)\n         (\\<lambda>(i, j).\n             if i = degree F - J - 1\n             then monom (1::'a) (degree F - J - 1 - j) * G\n             else [:coeff_int G (int (degree G) - int i + int j):]) $$\n        (i, i))", "unfolding prod_list_diag_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_row\n                     (mat (degree F - J) (degree F - J)\n                       (\\<lambda>(i, j).\n                           if i = degree F - J - 1\n                           then monom (1::'a) (degree F - J - 1 - j) * G\n                           else [:coeff_int G\n                                   (int (degree G) - int i + int j):])).\n        mat (degree F - J) (degree F - J)\n         (\\<lambda>(i, j).\n             if i = degree F - J - 1\n             then monom (1::'a) (degree F - J - 1 - j) * G\n             else [:coeff_int G (int (degree G) - int i + int j):]) $$\n        (i, i)) =\n    (\\<Prod>i = 0..<degree F - J.\n        mat (degree F - J) (degree F - J)\n         (\\<lambda>(i, j).\n             if i = degree F - J - 1\n             then monom (1::'a) (degree F - J - 1 - j) * G\n             else [:coeff_int G (int (degree G) - int i + int j):]) $$\n        (i, i))", "by simp"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):]))) =\n  (\\<Prod>i = 0..<degree F - J.\n      mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):]) $$\n      (i, i))\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "also"], ["proof (state)\nthis:\n  prod_list\n   (diag_mat\n     (mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):]))) =\n  (\\<Prod>i = 0..<degree F - J.\n      mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):]) $$\n      (i, i))\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "have \"\\<dots> = (\\<Prod>i = 0..< ?n. if i = ?n - 1 then G else [: lead_coeff G :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<degree F - J.\n        mat (degree F - J) (degree F - J)\n         (\\<lambda>(i, j).\n             if i = degree F - J - 1\n             then monom (1::'a) (degree F - J - 1 - j) * G\n             else [:coeff_int G (int (degree G) - int i + int j):]) $$\n        (i, i)) =\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:])", "by (rule prod.cong[OF refl], auto simp: coeff_int_def)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J.\n      mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):]) $$\n      (i, i)) =\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:])\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J.\n      mat (degree F - J) (degree F - J)\n       (\\<lambda>(i, j).\n           if i = degree F - J - 1\n           then monom (1::'a) (degree F - J - 1 - j) * G\n           else [:coeff_int G (int (degree G) - int i + int j):]) $$\n      (i, i)) =\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:])\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "have \"\\<dots> = (if J < degree F then smult (lead_coeff G ^ (?n - 1)) G else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "proof (cases \"J < degree F\")"], ["proof (state)\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "case True"], ["proof (state)\nthis:\n  J < degree F\n\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "hence id: \"{ 0 ..< ?n} = { 0 ..< ?n - 1} \\<union> {?n - 1}\""], ["proof (prove)\nusing this:\n  J < degree F\n\ngoal (1 subgoal):\n 1. {0..<degree F - J} = {0..<degree F - J - 1} \\<union> {degree F - J - 1}", "by auto"], ["proof (state)\nthis:\n  {0..<degree F - J} = {0..<degree F - J - 1} \\<union> {degree F - J - 1}\n\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "have \"(\\<Prod>i = 0..< ?n. if i = ?n - 1 then G else [: lead_coeff G :])\n      = (\\<Prod>i = 0 ..< ?n - 1. if i = ?n - 1 then G else [: lead_coeff G :]) * G\" (is \"_ = ?P * G\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (\\<Prod>i = 0..<degree F - J - 1.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) *\n    G", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<degree F - J - 1} \\<union> {degree F - J - 1}.\n       if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (\\<Prod>i = 0..<degree F - J - 1.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) *\n    G", "by (subst prod.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  (\\<Prod>i = 0..<degree F - J - 1.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) *\n  G\n\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  (\\<Prod>i = 0..<degree F - J - 1.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) *\n  G\n\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "have \"?P = (\\<Prod>i = 0 ..< ?n - 1. [: lead_coeff G :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<degree F - J - 1.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (\\<Prod>i = 0..<degree F - J - 1. [:lead_coeff G:])", "by (rule prod.cong, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J - 1.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  (\\<Prod>i = 0..<degree F - J - 1. [:lead_coeff G:])\n\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J - 1.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  (\\<Prod>i = 0..<degree F - J - 1. [:lead_coeff G:])\n\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "have \"\\<dots> = [: lead_coeff G ^ (?n - 1) :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<degree F - J - 1. [:lead_coeff G:]) =\n    [:lead_coeff G ^ (degree F - J - 1):]", "by (simp add: poly_const_pow)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J - 1. [:lead_coeff G:]) =\n  [:lead_coeff G ^ (degree F - J - 1):]\n\ngoal (2 subgoals):\n 1. J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n 2. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  [:lead_coeff G ^ (degree F - J - 1):] * G", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  [:lead_coeff G ^ (degree F - J - 1):] * G\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  (if J < degree F\n   then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n\ngoal (1 subgoal):\n 1. \\<not> J < degree F \\<Longrightarrow>\n    (\\<Prod>i = 0..<degree F - J.\n        if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "qed auto"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<degree F - J.\n      if i = degree F - J - 1 then G else [:lead_coeff G:]) =\n  (if J < degree F\n   then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "finally"], ["proof (chain)\npicking this:\n  subresultant J F G =\n  (if J < degree F\n   then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "have \"subresultant J F G =\n      (if J < degree F then smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\""], ["proof (prove)\nusing this:\n  subresultant J F G =\n  (if J < degree F\n   then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    (if J < degree F\n     then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)", "."], ["proof (state)\nthis:\n  subresultant J F G =\n  (if J < degree F\n   then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n\ngoal (1 subgoal):\n 1. \\<not> J < degree G \\<Longrightarrow>\n    subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  subresultant J F G =\n  (if J < degree F\n   then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "using J"], ["proof (prove)\nusing this:\n  subresultant J F G =\n  (if J < degree F\n   then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n  \\<not> J < degree G\n\ngoal (1 subgoal):\n 1. subresultant J F G =\n    (if J < degree G then 0\n     else if J < degree F\n          then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G\n          else 1)", "by simp"], ["proof (state)\nthis:\n  subresultant J F G =\n  (if J < degree G then 0\n   else if J < degree F\n        then Polynomial.smult (lead_coeff G ^ (degree F - J - 1)) G else 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resultant_pseudo_mod_0: assumes \"pseudo_mod f g = (0 :: 'a :: idom_divide poly)\"\n  and dfg: \"degree f \\<ge> degree g\"\n  and f: \"f \\<noteq> 0\" and g: \"g \\<noteq> 0\"\n  shows \"resultant f g = (if degree g = 0 then lead_coeff g^degree f else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "let ?df = \"degree f\""], ["proof (state)\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "let ?dg = \"degree g\""], ["proof (state)\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "obtain d r where pd: \"pseudo_divmod f g = (d,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d r.\n        pseudo_divmod f g = (d, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pseudo_divmod f g = (d, r)\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "from pd"], ["proof (chain)\npicking this:\n  pseudo_divmod f g = (d, r)", "have r: \"r = pseudo_mod f g\""], ["proof (prove)\nusing this:\n  pseudo_divmod f g = (d, r)\n\ngoal (1 subgoal):\n 1. r = pseudo_mod f g", "unfolding pseudo_mod_def"], ["proof (prove)\nusing this:\n  pseudo_divmod f g = (d, r)\n\ngoal (1 subgoal):\n 1. r = snd (pseudo_divmod f g)", "by simp"], ["proof (state)\nthis:\n  r = pseudo_mod f g\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "with assms pd"], ["proof (chain)\npicking this:\n  pseudo_mod f g = 0\n  degree g \\<le> degree f\n  f \\<noteq> 0\n  g \\<noteq> 0\n  pseudo_divmod f g = (d, r)\n  r = pseudo_mod f g", "have pd: \"pseudo_divmod f g = (d,0)\""], ["proof (prove)\nusing this:\n  pseudo_mod f g = 0\n  degree g \\<le> degree f\n  f \\<noteq> 0\n  g \\<noteq> 0\n  pseudo_divmod f g = (d, r)\n  r = pseudo_mod f g\n\ngoal (1 subgoal):\n 1. pseudo_divmod f g = (d, 0)", "by auto"], ["proof (state)\nthis:\n  pseudo_divmod f g = (d, 0)\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "from pseudo_divmod[OF g pd] g"], ["proof (chain)\npicking this:\n  Polynomial.smult (lead_coeff g ^ (Suc (degree f) - degree g)) f =\n  g * d + 0\n  0 = 0 \\<or> degree 0 < degree g\n  g \\<noteq> 0", "obtain a q where prod: \"smult a f = g * q\" and a: \"a \\<noteq> 0\" \"a = lead_coeff g ^ (Suc ?df - ?dg)\""], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff g ^ (Suc (degree f) - degree g)) f =\n  g * d + 0\n  0 = 0 \\<or> degree 0 < degree g\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a q.\n        \\<lbrakk>Polynomial.smult a f = g * q; a \\<noteq> (0::'a);\n         a = lead_coeff g ^ (Suc (degree f) - degree g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult a f = g * q\n  a \\<noteq> (0::'a)\n  a = lead_coeff g ^ (Suc (degree f) - degree g)\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "from a dfg"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  a = lead_coeff g ^ (Suc (degree f) - degree g)\n  degree g \\<le> degree f", "have dfg: \"degree g \\<le> degree (smult a f)\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  a = lead_coeff g ^ (Suc (degree f) - degree g)\n  degree g \\<le> degree f\n\ngoal (1 subgoal):\n 1. degree g \\<le> degree (Polynomial.smult a f)", "by auto"], ["proof (state)\nthis:\n  degree g \\<le> degree (Polynomial.smult a f)\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "have g0: \"degree g = 0 \\<Longrightarrow> coeff g 0 = 0 \\<Longrightarrow> g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>degree g = 0; coeff g 0 = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> g = 0", "using leading_coeff_0_iff"], ["proof (prove)\nusing this:\n  (lead_coeff ?p = (0::?'a)) = (?p = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree g = 0; coeff g 0 = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> g = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>degree g = 0; coeff g 0 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> g = 0\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "from prod"], ["proof (chain)\npicking this:\n  Polynomial.smult a f = g * q", "have \"smult a f = q * g\""], ["proof (prove)\nusing this:\n  Polynomial.smult a f = g * q\n\ngoal (1 subgoal):\n 1. Polynomial.smult a f = q * g", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult a f = q * g\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "from arg_cong[OF subresultant_product[OF this dfg, of 0, unfolded subresultant_resultant\n    resultant_smult_left[OF a(1)]], of \"\\<lambda> x. coeff x 0\"]"], ["proof (chain)\npicking this:\n  coeff [:a ^ degree g * resultant f g:] 0 =\n  coeff\n   (if 0 < degree g then 0\n    else if 0 < degree (Polynomial.smult a f)\n         then Polynomial.smult\n               (lead_coeff g ^ (degree (Polynomial.smult a f) - 0 - 1)) g\n         else 1)\n   0", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff [:a ^ degree g * resultant f g:] 0 =\n  coeff\n   (if 0 < degree g then 0\n    else if 0 < degree (Polynomial.smult a f)\n         then Polynomial.smult\n               (lead_coeff g ^ (degree (Polynomial.smult a f) - 0 - 1)) g\n         else 1)\n   0\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "using a g0"], ["proof (prove)\nusing this:\n  coeff [:a ^ degree g * resultant f g:] 0 =\n  coeff\n   (if 0 < degree g then 0\n    else if 0 < degree (Polynomial.smult a f)\n         then Polynomial.smult\n               (lead_coeff g ^ (degree (Polynomial.smult a f) - 0 - 1)) g\n         else 1)\n   0\n  a \\<noteq> (0::'a)\n  a = lead_coeff g ^ (Suc (degree f) - degree g)\n  \\<lbrakk>degree g = 0; coeff g 0 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> g = 0\n\ngoal (1 subgoal):\n 1. resultant f g =\n    (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))", "by (cases \"degree f\", auto)"], ["proof (state)\nthis:\n  resultant f g =\n  (if degree g = 0 then lead_coeff g ^ degree f else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "locale primitive_remainder_sequence =\n  fixes F :: \"nat \\<Rightarrow> 'a :: idom_divide poly\"\n    and n :: \"nat \\<Rightarrow> nat\"\n    and \\<delta> :: \"nat \\<Rightarrow> nat\"\n    and f :: \"nat \\<Rightarrow> 'a\"\n    and k :: nat\n    and \\<beta> :: \"nat \\<Rightarrow> 'a\"\n  assumes f: \"\\<And> i. f i = lead_coeff (F i)\"\n      and n: \"\\<And> i. n i = degree (F i)\"\n      and \\<delta>: \"\\<And> i. \\<delta> i = n i - n (Suc i)\"\n      and n12: \"n 1 \\<ge> n 2\"\n      and F12: \"F 1 \\<noteq> 0\" \"F 2 \\<noteq> 0\"\n      and F0: \"\\<And> i. i \\<noteq> 0 \\<Longrightarrow> F i = 0 \\<longleftrightarrow> i > k\"\n      and \\<beta>0: \"\\<And> i. \\<beta> i \\<noteq> 0\"\n      and pmod: \"\\<And> i. i \\<ge> 3 \\<Longrightarrow> i \\<le> Suc k \\<Longrightarrow> smult (\\<beta> i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))\"\nbegin"], ["", "lemma f10: \"f 1 \\<noteq> 0\" and f20: \"f 2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 1 \\<noteq> (0::'a) &&& f 2 \\<noteq> (0::'a)", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (F 1) \\<noteq> (0::'a) &&& lead_coeff (F 2) \\<noteq> (0::'a)", "using F12"], ["proof (prove)\nusing this:\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (F 1) \\<noteq> (0::'a) &&& lead_coeff (F 2) \\<noteq> (0::'a)", "by auto"], ["", "lemma f0: \"i \\<noteq> 0 \\<Longrightarrow> f i = 0 \\<longleftrightarrow> i > k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> (f i = (0::'a)) = (k < i)", "using F0[of i]"], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> (f i = (0::'a)) = (k < i)", "unfolding f"], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> (lead_coeff (F i) = (0::'a)) = (k < i)", "by auto"], ["", "lemma n_gt: assumes \"2 \\<le> i\" \"i < k\"\n  shows \"n i > n (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (Suc i) < n i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n (Suc i) < n i", "from assms"], ["proof (chain)\npicking this:\n  2 \\<le> i\n  i < k", "have \"3 \\<le> Suc i\" \"Suc i \\<le> Suc k\""], ["proof (prove)\nusing this:\n  2 \\<le> i\n  i < k\n\ngoal (1 subgoal):\n 1. 3 \\<le> Suc i &&& Suc i \\<le> Suc k", "by auto"], ["proof (state)\nthis:\n  3 \\<le> Suc i\n  Suc i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. n (Suc i) < n i", "note pmod = pmod[OF this]"], ["proof (state)\nthis:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n  pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))\n\ngoal (1 subgoal):\n 1. n (Suc i) < n i", "from assms F0"], ["proof (chain)\npicking this:\n  2 \\<le> i\n  i < k\n  ?i \\<noteq> 0 \\<Longrightarrow> (F ?i = 0) = (k < ?i)", "have \"F (Suc i - 1) \\<noteq> 0\" \"F (Suc i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  2 \\<le> i\n  i < k\n  ?i \\<noteq> 0 \\<Longrightarrow> (F ?i = 0) = (k < ?i)\n\ngoal (1 subgoal):\n 1. F (Suc i - 1) \\<noteq> 0 &&& F (Suc i) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F (Suc i - 1) \\<noteq> 0\n  F (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n (Suc i) < n i", "from pseudo_mod(2)[OF this(1), of \"F (Suc i - 2)\", folded pmod] this(2)"], ["proof (chain)\npicking this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) = 0 \\<or>\n  degree (Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)))\n  < degree (F (Suc i - 1))\n  F (Suc i) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) = 0 \\<or>\n  degree (Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)))\n  < degree (F (Suc i - 1))\n  F (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n (Suc i) < n i", "unfolding n"], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) = 0 \\<or>\n  degree (Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)))\n  < degree (F (Suc i - 1))\n  F (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (F (Suc i)) < degree (F i)", "using \\<beta>0"], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) = 0 \\<or>\n  degree (Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)))\n  < degree (F (Suc i - 1))\n  F (Suc i) \\<noteq> 0\n  \\<beta> ?i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree (F (Suc i)) < degree (F i)", "by auto"], ["proof (state)\nthis:\n  n (Suc i) < n i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma n_ge: assumes \"1 \\<le> i\" \"i < k\"\n  shows \"n i \\<ge> n (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (Suc i) \\<le> n i", "using n12 n_gt[OF _ assms(2)] assms(1)"], ["proof (prove)\nusing this:\n  n 2 \\<le> n 1\n  2 \\<le> i \\<Longrightarrow> n (Suc i) < n i\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. n (Suc i) \\<le> n i", "by (cases \"i = 1\", auto simp: numeral_2_eq_2)"], ["", "lemma n_ge_trans: assumes \"1 \\<le> i\" \"i \\<le> j\" \"j \\<le> k\"\n  shows \"n i \\<ge> n j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n j \\<le> n i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n j \\<le> n i", "from assms(2)"], ["proof (chain)\npicking this:\n  i \\<le> j", "have \"j = i + (j - i)\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. j = i + (j - i)", "by simp"], ["proof (state)\nthis:\n  j = i + (j - i)\n\ngoal (1 subgoal):\n 1. n j \\<le> n i", "then"], ["proof (chain)\npicking this:\n  j = i + (j - i)", "obtain jj where j: \"j = i + jj\""], ["proof (prove)\nusing this:\n  j = i + (j - i)\n\ngoal (1 subgoal):\n 1. (\\<And>jj. j = i + jj \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  j = i + jj\n\ngoal (1 subgoal):\n 1. n j \\<le> n i", "from assms(3)[unfolded j]"], ["proof (chain)\npicking this:\n  i + jj \\<le> k", "show ?thesis"], ["proof (prove)\nusing this:\n  i + jj \\<le> k\n\ngoal (1 subgoal):\n 1. n j \\<le> n i", "unfolding j"], ["proof (prove)\nusing this:\n  i + jj \\<le> k\n\ngoal (1 subgoal):\n 1. n (i + jj) \\<le> n i", "proof (induct jj)"], ["proof (state)\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow> n (i + 0) \\<le> n i\n 2. \\<And>jj.\n       \\<lbrakk>i + jj \\<le> k \\<Longrightarrow> n (i + jj) \\<le> n i;\n        i + Suc jj \\<le> k\\<rbrakk>\n       \\<Longrightarrow> n (i + Suc jj) \\<le> n i", "case (Suc j)"], ["proof (state)\nthis:\n  i + j \\<le> k \\<Longrightarrow> n (i + j) \\<le> n i\n  i + Suc j \\<le> k\n\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow> n (i + 0) \\<le> n i\n 2. \\<And>jj.\n       \\<lbrakk>i + jj \\<le> k \\<Longrightarrow> n (i + jj) \\<le> n i;\n        i + Suc jj \\<le> k\\<rbrakk>\n       \\<Longrightarrow> n (i + Suc jj) \\<le> n i", "from Suc(2)"], ["proof (chain)\npicking this:\n  i + Suc j \\<le> k", "have \"i + j \\<le> k\""], ["proof (prove)\nusing this:\n  i + Suc j \\<le> k\n\ngoal (1 subgoal):\n 1. i + j \\<le> k", "by simp"], ["proof (state)\nthis:\n  i + j \\<le> k\n\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow> n (i + 0) \\<le> n i\n 2. \\<And>jj.\n       \\<lbrakk>i + jj \\<le> k \\<Longrightarrow> n (i + jj) \\<le> n i;\n        i + Suc jj \\<le> k\\<rbrakk>\n       \\<Longrightarrow> n (i + Suc jj) \\<le> n i", "from Suc(1)[OF this]"], ["proof (chain)\npicking this:\n  n (i + j) \\<le> n i", "have IH: \"n (i + j) \\<le> n i\""], ["proof (prove)\nusing this:\n  n (i + j) \\<le> n i\n\ngoal (1 subgoal):\n 1. n (i + j) \\<le> n i", "."], ["proof (state)\nthis:\n  n (i + j) \\<le> n i\n\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow> n (i + 0) \\<le> n i\n 2. \\<And>jj.\n       \\<lbrakk>i + jj \\<le> k \\<Longrightarrow> n (i + jj) \\<le> n i;\n        i + Suc jj \\<le> k\\<rbrakk>\n       \\<Longrightarrow> n (i + Suc jj) \\<le> n i", "have \"n (Suc (i + j)) \\<le> n (i + j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (Suc (i + j)) \\<le> n (i + j)", "by (rule n_ge, insert assms(1) Suc(2), auto)"], ["proof (state)\nthis:\n  n (Suc (i + j)) \\<le> n (i + j)\n\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow> n (i + 0) \\<le> n i\n 2. \\<And>jj.\n       \\<lbrakk>i + jj \\<le> k \\<Longrightarrow> n (i + jj) \\<le> n i;\n        i + Suc jj \\<le> k\\<rbrakk>\n       \\<Longrightarrow> n (i + Suc jj) \\<le> n i", "with IH"], ["proof (chain)\npicking this:\n  n (i + j) \\<le> n i\n  n (Suc (i + j)) \\<le> n (i + j)", "show ?case"], ["proof (prove)\nusing this:\n  n (i + j) \\<le> n i\n  n (Suc (i + j)) \\<le> n (i + j)\n\ngoal (1 subgoal):\n 1. n (i + Suc j) \\<le> n i", "by auto"], ["proof (state)\nthis:\n  n (i + Suc j) \\<le> n i\n\ngoal (1 subgoal):\n 1. i + 0 \\<le> k \\<Longrightarrow> n (i + 0) \\<le> n i", "qed auto"], ["proof (state)\nthis:\n  n j \\<le> n i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delta_gt: assumes \"2 \\<le> i\" \"i < k\"\n  shows \"\\<delta> i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<delta> i", "using n_gt[OF assms]"], ["proof (prove)\nusing this:\n  n (Suc i) < n i\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> i", "unfolding \\<delta>"], ["proof (prove)\nusing this:\n  n (Suc i) < n i\n\ngoal (1 subgoal):\n 1. 0 < n i - n (Suc i)", "by auto"], ["", "lemma k2:\"2 \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> k", "by (metis le_cases linorder_not_le F0 F12(2) zero_order(2))"], ["", "lemma k0: \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "using k2"], ["proof (prove)\nusing this:\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["", "lemma ni2:\"3 \\<le> i \\<Longrightarrow> i \\<le> k \\<Longrightarrow> n i \\<noteq> n 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> i; i \\<le> k\\<rbrakk>\n    \\<Longrightarrow> n i \\<noteq> n 2", "by (metis Suc_numeral \\<delta> delta_gt k2 le_imp_less_Suc le_less n_ge_trans not_le one_le_numeral\n      semiring_norm(5) zero_less_diff)"], ["", "end"], ["", "locale subresultant_prs_locale = primitive_remainder_sequence F n \\<delta> f k \\<beta> for\n       F :: \"nat \\<Rightarrow> 'a :: idom_divide fract poly\"\n    and n :: \"nat \\<Rightarrow> nat\"\n    and \\<delta> :: \"nat \\<Rightarrow> nat\"\n    and f :: \"nat \\<Rightarrow> 'a fract\"\n    and k :: nat\n    and \\<beta> :: \"nat \\<Rightarrow> 'a fract\" +\n  fixes G1 G2 :: \"'a poly\"\n  assumes F1: \"F 1 = map_poly to_fract G1\"\n    and F2: \"F 2 = map_poly to_fract G2\"\nbegin"], ["", "definition \"\\<alpha> i = (f (i - 1))^(Suc (\\<delta> (i - 2)))\""], ["", "lemma \\<alpha>0: \"i > 1 \\<Longrightarrow> \\<alpha> i = 0 \\<longleftrightarrow> (i - 1) > k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < i \\<Longrightarrow> (\\<alpha> i = 0) = (k < i - 1)", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < i \\<Longrightarrow>\n    (f (i - 1) ^ Suc (\\<delta> (i - 2)) = 0) = (k < i - 1)", "using f0[of \"i - 1\"]"], ["proof (prove)\nusing this:\n  i - 1 \\<noteq> 0 \\<Longrightarrow> (f (i - 1) = 0) = (k < i - 1)\n\ngoal (1 subgoal):\n 1. 1 < i \\<Longrightarrow>\n    (f (i - 1) ^ Suc (\\<delta> (i - 2)) = 0) = (k < i - 1)", "by auto"], ["", "lemma \\<alpha>_char:\nassumes \"3 \\<le> i\" \"i < k + 2\"\n  shows \"\\<alpha> i = (f (i - 1)) ^ (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "proof (cases \"i = 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n 2. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "case True"], ["proof (state)\nthis:\n  i = 3\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n 2. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "have triv:\"Suc (Suc 0) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc 0) = 2", "by auto"], ["proof (state)\nthis:\n  Suc (Suc 0) = 2\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n 2. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "have l:\"length (coeffs (F 2)) \\<noteq> 0\" \"length (coeffs (F 1)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (coeffs (F 2)) \\<noteq> 0 &&& length (coeffs (F 1)) \\<noteq> 0", "using F12"], ["proof (prove)\nusing this:\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (coeffs (F 2)) \\<noteq> 0 &&& length (coeffs (F 1)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length (coeffs (F 2)) \\<noteq> 0\n  length (coeffs (F 1)) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n 2. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "hence \"length (coeffs (F 2)) \\<le> length (coeffs (F (Suc 0)))\""], ["proof (prove)\nusing this:\n  length (coeffs (F 2)) \\<noteq> 0\n  length (coeffs (F 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (coeffs (F 2)) \\<le> length (coeffs (F (Suc 0)))", "using n12"], ["proof (prove)\nusing this:\n  length (coeffs (F 2)) \\<noteq> 0\n  length (coeffs (F 1)) \\<noteq> 0\n  n 2 \\<le> n 1\n\ngoal (1 subgoal):\n 1. length (coeffs (F 2)) \\<le> length (coeffs (F (Suc 0)))", "unfolding n degree_eq_length_coeffs One_nat_def"], ["proof (prove)\nusing this:\n  length (coeffs (F 2)) \\<noteq> 0\n  length (coeffs (F (Suc 0))) \\<noteq> 0\n  length (coeffs (F 2)) - Suc 0 \\<le> length (coeffs (F (Suc 0))) - Suc 0\n\ngoal (1 subgoal):\n 1. length (coeffs (F 2)) \\<le> length (coeffs (F (Suc 0)))", "by linarith"], ["proof (state)\nthis:\n  length (coeffs (F 2)) \\<le> length (coeffs (F (Suc 0)))\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n 2. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "hence \"Suc (length (coeffs (F 1)) - 1 - (length (coeffs (F 2)) - 1)) =\n         (Suc (length (coeffs (F 1))) - length (coeffs (F (3 - 1))))\""], ["proof (prove)\nusing this:\n  length (coeffs (F 2)) \\<le> length (coeffs (F (Suc 0)))\n\ngoal (1 subgoal):\n 1. Suc (length (coeffs (F 1)) - 1 - (length (coeffs (F 2)) - 1)) =\n    Suc (length (coeffs (F 1))) - length (coeffs (F (3 - 1)))", "using l"], ["proof (prove)\nusing this:\n  length (coeffs (F 2)) \\<le> length (coeffs (F (Suc 0)))\n  length (coeffs (F 2)) \\<noteq> 0\n  length (coeffs (F 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (length (coeffs (F 1)) - 1 - (length (coeffs (F 2)) - 1)) =\n    Suc (length (coeffs (F 1))) - length (coeffs (F (3 - 1)))", "by simp"], ["proof (state)\nthis:\n  Suc (length (coeffs (F 1)) - 1 - (length (coeffs (F 2)) - 1)) =\n  Suc (length (coeffs (F 1))) - length (coeffs (F (3 - 1)))\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n 2. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc (length (coeffs (F 1)) - 1 - (length (coeffs (F 2)) - 1)) =\n  Suc (length (coeffs (F 1))) - length (coeffs (F (3 - 1)))\n\ngoal (1 subgoal):\n 1. \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "unfolding True \\<alpha>_def n \\<delta> degree_eq_length_coeffs"], ["proof (prove)\nusing this:\n  Suc (length (coeffs (F 1)) - 1 - (length (coeffs (F 2)) - 1)) =\n  Suc (length (coeffs (F 1))) - length (coeffs (F (3 - 1)))\n\ngoal (1 subgoal):\n 1. f (3 - 1) ^\n    Suc (length (coeffs (F (3 - 2))) - 1 -\n         (length (coeffs (F (Suc (3 - 2)))) - 1)) =\n    f (3 - 1) ^\n    (Suc (length (coeffs (F (3 - 2)))) - length (coeffs (F (3 - 1))))", "by (simp add:triv)"], ["proof (state)\nthis:\n  \\<alpha> i =\n  f (i - 1) ^\n  (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 3\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "hence assms:\"2 \\<le> i - 2\" \"i - 2 < k\""], ["proof (prove)\nusing this:\n  i \\<noteq> 3\n\ngoal (1 subgoal):\n 1. 2 \\<le> i - 2 &&& i - 2 < k", "using assms"], ["proof (prove)\nusing this:\n  i \\<noteq> 3\n  3 \\<le> i\n  i < k + 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> i - 2 &&& i - 2 < k", "by auto"], ["proof (state)\nthis:\n  2 \\<le> i - 2\n  i - 2 < k\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "have i:\"i - 2 \\<noteq> 0\" \"i - 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 2 \\<noteq> 0 &&& i - 1 \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  2 \\<le> i - 2\n  i - 2 < k\n\ngoal (1 subgoal):\n 1. i - 2 \\<noteq> 0 &&& i - 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  i - 2 \\<noteq> 0\n  i - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "hence [simp]: \"Suc (i - 2) = i - 1\""], ["proof (prove)\nusing this:\n  i - 2 \\<noteq> 0\n  i - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (i - 2) = i - 1", "by auto"], ["proof (state)\nthis:\n  Suc (i - 2) = i - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "from assms(2) F0[OF i(2)]"], ["proof (chain)\npicking this:\n  i - 2 < k\n  (F (i - 1) = 0) = (k < i - 1)", "have \"F (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i - 2 < k\n  (F (i - 1) = 0) = (k < i - 1)\n\ngoal (1 subgoal):\n 1. F (i - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "then"], ["proof (chain)\npicking this:\n  F (i - 1) \\<noteq> 0", "have \"length (coeffs (F (i - 1))) > 0\""], ["proof (prove)\nusing this:\n  F (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < length (coeffs (F (i - 1)))", "by (cases \"F (i - 1)\") auto"], ["proof (state)\nthis:\n  0 < length (coeffs (F (i - 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "with delta_gt[unfolded \\<delta> n degree_eq_length_coeffs,OF assms]"], ["proof (chain)\npicking this:\n  0 < length (coeffs (F (i - 2))) - 1 -\n      (length (coeffs (F (Suc (i - 2)))) - 1)\n  0 < length (coeffs (F (i - 1)))", "have * : \"Suc (\\<delta> (i - 2)) = Suc (length (coeffs (F (i - 2)))) - (length (coeffs (F (Suc (i - 2)))))\""], ["proof (prove)\nusing this:\n  0 < length (coeffs (F (i - 2))) - 1 -\n      (length (coeffs (F (Suc (i - 2)))) - 1)\n  0 < length (coeffs (F (i - 1)))\n\ngoal (1 subgoal):\n 1. Suc (\\<delta> (i - 2)) =\n    Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (Suc (i - 2))))", "by (auto simp:\\<delta> n degree_eq_length_coeffs)"], ["proof (state)\nthis:\n  Suc (\\<delta> (i - 2)) =\n  Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (Suc (i - 2))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow>\n    \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> i =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "unfolding \\<alpha>_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) -\n     length (coeffs (F (Suc (i - 2))))) =\n    f (i - 1) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "by simp"], ["proof (state)\nthis:\n  \\<alpha> i =\n  f (i - 1) ^\n  (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Q :: \"nat \\<Rightarrow> 'a fract poly\" where\n  \"Q i \\<equiv> smult (\\<alpha> i) (fst (pdivmod (F (i - 2)) (F (i - 1))))\""], ["", "lemma beta_F_as_sum:\n  assumes \"3 \\<le> i\" \"i \\<le> Suc k\"\n  shows \"smult (\\<beta> i) (F i) = smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)\" (is ?t1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have ik:\"i < k + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k + 2", "using assms"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. i < k + 2", "by auto"], ["proof (state)\nthis:\n  i < k + 2\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have f0:\"F (i - 1) = 0 \\<longleftrightarrow> False\" \"F (i - Suc 0) = 0 \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F (i - 1) = 0) = False &&& (F (i - Suc 0) = 0) = False", "using F0[of \"i - 1\"] assms"], ["proof (prove)\nusing this:\n  i - 1 \\<noteq> 0 \\<Longrightarrow> (F (i - 1) = 0) = (k < i - 1)\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. (F (i - 1) = 0) = False &&& (F (i - Suc 0) = 0) = False", "by auto"], ["proof (state)\nthis:\n  (F (i - 1) = 0) = False\n  (F (i - Suc 0) = 0) = False\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "hence f0_b:\"(inverse (coeff (F (i - 1)) (degree (F (i - 1))))) \\<noteq> 0\" \"F (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (F (i - 1) = 0) = False\n  (F (i - Suc 0) = 0) = False\n\ngoal (1 subgoal):\n 1. inverse (lead_coeff (F (i - 1))) \\<noteq> 0 &&& F (i - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  inverse (lead_coeff (F (i - 1))) \\<noteq> 0\n  F (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have i:\"i - 2 \\<noteq> 0\" \"Suc (i - 2) = i - 1\" \"(k < i - 2) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 2 \\<noteq> 0 &&& Suc (i - 2) = i - 1 &&& (k < i - 2) = False", "using assms"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. i - 2 \\<noteq> 0 &&& Suc (i - 2) = i - 1 &&& (k < i - 2) = False", "by auto"], ["proof (state)\nthis:\n  i - 2 \\<noteq> 0\n  Suc (i - 2) = i - 1\n  (k < i - 2) = False\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have \"F (i - 2) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (i - 2) \\<noteq> 0", "using F0[of \"i - 2\"] assms"], ["proof (prove)\nusing this:\n  i - 2 \\<noteq> 0 \\<Longrightarrow> (F (i - 2) = 0) = (k < i - 2)\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. F (i - 2) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "let ?c = \"(inverse (f (i - 1)) ^ (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have inv:\"inverse (\\<alpha> i) = ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (\\<alpha> i) =\n    inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))", "unfolding \\<alpha>_char[OF assms(1) ik] power_inverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse\n     (f (i - 1) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))) =\n    inverse\n     (f (i - 1) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))", "by auto"], ["proof (state)\nthis:\n  inverse (\\<alpha> i) =\n  inverse (f (i - 1)) ^\n  (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1))))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have alpha0:\"\\<alpha> i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> i \\<noteq> 0", "unfolding \\<alpha>_def f"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (F (i - 1)) ^ Suc (\\<delta> (i - 2)) \\<noteq> 0", "using f0"], ["proof (prove)\nusing this:\n  (F (i - 1) = 0) = False\n  (F (i - Suc 0) = 0) = False\n\ngoal (1 subgoal):\n 1. lead_coeff (F (i - 1)) ^ Suc (\\<delta> (i - 2)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have \\<alpha>_inv[simp]:\"\\<alpha> i * inverse (\\<alpha> i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> i * inverse (\\<alpha> i) = 1", "using field_class.field_inverse[OF alpha0] mult.commute"], ["proof (prove)\nusing this:\n  inverse (\\<alpha> i) * \\<alpha> i = 1\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. \\<alpha> i * inverse (\\<alpha> i) = 1", "by metis"], ["proof (state)\nthis:\n  \\<alpha> i * inverse (\\<alpha> i) = 1\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "with field_class.field_inverse[OF alpha0,unfolded inv]"], ["proof (chain)\npicking this:\n  inverse (f (i - 1)) ^\n  (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))) *\n  \\<alpha> i =\n  1\n  \\<alpha> i * inverse (\\<alpha> i) = 1", "have c_times_Q:\"smult ?c (Q i) = fst (pdivmod (F (i - 2)) (F (i - 1)))\""], ["proof (prove)\nusing this:\n  inverse (f (i - 1)) ^\n  (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))) *\n  \\<alpha> i =\n  1\n  \\<alpha> i * inverse (\\<alpha> i) = 1\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Q i) =\n    fst (pdivmod (F (i - 2)) (F (i - 1)))", "unfolding Q_def"], ["proof (prove)\nusing this:\n  inverse (f (i - 1)) ^\n  (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))) *\n  \\<alpha> i =\n  1\n  \\<alpha> i * inverse (\\<alpha> i) = 1\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Polynomial.smult (\\<alpha> i)\n       (fst (pdivmod (F (i - 2)) (F (i - 1))))) =\n    fst (pdivmod (F (i - 2)) (F (i - 1)))", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult\n   (inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n   (Q i) =\n  fst (pdivmod (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have \"pdivmod (F (i - 2)) (F (i - 1)) = (smult ?c (Q i), smult ?c (smult (\\<beta> i) (F i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdivmod (F (i - 2)) (F (i - 1)) =\n    (Polynomial.smult\n      (inverse (f (i - 1)) ^\n       (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n      (Q i),\n     Polynomial.smult\n      (inverse (f (i - 1)) ^\n       (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n      (Polynomial.smult (\\<beta> i) (F i)))", "unfolding c_times_Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdivmod (F (i - 2)) (F (i - 1)) =\n    (fst (pdivmod (F (i - 2)) (F (i - 1))),\n     Polynomial.smult\n      (inverse (f (i - 1)) ^\n       (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n      (Polynomial.smult (\\<beta> i) (F i)))", "unfolding pdivmod_via_pseudo_divmod pmod[OF assms] f n c_times_Q\n              pseudo_mod_smult_right[OF f0_b, of \"F (i - 2)\",symmetric] f0 if_False Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case pseudo_divmod (F (i - 2))\n           (Polynomial.smult (inverse (lead_coeff (F (i - 1))))\n             (F (i - 1))) of\n     (q, x) \\<Rightarrow>\n       (Polynomial.smult (inverse (lead_coeff (F (i - 1)))) q, x)) =\n    (fst (case pseudo_divmod (F (i - 2))\n                (Polynomial.smult (inverse (lead_coeff (F (i - 1))))\n                  (F (i - 1))) of\n          (q, x) \\<Rightarrow>\n            (Polynomial.smult (inverse (lead_coeff (F (i - 1)))) q, x)),\n     pseudo_mod (F (i - 2))\n      (Polynomial.smult (inverse (lead_coeff (F (i - 1)))) (F (i - 1))))", "unfolding pseudo_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case pseudo_divmod (F (i - 2))\n           (Polynomial.smult (inverse (lead_coeff (F (i - 1))))\n             (F (i - 1))) of\n     (q, x) \\<Rightarrow>\n       (Polynomial.smult (inverse (lead_coeff (F (i - 1)))) q, x)) =\n    (fst (case pseudo_divmod (F (i - 2))\n                (Polynomial.smult (inverse (lead_coeff (F (i - 1))))\n                  (F (i - 1))) of\n          (q, x) \\<Rightarrow>\n            (Polynomial.smult (inverse (lead_coeff (F (i - 1)))) q, x)),\n     snd (pseudo_divmod (F (i - 2))\n           (Polynomial.smult (inverse (lead_coeff (F (i - 1))))\n             (F (i - 1)))))", "by (auto split:prod.split)"], ["proof (state)\nthis:\n  pdivmod (F (i - 2)) (F (i - 1)) =\n  (Polynomial.smult\n    (inverse (f (i - 1)) ^\n     (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n    (Q i),\n   Polynomial.smult\n    (inverse (f (i - 1)) ^\n     (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n    (Polynomial.smult (\\<beta> i) (F i)))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "from this[folded pdivmod_pdivmodrel]"], ["proof (chain)\npicking this:\n  eucl_rel_poly (F (i - 2)) (F (i - 1))\n   (Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Q i),\n    Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Polynomial.smult (\\<beta> i) (F i)))", "have pr:\"F (i - 2) = smult ?c (Q i) * F (i - 1) + smult ?c ( smult (\\<beta> i) (F i))\""], ["proof (prove)\nusing this:\n  eucl_rel_poly (F (i - 2)) (F (i - 1))\n   (Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Q i),\n    Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Polynomial.smult (\\<beta> i) (F i)))\n\ngoal (1 subgoal):\n 1. F (i - 2) =\n    Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Q i) *\n    F (i - 1) +\n    Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Polynomial.smult (\\<beta> i) (F i))", "by (auto simp: eucl_rel_poly_iff)"], ["proof (state)\nthis:\n  F (i - 2) =\n  Polynomial.smult\n   (inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n   (Q i) *\n  F (i - 1) +\n  Polynomial.smult\n   (inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "hence \"F (i - 2) = smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)\n                   + smult (inverse (\\<alpha> i)) ( smult (\\<beta> i) (F i))\" (is \"?l = ?r\" is \"_ = ?t + _\")"], ["proof (prove)\nusing this:\n  F (i - 2) =\n  Polynomial.smult\n   (inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n   (Q i) *\n  F (i - 1) +\n  Polynomial.smult\n   (inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. F (i - 2) =\n    Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n    Polynomial.smult (inverse (\\<alpha> i))\n     (Polynomial.smult (\\<beta> i) (F i))", "unfolding inv"], ["proof (prove)\nusing this:\n  F (i - 2) =\n  Polynomial.smult\n   (inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n   (Q i) *\n  F (i - 1) +\n  Polynomial.smult\n   (inverse (f (i - 1)) ^\n    (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. F (i - 2) =\n    Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Q i) *\n    F (i - 1) +\n    Polynomial.smult\n     (inverse (f (i - 1)) ^\n      (Suc (length (coeffs (F (i - 2)))) - length (coeffs (F (i - 1)))))\n     (Polynomial.smult (\\<beta> i) (F i))", "."], ["proof (state)\nthis:\n  F (i - 2) =\n  Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n  Polynomial.smult (inverse (\\<alpha> i))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "hence eq:\"smult (\\<alpha> i) (?l - ?t) = smult (\\<alpha> i) (?r - ?t)\""], ["proof (prove)\nusing this:\n  F (i - 2) =\n  Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n  Polynomial.smult (inverse (\\<alpha> i))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (F (i - 2) -\n      Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n    Polynomial.smult (\\<alpha> i)\n     (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n      Polynomial.smult (inverse (\\<alpha> i))\n       (Polynomial.smult (\\<beta> i) (F i)) -\n      Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i)\n   (F (i - 2) - Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n  Polynomial.smult (\\<alpha> i)\n   (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n    Polynomial.smult (inverse (\\<alpha> i))\n     (Polynomial.smult (\\<beta> i) (F i)) -\n    Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have \" smult (\\<alpha> i) (F (i - 2)) - Q i * (F (i - 1)) = smult (\\<alpha> i) (?l - ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i) (F (i - 2)) - Q i * F (i - 1) =\n    Polynomial.smult (\\<alpha> i)\n     (F (i - 2) - Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))", "unfolding smult_diff_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i) (F (i - 2)) - Q i * F (i - 1) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) -\n    Polynomial.smult (\\<alpha> i)\n     (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i) (F (i - 2)) - Q i * F (i - 1) =\n  Polynomial.smult (\\<alpha> i)\n   (F (i - 2) - Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "also"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i) (F (i - 2)) - Q i * F (i - 1) =\n  Polynomial.smult (\\<alpha> i)\n   (F (i - 2) - Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have \"\\<dots> = smult (\\<alpha> i) (?r - ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (F (i - 2) -\n      Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n    Polynomial.smult (\\<alpha> i)\n     (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n      Polynomial.smult (inverse (\\<alpha> i))\n       (Polynomial.smult (\\<beta> i) (F i)) -\n      Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n      Polynomial.smult (inverse (\\<alpha> i))\n       (Polynomial.smult (\\<beta> i) (F i)) -\n      Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n    Polynomial.smult (\\<alpha> i)\n     (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n      Polynomial.smult (inverse (\\<alpha> i))\n       (Polynomial.smult (\\<beta> i) (F i)) -\n      Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))", ".."], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i)\n   (F (i - 2) - Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n  Polynomial.smult (\\<alpha> i)\n   (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n    Polynomial.smult (inverse (\\<alpha> i))\n     (Polynomial.smult (\\<beta> i) (F i)) -\n    Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "also"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i)\n   (F (i - 2) - Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n  Polynomial.smult (\\<alpha> i)\n   (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n    Polynomial.smult (inverse (\\<alpha> i))\n     (Polynomial.smult (\\<beta> i) (F i)) -\n    Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "have \"\\<dots> = smult (\\<beta> i) (F i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n      Polynomial.smult (inverse (\\<alpha> i))\n       (Polynomial.smult (\\<beta> i) (F i)) -\n      Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n    Polynomial.smult (\\<beta> i) (F i)", "by (auto simp:mult.assoc[symmetric])"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i)\n   (Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1) +\n    Polynomial.smult (inverse (\\<alpha> i))\n     (Polynomial.smult (\\<beta> i) (F i)) -\n    Polynomial.smult (inverse (\\<alpha> i)) (Q i) * F (i - 1)) =\n  Polynomial.smult (\\<beta> i) (F i)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult (\\<alpha> i) (F (i - 2)) - Q i * F (i - 1) =\n  Polynomial.smult (\\<beta> i) (F i)", "show ?t1"], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<alpha> i) (F (i - 2)) - Q i * F (i - 1) =\n  Polynomial.smult (\\<beta> i) (F i)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> i) (F i) =\n    Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (\\<beta> i) (F i) =\n  Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes \"3 \\<le> i\" \"i \\<le> k\" shows\n  BT_lemma_2_21: \"j < n i \\<Longrightarrow> smult (\\<alpha> i ^ (n (i - 1) - j)) (subresultant j (F (i - 2)) (F (i - 1)))\n  = smult ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) * (f (i - 1)) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) * (\\<beta> i) ^ (n (i - 1) - j)) (subresultant j (F (i - 1)) (F i))\"\n    (is \"_ \\<Longrightarrow> ?eq_21\") and\n  BT_lemma_2_22: \"smult (\\<alpha> i ^ (\\<delta> (i - 1))) (subresultant (n i) (F (i - 2)) (F (i - 1)))\n  = smult ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) * f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) * f i ^ (\\<delta> (i - 1) - 1) * (\\<beta> i) ^ \\<delta> (i - 1)) (F i)\"\n    (is \"?eq_22\") and\n  BT_lemma_2_23: \"n i < j \\<Longrightarrow> j < n (i - 1) - 1 \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\"\n    (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> ?eq_23\") and\n  BT_lemma_2_24: \"smult (\\<alpha> i) (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)))\n  = smult ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) (F i)\" (is \"?eq_24\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((j < n i \\<Longrightarrow>\n      Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n       (subresultant j (F (i - 2)) (F (i - 1))) =\n      Polynomial.smult\n       ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n        f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n        \\<beta> i ^ (n (i - 1) - j))\n       (subresultant j (F (i - 1)) (F i))) &&&\n     Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n      (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n     Polynomial.smult\n      ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n       f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n       f i ^ (\\<delta> (i - 1) - 1) *\n       \\<beta> i ^ \\<delta> (i - 1))\n      (F i)) &&&\n    (\\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n     \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0) &&&\n    Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "from assms"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k", "have ik:\"i \\<le> Suc k\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. i \\<le> Suc k", "by auto"], ["proof (state)\nthis:\n  i \\<le> Suc k\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "note beta_F_as_sum = beta_F_as_sum[OF assms(1) ik, symmetric]"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i) (F (i - 2)) + - Q i * F (i - 1) =\n  Polynomial.smult (\\<beta> i) (F i)\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have s[simp]:\"Suc (i - 2) = i - 1\" \"Suc (i - 1) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (i - 2) = i - 1 &&& Suc (i - 1) = i", "using assms"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. Suc (i - 2) = i - 1 &&& Suc (i - 1) = i", "by auto"], ["proof (state)\nthis:\n  Suc (i - 2) = i - 1\n  Suc (i - 1) = i\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have \\<alpha>0:\"\\<alpha> i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> i \\<noteq> 0", "using assms f0[of \"i - 1\"]"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  i - 1 \\<noteq> 0 \\<Longrightarrow> (f (i - 1) = 0) = (k < i - 1)\n\ngoal (1 subgoal):\n 1. \\<alpha> i \\<noteq> 0", "unfolding \\<alpha>_def f"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  i - 1 \\<noteq> 0 \\<Longrightarrow>\n  (lead_coeff (F (i - 1)) = 0) = (k < i - 1)\n\ngoal (1 subgoal):\n 1. lead_coeff (F (i - 1)) ^ Suc (\\<delta> (i - 2)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> i \\<noteq> 0\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "hence \\<alpha>0pow:\"\\<And> x. \\<alpha> i ^ x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<alpha> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<alpha> i ^ x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> i ^ ?x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have df:\"degree (F (i - 1)) \\<le> degree (smult (\\<alpha> i) (F (i - 2)))\"\n          \"degree (smult (\\<beta> i) (F i)) < degree (F (i - 1)) \\<or> b\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (F (i - 1))\n    \\<le> degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) &&&\n    degree (Polynomial.smult (\\<beta> i) (F i)) < degree (F (i - 1)) \\<or> b", "using n_ge[of \"i-2\"] n_gt[of \"i-1\"] assms \\<alpha>0 \\<beta>0"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> i - 2; i - 2 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 2)) \\<le> n (i - 2)\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k\n  \\<alpha> i \\<noteq> 0\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (F (i - 1))\n    \\<le> degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) &&&\n    degree (Polynomial.smult (\\<beta> i) (F i)) < degree (F (i - 1)) \\<or> b", "unfolding n"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> i - 2; i - 2 < k\\<rbrakk>\n  \\<Longrightarrow> degree (F (Suc (i - 2))) \\<le> degree (F (i - 2))\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> degree (F (Suc (i - 1))) < degree (F (i - 1))\n  3 \\<le> i\n  i \\<le> k\n  \\<alpha> i \\<noteq> 0\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (F (i - 1))\n    \\<le> degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) &&&\n    degree (Polynomial.smult (\\<beta> i) (F i)) < degree (F (i - 1)) \\<or> b", "by auto"], ["proof (state)\nthis:\n  degree (F (i - 1))\n  \\<le> degree (Polynomial.smult (\\<alpha> i) (F (i - 2)))\n  degree (Polynomial.smult (\\<beta> i) (F i)) < degree (F (i - 1)) \\<or> ?b\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have degree_smult_eq:\"\\<And> c f. (c::_::{idom_divide}) \\<noteq> 0 \\<Longrightarrow> degree (smult c f) = degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f.\n       c \\<noteq> (0::'b) \\<Longrightarrow>\n       degree (Polynomial.smult c f) = degree f", "by auto"], ["proof (state)\nthis:\n  ?c \\<noteq> (0::?'b1) \\<Longrightarrow>\n  degree (Polynomial.smult ?c ?f) = degree ?f\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have n_lt:\"n i < n (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n i < n (i - 1)", "using n_gt[of \"i-1\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. n i < n (i - 1)", "unfolding n"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> degree (F (Suc (i - 1))) < degree (F (i - 1))\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. degree (F i) < degree (F (i - 1))", "by auto"], ["proof (state)\nthis:\n  n i < n (i - 1)\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "from semiring_normalization_rules(30) mult.commute"], ["proof (chain)\npicking this:\n  (?x * ?y) ^ ?q = ?x ^ ?q * ?y ^ ?q\n  ?a * ?b = ?b * ?a", "have *:\"\\<And> x y q. (x * (y::'a fract)) ^ q = y ^ q * x ^ q\""], ["proof (prove)\nusing this:\n  (?x * ?y) ^ ?q = ?x ^ ?q * ?y ^ ?q\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. \\<And>x y q. (x * y) ^ q = y ^ q * x ^ q", "by metis"], ["proof (state)\nthis:\n  (?x1 * ?y1) ^ ?q1 = ?y1 ^ ?q1 * ?x1 ^ ?q1\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have \"n (i - 1) - n i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n (i - 1) - n i", "using n_lt"], ["proof (prove)\nusing this:\n  n i < n (i - 1)\n\ngoal (1 subgoal):\n 1. 0 < n (i - 1) - n i", "by auto"], ["proof (state)\nthis:\n  0 < n (i - 1) - n i\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "hence **:\"\\<beta> i ^ (n (i - 1) - n i - 1) * \\<beta> i = \\<beta> i ^ (n (i - 1) - n i)\""], ["proof (prove)\nusing this:\n  0 < n (i - 1) - n i\n\ngoal (1 subgoal):\n 1. \\<beta> i ^ (n (i - 1) - n i - 1) * \\<beta> i =\n    \\<beta> i ^ (n (i - 1) - n i)", "by (subst power_minus_mult) auto"], ["proof (state)\nthis:\n  \\<beta> i ^ (n (i - 1) - n i - 1) * \\<beta> i =\n  \\<beta> i ^ (n (i - 1) - n i)\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have \"max (n (i - 2)) (n (i - 1)) = n (i - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (n (i - 2)) (n (i - 1)) = n (i - 2)", "using n_ge[of \"i-2\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> i - 2; i - 2 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 2)) \\<le> n (i - 2)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. max (n (i - 2)) (n (i - 1)) = n (i - 2)", "unfolding max_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> i - 2; i - 2 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 2)) \\<le> n (i - 2)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. (if n (i - 2) \\<le> n (i - 1) then n (i - 1) else n (i - 2)) = n (i - 2)", "by auto"], ["proof (state)\nthis:\n  max (n (i - 2)) (n (i - 1)) = n (i - 2)\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "with diff_add_assoc[OF n_ge[of \"i-1\"],symmetric] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> ?i + (n (i - 1) - n (Suc (i - 1))) =\n                    ?i + n (i - 1) - n (Suc (i - 1))\n  3 \\<le> i\n  i \\<le> k\n  max (n (i - 2)) (n (i - 1)) = n (i - 2)", "have ns : \"n (i - 2) - n (i - 1) + (n (i - 1) - n i) = n (i - 2) - n i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> ?i + (n (i - 1) - n (Suc (i - 1))) =\n                    ?i + n (i - 1) - n (Suc (i - 1))\n  3 \\<le> i\n  i \\<le> k\n  max (n (i - 2)) (n (i - 1)) = n (i - 2)\n\ngoal (1 subgoal):\n 1. n (i - 2) - n (i - 1) + (n (i - 1) - n i) = n (i - 2) - n i", "by (auto simp:nat_minus_add_max)"], ["proof (state)\nthis:\n  n (i - 2) - n (i - 1) + (n (i - 1) - n i) = n (i - 2) - n i\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "{"], ["proof (state)\nthis:\n  n (i - 2) - n (i - 1) + (n (i - 1) - n i) = n (i - 2) - n i\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "assume \"j < n i\""], ["proof (state)\nthis:\n  j < n i\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "hence j:\"j < degree (smult (\\<beta> i) (F i))\""], ["proof (prove)\nusing this:\n  j < n i\n\ngoal (1 subgoal):\n 1. j < degree (Polynomial.smult (\\<beta> i) (F i))", "using \\<beta>0"], ["proof (prove)\nusing this:\n  j < n i\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j < degree (Polynomial.smult (\\<beta> i) (F i))", "unfolding n"], ["proof (prove)\nusing this:\n  j < degree (F i)\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j < degree (Polynomial.smult (\\<beta> i) (F i))", "by auto"], ["proof (state)\nthis:\n  j < degree (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (4 subgoals):\n 1. j < n i \\<Longrightarrow>\n    Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))\n 2. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 3. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 4. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "from BT_lemma_1_12[OF beta_F_as_sum df j]"], ["proof (chain)\npicking this:\n  subresultant j (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) =\n  Polynomial.smult\n   ((- 1) ^\n    ((degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) - j) *\n     (degree (F (i - 1)) - j)) *\n    lead_coeff (F (i - 1)) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (Polynomial.smult (\\<beta> i) (F i))))\n   (subresultant j (F (i - 1)) (Polynomial.smult (\\<beta> i) (F i)))", "show ?eq_21"], ["proof (prove)\nusing this:\n  subresultant j (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) =\n  Polynomial.smult\n   ((- 1) ^\n    ((degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) - j) *\n     (degree (F (i - 1)) - j)) *\n    lead_coeff (F (i - 1)) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (Polynomial.smult (\\<beta> i) (F i))))\n   (subresultant j (F (i - 1)) (Polynomial.smult (\\<beta> i) (F i)))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))", "unfolding subresultant_smult_right[OF \\<beta>0] subresultant_smult_left[OF \\<alpha>0]\n                degree_smult_eq[OF \\<alpha>0] degree_smult_eq[OF \\<beta>0] n[symmetric] f[symmetric] \\<delta> s ns"], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i)) f i ^\n    (n (i - 1) - j))\n   (subresultant j (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n    coeff (F (i - 1)) (n (i - 1)) ^ (n (i - 2) - n i))\n   (Polynomial.smult (\\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i)))\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i)) f i ^\n      (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (n (i - 2) - n i) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))", "using f n"], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i)) f i ^\n    (n (i - 1) - j))\n   (subresultant j (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n    coeff (F (i - 1)) (n (i - 1)) ^ (n (i - 2) - n i))\n   (Polynomial.smult (\\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i)))\n  f ?i = lead_coeff (F ?i)\n  n ?i = degree (F ?i)\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i)) f i ^\n      (n (i - 1) - j))\n     (subresultant j (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n      f (i - 1) ^ (n (i - 2) - n i) *\n      \\<beta> i ^ (n (i - 1) - j))\n     (subresultant j (F (i - 1)) (F i))", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n   (subresultant j (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    \\<beta> i ^ (n (i - 1) - j))\n   (subresultant j (F (i - 1)) (F i))\n\ngoal (3 subgoals):\n 1. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 2. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 3. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "}"], ["proof (state)\nthis:\n  j < n i \\<Longrightarrow>\n  Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n   (subresultant j (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    \\<beta> i ^ (n (i - 1) - j))\n   (subresultant j (F (i - 1)) (F i))\n\ngoal (3 subgoals):\n 1. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 2. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 3. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "{"], ["proof (state)\nthis:\n  j < n i \\<Longrightarrow>\n  Polynomial.smult (\\<alpha> i ^ (n (i - 1) - j))\n   (subresultant j (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((n (i - 2) - j) * (n (i - 1) - j)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    \\<beta> i ^ (n (i - 1) - j))\n   (subresultant j (F (i - 1)) (F i))\n\ngoal (3 subgoals):\n 1. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)\n 2. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 3. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "from BT_lemma_1_13[OF beta_F_as_sum df df(2)]"], ["proof (chain)\npicking this:\n  subresultant (degree (Polynomial.smult (\\<beta> i) (F i)))\n   (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) =\n  Polynomial.smult\n   ((- 1) ^\n    ((degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n      degree (Polynomial.smult (\\<beta> i) (F i))) *\n     (degree (F (i - 1)) - degree (Polynomial.smult (\\<beta> i) (F i)))) *\n    lead_coeff (F (i - 1)) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (Polynomial.smult (\\<beta> i) (F i))) *\n    lead_coeff (Polynomial.smult (\\<beta> i) (F i)) ^\n    (degree (F (i - 1)) - degree (Polynomial.smult (\\<beta> i) (F i)) - 1))\n   (Polynomial.smult (\\<beta> i) (F i))", "show ?eq_22"], ["proof (prove)\nusing this:\n  subresultant (degree (Polynomial.smult (\\<beta> i) (F i)))\n   (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) =\n  Polynomial.smult\n   ((- 1) ^\n    ((degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n      degree (Polynomial.smult (\\<beta> i) (F i))) *\n     (degree (F (i - 1)) - degree (Polynomial.smult (\\<beta> i) (F i)))) *\n    lead_coeff (F (i - 1)) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (Polynomial.smult (\\<beta> i) (F i))) *\n    lead_coeff (Polynomial.smult (\\<beta> i) (F i)) ^\n    (degree (F (i - 1)) - degree (Polynomial.smult (\\<beta> i) (F i)) - 1))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n      f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n      f i ^ (\\<delta> (i - 1) - 1) *\n      \\<beta> i ^ \\<delta> (i - 1))\n     (F i)", "unfolding subresultant_smult_left[OF \\<alpha>0] lead_coeff_smult smult_smult\n                degree_smult_eq[OF \\<alpha>0] degree_smult_eq[OF \\<beta>0] n[symmetric] f[symmetric] \\<delta> s ns"], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i)) f i ^\n    (n (i - 1) - n i))\n   (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((n (i - 2) - n i) * (n (i - 1) - n i)) *\n    coeff (F (i - 1)) (n (i - 1)) ^ (n (i - 2) - n i) *\n    coeff (Polynomial.smult (\\<beta> i) (F i)) (n i) ^\n    (n (i - 1) - n i - 1) *\n    \\<beta> i)\n   (F i)\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i)) f i ^\n      (n (i - 1) - n i))\n     (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ ((n (i - 2) - n i) * (n (i - 1) - n i)) *\n      f (i - 1) ^ (n (i - 2) - n i) *\n      f i ^ (n (i - 1) - n i - 1) *\n      \\<beta> i ^ (n (i - 1) - n i))\n     (F i)", "by (metis (no_types, lifting) * ** coeff_smult f mult.assoc n)"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n   (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    f i ^ (\\<delta> (i - 1) - 1) *\n    \\<beta> i ^ \\<delta> (i - 1))\n   (F i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 2. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "}"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n   (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    f i ^ (\\<delta> (i - 1) - 1) *\n    \\<beta> i ^ \\<delta> (i - 1))\n   (F i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 2. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "{"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i ^ \\<delta> (i - 1))\n   (subresultant (n i) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    f i ^ (\\<delta> (i - 1) - 1) *\n    \\<beta> i ^ \\<delta> (i - 1))\n   (F i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 2. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "assume \"n i < j\" \"j < n (i - 1) - 1\""], ["proof (state)\nthis:\n  n i < j\n  j < n (i - 1) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 2. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "hence j:\"degree (smult (\\<beta> i) (F i)) < j\" \"j < degree (F (i - 1)) - 1\""], ["proof (prove)\nusing this:\n  n i < j\n  j < n (i - 1) - 1\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (\\<beta> i) (F i)) < j &&&\n    j < degree (F (i - 1)) - 1", "using \\<beta>0"], ["proof (prove)\nusing this:\n  n i < j\n  j < n (i - 1) - 1\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (\\<beta> i) (F i)) < j &&&\n    j < degree (F (i - 1)) - 1", "unfolding n"], ["proof (prove)\nusing this:\n  degree (F i) < j\n  j < degree (F (i - 1)) - 1\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (\\<beta> i) (F i)) < j &&&\n    j < degree (F (i - 1)) - 1", "by auto"], ["proof (state)\nthis:\n  degree (Polynomial.smult (\\<beta> i) (F i)) < j\n  j < degree (F (i - 1)) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n    \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n 2. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "from BT_lemma_1_14[OF beta_F_as_sum df j]"], ["proof (chain)\npicking this:\n  subresultant j (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) = 0", "show ?eq_23"], ["proof (prove)\nusing this:\n  subresultant j (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. subresultant j (F (i - 2)) (F (i - 1)) = 0", "unfolding subresultant_smult_left[OF \\<alpha>0] smult_eq_0_iff"], ["proof (prove)\nusing this:\n  \\<alpha> i ^ (degree (F (i - 1)) - j) = 0 \\<or>\n  subresultant j (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. subresultant j (F (i - 2)) (F (i - 1)) = 0", "using \\<alpha>0pow"], ["proof (prove)\nusing this:\n  \\<alpha> i ^ (degree (F (i - 1)) - j) = 0 \\<or>\n  subresultant j (F (i - 2)) (F (i - 1)) = 0\n  \\<alpha> i ^ ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant j (F (i - 2)) (F (i - 1)) = 0", "by auto"], ["proof (state)\nthis:\n  subresultant j (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n  \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>n i < j; j < n (i - 1) - 1\\<rbrakk>\n  \\<Longrightarrow> subresultant j (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "have ***: \"n (i - 1) - (n (i - 1) - 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (i - 1) - (n (i - 1) - 1) = 1", "using n_lt"], ["proof (prove)\nusing this:\n  n i < n (i - 1)\n\ngoal (1 subgoal):\n 1. n (i - 1) - (n (i - 1) - 1) = 1", "by auto"], ["proof (state)\nthis:\n  n (i - 1) - (n (i - 1) - 1) = 1\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "from BT_lemma_1_15[OF beta_F_as_sum df df(2)]"], ["proof (chain)\npicking this:\n  subresultant (degree (F (i - 1)) - 1)\n   (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) =\n  Polynomial.smult\n   ((- 1) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (F (i - 1)) +\n     1) *\n    lead_coeff (F (i - 1)) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (F (i - 1)) +\n     1))\n   (Polynomial.smult (\\<beta> i) (F i))", "show ?eq_24"], ["proof (prove)\nusing this:\n  subresultant (degree (F (i - 1)) - 1)\n   (Polynomial.smult (\\<alpha> i) (F (i - 2))) (F (i - 1)) =\n  Polynomial.smult\n   ((- 1) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (F (i - 1)) +\n     1) *\n    lead_coeff (F (i - 1)) ^\n    (degree (Polynomial.smult (\\<alpha> i) (F (i - 2))) -\n     degree (F (i - 1)) +\n     1))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i)", "unfolding subresultant_smult_left[OF \\<alpha>0] *** degree_smult_eq[OF \\<alpha>0] n[symmetric] f \\<delta>"], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i))\n     (\\<lambda>i. coeff (F i) (n i)) i ^\n    1)\n   (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ (n (i - 2) - n (i - 1) + 1) *\n    coeff (F (i - 1)) (n (i - 1)) ^ (n (i - 2) - n (i - 1) + 1))\n   (Polynomial.smult (\\<beta> i) (F i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (subresultant_prs_locale.\\<alpha> (\\<lambda>i. n i - n (Suc i))\n       (\\<lambda>i. coeff (F i) (n i)) i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n    Polynomial.smult\n     ((- 1) ^ (n (i - 2) - n (Suc (i - 2)) + 1) *\n      coeff (F (i - 1)) (n (i - 1)) ^ (n (i - 2) - n (Suc (i - 2)) + 1) *\n      \\<beta> i)\n     (F i)", "by (auto simp:mult.commute)"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i)\n   (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n    \\<beta> i)\n   (F i)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i)\n   (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n    \\<beta> i)\n   (F i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma BT_eq_30: \"3 \\<le> i \\<Longrightarrow> i \\<le> k + 1 \\<Longrightarrow> j < n (i - 1) \\<Longrightarrow>\n    smult (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) (subresultant j (F 1) (F 2))\n  = smult (\\<Prod>l\\<leftarrow>[3..<i]. \\<beta> l ^ (n (l - 1) - j) * f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1))\n        * (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))) (subresultant j (F (i - 2)) (F (i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n    \\<Longrightarrow> Polynomial.smult\n                       (\\<Prod>l\\<leftarrow>[3..<\n       i]. \\<alpha> l ^ (n (l - 1) - j))\n                       (subresultant j (F 1) (F 2)) =\n                      Polynomial.smult\n                       (\\<Prod>l\\<leftarrow>[3..<\n       i]. \\<beta> l ^ (n (l - 1) - j) *\n           f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n           (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                       (subresultant j (F (i - 2)) (F (i - 1)))", "proof (induct \"i - 3\" arbitrary:i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?i - 3; 3 \\<le> ?i; ?i \\<le> k + 1; j < n (?i - 1)\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult\n                     (\\<Prod>l\\<leftarrow>[3..<\n     ?i]. \\<alpha> l ^ (n (l - 1) - j))\n                     (subresultant j (F 1) (F 2)) =\n                    Polynomial.smult\n                     (\\<Prod>l\\<leftarrow>[3..<\n     ?i]. \\<beta> l ^ (n (l - 1) - j) *\n          f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                     (subresultant j (F (?i - 2)) (F (?i - 1)))\n  Suc x = i - 3\n  3 \\<le> i\n  i \\<le> k + 1\n  j < n (i - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "from Suc.hyps(2) Suc.prems(1-2)"], ["proof (chain)\npicking this:\n  Suc x = i - 3\n  3 \\<le> i\n  i \\<le> k + 1", "have prems:\"x = (i - 1) - 3\" \"3 \\<le> i - 1\" \"i - 1 \\<le> k + 1\" \"2 \\<le> i - 1 - 1\" \"i - 1 - 1 < k\"\n               \"i - 1 \\<le> k\""], ["proof (prove)\nusing this:\n  Suc x = i - 3\n  3 \\<le> i\n  i \\<le> k + 1\n\ngoal (1 subgoal):\n 1. (x = i - 1 - 3 &&& 3 \\<le> i - 1 &&& i - 1 \\<le> k + 1) &&&\n    2 \\<le> i - 1 - 1 &&& i - 1 - 1 < k &&& i - 1 \\<le> k", "by auto"], ["proof (state)\nthis:\n  x = i - 1 - 3\n  3 \\<le> i - 1\n  i - 1 \\<le> k + 1\n  2 \\<le> i - 1 - 1\n  i - 1 - 1 < k\n  i - 1 \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "from prems(2)"], ["proof (chain)\npicking this:\n  3 \\<le> i - 1", "have inset:\"i - 1 \\<in> set [3..<i]\""], ["proof (prove)\nusing this:\n  3 \\<le> i - 1\n\ngoal (1 subgoal):\n 1. i - 1 \\<in> set [3..<i]", "by auto"], ["proof (state)\nthis:\n  i - 1 \\<in> set [3..<i]\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "have r1:\"remove1 (i - 1) [3..<i] = [3..<i-1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1 (i - 1) [3..<i] = [3..<i - 1]", "by (induct i,auto simp:remove1_append)"], ["proof (state)\nthis:\n  remove1 (i - 1) [3..<i] = [3..<i - 1]\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "from Suc.prems(1)"], ["proof (chain)\npicking this:\n  3 \\<le> i", "have \"Suc (i - 1 - 1) = i - 1\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. Suc (i - 1 - 1) = i - 1", "by auto"], ["proof (state)\nthis:\n  Suc (i - 1 - 1) = i - 1\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "from n_gt[OF prems(4,5),unfolded this] Suc.prems(3)"], ["proof (chain)\npicking this:\n  n (i - 1) < n (i - 1 - 1)\n  j < n (i - 1)", "have j:\"j < n (i - 1 - 1)\""], ["proof (prove)\nusing this:\n  n (i - 1) < n (i - 1 - 1)\n  j < n (i - 1)\n\ngoal (1 subgoal):\n 1. j < n (i - 1 - 1)", "by auto"], ["proof (state)\nthis:\n  j < n (i - 1 - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "have *:\"\\<And> c d e x. smult c d = e \\<Longrightarrow> smult (x * c) d = smult x e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c d e x.\n       Polynomial.smult c d = e \\<Longrightarrow>\n       Polynomial.smult (x * c) d = Polynomial.smult x e", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult ?c ?d = ?e \\<Longrightarrow>\n  Polynomial.smult (?x * ?c) ?d = Polynomial.smult ?x ?e\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "have **:\"\\<And> c d e x. smult c d = e \\<Longrightarrow> smult c (smult x d) = smult x e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c d e x.\n       Polynomial.smult c d = e \\<Longrightarrow>\n       Polynomial.smult c (Polynomial.smult x d) = Polynomial.smult x e", "by (auto simp:mult.commute)"], ["proof (state)\nthis:\n  Polynomial.smult ?c1 ?d1 = ?e1 \\<Longrightarrow>\n  Polynomial.smult ?c1 (Polynomial.smult ?x1 ?d1) = Polynomial.smult ?x1 ?e1\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = i - 3; 3 \\<le> i; i \\<le> k + 1;\n                    j < n (i - 1)\\<rbrakk>\n                   \\<Longrightarrow> Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n(subresultant j (F 1) (F 2)) =\n                                     Polynomial.smult\n(\\<Prod>l\\<leftarrow>[3..<\n                      i]. \\<beta> l ^ (n (l - 1) - j) *\n                          f (l - 1) ^\n                          (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                          (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n(subresultant j (F (i - 2)) (F (i - 1)));\n        Suc x = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n     (subresultant j (F 1) (F 2)) =\n    Polynomial.smult\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. \\<beta> l ^ (n (l - 1) - j) *\n                               f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                               (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "unfolding prod_list_map_remove1[OF inset(1),unfolded r1]\n      *[OF Suc.hyps(1)[OF prems(1-3) j]]\n      **[OF BT_lemma_2_21[OF prems(2,6) Suc.prems(3)]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i -\n                           1]. \\<beta> l ^ (n (l - 1) - j) *\n                               f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                               (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n     (Polynomial.smult\n       ((- 1) ^ ((n (i - 1 - 2) - j) * (n (i - 1 - 1) - j)) *\n        f (i - 1 - 1) ^ (\\<delta> (i - 1 - 2) + \\<delta> (i - 1 - 1)) *\n        \\<beta> (i - 1) ^ (n (i - 1 - 1) - j))\n       (subresultant j (F (i - 1 - 1)) (F (i - 1)))) =\n    Polynomial.smult\n     (\\<beta> (i - 1) ^ (n (i - 1 - 1) - j) *\n      f (i - 1 - 1) ^ (\\<delta> (i - 1 - 2) + \\<delta> (i - 1 - 1)) *\n      (- 1) ^ ((n (i - 1 - 2) - j) * (n (i - 1 - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i -\n                            1]. \\<beta> l ^ (n (l - 1) - j) *\n                                f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                                (- 1) ^\n                                ((n (l - 2) - j) * (n (l - 1) - j))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "by (auto simp: numeral_2_eq_2 ac_simps)"], ["proof (state)\nthis:\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n   (subresultant j (F 1) (F 2)) =\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<\n                         i]. \\<beta> l ^ (n (l - 1) - j) *\n                             f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                             (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 = i - 3; 3 \\<le> i; i \\<le> k + 1; j < n (i - 1)\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<alpha> l ^ (n (l - 1) - j))\n                          (subresultant j (F 1) (F 2)) =\n                         Polynomial.smult\n                          (\\<Prod>l\\<leftarrow>[3..<\n          i]. \\<beta> l ^ (n (l - 1) - j) *\n              f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n                          (subresultant j (F (i - 2)) (F (i - 1)))", "qed auto"], ["", "lemma nonzero_alphaprod: assumes \"i \\<le> k + 1\" shows \"(\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (p l)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ p l) \\<noteq> 0", "unfolding prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set (map (\\<lambda>l. \\<alpha> l ^ p l) [3..<i])", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> k + 1\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set (map (\\<lambda>l. \\<alpha> l ^ p l) [3..<i])", "by (auto simp: \\<alpha>0)"], ["", "lemma BT_eq_30': assumes i: \"3 \\<le> i\" \"i \\<le> k + 1\" \"j < n (i - 1)\"\nshows \"subresultant j (F 1) (F 2)\n  = smult ((- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j))\n     * (\\<Prod>l\\<leftarrow>[3..<i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) * (\\<Prod>l\\<leftarrow>[3..<i]. f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)))) (subresultant j (F (i - 2)) (F (i - 1)))\"\n  (is \"_ = smult (?mm * ?b * ?f) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "let ?a = \"\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "let ?d = \"\\<Prod>l\\<leftarrow>[3..<i]. \\<beta> l ^ (n (l - 1) - j) * f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                     (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "let ?m = \"\\<Prod>l\\<leftarrow>[3..<i]. (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "have a0: \"?a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0", "by (rule nonzero_alphaprod, rule i)"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "with arg_cong[OF BT_eq_30[OF i], of \"smult (inverse ?a)\", unfolded smult_smult]"], ["proof (chain)\npicking this:\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)))\n   (subresultant j (F 1) (F 2)) =\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. \\<beta> l ^ (n (l - 1) - j) *\n                              f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n  (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0", "have \"subresultant j (F 1) (F 2) = smult (inverse ?a * ?d)\n    (subresultant j (F (i - 2)) (F (i - 1)))\""], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)))\n   (subresultant j (F 1) (F 2)) =\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. \\<beta> l ^ (n (l - 1) - j) *\n                              f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n  (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. \\<beta> l ^ (n (l - 1) - j) *\n                                f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                                (- 1) ^\n                                ((n (l - 2) - j) * (n (l - 1) - j))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "by simp"], ["proof (state)\nthis:\n  subresultant j (F 1) (F 2) =\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. \\<beta> l ^ (n (l - 1) - j) *\n                              f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "also"], ["proof (state)\nthis:\n  subresultant j (F 1) (F 2) =\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. \\<beta> l ^ (n (l - 1) - j) *\n                              f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "have \"inverse ?a * ?d = ?b * ?f * ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. \\<beta> l ^ (n (l - 1) - j) *\n                              f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))) =\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))", "unfolding prod_list_multf inverse_prod_list map_map o_def\n      power_inverse[symmetric] power_mult_distrib divide_inverse_commute"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>[3..<i]. inverse (\\<alpha> x) ^ (n (x - 1) - j)) *\n    ((\\<Prod>l\\<leftarrow>[3..<i]. \\<beta> l ^ (n (l - 1) - j)) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. (- 1) ^\n                               ((n (l - 2) - j) * (n (l - 1) - j)))) =\n    (\\<Prod>l\\<leftarrow>[3..<i]. inverse (\\<alpha> l) ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<i]. \\<beta> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))", "by simp"], ["proof (state)\nthis:\n  inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. \\<beta> l ^ (n (l - 1) - j) *\n                            f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                            (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<i]. (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "also"], ["proof (state)\nthis:\n  inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. \\<beta> l ^ (n (l - 1) - j) *\n                            f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                            (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<i]. (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "have \"?m = ?mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))) =\n    (- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j))", "unfolding prod_list_minus_1_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) =\n    (- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j))", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))) =\n  (- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j))\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "finally"], ["proof (chain)\npicking this:\n  subresultant j (F 1) (F 2) =\n  Polynomial.smult\n   ((\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    (- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)))\n   (subresultant j (F (i - 2)) (F (i - 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  subresultant j (F 1) (F 2) =\n  Polynomial.smult\n   ((\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    (- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  subresultant j (F 1) (F 2) =\n  Polynomial.smult\n   ((- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - j) * (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For defining the subresultant PRS, we mainly follow Brown's ``The Subresultant PRS Algorithm'' (B).\\<close>"], ["", "definition \"R j = (if j = n 2 then sdiv_poly (smult ((lead_coeff G2)^(\\<delta> 1)) G2) (lead_coeff G2) else subresultant j G1 G2)\""], ["", "abbreviation \"ff i \\<equiv> to_fract (i :: 'a)\""], ["", "abbreviation \"ffp \\<equiv> map_poly ff\""], ["", "sublocale map_poly_hom: map_poly_inj_idom_hom to_fract"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_hom to_fract", ".."], ["", "(* for \\<sigma> and \\<tau> we only take additions, so that no negative number-problems occur *)"], ["", "definition \"\\<sigma> i = (\\<Sum>l\\<leftarrow>[3..<Suc i]. (n (l - 2) + n (i - 1) + 1) * (n (l - 1) + n (i - 1) + 1))\""], ["", "definition \"\\<tau> i = (\\<Sum>l\\<leftarrow>[3..<Suc i]. (n (l - 2) + n i) * (n (l - 1) + n i))\""], ["", "definition \"\\<gamma> i = (-1)^(\\<sigma> i) * pow_int ( f (i - 1)) (1 - int (\\<delta> (i - 1))) * (\\<Prod>l\\<leftarrow>[3..<Suc i].\n  (\\<beta> l / \\<alpha> l)^(n (l - 1) - n (i - 1) + 1) * (f (l - 1))^(\\<delta> (l - 2) + \\<delta> (l - 1)))\""], ["", "definition \"\\<Theta> i = (-1)^(\\<tau> i) * pow_int (f i) (int (\\<delta> (i - 1)) - 1) * (\\<Prod>l\\<leftarrow>[3..<Suc i].\n  (\\<beta> l / \\<alpha> l)^(n (l - 1) - n i) * (f (l - 1))^(\\<delta> (l - 2) + \\<delta> (l - 1)))\""], ["", "(* is eq 29 in BT *)"], ["", "lemma fundamental_theorem_eq_4: assumes i: \"3 \\<le> i\" \"i \\<le> k\"\n  shows \"ffp (R (n (i - 1) - 1)) = smult (\\<gamma> i) (F i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "have \"n (i - 1) \\<le> n 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (i - 1) \\<le> n 2", "by (rule n_ge_trans, insert i, auto)"], ["proof (state)\nthis:\n  n (i - 1) \\<le> n 2\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "with n_gt[of \"i - 1\"] i"], ["proof (chain)\npicking this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k\n  n (i - 1) \\<le> n 2", "have \"n (i - 1) - 1 < n 2\"\n    and lt: \"n (i - 1) - 1 < n (i - 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k\n  n (i - 1) \\<le> n 2\n\ngoal (1 subgoal):\n 1. n (i - 1) - 1 < n 2 &&& n (i - 1) - 1 < n (i - 1)", "by linarith+"], ["proof (state)\nthis:\n  n (i - 1) - 1 < n 2\n  n (i - 1) - 1 < n (i - 1)\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "hence \"R (n (i - 1) - 1) = subresultant (n (i - 1) - 1) G1 G2\""], ["proof (prove)\nusing this:\n  n (i - 1) - 1 < n 2\n  n (i - 1) - 1 < n (i - 1)\n\ngoal (1 subgoal):\n 1. R (n (i - 1) - 1) = subresultant (n (i - 1) - 1) G1 G2", "unfolding R_def"], ["proof (prove)\nusing this:\n  n (i - 1) - 1 < n 2\n  n (i - 1) - 1 < n (i - 1)\n\ngoal (1 subgoal):\n 1. (if n (i - 1) - 1 = n 2\n     then sdiv_poly (Polynomial.smult (lead_coeff G2 ^ \\<delta> 1) G2)\n           (lead_coeff G2)\n     else subresultant (n (i - 1) - 1) G1 G2) =\n    subresultant (n (i - 1) - 1) G1 G2", "by auto"], ["proof (state)\nthis:\n  R (n (i - 1) - 1) = subresultant (n (i - 1) - 1) G1 G2\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "from arg_cong[OF this, of ffp, unfolded to_fract_hom.subresultant_hom, folded F1 F2]"], ["proof (chain)\npicking this:\n  ffp (R (n (i - 1) - 1)) = subresultant (n (i - 1) - 1) (F 1) (F 2)", "have id1: \"ffp (R (n (i - 1) - 1)) = subresultant (n (i - 1) - 1) (F 1) (F 2)\""], ["proof (prove)\nusing this:\n  ffp (R (n (i - 1) - 1)) = subresultant (n (i - 1) - 1) (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = subresultant (n (i - 1) - 1) (F 1) (F 2)", "."], ["proof (state)\nthis:\n  ffp (R (n (i - 1) - 1)) = subresultant (n (i - 1) - 1) (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "note eq_24 = BT_lemma_2_24[OF i]"], ["proof (state)\nthis:\n  Polynomial.smult (\\<alpha> i)\n   (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1))) =\n  Polynomial.smult\n   ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n    \\<beta> i)\n   (F i)\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?o = \"(- 1) :: 'a fract\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?m1 = \"(\\<delta> (i - 2) + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?d1 = \"f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?c1 = \"?o ^ ?m1  * ?d1\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?c0 = \"\\<alpha> i\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "have \"?c0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> i \\<noteq> 0", "using \\<alpha>0[of i] i"], ["proof (prove)\nusing this:\n  1 < i \\<Longrightarrow> (\\<alpha> i = 0) = (k < i - 1)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<alpha> i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "with arg_cong[OF eq_24, of \"smult (inverse ?c0)\"]"], ["proof (chain)\npicking this:\n  Polynomial.smult (inverse (\\<alpha> i))\n   (Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)))) =\n  Polynomial.smult (inverse (\\<alpha> i))\n   (Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i))\n  \\<alpha> i \\<noteq> 0", "have id2: \"subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)) =\n     smult (inverse ?c0 * ?c1) (F i)\""], ["proof (prove)\nusing this:\n  Polynomial.smult (inverse (\\<alpha> i))\n   (Polynomial.smult (\\<alpha> i)\n     (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)))) =\n  Polynomial.smult (inverse (\\<alpha> i))\n   (Polynomial.smult\n     ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 1) ^ (\\<delta> (i - 2) + 1) *\n      \\<beta> i)\n     (F i))\n  \\<alpha> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)) =\n    Polynomial.smult\n     (inverse (\\<alpha> i) *\n      ((- 1) ^ (\\<delta> (i - 2) + 1) *\n       (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i)))\n     (F i)", "by (auto intro: poly_eqI)"], ["proof (state)\nthis:\n  subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)) =\n  Polynomial.smult\n   (inverse (\\<alpha> i) *\n    ((- 1) ^ (\\<delta> (i - 2) + 1) *\n     (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i)))\n   (F i)\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "from i"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k", "have \"3 \\<le> i\" \"i \\<le> k + 1\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. 3 \\<le> i &&& i \\<le> k + 1", "by auto"], ["proof (state)\nthis:\n  3 \\<le> i\n  i \\<le> k + 1\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "note id3 = BT_eq_30'[OF this lt]"], ["proof (state)\nthis:\n  subresultant (n (i - 1) - 1) (F 1) (F 2) =\n  Polynomial.smult\n   ((- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))))\n   (subresultant (n (i - 1) - 1) (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?f = \"\\<lambda> l. f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?b = \"\\<lambda> l. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - (n (i - 1) - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?b' = \"\\<lambda> l. (\\<beta> l / \\<alpha> l) ^ (n (l - 1) - n (i - 1) + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?m = \"\\<lambda> l.  (n (l - 2) - (n (i - 1) - 1)) * (n (l - 1) - (n (i - 1) - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?m' = \"\\<lambda> l. (n (l - 2) + n (i - 1) + 1) * (n (l - 1) + n (i - 1) + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?m2 = \"(\\<Sum>l\\<leftarrow>[3..<i]. ?m l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?b2 = \"(\\<Prod>l\\<leftarrow>[3..<i]. ?b l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?f2 = \"(\\<Prod>l\\<leftarrow>[3..<i]. ?f l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "let ?f1 = \"pow_int ( f (i - 1)) (1 - int (\\<delta> (i - 1)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "have id4: \"\\<gamma> i = ?o ^ (?m1 + ?m2) * (inverse ?c0 * ?d1 * ?b2 * ?f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^\n    (\\<delta> (i - 2) + 1 +\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) - (n (i - 1) - 1)) *\n                              (n (l - 1) - (n (i - 1) - 1)))) *\n    (inverse (\\<alpha> i) *\n     (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. (\\<beta> l / \\<alpha> l) ^\n                               (n (l - 1) - (n (i - 1) - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^\n    (\\<delta> (i - 2) + 1 +\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) - (n (i - 1) - 1)) *\n                              (n (l - 1) - (n (i - 1) - 1)))) *\n    (inverse (\\<alpha> i) *\n     (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. (\\<beta> l / \\<alpha> l) ^\n                               (n (l - 1) - (n (i - 1) - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1))))", "have id: \"\\<gamma> i = (-1)^(\\<sigma> i) * (?f1 * (\\<Prod>l\\<leftarrow>[3..<Suc i]. ?b' l) * (\\<Prod>l\\<leftarrow>[3..<Suc i]. ?f l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^ \\<sigma> i *\n    (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                   (n (l - 1) - n (i - 1) + 1)) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. f (l - 1) ^\n                                   (\\<delta> (l - 2) + \\<delta> (l - 1))))", "unfolding \\<gamma>_def prod_list_multf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    ((\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                   (n (l - 1) - n (i - 1) + 1)) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. f (l - 1) ^\n                                   (\\<delta> (l - 2) + \\<delta> (l - 1)))) =\n    (- 1) ^ \\<sigma> i *\n    (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                   (n (l - 1) - n (i - 1) + 1)) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. f (l - 1) ^\n                                   (\\<delta> (l - 2) + \\<delta> (l - 1))))", "by simp"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^ \\<sigma> i *\n  (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n   (\\<Prod>l\\<leftarrow>[3..<\n                         Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                 (n (l - 1) - n (i - 1) + 1)) *\n   (\\<Prod>l\\<leftarrow>[3..<\n                         Suc i]. f (l - 1) ^\n                                 (\\<delta> (l - 2) + \\<delta> (l - 1))))\n\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^\n    (\\<delta> (i - 2) + 1 +\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) - (n (i - 1) - 1)) *\n                              (n (l - 1) - (n (i - 1) - 1)))) *\n    (inverse (\\<alpha> i) *\n     (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. (\\<beta> l / \\<alpha> l) ^\n                               (n (l - 1) - (n (i - 1) - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1))))", "have cong: \"even m1 = even m2 \\<Longrightarrow> c1 = c2 \\<Longrightarrow> ?o^m1 * c1 = ?o^m2 * c2\" for m1 m2 c1 c2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even m1 = even m2; c1 = c2\\<rbrakk>\n    \\<Longrightarrow> (- 1) ^ m1 * c1 = (- 1) ^ m2 * c2", "unfolding minus_1_power_even"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even m1 = even m2; c1 = c2\\<rbrakk>\n    \\<Longrightarrow> (if even m1 then 1 else - 1) * c1 =\n                      (if even m2 then 1 else - 1) * c2", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>even ?m1.1 = even ?m2.1; ?c1.1 = ?c2.1\\<rbrakk>\n  \\<Longrightarrow> (- 1) ^ ?m1.1 * ?c1.1 = (- 1) ^ ?m2.1 * ?c2.1\n\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^\n    (\\<delta> (i - 2) + 1 +\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) - (n (i - 1) - 1)) *\n                              (n (l - 1) - (n (i - 1) - 1)))) *\n    (inverse (\\<alpha> i) *\n     (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. (\\<beta> l / \\<alpha> l) ^\n                               (n (l - 1) - (n (i - 1) - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^\n    (\\<delta> (i - 2) + 1 +\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) - (n (i - 1) - 1)) *\n                              (n (l - 1) - (n (i - 1) - 1)))) *\n    (inverse (\\<alpha> i) *\n     (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. (\\<beta> l / \\<alpha> l) ^\n                               (n (l - 1) - (n (i - 1) - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1))))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> i *\n    (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                   (n (l - 1) - n (i - 1) + 1)) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           Suc i]. f (l - 1) ^\n                                   (\\<delta> (l - 2) + \\<delta> (l - 1)))) =\n    (- 1) ^\n    (\\<delta> (i - 2) + 1 +\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) - (n (i - 1) - 1)) *\n                              (n (l - 1) - (n (i - 1) - 1)))) *\n    (inverse (\\<alpha> i) *\n     (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. (\\<beta> l / \\<alpha> l) ^\n                               (n (l - 1) - (n (i - 1) - 1))) *\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1))))", "proof (rule cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "from n_gt[of \"i - 1\"] i"], ["proof (chain)\npicking this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k", "have n1: \"n (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. n (i - 1) \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  n (i - 1) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "{"], ["proof (state)\nthis:\n  n (i - 1) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "assume \"2 \\<le> l\" \"l \\<le> i\""], ["proof (state)\nthis:\n  2 \\<le> l\n  l \\<le> i\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "hence l: \"l \\<ge> 2\" \"l - 1 \\<le> i - 1\" \"l \\<le> k\""], ["proof (prove)\nusing this:\n  2 \\<le> l\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. 2 \\<le> l &&& l - 1 \\<le> i - 1 &&& l \\<le> k", "using i"], ["proof (prove)\nusing this:\n  2 \\<le> l\n  l \\<le> i\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. 2 \\<le> l &&& l - 1 \\<le> i - 1 &&& l \\<le> k", "by auto"], ["proof (state)\nthis:\n  2 \\<le> l\n  l - 1 \\<le> i - 1\n  l \\<le> k\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "from n_ge_trans[OF _ l(2)] l i"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 \\<le> l - 1; i - 1 \\<le> k\\<rbrakk>\n  \\<Longrightarrow> n (i - 1) \\<le> n (l - 1)\n  2 \\<le> l\n  l - 1 \\<le> i - 1\n  l \\<le> k\n  3 \\<le> i\n  i \\<le> k", "have n2: \"n (i - 1) \\<le> n (l - 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> l - 1; i - 1 \\<le> k\\<rbrakk>\n  \\<Longrightarrow> n (i - 1) \\<le> n (l - 1)\n  2 \\<le> l\n  l - 1 \\<le> i - 1\n  l \\<le> k\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. n (i - 1) \\<le> n (l - 1)", "by auto"], ["proof (state)\nthis:\n  n (i - 1) \\<le> n (l - 1)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "from n1 n2"], ["proof (chain)\npicking this:\n  n (i - 1) \\<noteq> 0\n  n (i - 1) \\<le> n (l - 1)", "have id: \"n (l - 1) - (n (i - 1) - 1) = n (l - 1) - n (i - 1) + 1\""], ["proof (prove)\nusing this:\n  n (i - 1) \\<noteq> 0\n  n (i - 1) \\<le> n (l - 1)\n\ngoal (1 subgoal):\n 1. n (l - 1) - (n (i - 1) - 1) = n (l - 1) - n (i - 1) + 1", "by auto"], ["proof (state)\nthis:\n  n (l - 1) - (n (i - 1) - 1) = n (l - 1) - n (i - 1) + 1\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "have \"even (n (l - 1) - (n (i - 1) - 1)) = even (n (l - 1) + n (i - 1) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (n (l - 1) - (n (i - 1) - 1)) = even (n (l - 1) + n (i - 1) + 1)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (n (l - 1) - n (i - 1) + 1) = even (n (l - 1) + n (i - 1) + 1)", "using n2"], ["proof (prove)\nusing this:\n  n (i - 1) \\<le> n (l - 1)\n\ngoal (1 subgoal):\n 1. even (n (l - 1) - n (i - 1) + 1) = even (n (l - 1) + n (i - 1) + 1)", "by auto"], ["proof (state)\nthis:\n  even (n (l - 1) - (n (i - 1) - 1)) = even (n (l - 1) + n (i - 1) + 1)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "note id n2 this"], ["proof (state)\nthis:\n  n (l - 1) - (n (i - 1) - 1) = n (l - 1) - n (i - 1) + 1\n  n (i - 1) \\<le> n (l - 1)\n  even (n (l - 1) - (n (i - 1) - 1)) = even (n (l - 1) + n (i - 1) + 1)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>2 \\<le> ?l3; ?l3 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> n (?l3 - 1) - (n (i - 1) - 1) =\n                    n (?l3 - 1) - n (i - 1) + 1\n  \\<lbrakk>2 \\<le> ?l3; ?l3 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> n (i - 1) \\<le> n (?l3 - 1)\n  \\<lbrakk>2 \\<le> ?l3; ?l3 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> even (n (?l3 - 1) - (n (i - 1) - 1)) =\n                    even (n (?l3 - 1) + n (i - 1) + 1)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "note diff = this"], ["proof (state)\nthis:\n  \\<lbrakk>2 \\<le> ?l3; ?l3 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> n (?l3 - 1) - (n (i - 1) - 1) =\n                    n (?l3 - 1) - n (i - 1) + 1\n  \\<lbrakk>2 \\<le> ?l3; ?l3 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> n (i - 1) \\<le> n (?l3 - 1)\n  \\<lbrakk>2 \\<le> ?l3; ?l3 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> even (n (?l3 - 1) - (n (i - 1) - 1)) =\n                    even (n (?l3 - 1) + n (i - 1) + 1)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "have f0: \"f (i - 1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i - 1) \\<noteq> 0", "using f0[of \"i - 1\"] i"], ["proof (prove)\nusing this:\n  i - 1 \\<noteq> 0 \\<Longrightarrow> (f (i - 1) = 0) = (k < i - 1)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. f (i - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f (i - 1) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "have \"(\\<Prod>l\\<leftarrow>[3..<Suc i]. ?b' l) = (\\<Prod>l\\<leftarrow>[3..<Suc i]. ?b l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) =\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - (n (i - 1) - 1)))", "by (rule arg_cong, rule map_cong, use diff(1) in auto)"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - (n (i - 1) - 1)))\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "also"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - (n (i - 1) - 1)))\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "have \"\\<dots> = ?b2 * ?b i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - (n (i - 1) - 1))) =\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1))", "using i"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - (n (i - 1) - 1))) =\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1))", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - (n (i - 1) - 1))) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1))\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1))", "have \"?f1 * (\\<Prod>l\\<leftarrow>[3..<Suc i]. ?b' l) * (\\<Prod>l\\<leftarrow>[3..<Suc i]. ?f l) =\n         (?b2 * ?f2) * (?f1 * ?b i * ?f i)\""], ["proof (prove)\nusing this:\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1))\n\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n     (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n     f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)))", "using i"], ["proof (prove)\nusing this:\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1))\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n     (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n     f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)))", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n  (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n   (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n   f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)))\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "also"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n  (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n   (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n   f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)))\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "have \"?f1 * ?b i * ?f i = (?f1 * ?f i) * \\<beta> i * inverse ?c0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) =\n    pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    \\<beta> i *\n    inverse (\\<alpha> i)", "using n1"], ["proof (prove)\nusing this:\n  n (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) =\n    pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n    \\<beta> i *\n    inverse (\\<alpha> i)", "by (simp add: divide_inverse)"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n  f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) =\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n  \\<beta> i *\n  inverse (\\<alpha> i)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "also"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - (n (i - 1) - 1)) *\n  f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) =\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n  \\<beta> i *\n  inverse (\\<alpha> i)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "have \"?f1 * ?f i = f (i - 1) ^ (\\<delta> (i - 2) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) =\n    f (i - 1) ^ (\\<delta> (i - 2) + 1)", "unfolding exp_pow_int pow_int_add[OF f0, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1))\n     (1 - int (\\<delta> (i - 1)) +\n      int (\\<delta> (i - 2) + \\<delta> (i - 1))) =\n    pow_int (f (i - 1)) (int (\\<delta> (i - 2) + 1))", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) =\n  f (i - 1) ^ (\\<delta> (i - 2) + 1)\n\ngoal (2 subgoals):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))\n 2. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "finally"], ["proof (chain)\npicking this:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n  (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i * inverse (\\<alpha> i))", "show \"?f1 * (\\<Prod>l\\<leftarrow>[3..<Suc i]. ?b' l) * (\\<Prod>l\\<leftarrow>[3..<Suc i]. ?f l)\n         = inverse ?c0 * ?d1 * ?b2 * ?f2\""], ["proof (prove)\nusing this:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n  (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i * inverse (\\<alpha> i))\n\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i - 1) + 1)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    inverse (\\<alpha> i) *\n    (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - (n (i - 1) - 1))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)))", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - n (i - 1) + 1)) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n  inverse (\\<alpha> i) * (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - (n (i - 1) - 1))) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        i]. f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1)))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "have \"even (\\<sigma> i) = even ((\\<Sum>l\\<leftarrow>[3..<i]. ?m' l) + ?m' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     ((\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) + n (i - 1) + 1) *\n                               (n (l - 1) + n (i - 1) + 1)) +\n      (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))", "unfolding \\<sigma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     (\\<Sum>l\\<leftarrow>[3..<\n                          Suc i]. (n (l - 2) + n (i - 1) + 1) *\n                                  (n (l - 1) + n (i - 1) + 1)) =\n    even\n     ((\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) + n (i - 1) + 1) *\n                               (n (l - 1) + n (i - 1) + 1)) +\n      (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))", "using i"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. even\n     (\\<Sum>l\\<leftarrow>[3..<\n                          Suc i]. (n (l - 2) + n (i - 1) + 1) *\n                                  (n (l - 1) + n (i - 1) + 1)) =\n    even\n     ((\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) + n (i - 1) + 1) *\n                               (n (l - 1) + n (i - 1) + 1)) +\n      (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))", "by simp"], ["proof (state)\nthis:\n  even (\\<sigma> i) =\n  even\n   ((\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) +\n    (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "also"], ["proof (state)\nthis:\n  even (\\<sigma> i) =\n  even\n   ((\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) +\n    (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "have \"\\<dots> = (even (\\<Sum>l\\<leftarrow>[3..<i]. ?m' l) = even (?m' i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     ((\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) + n (i - 1) + 1) *\n                               (n (l - 1) + n (i - 1) + 1)) +\n      (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    (even\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) + n (i - 1) + 1) *\n                               (n (l - 1) + n (i - 1) + 1)) =\n     even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)))", "by simp"], ["proof (state)\nthis:\n  even\n   ((\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) +\n    (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n  (even\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) =\n   even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "also"], ["proof (state)\nthis:\n  even\n   ((\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) +\n    (n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n  (even\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) =\n   even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "have \"even (\\<Sum>l\\<leftarrow>[3..<i]. ?m' l) = even ?m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) + n (i - 1) + 1) *\n                              (n (l - 1) + n (i - 1) + 1)) =\n    even\n     (\\<Sum>l\\<leftarrow>[3..<\n                          i]. (n (l - 2) - (n (i - 1) - 1)) *\n                              (n (l - 1) - (n (i - 1) - 1)))", "proof (rule even_sum_list, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [3..<i] \\<Longrightarrow>\n       even ((n (x - 2) + n (i - 1) + 1) * (n (x - 1) + n (i - 1) + 1)) =\n       even ((n (x - 2) - (n (i - 1) - 1)) * (n (x - 1) - (n (i - 1) - 1)))", "case (1 l)"], ["proof (state)\nthis:\n  l \\<in> set [3..<i]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [3..<i] \\<Longrightarrow>\n       even ((n (x - 2) + n (i - 1) + 1) * (n (x - 1) + n (i - 1) + 1)) =\n       even ((n (x - 2) - (n (i - 1) - 1)) * (n (x - 1) - (n (i - 1) - 1)))", "hence l: \"l \\<ge> 2\" \"l \\<le> i\" and l1: \"l - 1 \\<ge> 2\" \"l - 1 \\<le> i\""], ["proof (prove)\nusing this:\n  l \\<in> set [3..<i]\n\ngoal (1 subgoal):\n 1. (2 \\<le> l &&& l \\<le> i) &&& 2 \\<le> l - 1 &&& l - 1 \\<le> i", "by auto"], ["proof (state)\nthis:\n  2 \\<le> l\n  l \\<le> i\n  2 \\<le> l - 1\n  l - 1 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [3..<i] \\<Longrightarrow>\n       even ((n (x - 2) + n (i - 1) + 1) * (n (x - 1) + n (i - 1) + 1)) =\n       even ((n (x - 2) - (n (i - 1) - 1)) * (n (x - 1) - (n (i - 1) - 1)))", "have l2: \"l - 2 = l - 1 - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l - 2 = l - 1 - 1", "by simp"], ["proof (state)\nthis:\n  l - 2 = l - 1 - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [3..<i] \\<Longrightarrow>\n       even ((n (x - 2) + n (i - 1) + 1) * (n (x - 1) + n (i - 1) + 1)) =\n       even ((n (x - 2) - (n (i - 1) - 1)) * (n (x - 1) - (n (i - 1) - 1)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. even ((n (l - 2) + n (i - 1) + 1) * (n (l - 1) + n (i - 1) + 1)) =\n    even ((n (l - 2) - (n (i - 1) - 1)) * (n (l - 1) - (n (i - 1) - 1)))", "using diff(3) [OF l] diff(3) [OF l1] l2"], ["proof (prove)\nusing this:\n  even (n (l - 1) - (n (i - 1) - 1)) = even (n (l - 1) + n (i - 1) + 1)\n  even (n (l - 1 - 1) - (n (i - 1) - 1)) =\n  even (n (l - 1 - 1) + n (i - 1) + 1)\n  l - 2 = l - 1 - 1\n\ngoal (1 subgoal):\n 1. even ((n (l - 2) + n (i - 1) + 1) * (n (l - 1) + n (i - 1) + 1)) =\n    even ((n (l - 2) - (n (i - 1) - 1)) * (n (l - 1) - (n (i - 1) - 1)))", "by auto"], ["proof (state)\nthis:\n  even ((n (l - 2) + n (i - 1) + 1) * (n (l - 1) + n (i - 1) + 1)) =\n  even ((n (l - 2) - (n (i - 1) - 1)) * (n (l - 1) - (n (i - 1) - 1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even\n   (\\<Sum>l\\<leftarrow>[3..<\n                        i]. (n (l - 2) + n (i - 1) + 1) *\n                            (n (l - 1) + n (i - 1) + 1)) =\n  even\n   (\\<Sum>l\\<leftarrow>[3..<\n                        i]. (n (l - 2) - (n (i - 1) - 1)) *\n                            (n (l - 1) - (n (i - 1) - 1)))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "also"], ["proof (state)\nthis:\n  even\n   (\\<Sum>l\\<leftarrow>[3..<\n                        i]. (n (l - 2) + n (i - 1) + 1) *\n                            (n (l - 1) + n (i - 1) + 1)) =\n  even\n   (\\<Sum>l\\<leftarrow>[3..<\n                        i]. (n (l - 2) - (n (i - 1) - 1)) *\n                            (n (l - 1) - (n (i - 1) - 1)))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "have \"even (?m' i) = even ?m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    even (\\<delta> (i - 2) + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    even (\\<delta> (i - 2) + 1)", "from i"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k", "have id: \"Suc (i - 1 - 1) = i - 1\" \"i - 2 = i - 1 - 1\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. Suc (i - 1 - 1) = i - 1 &&& i - 2 = i - 1 - 1", "by auto"], ["proof (state)\nthis:\n  Suc (i - 1 - 1) = i - 1\n  i - 2 = i - 1 - 1\n\ngoal (1 subgoal):\n 1. even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    even (\\<delta> (i - 2) + 1)", "have \"even ?m1 = even (n (i - 2) + n (i - 1) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (\\<delta> (i - 2) + 1) = even (n (i - 2) + n (i - 1) + 1)", "unfolding \\<delta> id"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (n (i - 1 - 1) - n (i - 1) + 1) =\n    even (n (i - 1 - 1) + n (i - 1) + 1)", "using diff[of \"i - 1\"] i"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> n (i - 1 - 1) - (n (i - 1) - 1) =\n                    n (i - 1 - 1) - n (i - 1) + 1\n  \\<lbrakk>2 \\<le> i - 1; i - 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> n (i - 1) \\<le> n (i - 1 - 1)\n  \\<lbrakk>2 \\<le> i - 1; i - 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> even (n (i - 1 - 1) - (n (i - 1) - 1)) =\n                    even (n (i - 1 - 1) + n (i - 1) + 1)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. even (n (i - 1 - 1) - n (i - 1) + 1) =\n    even (n (i - 1 - 1) + n (i - 1) + 1)", "by auto"], ["proof (state)\nthis:\n  even (\\<delta> (i - 2) + 1) = even (n (i - 2) + n (i - 1) + 1)\n\ngoal (1 subgoal):\n 1. even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    even (\\<delta> (i - 2) + 1)", "also"], ["proof (state)\nthis:\n  even (\\<delta> (i - 2) + 1) = even (n (i - 2) + n (i - 1) + 1)\n\ngoal (1 subgoal):\n 1. even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    even (\\<delta> (i - 2) + 1)", "have \"\\<dots> = even (?m' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (n (i - 2) + n (i - 1) + 1) =\n    even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))", "by auto"], ["proof (state)\nthis:\n  even (n (i - 2) + n (i - 1) + 1) =\n  even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))\n\ngoal (1 subgoal):\n 1. even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    even (\\<delta> (i - 2) + 1)", "finally"], ["proof (chain)\npicking this:\n  even (\\<delta> (i - 2) + 1) =\n  even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  even (\\<delta> (i - 2) + 1) =\n  even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1))\n\ngoal (1 subgoal):\n 1. even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n    even (\\<delta> (i - 2) + 1)", "by simp"], ["proof (state)\nthis:\n  even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n  even (\\<delta> (i - 2) + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n  even (\\<delta> (i - 2) + 1)\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "also"], ["proof (state)\nthis:\n  even ((n (i - 2) + n (i - 1) + 1) * (n (i - 1) + n (i - 1) + 1)) =\n  even (\\<delta> (i - 2) + 1)\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "have \"(even ?m2 = even ?m1) = even (?m2 + ?m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))) =\n     even (\\<delta> (i - 2) + 1)) =\n    even\n     ((\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))) +\n      (\\<delta> (i - 2) + 1))", "unfolding even_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (even\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))) =\n     (even (\\<delta> (i - 2)) = is_unit 2)) =\n    (even\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))) =\n     (even (\\<delta> (i - 2)) = is_unit 2))", "by simp"], ["proof (state)\nthis:\n  (even\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))) =\n   even (\\<delta> (i - 2) + 1)) =\n  even\n   ((\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))) +\n    (\\<delta> (i - 2) + 1))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "also"], ["proof (state)\nthis:\n  (even\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))) =\n   even (\\<delta> (i - 2) + 1)) =\n  even\n   ((\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))) +\n    (\\<delta> (i - 2) + 1))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "have \"?m2 + ?m1 = ?m1 + ?m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))) +\n    (\\<delta> (i - 2) + 1) =\n    \\<delta> (i - 2) + 1 +\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<\n                       i]. (n (l - 2) - (n (i - 1) - 1)) *\n                           (n (l - 1) - (n (i - 1) - 1))) +\n  (\\<delta> (i - 2) + 1) =\n  \\<delta> (i - 2) + 1 +\n  (\\<Sum>l\\<leftarrow>[3..<\n                       i]. (n (l - 2) - (n (i - 1) - 1)) *\n                           (n (l - 1) - (n (i - 1) - 1)))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "finally"], ["proof (chain)\npicking this:\n  even (\\<sigma> i) =\n  even\n   (\\<delta> (i - 2) + 1 +\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))))", "show \"even (\\<sigma> i) = even (?m1 + ?m2)\""], ["proof (prove)\nusing this:\n  even (\\<sigma> i) =\n  even\n   (\\<delta> (i - 2) + 1 +\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))))\n\ngoal (1 subgoal):\n 1. even (\\<sigma> i) =\n    even\n     (\\<delta> (i - 2) + 1 +\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))))", "."], ["proof (state)\nthis:\n  even (\\<sigma> i) =\n  even\n   (\\<delta> (i - 2) + 1 +\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - 2) - (n (i - 1) - 1)) *\n                             (n (l - 1) - (n (i - 1) - 1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^\n  (\\<delta> (i - 2) + 1 +\n   (\\<Sum>l\\<leftarrow>[3..<\n                        i]. (n (l - 2) - (n (i - 1) - 1)) *\n                            (n (l - 1) - (n (i - 1) - 1)))) *\n  (inverse (\\<alpha> i) * (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n   (\\<Prod>l\\<leftarrow>[3..<\n                         i]. (\\<beta> l / \\<alpha> l) ^\n                             (n (l - 1) - (n (i - 1) - 1))) *\n   (\\<Prod>l\\<leftarrow>[3..<\n                         i]. f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^\n  (\\<delta> (i - 2) + 1 +\n   (\\<Sum>l\\<leftarrow>[3..<\n                        i]. (n (l - 2) - (n (i - 1) - 1)) *\n                            (n (l - 1) - (n (i - 1) - 1)))) *\n  (inverse (\\<alpha> i) * (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n   (\\<Prod>l\\<leftarrow>[3..<\n                         i]. (\\<beta> l / \\<alpha> l) ^\n                             (n (l - 1) - (n (i - 1) - 1))) *\n   (\\<Prod>l\\<leftarrow>[3..<\n                         i]. f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1))))\n\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)", "unfolding id1 id3 id2 smult_smult id4"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<\n                           i]. (n (l - 2) - (n (i - 1) - 1)) *\n                               (n (l - 1) - (n (i - 1) - 1))) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. (\\<beta> l / \\<alpha> l) ^\n                                (n (l - 1) - (n (i - 1) - 1))) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n      (inverse (\\<alpha> i) *\n       ((- 1) ^ (\\<delta> (i - 2) + 1) *\n        (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i))))\n     (F i) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<delta> (i - 2) + 1 +\n       (\\<Sum>l\\<leftarrow>[3..<\n                            i]. (n (l - 2) - (n (i - 1) - 1)) *\n                                (n (l - 1) - (n (i - 1) - 1)))) *\n      (inverse (\\<alpha> i) *\n       (f (i - 1) ^ (\\<delta> (i - 2) + 1) * \\<beta> i) *\n       (\\<Prod>l\\<leftarrow>[3..<\n                             i]. (\\<beta> l / \\<alpha> l) ^\n                                 (n (l - 1) - (n (i - 1) - 1))) *\n       (\\<Prod>l\\<leftarrow>[3..<\n                             i]. f (l - 1) ^\n                                 (\\<delta> (l - 2) + \\<delta> (l - 1)))))\n     (F i)", "by (simp add: ac_simps power_add)"], ["proof (state)\nthis:\n  ffp (R (n (i - 1) - 1)) = Polynomial.smult (\\<gamma> i) (F i)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* equation 28 in BT *)"], ["", "lemma fundamental_theorem_eq_5: assumes i: \"3 \\<le> i\" \"i \\<le> k\" \"n i < j\" \"j < n (i - 1) - 1\"\n  shows \"R j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R j = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R j = 0", "from BT_lemma_2_23[OF i]"], ["proof (chain)\npicking this:\n  subresultant j (F (i - 2)) (F (i - 1)) = 0", "have id1: \"subresultant j (F (i - 2)) (F (i - 1)) = 0\""], ["proof (prove)\nusing this:\n  subresultant j (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. subresultant j (F (i - 2)) (F (i - 1)) = 0", "."], ["proof (state)\nthis:\n  subresultant j (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. R j = 0", "have \"n (i - 1) \\<le> n 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (i - 1) \\<le> n 2", "by (rule n_ge_trans, insert i, auto)"], ["proof (state)\nthis:\n  n (i - 1) \\<le> n 2\n\ngoal (1 subgoal):\n 1. R j = 0", "with n_gt[of \"i - 1\"] i"], ["proof (chain)\npicking this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k\n  n i < j\n  j < n (i - 1) - 1\n  n (i - 1) \\<le> n 2", "have \"n (i - 1) - 1 < n 2\"\n    and lt: \"j < n (i - 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  3 \\<le> i\n  i \\<le> k\n  n i < j\n  j < n (i - 1) - 1\n  n (i - 1) \\<le> n 2\n\ngoal (1 subgoal):\n 1. n (i - 1) - 1 < n 2 &&& j < n (i - 1)", "by linarith+"], ["proof (state)\nthis:\n  n (i - 1) - 1 < n 2\n  j < n (i - 1)\n\ngoal (1 subgoal):\n 1. R j = 0", "with i"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k\n  n i < j\n  j < n (i - 1) - 1\n  n (i - 1) - 1 < n 2\n  j < n (i - 1)", "have \"R j = subresultant j G1 G2\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  n i < j\n  j < n (i - 1) - 1\n  n (i - 1) - 1 < n 2\n  j < n (i - 1)\n\ngoal (1 subgoal):\n 1. R j = subresultant j G1 G2", "unfolding R_def"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  n i < j\n  j < n (i - 1) - 1\n  n (i - 1) - 1 < n 2\n  j < n (i - 1)\n\ngoal (1 subgoal):\n 1. (if j = n 2\n     then sdiv_poly (Polynomial.smult (lead_coeff G2 ^ \\<delta> 1) G2)\n           (lead_coeff G2)\n     else subresultant j G1 G2) =\n    subresultant j G1 G2", "by auto"], ["proof (state)\nthis:\n  R j = subresultant j G1 G2\n\ngoal (1 subgoal):\n 1. R j = 0", "from arg_cong[OF this, of ffp, unfolded to_fract_hom.subresultant_hom, folded F1 F2]"], ["proof (chain)\npicking this:\n  ffp (R j) = subresultant j (F 1) (F 2)", "have id2: \"ffp (R j) = subresultant j (F 1) (F 2)\""], ["proof (prove)\nusing this:\n  ffp (R j) = subresultant j (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. ffp (R j) = subresultant j (F 1) (F 2)", "."], ["proof (state)\nthis:\n  ffp (R j) = subresultant j (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. R j = 0", "from i"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k\n  n i < j\n  j < n (i - 1) - 1", "have \"3 \\<le> i\" \"i \\<le> k + 1\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  n i < j\n  j < n (i - 1) - 1\n\ngoal (1 subgoal):\n 1. 3 \\<le> i &&& i \\<le> k + 1", "by auto"], ["proof (state)\nthis:\n  3 \\<le> i\n  i \\<le> k + 1\n\ngoal (1 subgoal):\n 1. R j = 0", "note eq_30 = BT_eq_30[OF this lt]"], ["proof (state)\nthis:\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n   (subresultant j (F 1) (F 2)) =\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<\n                         i]. \\<beta> l ^ (n (l - 1) - j) *\n                             f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                             (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. R j = 0", "let ?c3 = \"\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. R j = 0", "let ?c2 = \"\\<Prod>l\\<leftarrow>[3..<i]. \\<beta> l ^ (n (l - 1) - j) * f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                  (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. R j = 0", "have \"?c3 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0", "by (rule nonzero_alphaprod, insert i, auto)"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R j = 0", "with arg_cong[OF eq_30, of \"smult (inverse ?c3)\"]"], ["proof (chain)\npicking this:\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)))\n   (Polynomial.smult\n     (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n     (subresultant j (F 1) (F 2))) =\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)))\n   (Polynomial.smult\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. \\<beta> l ^ (n (l - 1) - j) *\n                               f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                               (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n     (subresultant j (F (i - 2)) (F (i - 1))))\n  (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0", "have id3: \"subresultant j (F 1) (F 2) = smult (inverse ?c3 * ?c2)\n     (subresultant j (F (i - 2)) (F (i - 1)))\""], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)))\n   (Polynomial.smult\n     (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j))\n     (subresultant j (F 1) (F 2))) =\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)))\n   (Polynomial.smult\n     (\\<Prod>l\\<leftarrow>[3..<\n                           i]. \\<beta> l ^ (n (l - 1) - j) *\n                               f (l - 1) ^\n                               (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                               (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n     (subresultant j (F (i - 2)) (F (i - 1))))\n  (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant j (F 1) (F 2) =\n    Polynomial.smult\n     (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. \\<beta> l ^ (n (l - 1) - j) *\n                                f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                                (- 1) ^\n                                ((n (l - 2) - j) * (n (l - 1) - j))))\n     (subresultant j (F (i - 2)) (F (i - 1)))", "by (auto intro: poly_eqI)"], ["proof (state)\nthis:\n  subresultant j (F 1) (F 2) =\n  Polynomial.smult\n   (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          i]. \\<beta> l ^ (n (l - 1) - j) *\n                              f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                              (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j))))\n   (subresultant j (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. R j = 0", "have \"ffp (R j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffp (R j) = 0", "unfolding id1 id2 id3"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (inverse (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l ^ (n (l - 1) - j)) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            i]. \\<beta> l ^ (n (l - 1) - j) *\n                                f (l - 1) ^\n                                (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                                (- 1) ^\n                                ((n (l - 2) - j) * (n (l - 1) - j))))\n     0 =\n    0", "by simp"], ["proof (state)\nthis:\n  ffp (R j) = 0\n\ngoal (1 subgoal):\n 1. R j = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ffp (R j) = 0\n\ngoal (1 subgoal):\n 1. R j = 0", "by simp"], ["proof (state)\nthis:\n  R j = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(* equation 27 in BT *)"], ["", "lemma fundamental_theorem_eq_6: assumes \"3 \\<le> i\" \"i \\<le> k\" shows \"ffp (R (n i)) = smult (\\<Theta> i) (F i)\"\n  (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "from assms"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k", "have i1:\"1 \\<le> i\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. 1 \\<le> i", "by auto"], ["proof (state)\nthis:\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "from assms"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k", "have nlt:\"i \\<le> k + 1\" \"n i < n (i - 1)\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. i \\<le> k + 1 &&& n i < n (i - 1)", "using n_gt[of \"i - 1\"]"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  \\<lbrakk>2 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<le> k + 1 &&& n i < n (i - 1)", "by auto"], ["proof (state)\nthis:\n  i \\<le> k + 1\n  n i < n (i - 1)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "from assms"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k", "have \\<alpha>nz:\"\\<alpha> i ^ \\<delta> (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<alpha> i ^ \\<delta> (i - 1) \\<noteq> 0", "using \\<alpha>0"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  1 < ?i \\<Longrightarrow> (\\<alpha> ?i = 0) = (k < ?i - 1)\n\ngoal (1 subgoal):\n 1. \\<alpha> i ^ \\<delta> (i - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> i ^ \\<delta> (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have *:\"\\<And> a f b. a \\<noteq> 0 \\<Longrightarrow> smult a f = b \\<Longrightarrow> f = smult (inverse (a::'a fract)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a f b.\n       \\<lbrakk>a \\<noteq> 0; Polynomial.smult a f = b\\<rbrakk>\n       \\<Longrightarrow> f = Polynomial.smult (inverse a) b", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a1 \\<noteq> 0; Polynomial.smult ?a1 ?f1 = ?b1\\<rbrakk>\n  \\<Longrightarrow> ?f1 = Polynomial.smult (inverse ?a1) ?b1\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have **:\"\\<And> f g xs c. c * prod_list (map f xs) * prod_list (map g xs)\n         = c * (\\<Prod>x\\<leftarrow>xs. f x * (g:: _ \\<Rightarrow> (_ :: comm_monoid_mult)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g xs c.\n       c * prod_list (map f xs) * prod_list (map g xs) =\n       c * (\\<Prod>x\\<leftarrow>xs. f x * g x)", "by (auto simp:ac_simps prod_list_multf)"], ["proof (state)\nthis:\n  ?c1 * prod_list (map ?f1 ?xs1) * prod_list (map ?g1 ?xs1) =\n  ?c1 * (\\<Prod>x\\<leftarrow>?xs1. ?f1 x * ?g1 x)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have ***:\"\\<And> c. \\<beta> i ^ \\<delta> (i - Suc 0) * (inverse (\\<alpha> i ^ \\<delta> (i - Suc 0)) * c) = (\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<beta> i ^ \\<delta> (i - Suc 0) *\n       (inverse (\\<alpha> i ^ \\<delta> (i - Suc 0)) * c) =\n       (\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) * c", "by (auto simp:inverse_eq_divide power_divide)"], ["proof (state)\nthis:\n  \\<beta> i ^ \\<delta> (i - Suc 0) *\n  (inverse (\\<alpha> i ^ \\<delta> (i - Suc 0)) * ?c2) =\n  (\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) * ?c2\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have ****:\"int (n (i - Suc 0) - n i) - 1 = int (n (i - 1) - Suc (n i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n (i - Suc 0) - n i) - 1 = int (n (i - 1) - Suc (n i))", "using assms nlt"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  i \\<le> k + 1\n  n i < n (i - 1)\n\ngoal (1 subgoal):\n 1. int (n (i - Suc 0) - n i) - 1 = int (n (i - 1) - Suc (n i))", "by auto"], ["proof (state)\nthis:\n  int (n (i - Suc 0) - n i) - 1 = int (n (i - 1) - Suc (n i))\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "from assms n_ge[of \"i-2\"] nlt n_ge[of i]"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k\n  \\<lbrakk>1 \\<le> i - 2; i - 2 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 2)) \\<le> n (i - 2)\n  i \\<le> k + 1\n  n i < n (i - 1)\n  \\<lbrakk>1 \\<le> i; i < k\\<rbrakk> \\<Longrightarrow> n (Suc i) \\<le> n i", "have nge:\"n (i - Suc 0) \\<le> n (i - 2)\" \"n i < n (i - Suc 0)\" \"n i < n (i - 1)\" \"Suc (i - 2) = i - 1\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  \\<lbrakk>1 \\<le> i - 2; i - 2 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 2)) \\<le> n (i - 2)\n  i \\<le> k + 1\n  n i < n (i - 1)\n  \\<lbrakk>1 \\<le> i; i < k\\<rbrakk> \\<Longrightarrow> n (Suc i) \\<le> n i\n\ngoal (1 subgoal):\n 1. (n (i - Suc 0) \\<le> n (i - 2) &&& n i < n (i - Suc 0)) &&&\n    n i < n (i - 1) &&& Suc (i - 2) = i - 1", "by (cases i,auto simp:numeral_2_eq_2 numeral_3_eq_3)"], ["proof (state)\nthis:\n  n (i - Suc 0) \\<le> n (i - 2)\n  n i < n (i - Suc 0)\n  n i < n (i - 1)\n  Suc (i - 2) = i - 1\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have *****:\"(- 1 ::  'a fract) ^ ((n (i - Suc 0) - n i) * (n (i - Suc 0) - n i + (n (i - 2) - n (Suc (i - 2)))))\n       = (- 1) ^ ((n i + n (i - Suc 0)) * (n i + n (i - 2)))\"\n       \"(- 1 ::  'a fract) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - Suc 0) - n i) * (n (l - 2) - n i))\n       = (- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n i + n (l - Suc 0)) * (n i + n (l - 2))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^\n    ((n (i - Suc 0) - n i) *\n     (n (i - Suc 0) - n i + (n (i - 2) - n (Suc (i - 2))))) =\n    (- 1) ^ ((n i + n (i - Suc 0)) * (n i + n (i - 2))) &&&\n    (- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - Suc 0) - n i) * (n (l - 2) - n i)) =\n    (- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<i]. (n i + n (l - Suc 0)) * (n i + n (l - 2)))", "using nge"], ["proof (prove)\nusing this:\n  n (i - Suc 0) \\<le> n (i - 2)\n  n i < n (i - Suc 0)\n  n i < n (i - 1)\n  Suc (i - 2) = i - 1\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    ((n (i - Suc 0) - n i) *\n     (n (i - Suc 0) - n i + (n (i - 2) - n (Suc (i - 2))))) =\n    (- 1) ^ ((n i + n (i - Suc 0)) * (n i + n (i - 2))) &&&\n    (- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<\n                         i]. (n (l - Suc 0) - n i) * (n (l - 2) - n i)) =\n    (- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<i]. (n i + n (l - Suc 0)) * (n i + n (l - 2)))", "apply (intro minus_1_even_eqI,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n (i - Suc 0) \\<le> n (i - 2); n i < n (i - Suc 0);\n     Suc (i - 2) = i - Suc 0\\<rbrakk>\n    \\<Longrightarrow> (- 1) ^\n                      (\\<Sum>l\\<leftarrow>[3..<\n     i]. (n (l - Suc 0) - n i) * (n (l - 2) - n i)) =\n                      (- 1) ^\n                      (\\<Sum>l\\<leftarrow>[3..<\n     i]. (n i + n (l - Suc 0)) * (n i + n (l - 2)))", "apply (intro minus_1_even_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n (i - Suc 0) \\<le> n (i - 2); n i < n (i - Suc 0);\n     Suc (i - 2) = i - Suc 0\\<rbrakk>\n    \\<Longrightarrow> even\n                       (\\<Sum>l\\<leftarrow>[3..<\n      i]. (n (l - Suc 0) - n i) * (n (l - 2) - n i)) =\n                      even\n                       (\\<Sum>l\\<leftarrow>[3..<\n      i]. (n i + n (l - Suc 0)) * (n i + n (l - 2)))", "apply (intro even_sum_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n (i - Suc 0) \\<le> n (i - 2); n i < n (i - Suc 0);\n        Suc (i - 2) = i - Suc 0; x \\<in> set [3..<i]\\<rbrakk>\n       \\<Longrightarrow> even ((n (x - Suc 0) - n i) * (n (x - 2) - n i)) =\n                         even ((n i + n (x - Suc 0)) * (n i + n (x - 2)))", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n (i - Suc 0) \\<le> n (i - 2); n i < n (i - Suc 0);\n        Suc (i - 2) = i - Suc 0; x \\<in> set [3..<i]\\<rbrakk>\n       \\<Longrightarrow> even ((n (x - Suc 0) - n i) * (n (x - 2) - n i)) =\n                         even ((n i + n (x - Suc 0)) * (n i + n (x - 2)))", "case (1 x)"], ["proof (state)\nthis:\n  n (i - Suc 0) \\<le> n (i - 2)\n  n i < n (i - Suc 0)\n  Suc (i - 2) = i - Suc 0\n  x \\<in> set [3..<i]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n (i - Suc 0) \\<le> n (i - 2); n i < n (i - Suc 0);\n        Suc (i - 2) = i - Suc 0; x \\<in> set [3..<i]\\<rbrakk>\n       \\<Longrightarrow> even ((n (x - Suc 0) - n i) * (n (x - 2) - n i)) =\n                         even ((n i + n (x - Suc 0)) * (n i + n (x - 2)))", "with n_ge_trans assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 \\<le> ?i; ?i \\<le> ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> n ?j \\<le> n ?i\n  3 \\<le> i\n  i \\<le> k\n  n (i - Suc 0) \\<le> n (i - 2)\n  n i < n (i - Suc 0)\n  Suc (i - 2) = i - Suc 0\n  x \\<in> set [3..<i]", "have \"n i \\<le> n (x - Suc 0)\" \"n (x - 2) \\<ge> n i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> ?i; ?i \\<le> ?j; ?j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> n ?j \\<le> n ?i\n  3 \\<le> i\n  i \\<le> k\n  n (i - Suc 0) \\<le> n (i - 2)\n  n i < n (i - Suc 0)\n  Suc (i - 2) = i - Suc 0\n  x \\<in> set [3..<i]\n\ngoal (1 subgoal):\n 1. n i \\<le> n (x - Suc 0) &&& n i \\<le> n (x - 2)", "by auto"], ["proof (state)\nthis:\n  n i \\<le> n (x - Suc 0)\n  n i \\<le> n (x - 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n (i - Suc 0) \\<le> n (i - 2); n i < n (i - Suc 0);\n        Suc (i - 2) = i - Suc 0; x \\<in> set [3..<i]\\<rbrakk>\n       \\<Longrightarrow> even ((n (x - Suc 0) - n i) * (n (x - 2) - n i)) =\n                         even ((n i + n (x - Suc 0)) * (n i + n (x - 2)))", "with 1"], ["proof (chain)\npicking this:\n  n (i - Suc 0) \\<le> n (i - 2)\n  n i < n (i - Suc 0)\n  Suc (i - 2) = i - Suc 0\n  x \\<in> set [3..<i]\n  n i \\<le> n (x - Suc 0)\n  n i \\<le> n (x - 2)", "show ?case"], ["proof (prove)\nusing this:\n  n (i - Suc 0) \\<le> n (i - 2)\n  n i < n (i - Suc 0)\n  Suc (i - 2) = i - Suc 0\n  x \\<in> set [3..<i]\n  n i \\<le> n (x - Suc 0)\n  n i \\<le> n (x - 2)\n\ngoal (1 subgoal):\n 1. even ((n (x - Suc 0) - n i) * (n (x - 2) - n i)) =\n    even ((n i + n (x - Suc 0)) * (n i + n (x - 2)))", "by auto"], ["proof (state)\nthis:\n  even ((n (x - Suc 0) - n i) * (n (x - 2) - n i)) =\n  even ((n i + n (x - Suc 0)) * (n i + n (x - 2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (- 1) ^\n  ((n (i - Suc 0) - n i) *\n   (n (i - Suc 0) - n i + (n (i - 2) - n (Suc (i - 2))))) =\n  (- 1) ^ ((n i + n (i - Suc 0)) * (n i + n (i - 2)))\n  (- 1) ^\n  (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - Suc 0) - n i) * (n (l - 2) - n i)) =\n  (- 1) ^\n  (\\<Sum>l\\<leftarrow>[3..<i]. (n i + n (l - Suc 0)) * (n i + n (l - 2)))\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have \"ffp (R (n i)) = subresultant (n i) (F 1) (F 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffp (R (n i)) = subresultant (n i) (F 1) (F 2)", "unfolding R_def F1 F2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffp (if n i = n 2\n         then sdiv_poly (Polynomial.smult (lead_coeff G2 ^ \\<delta> 1) G2)\n               (lead_coeff G2)\n         else subresultant (n i) G1 G2) =\n    subresultant (n i) (ffp G1) (ffp G2)", "by (auto simp: to_fract_hom.subresultant_hom ni2[OF assms])"], ["proof (state)\nthis:\n  ffp (R (n i)) = subresultant (n i) (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "also"], ["proof (state)\nthis:\n  ffp (R (n i)) = subresultant (n i) (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have \"\\<dots> = smult\n     ((- 1) ^ (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n      (\\<Prod>x\\<leftarrow>[3..<i]. (\\<beta> x / \\<alpha> x) ^ (n (x - 1) - n i) * f (x - 1) ^ (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n      (((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1)) * f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n       ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) * f i ^ (\\<delta> (i - 1) - 1)\n        ))\n     (F i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant (n i) (F 1) (F 2) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n      (\\<Prod>x\\<leftarrow>[3..<\n                            i]. (\\<beta> x / \\<alpha> x) ^\n                                (n (x - 1) - n i) *\n                                f (x - 1) ^\n                                (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n      ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n       f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n      ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n       f i ^ (\\<delta> (i - 1) - 1)))\n     (F i)", "unfolding BT_eq_30'[OF assms(1) nlt] **\n              *[OF \\<alpha>nz BT_lemma_2_22[OF assms]] smult_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n      (\\<Prod>x\\<leftarrow>[3..<\n                            i]. (\\<beta> x / \\<alpha> x) ^\n                                (n (x - 1) - n i) *\n                                f (x - 1) ^\n                                (\\<delta> (x - 2) + \\<delta> (x - 1))) *\n      (inverse (\\<alpha> i ^ \\<delta> (i - 1)) *\n       ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n        f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1)) *\n        f i ^ (\\<delta> (i - 1) - 1) *\n        \\<beta> i ^ \\<delta> (i - 1))))\n     (F i) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n      (\\<Prod>x\\<leftarrow>[3..<\n                            i]. (\\<beta> x / \\<alpha> x) ^\n                                (n (x - 1) - n i) *\n                                f (x - 1) ^\n                                (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n      ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n       f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n      ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n       f i ^ (\\<delta> (i - 1) - 1)))\n     (F i)", "by (auto simp:ac_simps *** )"], ["proof (state)\nthis:\n  subresultant (n i) (F 1) (F 2) =\n  Polynomial.smult\n   ((- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n    (\\<Prod>x\\<leftarrow>[3..<\n                          i]. (\\<beta> x / \\<alpha> x) ^ (n (x - 1) - n i) *\n                              f (x - 1) ^\n                              (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n    ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n     f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n    ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n     f i ^ (\\<delta> (i - 1) - 1)))\n   (F i)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "also"], ["proof (state)\nthis:\n  subresultant (n i) (F 1) (F 2) =\n  Polynomial.smult\n   ((- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n    (\\<Prod>x\\<leftarrow>[3..<\n                          i]. (\\<beta> x / \\<alpha> x) ^ (n (x - 1) - n i) *\n                              f (x - 1) ^\n                              (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n    ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n     f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n    ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n     f i ^ (\\<delta> (i - 1) - 1)))\n   (F i)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n      (\\<Prod>x\\<leftarrow>[3..<\n                            i]. (\\<beta> x / \\<alpha> x) ^\n                                (n (x - 1) - n i) *\n                                f (x - 1) ^\n                                (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n      ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n       f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n      ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n       f i ^ (\\<delta> (i - 1) - 1)))\n     (F i) =\n    Polynomial.smult (\\<Theta> i) (F i)", "unfolding \\<Theta>_def \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n      (\\<Prod>x\\<leftarrow>[3..<\n                            i]. (\\<beta> x / \\<alpha> x) ^\n                                (n (x - 1) - n i) *\n                                f (x - 1) ^\n                                (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n      ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n       f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n      ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n       f i ^ (\\<delta> (i - 1) - 1)))\n     (F i) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<\n                           Suc i]. (n (l - 2) + n i) * (n (l - 1) + n i)) *\n      pow_int (f i) (int (\\<delta> (i - 1)) - 1) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                    (n (l - 1) - n i) *\n                                    f (l - 1) ^\n                                    (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (F i)", "using prod_combine[OF assms(1)] \\<delta> assms"], ["proof (prove)\nusing this:\n  ?f i * prod_list (map ?f [3..<i]) = prod_list (map ?f [3..<Suc i])\n  \\<delta> ?i = n ?i - n (Suc ?i)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n      (\\<Prod>x\\<leftarrow>[3..<\n                            i]. (\\<beta> x / \\<alpha> x) ^\n                                (n (x - 1) - n i) *\n                                f (x - 1) ^\n                                (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n      ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n       f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n      ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n       f i ^ (\\<delta> (i - 1) - 1)))\n     (F i) =\n    Polynomial.smult\n     ((- 1) ^\n      (\\<Sum>l\\<leftarrow>[3..<\n                           Suc i]. (n (l - 2) + n i) * (n (l - 1) + n i)) *\n      pow_int (f i) (int (\\<delta> (i - 1)) - 1) *\n      (\\<Prod>l\\<leftarrow>[3..<\n                            Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                    (n (l - 1) - n i) *\n                                    f (l - 1) ^\n                                    (\\<delta> (l - 2) + \\<delta> (l - 1))))\n     (F i)", "by (auto simp:ac_simps exp_pow_int[symmetric] power_add ***** ****)"], ["proof (state)\nthis:\n  Polynomial.smult\n   ((- 1) ^\n    (\\<Sum>l\\<leftarrow>[3..<i]. (n (l - 2) - n i) * (n (l - 1) - n i)) *\n    (\\<Prod>x\\<leftarrow>[3..<\n                          i]. (\\<beta> x / \\<alpha> x) ^ (n (x - 1) - n i) *\n                              f (x - 1) ^\n                              (\\<delta> (x - 1) + \\<delta> (x - 2))) *\n    ((\\<beta> i / \\<alpha> i) ^ \\<delta> (i - 1) *\n     f (i - 1) ^ (\\<delta> (i - 1) + \\<delta> (i - 2))) *\n    ((- 1) ^ ((\\<delta> (i - 2) + \\<delta> (i - 1)) * \\<delta> (i - 1)) *\n     f i ^ (\\<delta> (i - 1) - 1)))\n   (F i) =\n  Polynomial.smult (\\<Theta> i) (F i)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "finally"], ["proof (chain)\npicking this:\n  ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "show ?thesis"], ["proof (prove)\nusing this:\n  ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)\n\ngoal (1 subgoal):\n 1. ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)", "."], ["proof (state)\nthis:\n  ffp (R (n i)) = Polynomial.smult (\\<Theta> i) (F i)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* equation 26 in BT *)"], ["", "lemma fundamental_theorem_eq_7: assumes j: \"j < n k\" shows \"R j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R j = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R j = 0", "let ?P = \"pseudo_divmod (F (k - 1)) (F k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. R j = 0", "from F0[of k] k2"], ["proof (chain)\npicking this:\n  k \\<noteq> 0 \\<Longrightarrow> (F k = 0) = (k < k)\n  2 \\<le> k", "have Fk: \"F k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0 \\<Longrightarrow> (F k = 0) = (k < k)\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. F k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R j = 0", "from pmod[of \"Suc k\"] k2 F0[of \"Suc k\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>3 \\<le> Suc k; Suc k \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> (Suc k)) (F (Suc k)) =\n                    pseudo_mod (F (Suc k - 2)) (F (Suc k - 1))\n  2 \\<le> k\n  Suc k \\<noteq> 0 \\<Longrightarrow> (F (Suc k) = 0) = (k < Suc k)", "have \"pseudo_mod (F (k - 1)) (F k) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> Suc k; Suc k \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> (Suc k)) (F (Suc k)) =\n                    pseudo_mod (F (Suc k - 2)) (F (Suc k - 1))\n  2 \\<le> k\n  Suc k \\<noteq> 0 \\<Longrightarrow> (F (Suc k) = 0) = (k < Suc k)\n\ngoal (1 subgoal):\n 1. pseudo_mod (F (k - 1)) (F k) = 0", "by auto"], ["proof (state)\nthis:\n  pseudo_mod (F (k - 1)) (F k) = 0\n\ngoal (1 subgoal):\n 1. R j = 0", "then"], ["proof (chain)\npicking this:\n  pseudo_mod (F (k - 1)) (F k) = 0", "obtain Q where \"?P = (Q,0)\""], ["proof (prove)\nusing this:\n  pseudo_mod (F (k - 1)) (F k) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        pseudo_divmod (F (k - 1)) (F k) = (Q, 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding pseudo_mod_def"], ["proof (prove)\nusing this:\n  snd (pseudo_divmod (F (k - 1)) (F k)) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        pseudo_divmod (F (k - 1)) (F k) = (Q, 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?P, auto)"], ["proof (state)\nthis:\n  pseudo_divmod (F (k - 1)) (F k) = (Q, 0)\n\ngoal (1 subgoal):\n 1. R j = 0", "from pseudo_divmod(1)[OF Fk this] Fk"], ["proof (chain)\npicking this:\n  Polynomial.smult\n   (lead_coeff (F k) ^ (Suc (degree (F (k - 1))) - degree (F k)))\n   (F (k - 1)) =\n  F k * Q + 0\n  F k \\<noteq> 0", "obtain c where id: \"smult c (F (k - 1)) = F k * Q\"\n    and c: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (lead_coeff (F k) ^ (Suc (degree (F (k - 1))) - degree (F k)))\n   (F (k - 1)) =\n  F k * Q + 0\n  F k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>Polynomial.smult c (F (k - 1)) = F k * Q;\n         c \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult c (F (k - 1)) = F k * Q\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R j = 0", "from id"], ["proof (chain)\npicking this:\n  Polynomial.smult c (F (k - 1)) = F k * Q", "have id: \"smult c (F (k - 1)) = Q * F k\""], ["proof (prove)\nusing this:\n  Polynomial.smult c (F (k - 1)) = F k * Q\n\ngoal (1 subgoal):\n 1. Polynomial.smult c (F (k - 1)) = Q * F k", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult c (F (k - 1)) = Q * F k\n\ngoal (1 subgoal):\n 1. R j = 0", "from n_ge[unfolded n, of \"k - 1\"] k2 c"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 \\<le> k - 1; k - 1 < k\\<rbrakk>\n  \\<Longrightarrow> degree (F (Suc (k - 1))) \\<le> degree (F (k - 1))\n  2 \\<le> k\n  c \\<noteq> 0", "have \"degree (F k) \\<le> degree (smult c (F (k - 1)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> k - 1; k - 1 < k\\<rbrakk>\n  \\<Longrightarrow> degree (F (Suc (k - 1))) \\<le> degree (F (k - 1))\n  2 \\<le> k\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (F k) \\<le> degree (Polynomial.smult c (F (k - 1)))", "by auto"], ["proof (state)\nthis:\n  degree (F k) \\<le> degree (Polynomial.smult c (F (k - 1)))\n\ngoal (1 subgoal):\n 1. R j = 0", "from subresultant_product[OF id this, unfolded subresultant_smult_left[OF c], of j] j"], ["proof (chain)\npicking this:\n  Polynomial.smult (c ^ (degree (F k) - j))\n   (subresultant j (F (k - 1)) (F k)) =\n  (if j < degree (F k) then 0\n   else if j < degree (Polynomial.smult c (F (k - 1)))\n        then Polynomial.smult\n              (lead_coeff (F k) ^\n               (degree (Polynomial.smult c (F (k - 1))) - j - 1))\n              (F k)\n        else 1)\n  j < n k", "have *:\"subresultant j (F (k + 1 - 2)) (F (k + 1 - 1)) = 0\""], ["proof (prove)\nusing this:\n  Polynomial.smult (c ^ (degree (F k) - j))\n   (subresultant j (F (k - 1)) (F k)) =\n  (if j < degree (F k) then 0\n   else if j < degree (Polynomial.smult c (F (k - 1)))\n        then Polynomial.smult\n              (lead_coeff (F k) ^\n               (degree (Polynomial.smult c (F (k - 1))) - j - 1))\n              (F k)\n        else 1)\n  j < n k\n\ngoal (1 subgoal):\n 1. subresultant j (F (k + 1 - 2)) (F (k + 1 - 1)) = 0", "using c"], ["proof (prove)\nusing this:\n  Polynomial.smult (c ^ (degree (F k) - j))\n   (subresultant j (F (k - 1)) (F k)) =\n  (if j < degree (F k) then 0\n   else if j < degree (Polynomial.smult c (F (k - 1)))\n        then Polynomial.smult\n              (lead_coeff (F k) ^\n               (degree (Polynomial.smult c (F (k - 1))) - j - 1))\n              (F k)\n        else 1)\n  j < n k\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant j (F (k + 1 - 2)) (F (k + 1 - 1)) = 0", "unfolding n"], ["proof (prove)\nusing this:\n  Polynomial.smult (c ^ (degree (F k) - j))\n   (subresultant j (F (k - 1)) (F k)) =\n  (if j < degree (F k) then 0\n   else if j < degree (Polynomial.smult c (F (k - 1)))\n        then Polynomial.smult\n              (lead_coeff (F k) ^\n               (degree (Polynomial.smult c (F (k - 1))) - j - 1))\n              (F k)\n        else 1)\n  j < degree (F k)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant j (F (k + 1 - 2)) (F (k + 1 - 1)) = 0", "by simp"], ["proof (state)\nthis:\n  subresultant j (F (k + 1 - 2)) (F (k + 1 - 1)) = 0\n\ngoal (1 subgoal):\n 1. R j = 0", "from assms"], ["proof (chain)\npicking this:\n  j < n k", "have **:\"j \\<noteq> n 2\""], ["proof (prove)\nusing this:\n  j < n k\n\ngoal (1 subgoal):\n 1. j \\<noteq> n 2", "by (meson k2 n_ge_trans not_le one_le_numeral order_refl)"], ["proof (state)\nthis:\n  j \\<noteq> n 2\n\ngoal (1 subgoal):\n 1. R j = 0", "from k2 assms"], ["proof (chain)\npicking this:\n  2 \\<le> k\n  j < n k", "have \"3 \\<le> k + 1\" \"k + 1 \\<le> k + 1\" \"j < n (k + 1 - 1)\""], ["proof (prove)\nusing this:\n  2 \\<le> k\n  j < n k\n\ngoal (1 subgoal):\n 1. 3 \\<le> k + 1 &&& k + 1 \\<le> k + 1 &&& j < n (k + 1 - 1)", "by auto"], ["proof (state)\nthis:\n  3 \\<le> k + 1\n  k + 1 \\<le> k + 1\n  j < n (k + 1 - 1)\n\ngoal (1 subgoal):\n 1. R j = 0", "from BT_eq_30[OF this,unfolded *] nonzero_alphaprod[OF le_refl] ** F1 F2"], ["proof (chain)\npicking this:\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<k + 1]. \\<alpha> l ^ (n (l - 1) - j))\n   (subresultant j (F 1) (F 2)) =\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<\n                         k +\n                         1]. \\<beta> l ^ (n (l - 1) - j) *\n                             f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                             (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n   0\n  (\\<Prod>l\\<leftarrow>[3..<k + 1]. \\<alpha> l ^ ?p l) \\<noteq> 0\n  j \\<noteq> n 2\n  F 1 = ffp G1\n  F 2 = ffp G2", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<k + 1]. \\<alpha> l ^ (n (l - 1) - j))\n   (subresultant j (F 1) (F 2)) =\n  Polynomial.smult\n   (\\<Prod>l\\<leftarrow>[3..<\n                         k +\n                         1]. \\<beta> l ^ (n (l - 1) - j) *\n                             f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1)) *\n                             (- 1) ^ ((n (l - 2) - j) * (n (l - 1) - j)))\n   0\n  (\\<Prod>l\\<leftarrow>[3..<k + 1]. \\<alpha> l ^ ?p l) \\<noteq> 0\n  j \\<noteq> n 2\n  F 1 = ffp G1\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. R j = 0", "by (auto simp:R_def F0 to_fract_hom.subresultant_hom[symmetric])"], ["proof (state)\nthis:\n  R j = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"G i = R (n (i - 1) - 1)\""], ["", "definition \"H i = R (n i)\""], ["", "lemma gamma_delta_beta_3: \"\\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"\\<gamma> 3 = (- 1) ^ \\<sigma> 3 * pow_int (f 2) (1 - int (\\<delta> 2)) *\n    (\\<beta> 3 / (f 2 ^ Suc (\\<delta> 1)) * f 2 ^ (\\<delta> 1 + \\<delta> 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> 3 =\n    (- 1) ^ \\<sigma> 3 * pow_int (f 2) (1 - int (\\<delta> 2)) *\n    (\\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ (\\<delta> 1 + \\<delta> 2))", "unfolding \\<gamma>_def \\<delta> \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> 3 *\n    pow_int (f (3 - 1)) (1 - int (n (3 - 1) - n (Suc (3 - 1)))) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc 3]. (\\<beta> l /\n                                   f (l - 1) ^\n                                   Suc (n (l - 2) - n (Suc (l - 2)))) ^\n                                  (n (l - 1) - n (3 - 1) + 1) *\n                                  f (l - 1) ^\n                                  (n (l - 2) - n (Suc (l - 2)) +\n                                   (n (l - 1) - n (Suc (l - 1))))) =\n    (- 1) ^ \\<sigma> 3 * pow_int (f 2) (1 - int (n 2 - n (Suc 2))) *\n    (\\<beta> 3 / f 2 ^ Suc (n 1 - n (Suc 1)) *\n     f 2 ^ (n 1 - n (Suc 1) + (n 2 - n (Suc 2))))", "by (simp add: \\<delta>)"], ["proof (state)\nthis:\n  \\<gamma> 3 =\n  (- 1) ^ \\<sigma> 3 * pow_int (f 2) (1 - int (\\<delta> 2)) *\n  (\\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ (\\<delta> 1 + \\<delta> 2))\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  \\<gamma> 3 =\n  (- 1) ^ \\<sigma> 3 * pow_int (f 2) (1 - int (\\<delta> 2)) *\n  (\\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ (\\<delta> 1 + \\<delta> 2))\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"f 2 ^ (\\<delta> 1 + \\<delta> 2) = pow_int (f 2) (int (\\<delta> 1 + \\<delta> 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 2 ^ (\\<delta> 1 + \\<delta> 2) =\n    pow_int (f 2) (int (\\<delta> 1 + \\<delta> 2))", "unfolding pow_int_def nat_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. f 2 ^ (\\<delta> 1 + \\<delta> 2) =\n    (if int (\\<delta> 1 + \\<delta> 2) < 0\n     then 1 / f 2 ^ nat (- int (\\<delta> 1 + \\<delta> 2))\n     else f 2 ^ (\\<delta> 1 + \\<delta> 2))", "by auto"], ["proof (state)\nthis:\n  f 2 ^ (\\<delta> 1 + \\<delta> 2) =\n  pow_int (f 2) (int (\\<delta> 1 + \\<delta> 2))\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  f 2 ^ (\\<delta> 1 + \\<delta> 2) =\n  pow_int (f 2) (int (\\<delta> 1 + \\<delta> 2))\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"int (\\<delta> 1 + \\<delta> 2) = int (Suc (\\<delta> 1)) + (int (\\<delta> 2) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<delta> 1 + \\<delta> 2) =\n    int (Suc (\\<delta> 1)) + (int (\\<delta> 2) - 1)", "by simp"], ["proof (state)\nthis:\n  int (\\<delta> 1 + \\<delta> 2) =\n  int (Suc (\\<delta> 1)) + (int (\\<delta> 2) - 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  int (\\<delta> 1 + \\<delta> 2) =\n  int (Suc (\\<delta> 1)) + (int (\\<delta> 2) - 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"pow_int (f 2) \\<dots> = pow_int (f 2) (Suc (\\<delta> 1)) * pow_int (f 2) (int (\\<delta> 2) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f 2) (int (Suc (\\<delta> 1)) + (int (\\<delta> 2) - 1)) =\n    pow_int (f 2) (int (Suc (\\<delta> 1))) *\n    pow_int (f 2) (int (\\<delta> 2) - 1)", "by (rule pow_int_add, insert f20, auto)"], ["proof (state)\nthis:\n  pow_int (f 2) (int (Suc (\\<delta> 1)) + (int (\\<delta> 2) - 1)) =\n  pow_int (f 2) (int (Suc (\\<delta> 1))) *\n  pow_int (f 2) (int (\\<delta> 2) - 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  pow_int (f 2) (int (Suc (\\<delta> 1)) + (int (\\<delta> 2) - 1)) =\n  pow_int (f 2) (int (Suc (\\<delta> 1))) *\n  pow_int (f 2) (int (\\<delta> 2) - 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"pow_int (f 2) (Suc (\\<delta> 1)) = f 2 ^ (Suc (\\<delta> 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f 2) (int (Suc (\\<delta> 1))) = f 2 ^ Suc (\\<delta> 1)", "unfolding pow_int_def nat_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if int (Suc (\\<delta> 1)) < 0\n     then 1 / f 2 ^ nat (- int (Suc (\\<delta> 1)))\n     else f 2 ^ Suc (\\<delta> 1)) =\n    f 2 ^ Suc (\\<delta> 1)", "by simp"], ["proof (state)\nthis:\n  pow_int (f 2) (int (Suc (\\<delta> 1))) = f 2 ^ Suc (\\<delta> 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  pow_int (f 2) (int (Suc (\\<delta> 1))) = f 2 ^ Suc (\\<delta> 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"\\<beta> 3 / (f 2 ^ Suc (\\<delta> 1)) *\n   (f 2 ^ Suc (\\<delta> 1) * pow_int (f 2) (int (\\<delta> 2) - 1))\n    = (\\<beta> 3 / (f 2 ^ Suc (\\<delta> 1)) *  f 2 ^ Suc (\\<delta> 1) * pow_int (f 2) (int (\\<delta> 2) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) *\n    (f 2 ^ Suc (\\<delta> 1) * pow_int (f 2) (int (\\<delta> 2) - 1)) =\n    \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ Suc (\\<delta> 1) *\n    pow_int (f 2) (int (\\<delta> 2) - 1)", "by simp"], ["proof (state)\nthis:\n  \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) *\n  (f 2 ^ Suc (\\<delta> 1) * pow_int (f 2) (int (\\<delta> 2) - 1)) =\n  \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ Suc (\\<delta> 1) *\n  pow_int (f 2) (int (\\<delta> 2) - 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) *\n  (f 2 ^ Suc (\\<delta> 1) * pow_int (f 2) (int (\\<delta> 2) - 1)) =\n  \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ Suc (\\<delta> 1) *\n  pow_int (f 2) (int (\\<delta> 2) - 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"\\<beta> 3 / (f 2 ^ Suc (\\<delta> 1)) * f 2 ^ Suc (\\<delta> 1) = \\<beta> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ Suc (\\<delta> 1) = \\<beta> 3", "using f20"], ["proof (prove)\nusing this:\n  f 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ Suc (\\<delta> 1) = \\<beta> 3", "by auto"], ["proof (state)\nthis:\n  \\<beta> 3 / f 2 ^ Suc (\\<delta> 1) * f 2 ^ Suc (\\<delta> 1) = \\<beta> 3\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> 3 =\n  (- 1) ^ \\<sigma> 3 * pow_int (f 2) (1 - int (\\<delta> 2)) *\n  (\\<beta> 3 * pow_int (f 2) (int (\\<delta> 2) - 1))", "have \"\\<gamma> 3 = ((- 1) ^ \\<sigma> 3 * \\<beta> 3) * (pow_int (f 2) (1 - int (\\<delta> 2)) * pow_int (f 2) (int (\\<delta> 2) - 1))\""], ["proof (prove)\nusing this:\n  \\<gamma> 3 =\n  (- 1) ^ \\<sigma> 3 * pow_int (f 2) (1 - int (\\<delta> 2)) *\n  (\\<beta> 3 * pow_int (f 2) (int (\\<delta> 2) - 1))\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 =\n    (- 1) ^ \\<sigma> 3 * \\<beta> 3 *\n    (pow_int (f 2) (1 - int (\\<delta> 2)) *\n     pow_int (f 2) (int (\\<delta> 2) - 1))", "by simp"], ["proof (state)\nthis:\n  \\<gamma> 3 =\n  (- 1) ^ \\<sigma> 3 * \\<beta> 3 *\n  (pow_int (f 2) (1 - int (\\<delta> 2)) *\n   pow_int (f 2) (int (\\<delta> 2) - 1))\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  \\<gamma> 3 =\n  (- 1) ^ \\<sigma> 3 * \\<beta> 3 *\n  (pow_int (f 2) (1 - int (\\<delta> 2)) *\n   pow_int (f 2) (int (\\<delta> 2) - 1))\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"pow_int (f 2) (1 - int (\\<delta> 2)) * pow_int (f 2) (int (\\<delta> 2) - 1)\n    = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f 2) (1 - int (\\<delta> 2)) *\n    pow_int (f 2) (int (\\<delta> 2) - 1) =\n    1", "by (subst pow_int_add[symmetric], insert f20, auto)"], ["proof (state)\nthis:\n  pow_int (f 2) (1 - int (\\<delta> 2)) *\n  pow_int (f 2) (int (\\<delta> 2) - 1) =\n  1\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> 3 = (- 1) ^ \\<sigma> 3 * \\<beta> 3 * 1", "have \"\\<gamma> 3 = (- 1) ^ \\<sigma> 3 * \\<beta> 3\""], ["proof (prove)\nusing this:\n  \\<gamma> 3 = (- 1) ^ \\<sigma> 3 * \\<beta> 3 * 1\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ \\<sigma> 3 * \\<beta> 3", "by simp"], ["proof (state)\nthis:\n  \\<gamma> 3 = (- 1) ^ \\<sigma> 3 * \\<beta> 3\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  \\<gamma> 3 = (- 1) ^ \\<sigma> 3 * \\<beta> 3\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"\\<sigma> 3 = (n 1 + n 2 + 1) * (n 2 + n 2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> 3 = (n 1 + n 2 + 1) * (n 2 + n 2 + 1)", "unfolding \\<sigma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<\n                         Suc 3]. (n (l - 2) + n (3 - 1) + 1) *\n                                 (n (l - 1) + n (3 - 1) + 1)) =\n    (n 1 + n 2 + 1) * (n 2 + n 2 + 1)", "by simp"], ["proof (state)\nthis:\n  \\<sigma> 3 = (n 1 + n 2 + 1) * (n 2 + n 2 + 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  \\<sigma> 3 = (n 1 + n 2 + 1) * (n 2 + n 2 + 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"(- (1 :: 'a fract)) ^ \\<dots> = (- 1) ^ (n 1 - n 2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ ((n 1 + n 2 + 1) * (n 2 + n 2 + 1)) = (- 1) ^ (n 1 - n 2 + 1)", "by (rule minus_1_even_eqI, insert n12, auto)"], ["proof (state)\nthis:\n  (- 1) ^ ((n 1 + n 2 + 1) * (n 2 + n 2 + 1)) = (- 1) ^ (n 1 - n 2 + 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "also"], ["proof (state)\nthis:\n  (- 1) ^ ((n 1 + n 2 + 1) * (n 2 + n 2 + 1)) = (- 1) ^ (n 1 - n 2 + 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "have \"\\<dots> = (- 1)^(\\<delta> 1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 - n 2 + 1) = (- 1) ^ (\\<delta> 1 + 1)", "unfolding \\<delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 - n 2 + 1) = (- 1) ^ (n 1 - n (Suc 1) + 1)", "by (simp add: numeral_2_eq_2)"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 - n 2 + 1) = (- 1) ^ (\\<delta> 1 + 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "show \"\\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3\""], ["proof (prove)\nusing this:\n  \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3\n\ngoal (1 subgoal):\n 1. \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3", "."], ["proof (state)\nthis:\n  \\<gamma> 3 = (- 1) ^ (\\<delta> 1 + 1) * \\<beta> 3\n\ngoal:\nNo subgoals!", "qed"], ["", "fun h :: \"nat \\<Rightarrow> 'a fract\" where\n  \"h i = (if (i \\<le> 1) then 1 else if i = 2 then (f 2 ^ \\<delta> 1) else (f i ^ \\<delta> (i - 1) / (h (i - 1) ^ (\\<delta> (i - 1) - 1))))\""], ["", "lemma smult_inverse_sdiv_poly: assumes ffp: \"p \\<in> range ffp\"\n  and p: \"p = smult (inverse x) q\"\n  and p': \"p' = sdiv_poly q' x'\"\n  and xx: \"x = ff x'\"\n  and qq: \"q = ffp q'\"\nshows \"p = ffp p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = ffp p'", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "have \"coeff p i = coeff q i / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p i = coeff q i / x", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Polynomial.smult (inverse x) q) i = coeff q i / x", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  coeff p i = coeff q i / x\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "also"], ["proof (state)\nthis:\n  coeff p i = coeff q i / x\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "have \"\\<dots> = ff (coeff q' i) / ff x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff q i / x = ff (coeff q' i) / ff x'", "unfolding qq xx"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (ffp q') i / ff x' = ff (coeff q' i) / ff x'", "by simp"], ["proof (state)\nthis:\n  coeff q i / x = ff (coeff q' i) / ff x'\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "finally"], ["proof (chain)\npicking this:\n  coeff p i = ff (coeff q' i) / ff x'", "have cpi: \"coeff p i = ff (coeff q' i) / ff x'\""], ["proof (prove)\nusing this:\n  coeff p i = ff (coeff q' i) / ff x'\n\ngoal (1 subgoal):\n 1. coeff p i = ff (coeff q' i) / ff x'", "."], ["proof (state)\nthis:\n  coeff p i = ff (coeff q' i) / ff x'\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "from ffp"], ["proof (chain)\npicking this:\n  p \\<in> range ffp", "obtain r where pr: \"p = ffp r\""], ["proof (prove)\nusing this:\n  p \\<in> range ffp\n\ngoal (1 subgoal):\n 1. (\\<And>r. p = ffp r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = ffp r\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "from arg_cong[OF this, of \"\\<lambda> p. coeff p i\", unfolded cpi]"], ["proof (chain)\npicking this:\n  ff (coeff q' i) / ff x' = coeff (ffp r) i", "have \"ff (coeff q' i) / ff x' \\<in> range ff\""], ["proof (prove)\nusing this:\n  ff (coeff q' i) / ff x' = coeff (ffp r) i\n\ngoal (1 subgoal):\n 1. ff (coeff q' i) / ff x' \\<in> range ff", "by auto"], ["proof (state)\nthis:\n  ff (coeff q' i) / ff x' \\<in> range ff\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "hence id: \"ff (coeff q' i) / ff x' = ff (coeff q' i div x')\""], ["proof (prove)\nusing this:\n  ff (coeff q' i) / ff x' \\<in> range ff\n\ngoal (1 subgoal):\n 1. ff (coeff q' i) / ff x' = ff (coeff q' i div x')", "by (rule div_divide_to_fract, auto)"], ["proof (state)\nthis:\n  ff (coeff q' i) / ff x' = ff (coeff q' i div x')\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (ffp p') n", "show \"coeff p i = coeff (ffp p') i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p i = coeff (ffp p') i", "unfolding cpi id p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ff (coeff q' i div x') = coeff (ffp (sdiv_poly q' x')) i", "by (simp add: sdiv_poly_def coeff_map_poly)"], ["proof (state)\nthis:\n  coeff p i = coeff (ffp p') i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale subresultant_prs_locale2 = subresultant_prs_locale F n \\<delta> f k \\<beta> G1 G2 for\n       F :: \"nat \\<Rightarrow> 'a :: idom_divide fract poly\"\n    and n :: \"nat \\<Rightarrow> nat\"\n    and \\<delta> :: \"nat \\<Rightarrow> nat\"\n    and f :: \"nat \\<Rightarrow> 'a fract\"\n    and k :: nat\n    and \\<beta> :: \"nat \\<Rightarrow> 'a fract\"\n    and G1 G2 :: \"'a poly\" +\n  assumes \\<beta>3: \"\\<beta> 3 = (-1)^(\\<delta> 1 + 1)\"\n  and \\<beta>i: \"\\<And> i. 4 \\<le> i \\<Longrightarrow> i \\<le> Suc k \\<Longrightarrow> \\<beta> i = (-1)^(\\<delta> (i - 2) + 1) * f (i - 2) * h (i - 2) ^ (\\<delta> (i - 2))\"\nbegin"], ["", "lemma B_eq_17_main: \"2 \\<le> i \\<Longrightarrow> i \\<le> k \\<Longrightarrow>\n    h i = (-1) ^ (n 1 + n i + i + 1) / f i\n   * (\\<Prod>l\\<leftarrow>[3..< Suc (Suc i)]. (\\<alpha> l / \\<beta> l)) \\<and> h i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 \\<le> i; i \\<le> k\\<rbrakk>\n    \\<Longrightarrow> h i =\n                      (- 1) ^ (n 1 + n i + i + 1) / f i *\n                      (\\<Prod>l\\<leftarrow>[3..<\n      Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n                      h i \\<noteq> 0", "proof (induct i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 2 \\<le> y; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> h y =\n                                     (- 1) ^ (n 1 + n y + y + 1) / f y *\n                                     (\\<Prod>l\\<leftarrow>[3..<\n                     Suc (Suc y)]. \\<alpha> l / \\<beta> l) \\<and>\n                                     h y \\<noteq> 0;\n        2 \\<le> x; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> h x =\n                         (- 1) ^ (n 1 + n x + x + 1) / f x *\n                         (\\<Prod>l\\<leftarrow>[3..<\n         Suc (Suc x)]. \\<alpha> l / \\<beta> l) \\<and>\n                         h x \\<noteq> 0", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < i; 2 \\<le> ?y1; ?y1 \\<le> k\\<rbrakk>\n  \\<Longrightarrow> h ?y1 =\n                    (- 1) ^ (n 1 + n ?y1 + ?y1 + 1) / f ?y1 *\n                    (\\<Prod>l\\<leftarrow>[3..<\n    Suc (Suc ?y1)]. \\<alpha> l / \\<beta> l) \\<and>\n                    h ?y1 \\<noteq> 0\n  2 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 2 \\<le> y; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> h y =\n                                     (- 1) ^ (n 1 + n y + y + 1) / f y *\n                                     (\\<Prod>l\\<leftarrow>[3..<\n                     Suc (Suc y)]. \\<alpha> l / \\<beta> l) \\<and>\n                                     h y \\<noteq> 0;\n        2 \\<le> x; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> h x =\n                         (- 1) ^ (n 1 + n x + x + 1) / f x *\n                         (\\<Prod>l\\<leftarrow>[3..<\n         Suc (Suc x)]. \\<alpha> l / \\<beta> l) \\<and>\n                         h x \\<noteq> 0", "from less(2-)"], ["proof (chain)\npicking this:\n  2 \\<le> i\n  i \\<le> k", "have fi0: \"f i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  2 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0", "using f0[of i]"], ["proof (prove)\nusing this:\n  2 \\<le> i\n  i \\<le> k\n  i \\<noteq> 0 \\<Longrightarrow> (f i = 0) = (k < i)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 2 \\<le> y; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> h y =\n                                     (- 1) ^ (n 1 + n y + y + 1) / f y *\n                                     (\\<Prod>l\\<leftarrow>[3..<\n                     Suc (Suc y)]. \\<alpha> l / \\<beta> l) \\<and>\n                                     h y \\<noteq> 0;\n        2 \\<le> x; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> h x =\n                         (- 1) ^ (n 1 + n x + x + 1) / f x *\n                         (\\<Prod>l\\<leftarrow>[3..<\n         Suc (Suc x)]. \\<alpha> l / \\<beta> l) \\<and>\n                         h x \\<noteq> 0", "have 1: \"(- 1) \\<noteq> (0 :: 'a fract)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 2 \\<le> y; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> h y =\n                                     (- 1) ^ (n 1 + n y + y + 1) / f y *\n                                     (\\<Prod>l\\<leftarrow>[3..<\n                     Suc (Suc y)]. \\<alpha> l / \\<beta> l) \\<and>\n                                     h y \\<noteq> 0;\n        2 \\<le> x; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> h x =\n                         (- 1) ^ (n 1 + n x + x + 1) / f x *\n                         (\\<Prod>l\\<leftarrow>[3..<\n         Suc (Suc x)]. \\<alpha> l / \\<beta> l) \\<and>\n                         h x \\<noteq> 0", "show ?case (is \"h i = ?r i \\<and> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "proof (cases \"i = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "case True"], ["proof (state)\nthis:\n  i = 2\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have f20: \"f 2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 2 \\<noteq> 0", "using f20"], ["proof (prove)\nusing this:\n  f 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f 2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f 2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have hi: \"h i = f 2 ^ \\<delta> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i = f 2 ^ \\<delta> 1", "unfolding True h.simps[of 2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 2 \\<le> 1 then 1\n     else if 2 = 2 then f 2 ^ \\<delta> 1\n          else f 2 ^ \\<delta> (2 - 1) /\n               h (2 - 1) ^ (\\<delta> (2 - 1) - 1)) =\n    f 2 ^ \\<delta> 1", "by simp"], ["proof (state)\nthis:\n  h i = f 2 ^ \\<delta> 1\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have id: \"int (\\<delta> 1) = int (n 1) - int (n 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<delta> 1) = int (n 1) - int (n 2)", "using n12"], ["proof (prove)\nusing this:\n  n 2 \\<le> n 1\n\ngoal (1 subgoal):\n 1. int (\\<delta> 1) = int (n 1) - int (n 2)", "unfolding \\<delta> numeral_2_eq_2"], ["proof (prove)\nusing this:\n  n (Suc (Suc 0)) \\<le> n 1\n\ngoal (1 subgoal):\n 1. int (n 1 - n (Suc 1)) = int (n 1) - int (n (Suc (Suc 0)))", "by simp"], ["proof (state)\nthis:\n  int (\\<delta> 1) = int (n 1) - int (n 2)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"?r i = (- 1) ^ (1 + n 1 + n 2)\n      * ((f 2 ^ Suc (\\<delta> 1)) / (\\<beta> 3)) / pow_int (f 2) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    (- 1) ^ (1 + n 1 + n 2) * (f 2 ^ Suc (\\<delta> 1) / \\<beta> 3) /\n    pow_int (f 2) 1", "unfolding True \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n 2 + 2 + 1) / f 2 *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc (Suc 2)]. f (l - 1) ^ Suc (\\<delta> (l - 2)) /\n  \\<beta> l) =\n    (- 1) ^ (1 + n 1 + n 2) * (f 2 ^ Suc (\\<delta> 1) / \\<beta> 3) /\n    pow_int (f 2) 1", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (1 + n 1 + n 2) * (f 2 ^ Suc (\\<delta> 1) / \\<beta> 3) /\n  pow_int (f 2) 1\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (1 + n 1 + n 2) * (f 2 ^ Suc (\\<delta> 1) / \\<beta> 3) /\n  pow_int (f 2) 1\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<beta> 3 = (- 1) ^ (\\<delta> 1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> 3 = (- 1) ^ (\\<delta> 1 + 1)", "by (rule \\<beta>3)"], ["proof (state)\nthis:\n  \\<beta> 3 = (- 1) ^ (\\<delta> 1 + 1)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  \\<beta> 3 = (- 1) ^ (\\<delta> 1 + 1)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"f 2 ^ Suc (\\<delta> 1) / \\<dots> = \\<dots> * f 2 ^ Suc (\\<delta> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 2 ^ Suc (\\<delta> 1) / (- 1) ^ (\\<delta> 1 + 1) =\n    (- 1) ^ (\\<delta> 1 + 1) * f 2 ^ Suc (\\<delta> 1)", "by simp"], ["proof (state)\nthis:\n  f 2 ^ Suc (\\<delta> 1) / (- 1) ^ (\\<delta> 1 + 1) =\n  (- 1) ^ (\\<delta> 1 + 1) * f 2 ^ Suc (\\<delta> 1)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (1 + n 1 + n 2) *\n  ((- 1) ^ (\\<delta> 1 + 1) * f 2 ^ Suc (\\<delta> 1)) /\n  pow_int (f 2) 1", "have \"?r i = ((- 1) ^ (1 + n 1 + n 2) * ((- 1) ^ (\\<delta> 1 + 1))) *\n        pow_int (f 2) (int (Suc (\\<delta> 1)) + (-1))\" (is \"_ = ?a * _\")"], ["proof (prove)\nusing this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (1 + n 1 + n 2) *\n  ((- 1) ^ (\\<delta> 1 + 1) * f 2 ^ Suc (\\<delta> 1)) /\n  pow_int (f 2) 1\n\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    (- 1) ^ (1 + n 1 + n 2) * (- 1) ^ (\\<delta> 1 + 1) *\n    pow_int (f 2) (int (Suc (\\<delta> 1)) + - 1)", "unfolding pow_int_divide exp_pow_int power_add pow_int_add[OF f20]"], ["proof (prove)\nusing this:\n  pow_int (- 1) (int (n 1 + n i + i + 1)) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  pow_int (- 1) (int (1 + n 1 + n 2)) *\n  (pow_int (- 1) (int (\\<delta> 1 + 1)) *\n   pow_int (f 2) (int (Suc (\\<delta> 1)))) *\n  pow_int (f 2) (- 1)\n\ngoal (1 subgoal):\n 1. pow_int (- 1) (int (n 1 + n i + i + 1)) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    pow_int (- 1) (int (1 + n 1 + n 2)) *\n    pow_int (- 1) (int (\\<delta> 1 + 1)) *\n    (pow_int (f 2) (int (Suc (\\<delta> 1))) * pow_int (f 2) (- 1))", "by (simp add: ac_simps pow_int_add)"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (1 + n 1 + n 2) * (- 1) ^ (\\<delta> 1 + 1) *\n  pow_int (f 2) (int (Suc (\\<delta> 1)) + - 1)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (1 + n 1 + n 2) * (- 1) ^ (\\<delta> 1 + 1) *\n  pow_int (f 2) (int (Suc (\\<delta> 1)) + - 1)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"?a = (-1)^(1 + n 1 + n 2 + \\<delta> 1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (1 + n 1 + n 2) * (- 1) ^ (\\<delta> 1 + 1) =\n    (- 1) ^ (1 + n 1 + n 2 + \\<delta> 1 + 1)", "unfolding power_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ 1 * (- 1) ^ n 1 * (- 1) ^ n 2 *\n    ((- 1) ^ \\<delta> 1 * (- 1) ^ 1) =\n    (- 1) ^ 1 * (- 1) ^ n 1 * (- 1) ^ n 2 * (- 1) ^ \\<delta> 1 * (- 1) ^ 1", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (1 + n 1 + n 2) * (- 1) ^ (\\<delta> 1 + 1) =\n  (- 1) ^ (1 + n 1 + n 2 + \\<delta> 1 + 1)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (1 + n 1 + n 2) * (- 1) ^ (\\<delta> 1 + 1) =\n  (- 1) ^ (1 + n 1 + n 2 + \\<delta> 1 + 1)\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<dots> = (-1)^0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (1 + n 1 + n 2 + \\<delta> 1 + 1) = (- 1) ^ 0", "by (rule minus_1_even_eqI, insert n12, auto simp: \\<delta> numeral_2_eq_2, presburger)"], ["proof (state)\nthis:\n  (- 1) ^ (1 + n 1 + n 2 + \\<delta> 1 + 1) = (- 1) ^ 0\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ 0 * pow_int (f 2) (int (Suc (\\<delta> 1)) + - 1)", "have ri: \"?r i = pow_int (f 2) (int (\\<delta> 1))\""], ["proof (prove)\nusing this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ 0 * pow_int (f 2) (int (Suc (\\<delta> 1)) + - 1)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    pow_int (f 2) (int (\\<delta> 1))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  pow_int (f 2) (int (\\<delta> 1))\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "unfolding ri hi exp_pow_int[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f 2 ^ \\<delta> 1 = f 2 ^ \\<delta> 1 \\<and> f 2 ^ \\<delta> 1 \\<noteq> 0", "using f20"], ["proof (prove)\nusing this:\n  f 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f 2 ^ \\<delta> 1 = f 2 ^ \\<delta> 1 \\<and> f 2 ^ \\<delta> 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  h i =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n  h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 2\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "hence i: \"i \\<ge> 3\" and ii: \"i - 1 < i\" \"2 \\<le> i - 1\" \"i - 1 \\<le> k\""], ["proof (prove)\nusing this:\n  i \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 3 \\<le> i &&& i - 1 < i &&& 2 \\<le> i - 1 &&& i - 1 \\<le> k", "using less(2-)"], ["proof (prove)\nusing this:\n  i \\<noteq> 2\n  2 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. 3 \\<le> i &&& i - 1 < i &&& 2 \\<le> i - 1 &&& i - 1 \\<le> k", "by auto"], ["proof (state)\nthis:\n  3 \\<le> i\n  i - 1 < i\n  2 \\<le> i - 1\n  i - 1 \\<le> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "from i less(2-)"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  2 \\<le> i\n  i \\<le> k", "have cc: \"4 \\<le> Suc i\" \"Suc i \\<le> Suc k\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  2 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. 4 \\<le> Suc i &&& Suc i \\<le> Suc k", "by auto"], ["proof (state)\nthis:\n  4 \\<le> Suc i\n  Suc i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "define P where \"P = (\\<Prod>l\\<leftarrow>[3..< Suc i]. \\<alpha> l / \\<beta> l)\""], ["proof (state)\nthis:\n  P = (\\<Prod>l\\<leftarrow>[3..<Suc i]. \\<alpha> l / \\<beta> l)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "define Q where \"Q = P * pow_int (h (i - 1)) (- int (\\<delta> (i - 1)))\""], ["proof (state)\nthis:\n  Q = P * pow_int (h (i - 1)) (- int (\\<delta> (i - 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "define R where \"R = f i ^ \\<delta> (i - 1)\""], ["proof (state)\nthis:\n  R = f i ^ \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "define S where \"S = pow_int (f (i - 1)) (- 1)\""], ["proof (state)\nthis:\n  S = pow_int (f (i - 1)) (- 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "note IH = less(1)[OF ii]"], ["proof (state)\nthis:\n  h (i - 1) =\n  (- 1) ^ (n 1 + n (i - 1) + (i - 1) + 1) / f (i - 1) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc (Suc (i - 1))]. \\<alpha> l / \\<beta> l) \\<and>\n  h (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "hence hi0: \"h (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h (i - 1) =\n  (- 1) ^ (n 1 + n (i - 1) + (i - 1) + 1) / f (i - 1) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc (Suc (i - 1))]. \\<alpha> l / \\<beta> l) \\<and>\n  h (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h (i - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  h (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have hii: \"h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)", "unfolding h.simps[of i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i \\<le> 1 then 1\n     else if i = 2 then f 2 ^ \\<delta> 1\n          else f i ^ \\<delta> (i - 1) /\n               h (i - 1) ^ (\\<delta> (i - 1) - 1)) =\n    f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)", "using i"], ["proof (prove)\nusing this:\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. (if i \\<le> 1 then 1\n     else if i = 2 then f 2 ^ \\<delta> 1\n          else f i ^ \\<delta> (i - 1) /\n               h (i - 1) ^ (\\<delta> (i - 1) - 1)) =\n    f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)", "by simp"], ["proof (state)\nthis:\n  h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<dots> = f i ^ \\<delta> (i - 1) * pow_int (h (i - 1)) (- int (\\<delta> (i - 1) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1) =\n    f i ^ \\<delta> (i - 1) *\n    pow_int (h (i - 1)) (- int (\\<delta> (i - 1) - 1))", "unfolding exp_pow_int pow_int_divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (int (\\<delta> (i - 1))) *\n    pow_int (h (i - 1)) (- int (\\<delta> (i - 1) - 1)) =\n    pow_int (f i) (int (\\<delta> (i - 1))) *\n    pow_int (h (i - 1)) (- int (\\<delta> (i - 1) - 1))", "by simp"], ["proof (state)\nthis:\n  f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1) =\n  f i ^ \\<delta> (i - 1) *\n  pow_int (h (i - 1)) (- int (\\<delta> (i - 1) - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1) =\n  f i ^ \\<delta> (i - 1) *\n  pow_int (h (i - 1)) (- int (\\<delta> (i - 1) - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1", "have \"\\<delta> (i - 1) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<delta> (i - 1)", "unfolding \\<delta>[of \"i - 1\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n (i - 1) - n (Suc (i - 1))", "using n_gt[OF ii(2)] less(2-)"], ["proof (prove)\nusing this:\n  i - 1 < k \\<Longrightarrow> n (Suc (i - 1)) < n (i - 1)\n  2 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. 0 < n (i - 1) - n (Suc (i - 1))", "by auto"], ["proof (state)\nthis:\n  0 < \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1", "by simp"], ["proof (state)\nthis:\n  int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  int (\\<delta> (i - 1) - 1) = int (\\<delta> (i - 1)) - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"- (int (\\<delta> (i - 1)) - 1) = 1 + (- int (\\<delta> (i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (int (\\<delta> (i - 1)) - 1) = 1 + - int (\\<delta> (i - 1))", "by simp"], ["proof (state)\nthis:\n  - (int (\\<delta> (i - 1)) - 1) = 1 + - int (\\<delta> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  h i =\n  f i ^ \\<delta> (i - 1) *\n  pow_int (h (i - 1)) (1 + - int (\\<delta> (i - 1)))", "have hi: \"h i = (- 1) ^ (n 1 + n (i - 1) + i) * (R * Q * S)\""], ["proof (prove)\nusing this:\n  h i =\n  f i ^ \\<delta> (i - 1) *\n  pow_int (h (i - 1)) (1 + - int (\\<delta> (i - 1)))\n\ngoal (1 subgoal):\n 1. h i = (- 1) ^ (n 1 + n (i - 1) + i) * (R * Q * S)", "unfolding pow_int_add[OF hi0] P_def Q_def pow_int_divide[symmetric] R_def S_def"], ["proof (prove)\nusing this:\n  h i =\n  f i ^ \\<delta> (i - 1) *\n  (pow_int (h (i - 1)) 1 / pow_int (h (i - 1)) (int (\\<delta> (i - 1))))\n\ngoal (1 subgoal):\n 1. h i =\n    (- 1) ^ (n 1 + n (i - 1) + i) *\n    (f i ^ \\<delta> (i - 1) *\n     ((\\<Prod>l\\<leftarrow>[3..<Suc i]. \\<alpha> l / \\<beta> l) /\n      pow_int (h (i - 1)) (int (\\<delta> (i - 1)))) /\n     pow_int (f (i - 1)) 1)", "using IH i"], ["proof (prove)\nusing this:\n  h i =\n  f i ^ \\<delta> (i - 1) *\n  (pow_int (h (i - 1)) 1 / pow_int (h (i - 1)) (int (\\<delta> (i - 1))))\n  h (i - 1) =\n  (- 1) ^ (n 1 + n (i - 1) + (i - 1) + 1) / f (i - 1) *\n  (\\<Prod>l\\<leftarrow>[3..<\n                        Suc (Suc (i - 1))]. \\<alpha> l / \\<beta> l) \\<and>\n  h (i - 1) \\<noteq> 0\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. h i =\n    (- 1) ^ (n 1 + n (i - 1) + i) *\n    (f i ^ \\<delta> (i - 1) *\n     ((\\<Prod>l\\<leftarrow>[3..<Suc i]. \\<alpha> l / \\<beta> l) /\n      pow_int (h (i - 1)) (int (\\<delta> (i - 1)))) /\n     pow_int (f (i - 1)) 1)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  h i = (- 1) ^ (n 1 + n (i - 1) + i) * (R * Q * S)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "from i"], ["proof (chain)\npicking this:\n  3 \\<le> i", "have id: \"[3..<Suc (Suc i)] = [3 ..< Suc i] @ [Suc i]\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. [3..<Suc (Suc i)] = [3..<Suc i] @ [Suc i]", "by simp"], ["proof (state)\nthis:\n  [3..<Suc (Suc i)] = [3..<Suc i] @ [Suc i]\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"?r i = (- 1) ^ (n 1 + n i + i + 1)\n      * pow_int (f i) (- 1) * P * \\<alpha> (Suc i) / \\<beta> (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n    \\<alpha> (Suc i) /\n    \\<beta> (Suc i)", "unfolding pow_int_divide[symmetric] P_def id Fract_conv_to_fract"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc i] @ [Suc i]. \\<alpha> l / \\<beta> l) =\n    (- 1) ^ (n 1 + n i + i + 1) / pow_int (f i) 1 *\n    (\\<Prod>l\\<leftarrow>[3..<Suc i]. \\<alpha> l / \\<beta> l) *\n    \\<alpha> (Suc i) /\n    \\<beta> (Suc i)", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P * \\<alpha> (Suc i) /\n  \\<beta> (Suc i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P * \\<alpha> (Suc i) /\n  \\<beta> (Suc i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<beta> (Suc i) = (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) * h (i - 1) ^ \\<delta> (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) =\n    (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n    h (i - 1) ^ \\<delta> (i - 1)", "using \\<beta>i[OF cc]"], ["proof (prove)\nusing this:\n  \\<beta> (Suc i) =\n  (- 1) ^ (\\<delta> (Suc i - 2) + 1) * f (Suc i - 2) *\n  h (Suc i - 2) ^ \\<delta> (Suc i - 2)\n\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) =\n    (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n    h (i - 1) ^ \\<delta> (i - 1)", "by simp"], ["proof (state)\nthis:\n  \\<beta> (Suc i) =\n  (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) * h (i - 1) ^ \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  \\<beta> (Suc i) =\n  (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) * h (i - 1) ^ \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<alpha> (Suc i) = f i ^ Suc (\\<delta> (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (Suc i) = f i ^ Suc (\\<delta> (i - 1))", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i - 1) ^ Suc (\\<delta> (Suc i - 2)) =\n    f i ^ Suc (\\<delta> (i - 1))", "by simp"], ["proof (state)\nthis:\n  \\<alpha> (Suc i) = f i ^ Suc (\\<delta> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n  f i ^ Suc (\\<delta> (i - 1)) /\n  ((- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n   h (i - 1) ^ \\<delta> (i - 1))", "have \"?r i = (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *  (f i ^ Suc (\\<delta> (i - 1))) /\n      (- 1) ^ (\\<delta> (i - 1) + 1) * pow_int (f (i - 1)) (- 1) / h (i - 1) ^ \\<delta> (i - 1)\"\n      (is \"_ = ?a1 * ?fi1 * P * ?fi2 / ?a2 * ?b / ?c\")"], ["proof (prove)\nusing this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n  f i ^ Suc (\\<delta> (i - 1)) /\n  ((- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n   h (i - 1) ^ \\<delta> (i - 1))\n\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n    f i ^ Suc (\\<delta> (i - 1)) /\n    (- 1) ^ (\\<delta> (i - 1) + 1) *\n    pow_int (f (i - 1)) (- 1) /\n    h (i - 1) ^ \\<delta> (i - 1)", "unfolding exp_pow_int pow_int_divide[symmetric]"], ["proof (prove)\nusing this:\n  pow_int (- 1) (int (n 1 + n i + i + 1)) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  pow_int (- 1) (int (n 1 + n i + i + 1)) / pow_int (f i) 1 * P *\n  pow_int (f i) (int (Suc (\\<delta> (i - 1)))) /\n  (pow_int (- 1) (int (\\<delta> (i - 1) + 1)) * f (i - 1) *\n   pow_int (h (i - 1)) (int (\\<delta> (i - 1))))\n\ngoal (1 subgoal):\n 1. pow_int (- 1) (int (n 1 + n i + i + 1)) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    pow_int (- 1) (int (n 1 + n i + i + 1)) / pow_int (f i) 1 * P *\n    pow_int (f i) (int (Suc (\\<delta> (i - 1)))) /\n    pow_int (- 1) (int (\\<delta> (i - 1) + 1)) /\n    pow_int (f (i - 1)) 1 /\n    pow_int (h (i - 1)) (int (\\<delta> (i - 1)))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n  f i ^ Suc (\\<delta> (i - 1)) /\n  (- 1) ^ (\\<delta> (i - 1) + 1) *\n  pow_int (f (i - 1)) (- 1) /\n  h (i - 1) ^ \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n  f i ^ Suc (\\<delta> (i - 1)) /\n  (- 1) ^ (\\<delta> (i - 1) + 1) *\n  pow_int (f (i - 1)) (- 1) /\n  h (i - 1) ^ \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<dots> = (?a1 / ?a2) * (?fi1 * ?fi2) * (P / ?c) * ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n    f i ^ Suc (\\<delta> (i - 1)) /\n    (- 1) ^ (\\<delta> (i - 1) + 1) *\n    pow_int (f (i - 1)) (- 1) /\n    h (i - 1) ^ \\<delta> (i - 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / (- 1) ^ (\\<delta> (i - 1) + 1) *\n    (pow_int (f i) (- 1) * f i ^ Suc (\\<delta> (i - 1))) *\n    (P / h (i - 1) ^ \\<delta> (i - 1)) *\n    pow_int (f (i - 1)) (- 1)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n  f i ^ Suc (\\<delta> (i - 1)) /\n  (- 1) ^ (\\<delta> (i - 1) + 1) *\n  pow_int (f (i - 1)) (- 1) /\n  h (i - 1) ^ \\<delta> (i - 1) =\n  (- 1) ^ (n 1 + n i + i + 1) / (- 1) ^ (\\<delta> (i - 1) + 1) *\n  (pow_int (f i) (- 1) * f i ^ Suc (\\<delta> (i - 1))) *\n  (P / h (i - 1) ^ \\<delta> (i - 1)) *\n  pow_int (f (i - 1)) (- 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) * pow_int (f i) (- 1) * P *\n  f i ^ Suc (\\<delta> (i - 1)) /\n  (- 1) ^ (\\<delta> (i - 1) + 1) *\n  pow_int (f (i - 1)) (- 1) /\n  h (i - 1) ^ \\<delta> (i - 1) =\n  (- 1) ^ (n 1 + n i + i + 1) / (- 1) ^ (\\<delta> (i - 1) + 1) *\n  (pow_int (f i) (- 1) * f i ^ Suc (\\<delta> (i - 1))) *\n  (P / h (i - 1) ^ \\<delta> (i - 1)) *\n  pow_int (f (i - 1)) (- 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"?a1 / ?a2 = (- 1) ^ (n 1 + n i + i + 1 + \\<delta> (i - 1) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / (- 1) ^ (\\<delta> (i - 1) + 1) =\n    (- 1) ^ (n 1 + n i + i + 1 + \\<delta> (i - 1) + 1)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / (- 1) ^ (\\<delta> (i - 1) + 1) =\n  (- 1) ^ (n 1 + n i + i + 1 + \\<delta> (i - 1) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / (- 1) ^ (\\<delta> (i - 1) + 1) =\n  (- 1) ^ (n 1 + n i + i + 1 + \\<delta> (i - 1) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<dots> = (-1) ^ (n 1 + n i + i + \\<delta> (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1 + \\<delta> (i - 1) + 1) =\n    (- 1) ^ (n 1 + n i + i + \\<delta> (i - 1))", "by (rule minus_1_even_eqI, auto)"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1 + \\<delta> (i - 1) + 1) =\n  (- 1) ^ (n 1 + n i + i + \\<delta> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1 + \\<delta> (i - 1) + 1) =\n  (- 1) ^ (n 1 + n i + i + \\<delta> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"n 1 + n i + i + \\<delta> (i - 1) = n 1 + n (i - 1) + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n 1 + n i + i + \\<delta> (i - 1) = n 1 + n (i - 1) + i", "unfolding \\<delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n 1 + n i + i + (n (i - 1) - n (Suc (i - 1))) = n 1 + n (i - 1) + i", "using i less(2-) n_ge[of \"i - 1\"]"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  2 \\<le> i\n  i \\<le> k\n  \\<lbrakk>1 \\<le> i - 1; i - 1 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 1)) \\<le> n (i - 1)\n\ngoal (1 subgoal):\n 1. n 1 + n i + i + (n (i - 1) - n (Suc (i - 1))) = n 1 + n (i - 1) + i", "by simp"], ["proof (state)\nthis:\n  n 1 + n i + i + \\<delta> (i - 1) = n 1 + n (i - 1) + i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  n 1 + n i + i + \\<delta> (i - 1) = n 1 + n (i - 1) + i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"?fi1 * ?fi2 = pow_int (f i) (-1 + int (Suc (\\<delta> (i - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (- 1) * f i ^ Suc (\\<delta> (i - 1)) =\n    pow_int (f i) (- 1 + int (Suc (\\<delta> (i - 1))))", "unfolding exp_pow_int pow_int_add[OF fi0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (- 1) * pow_int (f i) (int (Suc (\\<delta> (i - 1)))) =\n    pow_int (f i) (- 1) * pow_int (f i) (int (Suc (\\<delta> (i - 1))))", "by simp"], ["proof (state)\nthis:\n  pow_int (f i) (- 1) * f i ^ Suc (\\<delta> (i - 1)) =\n  pow_int (f i) (- 1 + int (Suc (\\<delta> (i - 1))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  pow_int (f i) (- 1) * f i ^ Suc (\\<delta> (i - 1)) =\n  pow_int (f i) (- 1 + int (Suc (\\<delta> (i - 1))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"\\<dots> = pow_int (f i) (int (\\<delta> (i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (- 1 + int (Suc (\\<delta> (i - 1)))) =\n    pow_int (f i) (int (\\<delta> (i - 1)))", "by simp"], ["proof (state)\nthis:\n  pow_int (f i) (- 1 + int (Suc (\\<delta> (i - 1)))) =\n  pow_int (f i) (int (\\<delta> (i - 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  pow_int (f i) (- 1 + int (Suc (\\<delta> (i - 1)))) =\n  pow_int (f i) (int (\\<delta> (i - 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"P / ?c = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P / h (i - 1) ^ \\<delta> (i - 1) = Q", "unfolding Q_def exp_pow_int pow_int_divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * pow_int (h (i - 1)) (- int (\\<delta> (i - 1))) =\n    P * pow_int (h (i - 1)) (- int (\\<delta> (i - 1)))", "by simp"], ["proof (state)\nthis:\n  P / h (i - 1) ^ \\<delta> (i - 1) = Q\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "also"], ["proof (state)\nthis:\n  P / h (i - 1) ^ \\<delta> (i - 1) = Q\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have \"?b = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (- 1) = S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (- 1) = pow_int (f (i - 1)) (- 1)", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (- 1) = S\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n (i - 1) + i) * pow_int (f i) (int (\\<delta> (i - 1))) *\n  Q *\n  S", "have ri: \"?r i = (-1)^(n 1 + n (i - 1) + i)\n      * (R * Q * S)\""], ["proof (prove)\nusing this:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n (i - 1) + i) * pow_int (f i) (int (\\<delta> (i - 1))) *\n  Q *\n  S\n\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    (- 1) ^ (n 1 + n (i - 1) + i) * (R * Q * S)", "by (simp add: exp_pow_int R_def)"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  (- 1) ^ (n 1 + n (i - 1) + i) * (R * Q * S)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "have id: \"h i = ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "unfolding hi ri"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n (i - 1) + i) * (R * Q * S) =\n    (- 1) ^ (n 1 + n (i - 1) + i) * (R * Q * S)", ".."], ["proof (state)\nthis:\n  h i =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. h i =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n    h i \\<noteq> 0", "by (rule conjI[OF id], unfold hii, insert IH fi0, auto)"], ["proof (state)\nthis:\n  h i =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n  h i \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h i =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) \\<and>\n  h i \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma B_eq_17: \"2 \\<le> i \\<Longrightarrow> i \\<le> k \\<Longrightarrow>\n    h i = (-1) ^ (n 1 + n i + i + 1) / f i * (\\<Prod>l\\<leftarrow>[3..< Suc (Suc i)]. (\\<alpha> l / \\<beta> l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 \\<le> i; i \\<le> k\\<rbrakk>\n    \\<Longrightarrow> h i =\n                      (- 1) ^ (n 1 + n i + i + 1) / f i *\n                      (\\<Prod>l\\<leftarrow>[3..<\n      Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "using B_eq_17_main"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> ?i; ?i \\<le> k\\<rbrakk>\n  \\<Longrightarrow> h ?i =\n                    (- 1) ^ (n 1 + n ?i + ?i + 1) / f ?i *\n                    (\\<Prod>l\\<leftarrow>[3..<\n    Suc (Suc ?i)]. \\<alpha> l / \\<beta> l) \\<and>\n                    h ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 \\<le> i; i \\<le> k\\<rbrakk>\n    \\<Longrightarrow> h i =\n                      (- 1) ^ (n 1 + n i + i + 1) / f i *\n                      (\\<Prod>l\\<leftarrow>[3..<\n      Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "by blast"], ["", "lemma B_theorem_2: \"3 \\<le> i \\<Longrightarrow> i \\<le> Suc k \\<Longrightarrow> \\<gamma> i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<gamma> i = 1", "proof (induct i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 3 \\<le> y; y \\<le> Suc k\\<rbrakk>\n                   \\<Longrightarrow> \\<gamma> y = 1;\n        3 \\<le> x; x \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<gamma> x = 1", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < i; 3 \\<le> ?y1; ?y1 \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> \\<gamma> ?y1 = 1\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 3 \\<le> y; y \\<le> Suc k\\<rbrakk>\n                   \\<Longrightarrow> \\<gamma> y = 1;\n        3 \\<le> x; x \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<gamma> x = 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i = 1", "proof (cases \"i = 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow> \\<gamma> i = 1\n 2. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "case True"], ["proof (state)\nthis:\n  i = 3\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow> \\<gamma> i = 1\n 2. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i = 1", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> 3 = 1", "unfolding gamma_delta_beta_3 \\<beta>3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<delta> 1 + 1) * (- 1) ^ (\\<delta> 1 + 1) = 1", "by simp"], ["proof (state)\nthis:\n  \\<gamma> i = 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 3\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "with less(2-)"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> Suc k\n  i \\<noteq> 3", "have i: \"i \\<ge> 4\" and ii: \"i - 1 < i\" \"3 \\<le> i - 1\" \"i - 1 \\<le> Suc k\"\n      and iii: \"4 \\<le> i\" \"i \\<le> Suc k\"\n      and iv: \"2 \\<le> i - 2\" \"i - 2 \\<le> k\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> Suc k\n  i \\<noteq> 3\n\ngoal (1 subgoal):\n 1. (4 \\<le> i &&& i - 1 < i &&& 3 \\<le> i - 1 &&& i - 1 \\<le> Suc k) &&&\n    (4 \\<le> i &&& i \\<le> Suc k) &&& 2 \\<le> i - 2 &&& i - 2 \\<le> k", "by auto"], ["proof (state)\nthis:\n  4 \\<le> i\n  i - 1 < i\n  3 \\<le> i - 1\n  i - 1 \\<le> Suc k\n  4 \\<le> i\n  i \\<le> Suc k\n  2 \\<le> i - 2\n  i - 2 \\<le> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "from less(1)[OF ii]"], ["proof (chain)\npicking this:\n  \\<gamma> (i - 1) = 1", "have IH: \"\\<gamma> (i - 1) = 1\""], ["proof (prove)\nusing this:\n  \\<gamma> (i - 1) = 1\n\ngoal (1 subgoal):\n 1. \\<gamma> (i - 1) = 1", "."], ["proof (state)\nthis:\n  \\<gamma> (i - 1) = 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "define L where \"L = [3..< i]\""], ["proof (state)\nthis:\n  L = [3..<i]\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have id: \"[3..<Suc (i - 1)] = L\" \"[3..<Suc i] = L @ [i]\" \"Suc (Suc (i - 2)) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [3..<Suc (i - 1)] = L &&&\n    [3..<Suc i] = L @ [i] &&& Suc (Suc (i - 2)) = i", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [3..<Suc (i - 1)] = [3..<i] &&&\n    [3..<Suc i] = [3..<i] @ [i] &&& Suc (Suc (i - 2)) = i", "using i"], ["proof (prove)\nusing this:\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. [3..<Suc (i - 1)] = [3..<i] &&&\n    [3..<Suc i] = [3..<i] @ [i] &&& Suc (Suc (i - 2)) = i", "by auto"], ["proof (state)\nthis:\n  [3..<Suc (i - 1)] = L\n  [3..<Suc i] = L @ [i]\n  Suc (Suc (i - 2)) = i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "define B where \"B = (\\<lambda> l. \\<beta> l / \\<alpha> l)\""], ["proof (state)\nthis:\n  B = (\\<lambda>l. \\<beta> l / \\<alpha> l)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "define A where \"A = (\\<lambda> l. \\<alpha> l / \\<beta> l)\""], ["proof (state)\nthis:\n  A = (\\<lambda>l. \\<alpha> l / \\<beta> l)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "define Q where \"Q = (\\<lambda> l. f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)))\""], ["proof (state)\nthis:\n  Q = (\\<lambda>l. f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "define R where \"R = (\\<lambda> i l. B l ^ (n (l - 1) - n (i - 1) + 1))\""], ["proof (state)\nthis:\n  R = (\\<lambda>i l. B l ^ (n (l - 1) - n (i - 1) + 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "define P where \"P = (\\<lambda> i l. R i l * Q l)\""], ["proof (state)\nthis:\n  P = (\\<lambda>i l. R i l * Q l)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have fi0: \"f (i - 1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i - 1) \\<noteq> 0", "using f0[of \"i - 1\"] less(2-)"], ["proof (prove)\nusing this:\n  i - 1 \\<noteq> 0 \\<Longrightarrow> (f (i - 1) = 0) = (k < i - 1)\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. f (i - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have fi0': \"f (i - 2) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i - 2) \\<noteq> 0", "using f0[of \"i - 2\"] less(2-)"], ["proof (prove)\nusing this:\n  i - 2 \\<noteq> 0 \\<Longrightarrow> (f (i - 2) = 0) = (k < i - 2)\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. f (i - 2) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "{"], ["proof (state)\nthis:\n  f (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "assume \"j \\<in> set L\""], ["proof (state)\nthis:\n  j \\<in> set L\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "hence \"j \\<ge> 3\" \"j < i\""], ["proof (prove)\nusing this:\n  j \\<in> set L\n\ngoal (1 subgoal):\n 1. 3 \\<le> j &&& j < i", "unfolding L_def"], ["proof (prove)\nusing this:\n  j \\<in> set [3..<i]\n\ngoal (1 subgoal):\n 1. 3 \\<le> j &&& j < i", "by auto"], ["proof (state)\nthis:\n  3 \\<le> j\n  j < i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "with less(3)"], ["proof (chain)\npicking this:\n  i \\<le> Suc k\n  3 \\<le> j\n  j < i", "have j: \"j - 1 \\<noteq> 0\" \"j - 1 < k\""], ["proof (prove)\nusing this:\n  i \\<le> Suc k\n  3 \\<le> j\n  j < i\n\ngoal (1 subgoal):\n 1. j - 1 \\<noteq> 0 &&& j - 1 < k", "by auto"], ["proof (state)\nthis:\n  j - 1 \\<noteq> 0\n  j - 1 < k\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "hence Q: \"Q j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j - 1 \\<noteq> 0\n  j - 1 < k\n\ngoal (1 subgoal):\n 1. Q j \\<noteq> 0", "unfolding Q_def"], ["proof (prove)\nusing this:\n  j - 1 \\<noteq> 0\n  j - 1 < k\n\ngoal (1 subgoal):\n 1. f (j - 1) ^ (\\<delta> (j - 2) + \\<delta> (j - 1)) \\<noteq> 0", "using f0[of \"j - 1\"]"], ["proof (prove)\nusing this:\n  j - 1 \\<noteq> 0\n  j - 1 < k\n  j - 1 \\<noteq> 0 \\<Longrightarrow> (f (j - 1) = 0) = (k < j - 1)\n\ngoal (1 subgoal):\n 1. f (j - 1) ^ (\\<delta> (j - 2) + \\<delta> (j - 1)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Q j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "from j \\<alpha>0 \\<beta>0[of j]"], ["proof (chain)\npicking this:\n  j - 1 \\<noteq> 0\n  j - 1 < k\n  1 < ?i \\<Longrightarrow> (\\<alpha> ?i = 0) = (k < ?i - 1)\n  \\<beta> j \\<noteq> 0", "have 0: \"\\<alpha> j \\<noteq> 0\" \"\\<beta> j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j - 1 \\<noteq> 0\n  j - 1 < k\n  1 < ?i \\<Longrightarrow> (\\<alpha> ?i = 0) = (k < ?i - 1)\n  \\<beta> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> j \\<noteq> 0 &&& \\<beta> j \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> j \\<noteq> 0\n  \\<beta> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "hence \"B j \\<noteq> 0\" \"A j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<alpha> j \\<noteq> 0\n  \\<beta> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B j \\<noteq> 0 &&& A j \\<noteq> 0", "unfolding B_def A_def"], ["proof (prove)\nusing this:\n  \\<alpha> j \\<noteq> 0\n  \\<beta> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> j / \\<alpha> j \\<noteq> 0 &&& \\<alpha> j / \\<beta> j \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  B j \\<noteq> 0\n  A j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "note Q this"], ["proof (state)\nthis:\n  Q j \\<noteq> 0\n  B j \\<noteq> 0\n  A j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "}"], ["proof (state)\nthis:\n  ?j3 \\<in> set L \\<Longrightarrow> Q ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> B ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> A ?j3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "note L0 = this"], ["proof (state)\nthis:\n  ?j3 \\<in> set L \\<Longrightarrow> Q ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> B ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> A ?j3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "let ?exp = \"\\<delta> (i - 2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<gamma> i = \\<gamma> i / \\<gamma> (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i = \\<gamma> i / \\<gamma> (i - 1)", "unfolding IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i = \\<gamma> i / 1", "by simp"], ["proof (state)\nthis:\n  \\<gamma> i = \\<gamma> i / \\<gamma> (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  \\<gamma> i = \\<gamma> i / \\<gamma> (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<dots> = (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n      (\\<Prod>l\\<leftarrow>L. P i l) * P i i /\n      ((- 1) ^ \\<sigma> (i - 1) * pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n       (\\<Prod>l\\<leftarrow>L. P (i - 1) l))\"  (is \"_ = ?a1 * ?f1 * ?L1 * P i i / (?a2 * ?f2 * ?L2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> i / \\<gamma> (i - 1) =\n    (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    prod_list (map (P i) L) *\n    P i i /\n    ((- 1) ^ \\<sigma> (i - 1) *\n     pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n     prod_list (map (P (i - 1)) L))", "unfolding \\<gamma>_def id P_def Q_def R_def B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>L @\n                         [i]. (\\<beta> l / \\<alpha> l) ^\n                              (n (l - 1) - n (i - 1) + 1) *\n                              f (l - 1) ^\n                              (\\<delta> (l - 2) + \\<delta> (l - 1))) /\n    ((- 1) ^ \\<sigma> (i - 1) *\n     pow_int (f (i - 1 - 1)) (1 - int (\\<delta> (i - 1 - 1))) *\n     (\\<Prod>l\\<leftarrow>L. (\\<beta> l / \\<alpha> l) ^\n                             (n (l - 1) - n (i - 1 - 1) + 1) *\n                             f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1)))) =\n    (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (\\<Prod>l\\<leftarrow>L. (\\<beta> l / \\<alpha> l) ^\n                            (n (l - 1) - n (i - 1) + 1) *\n                            f (l - 1) ^\n                            (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    ((\\<beta> i / \\<alpha> i) ^ (n (i - 1) - n (i - 1) + 1) *\n     f (i - 1) ^ (\\<delta> (i - 2) + \\<delta> (i - 1))) /\n    ((- 1) ^ \\<sigma> (i - 1) *\n     pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n     (\\<Prod>l\\<leftarrow>L. (\\<beta> l / \\<alpha> l) ^\n                             (n (l - 1) - n (i - 1 - 1) + 1) *\n                             f (l - 1) ^\n                             (\\<delta> (l - 2) + \\<delta> (l - 1))))", "by (simp add: numeral_2_eq_2)"], ["proof (state)\nthis:\n  \\<gamma> i / \\<gamma> (i - 1) =\n  (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  prod_list (map (P i) L) *\n  P i i /\n  ((- 1) ^ \\<sigma> (i - 1) *\n   pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n   prod_list (map (P (i - 1)) L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  \\<gamma> i / \\<gamma> (i - 1) =\n  (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  prod_list (map (P i) L) *\n  P i i /\n  ((- 1) ^ \\<sigma> (i - 1) *\n   pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n   prod_list (map (P (i - 1)) L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<dots> = (?a1 * ?a2) * (?f1 * P i i) / ?f2 * (?L1 / ?L2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    prod_list (map (P i) L) *\n    P i i /\n    ((- 1) ^ \\<sigma> (i - 1) *\n     pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n     prod_list (map (P (i - 1)) L)) =\n    (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) *\n    (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) * P i i) /\n    pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n    (prod_list (map (P i) L) / prod_list (map (P (i - 1)) L))", "unfolding divide_prod_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    prod_list (map (P i) L) *\n    P i i /\n    (- 1) ^ \\<sigma> (i - 1) /\n    pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) /\n    prod_list (map (P (i - 1)) L) =\n    (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) *\n    (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) * P i i) /\n    pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n    (prod_list (map (P i) L) / prod_list (map (P (i - 1)) L))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  prod_list (map (P i) L) *\n  P i i /\n  ((- 1) ^ \\<sigma> (i - 1) *\n   pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n   prod_list (map (P (i - 1)) L)) =\n  (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) *\n  (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) * P i i) /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  (prod_list (map (P i) L) / prod_list (map (P (i - 1)) L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  (- 1) ^ \\<sigma> i * pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  prod_list (map (P i) L) *\n  P i i /\n  ((- 1) ^ \\<sigma> (i - 1) *\n   pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n   prod_list (map (P (i - 1)) L)) =\n  (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) *\n  (pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) * P i i) /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  (prod_list (map (P i) L) / prod_list (map (P (i - 1)) L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?a1 * ?a2 = (-1)^(\\<sigma> i + \\<sigma> (i - 1))\" (is \"_ = ?a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1))", "unfolding power_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) =\n    (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1)", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  (- 1) ^ \\<sigma> i * (- 1) ^ \\<sigma> (i - 1) =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?L1 / ?L2 = (\\<Prod>l\\<leftarrow>L. R i l) / (\\<Prod>l\\<leftarrow>L. R (i - 1) l) * ((\\<Prod>l\\<leftarrow>L. Q l) / (\\<Prod>l\\<leftarrow>L. Q l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (P i) L) / prod_list (map (P (i - 1)) L) =\n    prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n    (prod_list (map Q L) / prod_list (map Q L))", "unfolding P_def prod_list_multf divide_prod_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) * prod_list (map Q L) /\n    prod_list (map (R (i - 1)) L) /\n    prod_list (map Q L) =\n    prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n    (prod_list (map Q L) / prod_list (map Q L))", "by simp"], ["proof (state)\nthis:\n  prod_list (map (P i) L) / prod_list (map (P (i - 1)) L) =\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n  (prod_list (map Q L) / prod_list (map Q L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  prod_list (map (P i) L) / prod_list (map (P (i - 1)) L) =\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n  (prod_list (map Q L) / prod_list (map Q L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<dots> = (\\<Prod>l\\<leftarrow>L. R i l) / (\\<Prod>l\\<leftarrow>L. R (i - 1) l)\" (is \"_ = ?L1 / ?L2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n    (prod_list (map Q L) / prod_list (map Q L)) =\n    prod_list (map (R i) L) / prod_list (map (R (i - 1)) L)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n    (prod_list (map Q L) / prod_list (map Q L)) =\n    prod_list (map (R i) L) / prod_list (map (R (i - 1)) L)", "have \"(\\<Prod>l\\<leftarrow>L. Q l) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map Q L) \\<noteq> 0", "unfolding prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set (map Q L)", "using L0"], ["proof (prove)\nusing this:\n  ?j3 \\<in> set L \\<Longrightarrow> Q ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> B ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> A ?j3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set (map Q L)", "by auto"], ["proof (state)\nthis:\n  prod_list (map Q L) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n    (prod_list (map Q L) / prod_list (map Q L)) =\n    prod_list (map (R i) L) / prod_list (map (R (i - 1)) L)", "thus ?thesis"], ["proof (prove)\nusing this:\n  prod_list (map Q L) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n    (prod_list (map Q L) / prod_list (map Q L)) =\n    prod_list (map (R i) L) / prod_list (map (R (i - 1)) L)", "by simp"], ["proof (state)\nthis:\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n  (prod_list (map Q L) / prod_list (map Q L)) =\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n  (prod_list (map Q L) / prod_list (map Q L)) =\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) *\n  (prod_list (map Q L) / prod_list (map Q L)) =\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?f1 * P i i = (?f1 * pow_int (f (i - 1)) (int ?exp + int (\\<delta> (i - 1)))) * R i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) * P i i =\n    pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    pow_int (f (i - 1)) (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1))) *\n    R i i", "unfolding P_def Q_def\n      exp_pow_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    (R i i *\n     pow_int (f (i - 1)) (int (\\<delta> (i - 2) + \\<delta> (i - 1)))) =\n    pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    pow_int (f (i - 1)) (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1))) *\n    R i i", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) * P i i =\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  pow_int (f (i - 1)) (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1))) *\n  R i i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) * P i i =\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  pow_int (f (i - 1)) (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1))) *\n  R i i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?f1 * pow_int (f (i - 1)) (int ?exp + \\<delta> (i - 1)) = pow_int (f (i - 1))\n      (1 + int ?exp)\" (is \"_ = ?f1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n    pow_int (f (i - 1)) (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1))) =\n    pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2)))", "unfolding pow_int_add[OF fi0, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 1))\n     (1 - int (\\<delta> (i - 1)) +\n      (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1)))) =\n    pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2)))", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  pow_int (f (i - 1)) (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1))) =\n  pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  pow_int (f (i - 1)) (1 - int (\\<delta> (i - 1))) *\n  pow_int (f (i - 1)) (int (\\<delta> (i - 2)) + int (\\<delta> (i - 1))) =\n  pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"R i i = \\<beta> i / \\<alpha> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R i i = \\<beta> i / \\<alpha> i", "unfolding B_def R_def Fract_conv_to_fract"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<beta> i / \\<alpha> i) ^ (n (i - 1) - n (i - 1) + 1) =\n    \\<beta> i / \\<alpha> i", "by simp"], ["proof (state)\nthis:\n  R i i = \\<beta> i / \\<alpha> i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  R i i = \\<beta> i / \\<alpha> i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<alpha> i = f (i - 1) ^ Suc ?exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> i = f (i - 1) ^ Suc (\\<delta> (i - 2))", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i - 1) ^ Suc (\\<delta> (i - 2)) = f (i - 1) ^ Suc (\\<delta> (i - 2))", "by simp"], ["proof (state)\nthis:\n  \\<alpha> i = f (i - 1) ^ Suc (\\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  \\<alpha> i = f (i - 1) ^ Suc (\\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<beta> i / \\<dots> = \\<beta> i * pow_int (f (i - 1)) (- 1 - ?exp)\"\n      (is \"_ = ?\\<beta> * ?f12\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> i / f (i - 1) ^ Suc (\\<delta> (i - 2)) =\n    \\<beta> i * pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))", "unfolding exp_pow_int pow_int_divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> i * pow_int (f (i - 1)) (- int (Suc (\\<delta> (i - 2)))) =\n    \\<beta> i * pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))", "by simp"], ["proof (state)\nthis:\n  \\<beta> i / f (i - 1) ^ Suc (\\<delta> (i - 2)) =\n  \\<beta> i * pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n   (\\<beta> i * pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2))))) /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  (prod_list (map (R i) L) / prod_list (map (R (i - 1)) L))", "have \"\\<gamma> i = (?a * (?f1 * ?f12)) *  ?\\<beta> / ?f2 * (?L1 / ?L2)\""], ["proof (prove)\nusing this:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n   (\\<beta> i * pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2))))) /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  (prod_list (map (R i) L) / prod_list (map (R (i - 1)) L))\n\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n    (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n     pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))) *\n    \\<beta> i /\n    pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n    (prod_list (map (R i) L) / prod_list (map (R (i - 1)) L))", "by simp"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n   pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))) *\n  \\<beta> i /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  (prod_list (map (R i) L) / prod_list (map (R (i - 1)) L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n   pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))) *\n  \\<beta> i /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  (prod_list (map (R i) L) / prod_list (map (R (i - 1)) L))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?a * (?f1 * ?f12) = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n    (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n     pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))) =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1))", "unfolding pow_int_add[OF fi0, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n    pow_int (f (i - 1))\n     (1 + int (\\<delta> (i - 2)) + (- 1 - int (\\<delta> (i - 2)))) =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n   pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))) =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  (pow_int (f (i - 1)) (1 + int (\\<delta> (i - 2))) *\n   pow_int (f (i - 1)) (- 1 - int (\\<delta> (i - 2)))) =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?L1 / ?L2 = pow_int (\\<Prod>l\\<leftarrow>L. A l) (- ?exp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "have id: \"i - 1 - 1 = i - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 1 - 1 = i - 2", "by simp"], ["proof (state)\nthis:\n  i - 1 - 1 = i - 2\n\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "have \"set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [3..<i] \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}", "using less(3)"], ["proof (prove)\nusing this:\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. set [3..<i] \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}", "by auto"], ["proof (state)\nthis:\n  set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\n\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\n\ngoal (1 subgoal):\n 1. prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "unfolding R_def id"], ["proof (prove)\nusing this:\n  set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\n\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "proof (induct L)"], ["proof (state)\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "case (Cons l L)"], ["proof (state)\nthis:\n  set L\n  \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i} \\<Longrightarrow>\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n  set (l # L) \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "from Cons(2)"], ["proof (chain)\npicking this:\n  set (l # L) \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}", "have l: \"3 \\<le> l\" \"l \\<le> k\" \"l < i\" and L: \"set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\""], ["proof (prove)\nusing this:\n  set (l # L) \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\n\ngoal (1 subgoal):\n 1. (3 \\<le> l &&& l \\<le> k &&& l < i) &&&\n    set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}", "by auto"], ["proof (state)\nthis:\n  3 \\<le> l\n  l \\<le> k\n  l < i\n  set L \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "note IH = Cons(1)[OF L]"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "from l \\<alpha>0 \\<beta>0[of l]"], ["proof (chain)\npicking this:\n  3 \\<le> l\n  l \\<le> k\n  l < i\n  1 < ?i \\<Longrightarrow> (\\<alpha> ?i = 0) = (k < ?i - 1)\n  \\<beta> l \\<noteq> 0", "have 0: \"\\<alpha> l \\<noteq> 0\" \"\\<beta> l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  3 \\<le> l\n  l \\<le> k\n  l < i\n  1 < ?i \\<Longrightarrow> (\\<alpha> ?i = 0) = (k < ?i - 1)\n  \\<beta> l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> l \\<noteq> 0 &&& \\<beta> l \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> l \\<noteq> 0\n  \\<beta> l \\<noteq> 0\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "hence B0: \"B l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<alpha> l \\<noteq> 0\n  \\<beta> l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B l \\<noteq> 0", "unfolding B_def"], ["proof (prove)\nusing this:\n  \\<alpha> l \\<noteq> 0\n  \\<beta> l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> l / \\<alpha> l \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  B l \\<noteq> 0\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"(\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) / (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1))\n          = (B l ^ (n (l - 1) - n (i - 1) + 1) * (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1))) /\n            (B l ^ (n (l - 1) - n (i - 2) + 1) * (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)))\"\n          (is \"_ = (?l1 * ?L1) / (?l2 * ?L2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    B l ^ (n (l - 1) - n (i - 1) + 1) *\n    (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (B l ^ (n (l - 1) - n (i - 2) + 1) *\n     (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)))", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  B l ^ (n (l - 1) - n (i - 1) + 1) *\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (B l ^ (n (l - 1) - n (i - 2) + 1) *\n   (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "also"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  B l ^ (n (l - 1) - n (i - 1) + 1) *\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (B l ^ (n (l - 1) - n (i - 2) + 1) *\n   (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"\\<dots> = (?l1 / ?l2) * (?L1 / ?L2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B l ^ (n (l - 1) - n (i - 1) + 1) *\n    (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (B l ^ (n (l - 1) - n (i - 2) + 1) *\n     (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1))) =\n    B l ^ (n (l - 1) - n (i - 1) + 1) / B l ^ (n (l - 1) - n (i - 2) + 1) *\n    ((\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n     (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)))", "by simp"], ["proof (state)\nthis:\n  B l ^ (n (l - 1) - n (i - 1) + 1) *\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (B l ^ (n (l - 1) - n (i - 2) + 1) *\n   (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1))) =\n  B l ^ (n (l - 1) - n (i - 1) + 1) / B l ^ (n (l - 1) - n (i - 2) + 1) *\n  ((\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n   (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "also"], ["proof (state)\nthis:\n  B l ^ (n (l - 1) - n (i - 1) + 1) *\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (B l ^ (n (l - 1) - n (i - 2) + 1) *\n   (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1))) =\n  B l ^ (n (l - 1) - n (i - 1) + 1) / B l ^ (n (l - 1) - n (i - 2) + 1) *\n  ((\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n   (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"?L1 / ?L2 = pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "by (rule IH)"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "also"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"?l1 / ?l2 = pow_int (B l) (int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B l ^ (n (l - 1) - n (i - 1) + 1) / B l ^ (n (l - 1) - n (i - 2) + 1) =\n    pow_int (B l)\n     (int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)))", "unfolding exp_pow_int pow_int_divide pow_int_add[OF B0, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (B l)\n     (int (n (l - 1) - n (i - 1) + 1) + - int (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (B l)\n     (int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)))", "by simp"], ["proof (state)\nthis:\n  B l ^ (n (l - 1) - n (i - 1) + 1) / B l ^ (n (l - 1) - n (i - 2) + 1) =\n  pow_int (B l) (int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "also"], ["proof (state)\nthis:\n  B l ^ (n (l - 1) - n (i - 1) + 1) / B l ^ (n (l - 1) - n (i - 2) + 1) =\n  pow_int (B l) (int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) = int ?exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n    int (\\<delta> (i - 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n    int (\\<delta> (i - 2))", "have \"n (l - 1) \\<ge> n (i - 2)\" \"n (l - 1) \\<ge> n (i - 1)\" \"n (i - 2) \\<ge> n (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (i - 2) \\<le> n (l - 1) &&&\n    n (i - 1) \\<le> n (l - 1) &&& n (i - 1) \\<le> n (i - 2)", "using i l less(3)"], ["proof (prove)\nusing this:\n  4 \\<le> i\n  3 \\<le> l\n  l \\<le> k\n  l < i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. n (i - 2) \\<le> n (l - 1) &&&\n    n (i - 1) \\<le> n (l - 1) &&& n (i - 1) \\<le> n (i - 2)", "by (intro n_ge_trans, auto)+"], ["proof (state)\nthis:\n  n (i - 2) \\<le> n (l - 1)\n  n (i - 1) \\<le> n (l - 1)\n  n (i - 1) \\<le> n (i - 2)\n\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n    int (\\<delta> (i - 2))", "hence id: \"int (n (l - 1) - n (i - 1)) = int (n (l - 1)) - int (n (i - 1))\"\n                \"int (n (l - 1) - n (i - 2)) = int (n (l - 1)) - int (n (i - 2))\"\n                \"int (n (i - 2) - n (i - 1)) = int (n (i - 2)) - int (n (i - 1))\""], ["proof (prove)\nusing this:\n  n (i - 2) \\<le> n (l - 1)\n  n (i - 1) \\<le> n (l - 1)\n  n (i - 1) \\<le> n (i - 2)\n\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) = int (n (l - 1)) - int (n (i - 1)) &&&\n    int (n (l - 1) - n (i - 2)) = int (n (l - 1)) - int (n (i - 2)) &&&\n    int (n (i - 2) - n (i - 1)) = int (n (i - 2)) - int (n (i - 1))", "by simp_all"], ["proof (state)\nthis:\n  int (n (l - 1) - n (i - 1)) = int (n (l - 1)) - int (n (i - 1))\n  int (n (l - 1) - n (i - 2)) = int (n (l - 1)) - int (n (i - 2))\n  int (n (i - 2) - n (i - 1)) = int (n (i - 2)) - int (n (i - 1))\n\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n    int (\\<delta> (i - 2))", "have id2: \"int ?exp = int (n (i - 2) - n (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<delta> (i - 2)) = int (n (i - 2) - n (i - 1))", "unfolding \\<delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n (i - 2) - n (Suc (i - 2))) = int (n (i - 2) - n (i - 1))", "using i"], ["proof (prove)\nusing this:\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. int (n (i - 2) - n (Suc (i - 2))) = int (n (i - 2) - n (i - 1))", "by (cases i; cases \"i - 1\", auto)"], ["proof (state)\nthis:\n  int (\\<delta> (i - 2)) = int (n (i - 2) - n (i - 1))\n\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n    int (\\<delta> (i - 2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n    int (\\<delta> (i - 2))", "unfolding id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n    int (n (i - 2) - n (i - 1))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n (l - 1)) - int (n (i - 1)) -\n    (int (n (l - 1)) - int (n (i - 2))) =\n    int (n (i - 2)) - int (n (i - 1))", "by simp"], ["proof (state)\nthis:\n  int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n  int (\\<delta> (i - 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n  int (\\<delta> (i - 2))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "also"], ["proof (state)\nthis:\n  int (n (l - 1) - n (i - 1)) - int (n (l - 1) - n (i - 2)) =\n  int (\\<delta> (i - 2))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"pow_int (B l) \\<dots> = pow_int (inverse (B l)) (- \\<dots>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (B l) (int (\\<delta> (i - 2))) =\n    pow_int (inverse (B l)) (- int (\\<delta> (i - 2)))", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if int (\\<delta> (i - 2)) < 0\n     then 1 / B l ^ nat (- int (\\<delta> (i - 2)))\n     else B l ^ nat (int (\\<delta> (i - 2)))) =\n    (if - int (\\<delta> (i - 2)) < 0\n     then 1 / inverse (B l) ^ nat (- (- int (\\<delta> (i - 2))))\n     else inverse (B l) ^ nat (- int (\\<delta> (i - 2))))", "by (cases \"int (\\<delta> (i - 2))\" rule: linorder_cases, auto simp: field_simps)"], ["proof (state)\nthis:\n  pow_int (B l) (int (\\<delta> (i - 2))) =\n  pow_int (inverse (B l)) (- int (\\<delta> (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "also"], ["proof (state)\nthis:\n  pow_int (B l) (int (\\<delta> (i - 2))) =\n  pow_int (inverse (B l)) (- int (\\<delta> (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"inverse (B l) = A l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (B l) = A l", "unfolding B_def A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (\\<beta> l / \\<alpha> l) = \\<alpha> l / \\<beta> l", "by simp"], ["proof (state)\nthis:\n  inverse (B l) = A l\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "also"], ["proof (state)\nthis:\n  inverse (B l) = A l\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "have \"pow_int (A l) (- int ?exp) * pow_int (prod_list (map A L)) (- int ?exp)\n          = pow_int (prod_list (map A (l # L))) (- int ?exp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (A l) (- int (\\<delta> (i - 2))) *\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2))) =\n    pow_int (prod_list (map A (l # L))) (- int (\\<delta> (i - 2)))", "by (simp add: pow_int_mult)"], ["proof (state)\nthis:\n  pow_int (A l) (- int (\\<delta> (i - 2))) *\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2))) =\n  pow_int (prod_list (map A (l # L))) (- int (\\<delta> (i - 2)))\n\ngoal (2 subgoals):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))\n 2. \\<And>a L.\n       \\<lbrakk>set L\n                \\<subseteq> {l. 3 \\<le> l \\<and>\n                                l \\<le> k \\<and> l < i} \\<Longrightarrow>\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                (\\<Prod>l\\<leftarrow>L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)));\n        set (a # L)\n        \\<subseteq> {l. 3 \\<le> l \\<and> l \\<le> k \\<and> l < i}\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n                         (\\<Prod>l\\<leftarrow>a #\n        L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n                         pow_int (prod_list (map A (a # L)))\n                          (- int (\\<delta> (i - 2)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  pow_int (prod_list (map A (l # L))) (- int (\\<delta> (i - 2)))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  pow_int (prod_list (map A (l # L))) (- int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A (l # L))) (- int (\\<delta> (i - 2)))", "."], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n  (\\<Prod>l\\<leftarrow>l # L. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n  pow_int (prod_list (map A (l # L))) (- int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. set []\n    \\<subseteq> {l. 3 \\<le> l \\<and>\n                    l \\<le> k \\<and> l < i} \\<Longrightarrow>\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 1) + 1)) /\n    (\\<Prod>l\\<leftarrow>[]. B l ^ (n (l - 1) - n (i - 2) + 1)) =\n    pow_int (prod_list (map A [])) (- int (\\<delta> (i - 2)))", "qed simp"], ["proof (state)\nthis:\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  prod_list (map (R i) L) / prod_list (map (R (i - 1)) L) =\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<beta> i = (- 1) ^ (?exp + 1) * f (i - 2) * h (i - 2) ^ ?exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> i =\n    (- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 2) *\n    h (i - 2) ^ \\<delta> (i - 2)", "unfolding \\<beta>i[OF iii]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 2) *\n    h (i - 2) ^ \\<delta> (i - 2) =\n    (- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 2) *\n    h (i - 2) ^ \\<delta> (i - 2)", ".."], ["proof (state)\nthis:\n  \\<beta> i =\n  (- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 2) * h (i - 2) ^ \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 2) *\n   h (i - 2) ^ \\<delta> (i - 2)) /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "have \"\\<gamma> i =  (((- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) * (- 1) ^ (?exp + 1))) *\n      (pow_int (f (i - 2)) 1 *\n      pow_int (f (i - 2)) (int ?exp - 1)) *\n      h (i - 2) ^ ?exp /\n      (\\<Prod>l\\<leftarrow>L. A l) ^ ?exp\" (is \"_ = ?a * ?f1 * ?H / ?L\")"], ["proof (prove)\nusing this:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n  ((- 1) ^ (\\<delta> (i - 2) + 1) * f (i - 2) *\n   h (i - 2) ^ \\<delta> (i - 2)) /\n  pow_int (f (i - 2)) (1 - int (\\<delta> (i - 2))) *\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n    (- 1) ^ (\\<delta> (i - 2) + 1) *\n    (pow_int (f (i - 2)) 1 *\n     pow_int (f (i - 2)) (int (\\<delta> (i - 2)) - 1)) *\n    h (i - 2) ^ \\<delta> (i - 2) /\n    prod_list (map A L) ^ \\<delta> (i - 2)", "unfolding pow_int_divide exp_pow_int"], ["proof (prove)\nusing this:\n  \\<gamma> i =\n  pow_int (- 1) (int (\\<sigma> i + \\<sigma> (i - 1))) *\n  (pow_int (- 1) (int (\\<delta> (i - 2) + 1)) * f (i - 2) *\n   pow_int (h (i - 2)) (int (\\<delta> (i - 2)))) *\n  pow_int (f (i - 2)) (- (1 - int (\\<delta> (i - 2)))) *\n  pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    pow_int (- 1) (int (\\<sigma> i + \\<sigma> (i - 1))) *\n    pow_int (- 1) (int (\\<delta> (i - 2) + 1)) *\n    (pow_int (f (i - 2)) 1 *\n     pow_int (f (i - 2)) (int (\\<delta> (i - 2)) - 1)) *\n    pow_int (h (i - 2)) (int (\\<delta> (i - 2))) *\n    pow_int (prod_list (map A L)) (- int (\\<delta> (i - 2)))", "by simp"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) * (- 1) ^ (\\<delta> (i - 2) + 1) *\n  (pow_int (f (i - 2)) 1 *\n   pow_int (f (i - 2)) (int (\\<delta> (i - 2)) - 1)) *\n  h (i - 2) ^ \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) * (- 1) ^ (\\<delta> (i - 2) + 1) *\n  (pow_int (f (i - 2)) 1 *\n   pow_int (f (i - 2)) (int (\\<delta> (i - 2)) - 1)) *\n  h (i - 2) ^ \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?f1 = pow_int (f (i - 2)) (int ?exp)\" (is \"_ = ?f1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 2)) 1 *\n    pow_int (f (i - 2)) (int (\\<delta> (i - 2)) - 1) =\n    pow_int (f (i - 2)) (int (\\<delta> (i - 2)))", "unfolding pow_int_add[OF fi0', symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 2)) (1 + (int (\\<delta> (i - 2)) - 1)) =\n    pow_int (f (i - 2)) (int (\\<delta> (i - 2)))", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 2)) 1 * pow_int (f (i - 2)) (int (\\<delta> (i - 2)) - 1) =\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  pow_int (f (i - 2)) 1 * pow_int (f (i - 2)) (int (\\<delta> (i - 2)) - 1) =\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"h (i - 2) = (- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n      (\\<Prod>l\\<leftarrow>L. A l)\" (is \"_ = ?a2 / ?f2 * ?L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (i - 2) =\n    (- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n    prod_list (map A L)", "unfolding B_eq_17[OF iv] A_def id L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n    (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l / \\<beta> l) =\n    (- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n    (\\<Prod>l\\<leftarrow>[3..<i]. \\<alpha> l / \\<beta> l)", "by simp"], ["proof (state)\nthis:\n  h (i - 2) =\n  (- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) * prod_list (map A L)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  h (i - 2) =\n  (- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) * prod_list (map A L)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"((- (1 :: 'a fract)) ^ (\\<sigma> i + \\<sigma> (i - 1)) * (- 1) ^ (?exp + 1)) =\n      ((- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + ?exp + 1))\" (is \"_ = ?a1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) *\n    (- 1) ^ (\\<delta> (i - 2) + 1) =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1)) * (- 1) ^ (\\<delta> (i - 2) + 1) =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n   prod_list (map A L)) ^\n  \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2)", "have \"\\<gamma> i = ?a1 * ?f1 * (?a2 / ?f2 * ?L) ^ ?exp / ?L ^ ?exp\""], ["proof (prove)\nusing this:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n   prod_list (map A L)) ^\n  \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. \\<gamma> i =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n    pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n    ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n     prod_list (map A L)) ^\n    \\<delta> (i - 2) /\n    prod_list (map A L) ^ \\<delta> (i - 2)", "by simp"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n   prod_list (map A L)) ^\n  \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  \\<gamma> i =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n   prod_list (map A L)) ^\n  \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<dots> = (?a1 * ?a2^?exp) * (?f1 / ?f2 ^ ?exp) * (?L^?exp / ?L ^ ?exp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n    pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n    ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n     prod_list (map A L)) ^\n    \\<delta> (i - 2) /\n    prod_list (map A L) ^ \\<delta> (i - 2) =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n    ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) *\n    (pow_int (f (i - 2)) (int (\\<delta> (i - 2))) /\n     f (i - 2) ^ \\<delta> (i - 2)) *\n    (prod_list (map A L) ^ \\<delta> (i - 2) /\n     prod_list (map A L) ^ \\<delta> (i - 2))", "unfolding power_mult_distrib power_divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n    pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n    (((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) /\n     f (i - 2) ^ \\<delta> (i - 2) *\n     prod_list (map A L) ^ \\<delta> (i - 2)) /\n    prod_list (map A L) ^ \\<delta> (i - 2) =\n    (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n    ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) *\n    (pow_int (f (i - 2)) (int (\\<delta> (i - 2))) /\n     f (i - 2) ^ \\<delta> (i - 2)) *\n    (prod_list (map A L) ^ \\<delta> (i - 2) /\n     prod_list (map A L) ^ \\<delta> (i - 2))", "by auto"], ["proof (state)\nthis:\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n   prod_list (map A L)) ^\n  \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2) =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) *\n  (pow_int (f (i - 2)) (int (\\<delta> (i - 2))) /\n   f (i - 2) ^ \\<delta> (i - 2)) *\n  (prod_list (map A L) ^ \\<delta> (i - 2) /\n   prod_list (map A L) ^ \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1) / f (i - 2) *\n   prod_list (map A L)) ^\n  \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2) =\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) *\n  (pow_int (f (i - 2)) (int (\\<delta> (i - 2))) /\n   f (i - 2) ^ \\<delta> (i - 2)) *\n  (prod_list (map A L) ^ \\<delta> (i - 2) /\n   prod_list (map A L) ^ \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \" ?L ^ ?exp / ?L ^ ?exp = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map A L) ^ \\<delta> (i - 2) /\n    prod_list (map A L) ^ \\<delta> (i - 2) =\n    1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list (map A L) ^ \\<delta> (i - 2) /\n    prod_list (map A L) ^ \\<delta> (i - 2) =\n    1", "have \"?L \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map A L) \\<noteq> 0", "unfolding prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set (map A L)", "using L0"], ["proof (prove)\nusing this:\n  ?j3 \\<in> set L \\<Longrightarrow> Q ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> B ?j3 \\<noteq> 0\n  ?j3 \\<in> set L \\<Longrightarrow> A ?j3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set (map A L)", "by auto"], ["proof (state)\nthis:\n  prod_list (map A L) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list (map A L) ^ \\<delta> (i - 2) /\n    prod_list (map A L) ^ \\<delta> (i - 2) =\n    1", "thus ?thesis"], ["proof (prove)\nusing this:\n  prod_list (map A L) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list (map A L) ^ \\<delta> (i - 2) /\n    prod_list (map A L) ^ \\<delta> (i - 2) =\n    1", "by simp"], ["proof (state)\nthis:\n  prod_list (map A L) ^ \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod_list (map A L) ^ \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2) =\n  1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  prod_list (map A L) ^ \\<delta> (i - 2) /\n  prod_list (map A L) ^ \\<delta> (i - 2) =\n  1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?f1 / ?f2 ^ ?exp = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 2)) (int (\\<delta> (i - 2))) /\n    f (i - 2) ^ \\<delta> (i - 2) =\n    1", "unfolding exp_pow_int pow_int_divide\n      pow_int_add[OF fi0', symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f (i - 2))\n     (int (\\<delta> (i - 2)) + - int (\\<delta> (i - 2))) =\n    1", "by simp"], ["proof (state)\nthis:\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) /\n  f (i - 2) ^ \\<delta> (i - 2) =\n  1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  pow_int (f (i - 2)) (int (\\<delta> (i - 2))) /\n  f (i - 2) ^ \\<delta> (i - 2) =\n  1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?a2^?exp = (- 1) ^ ((n 1 + n (i - 2) + (i - 2) + 1) * ?exp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) =\n    (- 1) ^ ((n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))", "by (rule semiring_normalization_rules)"], ["proof (state)\nthis:\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) =\n  (- 1) ^ ((n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  ((- 1) ^ (n 1 + n (i - 2) + (i - 2) + 1)) ^ \\<delta> (i - 2) =\n  (- 1) ^ ((n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"?a1 * \\<dots> = (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + ?exp + 1 + (n 1 + n (i - 2) + (i - 2) + 1) * ?exp)\"\n      (is \"_ = _ ^ ?e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n    (- 1) ^ ((n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))", "by (simp add: power_add)"], ["proof (state)\nthis:\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  (- 1) ^ ((n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n  (- 1) ^\n  (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n   (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "also"], ["proof (state)\nthis:\n  (- 1) ^ (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1) *\n  (- 1) ^ ((n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n  (- 1) ^\n  (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n   (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "have \"\\<dots> = (-1)^0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define e where \"e = ?e\""], ["proof (state)\nthis:\n  e =\n  \\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n  (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have *: \"?e = (2 * ?exp + \\<sigma> i + \\<sigma> (i - 1) + 1 + (n 1 + n (i - 2) + (i - 2)) * ?exp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n    (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2) =\n    2 * \\<delta> (i - 2) + \\<sigma> i + \\<sigma> (i - 1) + 1 +\n    (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2)", "by simp"], ["proof (state)\nthis:\n  \\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n  (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2) =\n  2 * \\<delta> (i - 2) + \\<sigma> i + \\<sigma> (i - 1) + 1 +\n  (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define A where \"A = (\\<lambda> i l. (n (l - 2) + n (i - 1) + 1) * (n (l - 1) + n (i - 1) + 1))\""], ["proof (state)\nthis:\n  A =\n  (\\<lambda>i l. (n (l - 2) + n (i - 1) + 1) * (n (l - 1) + n (i - 1) + 1))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define B where \"B = (\\<lambda> i. (n (i - 1) + 1) * (n (i - 1) + 1))\""], ["proof (state)\nthis:\n  B = (\\<lambda>i. (n (i - 1) + 1) * (n (i - 1) + 1))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define C where \"C = (\\<lambda> l. (n (l - 1) + n (l - 2) + n (l - 1) * n (l - 2)))\""], ["proof (state)\nthis:\n  C = (\\<lambda>l. n (l - 1) + n (l - 2) + n (l - 1) * n (l - 2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define D where \"D = (\\<lambda> l. n (l - 1) + n (l - 2))\""], ["proof (state)\nthis:\n  D = (\\<lambda>l. n (l - 1) + n (l - 2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define m2 where \"m2 = n (i - 2)\""], ["proof (state)\nthis:\n  m2 = n (i - 2)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define m1 where \"m1 = n (i - 1)\""], ["proof (state)\nthis:\n  m1 = n (i - 1)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define m0 where \"m0 = n 1\""], ["proof (state)\nthis:\n  m0 = n 1\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "define i3 where \"i3 = i - 3\""], ["proof (state)\nthis:\n  i3 = i - 3\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have m12: \"m2 \\<ge> m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<le> m2", "unfolding m2_def m1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n (i - 1) \\<le> n (i - 2)", "using n_ge[of \"i - 2\"] i less(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> i - 2; i - 2 < k\\<rbrakk>\n  \\<Longrightarrow> n (Suc (i - 2)) \\<le> n (i - 2)\n  4 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. n (i - 1) \\<le> n (i - 2)", "by (cases i, auto)"], ["proof (state)\nthis:\n  m1 \\<le> m2\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have idd: \"Suc (i - 2) = i - 1\" \"i - 1 - 1 = i - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (i - 2) = i - 1 &&& i - 1 - 1 = i - 2", "using i"], ["proof (prove)\nusing this:\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. Suc (i - 2) = i - 1 &&& i - 1 - 1 = i - 2", "by auto"], ["proof (state)\nthis:\n  Suc (i - 2) = i - 1\n  i - 1 - 1 = i - 2\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have id4: \"i - 2 = Suc i3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 2 = Suc i3", "unfolding i3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 2 = Suc (i - 3)", "using i"], ["proof (prove)\nusing this:\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. i - 2 = Suc (i - 3)", "by auto"], ["proof (state)\nthis:\n  i - 2 = Suc i3\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "from i"], ["proof (chain)\npicking this:\n  4 \\<le> i", "have \"3 < i\""], ["proof (prove)\nusing this:\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. 3 < i", "by auto"], ["proof (state)\nthis:\n  3 < i\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "hence \"\\<exists> k. sum_list (map D L) = n 1 + n (i - 2) + 2 * k\""], ["proof (prove)\nusing this:\n  3 < i\n\ngoal (1 subgoal):\n 1. \\<exists>k. sum_list (map D L) = n 1 + n (i - 2) + 2 * k", "unfolding L_def"], ["proof (prove)\nusing this:\n  3 < i\n\ngoal (1 subgoal):\n 1. \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "proof (induct i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 3 < y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k.\n  sum_list (map D [3..<y]) = n 1 + n (y - 2) + 2 * k;\n        3 < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            sum_list (map D [3..<x]) =\n                            n 1 + n (x - 2) + 2 * k", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < i; 3 < ?y1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k.\n                       sum_list (map D [3..<?y1]) =\n                       n 1 + n (?y1 - 2) + 2 * k\n  3 < i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 3 < y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k.\n  sum_list (map D [3..<y]) = n 1 + n (y - 2) + 2 * k;\n        3 < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            sum_list (map D [3..<x]) =\n                            n 1 + n (x - 2) + 2 * k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "proof (cases \"i = 4\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k\n 2. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "case True"], ["proof (state)\nthis:\n  i = 4\n\ngoal (2 subgoals):\n 1. i = 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k\n 2. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 4\n\ngoal (1 subgoal):\n 1. \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "by (simp add: D_def)"], ["proof (state)\nthis:\n  \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 4\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "obtain ii where i: \"i = Suc ii\" and ii: \"ii < i\" \"3 < ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ii.\n        \\<lbrakk>i = Suc ii; ii < i; 3 < ii\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False less(2)"], ["proof (prove)\nusing this:\n  i \\<noteq> 4\n  3 < i\n\ngoal (1 subgoal):\n 1. (\\<And>ii.\n        \\<lbrakk>i = Suc ii; ii < i; 3 < ii\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases i, auto)"], ["proof (state)\nthis:\n  i = Suc ii\n  ii < i\n  3 < ii\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "from less(1)[OF ii]"], ["proof (chain)\npicking this:\n  \\<exists>k. sum_list (map D [3..<ii]) = n 1 + n (ii - 2) + 2 * k", "obtain k where IH: \"sum_list (map D [3 ..< ii]) = n 1 + n (ii - 2) + 2 * k\""], ["proof (prove)\nusing this:\n  \\<exists>k. sum_list (map D [3..<ii]) = n 1 + n (ii - 2) + 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        sum_list (map D [3..<ii]) =\n        n 1 + n (ii - 2) + 2 * k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sum_list (map D [3..<ii]) = n 1 + n (ii - 2) + 2 * k\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "have \"map D [3 ..< i] = map D [3 ..< ii] @ [D ii]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map D [3..<i] = map D [3..<ii] @ [D ii]", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map D [3..<Suc ii] = map D [3..<ii] @ [D ii]", "using ii"], ["proof (prove)\nusing this:\n  ii < i\n  3 < ii\n\ngoal (1 subgoal):\n 1. map D [3..<Suc ii] = map D [3..<ii] @ [D ii]", "by auto"], ["proof (state)\nthis:\n  map D [3..<i] = map D [3..<ii] @ [D ii]\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "hence \"sum_list (map D [3..<i]) = n 1 + n (ii - 2) + 2 * k + D ii\""], ["proof (prove)\nusing this:\n  map D [3..<i] = map D [3..<ii] @ [D ii]\n\ngoal (1 subgoal):\n 1. sum_list (map D [3..<i]) = n 1 + n (ii - 2) + 2 * k + D ii", "using IH"], ["proof (prove)\nusing this:\n  map D [3..<i] = map D [3..<ii] @ [D ii]\n  sum_list (map D [3..<ii]) = n 1 + n (ii - 2) + 2 * k\n\ngoal (1 subgoal):\n 1. sum_list (map D [3..<i]) = n 1 + n (ii - 2) + 2 * k + D ii", "by simp"], ["proof (state)\nthis:\n  sum_list (map D [3..<i]) = n 1 + n (ii - 2) + 2 * k + D ii\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "also"], ["proof (state)\nthis:\n  sum_list (map D [3..<i]) = n 1 + n (ii - 2) + 2 * k + D ii\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "have \"\\<dots> = n 1 + n (ii - 1) + 2 * (n (ii - 2) + k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n 1 + n (ii - 2) + 2 * k + D ii =\n    n 1 + n (ii - 1) + 2 * (n (ii - 2) + k)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n 1 + n (ii - 2) + 2 * k + (n (ii - 1) + n (ii - 2)) =\n    n 1 + n (ii - 1) + 2 * (n (ii - 2) + k)", "by simp"], ["proof (state)\nthis:\n  n 1 + n (ii - 2) + 2 * k + D ii = n 1 + n (ii - 1) + 2 * (n (ii - 2) + k)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "also"], ["proof (state)\nthis:\n  n 1 + n (ii - 2) + 2 * k + D ii = n 1 + n (ii - 1) + 2 * (n (ii - 2) + k)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "have \"n (ii - 1) = n (i - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n (ii - 1) = n (i - 2)", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. n (ii - 1) = n (Suc ii - 2)", "by simp"], ["proof (state)\nthis:\n  n (ii - 1) = n (i - 2)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 4 \\<Longrightarrow>\n    \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "finally"], ["proof (chain)\npicking this:\n  sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * (n (ii - 2) + k)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * (n (ii - 2) + k)\n\ngoal (1 subgoal):\n 1. \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k", "by blast"], ["proof (state)\nthis:\n  \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. sum_list (map D [3..<i]) = n 1 + n (i - 2) + 2 * k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. sum_list (map D L) = n 1 + n (i - 2) + 2 * k\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. sum_list (map D L) = n 1 + n (i - 2) + 2 * k", "obtain kk where DL: \"sum_list (map D L) = n 1 + n (i - 2) + 2 * kk\""], ["proof (prove)\nusing this:\n  \\<exists>k. sum_list (map D L) = n 1 + n (i - 2) + 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>kk.\n        sum_list (map D L) = n 1 + n (i - 2) + 2 * kk \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  sum_list (map D L) = n 1 + n (i - 2) + 2 * kk\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "let ?l = \"i - 3\""], ["proof (state)\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have len: \"length L = i - 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L = i - 3", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [3..<i] = i - 3", "using i"], ["proof (prove)\nusing this:\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. length [3..<i] = i - 3", "by auto"], ["proof (state)\nthis:\n  length L = i - 3\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have A: \"A i l = B i + D l * n (i - 1) + C l\" for i l"], ["proof (prove)\ngoal (1 subgoal):\n 1. A i l = B i + D l * n (i - 1) + C l", "unfolding A_def B_def C_def D_def ring_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. n (l - 2) * n (l - 1) + n (i - 1) * n (l - 1) + 1 * n (l - 1) +\n    (n (l - 2) * n (i - 1) + n (i - 1) * n (i - 1) + 1 * n (i - 1)) +\n    (n (l - 2) * 1 + n (i - 1) * 1 + 1 * 1) =\n    n (i - 1) * n (i - 1) + 1 * n (i - 1) + (n (i - 1) * 1 + 1 * 1) +\n    (n (l - 1) * n (i - 1) + n (l - 2) * n (i - 1)) +\n    (n (l - 1) + n (l - 2) + n (l - 1) * n (l - 2))", "by simp"], ["proof (state)\nthis:\n  A ?i1 ?l1 = B ?i1 + D ?l1 * n (?i1 - 1) + C ?l1\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have id2: \"[3..<Suc i] = 3 # [Suc 3 ..< Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [3..<Suc i] = 3 # [Suc 3..<Suc i]", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [3..<Suc i] = 3 # [Suc 3..<Suc i]", "using i"], ["proof (prove)\nusing this:\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. [3..<Suc i] = 3 # [Suc 3..<Suc i]", "by (auto simp: upt_rec[of 3])"], ["proof (state)\nthis:\n  [3..<Suc i] = 3 # [Suc 3..<Suc i]\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"even e = even ?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even e =\n    even\n     (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n      (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n      (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    even\n     (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n      (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))", "by simp"], ["proof (state)\nthis:\n  even e =\n  even\n   (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n    (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  even e =\n  even\n   (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n    (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"\\<dots> = even ((1 + (n 1 + n (i - 2) + (i - 2)) * ?exp) + (\\<sigma> i + \\<sigma> (i - 1)))\"\n        (is \"_ = even (?g + ?j)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n      (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    even\n     (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n      (\\<sigma> i + \\<sigma> (i - 1)))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     (2 * \\<delta> (i - 2) + \\<sigma> i + \\<sigma> (i - 1) + 1 +\n      (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2)) =\n    even\n     (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n      (\\<sigma> i + \\<sigma> (i - 1)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  even\n   (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n    (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (\\<sigma> i + \\<sigma> (i - 1)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  even\n   (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n    (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (\\<sigma> i + \\<sigma> (i - 1)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"?j = (\\<Sum>l\\<leftarrow>L @ [i]. A i l) + (\\<Sum>l\\<leftarrow>L. A (i - 1) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i + \\<sigma> (i - 1) =\n    sum_list (map (A i) (L @ [i])) + sum_list (map (A (i - 1)) L)", "unfolding \\<sigma>_def id A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>L @\n                        [i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) +\n    (\\<Sum>l\\<leftarrow>L. (n (l - 2) + n (i - 1 - 1) + 1) *\n                           (n (l - 1) + n (i - 1 - 1) + 1)) =\n    (\\<Sum>l\\<leftarrow>L @\n                        [i]. (n (l - 2) + n (i - 1) + 1) *\n                             (n (l - 1) + n (i - 1) + 1)) +\n    (\\<Sum>l\\<leftarrow>L. (n (l - 2) + n (i - 1 - 1) + 1) *\n                           (n (l - 1) + n (i - 1 - 1) + 1))", "by simp"], ["proof (state)\nthis:\n  \\<sigma> i + \\<sigma> (i - 1) =\n  sum_list (map (A i) (L @ [i])) + sum_list (map (A (i - 1)) L)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  \\<sigma> i + \\<sigma> (i - 1) =\n  sum_list (map (A i) (L @ [i])) + sum_list (map (A (i - 1)) L)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"\\<dots> = 2 * (\\<Sum>l\\<leftarrow>L. C l) + (Suc ?l) * B i + (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) + C i +\n          ?l * B (i - 1) + (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (A i) (L @ [i])) + sum_list (map (A (i - 1)) L) =\n    2 * sum_list (map C L) + Suc (i - 3) * B i +\n    (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n    C i +\n    (i - 3) * B (i - 1) +\n    (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1))", "unfolding A sum_list_addf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>L @ [i]. B i) +\n    (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n    sum_list (map C (L @ [i])) +\n    ((\\<Sum>l\\<leftarrow>L. B (i - 1)) +\n     (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1)) +\n     sum_list (map C L)) =\n    2 * sum_list (map C L) + Suc (i - 3) * B i +\n    (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n    C i +\n    (i - 3) * B (i - 1) +\n    (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1))", "by (simp add: sum_list_triv len)"], ["proof (state)\nthis:\n  sum_list (map (A i) (L @ [i])) + sum_list (map (A (i - 1)) L) =\n  2 * sum_list (map C L) + Suc (i - 3) * B i +\n  (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n  C i +\n  (i - 3) * B (i - 1) +\n  (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  sum_list (map (A i) (L @ [i])) + sum_list (map (A (i - 1)) L) =\n  2 * sum_list (map C L) + Suc (i - 3) * B i +\n  (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n  C i +\n  (i - 3) * B (i - 1) +\n  (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"\\<dots> = ((Suc ?l * B i + C i +\n          ?l * B (i - 1) + D i * n (i - 1)) + ((\\<Sum>l\\<leftarrow>L. D l) * (n (i - 1) + n (i - 2)) + 2 * (\\<Sum>l\\<leftarrow>L. C l)))\"\n        (is \"_ = ?i + ?j\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * sum_list (map C L) + Suc (i - 3) * B i +\n    (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n    C i +\n    (i - 3) * B (i - 1) +\n    (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1)) =\n    Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1) +\n    (sum_list (map D L) * (n (i - 1) + n (i - 2)) + 2 * sum_list (map C L))", "unfolding sum_list_mult_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * sum_list (map C L) + Suc (i - 3) * B i +\n    sum_list (map D (L @ [i])) * n (i - 1) +\n    C i +\n    (i - 3) * B (i - 1) +\n    sum_list (map D L) * n (i - 1 - 1) =\n    Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1) +\n    (sum_list (map D L) * (n (i - 1) + n (i - 2)) + 2 * sum_list (map C L))", "by (simp add: ring_distribs numeral_2_eq_2)"], ["proof (state)\nthis:\n  2 * sum_list (map C L) + Suc (i - 3) * B i +\n  (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n  C i +\n  (i - 3) * B (i - 1) +\n  (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1)) =\n  Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1) +\n  (sum_list (map D L) * (n (i - 1) + n (i - 2)) + 2 * sum_list (map C L))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  2 * sum_list (map C L) + Suc (i - 3) * B i +\n  (\\<Sum>l\\<leftarrow>L @ [i]. D l * n (i - 1)) +\n  C i +\n  (i - 3) * B (i - 1) +\n  (\\<Sum>l\\<leftarrow>L. D l * n (i - 1 - 1)) =\n  Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1) +\n  (sum_list (map D L) * (n (i - 1) + n (i - 2)) + 2 * sum_list (map C L))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"?j =\n          (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) + 2 * (kk * (n (i - 1) + n (i - 2)) + (\\<Sum>l\\<leftarrow>L. C l))\"\n        (is \"_ = ?h + 2 * ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map D L) * (n (i - 1) + n (i - 2)) + 2 * sum_list (map C L) =\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n    2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L))", "unfolding DL"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n 1 + n (i - 2) + 2 * kk) * (n (i - 1) + n (i - 2)) +\n    2 * sum_list (map C L) =\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n    2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L))", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  sum_list (map D L) * (n (i - 1) + n (i - 2)) + 2 * sum_list (map C L) =\n  (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n  2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "finally"], ["proof (chain)\npicking this:\n  even e =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1) +\n     ((n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n      2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L)))))", "have \"even e = even (?g + ?i + ?h + 2 * ?f)\""], ["proof (prove)\nusing this:\n  even e =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1) +\n     ((n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n      2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L)))))\n\ngoal (1 subgoal):\n 1. even e =\n    even\n     (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n      (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n      (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n      2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L)))", "by presburger"], ["proof (state)\nthis:\n  even e =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n    2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  even e =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n    2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"\\<dots> = even (?g + ?i + ?h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n      (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n      (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n      2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L))) =\n    even\n     (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n      (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n      (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)))", "by presburger"], ["proof (state)\nthis:\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n    2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L))) =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) +\n    2 * (kk * (n (i - 1) + n (i - 2)) + sum_list (map C L))) =\n  even\n   (1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"?g + ?i + ?h =\n         i3 * (m2 - m1 + m1 * m1 + m2 * m2)\n         + (m2 - m1 + m1 + m2) * (m0 + m2)\n         + (m1 + m2 + (m2 - m1))\n         + 2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n    (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n    (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) =\n    i3 * (m2 - m1 + m1 * m1 + m2 * m2) + (m2 - m1 + m1 + m2) * (m0 + m2) +\n    (m1 + m2 + (m2 - m1)) +\n    2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3)", "unfolding idd B_def D_def C_def \\<delta>\n        m1_def[symmetric] m2_def[symmetric] m0_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (m0 + m2 + (i - 2)) * (m2 - m1) +\n    (Suc (i - 3) * ((m1 + 1) * (m1 + 1)) + (m1 + m2 + m1 * m2) +\n     (i - 3) * ((m2 + 1) * (m2 + 1)) +\n     (m1 + m2) * m1) +\n    (m0 + m2) * (m1 + m2) =\n    i3 * (m2 - m1 + m1 * m1 + m2 * m2) + (m2 - m1 + m1 + m2) * (m0 + m2) +\n    (m1 + m2 + (m2 - m1)) +\n    2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3)", "unfolding i3_def[symmetric] id4"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (m0 + m2 + Suc i3) * (m2 - m1) +\n    (Suc i3 * ((m1 + 1) * (m1 + 1)) + (m1 + m2 + m1 * m2) +\n     i3 * ((m2 + 1) * (m2 + 1)) +\n     (m1 + m2) * m1) +\n    (m0 + m2) * (m1 + m2) =\n    i3 * (m2 - m1 + m1 * m1 + m2 * m2) + (m2 - m1 + m1 + m2) * (m0 + m2) +\n    (m1 + m2 + (m2 - m1)) +\n    2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n  (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n  (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) =\n  i3 * (m2 - m1 + m1 * m1 + m2 * m2) + (m2 - m1 + m1 + m2) * (m0 + m2) +\n  (m1 + m2 + (m2 - m1)) +\n  2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  1 + (n 1 + n (i - 2) + (i - 2)) * \\<delta> (i - 2) +\n  (Suc (i - 3) * B i + C i + (i - 3) * B (i - 1) + D i * n (i - 1)) +\n  (n 1 + n (i - 2)) * (n (i - 1) + n (i - 2)) =\n  i3 * (m2 - m1 + m1 * m1 + m2 * m2) + (m2 - m1 + m1 + m2) * (m0 + m2) +\n  (m1 + m2 + (m2 - m1)) +\n  2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"(m1 + m2 + (m2 - m1)) = 2 * m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 + m2 + (m2 - m1) = 2 * m2", "using m12"], ["proof (prove)\nusing this:\n  m1 \\<le> m2\n\ngoal (1 subgoal):\n 1. m1 + m2 + (m2 - m1) = 2 * m2", "by simp"], ["proof (state)\nthis:\n  m1 + m2 + (m2 - m1) = 2 * m2\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  m1 + m2 + (m2 - m1) = 2 * m2\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"(m2 - m1 + m1 + m2) * (m0 + m2) = 2 * (m2 * (m0 + m2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m2 - m1 + m1 + m2) * (m0 + m2) = 2 * (m2 * (m0 + m2))", "using m12"], ["proof (prove)\nusing this:\n  m1 \\<le> m2\n\ngoal (1 subgoal):\n 1. (m2 - m1 + m1 + m2) * (m0 + m2) = 2 * (m2 * (m0 + m2))", "by simp"], ["proof (state)\nthis:\n  (m2 - m1 + m1 + m2) * (m0 + m2) = 2 * (m2 * (m0 + m2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "finally"], ["proof (chain)\npicking this:\n  even e =\n  even\n   (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * (m2 * (m0 + m2)) + 2 * m2 +\n    2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3))", "obtain l1 l2 l3 where\n        \"even e = even (i3 * (m2 - m1 + m1 * m1 + m2 * m2)  + 2 * l1 + 2 * l2 + 2 * l3)\""], ["proof (prove)\nusing this:\n  even e =\n  even\n   (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * (m2 * (m0 + m2)) + 2 * m2 +\n    2 * (m1 * m2 + m1 * m1 + 1 + i3 + m1 * Suc i3 + m2 * i3))\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2 l3.\n        even e =\n        even\n         (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * l1 + 2 * l2 +\n          2 * l3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  even e =\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * l1 + 2 * l2 + 2 * l3)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  even e =\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * l1 + 2 * l2 + 2 * l3)\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"\\<dots> = even (i3 * (m2 - m1 + m1 * m1 + m2 * m2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * l1 + 2 * l2 + 2 * l3) =\n    even (i3 * (m2 - m1 + m1 * m1 + m2 * m2))", "by simp"], ["proof (state)\nthis:\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * l1 + 2 * l2 + 2 * l3) =\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2) + 2 * l1 + 2 * l2 + 2 * l3) =\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"\\<dots> = even (i3 * (2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (i3 * (m2 - m1 + m1 * m1 + m2 * m2)) =\n    even (i3 * (2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2)))", "by simp"], ["proof (state)\nthis:\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2)) =\n  even (i3 * (2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  even (i3 * (m2 - m1 + m1 * m1 + m2 * m2)) =\n  even (i3 * (2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2)))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2) = m1 + m2 + m1 * m1 + m2 * m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2) = m1 + m2 + m1 * m1 + m2 * m2", "using m12"], ["proof (prove)\nusing this:\n  m1 \\<le> m2\n\ngoal (1 subgoal):\n 1. 2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2) = m1 + m2 + m1 * m1 + m2 * m2", "by simp"], ["proof (state)\nthis:\n  2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2) = m1 + m2 + m1 * m1 + m2 * m2\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "also"], ["proof (state)\nthis:\n  2 * m1 + (m2 - m1 + m1 * m1 + m2 * m2) = m1 + m2 + m1 * m1 + m2 * m2\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "have \"even (i3 * \\<dots>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (i3 * (m1 + m2 + m1 * m1 + m2 * m2))", "by auto"], ["proof (state)\nthis:\n  even (i3 * (m1 + m2 + m1 * m1 + m2 * m2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "finally"], ["proof (chain)\npicking this:\n  even e", "have \"even e\""], ["proof (prove)\nusing this:\n  even e\n\ngoal (1 subgoal):\n 1. even e", "."], ["proof (state)\nthis:\n  even e\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  even e\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "unfolding e_def"], ["proof (prove)\nusing this:\n  even\n   (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n    (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2))\n\ngoal (1 subgoal):\n 1. (- 1) ^\n    (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n     (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n    (- 1) ^ 0", "by (intro minus_1_even_eqI, auto)"], ["proof (state)\nthis:\n  (- 1) ^\n  (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n   (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n  (- 1) ^ 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (- 1) ^\n  (\\<sigma> i + \\<sigma> (i - 1) + \\<delta> (i - 2) + 1 +\n   (n 1 + n (i - 2) + (i - 2) + 1) * \\<delta> (i - 2)) =\n  (- 1) ^ 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 3 \\<Longrightarrow> \\<gamma> i = 1", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> i = (- 1) ^ 0 * 1 * 1", "show \"\\<gamma> i = 1\""], ["proof (prove)\nusing this:\n  \\<gamma> i = (- 1) ^ 0 * 1 * 1\n\ngoal (1 subgoal):\n 1. \\<gamma> i = 1", "by simp"], ["proof (state)\nthis:\n  \\<gamma> i = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<gamma> i = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes i :: nat\n  assumes i: \"3 \\<le> i\" \"i \\<le> k\"\nbegin"], ["", "lemma B_theorem_3_b: \"\\<Theta> i * f i = ff (lead_coeff (H i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta> i * f i = ff (lead_coeff (H i))", "using arg_cong[OF fundamental_theorem_eq_6[folded H_def, OF i], of lead_coeff]"], ["proof (prove)\nusing this:\n  lead_coeff (ffp (H i)) = lead_coeff (Polynomial.smult (\\<Theta> i) (F i))\n\ngoal (1 subgoal):\n 1. \\<Theta> i * f i = ff (lead_coeff (H i))", "unfolding f[of i]\n  lead_coeff_smult"], ["proof (prove)\nusing this:\n  lead_coeff (ffp (H i)) = \\<Theta> i * lead_coeff (F i)\n\ngoal (1 subgoal):\n 1. \\<Theta> i * lead_coeff (F i) = ff (lead_coeff (H i))", "by simp"], ["", "lemma B_theorem_3_main: \"\\<Theta> i * f i / \\<gamma> (i + 1) = (-1)^(n 1 + n i + i + 1) / f i * (\\<Prod>l\\<leftarrow>[3..< Suc (Suc i)]. (\\<alpha> l / \\<beta> l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "proof (cases \"f i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f i = 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n 2. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "case True"], ["proof (state)\nthis:\n  f i = 0\n\ngoal (2 subgoals):\n 1. f i = 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n 2. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f i = 0\n\ngoal (1 subgoal):\n 1. \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "by simp"], ["proof (state)\nthis:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "case False"], ["proof (state)\nthis:\n  f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "note ff0 = this"], ["proof (state)\nthis:\n  f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "from i(1)"], ["proof (chain)\npicking this:\n  3 \\<le> i", "have \"Suc (Suc i) > 3\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. 3 < Suc (Suc i)", "by auto"], ["proof (state)\nthis:\n  3 < Suc (Suc i)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "hence id: \"[3 ..< Suc (i + 1)] = [3 ..< Suc i] @ [Suc i]\" \"[3 ..< Suc (Suc i)] = [3 ..< Suc i] @ [Suc i]\""], ["proof (prove)\nusing this:\n  3 < Suc (Suc i)\n\ngoal (1 subgoal):\n 1. [3..<Suc (i + 1)] = [3..<Suc i] @ [Suc i] &&&\n    [3..<Suc (Suc i)] = [3..<Suc i] @ [Suc i]", "by auto"], ["proof (state)\nthis:\n  [3..<Suc (i + 1)] = [3..<Suc i] @ [Suc i]\n  [3..<Suc (Suc i)] = [3..<Suc i] @ [Suc i]\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have cong: \"\\<And> a b c d. a = c \\<Longrightarrow> b = d \\<Longrightarrow> a * b = c * (d :: 'a fract)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = c; b = d\\<rbrakk> \\<Longrightarrow> a * b = c * d", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a1 = ?c1; ?b1 = ?d1\\<rbrakk>\n  \\<Longrightarrow> ?a1 * ?b1 = ?c1 * ?d1\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "define AB where \"AB = (\\<lambda> l. \\<beta> l / \\<alpha> l)\""], ["proof (state)\nthis:\n  AB = (\\<lambda>l. \\<beta> l / \\<alpha> l)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "define ABP where \"ABP = (\\<lambda> l. AB l ^ (n (l - 1) - n i) * f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)))\""], ["proof (state)\nthis:\n  ABP =\n  (\\<lambda>l.\n      AB l ^ (n (l - 1) - n i) *\n      f (l - 1) ^ (\\<delta> (l - 2) + \\<delta> (l - 1)))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "define PR where \"PR = (\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l)\""], ["proof (state)\nthis:\n  PR = prod_list (map ABP [3..<Suc i])\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "define PR2 where \"PR2 = (\\<Prod>l\\<leftarrow>[3..<Suc i]. AB l)\""], ["proof (state)\nthis:\n  PR2 = prod_list (map AB [3..<Suc i])\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "from F0[of i]"], ["proof (chain)\npicking this:\n  i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)", "have \"\\<Theta> i * f i / \\<gamma> (i + 1) = (\n  ((- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1)) * (pow_int (f i) (int (\\<delta> (i - 1)) - 1) *\n    PR * f i /\n    pow_int (f i) (1 - int (\\<delta> i)) / ((\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) *\n        AB (Suc i) * f i ^ (\\<delta> (i - 1) + \\<delta> i))))\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n\ngoal (1 subgoal):\n 1. \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) *\n    (pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n     pow_int (f i) (1 - int (\\<delta> i)) /\n     ((\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) * AB (Suc i) *\n      f i ^ (\\<delta> (i - 1) + \\<delta> i)))", "unfolding id prod_list.append map_append \\<Theta>_def \\<gamma>_def divide_prod_assoc"], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n\ngoal (1 subgoal):\n 1. (- 1) ^ \\<tau> i * pow_int (f i) (int (\\<delta> (i - 1)) - 1) *\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n i) *\n                                  f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) *\n    f i /\n    (- 1) ^ \\<sigma> (i + 1) /\n    pow_int (f (i + 1 - 1)) (1 - int (\\<delta> (i + 1 - 1))) /\n    (\\<Prod>l\\<leftarrow>[3..<\n                          Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i + 1 - 1) + 1) *\n                                  f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) /\n    (\\<Prod>l\\<leftarrow>[Suc i]. (\\<beta> l / \\<alpha> l) ^\n                                  (n (l - 1) - n (i + 1 - 1) + 1) *\n                                  f (l - 1) ^\n                                  (\\<delta> (l - 2) + \\<delta> (l - 1))) =\n    (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) *\n    (pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n     pow_int (f i) (1 - int (\\<delta> i)) /\n     (\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) /\n     AB (Suc i) /\n     f i ^ (\\<delta> (i - 1) + \\<delta> i))", "by (simp add: field_simps power_add AB_def ABP_def PR_def)"], ["proof (state)\nthis:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) *\n  (pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n   pow_int (f i) (1 - int (\\<delta> i)) /\n   ((\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) * AB (Suc i) *\n    f i ^ (\\<delta> (i - 1) + \\<delta> i)))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) *\n  (pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n   pow_int (f i) (1 - int (\\<delta> i)) /\n   ((\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) * AB (Suc i) *\n    f i ^ (\\<delta> (i - 1) + \\<delta> i)))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"(- 1 :: 'a fract) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) = (- 1) ^ (\\<tau> i + \\<sigma> (i + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) =\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1))", "unfolding power_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) =\n    (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) =\n  (- 1) ^ (\\<tau> i + \\<sigma> (i + 1))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  (- 1) ^ \\<tau> i * (- 1) ^ \\<sigma> (i + 1) =\n  (- 1) ^ (\\<tau> i + \\<sigma> (i + 1))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"\\<dots> = (- 1) ^ (n 1 + n i + i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "proof (cases \"i = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "case True"], ["proof (state)\nthis:\n  i = 2\n\ngoal (2 subgoals):\n 1. i = 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)\n 2. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "unfolding \\<tau>_def \\<sigma>_def True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^\n    ((\\<Sum>l\\<leftarrow>[3..<\n                          Suc 2]. (n (l - 2) + n 2) * (n (l - 1) + n 2)) +\n     (\\<Sum>l\\<leftarrow>[3..<\n                          Suc (2 +\n                               1)]. (n (l - 2) + n (2 + 1 - 1) + 1) *\n                                    (n (l - 1) + n (2 + 1 - 1) + 1))) =\n    (- 1) ^ (n 1 + n 2 + 2 + 1)", "by (auto, rule minus_1_even_eqI, auto)"], ["proof (state)\nthis:\n  (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 2\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "define a where \"a = (\\<lambda> l. n (l - 2) + n i)\""], ["proof (state)\nthis:\n  a = (\\<lambda>l. n (l - 2) + n i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "define b where \"b = (\\<lambda> l. n (l - 1) + n i)\""], ["proof (state)\nthis:\n  b = (\\<lambda>l. n (l - 1) + n i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "define c where \"c = (\\<Sum>l\\<leftarrow>[3..<Suc i]. (a l * b l + n i))\""], ["proof (state)\nthis:\n  c = (\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l + n i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "define d where \"d = c + (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1))\""], ["proof (state)\nthis:\n  d = c + (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "define e where \"e = (n (i - 1) + n i + 1) * n i\""], ["proof (state)\nthis:\n  e = (n (i - 1) + n i + 1) * n i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"(\\<tau> i + \\<sigma> (i + 1)) =\n      ((\\<Sum>l\\<leftarrow>[3..<Suc i]. (a l * b l) + (a l + 1) * (b l + 1))) + (a (Suc i) + 1) * (b (Suc i) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i + \\<sigma> (i + 1) =\n    (\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l + (a l + 1) * (b l + 1)) +\n    (a (Suc i) + 1) * (b (Suc i) + 1)", "unfolding \\<sigma>_def \\<tau>_def id a_def b_def sum_list_addf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<\n                         Suc i]. (n (l - 2) + n i) * (n (l - 1) + n i)) +\n    (\\<Sum>l\\<leftarrow>[3..<Suc i] @\n                        [Suc i]. (n (l - 2) + n (i + 1 - 1) + 1) *\n                                 (n (l - 1) + n (i + 1 - 1) + 1)) =\n    (\\<Sum>l\\<leftarrow>[3..<\n                         Suc i]. (n (l - 2) + n i) * (n (l - 1) + n i)) +\n    (\\<Sum>l\\<leftarrow>[3..<\n                         Suc i]. (n (l - 2) + n i + 1) *\n                                 (n (l - 1) + n i + 1)) +\n    (n (Suc i - 2) + n i + 1) * (n (Suc i - 1) + n i + 1)", "by simp"], ["proof (state)\nthis:\n  \\<tau> i + \\<sigma> (i + 1) =\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l + (a l + 1) * (b l + 1)) +\n  (a (Suc i) + 1) * (b (Suc i) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  \\<tau> i + \\<sigma> (i + 1) =\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l + (a l + 1) * (b l + 1)) +\n  (a (Suc i) + 1) * (b (Suc i) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"(\\<Sum>l\\<leftarrow>[3..<Suc i]. (a l * b l) + (a l + 1) * (b l + 1)) =\n       (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * a l * b l + (a l + b l) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l + (a l + 1) * (b l + 1)) =\n    (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * a l * b l + (a l + b l) + 1)", "by (rule arg_cong, rule map_cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l + (a l + 1) * (b l + 1)) =\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * a l * b l + (a l + b l) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l + (a l + 1) * (b l + 1)) =\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * a l * b l + (a l + b l) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"\\<dots> = (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * (a l * b l + n i) + (n (l - 1) + n (l - 2)) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * a l * b l + (a l + b l) + 1) =\n    (\\<Sum>l\\<leftarrow>[3..<\n                         Suc i]. 2 * (a l * b l + n i) +\n                                 (n (l - 1) + n (l - 2)) +\n                                 1)", "by (simp add: field_simps a_def b_def)"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * a l * b l + (a l + b l) + 1) =\n  (\\<Sum>l\\<leftarrow>[3..<\n                       Suc i]. 2 * (a l * b l + n i) +\n                               (n (l - 1) + n (l - 2)) +\n                               1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. 2 * a l * b l + (a l + b l) + 1) =\n  (\\<Sum>l\\<leftarrow>[3..<\n                       Suc i]. 2 * (a l * b l + n i) +\n                               (n (l - 1) + n (l - 2)) +\n                               1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"\\<dots> = 2 * c + (\\<Sum>l\\<leftarrow>[3..<Suc i]. (n (l - 1) + n (l - 2))) + length [3 ..< Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<\n                         Suc i]. 2 * (a l * b l + n i) +\n                                 (n (l - 1) + n (l - 2)) +\n                                 1) =\n    2 * c + (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1) + n (l - 2)) +\n    length [3..<Suc i]", "unfolding sum_list_addf c_def sum_list_const_mult sum_list_triv"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    ((\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l) +\n     of_nat (length [3..<Suc i]) * n i) +\n    ((\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) +\n     (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2))) +\n    of_nat (length [3..<Suc i]) * 1 =\n    2 *\n    ((\\<Sum>l\\<leftarrow>[3..<Suc i]. a l * b l) +\n     of_nat (length [3..<Suc i]) * n i) +\n    ((\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) +\n     (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2))) +\n    length [3..<Suc i]", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<\n                       Suc i]. 2 * (a l * b l + n i) +\n                               (n (l - 1) + n (l - 2)) +\n                               1) =\n  2 * c + (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1) + n (l - 2)) +\n  length [3..<Suc i]\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<\n                       Suc i]. 2 * (a l * b l + n i) +\n                               (n (l - 1) + n (l - 2)) +\n                               1) =\n  2 * c + (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1) + n (l - 2)) +\n  length [3..<Suc i]\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"(\\<Sum>l\\<leftarrow>[3..<Suc i]. (n (l - 1) + n (l - 2)))\n      = (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) + (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1) + n (l - 2)) =\n    (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) +\n    (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2))", "by (simp add: sum_list_addf)"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1) + n (l - 2)) =\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) +\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1) + n (l - 2)) =\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) +\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"(\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2)) = (\\<Sum>l\\<leftarrow>3 # [4..<Suc i]. n (l - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2)) =\n    (\\<Sum>l\\<leftarrow>3 # [4..<Suc i]. n (l - 2))", "by (rule arg_cong, rule map_cong, insert i False, auto simp: upt_rec[of 3])"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2)) =\n  (\\<Sum>l\\<leftarrow>3 # [4..<Suc i]. n (l - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 2)) =\n  (\\<Sum>l\\<leftarrow>3 # [4..<Suc i]. n (l - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"\\<dots> = n 1 + (\\<Sum>l\\<leftarrow>[(Suc 3)..<Suc i]. n (l - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>3 # [4..<Suc i]. n (l - 2)) =\n    n 1 + (\\<Sum>l\\<leftarrow>[Suc 3..<Suc i]. n (l - 2))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>3 # [4..<Suc i]. n (l - 2)) =\n  n 1 + (\\<Sum>l\\<leftarrow>[Suc 3..<Suc i]. n (l - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>3 # [4..<Suc i]. n (l - 2)) =\n  n 1 + (\\<Sum>l\\<leftarrow>[Suc 3..<Suc i]. n (l - 2))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"(\\<Sum>l\\<leftarrow>[(Suc 3)..<Suc i]. n (l - 2)) = (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[Suc 3..<Suc i]. n (l - 2)) =\n    (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1))", "proof (rule arg_cong[of _ _ sum_list], rule nth_equalityI, force, auto simp: nth_append, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia < Suc (i - 4); \\<not> ia < i - 4; 4 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> n (i - 2) = n (Suc (Suc ia))", "case (1 j)"], ["proof (state)\nthis:\n  j < Suc (i - 4)\n  \\<not> j < i - 4\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia < Suc (i - 4); \\<not> ia < i - 4; 4 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> n (i - 2) = n (Suc (Suc ia))", "hence \"i - 2 = Suc (Suc j)\""], ["proof (prove)\nusing this:\n  j < Suc (i - 4)\n  \\<not> j < i - 4\n  4 \\<le> i\n\ngoal (1 subgoal):\n 1. i - 2 = Suc (Suc j)", "by simp"], ["proof (state)\nthis:\n  i - 2 = Suc (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia < Suc (i - 4); \\<not> ia < i - 4; 4 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> n (i - 2) = n (Suc (Suc ia))", "thus ?case"], ["proof (prove)\nusing this:\n  i - 2 = Suc (Suc j)\n\ngoal (1 subgoal):\n 1. n (i - 2) = n (Suc (Suc j))", "by simp"], ["proof (state)\nthis:\n  n (i - 2) = n (Suc (Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[Suc 3..<Suc i]. n (l - 2)) =\n  (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[Suc 3..<Suc i]. n (l - 2)) =\n  (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"(\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) = (\\<Sum>l\\<leftarrow>[3..<i] @ [i]. n (l - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) =\n    (\\<Sum>l\\<leftarrow>[3..<i] @ [i]. n (l - 1))", "by (rule arg_cong, rule map_cong, insert i False, auto)"], ["proof (state)\nthis:\n  (\\<Sum>l\\<leftarrow>[3..<Suc i]. n (l - 1)) =\n  (\\<Sum>l\\<leftarrow>[3..<i] @ [i]. n (l - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "finally"], ["proof (chain)\npicking this:\n  \\<tau> i + \\<sigma> (i + 1) =\n  2 * c +\n  ((\\<Sum>l\\<leftarrow>[3..<i] @ [i]. n (l - 1)) +\n   (n 1 + (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1)))) +\n  length [3..<Suc i] +\n  (a (Suc i) + 1) * (b (Suc i) + 1)", "have \"\\<tau> i + \\<sigma> (i + 1) =\n      2 * d + n (i - 1) + n 1 +  length [3..<Suc i] + (a (Suc i) + 1) * (b (Suc i) + 1)\""], ["proof (prove)\nusing this:\n  \\<tau> i + \\<sigma> (i + 1) =\n  2 * c +\n  ((\\<Sum>l\\<leftarrow>[3..<i] @ [i]. n (l - 1)) +\n   (n 1 + (\\<Sum>l\\<leftarrow>[3..<i]. n (l - 1)))) +\n  length [3..<Suc i] +\n  (a (Suc i) + 1) * (b (Suc i) + 1)\n\ngoal (1 subgoal):\n 1. \\<tau> i + \\<sigma> (i + 1) =\n    2 * d + n (i - 1) + n 1 + length [3..<Suc i] +\n    (a (Suc i) + 1) * (b (Suc i) + 1)", "by (simp add: d_def)"], ["proof (state)\nthis:\n  \\<tau> i + \\<sigma> (i + 1) =\n  2 * d + n (i - 1) + n 1 + length [3..<Suc i] +\n  (a (Suc i) + 1) * (b (Suc i) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  \\<tau> i + \\<sigma> (i + 1) =\n  2 * d + n (i - 1) + n 1 + length [3..<Suc i] +\n  (a (Suc i) + 1) * (b (Suc i) + 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"length [3 ..< Suc i] = i - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [3..<Suc i] = i - 2", "using i"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. length [3..<Suc i] = i - 2", "by auto"], ["proof (state)\nthis:\n  length [3..<Suc i] = i - 2\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "also"], ["proof (state)\nthis:\n  length [3..<Suc i] = i - 2\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "have \"(a (Suc i) + 1) * (b (Suc i) + 1) = 2 * e + n (i - 1) + n i + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a (Suc i) + 1) * (b (Suc i) + 1) = 2 * e + n (i - 1) + n i + 1", "unfolding a_def b_def e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n (Suc i - 2) + n i + 1) * (n (Suc i - 1) + n i + 1) =\n    2 * ((n (i - 1) + n i + 1) * n i) + n (i - 1) + n i + 1", "by simp"], ["proof (state)\nthis:\n  (a (Suc i) + 1) * (b (Suc i) + 1) = 2 * e + n (i - 1) + n i + 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "finally"], ["proof (chain)\npicking this:\n  \\<tau> i + \\<sigma> (i + 1) =\n  2 * d + n (i - 1) + n 1 + (i - 2) + (2 * e + n (i - 1) + n i + 1)", "have id: \"\\<tau> i + \\<sigma> (i + 1) = 2 * (d + n (i - 1) + e) + n 1 + (i - 2) + n i + 1\""], ["proof (prove)\nusing this:\n  \\<tau> i + \\<sigma> (i + 1) =\n  2 * d + n (i - 1) + n 1 + (i - 2) + (2 * e + n (i - 1) + n i + 1)\n\ngoal (1 subgoal):\n 1. \\<tau> i + \\<sigma> (i + 1) =\n    2 * (d + n (i - 1) + e) + n 1 + (i - 2) + n i + 1", "by simp"], ["proof (state)\nthis:\n  \\<tau> i + \\<sigma> (i + 1) =\n  2 * (d + n (i - 1) + e) + n 1 + (i - 2) + n i + 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 2 \\<Longrightarrow>\n    (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)", "by (rule minus_1_even_eqI, unfold id, insert i, auto)"], ["proof (state)\nthis:\n  (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  (- 1) ^ (\\<tau> i + \\<sigma> (i + 1)) = (- 1) ^ (n 1 + n i + i + 1)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"(\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) = PR * PR2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) = PR * PR2", "unfolding PR_def prod_list_multf PR2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ABP [3..<Suc i]) * prod_list (map AB [3..<Suc i]) =\n    prod_list (map ABP [3..<Suc i]) * prod_list (map AB [3..<Suc i])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) = PR * PR2\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  (\\<Prod>l\\<leftarrow>[3..<Suc i]. ABP l * AB l) = PR * PR2\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"(pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i / pow_int (f i) (1 - int (\\<delta> i))\n    / (PR * PR2 * AB (Suc i) * f i ^ (\\<delta> (i - 1) + \\<delta> i))) =\n    ((pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 * pow_int (f i) (int (\\<delta> i) - 1)\n    / pow_int (f i) (int (\\<delta> (i - 1) + \\<delta> i)))) * (PR / PR / (PR2 * AB (Suc i)))\"\n    (is \"\\<dots> = ?x * ?y\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n    pow_int (f i) (1 - int (\\<delta> i)) /\n    (PR * PR2 * AB (Suc i) * f i ^ (\\<delta> (i - 1) + \\<delta> i)) =\n    pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 *\n    pow_int (f i) (int (\\<delta> i) - 1) /\n    pow_int (f i) (int (\\<delta> (i - 1) + \\<delta> i)) *\n    (PR / PR / (PR2 * AB (Suc i)))", "unfolding exp_pow_int[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n    pow_int (f i) (1 - int (\\<delta> i)) /\n    (PR * PR2 * AB (Suc i) * f i ^ (\\<delta> (i - 1) + \\<delta> i)) =\n    pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 *\n    pow_int (f i) (int (\\<delta> i) - 1) /\n    f i ^ (\\<delta> (i - 1) + \\<delta> i) *\n    (PR / PR / (PR2 * AB (Suc i)))", "by (simp add: pow_int_divide ac_simps)"], ["proof (state)\nthis:\n  pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n  pow_int (f i) (1 - int (\\<delta> i)) /\n  (PR * PR2 * AB (Suc i) * f i ^ (\\<delta> (i - 1) + \\<delta> i)) =\n  pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 *\n  pow_int (f i) (int (\\<delta> i) - 1) /\n  pow_int (f i) (int (\\<delta> (i - 1) + \\<delta> i)) *\n  (PR / PR / (PR2 * AB (Suc i)))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  pow_int (f i) (int (\\<delta> (i - 1)) - 1) * PR * f i /\n  pow_int (f i) (1 - int (\\<delta> i)) /\n  (PR * PR2 * AB (Suc i) * f i ^ (\\<delta> (i - 1) + \\<delta> i)) =\n  pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 *\n  pow_int (f i) (int (\\<delta> i) - 1) /\n  pow_int (f i) (int (\\<delta> (i - 1) + \\<delta> i)) *\n  (PR / PR / (PR2 * AB (Suc i)))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"?x = pow_int (f i) (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 *\n    pow_int (f i) (int (\\<delta> i) - 1) /\n    pow_int (f i) (int (\\<delta> (i - 1) + \\<delta> i)) =\n    pow_int (f i) (- 1)", "unfolding pow_int_divide pow_int_add[OF ff0, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i)\n     (int (\\<delta> (i - 1)) - 1 + 1 + (int (\\<delta> i) - 1) +\n      - int (\\<delta> (i - 1) + \\<delta> i)) =\n    pow_int (f i) (- 1)", "by simp"], ["proof (state)\nthis:\n  pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 *\n  pow_int (f i) (int (\\<delta> i) - 1) /\n  pow_int (f i) (int (\\<delta> (i - 1) + \\<delta> i)) =\n  pow_int (f i) (- 1)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  pow_int (f i) (int (\\<delta> (i - 1)) - 1) * pow_int (f i) 1 *\n  pow_int (f i) (int (\\<delta> i) - 1) /\n  pow_int (f i) (int (\\<delta> (i - 1) + \\<delta> i)) =\n  pow_int (f i) (- 1)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"\\<dots> = 1 / (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_int (f i) (- 1) = 1 / f i", "unfolding pow_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if - 1 < 0 then 1 / f i ^ nat (- (- 1)) else f i ^ nat (- 1)) = 1 / f i", "by simp"], ["proof (state)\nthis:\n  pow_int (f i) (- 1) = 1 / f i\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  pow_int (f i) (- 1) = 1 / f i\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"PR / PR = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR / PR = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. PR / PR = 1", "have \"PR \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR \\<noteq> 0", "unfolding PR_def prod_list_zero_iff set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> ABP ` set [3..<Suc i]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> ABP ` set [3..<Suc i] \\<Longrightarrow> False", "assume \"0 \\<in> ABP ` set [3 ..< Suc i]\""], ["proof (state)\nthis:\n  0 \\<in> ABP ` set [3..<Suc i]\n\ngoal (1 subgoal):\n 1. 0 \\<in> ABP ` set [3..<Suc i] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 \\<in> ABP ` set [3..<Suc i]", "obtain j where j: \"3 \\<le> j\" \"j < Suc i\" and 0: \"ABP j = 0\""], ["proof (prove)\nusing this:\n  0 \\<in> ABP ` set [3..<Suc i]\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>3 \\<le> j; j < Suc i; ABP j = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  3 \\<le> j\n  j < Suc i\n  ABP j = 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> ABP ` set [3..<Suc i] \\<Longrightarrow> False", "with i"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k\n  3 \\<le> j\n  j < Suc i\n  ABP j = 0", "have jk: \"j \\<le> k\" and j1: \"j - 1 \\<noteq> 0\" \"j - 1 < k\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  3 \\<le> j\n  j < Suc i\n  ABP j = 0\n\ngoal (1 subgoal):\n 1. j \\<le> k &&& j - 1 \\<noteq> 0 &&& j - 1 < k", "by auto"], ["proof (state)\nthis:\n  j \\<le> k\n  j - 1 \\<noteq> 0\n  j - 1 < k\n\ngoal (1 subgoal):\n 1. 0 \\<in> ABP ` set [3..<Suc i] \\<Longrightarrow> False", "hence 1: \"\\<alpha> j \\<noteq> 0\" \"f (j - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j \\<le> k\n  j - 1 \\<noteq> 0\n  j - 1 < k\n\ngoal (1 subgoal):\n 1. \\<alpha> j \\<noteq> 0 &&& f (j - 1) \\<noteq> 0", "using \\<alpha>0 f0"], ["proof (prove)\nusing this:\n  j \\<le> k\n  j - 1 \\<noteq> 0\n  j - 1 < k\n  1 < ?i \\<Longrightarrow> (\\<alpha> ?i = 0) = (k < ?i - 1)\n  ?i \\<noteq> 0 \\<Longrightarrow> (f ?i = 0) = (k < ?i)\n\ngoal (1 subgoal):\n 1. \\<alpha> j \\<noteq> 0 &&& f (j - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<alpha> j \\<noteq> 0\n  f (j - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> ABP ` set [3..<Suc i] \\<Longrightarrow> False", "with 0"], ["proof (chain)\npicking this:\n  ABP j = 0\n  \\<alpha> j \\<noteq> 0\n  f (j - 1) \\<noteq> 0", "have \"AB j = 0\""], ["proof (prove)\nusing this:\n  ABP j = 0\n  \\<alpha> j \\<noteq> 0\n  f (j - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. AB j = 0", "unfolding ABP_def"], ["proof (prove)\nusing this:\n  AB j ^ (n (j - 1) - n i) *\n  f (j - 1) ^ (\\<delta> (j - 2) + \\<delta> (j - 1)) =\n  0\n  \\<alpha> j \\<noteq> 0\n  f (j - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. AB j = 0", "by simp"], ["proof (state)\nthis:\n  AB j = 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> ABP ` set [3..<Suc i] \\<Longrightarrow> False", "from this[unfolded AB_def] 1(1) \\<beta>0[of j]"], ["proof (chain)\npicking this:\n  \\<beta> j / \\<alpha> j = 0\n  \\<alpha> j \\<noteq> 0\n  \\<beta> j \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  \\<beta> j / \\<alpha> j = 0\n  \\<alpha> j \\<noteq> 0\n  \\<beta> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  PR \\<noteq> 0\n\ngoal (1 subgoal):\n 1. PR / PR = 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  PR \\<noteq> 0\n\ngoal (1 subgoal):\n 1. PR / PR = 1", "by simp"], ["proof (state)\nthis:\n  PR / PR = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  PR / PR = 1\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  PR / PR = 1\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"PR2 * AB (Suc i) = (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. AB l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR2 * AB (Suc i) = prod_list (map AB [3..<Suc (Suc i)])", "unfolding id PR2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map AB [3..<Suc i]) * AB (Suc i) =\n    prod_list (map AB ([3..<Suc i] @ [Suc i]))", "by auto"], ["proof (state)\nthis:\n  PR2 * AB (Suc i) = prod_list (map AB [3..<Suc (Suc i)])\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  PR2 * AB (Suc i) = prod_list (map AB [3..<Suc (Suc i)])\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"1 / \\<dots> = inverse \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / prod_list (map AB [3..<Suc (Suc i)]) =\n    inverse (prod_list (map AB [3..<Suc (Suc i)]))", "by (simp add: inverse_eq_divide)"], ["proof (state)\nthis:\n  1 / prod_list (map AB [3..<Suc (Suc i)]) =\n  inverse (prod_list (map AB [3..<Suc (Suc i)]))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "also"], ["proof (state)\nthis:\n  1 / prod_list (map AB [3..<Suc (Suc i)]) =\n  inverse (prod_list (map AB [3..<Suc (Suc i)]))\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "have \"\\<dots> = (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (prod_list (map AB [3..<Suc (Suc i)])) =\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "unfolding AB_def\n    inverse_prod_list map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>[3..<\n                          Suc (Suc i)]. inverse (\\<beta> x / \\<alpha> x)) =\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "by (auto cong: map_cong)"], ["proof (state)\nthis:\n  inverse (prod_list (map AB [3..<Suc (Suc i)])) =\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0 \\<Longrightarrow>\n    \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "finally"], ["proof (chain)\npicking this:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ (n 1 + n i + i + 1) *\n  (1 / f i *\n   (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ (n 1 + n i + i + 1) *\n  (1 / f i *\n   (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l))\n\ngoal (1 subgoal):\n 1. \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "by simp"], ["proof (state)\nthis:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma B_theorem_3: \"h i = \\<Theta> i * f i\" \"h i = ff (lead_coeff (H i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i = \\<Theta> i * f i &&& h i = ff (lead_coeff (H i))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. h i = \\<Theta> i * f i\n 2. h i = ff (lead_coeff (H i))", "have \"\\<Theta> i * f i = \\<Theta> i * f i / \\<gamma> (i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta> i * f i = \\<Theta> i * f i / \\<gamma> (i + 1)", "using B_theorem_2[of \"i + 1\"] i"], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> i + 1; i + 1 \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> \\<gamma> (i + 1) = 1\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<Theta> i * f i = \\<Theta> i * f i / \\<gamma> (i + 1)", "by auto"], ["proof (state)\nthis:\n  \\<Theta> i * f i = \\<Theta> i * f i / \\<gamma> (i + 1)\n\ngoal (2 subgoals):\n 1. h i = \\<Theta> i * f i\n 2. h i = ff (lead_coeff (H i))", "also"], ["proof (state)\nthis:\n  \\<Theta> i * f i = \\<Theta> i * f i / \\<gamma> (i + 1)\n\ngoal (2 subgoals):\n 1. h i = \\<Theta> i * f i\n 2. h i = ff (lead_coeff (H i))", "have \"\\<dots> = (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta> i * f i / \\<gamma> (i + 1) =\n    (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)", "by (rule B_theorem_3_main)"], ["proof (state)\nthis:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n\ngoal (2 subgoals):\n 1. h i = \\<Theta> i * f i\n 2. h i = ff (lead_coeff (H i))", "also"], ["proof (state)\nthis:\n  \\<Theta> i * f i / \\<gamma> (i + 1) =\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n\ngoal (2 subgoals):\n 1. h i = \\<Theta> i * f i\n 2. h i = ff (lead_coeff (H i))", "have \"\\<dots> = h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    h i", "using B_eq_17[of i] i"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> i; i \\<le> k\\<rbrakk>\n  \\<Longrightarrow> h i =\n                    (- 1) ^ (n 1 + n i + i + 1) / f i *\n                    (\\<Prod>l\\<leftarrow>[3..<\n    Suc (Suc i)]. \\<alpha> l / \\<beta> l)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. (- 1) ^ (n 1 + n i + i + 1) / f i *\n    (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n    h i", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (n 1 + n i + i + 1) / f i *\n  (\\<Prod>l\\<leftarrow>[3..<Suc (Suc i)]. \\<alpha> l / \\<beta> l) =\n  h i\n\ngoal (2 subgoals):\n 1. h i = \\<Theta> i * f i\n 2. h i = ff (lead_coeff (H i))", "finally"], ["proof (chain)\npicking this:\n  \\<Theta> i * f i = h i", "show \"h i = \\<Theta> i * f i\""], ["proof (prove)\nusing this:\n  \\<Theta> i * f i = h i\n\ngoal (1 subgoal):\n 1. h i = \\<Theta> i * f i", ".."], ["proof (state)\nthis:\n  h i = \\<Theta> i * f i\n\ngoal (1 subgoal):\n 1. h i = ff (lead_coeff (H i))", "thus \"h i = ff (lead_coeff (H i))\""], ["proof (prove)\nusing this:\n  h i = \\<Theta> i * f i\n\ngoal (1 subgoal):\n 1. h i = ff (lead_coeff (H i))", "using B_theorem_3_b"], ["proof (prove)\nusing this:\n  h i = \\<Theta> i * f i\n  \\<Theta> i * f i = ff (lead_coeff (H i))\n\ngoal (1 subgoal):\n 1. h i = ff (lead_coeff (H i))", "by auto"], ["proof (state)\nthis:\n  h i = ff (lead_coeff (H i))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma h0: \"i \\<le> k \\<Longrightarrow> h i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> k \\<Longrightarrow> h i \\<noteq> 0", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> k \\<Longrightarrow> h 0 \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> k \\<Longrightarrow> h i \\<noteq> 0;\n        Suc i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> h (Suc i) \\<noteq> 0", "case (Suc i)"], ["proof (state)\nthis:\n  i \\<le> k \\<Longrightarrow> h i \\<noteq> 0\n  Suc i \\<le> k\n\ngoal (2 subgoals):\n 1. 0 \\<le> k \\<Longrightarrow> h 0 \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> k \\<Longrightarrow> h i \\<noteq> 0;\n        Suc i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> h (Suc i) \\<noteq> 0", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> k \\<Longrightarrow> h i \\<noteq> 0\n  Suc i \\<le> k\n\ngoal (1 subgoal):\n 1. h (Suc i) \\<noteq> 0", "unfolding h.simps[of \"Suc i\"]"], ["proof (prove)\nusing this:\n  i \\<le> k \\<Longrightarrow> h i \\<noteq> 0\n  Suc i \\<le> k\n\ngoal (1 subgoal):\n 1. (if Suc i \\<le> 1 then 1\n     else if Suc i = 2 then f 2 ^ \\<delta> 1\n          else f (Suc i) ^ \\<delta> (Suc i - 1) /\n               h (Suc i - 1) ^ (\\<delta> (Suc i - 1) - 1)) \\<noteq>\n    0", "using f0"], ["proof (prove)\nusing this:\n  i \\<le> k \\<Longrightarrow> h i \\<noteq> 0\n  Suc i \\<le> k\n  ?i \\<noteq> 0 \\<Longrightarrow> (f ?i = 0) = (k < ?i)\n\ngoal (1 subgoal):\n 1. (if Suc i \\<le> 1 then 1\n     else if Suc i = 2 then f 2 ^ \\<delta> 1\n          else f (Suc i) ^ \\<delta> (Suc i - 1) /\n               h (Suc i - 1) ^ (\\<delta> (Suc i - 1) - 1)) \\<noteq>\n    0", "by (auto simp del: h.simps)"], ["proof (state)\nthis:\n  h (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> k \\<Longrightarrow> h 0 \\<noteq> 0", "qed auto"], ["", "lemma deg_G12: \"degree G1 \\<ge> degree G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree G2 \\<le> degree G1", "using n12"], ["proof (prove)\nusing this:\n  n 2 \\<le> n 1\n\ngoal (1 subgoal):\n 1. degree G2 \\<le> degree G1", "unfolding n F1 F2"], ["proof (prove)\nusing this:\n  degree (ffp G2) \\<le> degree (ffp G1)\n\ngoal (1 subgoal):\n 1. degree G2 \\<le> degree G1", "by auto"], ["", "lemma R0: shows \"R 0 = [: resultant G1 G2 :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R 0 = [:resultant G1 G2:]", "proof(cases \"n 2 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n 2 = 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]\n 2. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "case True"], ["proof (state)\nthis:\n  n 2 = 0\n\ngoal (2 subgoals):\n 1. n 2 = 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]\n 2. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "hence d:\"degree G2 = 0\""], ["proof (prove)\nusing this:\n  n 2 = 0\n\ngoal (1 subgoal):\n 1. degree G2 = 0", "unfolding n F2"], ["proof (prove)\nusing this:\n  degree (ffp G2) = 0\n\ngoal (1 subgoal):\n 1. degree G2 = 0", "by auto"], ["proof (state)\nthis:\n  degree G2 = 0\n\ngoal (2 subgoals):\n 1. n 2 = 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]\n 2. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "from degree0_coeffs[OF d] F2 F12"], ["proof (chain)\npicking this:\n  \\<exists>a. G2 = [:a:]\n  F 2 = ffp G2\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0", "obtain a where\n    G2: \"G2 = [:a:]\" and a: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a. G2 = [:a:]\n  F 2 = ffp G2\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>G2 = [:a:]; a \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  G2 = [:a:]\n  a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. n 2 = 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]\n 2. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "have \"sdiv_poly [:a * a ^ degree G1:] a = [:a ^ degree G1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdiv_poly [:a * a ^ degree G1:] a = [:a ^ degree G1:]", "using a"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. sdiv_poly [:a * a ^ degree G1:] a = [:a ^ degree G1:]", "unfolding sdiv_poly_def"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>c. c div a) [:a * a ^ degree G1:] = [:a ^ degree G1:]", "by auto"], ["proof (state)\nthis:\n  sdiv_poly [:a * a ^ degree G1:] a = [:a ^ degree G1:]\n\ngoal (2 subgoals):\n 1. n 2 = 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]\n 2. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "note dp = this"], ["proof (state)\nthis:\n  sdiv_poly [:a * a ^ degree G1:] a = [:a ^ degree G1:]\n\ngoal (2 subgoals):\n 1. n 2 = 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]\n 2. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R 0 = [:resultant G1 G2:]", "using G2 F12"], ["proof (prove)\nusing this:\n  G2 = [:a:]\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R 0 = [:resultant G1 G2:]", "unfolding R_def \\<delta> n F1 F2 Suc_1"], ["proof (prove)\nusing this:\n  G2 = [:a:]\n  ffp G1 \\<noteq> 0\n  ffp G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if 0 = degree (ffp G2)\n     then sdiv_poly\n           (Polynomial.smult\n             (lead_coeff G2 ^ (degree (ffp G1) - degree (ffp G2))) G2)\n           (lead_coeff G2)\n     else subresultant 0 G1 G2) =\n    [:resultant G1 G2:]", "by (auto split:if_splits simp:mult.commute dp)"], ["proof (state)\nthis:\n  R 0 = [:resultant G1 G2:]\n\ngoal (1 subgoal):\n 1. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "case False"], ["proof (state)\nthis:\n  n 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "from False n12"], ["proof (chain)\npicking this:\n  n 2 \\<noteq> 0\n  n 2 \\<le> n 1", "have d:\"degree G2 \\<noteq> 0\" \"degree G2 \\<le> degree G1\""], ["proof (prove)\nusing this:\n  n 2 \\<noteq> 0\n  n 2 \\<le> n 1\n\ngoal (1 subgoal):\n 1. degree G2 \\<noteq> 0 &&& degree G2 \\<le> degree G1", "unfolding n F2 F1"], ["proof (prove)\nusing this:\n  degree (ffp G2) \\<noteq> 0\n  degree (ffp G2) \\<le> degree (ffp G1)\n\ngoal (1 subgoal):\n 1. degree G2 \\<noteq> 0 &&& degree G2 \\<le> degree G1", "by auto"], ["proof (state)\nthis:\n  degree G2 \\<noteq> 0\n  degree G2 \\<le> degree G1\n\ngoal (1 subgoal):\n 1. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "from False"], ["proof (chain)\npicking this:\n  n 2 \\<noteq> 0", "have \"R 0 = subresultant 0 G1 G2\""], ["proof (prove)\nusing this:\n  n 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R 0 = subresultant 0 G1 G2", "unfolding R_def"], ["proof (prove)\nusing this:\n  n 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if 0 = n 2\n     then sdiv_poly (Polynomial.smult (lead_coeff G2 ^ \\<delta> 1) G2)\n           (lead_coeff G2)\n     else subresultant 0 G1 G2) =\n    subresultant 0 G1 G2", "by simp"], ["proof (state)\nthis:\n  R 0 = subresultant 0 G1 G2\n\ngoal (1 subgoal):\n 1. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "also"], ["proof (state)\nthis:\n  R 0 = subresultant 0 G1 G2\n\ngoal (1 subgoal):\n 1. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "have \"\\<dots> = [: resultant G1 G2 :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant 0 G1 G2 = [:resultant G1 G2:]", "unfolding subresultant_resultant"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:resultant G1 G2:] = [:resultant G1 G2:]", "by simp"], ["proof (state)\nthis:\n  subresultant 0 G1 G2 = [:resultant G1 G2:]\n\ngoal (1 subgoal):\n 1. n 2 \\<noteq> 0 \\<Longrightarrow> R 0 = [:resultant G1 G2:]", "finally"], ["proof (chain)\npicking this:\n  R 0 = [:resultant G1 G2:]", "show ?thesis"], ["proof (prove)\nusing this:\n  R 0 = [:resultant G1 G2:]\n\ngoal (1 subgoal):\n 1. R 0 = [:resultant G1 G2:]", "."], ["proof (state)\nthis:\n  R 0 = [:resultant G1 G2:]\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes div_exp :: \"'a \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'a\"\n  assumes div_exp: \"\\<And> x y n.\n     (to_fract x)^n / (to_fract y)^(n-1) \\<in> range to_fract\n     \\<Longrightarrow> to_fract (div_exp x y n) = (to_fract x)^n / (to_fract y)^(n-1)\"\nbegin"], ["", "lemma subresultant_prs_main: assumes \"subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk)\"\n  and \"F i = ffp Gi\"\n  and \"F (i - 1) = ffp Gi_1\"\n  and \"h (i - 1) = ff hi_1\"\n  and \"i \\<ge> 3\" \"i \\<le> k\"\nshows \"F k = ffp Gk \\<and> h k = ff hk \\<and> (\\<forall> j. i \\<le> j \\<longrightarrow> j \\<le> k \\<longrightarrow> F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "obtain m where m: \"m = k - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. m = k - i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  m = k - i\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "using m assms"], ["proof (prove)\nusing this:\n  m = k - i\n  subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk)\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n  h (i - 1) = ff hi_1\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "proof (induct m arbitrary: Gi_1 Gi hi_1 i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "case (less m Gi_1 Gi hi_1 i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < m; ?y1 = k - ?i1;\n   subresultant_prs_main div_exp ?Gi_1.1 ?Gi1 ?hi_1.1 = (Gk, hk);\n   F ?i1 = ffp ?Gi1; F (?i1 - 1) = ffp ?Gi_1.1; h (?i1 - 1) = ff ?hi_1.1;\n   3 \\<le> ?i1; ?i1 \\<le> k\\<rbrakk>\n  \\<Longrightarrow> F k = ffp Gk \\<and>\n                    h k = ff hk \\<and>\n                    (\\<forall>j\\<ge>?i1.\n                        j \\<le> k \\<longrightarrow>\n                        F j \\<in> range ffp \\<and>\n                        \\<beta> (Suc j) \\<in> range ff)\n  m = k - i\n  subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk)\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n  h (i - 1) = ff hi_1\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < m; ?y1 = k - ?i1;\n   subresultant_prs_main div_exp ?Gi_1.1 ?Gi1 ?hi_1.1 = (Gk, hk);\n   F ?i1 = ffp ?Gi1; F (?i1 - 1) = ffp ?Gi_1.1; h (?i1 - 1) = ff ?hi_1.1;\n   3 \\<le> ?i1; ?i1 \\<le> k\\<rbrakk>\n  \\<Longrightarrow> F k = ffp Gk \\<and>\n                    h k = ff hk \\<and>\n                    (\\<forall>j\\<ge>?i1.\n                        j \\<le> k \\<longrightarrow>\n                        F j \\<in> range ffp \\<and>\n                        \\<beta> (Suc j) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "note m = less(2)"], ["proof (state)\nthis:\n  m = k - i\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "note res = less(3)"], ["proof (state)\nthis:\n  subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "note id = less(4-6)"], ["proof (state)\nthis:\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n  h (i - 1) = ff hi_1\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "note i = less(7-8)"], ["proof (state)\nthis:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "let ?pmod = \"pseudo_mod Gi_1 Gi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "let ?ni = \"degree Gi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "let ?ni_1 = \"degree Gi_1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "let ?gi = \"lead_coeff Gi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "let ?gi_1 = \"lead_coeff Gi_1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "let ?d1 = \"?ni_1 - ?ni\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "obtain hi where hi: \"hi = div_exp ?gi hi_1 ?d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>hi.\n        hi =\n        div_exp (lead_coeff Gi) hi_1\n         (degree Gi_1 - degree Gi) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hi = div_exp (lead_coeff Gi) hi_1 (degree Gi_1 - degree Gi)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "obtain divisor where div: \"divisor = (-1) ^ (?d1 + 1) * ?gi_1 * (hi_1 ^ ?d1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>divisor.\n        divisor =\n        (- (1::'a)) ^ (degree Gi_1 - degree Gi + 1) * lead_coeff Gi_1 *\n        hi_1 ^ (degree Gi_1 - degree Gi) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  divisor =\n  (- (1::'a)) ^ (degree Gi_1 - degree Gi + 1) * lead_coeff Gi_1 *\n  hi_1 ^ (degree Gi_1 - degree Gi)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "obtain G1_p1 where G1_p1: \"G1_p1 = sdiv_poly ?pmod divisor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G1_p1.\n        G1_p1 = sdiv_poly (pseudo_mod Gi_1 Gi) divisor \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  G1_p1 = sdiv_poly (pseudo_mod Gi_1 Gi) divisor\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "note res = res[unfolded subresultant_prs_main.simps[of div_exp Gi_1] Let_def,\n      folded hi, folded div, folded G1_p1]"], ["proof (state)\nthis:\n  (if pseudo_mod Gi_1 Gi = 0 then (Gi, hi)\n   else subresultant_prs_main div_exp Gi G1_p1 hi) =\n  (Gk, hk)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have h_i: \"h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)", "unfolding h.simps[of i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i \\<le> 1 then 1\n     else if i = 2 then f 2 ^ \\<delta> 1\n          else f i ^ \\<delta> (i - 1) /\n               h (i - 1) ^ (\\<delta> (i - 1) - 1)) =\n    f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)", "using i"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. (if i \\<le> 1 then 1\n     else if i = 2 then f 2 ^ \\<delta> 1\n          else f i ^ \\<delta> (i - 1) /\n               h (i - 1) ^ (\\<delta> (i - 1) - 1)) =\n    f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)", "by simp"], ["proof (state)\nthis:\n  h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have hi_ff: \"h i \\<in> range ff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i \\<in> range ff", "using B_theorem_3[OF _ i(2)] i"], ["proof (prove)\nusing this:\n  3 \\<le> i \\<Longrightarrow> h i = \\<Theta> i * f i\n  3 \\<le> i \\<Longrightarrow> h i = ff (lead_coeff (H i))\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. h i \\<in> range ff", "by auto"], ["proof (state)\nthis:\n  h i \\<in> range ff\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have d1: \"\\<delta> (i - 1) = ?d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (i - 1) = degree Gi_1 - degree Gi", "unfolding \\<delta> n"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (F (i - 1)) - degree (F (Suc (i - 1))) = degree Gi_1 - degree Gi", "using id(1,2)"], ["proof (prove)\nusing this:\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n\ngoal (1 subgoal):\n 1. degree (F (i - 1)) - degree (F (Suc (i - 1))) = degree Gi_1 - degree Gi", "using i"], ["proof (prove)\nusing this:\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. degree (F (i - 1)) - degree (F (Suc (i - 1))) = degree Gi_1 - degree Gi", "by simp"], ["proof (state)\nthis:\n  \\<delta> (i - 1) = degree Gi_1 - degree Gi\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have fi: \"f i = ff ?gi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i = ff (lead_coeff Gi)", "unfolding f id"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (ffp Gi) = ff (lead_coeff Gi)", "by simp"], ["proof (state)\nthis:\n  f i = ff (lead_coeff Gi)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have fi1: \"f (i - 1) = ff ?gi_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i - 1) = ff (lead_coeff Gi_1)", "unfolding f id"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (ffp Gi_1) = ff (lead_coeff Gi_1)", "by simp"], ["proof (state)\nthis:\n  f (i - 1) = ff (lead_coeff Gi_1)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have eq': \"h i = ff (lead_coeff Gi) ^ \\<delta> (i - 1) / ff hi_1 ^ (\\<delta> (i - 1) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i =\n    ff (lead_coeff Gi) ^ \\<delta> (i - 1) / ff hi_1 ^ (\\<delta> (i - 1) - 1)", "unfolding h_i fi id"], ["proof (prove)\ngoal (1 subgoal):\n 1. ff (lead_coeff Gi) ^ \\<delta> (i - 1) /\n    ff hi_1 ^ (\\<delta> (i - 1) - 1) =\n    ff (lead_coeff Gi) ^ \\<delta> (i - 1) / ff hi_1 ^ (\\<delta> (i - 1) - 1)", ".."], ["proof (state)\nthis:\n  h i =\n  ff (lead_coeff Gi) ^ \\<delta> (i - 1) / ff hi_1 ^ (\\<delta> (i - 1) - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have idh: \"h i = ff hi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h i = ff hi", "using hi_ff h_i fi id"], ["proof (prove)\nusing this:\n  h i \\<in> range ff\n  h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)\n  f i = ff (lead_coeff Gi)\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n  h (i - 1) = ff hi_1\n\ngoal (1 subgoal):\n 1. h i = ff hi", "unfolding hi d1[symmetric]"], ["proof (prove)\nusing this:\n  h i \\<in> range ff\n  h i = f i ^ \\<delta> (i - 1) / h (i - 1) ^ (\\<delta> (i - 1) - 1)\n  f i = ff (lead_coeff Gi)\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n  h (i - 1) = ff hi_1\n\ngoal (1 subgoal):\n 1. h i = ff (div_exp (lead_coeff Gi) hi_1 (\\<delta> (i - 1)))", "by (subst div_exp[of ?gi \"\\<delta> (i - 1)\" hi_1], unfold eq'[symmetric], insert assms, blast+)"], ["proof (state)\nthis:\n  h i = ff hi\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have \"\\<beta> (Suc i) = (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) * h (i - 1) ^ \\<delta> (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) =\n    (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n    h (i - 1) ^ \\<delta> (i - 1)", "using \\<beta>i[of \"Suc i\"] i"], ["proof (prove)\nusing this:\n  \\<lbrakk>4 \\<le> Suc i; Suc i \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> \\<beta> (Suc i) =\n                    (- 1) ^ (\\<delta> (Suc i - 2) + 1) * f (Suc i - 2) *\n                    h (Suc i - 2) ^ \\<delta> (Suc i - 2)\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) =\n    (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n    h (i - 1) ^ \\<delta> (i - 1)", "by auto"], ["proof (state)\nthis:\n  \\<beta> (Suc i) =\n  (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) * h (i - 1) ^ \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "also"], ["proof (state)\nthis:\n  \\<beta> (Suc i) =\n  (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) * h (i - 1) ^ \\<delta> (i - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have \"\\<dots> = ff ((- 1) ^ (\\<delta> (i - 1) + 1) * lead_coeff Gi_1 * hi_1 ^ \\<delta> (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n    h (i - 1) ^ \\<delta> (i - 1) =\n    ff ((- (1::'a)) ^ (\\<delta> (i - 1) + 1) * lead_coeff Gi_1 *\n        hi_1 ^ \\<delta> (i - 1))", "unfolding id f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<delta> (i - 1) + 1) * lead_coeff (ffp Gi_1) *\n    ff hi_1 ^ \\<delta> (i - 1) =\n    ff ((- (1::'a)) ^ (\\<delta> (i - 1) + 1) * lead_coeff Gi_1 *\n        hi_1 ^ \\<delta> (i - 1))", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n  h (i - 1) ^ \\<delta> (i - 1) =\n  ff ((- (1::'a)) ^ (\\<delta> (i - 1) + 1) * lead_coeff Gi_1 *\n      hi_1 ^ \\<delta> (i - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "also"], ["proof (state)\nthis:\n  (- 1) ^ (\\<delta> (i - 1) + 1) * f (i - 1) *\n  h (i - 1) ^ \\<delta> (i - 1) =\n  ff ((- (1::'a)) ^ (\\<delta> (i - 1) + 1) * lead_coeff Gi_1 *\n      hi_1 ^ \\<delta> (i - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have \"\\<dots> \\<in> range ff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ff ((- (1::'a)) ^ (\\<delta> (i - 1) + 1) * lead_coeff Gi_1 *\n        hi_1 ^ \\<delta> (i - 1))\n    \\<in> range ff", "by blast"], ["proof (state)\nthis:\n  ff ((- (1::'a)) ^ (\\<delta> (i - 1) + 1) * lead_coeff Gi_1 *\n      hi_1 ^ \\<delta> (i - 1))\n  \\<in> range ff\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "finally"], ["proof (chain)\npicking this:\n  \\<beta> (Suc i) \\<in> range ff", "have beta: \"\\<beta> (Suc i) \\<in> range ff\""], ["proof (prove)\nusing this:\n  \\<beta> (Suc i) \\<in> range ff\n\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) \\<in> range ff", "."], ["proof (state)\nthis:\n  \\<beta> (Suc i) \\<in> range ff\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have pm: \"pseudo_mod (F (i - 1)) (F i) = ffp ?pmod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 1)) (F i) = ffp (pseudo_mod Gi_1 Gi)", "unfolding to_fract_hom.pseudo_mod_hom[symmetric] id"], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (ffp Gi_1) (ffp Gi) = pseudo_mod (ffp Gi_1) (ffp Gi)", "by simp"], ["proof (state)\nthis:\n  pseudo_mod (F (i - 1)) (F i) = ffp (pseudo_mod Gi_1 Gi)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "have eq: \"(?pmod = 0) = (i = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pseudo_mod Gi_1 Gi = 0) = (i = k)", "using pm i pmod[of \"Suc i\"] F0[of \"Suc i\"] i \\<beta>0[of \"Suc i\"]"], ["proof (prove)\nusing this:\n  pseudo_mod (F (i - 1)) (F i) = ffp (pseudo_mod Gi_1 Gi)\n  3 \\<le> i\n  i \\<le> k\n  \\<lbrakk>3 \\<le> Suc i; Suc i \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n                    pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))\n  Suc i \\<noteq> 0 \\<Longrightarrow> (F (Suc i) = 0) = (k < Suc i)\n  3 \\<le> i\n  i \\<le> k\n  \\<beta> (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (pseudo_mod Gi_1 Gi = 0) = (i = k)", "by auto"], ["proof (state)\nthis:\n  (pseudo_mod Gi_1 Gi = 0) = (i = k)\n\ngoal (1 subgoal):\n 1. \\<And>x Gi_1 Gi hi_1 i.\n       \\<lbrakk>\\<And>y Gi_1 Gi hi_1 i.\n                   \\<lbrakk>y < x; y = k - i;\n                    subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n                    F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1;\n                    3 \\<le> i; i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> F k = ffp Gk \\<and>\n                                     h k = ff hk \\<and>\n                                     (\\<forall>j\\<ge>i.\n   j \\<le> k \\<longrightarrow>\n   F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff);\n        x = k - i; subresultant_prs_main div_exp Gi_1 Gi hi_1 = (Gk, hk);\n        F i = ffp Gi; F (i - 1) = ffp Gi_1; h (i - 1) = ff hi_1; 3 \\<le> i;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> F k = ffp Gk \\<and>\n                         h k = ff hk \\<and>\n                         (\\<forall>j\\<ge>i.\n                             j \\<le> k \\<longrightarrow>\n                             F j \\<in> range ffp \\<and>\n                             \\<beta> (Suc j) \\<in> range ff)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n 2. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "case True"], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n 2. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "with res eq"], ["proof (chain)\npicking this:\n  (if pseudo_mod Gi_1 Gi = 0 then (Gi, hi)\n   else subresultant_prs_main div_exp Gi G1_p1 hi) =\n  (Gk, hk)\n  (pseudo_mod Gi_1 Gi = 0) = (i = k)\n  i = k", "have res: \"Gk = Gi\" \"hk = hi\""], ["proof (prove)\nusing this:\n  (if pseudo_mod Gi_1 Gi = 0 then (Gi, hi)\n   else subresultant_prs_main div_exp Gi G1_p1 hi) =\n  (Gk, hk)\n  (pseudo_mod Gi_1 Gi = 0) = (i = k)\n  i = k\n\ngoal (1 subgoal):\n 1. Gk = Gi &&& hk = hi", "by auto"], ["proof (state)\nthis:\n  Gk = Gi\n  hk = hi\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n 2. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "with pmod"], ["proof (chain)\npicking this:\n  \\<lbrakk>3 \\<le> ?i; ?i \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> ?i) (F ?i) =\n                    pseudo_mod (F (?i - 2)) (F (?i - 1))\n  Gk = Gi\n  hk = hi", "have \"F k = ffp Gk \\<and> h k = ff hk\""], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> ?i; ?i \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> ?i) (F ?i) =\n                    pseudo_mod (F (?i - 2)) (F (?i - 1))\n  Gk = Gi\n  hk = hi\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and> h k = ff hk", "unfolding res idh[symmetric] id[symmetric] True"], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> ?i; ?i \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> ?i) (F ?i) =\n                    pseudo_mod (F (?i - 2)) (F (?i - 1))\n  Gi = Gi\n  hi = hi\n\ngoal (1 subgoal):\n 1. F k = F k \\<and> h k = h k", "by auto"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and> h k = ff hk\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n 2. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "thus ?thesis"], ["proof (prove)\nusing this:\n  F k = ffp Gk \\<and> h k = ff hk\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "using beta"], ["proof (prove)\nusing this:\n  F k = ffp Gk \\<and> h k = ff hk\n  \\<beta> (Suc i) \\<in> range ff\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "unfolding True"], ["proof (prove)\nusing this:\n  F k = ffp Gk \\<and> h k = ff hk\n  \\<beta> (Suc k) \\<in> range ff\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>k.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "by auto"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (\\<forall>j\\<ge>i.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "with res eq"], ["proof (chain)\npicking this:\n  (if pseudo_mod Gi_1 Gi = 0 then (Gi, hi)\n   else subresultant_prs_main div_exp Gi G1_p1 hi) =\n  (Gk, hk)\n  (pseudo_mod Gi_1 Gi = 0) = (i = k)\n  i \\<noteq> k", "have res:\n         \"subresultant_prs_main div_exp Gi G1_p1 hi = (Gk, hk)\""], ["proof (prove)\nusing this:\n  (if pseudo_mod Gi_1 Gi = 0 then (Gi, hi)\n   else subresultant_prs_main div_exp Gi G1_p1 hi) =\n  (Gk, hk)\n  (pseudo_mod Gi_1 Gi = 0) = (i = k)\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. subresultant_prs_main div_exp Gi G1_p1 hi = (Gk, hk)", "by auto"], ["proof (state)\nthis:\n  subresultant_prs_main div_exp Gi G1_p1 hi = (Gk, hk)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "from m False i"], ["proof (chain)\npicking this:\n  m = k - i\n  i \\<noteq> k\n  3 \\<le> i\n  i \\<le> k", "have m: \"m - 1 < m\" \"m - 1 = k - Suc i\""], ["proof (prove)\nusing this:\n  m = k - i\n  i \\<noteq> k\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. m - 1 < m &&& m - 1 = k - Suc i", "by auto"], ["proof (state)\nthis:\n  m - 1 < m\n  m - 1 = k - Suc i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "have si: \"Suc i - 1 = i\" and ii: \"3 \\<le> Suc i\" \"Suc i \\<le> k\" and iii: \"3 \\<le> Suc i\" \"Suc i \\<le> Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i - 1 = i &&&\n    (3 \\<le> Suc i &&& Suc i \\<le> k) &&&\n    3 \\<le> Suc i &&& Suc i \\<le> Suc k", "using False i"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n  3 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. Suc i - 1 = i &&&\n    (3 \\<le> Suc i &&& Suc i \\<le> k) &&&\n    3 \\<le> Suc i &&& Suc i \\<le> Suc k", "by auto"], ["proof (state)\nthis:\n  Suc i - 1 = i\n  3 \\<le> Suc i\n  Suc i \\<le> k\n  3 \\<le> Suc i\n  Suc i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "have *: \"(\\<forall>j\\<ge>Suc i. j \\<le> k \\<longrightarrow> F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff) = (\\<forall>j\\<ge>i. j \\<le> k \\<longrightarrow> F j \\<in> range ffp  \\<and> \\<beta> (Suc j) \\<in> range ff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<ge>Suc i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff) =\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "by (rule for_all_Suc, insert id(1) beta, auto)"], ["proof (state)\nthis:\n  (\\<forall>j\\<ge>Suc i.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff) =\n  (\\<forall>j\\<ge>i.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>i.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "proof (rule IH[OF m res, unfolded si, OF _ id(1) idh ii, unfolded *])"], ["proof (state)\ngoal (1 subgoal):\n 1. F (Suc i) = ffp G1_p1", "have F_ffp: \"F (Suc i) \\<in> range ffp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (Suc i) \\<in> range ffp", "using fundamental_theorem_eq_4[OF ii, symmetric] B_theorem_2[OF iii]"], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<gamma> (Suc i)) (F (Suc i)) =\n  ffp (R (n (Suc i - 1) - 1))\n  \\<gamma> (Suc i) = 1\n\ngoal (1 subgoal):\n 1. F (Suc i) \\<in> range ffp", "by auto"], ["proof (state)\nthis:\n  F (Suc i) \\<in> range ffp\n\ngoal (1 subgoal):\n 1. F (Suc i) = ffp G1_p1", "from pmod[OF iii]"], ["proof (chain)\npicking this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n  pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))", "have \"smult (\\<beta> (Suc i)) (F (Suc i)) = pseudo_mod (F (i - 1)) (F i)\""], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n  pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n    pseudo_mod (F (i - 1)) (F i)", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n  pseudo_mod (F (i - 1)) (F i)\n\ngoal (1 subgoal):\n 1. F (Suc i) = ffp G1_p1", "from arg_cong[OF this, of \"\\<lambda> x. smult (inverse (\\<beta> (Suc i))) x\"]"], ["proof (chain)\npicking this:\n  Polynomial.smult (inverse (\\<beta> (Suc i)))\n   (Polynomial.smult (\\<beta> (Suc i)) (F (Suc i))) =\n  Polynomial.smult (inverse (\\<beta> (Suc i)))\n   (pseudo_mod (F (i - 1)) (F i))", "have Fsi: \"F (Suc i) = smult (inverse (\\<beta> (Suc i))) (pseudo_mod (F (i - 1)) (F i))\""], ["proof (prove)\nusing this:\n  Polynomial.smult (inverse (\\<beta> (Suc i)))\n   (Polynomial.smult (\\<beta> (Suc i)) (F (Suc i))) =\n  Polynomial.smult (inverse (\\<beta> (Suc i)))\n   (pseudo_mod (F (i - 1)) (F i))\n\ngoal (1 subgoal):\n 1. F (Suc i) =\n    Polynomial.smult (inverse (\\<beta> (Suc i)))\n     (pseudo_mod (F (i - 1)) (F i))", "using \\<beta>0[of \"Suc i\"]"], ["proof (prove)\nusing this:\n  Polynomial.smult (inverse (\\<beta> (Suc i)))\n   (Polynomial.smult (\\<beta> (Suc i)) (F (Suc i))) =\n  Polynomial.smult (inverse (\\<beta> (Suc i)))\n   (pseudo_mod (F (i - 1)) (F i))\n  \\<beta> (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F (Suc i) =\n    Polynomial.smult (inverse (\\<beta> (Suc i)))\n     (pseudo_mod (F (i - 1)) (F i))", "by auto"], ["proof (state)\nthis:\n  F (Suc i) =\n  Polynomial.smult (inverse (\\<beta> (Suc i)))\n   (pseudo_mod (F (i - 1)) (F i))\n\ngoal (1 subgoal):\n 1. F (Suc i) = ffp G1_p1", "show \"F (Suc i) = ffp G1_p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (Suc i) = ffp G1_p1", "proof (rule smult_inverse_sdiv_poly[OF F_ffp Fsi G1_p1 _ pm])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) = ff divisor", "from i ii"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> k\n  3 \\<le> Suc i\n  Suc i \\<le> k", "have iv: \"4 \\<le> Suc i\" \"Suc i \\<le> Suc k\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> k\n  3 \\<le> Suc i\n  Suc i \\<le> k\n\ngoal (1 subgoal):\n 1. 4 \\<le> Suc i &&& Suc i \\<le> Suc k", "by auto"], ["proof (state)\nthis:\n  4 \\<le> Suc i\n  Suc i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) = ff divisor", "have *: \"Suc i - 2 = i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i - 2 = i - 1", "by auto"], ["proof (state)\nthis:\n  Suc i - 2 = i - 1\n\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) = ff divisor", "show \"\\<beta> (Suc i) = ff divisor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) = ff divisor", "unfolding \\<beta>i[OF iv] div d1 * fi1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (degree Gi_1 - degree Gi + 1) * ff (lead_coeff Gi_1) *\n    h (i - 1) ^ (degree Gi_1 - degree Gi) =\n    ff ((- (1::'a)) ^ (degree Gi_1 - degree Gi + 1) * lead_coeff Gi_1 *\n        hi_1 ^ (degree Gi_1 - degree Gi))", "using id"], ["proof (prove)\nusing this:\n  F i = ffp Gi\n  F (i - 1) = ffp Gi_1\n  h (i - 1) = ff hi_1\n\ngoal (1 subgoal):\n 1. (- 1) ^ (degree Gi_1 - degree Gi + 1) * ff (lead_coeff Gi_1) *\n    h (i - 1) ^ (degree Gi_1 - degree Gi) =\n    ff ((- (1::'a)) ^ (degree Gi_1 - degree Gi + 1) * lead_coeff Gi_1 *\n        hi_1 ^ (degree Gi_1 - degree Gi))", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  \\<beta> (Suc i) = ff divisor\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F (Suc i) = ffp G1_p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (\\<forall>j\\<ge>i.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (\\<forall>j\\<ge>i.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (\\<forall>j\\<ge>i.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subresultant_prs: assumes res: \"subresultant_prs div_exp G1 G2 = (Gk, hk)\"\n  shows \"F k = ffp Gk \\<and> h k = ff hk \\<and> (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and> (3 \\<le> i \\<longrightarrow> i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "let ?pmod = \"pseudo_mod G1 G2\""], ["proof (state)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "have pm: \"pseudo_mod (F 1) (F 2) = ffp ?pmod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (F 1) (F 2) = ffp (pseudo_mod G1 G2)", "unfolding to_fract_hom.pseudo_mod_hom[symmetric] F1 F2"], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (ffp G1) (ffp G2) = pseudo_mod (ffp G1) (ffp G2)", "by simp"], ["proof (state)\nthis:\n  pseudo_mod (F 1) (F 2) = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "let ?g2 = \"lead_coeff G2\""], ["proof (state)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "let ?n2 = \"degree G2\""], ["proof (state)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "obtain d1 where d1: \"d1 = degree G1 - ?n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        d1 = degree G1 - degree G2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d1 = degree G1 - degree G2\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "obtain h2 where h2: \"h2 = ?g2 ^ d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h2.\n        h2 = lead_coeff G2 ^ d1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h2 = lead_coeff G2 ^ d1\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "have \"(?pmod = 0) = (pseudo_mod (F 1) (F 2) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pseudo_mod G1 G2 = 0) = (pseudo_mod (F 1) (F 2) = 0)", "using pm"], ["proof (prove)\nusing this:\n  pseudo_mod (F 1) (F 2) = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. (pseudo_mod G1 G2 = 0) = (pseudo_mod (F 1) (F 2) = 0)", "by auto"], ["proof (state)\nthis:\n  (pseudo_mod G1 G2 = 0) = (pseudo_mod (F 1) (F 2) = 0)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "also"], ["proof (state)\nthis:\n  (pseudo_mod G1 G2 = 0) = (pseudo_mod (F 1) (F 2) = 0)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "have \"\\<dots> = (k < 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pseudo_mod (F 1) (F 2) = 0) = (k < 3)", "using k2 pmod[of 3] F0[of 3] \\<beta>0[of 3]"], ["proof (prove)\nusing this:\n  2 \\<le> k\n  \\<lbrakk>3 \\<le> 3; 3 \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> 3) (F 3) =\n                    pseudo_mod (F (3 - 2)) (F (3 - 1))\n  3 \\<noteq> 0 \\<Longrightarrow> (F 3 = 0) = (k < 3)\n  \\<beta> 3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (pseudo_mod (F 1) (F 2) = 0) = (k < 3)", "by auto"], ["proof (state)\nthis:\n  (pseudo_mod (F 1) (F 2) = 0) = (k < 3)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "finally"], ["proof (chain)\npicking this:\n  (pseudo_mod G1 G2 = 0) = (k < 3)", "have eq: \"?pmod = 0 \\<longleftrightarrow> k = 2\""], ["proof (prove)\nusing this:\n  (pseudo_mod G1 G2 = 0) = (k < 3)\n\ngoal (1 subgoal):\n 1. (pseudo_mod G1 G2 = 0) = (k = 2)", "using k2"], ["proof (prove)\nusing this:\n  (pseudo_mod G1 G2 = 0) = (k < 3)\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. (pseudo_mod G1 G2 = 0) = (k = 2)", "by linarith"], ["proof (state)\nthis:\n  (pseudo_mod G1 G2 = 0) = (k = 2)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "note res = res[unfolded subresultant_prs_def Let_def eq, folded d1, folded h2]"], ["proof (state)\nthis:\n  (if k = 2 then (G2, h2)\n   else subresultant_prs_main div_exp G2\n         ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) h2) =\n  (Gk, hk)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "have idh2: \"h 2 = ff h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h 2 = ff h2", "unfolding h2 d1 h.simps[of 2] \\<delta> n F1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 2 \\<le> 1 then 1\n     else if 2 = 2 then f 2 ^ (degree (ffp G1) - degree (F (Suc 1)))\n          else f 2 ^ (degree (F (2 - 1)) - degree (F (Suc (2 - 1)))) /\n               subresultant_prs_locale.h\n                (\\<lambda>i. degree (F i) - degree (F (Suc i))) f (2 - 1) ^\n               (degree (F (2 - 1)) - degree (F (Suc (2 - 1))) - 1)) =\n    ff (lead_coeff G2 ^ (degree G1 - degree G2))", "using F2"], ["proof (prove)\nusing this:\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. (if 2 \\<le> 1 then 1\n     else if 2 = 2 then f 2 ^ (degree (ffp G1) - degree (F (Suc 1)))\n          else f 2 ^ (degree (F (2 - 1)) - degree (F (Suc (2 - 1)))) /\n               subresultant_prs_locale.h\n                (\\<lambda>i. degree (F i) - degree (F (Suc i))) f (2 - 1) ^\n               (degree (F (2 - 1)) - degree (F (Suc (2 - 1))) - 1)) =\n    ff (lead_coeff G2 ^ (degree G1 - degree G2))", "by (simp add: numeral_2_eq_2 f hom_distribs)"], ["proof (state)\nthis:\n  h 2 = ff h2\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "have main: \"F k = ffp Gk \\<and> h k = ff hk \\<and> (i \\<ge> 3 \\<longrightarrow> i \\<le> k \\<longrightarrow> F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "proof (cases \"k = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "case True"], ["proof (state)\nthis:\n  k = 2\n\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "with res"], ["proof (chain)\npicking this:\n  (if k = 2 then (G2, h2)\n   else subresultant_prs_main div_exp G2\n         ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) h2) =\n  (Gk, hk)\n  k = 2", "have \"Gk = G2\" \"hk = h2\""], ["proof (prove)\nusing this:\n  (if k = 2 then (G2, h2)\n   else subresultant_prs_main div_exp G2\n         ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) h2) =\n  (Gk, hk)\n  k = 2\n\ngoal (1 subgoal):\n 1. Gk = G2 &&& hk = h2", "by auto"], ["proof (state)\nthis:\n  Gk = G2\n  hk = h2\n\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Gk = G2\n  hk = h2\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "using True idh2 F2"], ["proof (prove)\nusing this:\n  Gk = G2\n  hk = h2\n  k = 2\n  h 2 = ff h2\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "by auto"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (3 \\<le> i \\<longrightarrow>\n   i \\<le> k \\<longrightarrow>\n   F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 2\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "hence \"(k = 2) = False\""], ["proof (prove)\nusing this:\n  k \\<noteq> 2\n\ngoal (1 subgoal):\n 1. (k = 2) = False", "by simp"], ["proof (state)\nthis:\n  (k = 2) = False\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "note res = res[unfolded this if_False]"], ["proof (state)\nthis:\n  subresultant_prs_main div_exp G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n   h2 =\n  (Gk, hk)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "have F_2: \"F (3 - 1) = ffp G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (3 - 1) = ffp G2", "using F2"], ["proof (prove)\nusing this:\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. F (3 - 1) = ffp G2", "by simp"], ["proof (state)\nthis:\n  F (3 - 1) = ffp G2\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "have h2: \"h (3 - 1) = ff h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (3 - 1) = ff h2", "using idh2"], ["proof (prove)\nusing this:\n  h 2 = ff h2\n\ngoal (1 subgoal):\n 1. h (3 - 1) = ff h2", "by simp"], ["proof (state)\nthis:\n  h (3 - 1) = ff h2\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "have n2: \"degree G2 = n (3 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree G2 = n (3 - 1)", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree G2 = degree (F (3 - 1))", "using F2"], ["proof (prove)\nusing this:\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. degree G2 = degree (F (3 - 1))", "by simp"], ["proof (state)\nthis:\n  degree G2 = n (3 - 1)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "from False k2"], ["proof (chain)\npicking this:\n  k \\<noteq> 2\n  2 \\<le> k", "have k3: \"3 \\<le> k\""], ["proof (prove)\nusing this:\n  k \\<noteq> 2\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. 3 \\<le> k", "by auto"], ["proof (state)\nthis:\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "have \"F k = ffp Gk \\<and> h k = ff hk \\<and> (\\<forall>j\\<ge>3. j \\<le> k \\<longrightarrow> F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (\\<forall>j\\<ge>3.\n        j \\<le> k \\<longrightarrow>\n        F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)", "proof (rule subresultant_prs_main[OF res _ F_2 h2 le_refl k3])"], ["proof (state)\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "let ?pow = \"(- 1) ^ (\\<delta> 1 + 1) :: 'a fract\""], ["proof (state)\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "from pmod[of 3] k3"], ["proof (chain)\npicking this:\n  \\<lbrakk>3 \\<le> 3; 3 \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> 3) (F 3) =\n                    pseudo_mod (F (3 - 2)) (F (3 - 1))\n  3 \\<le> k", "have \"smult (\\<beta> 3) (F 3) = pseudo_mod (F 1) (F 2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> 3; 3 \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> 3) (F 3) =\n                    pseudo_mod (F (3 - 2)) (F (3 - 1))\n  3 \\<le> k\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> 3) (F 3) = pseudo_mod (F 1) (F 2)", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (\\<beta> 3) (F 3) = pseudo_mod (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "also"], ["proof (state)\nthis:\n  Polynomial.smult (\\<beta> 3) (F 3) = pseudo_mod (F 1) (F 2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "have \"\\<dots> = pseudo_mod (ffp G1) (ffp G2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (F 1) (F 2) = pseudo_mod (ffp G1) (ffp G2)", "using F1 F2"], ["proof (prove)\nusing this:\n  F 1 = ffp G1\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. pseudo_mod (F 1) (F 2) = pseudo_mod (ffp G1) (ffp G2)", "by auto"], ["proof (state)\nthis:\n  pseudo_mod (F 1) (F 2) = pseudo_mod (ffp G1) (ffp G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "also"], ["proof (state)\nthis:\n  pseudo_mod (F 1) (F 2) = pseudo_mod (ffp G1) (ffp G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "have \"\\<dots> = ffp (pseudo_mod G1 G2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (ffp G1) (ffp G2) = ffp (pseudo_mod G1 G2)", "unfolding to_fract_hom.pseudo_mod_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffp (pseudo_mod G1 G2) = ffp (pseudo_mod G1 G2)", "by simp"], ["proof (state)\nthis:\n  pseudo_mod (ffp G1) (ffp G2) = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "also"], ["proof (state)\nthis:\n  pseudo_mod (ffp G1) (ffp G2) = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "have \"\\<beta> 3 = (- 1) ^ (\\<delta> 1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> 3 = (- 1) ^ (\\<delta> 1 + 1)", "unfolding \\<beta>3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<delta> 1 + 1) = (- 1) ^ (\\<delta> 1 + 1)", "by simp"], ["proof (state)\nthis:\n  \\<beta> 3 = (- 1) ^ (\\<delta> 1 + 1)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) = ffp (pseudo_mod G1 G2)", "have \"smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) = ffp (pseudo_mod G1 G2)\""], ["proof (prove)\nusing this:\n  Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) =\n    ffp (pseudo_mod G1 G2)", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "also"], ["proof (state)\nthis:\n  Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "have \"smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) = [: ?pow :] * F 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) =\n    [:(- 1) ^ (\\<delta> 1 + 1):] * F 3", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) =\n  [:(- 1) ^ (\\<delta> 1 + 1):] * F 3\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "also"], ["proof (state)\nthis:\n  Polynomial.smult ((- 1) ^ (\\<delta> 1 + 1)) (F 3) =\n  [:(- 1) ^ (\\<delta> 1 + 1):] * F 3\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "have \"[: ?pow :] = (- 1) ^ (\\<delta> 1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:(- 1) ^ (\\<delta> 1 + 1):] = (- 1) ^ (\\<delta> 1 + 1)", "by (unfold hom_distribs, simp)"], ["proof (state)\nthis:\n  [:(- 1) ^ (\\<delta> 1 + 1):] = (- 1) ^ (\\<delta> 1 + 1)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (\\<delta> 1 + 1) * F 3 = ffp (pseudo_mod G1 G2)", "have \"(- 1) ^ (\\<delta> 1 + 1) * F 3 = ffp (pseudo_mod G1 G2)\""], ["proof (prove)\nusing this:\n  (- 1) ^ (\\<delta> 1 + 1) * F 3 = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<delta> 1 + 1) * F 3 = ffp (pseudo_mod G1 G2)", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (\\<delta> 1 + 1) * F 3 = ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "from arg_cong[OF this, of \"\\<lambda> i. (- 1) ^ (\\<delta> 1 + 1) * i\"]"], ["proof (chain)\npicking this:\n  (- 1) ^ (\\<delta> 1 + 1) * ((- 1) ^ (\\<delta> 1 + 1) * F 3) =\n  (- 1) ^ (\\<delta> 1 + 1) * ffp (pseudo_mod G1 G2)", "have \"F 3 = (- 1) ^ (\\<delta> 1 + 1) * ffp (pseudo_mod G1 G2)\""], ["proof (prove)\nusing this:\n  (- 1) ^ (\\<delta> 1 + 1) * ((- 1) ^ (\\<delta> 1 + 1) * F 3) =\n  (- 1) ^ (\\<delta> 1 + 1) * ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = (- 1) ^ (\\<delta> 1 + 1) * ffp (pseudo_mod G1 G2)", "by simp"], ["proof (state)\nthis:\n  F 3 = (- 1) ^ (\\<delta> 1 + 1) * ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "also"], ["proof (state)\nthis:\n  F 3 = (- 1) ^ (\\<delta> 1 + 1) * ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "have \"\\<delta> 1 = d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> 1 = d1", "unfolding \\<delta> n d1"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (F 1) - degree (F (Suc 1)) = degree G1 - degree G2", "using F1 F2"], ["proof (prove)\nusing this:\n  F 1 = ffp G1\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. degree (F 1) - degree (F (Suc 1)) = degree G1 - degree G2", "by (simp add: numeral_2_eq_2)"], ["proof (state)\nthis:\n  \\<delta> 1 = d1\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "finally"], ["proof (chain)\npicking this:\n  F 3 = (- 1) ^ (d1 + 1) * ffp (pseudo_mod G1 G2)", "show F3: \"F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\""], ["proof (prove)\nusing this:\n  F 3 = (- 1) ^ (d1 + 1) * ffp (pseudo_mod G1 G2)\n\ngoal (1 subgoal):\n 1. F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  F 3 = ffp ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (\\<forall>j\\<ge>3.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2 \\<Longrightarrow>\n    F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "thus ?thesis"], ["proof (prove)\nusing this:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (\\<forall>j\\<ge>3.\n      j \\<le> k \\<longrightarrow>\n      F j \\<in> range ffp \\<and> \\<beta> (Suc j) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> k \\<longrightarrow>\n     F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)", "by auto"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (3 \\<le> i \\<longrightarrow>\n   i \\<le> k \\<longrightarrow>\n   F i \\<in> range ffp \\<and> \\<beta> (Suc i) \\<in> range ff)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (3 \\<le> ?i1 \\<longrightarrow>\n   ?i1 \\<le> k \\<longrightarrow>\n   F ?i1 \\<in> range ffp \\<and> \\<beta> (Suc ?i1) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. F k = ffp Gk \\<and>\n    h k = ff hk \\<and>\n    (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n    (3 \\<le> i \\<longrightarrow>\n     i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)", "proof (intro conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk\n 3. i \\<noteq> 0 \\<Longrightarrow> F i \\<in> range ffp\n 4. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "assume \"i \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (4 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk\n 3. i \\<noteq> 0 \\<Longrightarrow> F i \\<in> range ffp\n 4. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "consider (12) \"i = 1 \\<or> i = 2\" | (i3) \"i \\<ge> 3 \\<and> i \\<le> k\" | (ik) \"i > k\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 1 \\<or> i = 2 \\<Longrightarrow> thesis;\n     3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> thesis;\n     k < i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>i = 1 \\<or> i = 2 \\<Longrightarrow> ?thesis1;\n   3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> ?thesis1;\n   k < i \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (4 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk\n 3. i \\<noteq> 0 \\<Longrightarrow> F i \\<in> range ffp\n 4. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "thus \"F i \\<in> range ffp\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 1 \\<or> i = 2 \\<Longrightarrow> ?thesis1;\n   3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> ?thesis1;\n   k < i \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. F i \\<in> range ffp", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. i = 1 \\<or> i = 2 \\<Longrightarrow> F i \\<in> range ffp\n 2. 3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> F i \\<in> range ffp\n 3. k < i \\<Longrightarrow> F i \\<in> range ffp", "case 12"], ["proof (state)\nthis:\n  i = 1 \\<or> i = 2\n\ngoal (3 subgoals):\n 1. i = 1 \\<or> i = 2 \\<Longrightarrow> F i \\<in> range ffp\n 2. 3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> F i \\<in> range ffp\n 3. k < i \\<Longrightarrow> F i \\<in> range ffp", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 1 \\<or> i = 2\n\ngoal (1 subgoal):\n 1. F i \\<in> range ffp", "using F1 F2"], ["proof (prove)\nusing this:\n  i = 1 \\<or> i = 2\n  F 1 = ffp G1\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. F i \\<in> range ffp", "by auto"], ["proof (state)\nthis:\n  F i \\<in> range ffp\n\ngoal (2 subgoals):\n 1. 3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> F i \\<in> range ffp\n 2. k < i \\<Longrightarrow> F i \\<in> range ffp", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> F i \\<in> range ffp\n 2. k < i \\<Longrightarrow> F i \\<in> range ffp", "case i3"], ["proof (state)\nthis:\n  3 \\<le> i \\<and> i \\<le> k\n\ngoal (2 subgoals):\n 1. 3 \\<le> i \\<and> i \\<le> k \\<Longrightarrow> F i \\<in> range ffp\n 2. k < i \\<Longrightarrow> F i \\<in> range ffp", "thus ?thesis"], ["proof (prove)\nusing this:\n  3 \\<le> i \\<and> i \\<le> k\n\ngoal (1 subgoal):\n 1. F i \\<in> range ffp", "using main"], ["proof (prove)\nusing this:\n  3 \\<le> i \\<and> i \\<le> k\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (3 \\<le> ?i1 \\<longrightarrow>\n   ?i1 \\<le> k \\<longrightarrow>\n   F ?i1 \\<in> range ffp \\<and> \\<beta> (Suc ?i1) \\<in> range ff)\n\ngoal (1 subgoal):\n 1. F i \\<in> range ffp", "by auto"], ["proof (state)\nthis:\n  F i \\<in> range ffp\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i \\<in> range ffp", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i \\<in> range ffp", "case ik"], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i \\<in> range ffp", "hence \"F i = 0\""], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. F i = 0", "using F0"], ["proof (prove)\nusing this:\n  k < i\n  ?i \\<noteq> 0 \\<Longrightarrow> (F ?i = 0) = (k < ?i)\n\ngoal (1 subgoal):\n 1. F i = 0", "by auto"], ["proof (state)\nthis:\n  F i = 0\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i \\<in> range ffp", "thus ?thesis"], ["proof (prove)\nusing this:\n  F i = 0\n\ngoal (1 subgoal):\n 1. F i \\<in> range ffp", "by simp"], ["proof (state)\nthis:\n  F i \\<in> range ffp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F i \\<in> range ffp\n\ngoal (3 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk\n 3. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk\n 3. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "assume \"3 \\<le> i\" and \"i \\<le> Suc k\""], ["proof (state)\nthis:\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (3 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk\n 3. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "then"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> Suc k", "consider (3) \"i = 3\" | (4) \"3 \\<le> i - 1\" \"i - 1 \\<le> k\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 3 \\<Longrightarrow> thesis;\n     \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>i = 3 \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (3 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk\n 3. \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "thus \"\\<beta> i \\<in> range ff\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 3 \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<beta> i \\<in> range ff", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow> \\<beta> i \\<in> range ff\n 2. \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "case 3"], ["proof (state)\nthis:\n  i = 3\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow> \\<beta> i \\<in> range ff\n 2. \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "have \"\\<beta> i = ff ((- 1) ^ (\\<delta> 1 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> i = ff ((- (1::'a)) ^ (\\<delta> 1 + 1))", "unfolding 3 \\<beta>3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (\\<delta> 1 + 1) = ff ((- (1::'a)) ^ (\\<delta> 1 + 1))", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  \\<beta> i = ff ((- (1::'a)) ^ (\\<delta> 1 + 1))\n\ngoal (2 subgoals):\n 1. i = 3 \\<Longrightarrow> \\<beta> i \\<in> range ff\n 2. \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> i = ff ((- (1::'a)) ^ (\\<delta> 1 + 1))\n\ngoal (1 subgoal):\n 1. \\<beta> i \\<in> range ff", "by blast"], ["proof (state)\nthis:\n  \\<beta> i \\<in> range ff\n\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "case 4"], ["proof (state)\nthis:\n  3 \\<le> i - 1\n  i - 1 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> i - 1; i - 1 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> \\<beta> i \\<in> range ff", "with main[of \"i - 1\"]"], ["proof (chain)\npicking this:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (3 \\<le> i - 1 \\<longrightarrow>\n   i - 1 \\<le> k \\<longrightarrow>\n   F (i - 1) \\<in> range ffp \\<and> \\<beta> (Suc (i - 1)) \\<in> range ff)\n  3 \\<le> i - 1\n  i - 1 \\<le> k", "show ?thesis"], ["proof (prove)\nusing this:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (3 \\<le> i - 1 \\<longrightarrow>\n   i - 1 \\<le> k \\<longrightarrow>\n   F (i - 1) \\<in> range ffp \\<and> \\<beta> (Suc (i - 1)) \\<in> range ff)\n  3 \\<le> i - 1\n  i - 1 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<beta> i \\<in> range ff", "by auto"], ["proof (state)\nthis:\n  \\<beta> i \\<in> range ff\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta> i \\<in> range ff\n\ngoal (2 subgoals):\n 1. F k = ffp Gk\n 2. h k = ff hk", "qed (insert main, auto)"], ["proof (state)\nthis:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (i \\<noteq> 0 \\<longrightarrow> F i \\<in> range ffp) \\<and>\n  (3 \\<le> i \\<longrightarrow>\n   i \\<le> Suc k \\<longrightarrow> \\<beta> i \\<in> range ff)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resultant_impl_main: \"resultant_impl_main div_exp G1 G2 = resultant G1 G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "from F0[of 2] F12(2)"], ["proof (chain)\npicking this:\n  2 \\<noteq> 0 \\<Longrightarrow> (F 2 = 0) = (k < 2)\n  F 2 \\<noteq> 0", "have k2: \"k \\<ge> 2\""], ["proof (prove)\nusing this:\n  2 \\<noteq> 0 \\<Longrightarrow> (F 2 = 0) = (k < 2)\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> k", "by auto"], ["proof (state)\nthis:\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "obtain Gk hk where sub: \"subresultant_prs div_exp G1 G2 = (Gk, hk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Gk hk.\n        subresultant_prs div_exp G1 G2 = (Gk, hk) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  subresultant_prs div_exp G1 G2 = (Gk, hk)\n\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "from subresultant_prs[OF this]"], ["proof (chain)\npicking this:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (?i \\<noteq> 0 \\<longrightarrow> F ?i \\<in> range ffp) \\<and>\n  (3 \\<le> ?i \\<longrightarrow>\n   ?i \\<le> Suc k \\<longrightarrow> \\<beta> ?i \\<in> range ff)", "have *: \"F k = ffp Gk\" \"h k = ff hk\""], ["proof (prove)\nusing this:\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (?i \\<noteq> 0 \\<longrightarrow> F ?i \\<in> range ffp) \\<and>\n  (3 \\<le> ?i \\<longrightarrow>\n   ?i \\<le> Suc k \\<longrightarrow> \\<beta> ?i \\<in> range ff)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk &&& h k = ff hk", "by auto"], ["proof (state)\nthis:\n  F k = ffp Gk\n  h k = ff hk\n\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "have \"resultant_impl_main div_exp G1 G2 = (if degree (F k) = 0 then hk else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 =\n    (if degree (F k) = 0 then hk else (0::'a))", "unfolding resultant_impl_main_def sub split *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if G2 = 0 then if degree G1 = 0 then 1::'a else (0::'a)\n     else if degree Gk = 0 then hk else (0::'a)) =\n    (if degree (ffp Gk) = 0 then hk else (0::'a))", "using F2 F12"], ["proof (prove)\nusing this:\n  F 2 = ffp G2\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if G2 = 0 then if degree G1 = 0 then 1::'a else (0::'a)\n     else if degree Gk = 0 then hk else (0::'a)) =\n    (if degree (ffp Gk) = 0 then hk else (0::'a))", "by auto"], ["proof (state)\nthis:\n  resultant_impl_main div_exp G1 G2 =\n  (if degree (F k) = 0 then hk else (0::'a))\n\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "also"], ["proof (state)\nthis:\n  resultant_impl_main div_exp G1 G2 =\n  (if degree (F k) = 0 then hk else (0::'a))\n\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "have \"\\<dots> = resultant G1 G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "proof (cases \"n k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n k = 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n 2. n k \\<noteq> 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "case False"], ["proof (state)\nthis:\n  n k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n k = 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n 2. n k \\<noteq> 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "with fundamental_theorem_eq_7[of 0]"], ["proof (chain)\npicking this:\n  0 < n k \\<Longrightarrow> R 0 = 0\n  n k \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n k \\<Longrightarrow> R 0 = 0\n  n k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "unfolding n[of k] * R0"], ["proof (prove)\nusing this:\n  0 < degree (ffp Gk) \\<Longrightarrow> [:resultant G1 G2:] = 0\n  degree (ffp Gk) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if degree (ffp Gk) = 0 then hk else (0::'a)) = resultant G1 G2", "by auto"], ["proof (state)\nthis:\n  (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n\ngoal (1 subgoal):\n 1. n k = 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n k = 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "case True"], ["proof (state)\nthis:\n  n k = 0\n\ngoal (1 subgoal):\n 1. n k = 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from H_def[of k, unfolded True]"], ["proof (chain)\npicking this:\n  H k = R 0", "have R: \"R 0 = H k\""], ["proof (prove)\nusing this:\n  H k = R 0\n\ngoal (1 subgoal):\n 1. R 0 = H k", "by simp"], ["proof (state)\nthis:\n  R 0 = H k\n\ngoal (1 subgoal):\n 1. n k = 0 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "proof (cases \"k = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 2\n\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "with k2"], ["proof (chain)\npicking this:\n  2 \\<le> k\n  k \\<noteq> 2", "have k3: \"k \\<ge> 3\""], ["proof (prove)\nusing this:\n  2 \\<le> k\n  k \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 3 \\<le> k", "by auto"], ["proof (state)\nthis:\n  3 \\<le> k\n\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from B_theorem_3[OF k3] R0 R"], ["proof (chain)\npicking this:\n  k \\<le> k \\<Longrightarrow> h k = \\<Theta> k * f k\n  k \\<le> k \\<Longrightarrow> h k = ff (lead_coeff (H k))\n  R 0 = [:resultant G1 G2:]\n  R 0 = H k", "have \"h k = ff (resultant G1 G2)\""], ["proof (prove)\nusing this:\n  k \\<le> k \\<Longrightarrow> h k = \\<Theta> k * f k\n  k \\<le> k \\<Longrightarrow> h k = ff (lead_coeff (H k))\n  R 0 = [:resultant G1 G2:]\n  R 0 = H k\n\ngoal (1 subgoal):\n 1. h k = ff (resultant G1 G2)", "by simp"], ["proof (state)\nthis:\n  h k = ff (resultant G1 G2)\n\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from this[folded *] *"], ["proof (chain)\npicking this:\n  h k = ff (resultant G1 G2)\n  F k = ffp Gk\n  h k = ff hk", "have \"hk = resultant G1 G2\""], ["proof (prove)\nusing this:\n  h k = ff (resultant G1 G2)\n  F k = ffp Gk\n  h k = ff hk\n\ngoal (1 subgoal):\n 1. hk = resultant G1 G2", "by simp"], ["proof (state)\nthis:\n  hk = resultant G1 G2\n\ngoal (2 subgoals):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n 2. k \\<noteq> 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "with True"], ["proof (chain)\npicking this:\n  n k = 0\n  hk = resultant G1 G2", "show ?thesis"], ["proof (prove)\nusing this:\n  n k = 0\n  hk = resultant G1 G2\n\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "unfolding n"], ["proof (prove)\nusing this:\n  degree (F k) = 0\n  hk = resultant G1 G2\n\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "by auto"], ["proof (state)\nthis:\n  (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "case 2: True"], ["proof (state)\nthis:\n  k = 2\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "have id: \"(if degree (F k) = 0 then hk else 0) = hk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = hk", "using True"], ["proof (prove)\nusing this:\n  n k = 0\n\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = hk", "unfolding n"], ["proof (prove)\nusing this:\n  degree (F k) = 0\n\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = hk", "by simp"], ["proof (state)\nthis:\n  (if degree (F k) = 0 then hk else (0::'a)) = hk\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from F0[of 3, unfolded 2]"], ["proof (chain)\npicking this:\n  3 \\<noteq> 0 \\<Longrightarrow> (F 3 = 0) = (2 < 3)", "have \"F 3 = 0\""], ["proof (prove)\nusing this:\n  3 \\<noteq> 0 \\<Longrightarrow> (F 3 = 0) = (2 < 3)\n\ngoal (1 subgoal):\n 1. F 3 = 0", "by simp"], ["proof (state)\nthis:\n  F 3 = 0\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "with pmod[of 3, unfolded 2] \\<beta>0[of 3]"], ["proof (chain)\npicking this:\n  \\<lbrakk>3 \\<le> 3; 3 \\<le> Suc 2\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> 3) (F 3) =\n                    pseudo_mod (F (3 - 2)) (F (3 - 1))\n  \\<beta> 3 \\<noteq> 0\n  F 3 = 0", "have \"pseudo_mod (F 1) (F 2) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> 3; 3 \\<le> Suc 2\\<rbrakk>\n  \\<Longrightarrow> Polynomial.smult (\\<beta> 3) (F 3) =\n                    pseudo_mod (F (3 - 2)) (F (3 - 1))\n  \\<beta> 3 \\<noteq> 0\n  F 3 = 0\n\ngoal (1 subgoal):\n 1. pseudo_mod (F 1) (F 2) = 0", "by auto"], ["proof (state)\nthis:\n  pseudo_mod (F 1) (F 2) = 0\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "hence pm: \"pseudo_mod G1 G2 = 0\""], ["proof (prove)\nusing this:\n  pseudo_mod (F 1) (F 2) = 0\n\ngoal (1 subgoal):\n 1. pseudo_mod G1 G2 = 0", "unfolding F1 F2 to_fract_hom.pseudo_mod_hom"], ["proof (prove)\nusing this:\n  ffp (pseudo_mod G1 G2) = 0\n\ngoal (1 subgoal):\n 1. pseudo_mod G1 G2 = 0", "by simp"], ["proof (state)\nthis:\n  pseudo_mod G1 G2 = 0\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from subresultant_prs_def[of div_exp G1 G2, unfolded sub Let_def this]"], ["proof (chain)\npicking this:\n  (Gk, hk) =\n  (if 0 = 0 then (G2, lead_coeff G2 ^ (degree G1 - degree G2))\n   else subresultant_prs_main div_exp G2\n         ((- 1) ^ (degree G1 - degree G2 + 1) * 0)\n         (lead_coeff G2 ^ (degree G1 - degree G2)))", "have id: \"Gk = G2\" \"hk = lead_coeff G2 ^ (degree G1 - degree G2)\""], ["proof (prove)\nusing this:\n  (Gk, hk) =\n  (if 0 = 0 then (G2, lead_coeff G2 ^ (degree G1 - degree G2))\n   else subresultant_prs_main div_exp G2\n         ((- 1) ^ (degree G1 - degree G2 + 1) * 0)\n         (lead_coeff G2 ^ (degree G1 - degree G2)))\n\ngoal (1 subgoal):\n 1. Gk = G2 &&& hk = lead_coeff G2 ^ (degree G1 - degree G2)", "by auto"], ["proof (state)\nthis:\n  Gk = G2\n  hk = lead_coeff G2 ^ (degree G1 - degree G2)\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from F12 F1 F2"], ["proof (chain)\npicking this:\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n  F 1 = ffp G1\n  F 2 = ffp G2", "have \"G1 \\<noteq> 0\" \"G2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n  F 1 = ffp G1\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. G1 \\<noteq> 0 &&& G2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  G1 \\<noteq> 0\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from resultant_pseudo_mod_0[OF pm deg_G12 this]"], ["proof (chain)\npicking this:\n  resultant G1 G2 =\n  (if degree G2 = 0 then lead_coeff G2 ^ degree G1 else (0::'a))", "have res: \"resultant G1 G2 = (if degree G2 = 0 then lead_coeff G2 ^ degree G1 else 0)\""], ["proof (prove)\nusing this:\n  resultant G1 G2 =\n  (if degree G2 = 0 then lead_coeff G2 ^ degree G1 else (0::'a))\n\ngoal (1 subgoal):\n 1. resultant G1 G2 =\n    (if degree G2 = 0 then lead_coeff G2 ^ degree G1 else (0::'a))", "by simp"], ["proof (state)\nthis:\n  resultant G1 G2 =\n  (if degree G2 = 0 then lead_coeff G2 ^ degree G1 else (0::'a))\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "from True[unfolded 2 n F2]"], ["proof (chain)\npicking this:\n  degree (ffp G2) = 0", "have \"degree G2 = 0\""], ["proof (prove)\nusing this:\n  degree (ffp G2) = 0\n\ngoal (1 subgoal):\n 1. degree G2 = 0", "by simp"], ["proof (state)\nthis:\n  degree G2 = 0\n\ngoal (1 subgoal):\n 1. k = 2 \\<Longrightarrow>\n    (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree G2 = 0\n\ngoal (1 subgoal):\n 1. (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2", "unfolding res 2 F2 id"], ["proof (prove)\nusing this:\n  degree G2 = 0\n\ngoal (1 subgoal):\n 1. (if degree (ffp G2) = 0 then lead_coeff G2 ^ (degree G1 - degree G2)\n     else (0::'a)) =\n    (if degree G2 = 0 then lead_coeff G2 ^ degree G1 else (0::'a))", "by simp"], ["proof (state)\nthis:\n  (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if degree (F k) = 0 then hk else (0::'a)) = resultant G1 G2\n\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "finally"], ["proof (chain)\npicking this:\n  resultant_impl_main div_exp G1 G2 = resultant G1 G2", "show ?thesis"], ["proof (prove)\nusing this:\n  resultant_impl_main div_exp G1 G2 = resultant G1 G2\n\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "."], ["proof (state)\nthis:\n  resultant_impl_main div_exp G1 G2 = resultant G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "text \\<open>At this point, we have soundness of the resultant-implementation, provided that we can\n  instantiate the locale by constructing suitable values of F, b, h, etc. Now we show the\n  existence of suitable locale parameters by constructively computing them.\\<close>"], ["", "context\n  fixes G1 G2 :: \"'a :: idom_divide poly\"\nbegin"], ["", "private"], ["", "function F and b and h where \"F i = (if i = (0 :: nat) then 1\n  else if i = 1 then map_poly to_fract G1 else if i = 2 then map_poly to_fract G2\n  else (let G = pseudo_mod (F (i - 2)) (F (i - 1))\n    in if F (i - 1) = 0 \\<or> G = 0 then 0 else smult (inverse (b i)) G))\"\n| \"b i = (if i \\<le> 2 then 1 else\n   if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n   else if F (i - 2) = 0 then 1 else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) * lead_coeff (F (i - 2)) *\n         h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1))))\"\n| \"h i = (if (i \\<le> 1) then 1 else if i = 2 then (lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))) else\n    if F i = 0 then 1 else (lead_coeff (F i) ^ (degree (F (i - 1)) - degree (F i)) / (h (i - 1) ^ ((degree (F (i - 1)) - degree (F i)) - 1))))\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>i. x = Inl i \\<Longrightarrow> P;\n        \\<And>i. x = Inr (Inl i) \\<Longrightarrow> P;\n        \\<And>i. x = Inr (Inr i) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>i ia.\n       Inl i = Inl ia \\<Longrightarrow>\n       Inl (if i = 0 then 1\n            else if i = 1 then map_poly to_fract G1\n                 else if i = 2 then map_poly to_fract G2\n                      else let G = pseudo_mod\n                                    (projl (F_b_h_sumC (Inl (i - 2))))\n                                    (projl (F_b_h_sumC (Inl (i - 1))))\n                           in if projl (F_b_h_sumC (Inl (i - 1))) = 0 \\<or>\n                                 G = 0\n                              then 0\n                              else Polynomial.smult\n                                    (inverse\n(projr (F_b_h_sumC (Inr (Inl i)))))\n                                    G) =\n       Inl (if ia = 0 then 1\n            else if ia = 1 then map_poly to_fract G1\n                 else if ia = 2 then map_poly to_fract G2\n                      else let G = pseudo_mod\n                                    (projl (F_b_h_sumC (Inl (ia - 2))))\n                                    (projl (F_b_h_sumC (Inl (ia - 1))))\n                           in if projl (F_b_h_sumC (Inl (ia - 1))) = 0 \\<or>\n                                 G = 0\n                              then 0\n                              else Polynomial.smult\n                                    (inverse\n(projr (F_b_h_sumC (Inr (Inl ia)))))\n                                    G)\n 3. \\<And>i ia.\n       Inl i = Inr (Inl ia) \\<Longrightarrow>\n       Inl (if i = 0 then 1\n            else if i = 1 then map_poly to_fract G1\n                 else if i = 2 then map_poly to_fract G2\n                      else let G = pseudo_mod\n                                    (projl (F_b_h_sumC (Inl (i - 2))))\n                                    (projl (F_b_h_sumC (Inl (i - 1))))\n                           in if projl (F_b_h_sumC (Inl (i - 1))) = 0 \\<or>\n                                 G = 0\n                              then 0\n                              else Polynomial.smult\n                                    (inverse\n(projr (F_b_h_sumC (Inr (Inl i)))))\n                                    G) =\n       Inr (if ia \\<le> 2 then 1\n            else if ia = 3\n                 then (- 1) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))) +\n                       1)\n                 else if projl (F_b_h_sumC (Inl (ia - 2))) = 0 then 1\n                      else (- 1) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (ia - 1)))) +\n                            1) *\n                           lead_coeff (projl (F_b_h_sumC (Inl (ia - 2)))) *\n                           projr (F_b_h_sumC (Inr (Inr (ia - 2)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (ia - 1))))))\n 4. \\<And>i ia.\n       Inl i = Inr (Inr ia) \\<Longrightarrow>\n       Inl (if i = 0 then 1\n            else if i = 1 then map_poly to_fract G1\n                 else if i = 2 then map_poly to_fract G2\n                      else let G = pseudo_mod\n                                    (projl (F_b_h_sumC (Inl (i - 2))))\n                                    (projl (F_b_h_sumC (Inl (i - 1))))\n                           in if projl (F_b_h_sumC (Inl (i - 1))) = 0 \\<or>\n                                 G = 0\n                              then 0\n                              else Polynomial.smult\n                                    (inverse\n(projr (F_b_h_sumC (Inr (Inl i)))))\n                                    G) =\n       Inr (if ia \\<le> 1 then 1\n            else if ia = 2\n                 then lead_coeff (projl (F_b_h_sumC (Inl 2))) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))))\n                 else if projl (F_b_h_sumC (Inl ia)) = 0 then 1\n                      else lead_coeff (projl (F_b_h_sumC (Inl ia))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl ia)))) /\n                           projr (F_b_h_sumC (Inr (Inr (ia - 1)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl ia))) -\n                            1))\n 5. \\<And>i ia.\n       Inr (Inl i) = Inr (Inl ia) \\<Longrightarrow>\n       Inr (if i \\<le> 2 then 1\n            else if i = 3\n                 then (- 1) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))) +\n                       1)\n                 else if projl (F_b_h_sumC (Inl (i - 2))) = 0 then 1\n                      else (- 1) ^\n                           (degree (projl (F_b_h_sumC (Inl (i - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (i - 1)))) +\n                            1) *\n                           lead_coeff (projl (F_b_h_sumC (Inl (i - 2)))) *\n                           projr (F_b_h_sumC (Inr (Inr (i - 2)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (i - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (i - 1)))))) =\n       Inr (if ia \\<le> 2 then 1\n            else if ia = 3\n                 then (- 1) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))) +\n                       1)\n                 else if projl (F_b_h_sumC (Inl (ia - 2))) = 0 then 1\n                      else (- 1) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (ia - 1)))) +\n                            1) *\n                           lead_coeff (projl (F_b_h_sumC (Inl (ia - 2)))) *\n                           projr (F_b_h_sumC (Inr (Inr (ia - 2)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (ia - 1))))))\n 6. \\<And>i ia.\n       Inr (Inl i) = Inr (Inr ia) \\<Longrightarrow>\n       Inr (if i \\<le> 2 then 1\n            else if i = 3\n                 then (- 1) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))) +\n                       1)\n                 else if projl (F_b_h_sumC (Inl (i - 2))) = 0 then 1\n                      else (- 1) ^\n                           (degree (projl (F_b_h_sumC (Inl (i - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (i - 1)))) +\n                            1) *\n                           lead_coeff (projl (F_b_h_sumC (Inl (i - 2)))) *\n                           projr (F_b_h_sumC (Inr (Inr (i - 2)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (i - 2)))) -\n                            degree (projl (F_b_h_sumC (Inl (i - 1)))))) =\n       Inr (if ia \\<le> 1 then 1\n            else if ia = 2\n                 then lead_coeff (projl (F_b_h_sumC (Inl 2))) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))))\n                 else if projl (F_b_h_sumC (Inl ia)) = 0 then 1\n                      else lead_coeff (projl (F_b_h_sumC (Inl ia))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl ia)))) /\n                           projr (F_b_h_sumC (Inr (Inr (ia - 1)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl ia))) -\n                            1))\n 7. \\<And>i ia.\n       Inr (Inr i) = Inr (Inr ia) \\<Longrightarrow>\n       Inr (if i \\<le> 1 then 1\n            else if i = 2\n                 then lead_coeff (projl (F_b_h_sumC (Inl 2))) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))))\n                 else if projl (F_b_h_sumC (Inl i)) = 0 then 1\n                      else lead_coeff (projl (F_b_h_sumC (Inl i))) ^\n                           (degree (projl (F_b_h_sumC (Inl (i - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl i)))) /\n                           projr (F_b_h_sumC (Inr (Inr (i - 1)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (i - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl i))) -\n                            1)) =\n       Inr (if ia \\<le> 1 then 1\n            else if ia = 2\n                 then lead_coeff (projl (F_b_h_sumC (Inl 2))) ^\n                      (degree (projl (F_b_h_sumC (Inl 1))) -\n                       degree (projl (F_b_h_sumC (Inl 2))))\n                 else if projl (F_b_h_sumC (Inl ia)) = 0 then 1\n                      else lead_coeff (projl (F_b_h_sumC (Inl ia))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl ia)))) /\n                           projr (F_b_h_sumC (Inr (Inr (ia - 1)))) ^\n                           (degree (projl (F_b_h_sumC (Inl (ia - 1)))) -\n                            degree (projl (F_b_h_sumC (Inl ia))) -\n                            1))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All F_b_h_dom", "proof"], ["proof (state)\ngoal (27 subgoals):\n 1. wf ?R\n 2. \\<And>i.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 2), Inl i) \\<in> ?R\n 3. \\<And>i.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 1), Inl i) \\<in> ?R\n 4. \\<And>i x.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2;\n        x = pseudo_mod (F (i - 2)) (F (i - 1)); F_b_h_dom (Inl (i - 1));\n        F_b_h_dom (Inl (i - 2))\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 1), Inl i) \\<in> ?R\n 5. \\<And>i x.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2;\n        x = pseudo_mod (F (i - 2)) (F (i - 1));\n        \\<not> (F (i - 1) = 0 \\<or> x = 0); F_b_h_dom (Inl (i - 1));\n        F_b_h_dom (Inl (i - 1)); F_b_h_dom (Inl (i - 2))\\<rbrakk>\n       \\<Longrightarrow> (Inr (Inl i), Inl i) \\<in> ?R\n 6. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i = 3\\<rbrakk>\n       \\<Longrightarrow> (Inl 1, Inr (Inl i)) \\<in> ?R\n 7. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i = 3\\<rbrakk>\n       \\<Longrightarrow> (Inl 2, Inr (Inl i)) \\<in> ?R\n 8. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i \\<noteq> 3\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 2), Inr (Inl i)) \\<in> ?R\n 9. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i \\<noteq> 3; F (i - 2) \\<noteq> 0;\n        F_b_h_dom (Inl (i - 2))\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 2), Inr (Inl i)) \\<in> ?R\n 10. \\<And>i.\n        \\<lbrakk>\\<not> i \\<le> 2; i \\<noteq> 3; F (i - 2) \\<noteq> 0;\n         F_b_h_dom (Inl (i - 2))\\<rbrakk>\n        \\<Longrightarrow> (Inl (i - 1), Inr (Inl i)) \\<in> ?R\nA total of 27 subgoals...", "show \"wf (measure (case_sum (\\<lambda> fi. 3 * fi +1)  (case_sum (\\<lambda> bi. 3 * bi) (\\<lambda> hi. 3 * hi + 2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure\n         (case_sum (\\<lambda>fi. 3 * fi + 1)\n           (case_sum ((*) 3) (\\<lambda>hi. 3 * hi + 2))))", "by simp"], ["proof (state)\nthis:\n  wf (measure\n       (case_sum (\\<lambda>fi. 3 * fi + 1)\n         (case_sum ((*) 3) (\\<lambda>hi. 3 * hi + 2))))\n\ngoal (26 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 2), Inl i)\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 2. \\<And>i.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 1), Inl i)\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 3. \\<And>i x.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2;\n        x = pseudo_mod (F (i - 2)) (F (i - 1)); F_b_h_dom (Inl (i - 1));\n        F_b_h_dom (Inl (i - 2))\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 1), Inl i)\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 4. \\<And>i x.\n       \\<lbrakk>i \\<noteq> 0; i \\<noteq> 1; i \\<noteq> 2;\n        x = pseudo_mod (F (i - 2)) (F (i - 1));\n        \\<not> (F (i - 1) = 0 \\<or> x = 0); F_b_h_dom (Inl (i - 1));\n        F_b_h_dom (Inl (i - 1)); F_b_h_dom (Inl (i - 2))\\<rbrakk>\n       \\<Longrightarrow> (Inr (Inl i), Inl i)\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 5. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i = 3\\<rbrakk>\n       \\<Longrightarrow> (Inl 1, Inr (Inl i))\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 6. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i = 3\\<rbrakk>\n       \\<Longrightarrow> (Inl 2, Inr (Inl i))\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 7. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i \\<noteq> 3\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 2), Inr (Inl i))\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 8. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i \\<noteq> 3; F (i - 2) \\<noteq> 0;\n        F_b_h_dom (Inl (i - 2))\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 2), Inr (Inl i))\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 9. \\<And>i.\n       \\<lbrakk>\\<not> i \\<le> 2; i \\<noteq> 3; F (i - 2) \\<noteq> 0;\n        F_b_h_dom (Inl (i - 2))\\<rbrakk>\n       \\<Longrightarrow> (Inl (i - 1), Inr (Inl i))\n                         \\<in> measure\n                                (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                  (case_sum ((*) 3)\n                                    (\\<lambda>hi. 3 * hi + 2)))\n 10. \\<And>i.\n        \\<lbrakk>\\<not> i \\<le> 2; i \\<noteq> 3; F (i - 2) \\<noteq> 0;\n         F_b_h_dom (Inl (i - 2))\\<rbrakk>\n        \\<Longrightarrow> (Inl (i - 2), Inr (Inl i))\n                          \\<in> measure\n                                 (case_sum (\\<lambda>fi. 3 * fi + 1)\n                                   (case_sum ((*) 3)\n                                     (\\<lambda>hi. 3 * hi + 2)))\nA total of 26 subgoals...", "qed (auto simp: termination_simp)"], ["", "declare h.simps[simp del] b.simps[simp del] F.simps[simp del]"], ["", "private"], ["", "lemma Fb0: assumes base: \"G1 \\<noteq> 0\" \"G2 \\<noteq> 0\"\n  shows \"(F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and> b i \\<noteq> 0 \\<and> h i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "proof (induct i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           (F y = 0 \\<longrightarrow> F (Suc y) = 0) \\<and>\n           b y \\<noteq> 0 \\<and> h y \\<noteq> 0) \\<Longrightarrow>\n       (F x = 0 \\<longrightarrow> F (Suc x) = 0) \\<and>\n       b x \\<noteq> 0 \\<and> h x \\<noteq> 0", "case (less i)"], ["proof (state)\nthis:\n  ?y < i \\<Longrightarrow>\n  (F ?y = 0 \\<longrightarrow> F (Suc ?y) = 0) \\<and>\n  b ?y \\<noteq> 0 \\<and> h ?y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           (F y = 0 \\<longrightarrow> F (Suc y) = 0) \\<and>\n           b y \\<noteq> 0 \\<and> h y \\<noteq> 0) \\<Longrightarrow>\n       (F x = 0 \\<longrightarrow> F (Suc x) = 0) \\<and>\n       b x \\<noteq> 0 \\<and> h x \\<noteq> 0", "note * [simp] = F.simps[of i] b.simps[of i] h.simps[of i]"], ["proof (state)\nthis:\n  F i =\n  (if i = 0 then 1\n   else if i = 1 then map_poly to_fract G1\n        else if i = 2 then map_poly to_fract G2\n             else let G = pseudo_mod (F (i - 2)) (F (i - 1))\n                  in if F (i - 1) = 0 \\<or> G = 0 then 0\n                     else Polynomial.smult (inverse (b i)) G)\n  b i =\n  (if i \\<le> 2 then 1\n   else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n        else if F (i - 2) = 0 then 1\n             else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                  lead_coeff (F (i - 2)) *\n                  h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1))))\n  h i =\n  (if i \\<le> 1 then 1\n   else if i = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n        else if F i = 0 then 1\n             else lead_coeff (F i) ^ (degree (F (i - 1)) - degree (F i)) /\n                  h (i - 1) ^ (degree (F (i - 1)) - degree (F i) - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           (F y = 0 \\<longrightarrow> F (Suc y) = 0) \\<and>\n           b y \\<noteq> 0 \\<and> h y \\<noteq> 0) \\<Longrightarrow>\n       (F x = 0 \\<longrightarrow> F (Suc x) = 0) \\<and>\n       b x \\<noteq> 0 \\<and> h x \\<noteq> 0", "consider (0) \"i = 0\" | (1) \"i = 1\" | (2) \"i \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<Longrightarrow> thesis; i = 1 \\<Longrightarrow> thesis;\n     2 \\<le> i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           (F y = 0 \\<longrightarrow> F (Suc y) = 0) \\<and>\n           b y \\<noteq> 0 \\<and> h y \\<noteq> 0) \\<Longrightarrow>\n       (F x = 0 \\<longrightarrow> F (Suc x) = 0) \\<and>\n       b x \\<noteq> 0 \\<and> h x \\<noteq> 0", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n 2. i = 1 \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n 3. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (3 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n 2. i = 1 \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n 3. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if i = 0 then 1\n      else if i = 1 then map_poly to_fract G1\n           else if i = 2 then map_poly to_fract G2\n                else let G = pseudo_mod (F (i - 2)) (F (i - 1))\n                     in if F (i - 1) = 0 \\<or> G = 0 then 0\n                        else Polynomial.smult\n                              (inverse\n                                (if i \\<le> 2 then 1\n                                 else if i = 3\nthen (- 1) ^ (degree (F 1) - degree (F 2) + 1)\nelse if F (i - 2) = 0 then 1\n     else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n          lead_coeff (F (i - 2)) *\n          h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))))\n                              G) =\n     0 \\<longrightarrow>\n     F (Suc i) = 0) \\<and>\n    (if i \\<le> 2 then 1\n     else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (i - 2) = 0 then 1\n               else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                    lead_coeff (F (i - 2)) *\n                    h (i - 2) ^\n                    (degree (F (i - 2)) - degree (F (i - 1)))) \\<noteq>\n    0 \\<and>\n    (if i \\<le> 1 then 1\n     else if i = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n          else if (if i = 0 then 1\n                   else if i = 1 then map_poly to_fract G1\n                        else if i = 2 then map_poly to_fract G2\n                             else let G = pseudo_mod (F (i - 2)) (F (i - 1))\n                                  in if F (i - 1) = 0 \\<or> G = 0 then 0\n                                     else Polynomial.smult\n     (inverse\n       (if i \\<le> 2 then 1\n        else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n             else if F (i - 2) = 0 then 1\n                  else (- 1) ^\n                       (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                       lead_coeff (F (i - 2)) *\n                       h (i - 2) ^\n                       (degree (F (i - 2)) - degree (F (i - 1)))))\n     G) =\n                  0\n               then 1\n               else lead_coeff\n                     (if i = 0 then 1\n                      else if i = 1 then map_poly to_fract G1\n                           else if i = 2 then map_poly to_fract G2\n                                else let G =\n     pseudo_mod (F (i - 2)) (F (i - 1))\n                                     in if F (i - 1) = 0 \\<or> G = 0 then 0\n  else Polynomial.smult\n        (inverse\n          (if i \\<le> 2 then 1\n           else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                else if F (i - 2) = 0 then 1\n                     else (- 1) ^\n                          (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                          lead_coeff (F (i - 2)) *\n                          h (i - 2) ^\n                          (degree (F (i - 2)) - degree (F (i - 1)))))\n        G) ^\n                    (degree (F (i - 1)) -\n                     degree\n                      (if i = 0 then 1\n                       else if i = 1 then map_poly to_fract G1\n                            else if i = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (i - 2)) (F (i - 1))\nin if F (i - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if i \\<le> 2 then 1\n            else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (i - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                           lead_coeff (F (i - 2)) *\n                           h (i - 2) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)))))\n         G)) /\n                    h (i - 1) ^\n                    (degree (F (i - 1)) -\n                     degree\n                      (if i = 0 then 1\n                       else if i = 1 then map_poly to_fract G1\n                            else if i = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (i - 2)) (F (i - 1))\nin if F (i - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if i \\<le> 2 then 1\n            else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (i - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                           lead_coeff (F (i - 2)) *\n                           h (i - 2) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)))))\n         G) -\n                     1)) \\<noteq>\n    0", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if 0 = 0 then 1\n      else if 0 = 1 then map_poly to_fract G1\n           else if 0 = 2 then map_poly to_fract G2\n                else let G = pseudo_mod (F (0 - 2)) (F (0 - 1))\n                     in if F (0 - 1) = 0 \\<or> G = 0 then 0\n                        else Polynomial.smult\n                              (inverse\n                                (if 0 \\<le> 2 then 1\n                                 else if 0 = 3\nthen (- 1) ^ (degree (F 1) - degree (F 2) + 1)\nelse if F (0 - 2) = 0 then 1\n     else (- 1) ^ (degree (F (0 - 2)) - degree (F (0 - 1)) + 1) *\n          lead_coeff (F (0 - 2)) *\n          h (0 - 2) ^ (degree (F (0 - 2)) - degree (F (0 - 1)))))\n                              G) =\n     0 \\<longrightarrow>\n     F (Suc 0) = 0) \\<and>\n    (if 0 \\<le> 2 then 1\n     else if 0 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (0 - 2) = 0 then 1\n               else (- 1) ^ (degree (F (0 - 2)) - degree (F (0 - 1)) + 1) *\n                    lead_coeff (F (0 - 2)) *\n                    h (0 - 2) ^\n                    (degree (F (0 - 2)) - degree (F (0 - 1)))) \\<noteq>\n    0 \\<and>\n    (if 0 \\<le> 1 then 1\n     else if 0 = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n          else if (if 0 = 0 then 1\n                   else if 0 = 1 then map_poly to_fract G1\n                        else if 0 = 2 then map_poly to_fract G2\n                             else let G = pseudo_mod (F (0 - 2)) (F (0 - 1))\n                                  in if F (0 - 1) = 0 \\<or> G = 0 then 0\n                                     else Polynomial.smult\n     (inverse\n       (if 0 \\<le> 2 then 1\n        else if 0 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n             else if F (0 - 2) = 0 then 1\n                  else (- 1) ^\n                       (degree (F (0 - 2)) - degree (F (0 - 1)) + 1) *\n                       lead_coeff (F (0 - 2)) *\n                       h (0 - 2) ^\n                       (degree (F (0 - 2)) - degree (F (0 - 1)))))\n     G) =\n                  0\n               then 1\n               else lead_coeff\n                     (if 0 = 0 then 1\n                      else if 0 = 1 then map_poly to_fract G1\n                           else if 0 = 2 then map_poly to_fract G2\n                                else let G =\n     pseudo_mod (F (0 - 2)) (F (0 - 1))\n                                     in if F (0 - 1) = 0 \\<or> G = 0 then 0\n  else Polynomial.smult\n        (inverse\n          (if 0 \\<le> 2 then 1\n           else if 0 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                else if F (0 - 2) = 0 then 1\n                     else (- 1) ^\n                          (degree (F (0 - 2)) - degree (F (0 - 1)) + 1) *\n                          lead_coeff (F (0 - 2)) *\n                          h (0 - 2) ^\n                          (degree (F (0 - 2)) - degree (F (0 - 1)))))\n        G) ^\n                    (degree (F (0 - 1)) -\n                     degree\n                      (if 0 = 0 then 1\n                       else if 0 = 1 then map_poly to_fract G1\n                            else if 0 = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (0 - 2)) (F (0 - 1))\nin if F (0 - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if 0 \\<le> 2 then 1\n            else if 0 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (0 - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (0 - 2)) - degree (F (0 - 1)) + 1) *\n                           lead_coeff (F (0 - 2)) *\n                           h (0 - 2) ^\n                           (degree (F (0 - 2)) - degree (F (0 - 1)))))\n         G)) /\n                    h (0 - 1) ^\n                    (degree (F (0 - 1)) -\n                     degree\n                      (if 0 = 0 then 1\n                       else if 0 = 1 then map_poly to_fract G1\n                            else if 0 = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (0 - 2)) (F (0 - 1))\nin if F (0 - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if 0 \\<le> 2 then 1\n            else if 0 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (0 - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (0 - 2)) - degree (F (0 - 1)) + 1) *\n                           lead_coeff (F (0 - 2)) *\n                           h (0 - 2) ^\n                           (degree (F (0 - 2)) - degree (F (0 - 1)))))\n         G) -\n                     1)) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n  b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n 2. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n 2. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "case 1"], ["proof (state)\nthis:\n  i = 1\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n 2. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if i = 0 then 1\n      else if i = 1 then map_poly to_fract G1\n           else if i = 2 then map_poly to_fract G2\n                else let G = pseudo_mod (F (i - 2)) (F (i - 1))\n                     in if F (i - 1) = 0 \\<or> G = 0 then 0\n                        else Polynomial.smult\n                              (inverse\n                                (if i \\<le> 2 then 1\n                                 else if i = 3\nthen (- 1) ^ (degree (F 1) - degree (F 2) + 1)\nelse if F (i - 2) = 0 then 1\n     else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n          lead_coeff (F (i - 2)) *\n          h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))))\n                              G) =\n     0 \\<longrightarrow>\n     F (Suc i) = 0) \\<and>\n    (if i \\<le> 2 then 1\n     else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (i - 2) = 0 then 1\n               else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                    lead_coeff (F (i - 2)) *\n                    h (i - 2) ^\n                    (degree (F (i - 2)) - degree (F (i - 1)))) \\<noteq>\n    0 \\<and>\n    (if i \\<le> 1 then 1\n     else if i = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n          else if (if i = 0 then 1\n                   else if i = 1 then map_poly to_fract G1\n                        else if i = 2 then map_poly to_fract G2\n                             else let G = pseudo_mod (F (i - 2)) (F (i - 1))\n                                  in if F (i - 1) = 0 \\<or> G = 0 then 0\n                                     else Polynomial.smult\n     (inverse\n       (if i \\<le> 2 then 1\n        else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n             else if F (i - 2) = 0 then 1\n                  else (- 1) ^\n                       (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                       lead_coeff (F (i - 2)) *\n                       h (i - 2) ^\n                       (degree (F (i - 2)) - degree (F (i - 1)))))\n     G) =\n                  0\n               then 1\n               else lead_coeff\n                     (if i = 0 then 1\n                      else if i = 1 then map_poly to_fract G1\n                           else if i = 2 then map_poly to_fract G2\n                                else let G =\n     pseudo_mod (F (i - 2)) (F (i - 1))\n                                     in if F (i - 1) = 0 \\<or> G = 0 then 0\n  else Polynomial.smult\n        (inverse\n          (if i \\<le> 2 then 1\n           else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                else if F (i - 2) = 0 then 1\n                     else (- 1) ^\n                          (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                          lead_coeff (F (i - 2)) *\n                          h (i - 2) ^\n                          (degree (F (i - 2)) - degree (F (i - 1)))))\n        G) ^\n                    (degree (F (i - 1)) -\n                     degree\n                      (if i = 0 then 1\n                       else if i = 1 then map_poly to_fract G1\n                            else if i = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (i - 2)) (F (i - 1))\nin if F (i - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if i \\<le> 2 then 1\n            else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (i - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                           lead_coeff (F (i - 2)) *\n                           h (i - 2) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)))))\n         G)) /\n                    h (i - 1) ^\n                    (degree (F (i - 1)) -\n                     degree\n                      (if i = 0 then 1\n                       else if i = 1 then map_poly to_fract G1\n                            else if i = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (i - 2)) (F (i - 1))\nin if F (i - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if i \\<le> 2 then 1\n            else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (i - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                           lead_coeff (F (i - 2)) *\n                           h (i - 2) ^\n                           (degree (F (i - 2)) - degree (F (i - 1)))))\n         G) -\n                     1)) \\<noteq>\n    0", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if 1 = 0 then 1\n      else if 1 = 1 then map_poly to_fract G1\n           else if 1 = 2 then map_poly to_fract G2\n                else let G = pseudo_mod (F (1 - 2)) (F (1 - 1))\n                     in if F (1 - 1) = 0 \\<or> G = 0 then 0\n                        else Polynomial.smult\n                              (inverse\n                                (if 1 \\<le> 2 then 1\n                                 else if 1 = 3\nthen (- 1) ^ (degree (F 1) - degree (F 2) + 1)\nelse if F (1 - 2) = 0 then 1\n     else (- 1) ^ (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n          lead_coeff (F (1 - 2)) *\n          h (1 - 2) ^ (degree (F (1 - 2)) - degree (F (1 - 1)))))\n                              G) =\n     0 \\<longrightarrow>\n     F (Suc 1) = 0) \\<and>\n    (if 1 \\<le> 2 then 1\n     else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (1 - 2) = 0 then 1\n               else (- 1) ^ (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                    lead_coeff (F (1 - 2)) *\n                    h (1 - 2) ^\n                    (degree (F (1 - 2)) - degree (F (1 - 1)))) \\<noteq>\n    0 \\<and>\n    (if 1 \\<le> 1 then 1\n     else if 1 = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n          else if (if 1 = 0 then 1\n                   else if 1 = 1 then map_poly to_fract G1\n                        else if 1 = 2 then map_poly to_fract G2\n                             else let G = pseudo_mod (F (1 - 2)) (F (1 - 1))\n                                  in if F (1 - 1) = 0 \\<or> G = 0 then 0\n                                     else Polynomial.smult\n     (inverse\n       (if 1 \\<le> 2 then 1\n        else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n             else if F (1 - 2) = 0 then 1\n                  else (- 1) ^\n                       (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                       lead_coeff (F (1 - 2)) *\n                       h (1 - 2) ^\n                       (degree (F (1 - 2)) - degree (F (1 - 1)))))\n     G) =\n                  0\n               then 1\n               else lead_coeff\n                     (if 1 = 0 then 1\n                      else if 1 = 1 then map_poly to_fract G1\n                           else if 1 = 2 then map_poly to_fract G2\n                                else let G =\n     pseudo_mod (F (1 - 2)) (F (1 - 1))\n                                     in if F (1 - 1) = 0 \\<or> G = 0 then 0\n  else Polynomial.smult\n        (inverse\n          (if 1 \\<le> 2 then 1\n           else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                else if F (1 - 2) = 0 then 1\n                     else (- 1) ^\n                          (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                          lead_coeff (F (1 - 2)) *\n                          h (1 - 2) ^\n                          (degree (F (1 - 2)) - degree (F (1 - 1)))))\n        G) ^\n                    (degree (F (1 - 1)) -\n                     degree\n                      (if 1 = 0 then 1\n                       else if 1 = 1 then map_poly to_fract G1\n                            else if 1 = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (1 - 2)) (F (1 - 1))\nin if F (1 - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if 1 \\<le> 2 then 1\n            else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (1 - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                           lead_coeff (F (1 - 2)) *\n                           h (1 - 2) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)))))\n         G)) /\n                    h (1 - 1) ^\n                    (degree (F (1 - 1)) -\n                     degree\n                      (if 1 = 0 then 1\n                       else if 1 = 1 then map_poly to_fract G1\n                            else if 1 = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (1 - 2)) (F (1 - 1))\nin if F (1 - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if 1 \\<le> 2 then 1\n            else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (1 - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                           lead_coeff (F (1 - 2)) *\n                           h (1 - 2) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)))))\n         G) -\n                     1)) \\<noteq>\n    0", "using assms"], ["proof (prove)\nusing this:\n  G1 \\<noteq> 0\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((if 1 = 0 then 1\n      else if 1 = 1 then map_poly to_fract G1\n           else if 1 = 2 then map_poly to_fract G2\n                else let G = pseudo_mod (F (1 - 2)) (F (1 - 1))\n                     in if F (1 - 1) = 0 \\<or> G = 0 then 0\n                        else Polynomial.smult\n                              (inverse\n                                (if 1 \\<le> 2 then 1\n                                 else if 1 = 3\nthen (- 1) ^ (degree (F 1) - degree (F 2) + 1)\nelse if F (1 - 2) = 0 then 1\n     else (- 1) ^ (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n          lead_coeff (F (1 - 2)) *\n          h (1 - 2) ^ (degree (F (1 - 2)) - degree (F (1 - 1)))))\n                              G) =\n     0 \\<longrightarrow>\n     F (Suc 1) = 0) \\<and>\n    (if 1 \\<le> 2 then 1\n     else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (1 - 2) = 0 then 1\n               else (- 1) ^ (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                    lead_coeff (F (1 - 2)) *\n                    h (1 - 2) ^\n                    (degree (F (1 - 2)) - degree (F (1 - 1)))) \\<noteq>\n    0 \\<and>\n    (if 1 \\<le> 1 then 1\n     else if 1 = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n          else if (if 1 = 0 then 1\n                   else if 1 = 1 then map_poly to_fract G1\n                        else if 1 = 2 then map_poly to_fract G2\n                             else let G = pseudo_mod (F (1 - 2)) (F (1 - 1))\n                                  in if F (1 - 1) = 0 \\<or> G = 0 then 0\n                                     else Polynomial.smult\n     (inverse\n       (if 1 \\<le> 2 then 1\n        else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n             else if F (1 - 2) = 0 then 1\n                  else (- 1) ^\n                       (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                       lead_coeff (F (1 - 2)) *\n                       h (1 - 2) ^\n                       (degree (F (1 - 2)) - degree (F (1 - 1)))))\n     G) =\n                  0\n               then 1\n               else lead_coeff\n                     (if 1 = 0 then 1\n                      else if 1 = 1 then map_poly to_fract G1\n                           else if 1 = 2 then map_poly to_fract G2\n                                else let G =\n     pseudo_mod (F (1 - 2)) (F (1 - 1))\n                                     in if F (1 - 1) = 0 \\<or> G = 0 then 0\n  else Polynomial.smult\n        (inverse\n          (if 1 \\<le> 2 then 1\n           else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                else if F (1 - 2) = 0 then 1\n                     else (- 1) ^\n                          (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                          lead_coeff (F (1 - 2)) *\n                          h (1 - 2) ^\n                          (degree (F (1 - 2)) - degree (F (1 - 1)))))\n        G) ^\n                    (degree (F (1 - 1)) -\n                     degree\n                      (if 1 = 0 then 1\n                       else if 1 = 1 then map_poly to_fract G1\n                            else if 1 = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (1 - 2)) (F (1 - 1))\nin if F (1 - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if 1 \\<le> 2 then 1\n            else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (1 - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                           lead_coeff (F (1 - 2)) *\n                           h (1 - 2) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)))))\n         G)) /\n                    h (1 - 1) ^\n                    (degree (F (1 - 1)) -\n                     degree\n                      (if 1 = 0 then 1\n                       else if 1 = 1 then map_poly to_fract G1\n                            else if 1 = 2 then map_poly to_fract G2\n                                 else let G =\n      pseudo_mod (F (1 - 2)) (F (1 - 1))\nin if F (1 - 1) = 0 \\<or> G = 0 then 0\n   else Polynomial.smult\n         (inverse\n           (if 1 \\<le> 2 then 1\n            else if 1 = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n                 else if F (1 - 2) = 0 then 1\n                      else (- 1) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)) + 1) *\n                           lead_coeff (F (1 - 2)) *\n                           h (1 - 2) ^\n                           (degree (F (1 - 2)) - degree (F (1 - 1)))))\n         G) -\n                     1)) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n  b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "case 2"], ["proof (state)\nthis:\n  2 \\<le> i\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "have F: \"F i = 0 \\<Longrightarrow> F (Suc i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F i = 0 \\<Longrightarrow> F (Suc i) = 0", "unfolding F.simps[of \"Suc i\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. F i = 0 \\<Longrightarrow>\n    (if Suc i = 0 then 1\n     else if Suc i = 1 then map_poly to_fract G1\n          else if Suc i = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))\n                    in if F (Suc i - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b (Suc i))) G) =\n    0", "using 2"], ["proof (prove)\nusing this:\n  2 \\<le> i\n\ngoal (1 subgoal):\n 1. F i = 0 \\<Longrightarrow>\n    (if Suc i = 0 then 1\n     else if Suc i = 1 then map_poly to_fract G1\n          else if Suc i = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))\n                    in if F (Suc i - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b (Suc i))) G) =\n    0", "by simp"], ["proof (state)\nthis:\n  F i = 0 \\<Longrightarrow> F (Suc i) = 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  G1 \\<noteq> 0\n  G2 \\<noteq> 0", "have F2: \"F 2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  G1 \\<noteq> 0\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F 2 \\<noteq> 0", "unfolding F.simps[of 2]"], ["proof (prove)\nusing this:\n  G1 \\<noteq> 0\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if 2 = 0 then 1\n     else if 2 = 1 then map_poly to_fract G1\n          else if 2 = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (2 - 2)) (F (2 - 1))\n                    in if F (2 - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b 2)) G) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "from 2"], ["proof (chain)\npicking this:\n  2 \\<le> i", "have \"i - 1 < i\" \"i - 2 < i\""], ["proof (prove)\nusing this:\n  2 \\<le> i\n\ngoal (1 subgoal):\n 1. i - 1 < i &&& i - 2 < i", "by auto"], ["proof (state)\nthis:\n  i - 1 < i\n  i - 2 < i\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "note IH = less[OF this(1)] less[OF this(2)]"], ["proof (state)\nthis:\n  (F (i - 1) = 0 \\<longrightarrow> F (Suc (i - 1)) = 0) \\<and>\n  b (i - 1) \\<noteq> 0 \\<and> h (i - 1) \\<noteq> 0\n  (F (i - 2) = 0 \\<longrightarrow> F (Suc (i - 2)) = 0) \\<and>\n  b (i - 2) \\<noteq> 0 \\<and> h (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "hence b: \"b (i - 1) \\<noteq> 0\" and h: \"h (i - 1) \\<noteq> 0\" \"h (i - 2) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (F (i - 1) = 0 \\<longrightarrow> F (Suc (i - 1)) = 0) \\<and>\n  b (i - 1) \\<noteq> 0 \\<and> h (i - 1) \\<noteq> 0\n  (F (i - 2) = 0 \\<longrightarrow> F (Suc (i - 2)) = 0) \\<and>\n  b (i - 2) \\<noteq> 0 \\<and> h (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b (i - 1) \\<noteq> 0 &&& h (i - 1) \\<noteq> 0 &&& h (i - 2) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  b (i - 1) \\<noteq> 0\n  h (i - 1) \\<noteq> 0\n  h (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "from h"], ["proof (chain)\npicking this:\n  h (i - 1) \\<noteq> 0\n  h (i - 2) \\<noteq> 0", "have hi: \"h i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h (i - 1) \\<noteq> 0\n  h (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h i \\<noteq> 0", "unfolding h.simps[of i]"], ["proof (prove)\nusing this:\n  h (i - 1) \\<noteq> 0\n  h (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i \\<le> 1 then 1\n     else if i = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n          else if F i = 0 then 1\n               else lead_coeff (F i) ^ (degree (F (i - 1)) - degree (F i)) /\n                    h (i - 1) ^\n                    (degree (F (i - 1)) - degree (F i) - 1)) \\<noteq>\n    0", "using 2 F2"], ["proof (prove)\nusing this:\n  h (i - 1) \\<noteq> 0\n  h (i - 2) \\<noteq> 0\n  2 \\<le> i\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i \\<le> 1 then 1\n     else if i = 2 then lead_coeff (F 2) ^ (degree (F 1) - degree (F 2))\n          else if F i = 0 then 1\n               else lead_coeff (F i) ^ (degree (F (i - 1)) - degree (F i)) /\n                    h (i - 1) ^\n                    (degree (F (i - 1)) - degree (F i) - 1)) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "have bi: \"b i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b i \\<noteq> 0", "unfolding b.simps[of i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i \\<le> 2 then 1\n     else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (i - 2) = 0 then 1\n               else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                    lead_coeff (F (i - 2)) *\n                    h (i - 2) ^\n                    (degree (F (i - 2)) - degree (F (i - 1)))) \\<noteq>\n    0", "using h(2)"], ["proof (prove)\nusing this:\n  h (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i \\<le> 2 then 1\n     else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (i - 2) = 0 then 1\n               else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                    lead_coeff (F (i - 2)) *\n                    h (i - 2) ^\n                    (degree (F (i - 2)) - degree (F (i - 1)))) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  b i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "using hi bi F"], ["proof (prove)\nusing this:\n  h i \\<noteq> 0\n  b i \\<noteq> 0\n  F i = 0 \\<Longrightarrow> F (Suc i) = 0\n\ngoal (1 subgoal):\n 1. (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n    b i \\<noteq> 0 \\<and> h i \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n  b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (F i = 0 \\<longrightarrow> F (Suc i) = 0) \\<and>\n  b i \\<noteq> 0 \\<and> h i \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition \"k = (LEAST i. F (Suc i) = 0)\""], ["", "private"], ["", "lemma k_exists: \"\\<exists> i. F (Suc i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. F (Suc i) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. F (Suc i) = 0", "obtain n i where \"i \\<ge> 3\" \"length (coeffs (F (Suc i))) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i n.\n        \\<lbrakk>3 \\<le> i; length (coeffs (F (Suc i))) = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  3 \\<le> i\n  length (coeffs (F (Suc i))) = n\n\ngoal (1 subgoal):\n 1. \\<exists>i. F (Suc i) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  length (coeffs (F (Suc i))) = n\n\ngoal (1 subgoal):\n 1. \\<exists>i. F (Suc i) = 0", "proof (induct n arbitrary: i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>y i.\n                   \\<lbrakk>y < x; 3 \\<le> i;\n                    length (coeffs (F (Suc i))) = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i. F (Suc i) = 0;\n        3 \\<le> i; length (coeffs (F (Suc i))) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "case (less n i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; 3 \\<le> ?i; length (coeffs (F (Suc ?i))) = ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i. F (Suc i) = 0\n  3 \\<le> i\n  length (coeffs (F (Suc i))) = n\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>y i.\n                   \\<lbrakk>y < x; 3 \\<le> i;\n                    length (coeffs (F (Suc i))) = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i. F (Suc i) = 0;\n        3 \\<le> i; length (coeffs (F (Suc i))) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "let ?ii = \"Suc (Suc i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>y i.\n                   \\<lbrakk>y < x; 3 \\<le> i;\n                    length (coeffs (F (Suc i))) = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i. F (Suc i) = 0;\n        3 \\<le> i; length (coeffs (F (Suc i))) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "let ?i = \"Suc i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>y i.\n                   \\<lbrakk>y < x; 3 \\<le> i;\n                    length (coeffs (F (Suc i))) = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i. F (Suc i) = 0;\n        3 \\<le> i; length (coeffs (F (Suc i))) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "from less(2)"], ["proof (chain)\npicking this:\n  3 \\<le> i", "have i: \"?i \\<ge> 3\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. 3 \\<le> Suc i", "by auto"], ["proof (state)\nthis:\n  3 \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>y i.\n                   \\<lbrakk>y < x; 3 \\<le> i;\n                    length (coeffs (F (Suc i))) = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i. F (Suc i) = 0;\n        3 \\<le> i; length (coeffs (F (Suc i))) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "let ?mod = \"pseudo_mod (F (?ii - 2)) (F ?i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>y i.\n                   \\<lbrakk>y < x; 3 \\<le> i;\n                    length (coeffs (F (Suc i))) = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i. F (Suc i) = 0;\n        3 \\<le> i; length (coeffs (F (Suc i))) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "have Fi: \"F ?ii = (if F ?i = 0 \\<or> ?mod = 0 then 0 else smult (inverse (b ?ii)) ?mod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (Suc (Suc i)) =\n    (if F (Suc i) = 0 \\<or> pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0\n     then 0\n     else Polynomial.smult (inverse (b (Suc (Suc i))))\n           (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))))", "unfolding F.simps[of ?ii]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc (Suc i) = 0 then 1\n     else if Suc (Suc i) = 1 then map_poly to_fract G1\n          else if Suc (Suc i) = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (Suc (Suc i) - 2))\n                             (F (Suc (Suc i) - 1))\n                    in if F (Suc (Suc i) - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b (Suc (Suc i))))\n                             G) =\n    (if F (Suc i) = 0 \\<or> pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0\n     then 0\n     else Polynomial.smult (inverse (b (Suc (Suc i))))\n           (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))))", "using i"], ["proof (prove)\nusing this:\n  3 \\<le> Suc i\n\ngoal (1 subgoal):\n 1. (if Suc (Suc i) = 0 then 1\n     else if Suc (Suc i) = 1 then map_poly to_fract G1\n          else if Suc (Suc i) = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (Suc (Suc i) - 2))\n                             (F (Suc (Suc i) - 1))\n                    in if F (Suc (Suc i) - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b (Suc (Suc i))))\n                             G) =\n    (if F (Suc i) = 0 \\<or> pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0\n     then 0\n     else Polynomial.smult (inverse (b (Suc (Suc i))))\n           (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))))", "by auto"], ["proof (state)\nthis:\n  F (Suc (Suc i)) =\n  (if F (Suc i) = 0 \\<or> pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0\n   then 0\n   else Polynomial.smult (inverse (b (Suc (Suc i))))\n         (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))))\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>y i.\n                   \\<lbrakk>y < x; 3 \\<le> i;\n                    length (coeffs (F (Suc i))) = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i. F (Suc i) = 0;\n        3 \\<le> i; length (coeffs (F (Suc i))) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. F (Suc i) = 0", "proof (cases \"F ?ii = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. F (Suc (Suc i)) = 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0\n 2. F (Suc (Suc i)) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "case False"], ["proof (state)\nthis:\n  F (Suc (Suc i)) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. F (Suc (Suc i)) = 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0\n 2. F (Suc (Suc i)) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "hence Fi: \"F ?ii = smult (inverse (b ?ii)) ?mod\" and mod: \"?mod \\<noteq> 0\" and Fi1: \"F ?i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  F (Suc (Suc i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F (Suc (Suc i)) =\n    Polynomial.smult (inverse (b (Suc (Suc i))))\n     (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))) &&&\n    pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) \\<noteq> 0 &&&\n    F (Suc i) \\<noteq> 0", "unfolding Fi"], ["proof (prove)\nusing this:\n  (if F (Suc i) = 0 \\<or> pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0\n   then 0\n   else Polynomial.smult (inverse (b (Suc (Suc i))))\n         (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (if F (Suc i) = 0 \\<or> pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0\n     then 0\n     else Polynomial.smult (inverse (b (Suc (Suc i))))\n           (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)))) =\n    Polynomial.smult (inverse (b (Suc (Suc i))))\n     (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))) &&&\n    pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) \\<noteq> 0 &&&\n    F (Suc i) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F (Suc (Suc i)) =\n  Polynomial.smult (inverse (b (Suc (Suc i))))\n   (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)))\n  pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) \\<noteq> 0\n  F (Suc i) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. F (Suc (Suc i)) = 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0\n 2. F (Suc (Suc i)) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "from pseudo_mod[OF Fi1, of \"F (?ii - 2)\"] mod"], ["proof (chain)\npicking this:\n  \\<exists>a q.\n     a \\<noteq> 0 \\<and>\n     Polynomial.smult a (F (Suc (Suc i) - 2)) =\n     F (Suc i) * q + pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))\n  pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0 \\<or>\n  degree (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))) < degree (F (Suc i))\n  pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) \\<noteq> 0", "have \"degree ?mod < degree (F ?i)\""], ["proof (prove)\nusing this:\n  \\<exists>a q.\n     a \\<noteq> 0 \\<and>\n     Polynomial.smult a (F (Suc (Suc i) - 2)) =\n     F (Suc i) * q + pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))\n  pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) = 0 \\<or>\n  degree (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))) < degree (F (Suc i))\n  pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i)))\n    < degree (F (Suc i))", "by simp"], ["proof (state)\nthis:\n  degree (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))) < degree (F (Suc i))\n\ngoal (2 subgoals):\n 1. F (Suc (Suc i)) = 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0\n 2. F (Suc (Suc i)) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "hence deg: \"degree (F ?ii) < degree (F ?i)\""], ["proof (prove)\nusing this:\n  degree (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))) < degree (F (Suc i))\n\ngoal (1 subgoal):\n 1. degree (F (Suc (Suc i))) < degree (F (Suc i))", "unfolding Fi"], ["proof (prove)\nusing this:\n  degree (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))) < degree (F (Suc i))\n\ngoal (1 subgoal):\n 1. degree\n     (Polynomial.smult (inverse (b (Suc (Suc i))))\n       (pseudo_mod (F (Suc (Suc i) - 2)) (F (Suc i))))\n    < degree (F (Suc i))", "by auto"], ["proof (state)\nthis:\n  degree (F (Suc (Suc i))) < degree (F (Suc i))\n\ngoal (2 subgoals):\n 1. F (Suc (Suc i)) = 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0\n 2. F (Suc (Suc i)) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "hence \"length (coeffs (F ?ii)) < length (coeffs (F ?i))\""], ["proof (prove)\nusing this:\n  degree (F (Suc (Suc i))) < degree (F (Suc i))\n\ngoal (1 subgoal):\n 1. length (coeffs (F (Suc (Suc i)))) < length (coeffs (F (Suc i)))", "unfolding degree_eq_length_coeffs"], ["proof (prove)\nusing this:\n  length (coeffs (F (Suc (Suc i)))) - 1 < length (coeffs (F (Suc i))) - 1\n\ngoal (1 subgoal):\n 1. length (coeffs (F (Suc (Suc i)))) < length (coeffs (F (Suc i)))", "by auto"], ["proof (state)\nthis:\n  length (coeffs (F (Suc (Suc i)))) < length (coeffs (F (Suc i)))\n\ngoal (2 subgoals):\n 1. F (Suc (Suc i)) = 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0\n 2. F (Suc (Suc i)) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "from less(1)[OF _ i refl, folded less(3), OF this]"], ["proof (chain)\npicking this:\n  \\<exists>i. F (Suc i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>i. F (Suc i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>i. F (Suc i) = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. F (Suc i) = 0\n\ngoal (1 subgoal):\n 1. F (Suc (Suc i)) = 0 \\<Longrightarrow> \\<exists>i. F (Suc i) = 0", "qed blast"], ["proof (state)\nthis:\n  \\<exists>i. F (Suc i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. F (Suc i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma k: \"F (Suc k) = 0\" \"i < k \\<Longrightarrow> F (Suc i) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (Suc k) = 0 &&& (i < k \\<Longrightarrow> F (Suc i) \\<noteq> 0)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. F (Suc k) = 0\n 2. i < k \\<Longrightarrow> F (Suc i) \\<noteq> 0", "show \"F (Suc k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (Suc k) = 0", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. F (Suc (LEAST i. F (Suc i) = 0)) = 0", "using k_exists"], ["proof (prove)\nusing this:\n  \\<exists>i. F (Suc i) = 0\n\ngoal (1 subgoal):\n 1. F (Suc (LEAST i. F (Suc i) = 0)) = 0", "by (rule LeastI2_ex)"], ["proof (state)\nthis:\n  F (Suc k) = 0\n\ngoal (1 subgoal):\n 1. i < k \\<Longrightarrow> F (Suc i) \\<noteq> 0", "assume \"i < k\""], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. i < k \\<Longrightarrow> F (Suc i) \\<noteq> 0", "from not_less_Least[OF this[unfolded k_def]]"], ["proof (chain)\npicking this:\n  F (Suc i) \\<noteq> 0", "show \"F (Suc i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  F (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F (Suc i) \\<noteq> 0", "."], ["proof (state)\nthis:\n  F (Suc i) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enter_subresultant_prs: assumes len: \"length (coeffs G1) \\<ge> length (coeffs G2)\"\n  and G2: \"G2 \\<noteq> 0\"\nshows \"\\<exists> F n d f k b. subresultant_prs_locale2 F n d f k b G1 G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F n d f k b. subresultant_prs_locale2 F n d f k b G1 G2", "proof (intro exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 ?F ?n1 ?d2 ?f3 ?k4 ?b5 G1 G2", "from G2 len"], ["proof (chain)\npicking this:\n  G2 \\<noteq> 0\n  length (coeffs G2) \\<le> length (coeffs G1)", "have G1: \"G1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  G2 \\<noteq> 0\n  length (coeffs G2) \\<le> length (coeffs G1)\n\ngoal (1 subgoal):\n 1. G1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  G1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 ?F ?n1 ?d2 ?f3 ?k4 ?b5 G1 G2", "from len"], ["proof (chain)\npicking this:\n  length (coeffs G2) \\<le> length (coeffs G1)", "have deg_le: \"degree (F 2) \\<le> degree (F 1)\""], ["proof (prove)\nusing this:\n  length (coeffs G2) \\<le> length (coeffs G1)\n\ngoal (1 subgoal):\n 1. degree (F 2) \\<le> degree (F 1)", "by (simp add: F.simps degree_eq_length_coeffs)"], ["proof (state)\nthis:\n  degree (F 2) \\<le> degree (F 1)\n\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 ?F ?n1 ?d2 ?f3 ?k4 ?b5 G1 G2", "from G2 G1"], ["proof (chain)\npicking this:\n  G2 \\<noteq> 0\n  G1 \\<noteq> 0", "have F1: \"F 1 \\<noteq> 0\" and F2: \"F 2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  G2 \\<noteq> 0\n  G1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F 1 \\<noteq> 0 &&& F 2 \\<noteq> 0", "by (auto simp: F.simps)"], ["proof (state)\nthis:\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 ?F ?n1 ?d2 ?f3 ?k4 ?b5 G1 G2", "note Fb0 = Fb0[OF G1 G2]"], ["proof (state)\nthis:\n  (F ?i = 0 \\<longrightarrow> F (Suc ?i) = 0) \\<and>\n  b ?i \\<noteq> 0 \\<and> h ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 ?F ?n1 ?d2 ?f3 ?k4 ?b5 G1 G2", "interpret s: subresultant_prs_locale F \"\\<lambda> i. degree (F i)\" \"\\<lambda> i. degree (F i) - degree (F (Suc i))\"\n    \"\\<lambda> i. lead_coeff (F i)\" k b G1 G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_locale F (\\<lambda>i. degree (F i))\n     (\\<lambda>i. degree (F i) - degree (F (Suc i)))\n     (\\<lambda>i. lead_coeff (F i)) k b G1 G2", "proof (unfold_locales, rule refl, rule refl, rule refl, rule deg_le, rule F1, rule F2)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n 2. \\<And>i. b i \\<noteq> 0\n 3. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))\n 4. F 1 = map_poly to_fract G1\n 5. F 2 = map_poly to_fract G2", "from k(1) F1"], ["proof (chain)\npicking this:\n  F (Suc k) = 0\n  F 1 \\<noteq> 0", "have k0: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  F (Suc k) = 0\n  F 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by (cases k, auto)"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (5 subgoals):\n 1. \\<And>i. i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n 2. \\<And>i. b i \\<noteq> 0\n 3. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))\n 4. F 1 = map_poly to_fract G1\n 5. F 2 = map_poly to_fract G2", "show Fk: \"(F i = 0) = (k < i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (F i = 0) = (k < i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. F i = 0 \\<Longrightarrow> k < i\n 2. k < i \\<Longrightarrow> F i = 0", "assume \"F i = 0\""], ["proof (state)\nthis:\n  F i = 0\n\ngoal (2 subgoals):\n 1. F i = 0 \\<Longrightarrow> k < i\n 2. k < i \\<Longrightarrow> F i = 0", "with k(2)[of \"i - 1\"]"], ["proof (chain)\npicking this:\n  i - 1 < k \\<Longrightarrow> F (Suc (i - 1)) \\<noteq> 0\n  F i = 0", "have \"\\<not> (i - 1 < k)\""], ["proof (prove)\nusing this:\n  i - 1 < k \\<Longrightarrow> F (Suc (i - 1)) \\<noteq> 0\n  F i = 0\n\ngoal (1 subgoal):\n 1. \\<not> i - 1 < k", "by (cases i, auto simp: F.simps)"], ["proof (state)\nthis:\n  \\<not> i - 1 < k\n\ngoal (2 subgoals):\n 1. F i = 0 \\<Longrightarrow> k < i\n 2. k < i \\<Longrightarrow> F i = 0", "thus \"i > k\""], ["proof (prove)\nusing this:\n  \\<not> i - 1 < k\n\ngoal (1 subgoal):\n 1. k < i", "using k0"], ["proof (prove)\nusing this:\n  \\<not> i - 1 < k\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k < i", "by auto"], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i = 0", "assume \"i > k\""], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i = 0", "then"], ["proof (chain)\npicking this:\n  k < i", "obtain j l where i: \"i = j + l\" and \"j = Suc k\" and \"l = i - Suc k\" and Fj: \"F j = 0\""], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. (\\<And>j l.\n        \\<lbrakk>i = j + l; j = Suc k; l = i - Suc k; F j = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using k(1)"], ["proof (prove)\nusing this:\n  k < i\n  F (Suc k) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>j l.\n        \\<lbrakk>i = j + l; j = Suc k; l = i - Suc k; F j = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i = j + l\n  j = Suc k\n  l = i - Suc k\n  F j = 0\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i = 0", "with F1 F2 k0"], ["proof (chain)\npicking this:\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n  k \\<noteq> 0\n  i = j + l\n  j = Suc k\n  l = i - Suc k\n  F j = 0", "have j2: \"j \\<ge> 2\""], ["proof (prove)\nusing this:\n  F 1 \\<noteq> 0\n  F 2 \\<noteq> 0\n  k \\<noteq> 0\n  i = j + l\n  j = Suc k\n  l = i - Suc k\n  F j = 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> j", "by auto"], ["proof (state)\nthis:\n  2 \\<le> j\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow> F i = 0", "show \"F i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F i = 0", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. F (j + l) = 0", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. F (j + 0) = 0\n 2. \\<And>l. F (j + l) = 0 \\<Longrightarrow> F (j + Suc l) = 0", "case (Suc l)"], ["proof (state)\nthis:\n  F (j + l) = 0\n\ngoal (2 subgoals):\n 1. F (j + 0) = 0\n 2. \\<And>l. F (j + l) = 0 \\<Longrightarrow> F (j + Suc l) = 0", "thus ?case"], ["proof (prove)\nusing this:\n  F (j + l) = 0\n\ngoal (1 subgoal):\n 1. F (j + Suc l) = 0", "unfolding F.simps[of \"j + Suc l\"]"], ["proof (prove)\nusing this:\n  F (j + l) = 0\n\ngoal (1 subgoal):\n 1. (if j + Suc l = 0 then 1\n     else if j + Suc l = 1 then map_poly to_fract G1\n          else if j + Suc l = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (j + Suc l - 2))\n                             (F (j + Suc l - 1))\n                    in if F (j + Suc l - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b (j + Suc l))) G) =\n    0", "using j2"], ["proof (prove)\nusing this:\n  F (j + l) = 0\n  2 \\<le> j\n\ngoal (1 subgoal):\n 1. (if j + Suc l = 0 then 1\n     else if j + Suc l = 1 then map_poly to_fract G1\n          else if j + Suc l = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (j + Suc l - 2))\n                             (F (j + Suc l - 1))\n                    in if F (j + Suc l - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b (j + Suc l))) G) =\n    0", "by auto"], ["proof (state)\nthis:\n  F (j + Suc l) = 0\n\ngoal (1 subgoal):\n 1. F (j + 0) = 0", "qed (auto simp: Fj)"], ["proof (state)\nthis:\n  F i = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (F ?i = 0) = (k < ?i)\n\ngoal (4 subgoals):\n 1. \\<And>i. b i \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))\n 3. F 1 = map_poly to_fract G1\n 4. F 2 = map_poly to_fract G2", "show b: \"b i \\<noteq> 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. b i \\<noteq> 0", "using Fb0"], ["proof (prove)\nusing this:\n  (F ?i = 0 \\<longrightarrow> F (Suc ?i) = 0) \\<and>\n  b ?i \\<noteq> 0 \\<and> h ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b i \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  b ?i \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))\n 2. F 1 = map_poly to_fract G1\n 3. F 2 = map_poly to_fract G2", "show \"F 1 = map_poly to_fract G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F 1 = map_poly to_fract G1", "unfolding F.simps[of 1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 1 = 0 then 1\n     else if 1 = 1 then map_poly to_fract G1\n          else if 1 = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (1 - 2)) (F (1 - 1))\n                    in if F (1 - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b 1)) G) =\n    map_poly to_fract G1", "by simp"], ["proof (state)\nthis:\n  F 1 = map_poly to_fract G1\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))\n 2. F 2 = map_poly to_fract G2", "show \"F 2 = map_poly to_fract G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F 2 = map_poly to_fract G2", "unfolding F.simps[of 2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 2 = 0 then 1\n     else if 2 = 1 then map_poly to_fract G1\n          else if 2 = 2 then map_poly to_fract G2\n               else let G = pseudo_mod (F (2 - 2)) (F (2 - 1))\n                    in if F (2 - 1) = 0 \\<or> G = 0 then 0\n                       else Polynomial.smult (inverse (b 2)) G) =\n    map_poly to_fract G2", "by simp"], ["proof (state)\nthis:\n  F 2 = map_poly to_fract G2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))", "let ?mod = \"pseudo_mod (F (i - 2)) (F (i - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))", "assume i: \"3 \\<le> i\" \"i \\<le> Suc k\""], ["proof (state)\nthis:\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))", "from Fk[of \"i - 1\"] i"], ["proof (chain)\npicking this:\n  (F (i - 1) = 0) = (k < i - 1)\n  3 \\<le> i\n  i \\<le> Suc k", "have \"F (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (F (i - 1) = 0) = (k < i - 1)\n  3 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. F (i - 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))", "with i"], ["proof (chain)\npicking this:\n  3 \\<le> i\n  i \\<le> Suc k\n  F (i - 1) \\<noteq> 0", "have Fi: \"F i = (if ?mod = 0 then 0 else smult (inverse (b i)) ?mod)\""], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> Suc k\n  F (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F i =\n    (if pseudo_mod (F (i - 2)) (F (i - 1)) = 0 then 0\n     else Polynomial.smult (inverse (b i))\n           (pseudo_mod (F (i - 2)) (F (i - 1))))", "unfolding F.simps[of i]\n      Let_def"], ["proof (prove)\nusing this:\n  3 \\<le> i\n  i \\<le> Suc k\n  F (i - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i = 0 then 1\n     else if i = 1 then map_poly to_fract G1\n          else if i = 2 then map_poly to_fract G2\n               else if F (i - 1) = 0 \\<or>\n                       pseudo_mod (F (i - 2)) (F (i - 1)) = 0\n                    then 0\n                    else Polynomial.smult (inverse (b i))\n                          (pseudo_mod (F (i - 2)) (F (i - 1)))) =\n    (if pseudo_mod (F (i - 2)) (F (i - 1)) = 0 then 0\n     else Polynomial.smult (inverse (b i))\n           (pseudo_mod (F (i - 2)) (F (i - 1))))", "by simp"], ["proof (state)\nthis:\n  F i =\n  (if pseudo_mod (F (i - 2)) (F (i - 1)) = 0 then 0\n   else Polynomial.smult (inverse (b i))\n         (pseudo_mod (F (i - 2)) (F (i - 1))))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> Polynomial.smult (b i) (F i) =\n                         pseudo_mod (F (i - 2)) (F (i - 1))", "show \"smult (b i) (F i) = ?mod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "proof (cases \"?mod = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pseudo_mod (F (i - 2)) (F (i - 1)) = 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))\n 2. pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "case True"], ["proof (state)\nthis:\n  pseudo_mod (F (i - 2)) (F (i - 1)) = 0\n\ngoal (2 subgoals):\n 1. pseudo_mod (F (i - 2)) (F (i - 1)) = 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))\n 2. pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  pseudo_mod (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "unfolding Fi"], ["proof (prove)\nusing this:\n  pseudo_mod (F (i - 2)) (F (i - 1)) = 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (b i)\n     (if pseudo_mod (F (i - 2)) (F (i - 1)) = 0 then 0\n      else Polynomial.smult (inverse (b i))\n            (pseudo_mod (F (i - 2)) (F (i - 1)))) =\n    pseudo_mod (F (i - 2)) (F (i - 1))", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))\n\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "case False"], ["proof (state)\nthis:\n  pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "with Fi"], ["proof (chain)\npicking this:\n  F i =\n  (if pseudo_mod (F (i - 2)) (F (i - 1)) = 0 then 0\n   else Polynomial.smult (inverse (b i))\n         (pseudo_mod (F (i - 2)) (F (i - 1))))\n  pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0", "have Fi: \"F i = smult (inverse (b i)) ?mod\""], ["proof (prove)\nusing this:\n  F i =\n  (if pseudo_mod (F (i - 2)) (F (i - 1)) = 0 then 0\n   else Polynomial.smult (inverse (b i))\n         (pseudo_mod (F (i - 2)) (F (i - 1))))\n  pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F i =\n    Polynomial.smult (inverse (b i)) (pseudo_mod (F (i - 2)) (F (i - 1)))", "by simp"], ["proof (state)\nthis:\n  F i =\n  Polynomial.smult (inverse (b i)) (pseudo_mod (F (i - 2)) (F (i - 1)))\n\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 2)) (F (i - 1)) \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "from arg_cong[OF this, of \"smult (b i)\"] b[of i]"], ["proof (chain)\npicking this:\n  Polynomial.smult (b i) (F i) =\n  Polynomial.smult (b i)\n   (Polynomial.smult (inverse (b i)) (pseudo_mod (F (i - 2)) (F (i - 1))))\n  b i \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.smult (b i) (F i) =\n  Polynomial.smult (b i)\n   (Polynomial.smult (inverse (b i)) (pseudo_mod (F (i - 2)) (F (i - 1))))\n  b i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Polynomial.smult (b i) (F i) = pseudo_mod (F (i - 2)) (F (i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 ?F ?n1 ?d2 ?f3 ?k4 ?b5 G1 G2", "note s.h.simps[simp del]"], ["proof (state)\nthis:\n  s.h ?i =\n  (if ?i \\<le> 1 then 1\n   else if ?i = 2\n        then lead_coeff (F 2) ^ (degree (F 1) - degree (F (Suc 1)))\n        else lead_coeff (F ?i) ^\n             (degree (F (?i - 1)) - degree (F (Suc (?i - 1)))) /\n             s.h (?i - 1) ^\n             (degree (F (?i - 1)) - degree (F (Suc (?i - 1))) - 1))\n\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 ?F ?n1 ?d2 ?f3 ?k4 ?b5 G1 G2", "show \"subresultant_prs_locale2 F (\\<lambda> i. degree (F i)) (\\<lambda> i. degree (F i) - degree (F (Suc i)))\n    (\\<lambda> i. lead_coeff (F i)) k b G1 G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 F (\\<lambda>i. degree (F i))\n     (\\<lambda>i. degree (F i) - degree (F (Suc i)))\n     (\\<lambda>i. lead_coeff (F i)) k b G1 G2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b 3 = (- 1) ^ (degree (F 1) - degree (F (Suc 1)) + 1)\n 2. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "show \"b 3 = (- 1) ^ (degree (F 1) - degree (F (Suc 1)) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b 3 = (- 1) ^ (degree (F 1) - degree (F (Suc 1)) + 1)", "unfolding b.simps numeral_2_eq_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 3 \\<le> Suc (Suc 0) then 1\n     else if 3 = 3\n          then (- 1) ^ (degree (F 1) - degree (F (Suc (Suc 0))) + 1)\n          else if F (3 - Suc (Suc 0)) = 0 then 1\n               else (- 1) ^\n                    (degree (F (3 - Suc (Suc 0))) - degree (F (3 - 1)) +\n                     1) *\n                    lead_coeff (F (3 - Suc (Suc 0))) *\n                    h (3 - Suc (Suc 0)) ^\n                    (degree (F (3 - Suc (Suc 0))) - degree (F (3 - 1)))) =\n    (- 1) ^ (degree (F 1) - degree (F (Suc 1)) + 1)", "by simp"], ["proof (state)\nthis:\n  b 3 = (- 1) ^ (degree (F 1) - degree (F (Suc 1)) + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "assume i: \"4 \\<le> i\" \"i \\<le> Suc k\""], ["proof (state)\nthis:\n  4 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "with s.F0[of \"i - 2\"]"], ["proof (chain)\npicking this:\n  i - 2 \\<noteq> 0 \\<Longrightarrow> (F (i - 2) = 0) = (k < i - 2)\n  4 \\<le> i\n  i \\<le> Suc k", "have \"F (i - 2) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i - 2 \\<noteq> 0 \\<Longrightarrow> (F (i - 2) = 0) = (k < i - 2)\n  4 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. F (i - 2) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "hence bi: \"b i = (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) * lead_coeff (F (i - 2)) *\n                    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))\""], ["proof (prove)\nusing this:\n  F (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b i =\n    (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n    lead_coeff (F (i - 2)) *\n    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))", "unfolding b.simps"], ["proof (prove)\nusing this:\n  F (i - 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i \\<le> 2 then 1\n     else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (i - 2) = 0 then 1\n               else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                    lead_coeff (F (i - 2)) *\n                    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))) =\n    (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n    lead_coeff (F (i - 2)) *\n    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))", "using i"], ["proof (prove)\nusing this:\n  F (i - 2) \\<noteq> 0\n  4 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. (if i \\<le> 2 then 1\n     else if i = 3 then (- 1) ^ (degree (F 1) - degree (F 2) + 1)\n          else if F (i - 2) = 0 then 1\n               else (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n                    lead_coeff (F (i - 2)) *\n                    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))) =\n    (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n    lead_coeff (F (i - 2)) *\n    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))", "by auto"], ["proof (state)\nthis:\n  b i =\n  (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n  lead_coeff (F (i - 2)) *\n  h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "have \"i < k \\<Longrightarrow> s.h i = h i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k \\<Longrightarrow> s.h i = h i", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k \\<Longrightarrow> s.h 0 = h 0\n 2. \\<And>i.\n       \\<lbrakk>i < k \\<Longrightarrow> s.h i = h i; Suc i < k\\<rbrakk>\n       \\<Longrightarrow> s.h (Suc i) = h (Suc i)", "case 0"], ["proof (state)\nthis:\n  0 < k\n\ngoal (2 subgoals):\n 1. 0 < k \\<Longrightarrow> s.h 0 = h 0\n 2. \\<And>i.\n       \\<lbrakk>i < k \\<Longrightarrow> s.h i = h i; Suc i < k\\<rbrakk>\n       \\<Longrightarrow> s.h (Suc i) = h (Suc i)", "thus ?case"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. s.h 0 = h 0", "by (simp add: h.simps s.h.simps)"], ["proof (state)\nthis:\n  s.h 0 = h 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < k \\<Longrightarrow> s.h i = h i; Suc i < k\\<rbrakk>\n       \\<Longrightarrow> s.h (Suc i) = h (Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < k \\<Longrightarrow> s.h i = h i; Suc i < k\\<rbrakk>\n       \\<Longrightarrow> s.h (Suc i) = h (Suc i)", "case (Suc i)"], ["proof (state)\nthis:\n  i < k \\<Longrightarrow> s.h i = h i\n  Suc i < k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < k \\<Longrightarrow> s.h i = h i; Suc i < k\\<rbrakk>\n       \\<Longrightarrow> s.h (Suc i) = h (Suc i)", "from Suc(2) s.F0[of \"Suc i\"]"], ["proof (chain)\npicking this:\n  Suc i < k\n  Suc i \\<noteq> 0 \\<Longrightarrow> (F (Suc i) = 0) = (k < Suc i)", "have \"F (Suc i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Suc i < k\n  Suc i \\<noteq> 0 \\<Longrightarrow> (F (Suc i) = 0) = (k < Suc i)\n\ngoal (1 subgoal):\n 1. F (Suc i) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  F (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < k \\<Longrightarrow> s.h i = h i; Suc i < k\\<rbrakk>\n       \\<Longrightarrow> s.h (Suc i) = h (Suc i)", "with Suc"], ["proof (chain)\npicking this:\n  i < k \\<Longrightarrow> s.h i = h i\n  Suc i < k\n  F (Suc i) \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  i < k \\<Longrightarrow> s.h i = h i\n  Suc i < k\n  F (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s.h (Suc i) = h (Suc i)", "unfolding h.simps[of \"Suc i\"] s.h.simps[of \"Suc i\"] numeral_2_eq_2"], ["proof (prove)\nusing this:\n  i < k \\<Longrightarrow> s.h i = h i\n  Suc i < k\n  F (Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if Suc i \\<le> 1 then 1\n     else if Suc i = Suc (Suc 0)\n          then lead_coeff (F (Suc (Suc 0))) ^\n               (degree (F 1) - degree (F (Suc 1)))\n          else lead_coeff (F (Suc i)) ^\n               (degree (F (Suc i - 1)) - degree (F (Suc (Suc i - 1)))) /\n               s.h (Suc i - 1) ^\n               (degree (F (Suc i - 1)) - degree (F (Suc (Suc i - 1))) -\n                1)) =\n    (if Suc i \\<le> 1 then 1\n     else if Suc i = Suc (Suc 0)\n          then lead_coeff (F (Suc (Suc 0))) ^\n               (degree (F 1) - degree (F (Suc (Suc 0))))\n          else if F (Suc i) = 0 then 1\n               else lead_coeff (F (Suc i)) ^\n                    (degree (F (Suc i - 1)) - degree (F (Suc i))) /\n                    h (Suc i - 1) ^\n                    (degree (F (Suc i - 1)) - degree (F (Suc i)) - 1))", "by simp"], ["proof (state)\nthis:\n  s.h (Suc i) = h (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i1 < k \\<Longrightarrow> s.h ?i1 = h ?i1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "hence sh: \"s.h (i - 2) = h (i - 2)\""], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow> s.h ?i1 = h ?i1\n\ngoal (1 subgoal):\n 1. s.h (i - 2) = h (i - 2)", "using i"], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow> s.h ?i1 = h ?i1\n  4 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. s.h (i - 2) = h (i - 2)", "by simp"], ["proof (state)\nthis:\n  s.h (i - 2) = h (i - 2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "from i"], ["proof (chain)\npicking this:\n  4 \\<le> i\n  i \\<le> Suc k", "have *: \"Suc (i - 2) = i - 1\""], ["proof (prove)\nusing this:\n  4 \\<le> i\n  i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. Suc (i - 2) = i - 1", "by auto"], ["proof (state)\nthis:\n  Suc (i - 2) = i - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>4 \\<le> i; i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> b i =\n                         (- 1) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))) +\n                          1) *\n                         lead_coeff (F (i - 2)) *\n                         s.h (i - 2) ^\n                         (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "show \"b i = (- 1) ^ (degree (F (i - 2)) - degree (F (Suc (i - 2))) + 1) * lead_coeff (F (i - 2)) *\n         s.h (i - 2) ^ (degree (F (i - 2)) - degree (F (Suc (i - 2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b i =\n    (- 1) ^ (degree (F (i - 2)) - degree (F (Suc (i - 2))) + 1) *\n    lead_coeff (F (i - 2)) *\n    s.h (i - 2) ^ (degree (F (i - 2)) - degree (F (Suc (i - 2))))", "unfolding sh bi *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n    lead_coeff (F (i - 2)) *\n    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1))) =\n    (- 1) ^ (degree (F (i - 2)) - degree (F (i - 1)) + 1) *\n    lead_coeff (F (i - 2)) *\n    h (i - 2) ^ (degree (F (i - 2)) - degree (F (i - 1)))", ".."], ["proof (state)\nthis:\n  b i =\n  (- 1) ^ (degree (F (i - 2)) - degree (F (Suc (i - 2))) + 1) *\n  lead_coeff (F (i - 2)) *\n  s.h (i - 2) ^ (degree (F (i - 2)) - degree (F (Suc (i - 2))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subresultant_prs_locale2 F (\\<lambda>i. degree (F i))\n   (\\<lambda>i. degree (F i) - degree (F (Suc i)))\n   (\\<lambda>i. lead_coeff (F i)) k b G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Now we obtain the soundness lemma outside the locale.\\<close>"], ["", "context\n  fixes div_exp :: \"'a :: idom_divide \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'a\"\n  assumes div_exp: \"\\<And> x y n.\n     (to_fract x)^n / (to_fract y)^(n-1) \\<in> range to_fract\n     \\<Longrightarrow> to_fract (div_exp x y n) = (to_fract x)^n / (to_fract y)^(n-1)\"\nbegin"], ["", "lemma resultant_impl_main: assumes len: \"length (coeffs G1) \\<ge> length (coeffs G2)\"\n  shows \"resultant_impl_main div_exp G1 G2 = resultant G1 G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "proof (cases \"G2 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2", "case G2: False"], ["proof (state)\nthis:\n  G2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2", "from enter_subresultant_prs[OF len G2]"], ["proof (chain)\npicking this:\n  \\<exists>F n d f k b. subresultant_prs_locale2 F n d f k b G1 G2", "obtain F n d f k b\n    where \"subresultant_prs_locale2 F n d f k b G1 G2\""], ["proof (prove)\nusing this:\n  \\<exists>F n d f k b. subresultant_prs_locale2 F n d f k b G1 G2\n\ngoal (1 subgoal):\n 1. (\\<And>F n d f k b.\n        subresultant_prs_locale2 F n d f k b G1 G2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subresultant_prs_locale2 F n d f k b G1 G2\n\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2", "interpret subresultant_prs_locale2 F n d f k b G1 G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 F n d f k b G1 G2", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "by (rule resultant_impl_main[OF div_exp])"], ["proof (state)\nthis:\n  resultant_impl_main div_exp G1 G2 = resultant G1 G2\n\ngoal (1 subgoal):\n 1. G2 = 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G2 = 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2", "case G2: True"], ["proof (state)\nthis:\n  G2 = 0\n\ngoal (1 subgoal):\n 1. G2 = 0 \\<Longrightarrow>\n    resultant_impl_main div_exp G1 G2 = resultant G1 G2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_main div_exp G1 G2 = resultant G1 G2", "unfolding G2\n    resultant_impl_main_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 = 0 then if degree G1 = 0 then 1::'a else (0::'a)\n     else case subresultant_prs div_exp G1 0 of\n          (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a)) =\n    resultant G1 0", "using resultant_const(2)[of G1 0]"], ["proof (prove)\nusing this:\n  resultant G1 [:0::'a:] = (0::'a) ^ degree G1\n\ngoal (1 subgoal):\n 1. (if 0 = 0 then if degree G1 = 0 then 1::'a else (0::'a)\n     else case subresultant_prs div_exp G1 0 of\n          (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a)) =\n    resultant G1 0", "by simp"], ["proof (state)\nthis:\n  resultant_impl_main div_exp G1 G2 = resultant G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem resultant_impl_generic: \"resultant_impl_generic div_exp = resultant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_generic div_exp = resultant", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. resultant_impl_generic div_exp x xa = resultant x xa", "fix f g :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. resultant_impl_generic div_exp x xa = resultant x xa", "show \"resultant_impl_generic div_exp f g = resultant f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_generic div_exp f g = resultant f g", "proof (cases \"length (coeffs f) \\<ge> length (coeffs g)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g\n 2. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g", "case True"], ["proof (state)\nthis:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (2 subgoals):\n 1. length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g\n 2. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. resultant_impl_generic div_exp f g = resultant f g", "unfolding resultant_impl_generic_def resultant_impl_main[OF True]"], ["proof (prove)\nusing this:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. (if length (coeffs g) \\<le> length (coeffs f) then resultant f g\n     else let res = resultant_impl_main div_exp g f\n          in if even (degree f) \\<or> even (degree g) then res else - res) =\n    resultant f g", "by auto"], ["proof (state)\nthis:\n  resultant_impl_generic div_exp f g = resultant f g\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g", "case False"], ["proof (state)\nthis:\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g", "hence \"length (coeffs g) \\<ge> length (coeffs f)\""], ["proof (prove)\nusing this:\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. length (coeffs f) \\<le> length (coeffs g)", "by auto"], ["proof (state)\nthis:\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    resultant_impl_generic div_exp f g = resultant f g", "from resultant_impl_main[OF this]"], ["proof (chain)\npicking this:\n  resultant_impl_main div_exp g f = resultant g f", "show ?thesis"], ["proof (prove)\nusing this:\n  resultant_impl_main div_exp g f = resultant g f\n\ngoal (1 subgoal):\n 1. resultant_impl_generic div_exp f g = resultant f g", "unfolding resultant_impl_generic_def resultant_swap[of f g]"], ["proof (prove)\nusing this:\n  resultant_impl_main div_exp g f = resultant g f\n\ngoal (1 subgoal):\n 1. (if length (coeffs g) \\<le> length (coeffs f)\n     then resultant_impl_main div_exp f g\n     else let res = resultant_impl_main div_exp g f\n          in if even (degree f) \\<or> even (degree g) then res else - res) =\n    (- (1::'a)) ^ (degree f * degree g) * resultant g f", "using False"], ["proof (prove)\nusing this:\n  resultant_impl_main div_exp g f = resultant g f\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. (if length (coeffs g) \\<le> length (coeffs f)\n     then resultant_impl_main div_exp f g\n     else let res = resultant_impl_main div_exp g f\n          in if even (degree f) \\<or> even (degree g) then res else - res) =\n    (- (1::'a)) ^ (degree f * degree g) * resultant g f", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  resultant_impl_generic div_exp f g = resultant f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  resultant_impl_generic div_exp f g = resultant f g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma resultant_impl[simp]: \"resultant_impl = resultant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl = resultant", "unfolding resultant_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_generic dichotomous_Lazard = resultant", "by (rule resultant_impl_generic[OF dichotomous_Lazard])"], ["", "lemma resultant_impl_idom_divide[simp]: \"resultant_impl_idom_divide = resultant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_idom_divide = resultant", "unfolding resultant_impl_idom_divide_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_generic basic_div_exp = resultant", "by (rule resultant_impl_generic[OF basic_div_exp])"], ["", "subsection \\<open>Code Equations\\<close>"], ["", "text \\<open>In the following code-equations, we only compute the required values, e.g., $h_k$\n  is not required if $n_k > 0$, we compute $(-1)^{\\ldots} * \\ldots$ via a case-analysis,\n  and we perform special cases for $\\delta_i = 1$, which is the most frequent case.\\<close>"], ["", "partial_function(tailrec) subresultant_prs_main_impl where\n  \"subresultant_prs_main_impl f Gi_1 Gi ni_1 d1_1 hi_2 = (let\n     gi_1 = lead_coeff Gi_1;\n     ni = degree Gi;\n     hi_1 = (if d1_1 = 1 then gi_1 else dichotomous_Lazard gi_1 hi_2 d1_1);\n     d1 = ni_1 - ni;\n     pmod = pseudo_mod Gi_1 Gi\n    in (if pmod = 0 then f (Gi, (if d1 = 1 then lead_coeff Gi\n      else dichotomous_Lazard (lead_coeff Gi) hi_1 d1)) else\n    let\n       gi = lead_coeff Gi;\n       divisor = (-1) ^ (d1 + 1) * gi_1 * (hi_1 ^ d1) ;\n       Gi_p1 = sdiv_poly pmod divisor\n       in subresultant_prs_main_impl f Gi Gi_p1 ni d1 hi_1))\""], ["", "definition subresultant_prs_impl where\n  [code del]: \"subresultant_prs_impl f G1 G2 = (let\n    pmod = pseudo_mod G1 G2;\n    n2 = degree G2;\n    delta_1 = (degree G1 - n2);\n    g2 = lead_coeff G2;\n    h2 = g2 ^ delta_1\n    in if pmod = 0 then f (G2,h2) else let\n      G3 = (- 1) ^ (delta_1 + 1) * pmod;\n      g3 = lead_coeff G3;\n      n3 = degree G3;\n      d2 = n2 - n3;\n      pmod = pseudo_mod G2 G3\n    in if pmod = 0 then f (G3, if d2 = 1 then g3 else dichotomous_Lazard g3 h2 d2)\n    else let divisor = (- 1) ^ (d2 + 1) * g2 * h2 ^ d2; G4 = sdiv_poly pmod divisor\n         in subresultant_prs_main_impl f G3 G4 n3 d2 h2\n    )\""], ["", "lemma subresultant_prs_impl: \"subresultant_prs_impl f G1 G2 = f (subresultant_prs dichotomous_Lazard G1 G2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "define h2 where \"h2 = lead_coeff G2 ^ (degree G1 - degree G2)\""], ["proof (state)\nthis:\n  h2 = lead_coeff G2 ^ (degree G1 - degree G2)\n\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "define G3 where \"G3 = ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2)\""], ["proof (state)\nthis:\n  G3 = (- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2\n\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "define G4 where \"G4 = sdiv_poly (pseudo_mod G2 G3)\n       ((- 1) ^ (degree G2 - degree G3 + 1) * lead_coeff G2 *\n        h2 ^ (degree G2 - degree G3))\""], ["proof (state)\nthis:\n  G4 =\n  sdiv_poly (pseudo_mod G2 G3)\n   ((- (1::'b)) ^ (degree G2 - degree G3 + 1) * lead_coeff G2 *\n    h2 ^ (degree G2 - degree G3))\n\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "define d2 where \"d2 = degree G2 - degree G3\""], ["proof (state)\nthis:\n  d2 = degree G2 - degree G3\n\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "have dl1: \"(if d = 1 then (g :: 'b) else dichotomous_Lazard g h d) = dichotomous_Lazard g h d\" for d g h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if d = 1 then g else dichotomous_Lazard g h d) =\n    dichotomous_Lazard g h d", "by (cases \"d = 1\", auto simp: dichotomous_Lazard dichotomous_Lazard.simps)"], ["proof (state)\nthis:\n  (if ?d = 1 then ?g else dichotomous_Lazard ?g ?h ?d) =\n  dichotomous_Lazard ?g ?h ?d\n\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_impl f G1 G2 =\n    f (subresultant_prs dichotomous_Lazard G1 G2)", "unfolding subresultant_prs_impl_def subresultant_prs_def Let_def\n      subresultant_prs_main.simps[of dichotomous_Lazard G2]\n      if_distrib[of f] dl1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0\n     then f (G2, lead_coeff G2 ^ (degree G1 - degree G2))\n     else if pseudo_mod G2\n              ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2) =\n             0\n          then f ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2,\n                  dichotomous_Lazard\n                   (lead_coeff\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2))\n                   (lead_coeff G2 ^ (degree G1 - degree G2))\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2)))\n          else subresultant_prs_main_impl f\n                ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2\n                    ((- 1) ^ (degree G1 - degree G2 + 1) *\n                     pseudo_mod G1 G2))\n                  ((- (1::'b)) ^\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ (degree G1 - degree G2)) ^\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2))))\n                (degree\n                  ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2))\n                (degree G2 -\n                 degree\n                  ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ (degree G1 - degree G2))) =\n    (if pseudo_mod G1 G2 = 0\n     then f (G2, lead_coeff G2 ^ (degree G1 - degree G2))\n     else if pseudo_mod G2\n              ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2) =\n             0\n          then f ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2,\n                  dichotomous_Lazard\n                   (lead_coeff\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2))\n                   (lead_coeff G2 ^ (degree G1 - degree G2))\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2)))\n          else f (subresultant_prs_main dichotomous_Lazard\n                   ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2)\n                   (sdiv_poly\n                     (pseudo_mod G2\n                       ((- 1) ^ (degree G1 - degree G2 + 1) *\n                        pseudo_mod G1 G2))\n                     ((- (1::'b)) ^\n                      (degree G2 -\n                       degree\n                        ((- 1) ^ (degree G1 - degree G2 + 1) *\n                         pseudo_mod G1 G2) +\n                       1) *\n                      lead_coeff G2 *\n                      (lead_coeff G2 ^ (degree G1 - degree G2)) ^\n                      (degree G2 -\n                       degree\n                        ((- 1) ^ (degree G1 - degree G2 + 1) *\n                         pseudo_mod G1 G2))))\n                   (dichotomous_Lazard\n                     (lead_coeff\n                       ((- 1) ^ (degree G1 - degree G2 + 1) *\n                        pseudo_mod G1 G2))\n                     (lead_coeff G2 ^ (degree G1 - degree G2))\n                     (degree G2 -\n                      degree\n                       ((- 1) ^ (degree G1 - degree G2 + 1) *\n                        pseudo_mod G1 G2)))))", "proof (rule if_cong[OF refl refl if_cong[OF refl refl]], unfold h2_def[symmetric],\n    unfold G3_def[symmetric], unfold G4_def[symmetric], unfold d2_def[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>pseudo_mod G1 G2 \\<noteq> 0;\n     pseudo_mod G2 G3 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n                      f (subresultant_prs_main dichotomous_Lazard G3 G4\n                          (dichotomous_Lazard (lead_coeff G3) h2 d2))", "note simp = subresultant_prs_main_impl.simps[of f] subresultant_prs_main.simps[of dichotomous_Lazard]"], ["proof (state)\nthis:\n  subresultant_prs_main_impl f ?Gi_1.0 ?Gi ?ni_1.0 ?d1_1.0 ?hi_2.0 =\n  (let gi_1 = lead_coeff ?Gi_1.0; ni = degree ?Gi;\n       hi_1 =\n         if ?d1_1.0 = 1 then gi_1\n         else dichotomous_Lazard gi_1 ?hi_2.0 ?d1_1.0;\n       d1 = ?ni_1.0 - ni; pmod = pseudo_mod ?Gi_1.0 ?Gi\n   in if pmod = 0\n      then f (?Gi,\n              if d1 = 1 then lead_coeff ?Gi\n              else dichotomous_Lazard (lead_coeff ?Gi) hi_1 d1)\n      else let gi = lead_coeff ?Gi;\n               divisor = (- (1::'b)) ^ (d1 + 1) * gi_1 * hi_1 ^ d1;\n               Gi_p1 = sdiv_poly pmod divisor\n           in subresultant_prs_main_impl f ?Gi Gi_p1 ni d1 hi_1)\n  subresultant_prs_main dichotomous_Lazard ?f ?g ?c =\n  (let m = degree ?f; n = degree ?g; lf = lead_coeff ?f; lg = lead_coeff ?g;\n       \\<delta> = m - n; d = dichotomous_Lazard lg ?c \\<delta>;\n       h = pseudo_mod ?f ?g\n   in if h = 0 then (?g, d)\n      else subresultant_prs_main dichotomous_Lazard ?g\n            (sdiv_poly h\n              ((- (1::?'c1)) ^ (\\<delta> + 1) * lf * ?c ^ \\<delta>))\n            d)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pseudo_mod G1 G2 \\<noteq> 0;\n     pseudo_mod G2 G3 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n                      f (subresultant_prs_main dichotomous_Lazard G3 G4\n                          (dichotomous_Lazard (lead_coeff G3) h2 d2))", "show \"subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n      f (subresultant_prs_main dichotomous_Lazard G3 G4 (dichotomous_Lazard (lead_coeff G3) h2 d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "proof (induct G4 arbitrary: G3 d2 h2 rule: wf_induct[OF wf_measure[of degree]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x G3 d2 h2.\n       \\<forall>y.\n          (y, x) \\<in> measure degree \\<longrightarrow>\n          (\\<forall>x xa xb.\n              subresultant_prs_main_impl f x y (degree x) xa xb =\n              f (subresultant_prs_main dichotomous_Lazard x y\n                  (dichotomous_Lazard (lead_coeff x) xb\n                    xa))) \\<Longrightarrow>\n       subresultant_prs_main_impl f G3 x (degree G3) d2 h2 =\n       f (subresultant_prs_main dichotomous_Lazard G3 x\n           (dichotomous_Lazard (lead_coeff G3) h2 d2))", "case (1 G4 G3 d2 h2)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, G4) \\<in> measure degree \\<longrightarrow>\n     (\\<forall>x xa xb.\n         subresultant_prs_main_impl f x y (degree x) xa xb =\n         f (subresultant_prs_main dichotomous_Lazard x y\n             (dichotomous_Lazard (lead_coeff x) xb xa)))\n\ngoal (1 subgoal):\n 1. \\<And>x G3 d2 h2.\n       \\<forall>y.\n          (y, x) \\<in> measure degree \\<longrightarrow>\n          (\\<forall>x xa xb.\n              subresultant_prs_main_impl f x y (degree x) xa xb =\n              f (subresultant_prs_main dichotomous_Lazard x y\n                  (dichotomous_Lazard (lead_coeff x) xb\n                    xa))) \\<Longrightarrow>\n       subresultant_prs_main_impl f G3 x (degree G3) d2 h2 =\n       f (subresultant_prs_main dichotomous_Lazard G3 x\n           (dichotomous_Lazard (lead_coeff G3) h2 d2))", "let ?M = \"pseudo_mod G3 G4\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x G3 d2 h2.\n       \\<forall>y.\n          (y, x) \\<in> measure degree \\<longrightarrow>\n          (\\<forall>x xa xb.\n              subresultant_prs_main_impl f x y (degree x) xa xb =\n              f (subresultant_prs_main dichotomous_Lazard x y\n                  (dichotomous_Lazard (lead_coeff x) xb\n                    xa))) \\<Longrightarrow>\n       subresultant_prs_main_impl f G3 x (degree G3) d2 h2 =\n       f (subresultant_prs_main dichotomous_Lazard G3 x\n           (dichotomous_Lazard (lead_coeff G3) h2 d2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "proof (cases \"?M = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pseudo_mod G3 G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))\n 2. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "case True"], ["proof (state)\nthis:\n  pseudo_mod G3 G4 = 0\n\ngoal (2 subgoals):\n 1. pseudo_mod G3 G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))\n 2. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  pseudo_mod G3 G4 = 0\n\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "unfolding simp[of G3] Let_def dl1"], ["proof (prove)\nusing this:\n  pseudo_mod G3 G4 = 0\n\ngoal (1 subgoal):\n 1. (if pseudo_mod G3 G4 = 0\n     then f (G4,\n             dichotomous_Lazard (lead_coeff G4)\n              (dichotomous_Lazard (lead_coeff G3) h2 d2)\n              (degree G3 - degree G4))\n     else subresultant_prs_main_impl f G4\n           (sdiv_poly (pseudo_mod G3 G4)\n             ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n              dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n              (degree G3 - degree G4)))\n           (degree G4) (degree G3 - degree G4)\n           (dichotomous_Lazard (lead_coeff G3) h2 d2)) =\n    f (if pseudo_mod G3 G4 = 0\n       then (G4,\n             dichotomous_Lazard (lead_coeff G4)\n              (dichotomous_Lazard (lead_coeff G3) h2 d2)\n              (degree G3 - degree G4))\n       else subresultant_prs_main dichotomous_Lazard G4\n             (sdiv_poly (pseudo_mod G3 G4)\n               ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n                dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                (degree G3 - degree G4)))\n             (dichotomous_Lazard (lead_coeff G4)\n               (dichotomous_Lazard (lead_coeff G3) h2 d2)\n               (degree G3 - degree G4)))", "by simp"], ["proof (state)\nthis:\n  subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n  f (subresultant_prs_main dichotomous_Lazard G3 G4\n      (dichotomous_Lazard (lead_coeff G3) h2 d2))\n\ngoal (1 subgoal):\n 1. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "case False"], ["proof (state)\nthis:\n  pseudo_mod G3 G4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "hence id: \"(?M = 0) = False\""], ["proof (prove)\nusing this:\n  pseudo_mod G3 G4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (pseudo_mod G3 G4 = 0) = False", "by auto"], ["proof (state)\nthis:\n  (pseudo_mod G3 G4 = 0) = False\n\ngoal (1 subgoal):\n 1. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "let ?c = \"((- 1) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n            (dichotomous_Lazard (lead_coeff G3) h2 d2) ^ (degree G3 - degree G4))\""], ["proof (state)\ngoal (1 subgoal):\n 1. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "let ?N = \"sdiv_poly ?M ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. pseudo_mod G3 G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "proof (cases \"G4 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))\n 2. G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "case G4: False"], ["proof (state)\nthis:\n  G4 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))\n 2. G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "have \"degree ?N \\<le> degree ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (sdiv_poly (pseudo_mod G3 G4)\n       ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n        dichotomous_Lazard (lead_coeff G3) h2 d2 ^ (degree G3 - degree G4)))\n    \\<le> degree (pseudo_mod G3 G4)", "unfolding sdiv_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (map_poly\n       (\\<lambda>c.\n           c div\n           ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n            dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n            (degree G3 - degree G4)))\n       (pseudo_mod G3 G4))\n    \\<le> degree (pseudo_mod G3 G4)", "by (rule degree_map_poly_le)"], ["proof (state)\nthis:\n  degree\n   (sdiv_poly (pseudo_mod G3 G4)\n     ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n      dichotomous_Lazard (lead_coeff G3) h2 d2 ^ (degree G3 - degree G4)))\n  \\<le> degree (pseudo_mod G3 G4)\n\ngoal (2 subgoals):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))\n 2. G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "also"], ["proof (state)\nthis:\n  degree\n   (sdiv_poly (pseudo_mod G3 G4)\n     ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n      dichotomous_Lazard (lead_coeff G3) h2 d2 ^ (degree G3 - degree G4)))\n  \\<le> degree (pseudo_mod G3 G4)\n\ngoal (2 subgoals):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))\n 2. G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "have \"\\<dots> < degree G4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pseudo_mod G3 G4) < degree G4", "using pseudo_mod[OF G4, of G3] False"], ["proof (prove)\nusing this:\n  \\<exists>a q.\n     a \\<noteq> (0::'b) \\<and>\n     Polynomial.smult a G3 = G4 * q + pseudo_mod G3 G4\n  pseudo_mod G3 G4 = 0 \\<or> degree (pseudo_mod G3 G4) < degree G4\n  pseudo_mod G3 G4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (pseudo_mod G3 G4) < degree G4", "by auto"], ["proof (state)\nthis:\n  degree (pseudo_mod G3 G4) < degree G4\n\ngoal (2 subgoals):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))\n 2. G4 \\<noteq> 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "finally"], ["proof (chain)\npicking this:\n  degree\n   (sdiv_poly (pseudo_mod G3 G4)\n     ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n      dichotomous_Lazard (lead_coeff G3) h2 d2 ^ (degree G3 - degree G4)))\n  < degree G4", "show ?thesis"], ["proof (prove)\nusing this:\n  degree\n   (sdiv_poly (pseudo_mod G3 G4)\n     ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n      dichotomous_Lazard (lead_coeff G3) h2 d2 ^ (degree G3 - degree G4)))\n  < degree G4\n\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "unfolding simp[of G3] Let_def id if_False dl1"], ["proof (prove)\nusing this:\n  degree\n   (sdiv_poly (pseudo_mod G3 G4)\n     ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n      dichotomous_Lazard (lead_coeff G3) h2 d2 ^ (degree G3 - degree G4)))\n  < degree G4\n\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G4\n     (sdiv_poly (pseudo_mod G3 G4)\n       ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n        dichotomous_Lazard (lead_coeff G3) h2 d2 ^ (degree G3 - degree G4)))\n     (degree G4) (degree G3 - degree G4)\n     (dichotomous_Lazard (lead_coeff G3) h2 d2) =\n    f (subresultant_prs_main dichotomous_Lazard G4\n        (sdiv_poly (pseudo_mod G3 G4)\n          ((- (1::'b)) ^ (degree G3 - degree G4 + 1) * lead_coeff G3 *\n           dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n           (degree G3 - degree G4)))\n        (dichotomous_Lazard (lead_coeff G4)\n          (dichotomous_Lazard (lead_coeff G3) h2 d2)\n          (degree G3 - degree G4)))", "by (intro 1(1)[rule_format], auto)"], ["proof (state)\nthis:\n  subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n  f (subresultant_prs_main dichotomous_Lazard G3 G4\n      (dichotomous_Lazard (lead_coeff G3) h2 d2))\n\ngoal (1 subgoal):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "case 0: True"], ["proof (state)\nthis:\n  G4 = 0\n\ngoal (1 subgoal):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "with False"], ["proof (chain)\npicking this:\n  pseudo_mod G3 G4 \\<noteq> 0\n  G4 = 0", "have \"G3 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pseudo_mod G3 G4 \\<noteq> 0\n  G4 = 0\n\ngoal (1 subgoal):\n 1. G3 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  G3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. G4 = 0 \\<Longrightarrow>\n    subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 G4\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_main_impl f G3 0 (degree G3) d2 h2 =\n    f (subresultant_prs_main dichotomous_Lazard G3 0\n        (dichotomous_Lazard (lead_coeff G3) h2 d2))", "unfolding simp[of G3] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G3 0 = 0\n     then f (0, if degree G3 - degree 0 = 1 then lead_coeff 0\n                else dichotomous_Lazard (lead_coeff 0)\n                      (if d2 = 1 then lead_coeff G3\n                       else dichotomous_Lazard (lead_coeff G3) h2 d2)\n                      (degree G3 - degree 0))\n     else subresultant_prs_main_impl f 0\n           (sdiv_poly (pseudo_mod G3 0)\n             ((- (1::'b)) ^ (degree G3 - degree 0 + 1) * lead_coeff G3 *\n              (if d2 = 1 then lead_coeff G3\n               else dichotomous_Lazard (lead_coeff G3) h2 d2) ^\n              (degree G3 - degree 0)))\n           (degree 0) (degree G3 - degree 0)\n           (if d2 = 1 then lead_coeff G3\n            else dichotomous_Lazard (lead_coeff G3) h2 d2)) =\n    f (if pseudo_mod G3 0 = 0\n       then (0, dichotomous_Lazard (lead_coeff 0)\n                 (dichotomous_Lazard (lead_coeff G3) h2 d2)\n                 (degree G3 - degree 0))\n       else subresultant_prs_main dichotomous_Lazard 0\n             (sdiv_poly (pseudo_mod G3 0)\n               ((- (1::'b)) ^ (degree G3 - degree 0 + 1) * lead_coeff G3 *\n                dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                (degree G3 - degree 0)))\n             (dichotomous_Lazard (lead_coeff 0)\n               (dichotomous_Lazard (lead_coeff G3) h2 d2)\n               (degree G3 - degree 0)))", "unfolding dl1 simp[of 0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G3 0 = 0\n     then f (0, dichotomous_Lazard (lead_coeff 0)\n                 (dichotomous_Lazard (lead_coeff G3) h2 d2)\n                 (degree G3 - degree 0))\n     else let gi_1 = lead_coeff 0;\n              ni = degree\n                    (sdiv_poly (pseudo_mod G3 0)\n                      ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                       lead_coeff G3 *\n                       dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                       (degree G3 - degree 0)));\n              hi_1 =\n                dichotomous_Lazard gi_1\n                 (dichotomous_Lazard (lead_coeff G3) h2 d2)\n                 (degree G3 - degree 0);\n              d1 = degree 0 - ni;\n              pmod =\n                pseudo_mod 0\n                 (sdiv_poly (pseudo_mod G3 0)\n                   ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                    lead_coeff G3 *\n                    dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                    (degree G3 - degree 0)))\n          in if pmod = 0\n             then f (sdiv_poly (pseudo_mod G3 0)\n                      ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                       lead_coeff G3 *\n                       dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                       (degree G3 - degree 0)),\n                     dichotomous_Lazard\n                      (lead_coeff\n                        (sdiv_poly (pseudo_mod G3 0)\n                          ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                           lead_coeff G3 *\n                           dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                           (degree G3 - degree 0))))\n                      hi_1 d1)\n             else let gi = lead_coeff\n                            (sdiv_poly (pseudo_mod G3 0)\n                              ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                               lead_coeff G3 *\n                               dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                               (degree G3 - degree 0)));\n                      divisor = (- (1::'b)) ^ (d1 + 1) * gi_1 * hi_1 ^ d1;\n                      Gi_p1 = sdiv_poly pmod divisor\n                  in subresultant_prs_main_impl f\n                      (sdiv_poly (pseudo_mod G3 0)\n                        ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                         lead_coeff G3 *\n                         dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                         (degree G3 - degree 0)))\n                      Gi_p1 ni d1 hi_1) =\n    f (if pseudo_mod G3 0 = 0\n       then (0, dichotomous_Lazard (lead_coeff 0)\n                 (dichotomous_Lazard (lead_coeff G3) h2 d2)\n                 (degree G3 - degree 0))\n       else let m = degree 0;\n                n = degree\n                     (sdiv_poly (pseudo_mod G3 0)\n                       ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                        lead_coeff G3 *\n                        dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                        (degree G3 - degree 0)));\n                lf = lead_coeff 0;\n                lg = lead_coeff\n                      (sdiv_poly (pseudo_mod G3 0)\n                        ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                         lead_coeff G3 *\n                         dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                         (degree G3 - degree 0)));\n                \\<delta> = m - n;\n                d = dichotomous_Lazard lg\n                     (dichotomous_Lazard (lead_coeff 0)\n                       (dichotomous_Lazard (lead_coeff G3) h2 d2)\n                       (degree G3 - degree 0))\n                     \\<delta>;\n                h = pseudo_mod 0\n                     (sdiv_poly (pseudo_mod G3 0)\n                       ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                        lead_coeff G3 *\n                        dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                        (degree G3 - degree 0)))\n            in if h = 0\n               then (sdiv_poly (pseudo_mod G3 0)\n                      ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                       lead_coeff G3 *\n                       dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                       (degree G3 - degree 0)),\n                     d)\n               else subresultant_prs_main dichotomous_Lazard\n                     (sdiv_poly (pseudo_mod G3 0)\n                       ((- (1::'b)) ^ (degree G3 - degree 0 + 1) *\n                        lead_coeff G3 *\n                        dichotomous_Lazard (lead_coeff G3) h2 d2 ^\n                        (degree G3 - degree 0)))\n                     (sdiv_poly h\n                       ((- (1::'b)) ^ (\\<delta> + 1) * lf *\n                        dichotomous_Lazard (lead_coeff 0)\n                         (dichotomous_Lazard (lead_coeff G3) h2 d2)\n                         (degree G3 - degree 0) ^\n                        \\<delta>))\n                     d)", "by simp"], ["proof (state)\nthis:\n  subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n  f (subresultant_prs_main dichotomous_Lazard G3 G4\n      (dichotomous_Lazard (lead_coeff G3) h2 d2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n  f (subresultant_prs_main dichotomous_Lazard G3 G4\n      (dichotomous_Lazard (lead_coeff G3) h2 d2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n  f (subresultant_prs_main dichotomous_Lazard G3 G4\n      (dichotomous_Lazard (lead_coeff G3) h2 d2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subresultant_prs_main_impl f G3 G4 (degree G3) d2 h2 =\n  f (subresultant_prs_main dichotomous_Lazard G3 G4\n      (dichotomous_Lazard (lead_coeff G3) h2 d2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subresultant_prs_impl f G1 G2 =\n  f (subresultant_prs dichotomous_Lazard G1 G2)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition [code del]:\n  \"resultant_impl_rec = subresultant_prs_main_impl (\\<lambda> (Gk,hk). if degree Gk = 0 then hk else 0)\""], ["", "definition [code del]:\n  \"resultant_impl_start = subresultant_prs_impl (\\<lambda> (Gk,hk). if degree Gk = 0 then hk else 0)\""], ["", "definition [code del]:\n  \"resultant_impl_Lazard = resultant_impl_main dichotomous_Lazard\""], ["", "lemma resultant_impl_start_code[code]:\n  \"resultant_impl_start G1 G2 =\n     (let pmod = pseudo_mod G1 G2;\n          n2 = degree G2;\n          n1 = degree G1;\n          g2 = lead_coeff G2;\n          d1 = n1 - n2\n         in if pmod = 0 then if n2 = 0 then if d1 = 0 then 1 else if d1 = 1 then g2 else g2 ^ d1 else 0\n            else let\n                 G3 = if even d1 then - pmod else pmod;\n                 n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n                 in if pmod = 0\n                    then if n3 = 0 then\n                     let d2 = n2 - n3;\n                         g3 = lead_coeff G3\n                        in (if d2 = 1 then g3 else\n                            dichotomous_Lazard g3 (if d1 = 1 then g2 else g2 ^ d1) d2) else 0\n                    else let\n                           h2 = (if d1 = 1 then g2 else g2 ^ d1);\n                           d2 = n2 - n3;\n                           divisor = (if d2 = 1 then g2 * h2 else if even d2 then - g2 * h2 ^ d2 else g2 * h2 ^ d2);\n                           G4 = sdiv_poly pmod divisor\n                         in resultant_impl_rec G3 G4 n3 d2 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2; n2 = degree G2; n1 = degree G1;\n         g2 = lead_coeff G2; d1 = n1 - n2\n     in if pmod = 0\n        then if n2 = 0\n             then if d1 = 0 then 1::'a else if d1 = 1 then g2 else g2 ^ d1\n             else (0::'a)\n        else let G3 = if even d1 then - pmod else pmod; n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0\n                then if n3 = 0\n                     then let d2 = n2 - n3; g3 = lead_coeff G3\n                          in if d2 = 1 then g3\n                             else dichotomous_Lazard g3\n                                   (if d1 = 1 then g2 else g2 ^ d1) d2\n                     else (0::'a)\n                else let h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in resultant_impl_rec G3 G4 n3 d2 h2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. resultant_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2; n2 = degree G2; n1 = degree G1;\n         g2 = lead_coeff G2; d1 = n1 - n2\n     in if pmod = 0\n        then if n2 = 0\n             then if d1 = 0 then 1::'a else if d1 = 1 then g2 else g2 ^ d1\n             else (0::'a)\n        else let G3 = if even d1 then - pmod else pmod; n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0\n                then if n3 = 0\n                     then let d2 = n2 - n3; g3 = lead_coeff G3\n                          in if d2 = 1 then g3\n                             else dichotomous_Lazard g3\n                                   (if d1 = 1 then g2 else g2 ^ d1) d2\n                     else (0::'a)\n                else let h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in resultant_impl_rec G3 G4 n3 d2 h2)", "obtain d1 where d1: \"degree G1 - degree G2 = d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        degree G1 - degree G2 = d1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree G1 - degree G2 = d1\n\ngoal (1 subgoal):\n 1. resultant_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2; n2 = degree G2; n1 = degree G1;\n         g2 = lead_coeff G2; d1 = n1 - n2\n     in if pmod = 0\n        then if n2 = 0\n             then if d1 = 0 then 1::'a else if d1 = 1 then g2 else g2 ^ d1\n             else (0::'a)\n        else let G3 = if even d1 then - pmod else pmod; n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0\n                then if n3 = 0\n                     then let d2 = n2 - n3; g3 = lead_coeff G3\n                          in if d2 = 1 then g3\n                             else dichotomous_Lazard g3\n                                   (if d1 = 1 then g2 else g2 ^ d1) d2\n                     else (0::'a)\n                else let h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in resultant_impl_rec G3 G4 n3 d2 h2)", "have id1: \"(if even d1 then - pmod else pmod) = (-1)^ (d1 + 1) * (pmod :: 'a poly)\" for pmod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even d1 then - pmod else pmod) = (- 1) ^ (d1 + 1) * pmod", "by simp"], ["proof (state)\nthis:\n  (if even d1 then - ?pmod else ?pmod) = (- 1) ^ (d1 + 1) * ?pmod\n\ngoal (1 subgoal):\n 1. resultant_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2; n2 = degree G2; n1 = degree G1;\n         g2 = lead_coeff G2; d1 = n1 - n2\n     in if pmod = 0\n        then if n2 = 0\n             then if d1 = 0 then 1::'a else if d1 = 1 then g2 else g2 ^ d1\n             else (0::'a)\n        else let G3 = if even d1 then - pmod else pmod; n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0\n                then if n3 = 0\n                     then let d2 = n2 - n3; g3 = lead_coeff G3\n                          in if d2 = 1 then g3\n                             else dichotomous_Lazard g3\n                                   (if d1 = 1 then g2 else g2 ^ d1) d2\n                     else (0::'a)\n                else let h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in resultant_impl_rec G3 G4 n3 d2 h2)", "have id3: \"(if d2 = 1 then g2 * h2 else if even d2 then - g2 * h2 ^ d2 else g2 * h2 ^ d2) =\n    ((- 1) ^ (d2 + 1) * g2 * h2 ^ d2)\"\n    for d2 and g2 h2 :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if d2 = 1 then g2 * h2\n     else if even d2 then - g2 * h2 ^ d2 else g2 * h2 ^ d2) =\n    (- (1::'a)) ^ (d2 + 1) * g2 * h2 ^ d2", "by auto"], ["proof (state)\nthis:\n  (if ?d2.0 = 1 then ?g2.0 * ?h2.0\n   else if even ?d2.0 then - ?g2.0 * ?h2.0 ^ ?d2.0\n        else ?g2.0 * ?h2.0 ^ ?d2.0) =\n  (- (1::'a)) ^ (?d2.0 + 1) * ?g2.0 * ?h2.0 ^ ?d2.0\n\ngoal (1 subgoal):\n 1. resultant_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2; n2 = degree G2; n1 = degree G1;\n         g2 = lead_coeff G2; d1 = n1 - n2\n     in if pmod = 0\n        then if n2 = 0\n             then if d1 = 0 then 1::'a else if d1 = 1 then g2 else g2 ^ d1\n             else (0::'a)\n        else let G3 = if even d1 then - pmod else pmod; n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0\n                then if n3 = 0\n                     then let d2 = n2 - n3; g3 = lead_coeff G3\n                          in if d2 = 1 then g3\n                             else dichotomous_Lazard g3\n                                   (if d1 = 1 then g2 else g2 ^ d1) d2\n                     else (0::'a)\n                else let h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in resultant_impl_rec G3 G4 n3 d2 h2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2; n2 = degree G2; n1 = degree G1;\n         g2 = lead_coeff G2; d1 = n1 - n2\n     in if pmod = 0\n        then if n2 = 0\n             then if d1 = 0 then 1::'a else if d1 = 1 then g2 else g2 ^ d1\n             else (0::'a)\n        else let G3 = if even d1 then - pmod else pmod; n3 = degree G3;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0\n                then if n3 = 0\n                     then let d2 = n2 - n3; g3 = lead_coeff G3\n                          in if d2 = 1 then g3\n                             else dichotomous_Lazard g3\n                                   (if d1 = 1 then g2 else g2 ^ d1) d2\n                     else (0::'a)\n                else let h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in resultant_impl_rec G3 G4 n3 d2 h2)", "unfolding resultant_impl_start_def subresultant_prs_impl_def resultant_impl_rec_def[symmetric] Let_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0 then lead_coeff G2 ^ (degree G1 - degree G2)\n          else (0::'a)\n     else if pseudo_mod G2\n              ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2) =\n             0\n          then if degree\n                   ((- 1) ^ (degree G1 - degree G2 + 1) *\n                    pseudo_mod G1 G2) =\n                  0\n               then if degree G2 -\n                       degree\n                        ((- 1) ^ (degree G1 - degree G2 + 1) *\n                         pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff\n                          ((- 1) ^ (degree G1 - degree G2 + 1) *\n                           pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff\n                            ((- 1) ^ (degree G1 - degree G2 + 1) *\n                             pseudo_mod G1 G2))\n                          (lead_coeff G2 ^ (degree G1 - degree G2))\n                          (degree G2 -\n                           degree\n                            ((- 1) ^ (degree G1 - degree G2 + 1) *\n                             pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec\n                ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2\n                    ((- 1) ^ (degree G1 - degree G2 + 1) *\n                     pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ (degree G1 - degree G2)) ^\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2))))\n                (degree\n                  ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2))\n                (degree G2 -\n                 degree\n                  ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ (degree G1 - degree G2))) =\n    (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0\n          then if degree G1 - degree G2 = 0 then 1::'a\n               else if degree G1 - degree G2 = 1 then lead_coeff G2\n                    else lead_coeff G2 ^ (degree G1 - degree G2)\n          else (0::'a)\n     else if pseudo_mod G2\n              (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n               else pseudo_mod G1 G2) =\n             0\n          then if degree\n                   (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                    else pseudo_mod G1 G2) =\n                  0\n               then if degree G2 -\n                       degree\n                        (if even (degree G1 - degree G2)\n                         then - pseudo_mod G1 G2 else pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff\n                          (if even (degree G1 - degree G2)\n                           then - pseudo_mod G1 G2 else pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff\n                            (if even (degree G1 - degree G2)\n                             then - pseudo_mod G1 G2 else pseudo_mod G1 G2))\n                          (if degree G1 - degree G2 = 1 then lead_coeff G2\n                           else lead_coeff G2 ^ (degree G1 - degree G2))\n                          (degree G2 -\n                           degree\n                            (if even (degree G1 - degree G2)\n                             then - pseudo_mod G1 G2 else pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec\n                (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                 else pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2\n                    (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                     else pseudo_mod G1 G2))\n                  (if degree G2 -\n                      degree\n                       (if even (degree G1 - degree G2)\n                        then - pseudo_mod G1 G2 else pseudo_mod G1 G2) =\n                      1\n                   then lead_coeff G2 *\n                        (if degree G1 - degree G2 = 1 then lead_coeff G2\n                         else lead_coeff G2 ^ (degree G1 - degree G2))\n                   else if even\n                            (degree G2 -\n                             degree\n                              (if even (degree G1 - degree G2)\n                               then - pseudo_mod G1 G2\n                               else pseudo_mod G1 G2))\n                        then - lead_coeff G2 *\n                             (if degree G1 - degree G2 = 1\n                              then lead_coeff G2\n                              else lead_coeff G2 ^\n                                   (degree G1 - degree G2)) ^\n                             (degree G2 -\n                              degree\n                               (if even (degree G1 - degree G2)\n                                then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))\n                        else lead_coeff G2 *\n                             (if degree G1 - degree G2 = 1\n                              then lead_coeff G2\n                              else lead_coeff G2 ^\n                                   (degree G1 - degree G2)) ^\n                             (degree G2 -\n                              degree\n                               (if even (degree G1 - degree G2)\n                                then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))))\n                (degree\n                  (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (degree G2 -\n                 degree\n                  (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (if degree G1 - degree G2 = 1 then lead_coeff G2\n                 else lead_coeff G2 ^ (degree G1 - degree G2)))", "unfolding d1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0 then lead_coeff G2 ^ d1 else (0::'a)\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then if degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n               then if degree G2 -\n                       degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                          (lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ d1) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ d1)) =\n    (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0\n          then if d1 = 0 then 1::'a\n               else if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1\n          else (0::'a)\n     else if pseudo_mod G2\n              (if even d1 then - pseudo_mod G1 G2 else pseudo_mod G1 G2) =\n             0\n          then if degree\n                   (if even d1 then - pseudo_mod G1 G2\n                    else pseudo_mod G1 G2) =\n                  0\n               then if degree G2 -\n                       degree\n                        (if even d1 then - pseudo_mod G1 G2\n                         else pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff\n                          (if even d1 then - pseudo_mod G1 G2\n                           else pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff\n                            (if even d1 then - pseudo_mod G1 G2\n                             else pseudo_mod G1 G2))\n                          (if d1 = 1 then lead_coeff G2\n                           else lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree\n                            (if even d1 then - pseudo_mod G1 G2\n                             else pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec\n                (if even d1 then - pseudo_mod G1 G2 else pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2\n                    (if even d1 then - pseudo_mod G1 G2\n                     else pseudo_mod G1 G2))\n                  (if degree G2 -\n                      degree\n                       (if even d1 then - pseudo_mod G1 G2\n                        else pseudo_mod G1 G2) =\n                      1\n                   then lead_coeff G2 *\n                        (if d1 = 1 then lead_coeff G2\n                         else lead_coeff G2 ^ d1)\n                   else if even\n                            (degree G2 -\n                             degree\n                              (if even d1 then - pseudo_mod G1 G2\n                               else pseudo_mod G1 G2))\n                        then - lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree\n                               (if even d1 then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))\n                        else lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree\n                               (if even d1 then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))))\n                (degree\n                  (if even d1 then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (degree G2 -\n                 degree\n                  (if even d1 then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1))", "unfolding id1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0 then lead_coeff G2 ^ d1 else (0::'a)\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then if degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n               then if degree G2 -\n                       degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                          (lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ d1) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ d1)) =\n    (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0\n          then if d1 = 0 then 1::'a\n               else if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1\n          else (0::'a)\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then if degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n               then if degree G2 -\n                       degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                          (if d1 = 1 then lead_coeff G2\n                           else lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  (if degree G2 -\n                      degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                      1\n                   then lead_coeff G2 *\n                        (if d1 = 1 then lead_coeff G2\n                         else lead_coeff G2 ^ d1)\n                   else if even\n                            (degree G2 -\n                             degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                        then - lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                        else lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree\n                               ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1))", "unfolding id3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0 then lead_coeff G2 ^ d1 else (0::'a)\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then if degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n               then if degree G2 -\n                       degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                          (lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ d1) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ d1)) =\n    (if pseudo_mod G1 G2 = 0\n     then if degree G2 = 0\n          then if d1 = 0 then 1::'a\n               else if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1\n          else (0::'a)\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then if degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n               then if degree G2 -\n                       degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                          (if d1 = 1 then lead_coeff G2\n                           else lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n               else (0::'a)\n          else resultant_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1))", "by (rule if_cong[OF refl if_cong if_cong], auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  resultant_impl_start G1 G2 =\n  (let pmod = pseudo_mod G1 G2; n2 = degree G2; n1 = degree G1;\n       g2 = lead_coeff G2; d1 = n1 - n2\n   in if pmod = 0\n      then if n2 = 0\n           then if d1 = 0 then 1::'a else if d1 = 1 then g2 else g2 ^ d1\n           else (0::'a)\n      else let G3 = if even d1 then - pmod else pmod; n3 = degree G3;\n               pmod = pseudo_mod G2 G3\n           in if pmod = 0\n              then if n3 = 0\n                   then let d2 = n2 - n3; g3 = lead_coeff G3\n                        in if d2 = 1 then g3\n                           else dichotomous_Lazard g3\n                                 (if d1 = 1 then g2 else g2 ^ d1) d2\n                   else (0::'a)\n              else let h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                       divisor =\n                         if d2 = 1 then g2 * h2\n                         else if even d2 then - g2 * h2 ^ d2\n                              else g2 * h2 ^ d2;\n                       G4 = sdiv_poly pmod divisor\n                   in resultant_impl_rec G3 G4 n3 d2 h2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resultant_impl_rec_code[code]:\n  \"resultant_impl_rec Gi_1 Gi ni_1 d1_1 hi_2 = (\n    let ni = degree Gi;\n        pmod = pseudo_mod Gi_1 Gi\n     in\n     if pmod = 0\n        then if ni = 0\n          then\n            let\n              d1 = ni_1 - ni;\n              gi = lead_coeff Gi\n            in if d1 = 1 then gi else\n              let gi_1 = lead_coeff Gi_1;\n                  hi_1 = (if d1_1 = 1 then gi_1 else dichotomous_Lazard gi_1 hi_2 d1_1) in\n                dichotomous_Lazard gi hi_1 d1\n          else 0\n        else let\n           d1 = ni_1 - ni;\n           gi_1 = lead_coeff Gi_1;\n           hi_1 = (if d1_1 = 1 then gi_1 else dichotomous_Lazard gi_1 hi_2 d1_1);\n           divisor = if d1 = 1 then gi_1 * hi_1 else if even d1 then - gi_1 * hi_1 ^ d1 else gi_1 * hi_1 ^ d1;\n           Gi_p1 = sdiv_poly pmod divisor\n       in resultant_impl_rec Gi Gi_p1 ni d1 hi_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_rec Gi_1 Gi ni_1 d1_1 hi_2 =\n    (let ni = degree Gi; pmod = pseudo_mod Gi_1 Gi\n     in if pmod = 0\n        then if ni = 0\n             then let d1 = ni_1 - ni; gi = lead_coeff Gi\n                  in if d1 = 1 then gi\n                     else let gi_1 = lead_coeff Gi_1;\n                              hi_1 =\n                                if d1_1 = 1 then gi_1\n                                else dichotomous_Lazard gi_1 hi_2 d1_1\n                          in dichotomous_Lazard gi hi_1 d1\n             else (0::'a)\n        else let d1 = ni_1 - ni; gi_1 = lead_coeff Gi_1;\n                 hi_1 =\n                   if d1_1 = 1 then gi_1\n                   else dichotomous_Lazard gi_1 hi_2 d1_1;\n                 divisor =\n                   if d1 = 1 then gi_1 * hi_1\n                   else if even d1 then - gi_1 * hi_1 ^ d1\n                        else gi_1 * hi_1 ^ d1;\n                 Gi_p1 = sdiv_poly pmod divisor\n             in resultant_impl_rec Gi Gi_p1 ni d1 hi_1)", "unfolding resultant_impl_rec_def subresultant_prs_main_impl.simps[of _ Gi_1] split Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod Gi_1 Gi = 0\n     then if degree Gi = 0\n          then if ni_1 - degree Gi = 1 then lead_coeff Gi\n               else dichotomous_Lazard (lead_coeff Gi)\n                     (if d1_1 = 1 then lead_coeff Gi_1\n                      else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n                     (ni_1 - degree Gi)\n          else (0::'a)\n     else subresultant_prs_main_impl\n           (\\<lambda>(Gk, hk). if degree Gk = 0 then hk else (0::'a)) Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             ((- (1::'a)) ^ (ni_1 - degree Gi + 1) * lead_coeff Gi_1 *\n              (if d1_1 = 1 then lead_coeff Gi_1\n               else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1) ^\n              (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)) =\n    (if pseudo_mod Gi_1 Gi = 0\n     then if degree Gi = 0\n          then if ni_1 - degree Gi = 1 then lead_coeff Gi\n               else dichotomous_Lazard (lead_coeff Gi)\n                     (if d1_1 = 1 then lead_coeff Gi_1\n                      else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n                     (ni_1 - degree Gi)\n          else (0::'a)\n     else subresultant_prs_main_impl\n           (\\<lambda>(Gk, hk). if degree Gk = 0 then hk else (0::'a)) Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             (if ni_1 - degree Gi = 1\n              then lead_coeff Gi_1 *\n                   (if d1_1 = 1 then lead_coeff Gi_1\n                    else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n              else if even (ni_1 - degree Gi)\n                   then - lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)\n                   else lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1))", "unfolding resultant_impl_rec_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod Gi_1 Gi = 0\n     then if degree Gi = 0\n          then if ni_1 - degree Gi = 1 then lead_coeff Gi\n               else dichotomous_Lazard (lead_coeff Gi)\n                     (if d1_1 = 1 then lead_coeff Gi_1\n                      else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n                     (ni_1 - degree Gi)\n          else (0::'a)\n     else resultant_impl_rec Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             ((- (1::'a)) ^ (ni_1 - degree Gi + 1) * lead_coeff Gi_1 *\n              (if d1_1 = 1 then lead_coeff Gi_1\n               else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1) ^\n              (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)) =\n    (if pseudo_mod Gi_1 Gi = 0\n     then if degree Gi = 0\n          then if ni_1 - degree Gi = 1 then lead_coeff Gi\n               else dichotomous_Lazard (lead_coeff Gi)\n                     (if d1_1 = 1 then lead_coeff Gi_1\n                      else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n                     (ni_1 - degree Gi)\n          else (0::'a)\n     else resultant_impl_rec Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             (if ni_1 - degree Gi = 1\n              then lead_coeff Gi_1 *\n                   (if d1_1 = 1 then lead_coeff Gi_1\n                    else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n              else if even (ni_1 - degree Gi)\n                   then - lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)\n                   else lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1))", "by (rule if_cong[OF _ if_cong _], auto)"], ["", "lemma resultant_impl_Lazard_code[code]: \"resultant_impl_Lazard G1 G2 =\n  (if G2 = 0 then if degree G1 = 0 then 1 else 0\n     else resultant_impl_start G1 G2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl_Lazard G1 G2 =\n    (if G2 = 0 then if degree G1 = 0 then 1::'a else (0::'a)\n     else resultant_impl_start G1 G2)", "unfolding resultant_impl_Lazard_def resultant_impl_main_def\n   resultant_impl_start_def subresultant_prs_impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if G2 = 0 then if degree G1 = 0 then 1::'a else (0::'a)\n     else case subresultant_prs dichotomous_Lazard G1 G2 of\n          (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a)) =\n    (if G2 = 0 then if degree G1 = 0 then 1::'a else (0::'a)\n     else case subresultant_prs dichotomous_Lazard G1 G2 of\n          (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a))", "by simp"], ["", "lemma resultant_impl_code[code]: \"resultant_impl f g =\n  (if length (coeffs f) \\<ge> length (coeffs g) then resultant_impl_Lazard f g\n     else let res = resultant_impl_Lazard g f in\n      if even (degree f) \\<or> even (degree g) then res else - res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant_impl f g =\n    (if length (coeffs g) \\<le> length (coeffs f)\n     then resultant_impl_Lazard f g\n     else let res = resultant_impl_Lazard g f\n          in if even (degree f) \\<or> even (degree g) then res else - res)", "unfolding resultant_impl_def resultant_impl_generic_def resultant_impl_Lazard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length (coeffs g) \\<le> length (coeffs f)\n     then resultant_impl_main dichotomous_Lazard f g\n     else let res = resultant_impl_main dichotomous_Lazard g f\n          in if even (degree f) \\<or> even (degree g) then res else - res) =\n    (if length (coeffs g) \\<le> length (coeffs f)\n     then resultant_impl_main dichotomous_Lazard f g\n     else let res = resultant_impl_main dichotomous_Lazard g f\n          in if even (degree f) \\<or> even (degree g) then res else - res)", ".."], ["", "lemma resultant_code[code]: \"resultant f g = resultant_impl f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant f g = resultant_impl f g", "by simp"], ["", "end"]]}