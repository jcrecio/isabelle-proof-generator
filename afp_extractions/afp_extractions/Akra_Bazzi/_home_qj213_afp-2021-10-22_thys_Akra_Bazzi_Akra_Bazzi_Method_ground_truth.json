{"file_name": "/home/qj213/afp-2021-10-22/thys/Akra_Bazzi/Akra_Bazzi_Method.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Akra_Bazzi", "problem_names": ["lemma landau_symbol_ge_3_cong:\n  assumes \"landau_symbol L L' Lr\"\n  assumes \"\\<And>x::'a::linordered_semidom. x \\<ge> 3 \\<Longrightarrow> f x = g x\"\n  shows   \"L at_top (f) = L at_top (g)\"", "lemma exp_1_lt_3: \"exp (1::real) < 3\"", "lemma ln_ln_pos:\n  assumes \"(x::real) \\<ge> 3\"\n  shows   \"ln (ln x) > 0\"", "lemma akra_bazzi_termsI:\n  \"(\\<And>i. i < length bs \\<Longrightarrow> akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs!i) (ts!i)) \\<Longrightarrow> akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts\"", "lemma master_theorem_functionI:\n  assumes \"\\<forall>x\\<in>{x\\<^sub>0..<x\\<^sub>1}. f x \\<ge> 0\"\n  assumes \"\\<forall>x\\<ge>x\\<^sub>1. f x = g x + (\\<Sum>i<k. as ! i * f ((ts ! i) x))\"\n  assumes \"\\<forall>x\\<ge>x\\<^sub>1. g x \\<ge> 0\"\n  assumes \"\\<forall>a\\<in>set as. a \\<ge> 0\"\n  assumes \"list_ex (\\<lambda>a. a > 0) as\"\n  assumes \"\\<forall>b\\<in>set bs. b \\<in> {0<..<1}\"\n  assumes \"k \\<noteq> 0\"\n  assumes \"length as = k\"\n  assumes \"length bs = k\"\n  assumes \"length ts = k\"\n  assumes \"akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts\"\n  shows \"master_theorem_function x\\<^sub>0 x\\<^sub>1 k as bs ts f g\"", "lemma akra_bazzi_term_measure:\n  \" x \\<ge> x\\<^sub>1 \\<Longrightarrow> akra_bazzi_term 0 x\\<^sub>1 b t \\<Longrightarrow> (t x, x) \\<in> Wellfounded.measure (\\<lambda>n::nat. n)\"\n  \" x > x\\<^sub>1 \\<Longrightarrow> akra_bazzi_term 0 (Suc x\\<^sub>1) b t \\<Longrightarrow> (t x, x) \\<in> Wellfounded.measure (\\<lambda>n::nat. n)\"", "lemma measure_prod_conv: \n  \"((a, b), (c, d)) \\<in> Wellfounded.measure (\\<lambda>x. t (fst x)) \\<longleftrightarrow> (a, c) \\<in> Wellfounded.measure t\"\n  \"((e, f), (g, h)) \\<in> Wellfounded.measure (\\<lambda>x. t (snd x)) \\<longleftrightarrow> (f, h) \\<in> Wellfounded.measure t\"", "lemmas measure_prod_conv' = measure_prod_conv[where t = \"\\<lambda>x. x\"]", "lemma akra_bazzi_termination_simps:\n  fixes x :: nat\n  shows \"a * real x / b = a/b * real x\" \"real x / b = 1/b * real x\"", "lemma akra_bazzi_params_nonzeroI:\n  \"length as = length bs \\<Longrightarrow>  \n   (\\<forall>a\\<in>set as. a \\<ge> 0) \\<Longrightarrow> (\\<forall>b\\<in>set bs. b \\<in> {0<..<1}) \\<Longrightarrow> (\\<exists>a\\<in>set as. a > 0) \\<Longrightarrow>\n   akra_bazzi_params_nonzero (length as) as bs\"", "lemmas akra_bazzi_p_rel_intros = \n  akra_bazzi_params_nonzero.p_lessI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_greaterI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_leI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_geI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_boundsI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_boundsI'[rotated, OF _ akra_bazzi_params_nonzeroI]", "lemma eval_length: \"length [] = 0\" \"length (x # xs) = Suc (length xs)\"", "lemma eval_akra_bazzi_sum:\n  \"(\\<Sum>i<0. as!i * bs!i powr x) = 0\"\n  \"(\\<Sum>i<Suc 0. (a#as)!i * (b#bs)!i powr x) = a * b powr x\"\n  \"(\\<Sum>i<Suc k. (a#as)!i * (b#bs)!i powr x) = a * b powr x + (\\<Sum>i<k. as!i * bs!i powr x)\"", "lemma eval_akra_bazzi_sum':\n  \"(\\<Sum>i<0. as!i * f ((ts!i) x)) = 0\"\n  \"(\\<Sum>i<Suc 0. (a#as)!i * f (((t#ts)!i) x)) = a * f (t x)\"\n  \"(\\<Sum>i<Suc k. (a#as)!i * f (((t#ts)!i) x)) = a * f (t x) + (\\<Sum>i<k. as!i * f ((ts!i) x))\"", "lemma akra_bazzi_termsI':\n  \"akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 [] []\"\n  \"akra_bazzi_term x\\<^sub>0 x\\<^sub>1 b t \\<Longrightarrow> akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts \\<Longrightarrow> akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 (b#bs) (t#ts)\"", "lemma ball_set_intros: \"(\\<forall>x\\<in>set []. P x)\" \"P x \\<Longrightarrow> (\\<forall>x\\<in>set xs. P x) \\<Longrightarrow> (\\<forall>x\\<in>set (x#xs). P x)\"", "lemma ball_set_simps: \"(\\<forall>x\\<in>set []. P x) = True\" \"(\\<forall>x\\<in>set (x#xs). P x) = (P x \\<and> (\\<forall>x\\<in>set xs. P x))\"", "lemma bex_set_simps: \"(\\<exists>x\\<in>set []. P x) = False\" \"(\\<exists>x\\<in>set (x#xs). P x) = (P x \\<or> (\\<exists>x\\<in>set xs. P x))\"", "lemma eval_akra_bazzi_le_list_ex:\n  \"list_ex P (x#y#xs) \\<longleftrightarrow> P x \\<or> list_ex P (y#xs)\"\n  \"list_ex P [x] \\<longleftrightarrow> P x\"\n  \"list_ex P [] \\<longleftrightarrow> False\"", "lemma eval_akra_bazzi_le_sum_list:\n  \"x \\<le> sum_list [] \\<longleftrightarrow> x \\<le> 0\" \"x \\<le> sum_list (y#ys) \\<longleftrightarrow> x \\<le> y + sum_list ys\"\n  \"x \\<le> z + sum_list [] \\<longleftrightarrow> x \\<le> z\" \"x \\<le> z + sum_list (y#ys) \\<longleftrightarrow> x \\<le> z + y + sum_list ys\"", "lemma atLeastLessThanE: \"x \\<in> {a..<b} \\<Longrightarrow> (x \\<ge> a \\<Longrightarrow> x < b \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma master_theorem_preprocess:\n  \"\\<Theta>(\\<lambda>n::nat. 1) = \\<Theta>(\\<lambda>n::nat. real n powr 0)\"\n  \"\\<Theta>(\\<lambda>n::nat. real n) = \\<Theta>(\\<lambda>n::nat. real n powr 1)\"\n  \"O(\\<lambda>n::nat. 1) = O(\\<lambda>n::nat. real n powr 0)\"\n  \"O(\\<lambda>n::nat. real n) = O(\\<lambda>n::nat. real n powr 1)\"\n\n  \"\\<Theta>(\\<lambda>n::nat. ln (ln (real n))) = \\<Theta>(\\<lambda>n::nat. real n powr 0 * ln (ln (real n)))\"\n  \"\\<Theta>(\\<lambda>n::nat. real n * ln (ln (real n))) = \\<Theta>(\\<lambda>n::nat. real n powr 1 * ln (ln (real n)))\"\n\n  \"\\<Theta>(\\<lambda>n::nat. ln (real n)) = \\<Theta>(\\<lambda>n::nat. real n powr 0 * ln (real n) powr 1)\"\n  \"\\<Theta>(\\<lambda>n::nat. real n * ln (real n)) = \\<Theta>(\\<lambda>n::nat. real n powr 1 * ln (real n) powr 1)\"\n  \"\\<Theta>(\\<lambda>n::nat. real n powr p * ln (real n)) = \\<Theta>(\\<lambda>n::nat. real n powr p * ln (real n) powr 1)\"\n  \"\\<Theta>(\\<lambda>n::nat. ln (real n) powr p') = \\<Theta>(\\<lambda>n::nat. real n powr 0 * ln (real n) powr p')\"\n  \"\\<Theta>(\\<lambda>n::nat. real n * ln (real n) powr p') = \\<Theta>(\\<lambda>n::nat. real n powr 1 * ln (real n) powr p')\"", "lemma akra_bazzi_term_imp_size_less:\n  \"x\\<^sub>1 \\<le> x \\<Longrightarrow> akra_bazzi_term 0 x\\<^sub>1 b t \\<Longrightarrow> size (t x) < size x\" \n  \"x\\<^sub>1 < x \\<Longrightarrow> akra_bazzi_term 0 (Suc x\\<^sub>1) b t \\<Longrightarrow> size (t x) < size x\"", "lemma ln_1_imp_less_3:\n  \"ln x = (1::real) \\<Longrightarrow> x < 3\"", "lemma ln_1_imp_less_3': \"ln (real (x::nat)) = 1 \\<Longrightarrow> x < 3\"", "lemma ln_ln_nonneg: \"x \\<ge> (3::real) \\<Longrightarrow> ln (ln x) \\<ge> 0\"", "lemma ln_ln_nonneg': \"x \\<ge> (3::nat) \\<Longrightarrow> ln (ln (real x)) \\<ge> 0\"", "lemma MASTER_BOUND_postproc:\n  \"CLAMP (MASTER_BOUND' a 0) = CLAMP (MASTER_BOUND'' a)\"\n  \"CLAMP (MASTER_BOUND' a 1) = CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x * CLAMP (\\<lambda>x. ln (real x)) x)\"\n  \"CLAMP (MASTER_BOUND' a (numeral n)) = \n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x * CLAMP (\\<lambda>x. ln (real x) ^ numeral n) x)\"\n  \"CLAMP (MASTER_BOUND' a (-1)) =\n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x / CLAMP (\\<lambda>x. ln (real x)) x)\"\n  \"CLAMP (MASTER_BOUND' a (-numeral n)) = \n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x / CLAMP (\\<lambda>x. ln (real x) ^ numeral n) x)\"\n  \"CLAMP (MASTER_BOUND' a b) = \n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x * CLAMP (\\<lambda>x. ln (real x) powr b) x)\"\n\n  \"CLAMP (MASTER_BOUND'' 0) = CLAMP (\\<lambda>x. 1)\"\n  \"CLAMP (MASTER_BOUND'' 1) = CLAMP (\\<lambda>x. (real x))\"\n  \"CLAMP (MASTER_BOUND'' (numeral n)) = CLAMP (\\<lambda>x. (real x) ^ numeral n)\"\n  \"CLAMP (MASTER_BOUND'' (-1)) = CLAMP (\\<lambda>x. 1 / (real x))\"\n  \"CLAMP (MASTER_BOUND'' (-numeral n)) = CLAMP (\\<lambda>x. 1 / (real x) ^ numeral n)\"\n  \"CLAMP (MASTER_BOUND'' a) = CLAMP (\\<lambda>x. (real x) powr a)\"\n\n  and MASTER_BOUND_UNCLAMP:\n  \"CLAMP (\\<lambda>x. CLAMP f x * CLAMP g x) = CLAMP (\\<lambda>x. f x * g x)\"\n  \"CLAMP (\\<lambda>x. CLAMP f x / CLAMP g x) = CLAMP (\\<lambda>x. f x / g x)\"\n  \"CLAMP (CLAMP f) = CLAMP f\"", "lemma CLAMP_: \n  \"landau_symbol L L' Lr \\<Longrightarrow> L at_top (f::nat \\<Rightarrow> real) \\<equiv> L at_top (\\<lambda>x. CLAMP f x)\"", "lemma UNCLAMP'_: \n  \"landau_symbol L L' Lr \\<Longrightarrow> L at_top (CLAMP' (MASTER_BOUND a b c)) \\<equiv> L at_top (MASTER_BOUND a b c)\"", "lemma UNCLAMP_: \n  \"landau_symbol L L' Lr \\<Longrightarrow> L at_top (CLAMP f) \\<equiv> L at_top (f)\"", "lemmas CLAMP = landau_symbols[THEN CLAMP_]", "lemmas UNCLAMP' = landau_symbols[THEN UNCLAMP'_]", "lemmas UNCLAMP = landau_symbols[THEN UNCLAMP_]", "lemma propagate_CLAMP:\n  \"CLAMP (\\<lambda>x. f x * g x) = CLAMP' (\\<lambda>x. CLAMP f x * CLAMP g x)\"\n  \"CLAMP (\\<lambda>x. f x / g x) = CLAMP' (\\<lambda>x. CLAMP f x / CLAMP g x)\"\n  \"CLAMP (\\<lambda>x. inverse (f x)) = CLAMP' (\\<lambda>x. inverse (CLAMP f x))\"\n  \"CLAMP (\\<lambda>x. real x) = CLAMP' (MASTER_BOUND 1 0 0)\"\n  \"CLAMP (\\<lambda>x. real x powr a) = CLAMP' (MASTER_BOUND a 0 0)\"\n  \"CLAMP (\\<lambda>x. real x ^ a') = CLAMP' (MASTER_BOUND (real a') 0 0)\"\n  \"CLAMP (\\<lambda>x. ln (real x)) = CLAMP' (MASTER_BOUND 0 1 0)\"\n  \"CLAMP (\\<lambda>x. ln (real x) powr b) = CLAMP' (MASTER_BOUND 0 b 0)\"\n  \"CLAMP (\\<lambda>x. ln (real x) ^ b') = CLAMP' (MASTER_BOUND 0 (real b') 0)\"\n  \"CLAMP (\\<lambda>x. ln (ln (real x))) = CLAMP' (MASTER_BOUND 0 0 1)\"\n  \"CLAMP (\\<lambda>x. ln (ln (real x)) powr c) = CLAMP' (MASTER_BOUND 0 0 c)\"\n  \"CLAMP (\\<lambda>x. ln (ln (real x)) ^ c') = CLAMP' (MASTER_BOUND 0 0 (real c'))\"\n  \"CLAMP' (CLAMP f) = CLAMP' f\"\n  \"CLAMP' (\\<lambda>x. CLAMP' (MASTER_BOUND a1 b1 c1) x * CLAMP' (MASTER_BOUND a2 b2 c2) x) = \n       CLAMP' (MASTER_BOUND (a1+a2) (b1+b2) (c1+c2))\"\n  \"CLAMP' (\\<lambda>x. CLAMP' (MASTER_BOUND a1 b1 c1) x / CLAMP' (MASTER_BOUND a2 b2 c2) x) = \n       CLAMP' (MASTER_BOUND (a1-a2) (b1-b2) (c1-c2))\"\n  \"CLAMP' (\\<lambda>x. inverse (MASTER_BOUND a1 b1 c1 x)) = CLAMP' (MASTER_BOUND (-a1) (-b1) (-c1))\"", "lemma numeral_assoc_simps:\n  \"((a::real) + numeral b) + numeral c = a + numeral (b + c)\"\n  \"(a + numeral b) - numeral c = a + neg_numeral_class.sub b c\"\n  \"(a - numeral b) + numeral c = a + neg_numeral_class.sub c b\"\n  \"(a - numeral b) - numeral c = a - numeral (b + c)\"", "lemmas CLAMP_aux =\n  arith_simps numeral_assoc_simps of_nat_power of_nat_mult of_nat_numeral\n  one_add_one numeral_One [symmetric]", "lemmas CLAMP_postproc = numeral_One", "lemma master1_bigo_automation:\n  assumes \"g \\<in> O(\\<lambda>x. real x powr p')\" \"1 < (\\<Sum>i<k. as ! i * bs ! i powr p')\" \n  shows   \"f \\<in> O(MASTER_BOUND p 0 0)\"", "lemma master1_automation:\n  assumes \"g \\<in> O(MASTER_BOUND'' p')\" \"1 < (\\<Sum>i<k. as ! i * bs ! i powr p')\" \n          \"eventually (\\<lambda>x. f x > 0) at_top\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p 0 0)\"", "lemma master2_1_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND' p p')\" \"p' < -1\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p 0 0)\"", "lemma master2_2_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND' p (-1))\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p 0 1)\"", "lemma master2_3_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND' p (p' - 1))\" \"p' > 0\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p p' 0)\"", "lemma master3_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND'' p')\" \"1 > (\\<Sum>i<k. as ! i * bs ! i powr p')\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)\"", "lemmas master_automation = \n  master1_automation master2_1_automation master2_2_automation \n  master2_2_automation master3_automation"], "translations": [["", "lemma landau_symbol_ge_3_cong:\n  assumes \"landau_symbol L L' Lr\"\n  assumes \"\\<And>x::'a::linordered_semidom. x \\<ge> 3 \\<Longrightarrow> f x = g x\"\n  shows   \"L at_top (f) = L at_top (g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L at_top f = L at_top g", "apply (rule landau_symbol.cong[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. f x = g x", "apply (subst eventually_at_top_linorder, rule exI[of _ 3], simp add: assms(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exp_1_lt_3: \"exp (1::real) < 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 < 3", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. exp 1 < 3", "from Taylor_up[of 3 \"\\<lambda>_. exp\" exp 0 1 0]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < 3; exp = exp;\n   \\<forall>m t.\n      m < 3 \\<and> 0 \\<le> t \\<and> t \\<le> 1 \\<longrightarrow>\n      (exp has_real_derivative exp t) (at t);\n   0 \\<le> 0; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t>0.\n                       t < 1 \\<and>\n                       exp 1 =\n                       (\\<Sum>m<3. exp 0 / fact m * (1 - 0) ^ m) +\n                       exp t / fact 3 * (1 - 0) ^ 3", "obtain t :: real where \"t > 0\" \"t < 1\" \"exp 1 = 5/2 + exp t / 6\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 3; exp = exp;\n   \\<forall>m t.\n      m < 3 \\<and> 0 \\<le> t \\<and> t \\<le> 1 \\<longrightarrow>\n      (exp has_real_derivative exp t) (at t);\n   0 \\<le> 0; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t>0.\n                       t < 1 \\<and>\n                       exp 1 =\n                       (\\<Sum>m<3. exp 0 / fact m * (1 - 0) ^ m) +\n                       exp t / fact 3 * (1 - 0) ^ 3\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 < t; t < 1; exp 1 = 5 / 2 + exp t / 6\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eval_nat_numeral)"], ["proof (state)\nthis:\n  0 < t\n  t < 1\n  exp 1 = 5 / 2 + exp t / 6\n\ngoal (1 subgoal):\n 1. exp 1 < 3", "note this(3)"], ["proof (state)\nthis:\n  exp 1 = 5 / 2 + exp t / 6\n\ngoal (1 subgoal):\n 1. exp 1 < 3", "also"], ["proof (state)\nthis:\n  exp 1 = 5 / 2 + exp t / 6\n\ngoal (1 subgoal):\n 1. exp 1 < 3", "from \\<open>t < 1\\<close>"], ["proof (chain)\npicking this:\n  t < 1", "have \"exp t < exp 1\""], ["proof (prove)\nusing this:\n  t < 1\n\ngoal (1 subgoal):\n 1. exp t < exp 1", "by simp"], ["proof (state)\nthis:\n  exp t < exp 1\n\ngoal (1 subgoal):\n 1. exp 1 < 3", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      5 / 2 + x / 6 < 5 / 2 + y / 6) \\<Longrightarrow>\n  exp 1 < 5 / 2 + exp 1 / 6", "show \"exp (1::real) < 3\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      5 / 2 + x / 6 < 5 / 2 + y / 6) \\<Longrightarrow>\n  exp 1 < 5 / 2 + exp 1 / 6\n\ngoal (1 subgoal):\n 1. exp 1 < 3", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  exp 1 < 3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ln_ln_pos:\n  assumes \"(x::real) \\<ge> 3\"\n  shows   \"ln (ln x) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ln (ln x)", "proof (subst ln_gt_zero_iff)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ln x\n 2. 1 < ln x", "from assms exp_1_lt_3"], ["proof (chain)\npicking this:\n  3 \\<le> x\n  exp 1 < 3", "have \"ln x > ln (exp 1)\""], ["proof (prove)\nusing this:\n  3 \\<le> x\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. ln (exp 1) < ln x", "by (intro ln_mono_strict) simp_all"], ["proof (state)\nthis:\n  ln (exp 1) < ln x\n\ngoal (2 subgoals):\n 1. 0 < ln x\n 2. 1 < ln x", "thus \"ln x > 0\" \"ln x > 1\""], ["proof (prove)\nusing this:\n  ln (exp 1) < ln x\n\ngoal (1 subgoal):\n 1. 0 < ln x &&& 1 < ln x", "by simp_all"], ["proof (state)\nthis:\n  0 < ln x\n  1 < ln x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition akra_bazzi_terms where\n  \"akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts = (\\<forall>i<length bs. akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs!i) (ts!i))\""], ["", "lemma akra_bazzi_termsI:\n  \"(\\<And>i. i < length bs \\<Longrightarrow> akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs!i) (ts!i)) \\<Longrightarrow> akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length bs \\<Longrightarrow>\n        akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs ! i)\n         (ts ! i)) \\<Longrightarrow>\n    akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts", "unfolding akra_bazzi_terms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length bs \\<Longrightarrow>\n        akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs ! i)\n         (ts ! i)) \\<Longrightarrow>\n    \\<forall>i<length bs.\n       akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs ! i) (ts ! i)", "by blast"], ["", "lemma master_theorem_functionI:\n  assumes \"\\<forall>x\\<in>{x\\<^sub>0..<x\\<^sub>1}. f x \\<ge> 0\"\n  assumes \"\\<forall>x\\<ge>x\\<^sub>1. f x = g x + (\\<Sum>i<k. as ! i * f ((ts ! i) x))\"\n  assumes \"\\<forall>x\\<ge>x\\<^sub>1. g x \\<ge> 0\"\n  assumes \"\\<forall>a\\<in>set as. a \\<ge> 0\"\n  assumes \"list_ex (\\<lambda>a. a > 0) as\"\n  assumes \"\\<forall>b\\<in>set bs. b \\<in> {0<..<1}\"\n  assumes \"k \\<noteq> 0\"\n  assumes \"length as = k\"\n  assumes \"length bs = k\"\n  assumes \"length ts = k\"\n  assumes \"akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts\"\n  shows \"master_theorem_function x\\<^sub>0 x\\<^sub>1 k as bs ts f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. master_theorem_function x\\<^sub>0 x\\<^sub>1 k as bs ts f g", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x\\<^sub>0..<x\\<^sub>1}. 0 \\<le> f x\n  \\<forall>x\\<ge>x\\<^sub>1. f x = g x + (\\<Sum>i<k. as ! i * f ((ts ! i) x))\n  \\<forall>x\\<ge>x\\<^sub>1. 0 \\<le> g x\n  \\<forall>a\\<in>set as. 0 \\<le> a\n  list_ex ((<) 0) as\n  \\<forall>b\\<in>set bs. b \\<in> {0<..<1}\n  k \\<noteq> 0\n  length as = k\n  length bs = k\n  length ts = k\n  akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts\n\ngoal (1 subgoal):\n 1. master_theorem_function x\\<^sub>0 x\\<^sub>1 k as bs ts f g", "unfolding akra_bazzi_terms_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x\\<^sub>0..<x\\<^sub>1}. 0 \\<le> f x\n  \\<forall>x\\<ge>x\\<^sub>1. f x = g x + (\\<Sum>i<k. as ! i * f ((ts ! i) x))\n  \\<forall>x\\<ge>x\\<^sub>1. 0 \\<le> g x\n  \\<forall>a\\<in>set as. 0 \\<le> a\n  list_ex ((<) 0) as\n  \\<forall>b\\<in>set bs. b \\<in> {0<..<1}\n  k \\<noteq> 0\n  length as = k\n  length bs = k\n  length ts = k\n  \\<forall>i<length bs.\n     akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs ! i) (ts ! i)\n\ngoal (1 subgoal):\n 1. master_theorem_function x\\<^sub>0 x\\<^sub>1 k as bs ts f g", "by unfold_locales (auto simp: list_ex_iff)"], ["", "lemma akra_bazzi_term_measure:\n  \" x \\<ge> x\\<^sub>1 \\<Longrightarrow> akra_bazzi_term 0 x\\<^sub>1 b t \\<Longrightarrow> (t x, x) \\<in> Wellfounded.measure (\\<lambda>n::nat. n)\"\n  \" x > x\\<^sub>1 \\<Longrightarrow> akra_bazzi_term 0 (Suc x\\<^sub>1) b t \\<Longrightarrow> (t x, x) \\<in> Wellfounded.measure (\\<lambda>n::nat. n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x\\<^sub>1 \\<le> x; akra_bazzi_term 0 x\\<^sub>1 b t\\<rbrakk>\n     \\<Longrightarrow> (t x, x)\n                       \\<in> Wellfounded.measure (\\<lambda>n. n)) &&&\n    (\\<lbrakk>x\\<^sub>1 < x; akra_bazzi_term 0 (Suc x\\<^sub>1) b t\\<rbrakk>\n     \\<Longrightarrow> (t x, x) \\<in> Wellfounded.measure (\\<lambda>n. n))", "unfolding akra_bazzi_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x\\<^sub>1 \\<le> x;\n      \\<exists>e h.\n         0 < e \\<and>\n         h \\<in> O(\\<lambda>x. real x / ln (real x) powr (1 + e)) \\<and>\n         (\\<forall>x\\<ge>x\\<^sub>1.\n             0 \\<le> t x \\<and>\n             t x < x \\<and> b * real x + h x = real (t x))\\<rbrakk>\n     \\<Longrightarrow> (t x, x)\n                       \\<in> Wellfounded.measure (\\<lambda>n. n)) &&&\n    (\\<lbrakk>x\\<^sub>1 < x;\n      \\<exists>e h.\n         0 < e \\<and>\n         h \\<in> O(\\<lambda>x. real x / ln (real x) powr (1 + e)) \\<and>\n         (\\<forall>x\\<ge>Suc x\\<^sub>1.\n             0 \\<le> t x \\<and>\n             t x < x \\<and> b * real x + h x = real (t x))\\<rbrakk>\n     \\<Longrightarrow> (t x, x) \\<in> Wellfounded.measure (\\<lambda>n. n))", "by auto"], ["", "lemma measure_prod_conv: \n  \"((a, b), (c, d)) \\<in> Wellfounded.measure (\\<lambda>x. t (fst x)) \\<longleftrightarrow> (a, c) \\<in> Wellfounded.measure t\"\n  \"((e, f), (g, h)) \\<in> Wellfounded.measure (\\<lambda>x. t (snd x)) \\<longleftrightarrow> (f, h) \\<in> Wellfounded.measure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((a, b), c, d) \\<in> Wellfounded.measure (\\<lambda>x. t (fst x))) =\n    ((a, c) \\<in> Wellfounded.measure t) &&&\n    (((e, f), g, h) \\<in> Wellfounded.measure (\\<lambda>x. t (snd x))) =\n    ((f, h) \\<in> Wellfounded.measure t)", "by simp_all"], ["", "lemmas measure_prod_conv' = measure_prod_conv[where t = \"\\<lambda>x. x\"]"], ["", "lemma akra_bazzi_termination_simps:\n  fixes x :: nat\n  shows \"a * real x / b = a/b * real x\" \"real x / b = 1/b * real x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * real x / b = a / b * real x &&& real x / b = 1 / b * real x", "by simp_all"], ["", "lemma akra_bazzi_params_nonzeroI:\n  \"length as = length bs \\<Longrightarrow>  \n   (\\<forall>a\\<in>set as. a \\<ge> 0) \\<Longrightarrow> (\\<forall>b\\<in>set bs. b \\<in> {0<..<1}) \\<Longrightarrow> (\\<exists>a\\<in>set as. a > 0) \\<Longrightarrow>\n   akra_bazzi_params_nonzero (length as) as bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length as = length bs; \\<forall>a\\<in>set as. 0 \\<le> a;\n     \\<forall>b\\<in>set bs. b \\<in> {0<..<1};\n     \\<exists>a\\<in>set as. 0 < a\\<rbrakk>\n    \\<Longrightarrow> akra_bazzi_params_nonzero (length as) as bs", "by (unfold_locales, simp_all) []"], ["", "lemmas akra_bazzi_p_rel_intros = \n  akra_bazzi_params_nonzero.p_lessI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_greaterI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_leI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_geI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_boundsI[rotated, OF _ akra_bazzi_params_nonzeroI]\n  akra_bazzi_params_nonzero.p_boundsI'[rotated, OF _ akra_bazzi_params_nonzeroI]"], ["", "lemma eval_length: \"length [] = 0\" \"length (x # xs) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] = 0 &&& length (x # xs) = Suc (length xs)", "by simp_all"], ["", "lemma eval_akra_bazzi_sum:\n  \"(\\<Sum>i<0. as!i * bs!i powr x) = 0\"\n  \"(\\<Sum>i<Suc 0. (a#as)!i * (b#bs)!i powr x) = a * b powr x\"\n  \"(\\<Sum>i<Suc k. (a#as)!i * (b#bs)!i powr x) = a * b powr x + (\\<Sum>i<k. as!i * bs!i powr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<0. as ! i * bs ! i powr x) = (0::'a) &&&\n    (\\<Sum>i<Suc 0. (a # as) ! i * (b # bs) ! i powr x) = a * b powr x &&&\n    (\\<Sum>i<Suc k. (a # as) ! i * (b # bs) ! i powr x) =\n    a * b powr x + (\\<Sum>i<k. as ! i * bs ! i powr x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>i<Suc 0. (a # as) ! i * (b # bs) ! i powr x) = a * b powr x\n 2. (\\<Sum>i<Suc k. (a # as) ! i * (b # bs) ! i powr x) =\n    a * b powr x + (\\<Sum>i<k. as ! i * bs ! i powr x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc k. (a # as) ! i * (b # bs) ! i powr x) =\n    a * b powr x + (\\<Sum>i<k. as ! i * bs ! i powr x)", "apply (induction k arbitrary: a as b bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as b bs.\n       (\\<Sum>i<Suc 0. (a # as) ! i * (b # bs) ! i powr x) =\n       a * b powr x + (\\<Sum>i<0. as ! i * bs ! i powr x)\n 2. \\<And>k a as b bs.\n       (\\<And>a as b bs.\n           (\\<Sum>i<Suc k. (a # as) ! i * (b # bs) ! i powr x) =\n           a * b powr x +\n           (\\<Sum>i<k. as ! i * bs ! i powr x)) \\<Longrightarrow>\n       (\\<Sum>i<Suc (Suc k). (a # as) ! i * (b # bs) ! i powr x) =\n       a * b powr x + (\\<Sum>i<Suc k. as ! i * bs ! i powr x)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_akra_bazzi_sum':\n  \"(\\<Sum>i<0. as!i * f ((ts!i) x)) = 0\"\n  \"(\\<Sum>i<Suc 0. (a#as)!i * f (((t#ts)!i) x)) = a * f (t x)\"\n  \"(\\<Sum>i<Suc k. (a#as)!i * f (((t#ts)!i) x)) = a * f (t x) + (\\<Sum>i<k. as!i * f ((ts!i) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<0. as ! i * f ((ts ! i) x)) = (0::'a) &&&\n    (\\<Sum>i<Suc 0. (a # as) ! i * f (((t # ts) ! i) x)) = a * f (t x) &&&\n    (\\<Sum>i<Suc k. (a # as) ! i * f (((t # ts) ! i) x)) =\n    a * f (t x) + (\\<Sum>i<k. as ! i * f ((ts ! i) x))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>i<Suc 0. (a # as) ! i * f (((t # ts) ! i) x)) = a * f (t x)\n 2. (\\<Sum>i<Suc k. (a # as) ! i * f (((t # ts) ! i) x)) =\n    a * f (t x) + (\\<Sum>i<k. as ! i * f ((ts ! i) x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc k. (a # as) ! i * f (((t # ts) ! i) x)) =\n    a * f (t x) + (\\<Sum>i<k. as ! i * f ((ts ! i) x))", "apply (induction k arbitrary: a as t ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as t ts.\n       (\\<Sum>i<Suc 0. (a # as) ! i * f (((t # ts) ! i) x)) =\n       a * f (t x) + (\\<Sum>i<0. as ! i * f ((ts ! i) x))\n 2. \\<And>k a as t ts.\n       (\\<And>a as t ts.\n           (\\<Sum>i<Suc k. (a # as) ! i * f (((t # ts) ! i) x)) =\n           a * f (t x) +\n           (\\<Sum>i<k. as ! i * f ((ts ! i) x))) \\<Longrightarrow>\n       (\\<Sum>i<Suc (Suc k). (a # as) ! i * f (((t # ts) ! i) x)) =\n       a * f (t x) + (\\<Sum>i<Suc k. as ! i * f ((ts ! i) x))", "apply (simp_all add: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma akra_bazzi_termsI':\n  \"akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 [] []\"\n  \"akra_bazzi_term x\\<^sub>0 x\\<^sub>1 b t \\<Longrightarrow> akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts \\<Longrightarrow> akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 (b#bs) (t#ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 [] [] &&&\n    (\\<lbrakk>akra_bazzi_term x\\<^sub>0 x\\<^sub>1 b t;\n      akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 bs ts\\<rbrakk>\n     \\<Longrightarrow> akra_bazzi_terms x\\<^sub>0 x\\<^sub>1 (b # bs)\n                        (t # ts))", "unfolding akra_bazzi_terms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length [].\n       akra_bazzi_term x\\<^sub>0 x\\<^sub>1 ([] ! i) ([] ! i) &&&\n    (\\<lbrakk>akra_bazzi_term x\\<^sub>0 x\\<^sub>1 b t;\n      \\<forall>i<length bs.\n         akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs ! i) (ts ! i)\\<rbrakk>\n     \\<Longrightarrow> \\<forall>i<length (b # bs).\n                          akra_bazzi_term x\\<^sub>0 x\\<^sub>1 ((b # bs) ! i)\n                           ((t # ts) ! i))", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length [].\n       akra_bazzi_term x\\<^sub>0 x\\<^sub>1 ([] ! i) ([] ! i) &&&\n    (\\<lbrakk>akra_bazzi_term x\\<^sub>0 x\\<^sub>1 b t;\n      \\<forall>i<length bs.\n         akra_bazzi_term x\\<^sub>0 x\\<^sub>1 (bs ! i) (ts ! i)\\<rbrakk>\n     \\<Longrightarrow> \\<forall>i<length (b # bs).\n                          akra_bazzi_term x\\<^sub>0 x\\<^sub>1 ((b # bs) ! i)\n                           ((t # ts) ! i))", "by auto"], ["", "lemma ball_set_intros: \"(\\<forall>x\\<in>set []. P x)\" \"P x \\<Longrightarrow> (\\<forall>x\\<in>set xs. P x) \\<Longrightarrow> (\\<forall>x\\<in>set (x#xs). P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set []. P x &&&\n    (\\<lbrakk>P x; \\<forall>x\\<in>set xs. P x\\<rbrakk>\n     \\<Longrightarrow> \\<forall>x\\<in>set (x # xs). P x)", "by auto"], ["", "lemma ball_set_simps: \"(\\<forall>x\\<in>set []. P x) = True\" \"(\\<forall>x\\<in>set (x#xs). P x) = (P x \\<and> (\\<forall>x\\<in>set xs. P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set []. P x) = True &&&\n    (\\<forall>x\\<in>set (x # xs). P x) =\n    (P x \\<and> (\\<forall>x\\<in>set xs. P x))", "by auto"], ["", "lemma bex_set_simps: \"(\\<exists>x\\<in>set []. P x) = False\" \"(\\<exists>x\\<in>set (x#xs). P x) = (P x \\<or> (\\<exists>x\\<in>set xs. P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>set []. P x) = False &&&\n    (\\<exists>x\\<in>set (x # xs). P x) =\n    (P x \\<or> (\\<exists>x\\<in>set xs. P x))", "by auto"], ["", "lemma eval_akra_bazzi_le_list_ex:\n  \"list_ex P (x#y#xs) \\<longleftrightarrow> P x \\<or> list_ex P (y#xs)\"\n  \"list_ex P [x] \\<longleftrightarrow> P x\"\n  \"list_ex P [] \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex P (x # y # xs) = (P x \\<or> list_ex P (y # xs)) &&&\n    list_ex P [x] = P x &&& list_ex P [] = False", "by (auto simp: list_ex_iff)"], ["", "lemma eval_akra_bazzi_le_sum_list:\n  \"x \\<le> sum_list [] \\<longleftrightarrow> x \\<le> 0\" \"x \\<le> sum_list (y#ys) \\<longleftrightarrow> x \\<le> y + sum_list ys\"\n  \"x \\<le> z + sum_list [] \\<longleftrightarrow> x \\<le> z\" \"x \\<le> z + sum_list (y#ys) \\<longleftrightarrow> x \\<le> z + y + sum_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x \\<le> sum_list []) = (x \\<le> (0::'a)) &&&\n     (x \\<le> sum_list (y # ys)) = (x \\<le> y + sum_list ys)) &&&\n    (x \\<le> z + sum_list []) = (x \\<le> z) &&&\n    (x \\<le> z + sum_list (y # ys)) = (x \\<le> z + y + sum_list ys)", "by (simp_all add: algebra_simps)"], ["", "lemma atLeastLessThanE: \"x \\<in> {a..<b} \\<Longrightarrow> (x \\<ge> a \\<Longrightarrow> x < b \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {a..<b};\n     \\<lbrakk>a \\<le> x; x < b\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by simp"], ["", "lemma master_theorem_preprocess:\n  \"\\<Theta>(\\<lambda>n::nat. 1) = \\<Theta>(\\<lambda>n::nat. real n powr 0)\"\n  \"\\<Theta>(\\<lambda>n::nat. real n) = \\<Theta>(\\<lambda>n::nat. real n powr 1)\"\n  \"O(\\<lambda>n::nat. 1) = O(\\<lambda>n::nat. real n powr 0)\"\n  \"O(\\<lambda>n::nat. real n) = O(\\<lambda>n::nat. real n powr 1)\"\n\n  \"\\<Theta>(\\<lambda>n::nat. ln (ln (real n))) = \\<Theta>(\\<lambda>n::nat. real n powr 0 * ln (ln (real n)))\"\n  \"\\<Theta>(\\<lambda>n::nat. real n * ln (ln (real n))) = \\<Theta>(\\<lambda>n::nat. real n powr 1 * ln (ln (real n)))\"\n\n  \"\\<Theta>(\\<lambda>n::nat. ln (real n)) = \\<Theta>(\\<lambda>n::nat. real n powr 0 * ln (real n) powr 1)\"\n  \"\\<Theta>(\\<lambda>n::nat. real n * ln (real n)) = \\<Theta>(\\<lambda>n::nat. real n powr 1 * ln (real n) powr 1)\"\n  \"\\<Theta>(\\<lambda>n::nat. real n powr p * ln (real n)) = \\<Theta>(\\<lambda>n::nat. real n powr p * ln (real n) powr 1)\"\n  \"\\<Theta>(\\<lambda>n::nat. ln (real n) powr p') = \\<Theta>(\\<lambda>n::nat. real n powr 0 * ln (real n) powr p')\"\n  \"\\<Theta>(\\<lambda>n::nat. real n * ln (real n) powr p') = \\<Theta>(\\<lambda>n::nat. real n powr 1 * ln (real n) powr p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Theta>(\\<lambda>n. 1) = \\<Theta>(\\<lambda>n. real n powr 0) &&&\n      \\<Theta>(real) = \\<Theta>(\\<lambda>n. real n powr 1)) &&&\n     O(\\<lambda>n. 1) = O(\\<lambda>n. real n powr 0) &&&\n     O(real) = O(\\<lambda>n. real n powr 1) &&&\n     \\<Theta>(\\<lambda>n. ln (ln (real n))) =\n     \\<Theta>(\\<lambda>n. real n powr 0 * ln (ln (real n)))) &&&\n    (\\<Theta>(\\<lambda>n. real n * ln (ln (real n))) =\n     \\<Theta>(\\<lambda>n. real n powr 1 * ln (ln (real n))) &&&\n     \\<Theta>(\\<lambda>n. ln (real n)) =\n     \\<Theta>(\\<lambda>n. real n powr 0 * ln (real n) powr 1) &&&\n     \\<Theta>(\\<lambda>n. real n * ln (real n)) =\n     \\<Theta>(\\<lambda>n. real n powr 1 * ln (real n) powr 1)) &&&\n    \\<Theta>(\\<lambda>n. real n powr p * ln (real n)) =\n    \\<Theta>(\\<lambda>n. real n powr p * ln (real n) powr 1) &&&\n    \\<Theta>(\\<lambda>n. ln (real n) powr p') =\n    \\<Theta>(\\<lambda>n. real n powr 0 * ln (real n) powr p') &&&\n    \\<Theta>(\\<lambda>n. real n * ln (real n) powr p') =\n    \\<Theta>(\\<lambda>n. real n powr 1 * ln (real n) powr p')", "apply (simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<Theta>(\\<lambda>n. ln (real n)) =\n    \\<Theta>(\\<lambda>x. ln (real x) powr 1)\n 2. \\<Theta>(\\<lambda>n. real n * ln (real n)) =\n    \\<Theta>(\\<lambda>n. real n * ln (real n) powr 1)\n 3. \\<Theta>(\\<lambda>n. real n powr p * ln (real n)) =\n    \\<Theta>(\\<lambda>n. real n powr p * ln (real n) powr 1)", "apply (simp_all cong: landau_symbols[THEN landau_symbol_ge_3_cong])?"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma akra_bazzi_term_imp_size_less:\n  \"x\\<^sub>1 \\<le> x \\<Longrightarrow> akra_bazzi_term 0 x\\<^sub>1 b t \\<Longrightarrow> size (t x) < size x\" \n  \"x\\<^sub>1 < x \\<Longrightarrow> akra_bazzi_term 0 (Suc x\\<^sub>1) b t \\<Longrightarrow> size (t x) < size x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x\\<^sub>1 \\<le> x; akra_bazzi_term 0 x\\<^sub>1 b t\\<rbrakk>\n     \\<Longrightarrow> size (t x) < size x) &&&\n    (\\<lbrakk>x\\<^sub>1 < x; akra_bazzi_term 0 (Suc x\\<^sub>1) b t\\<rbrakk>\n     \\<Longrightarrow> size (t x) < size x)", "by (simp_all add: akra_bazzi_term_imp_less)"], ["", "definition \"CLAMP (f :: nat \\<Rightarrow> real) x = (if x < 3 then 0 else f x)\""], ["", "definition \"CLAMP' (f :: nat \\<Rightarrow> real) x = (if x < 3 then 0 else f x)\""], ["", "definition \"MASTER_BOUND a b c x = real x powr a * ln (real x) powr b * ln (ln (real x)) powr c\""], ["", "definition \"MASTER_BOUND' a b x = real x powr a * ln (real x) powr b\""], ["", "definition \"MASTER_BOUND'' a x = real x powr a\""], ["", "lemma ln_1_imp_less_3:\n  \"ln x = (1::real) \\<Longrightarrow> x < 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "assume \"ln x = 1\""], ["proof (state)\nthis:\n  ln x = 1\n\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "also"], ["proof (state)\nthis:\n  ln x = 1\n\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "have \"(1::real) \\<le> ln (exp 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> ln (exp 1)", "by simp"], ["proof (state)\nthis:\n  1 \\<le> ln (exp 1)\n\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "finally"], ["proof (chain)\npicking this:\n  ln x \\<le> ln (exp 1)", "have \"ln x \\<le> ln (exp 1)\""], ["proof (prove)\nusing this:\n  ln x \\<le> ln (exp 1)\n\ngoal (1 subgoal):\n 1. ln x \\<le> ln (exp 1)", "by simp"], ["proof (state)\nthis:\n  ln x \\<le> ln (exp 1)\n\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "hence \"x \\<le> exp 1\""], ["proof (prove)\nusing this:\n  ln x \\<le> ln (exp 1)\n\ngoal (1 subgoal):\n 1. x \\<le> exp 1", "by (cases \"x > 0\") (force simp del: ln_exp simp add: not_less intro: order.trans)+"], ["proof (state)\nthis:\n  x \\<le> exp 1\n\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "also"], ["proof (state)\nthis:\n  x \\<le> exp 1\n\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "have \"... < 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 < 3", "by (rule exp_1_lt_3)"], ["proof (state)\nthis:\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. ln x = 1 \\<Longrightarrow> x < 3", "finally"], ["proof (chain)\npicking this:\n  x < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  x < 3\n\ngoal (1 subgoal):\n 1. x < 3", "."], ["proof (state)\nthis:\n  x < 3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ln_1_imp_less_3': \"ln (real (x::nat)) = 1 \\<Longrightarrow> x < 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (real x) = 1 \\<Longrightarrow> x < 3", "by (drule ln_1_imp_less_3) simp"], ["", "lemma ln_ln_nonneg: \"x \\<ge> (3::real) \\<Longrightarrow> ln (ln x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> x \\<Longrightarrow> 0 \\<le> ln (ln x)", "using ln_ln_pos[of \"x\"]"], ["proof (prove)\nusing this:\n  3 \\<le> x \\<Longrightarrow> 0 < ln (ln x)\n\ngoal (1 subgoal):\n 1. 3 \\<le> x \\<Longrightarrow> 0 \\<le> ln (ln x)", "by simp"], ["", "lemma ln_ln_nonneg': \"x \\<ge> (3::nat) \\<Longrightarrow> ln (ln (real x)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> x \\<Longrightarrow> 0 \\<le> ln (ln (real x))", "using ln_ln_pos[of \"real x\"]"], ["proof (prove)\nusing this:\n  3 \\<le> real x \\<Longrightarrow> 0 < ln (ln (real x))\n\ngoal (1 subgoal):\n 1. 3 \\<le> x \\<Longrightarrow> 0 \\<le> ln (ln (real x))", "by simp"], ["", "lemma MASTER_BOUND_postproc:\n  \"CLAMP (MASTER_BOUND' a 0) = CLAMP (MASTER_BOUND'' a)\"\n  \"CLAMP (MASTER_BOUND' a 1) = CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x * CLAMP (\\<lambda>x. ln (real x)) x)\"\n  \"CLAMP (MASTER_BOUND' a (numeral n)) = \n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x * CLAMP (\\<lambda>x. ln (real x) ^ numeral n) x)\"\n  \"CLAMP (MASTER_BOUND' a (-1)) =\n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x / CLAMP (\\<lambda>x. ln (real x)) x)\"\n  \"CLAMP (MASTER_BOUND' a (-numeral n)) = \n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x / CLAMP (\\<lambda>x. ln (real x) ^ numeral n) x)\"\n  \"CLAMP (MASTER_BOUND' a b) = \n       CLAMP (\\<lambda>x. CLAMP (MASTER_BOUND'' a) x * CLAMP (\\<lambda>x. ln (real x) powr b) x)\"\n\n  \"CLAMP (MASTER_BOUND'' 0) = CLAMP (\\<lambda>x. 1)\"\n  \"CLAMP (MASTER_BOUND'' 1) = CLAMP (\\<lambda>x. (real x))\"\n  \"CLAMP (MASTER_BOUND'' (numeral n)) = CLAMP (\\<lambda>x. (real x) ^ numeral n)\"\n  \"CLAMP (MASTER_BOUND'' (-1)) = CLAMP (\\<lambda>x. 1 / (real x))\"\n  \"CLAMP (MASTER_BOUND'' (-numeral n)) = CLAMP (\\<lambda>x. 1 / (real x) ^ numeral n)\"\n  \"CLAMP (MASTER_BOUND'' a) = CLAMP (\\<lambda>x. (real x) powr a)\"\n\n  and MASTER_BOUND_UNCLAMP:\n  \"CLAMP (\\<lambda>x. CLAMP f x * CLAMP g x) = CLAMP (\\<lambda>x. f x * g x)\"\n  \"CLAMP (\\<lambda>x. CLAMP f x / CLAMP g x) = CLAMP (\\<lambda>x. f x / g x)\"\n  \"CLAMP (CLAMP f) = CLAMP f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((CLAMP (MASTER_BOUND' a 0) = CLAMP (MASTER_BOUND'' a) &&&\n       CLAMP (MASTER_BOUND' a 1) =\n       CLAMP\n        (\\<lambda>x.\n            CLAMP (MASTER_BOUND'' a) x *\n            CLAMP (\\<lambda>x. ln (real x)) x) &&&\n       CLAMP (MASTER_BOUND' a (numeral n)) =\n       CLAMP\n        (\\<lambda>x.\n            CLAMP (MASTER_BOUND'' a) x *\n            CLAMP (\\<lambda>x. ln (real x) ^ numeral n) x)) &&&\n      CLAMP (MASTER_BOUND' a (- 1)) =\n      CLAMP\n       (\\<lambda>x.\n           CLAMP (MASTER_BOUND'' a) x /\n           CLAMP (\\<lambda>x. ln (real x)) x) &&&\n      CLAMP (MASTER_BOUND' a (- numeral n)) =\n      CLAMP\n       (\\<lambda>x.\n           CLAMP (MASTER_BOUND'' a) x /\n           CLAMP (\\<lambda>x. ln (real x) ^ numeral n) x) &&&\n      CLAMP (MASTER_BOUND' a b) =\n      CLAMP\n       (\\<lambda>x.\n           CLAMP (MASTER_BOUND'' a) x *\n           CLAMP (\\<lambda>x. ln (real x) powr b) x)) &&&\n     (CLAMP (MASTER_BOUND'' 0) = CLAMP (\\<lambda>x. 1) &&&\n      CLAMP (MASTER_BOUND'' 1) = CLAMP real &&&\n      CLAMP (MASTER_BOUND'' (numeral n)) =\n      CLAMP (\\<lambda>x. real x ^ numeral n)) &&&\n     CLAMP (MASTER_BOUND'' (- 1)) = CLAMP (\\<lambda>x. 1 / real x) &&&\n     CLAMP (MASTER_BOUND'' (- numeral n)) =\n     CLAMP (\\<lambda>x. 1 / real x ^ numeral n) &&&\n     CLAMP (MASTER_BOUND'' a) = CLAMP (\\<lambda>x. real x powr a)) &&&\n    CLAMP (\\<lambda>x. CLAMP f x * CLAMP g x) =\n    CLAMP (\\<lambda>x. f x * g x) &&&\n    CLAMP (\\<lambda>x. CLAMP f x / CLAMP g x) =\n    CLAMP (\\<lambda>x. f x / g x) &&&\n    CLAMP (CLAMP f) = CLAMP f", "unfolding CLAMP_def[abs_def] MASTER_BOUND'_def[abs_def] MASTER_BOUND''_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<lambda>x.\n           if x < 3 then 0 else real x powr a * ln (real x) powr 0) =\n       (\\<lambda>x. if x < 3 then 0 else real x powr a) &&&\n       (\\<lambda>x.\n           if x < 3 then 0 else real x powr a * ln (real x) powr 1) =\n       (\\<lambda>x.\n           if x < 3 then 0\n           else (if x < 3 then 0 else real x powr a) *\n                (if x < 3 then 0 else ln (real x))) &&&\n       (\\<lambda>x.\n           if x < 3 then 0\n           else real x powr a * ln (real x) powr numeral n) =\n       (\\<lambda>x.\n           if x < 3 then 0\n           else (if x < 3 then 0 else real x powr a) *\n                (if x < 3 then 0 else ln (real x) ^ numeral n))) &&&\n      (\\<lambda>x.\n          if x < 3 then 0 else real x powr a * ln (real x) powr - 1) =\n      (\\<lambda>x.\n          if x < 3 then 0\n          else (if x < 3 then 0 else real x powr a) /\n               (if x < 3 then 0 else ln (real x))) &&&\n      (\\<lambda>x.\n          if x < 3 then 0\n          else real x powr a * ln (real x) powr - numeral n) =\n      (\\<lambda>x.\n          if x < 3 then 0\n          else (if x < 3 then 0 else real x powr a) /\n               (if x < 3 then 0 else ln (real x) ^ numeral n)) &&&\n      (\\<lambda>x.\n          if x < 3 then 0 else real x powr a * ln (real x) powr b) =\n      (\\<lambda>x.\n          if x < 3 then 0\n          else (if x < 3 then 0 else real x powr a) *\n               (if x < 3 then 0 else ln (real x) powr b))) &&&\n     ((\\<lambda>x. if x < 3 then 0 else real x powr 0) =\n      (\\<lambda>x. if x < 3 then 0 else 1) &&&\n      (\\<lambda>x. if x < 3 then 0 else real x powr 1) =\n      (\\<lambda>x. if x < 3 then 0 else real x) &&&\n      (\\<lambda>x. if x < 3 then 0 else real x powr numeral n) =\n      (\\<lambda>x. if x < 3 then 0 else real x ^ numeral n)) &&&\n     (\\<lambda>x. if x < 3 then 0 else real x powr - 1) =\n     (\\<lambda>x. if x < 3 then 0 else 1 / real x) &&&\n     (\\<lambda>x. if x < 3 then 0 else real x powr - numeral n) =\n     (\\<lambda>x. if x < 3 then 0 else 1 / real x ^ numeral n) &&&\n     (\\<lambda>x. if x < 3 then 0 else real x powr a) =\n     (\\<lambda>x. if x < 3 then 0 else real x powr a)) &&&\n    (\\<lambda>x.\n        if x < 3 then 0\n        else (if x < 3 then 0 else f x) * (if x < 3 then 0 else g x)) =\n    (\\<lambda>x. if x < 3 then 0 else f x * g x) &&&\n    (\\<lambda>x.\n        if x < 3 then 0\n        else (if x < 3 then 0 else f x) / (if x < 3 then 0 else g x)) =\n    (\\<lambda>x. if x < 3 then 0 else f x / g x) &&&\n    (\\<lambda>x. if x < 3 then 0 else if x < 3 then 0 else f x) =\n    (\\<lambda>x. if x < 3 then 0 else f x)", "by (simp_all add: powr_minus divide_inverse fun_eq_iff)"], ["", "context\nbegin"], ["", "private"], ["", "lemma CLAMP_: \n  \"landau_symbol L L' Lr \\<Longrightarrow> L at_top (f::nat \\<Rightarrow> real) \\<equiv> L at_top (\\<lambda>x. CLAMP f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr \\<Longrightarrow>\n    L sequentially f \\<equiv> L sequentially (CLAMP f)", "unfolding CLAMP_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr \\<Longrightarrow>\n    L sequentially f \\<equiv>\n    L sequentially (\\<lambda>x. if x < 3 then 0 else f x)", "by (intro landau_symbol.cong eq_reflection) \n     (auto intro: eventually_mono[OF eventually_ge_at_top[of \"3::nat\"]])"], ["", "private"], ["", "lemma UNCLAMP'_: \n  \"landau_symbol L L' Lr \\<Longrightarrow> L at_top (CLAMP' (MASTER_BOUND a b c)) \\<equiv> L at_top (MASTER_BOUND a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr \\<Longrightarrow>\n    L sequentially (CLAMP' (MASTER_BOUND a b c)) \\<equiv>\n    L sequentially (MASTER_BOUND a b c)", "unfolding CLAMP'_def[abs_def] CLAMP_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr \\<Longrightarrow>\n    L sequentially\n     (\\<lambda>x. if x < 3 then 0 else MASTER_BOUND a b c x) \\<equiv>\n    L sequentially (MASTER_BOUND a b c)", "by (intro landau_symbol.cong eq_reflection) \n     (auto intro: eventually_mono[OF eventually_ge_at_top[of \"3::nat\"]])"], ["", "private"], ["", "lemma UNCLAMP_: \n  \"landau_symbol L L' Lr \\<Longrightarrow> L at_top (CLAMP f) \\<equiv> L at_top (f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr \\<Longrightarrow>\n    L sequentially (CLAMP f) \\<equiv> L sequentially f", "using eventually_ge_at_top[of \"3::nat\"]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) 3) sequentially\n\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr \\<Longrightarrow>\n    L sequentially (CLAMP f) \\<equiv> L sequentially f", "unfolding CLAMP'_def[abs_def] CLAMP_def[abs_def]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) 3) sequentially\n\ngoal (1 subgoal):\n 1. landau_symbol L L' Lr \\<Longrightarrow>\n    L sequentially (\\<lambda>x. if x < 3 then 0 else f x) \\<equiv>\n    L sequentially f", "by (intro landau_symbol.cong eq_reflection) \n     (auto intro: eventually_mono[OF eventually_ge_at_top[of \"3::nat\"]])"], ["", "lemmas CLAMP = landau_symbols[THEN CLAMP_]"], ["", "lemmas UNCLAMP' = landau_symbols[THEN UNCLAMP'_]"], ["", "lemmas UNCLAMP = landau_symbols[THEN UNCLAMP_]"], ["", "end"], ["", "lemma propagate_CLAMP:\n  \"CLAMP (\\<lambda>x. f x * g x) = CLAMP' (\\<lambda>x. CLAMP f x * CLAMP g x)\"\n  \"CLAMP (\\<lambda>x. f x / g x) = CLAMP' (\\<lambda>x. CLAMP f x / CLAMP g x)\"\n  \"CLAMP (\\<lambda>x. inverse (f x)) = CLAMP' (\\<lambda>x. inverse (CLAMP f x))\"\n  \"CLAMP (\\<lambda>x. real x) = CLAMP' (MASTER_BOUND 1 0 0)\"\n  \"CLAMP (\\<lambda>x. real x powr a) = CLAMP' (MASTER_BOUND a 0 0)\"\n  \"CLAMP (\\<lambda>x. real x ^ a') = CLAMP' (MASTER_BOUND (real a') 0 0)\"\n  \"CLAMP (\\<lambda>x. ln (real x)) = CLAMP' (MASTER_BOUND 0 1 0)\"\n  \"CLAMP (\\<lambda>x. ln (real x) powr b) = CLAMP' (MASTER_BOUND 0 b 0)\"\n  \"CLAMP (\\<lambda>x. ln (real x) ^ b') = CLAMP' (MASTER_BOUND 0 (real b') 0)\"\n  \"CLAMP (\\<lambda>x. ln (ln (real x))) = CLAMP' (MASTER_BOUND 0 0 1)\"\n  \"CLAMP (\\<lambda>x. ln (ln (real x)) powr c) = CLAMP' (MASTER_BOUND 0 0 c)\"\n  \"CLAMP (\\<lambda>x. ln (ln (real x)) ^ c') = CLAMP' (MASTER_BOUND 0 0 (real c'))\"\n  \"CLAMP' (CLAMP f) = CLAMP' f\"\n  \"CLAMP' (\\<lambda>x. CLAMP' (MASTER_BOUND a1 b1 c1) x * CLAMP' (MASTER_BOUND a2 b2 c2) x) = \n       CLAMP' (MASTER_BOUND (a1+a2) (b1+b2) (c1+c2))\"\n  \"CLAMP' (\\<lambda>x. CLAMP' (MASTER_BOUND a1 b1 c1) x / CLAMP' (MASTER_BOUND a2 b2 c2) x) = \n       CLAMP' (MASTER_BOUND (a1-a2) (b1-b2) (c1-c2))\"\n  \"CLAMP' (\\<lambda>x. inverse (MASTER_BOUND a1 b1 c1 x)) = CLAMP' (MASTER_BOUND (-a1) (-b1) (-c1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((CLAMP (\\<lambda>x. f x * g x) =\n       CLAMP' (\\<lambda>x. CLAMP f x * CLAMP g x) &&&\n       CLAMP (\\<lambda>x. f x / g x) =\n       CLAMP' (\\<lambda>x. CLAMP f x / CLAMP g x)) &&&\n      CLAMP (\\<lambda>x. inverse (f x)) =\n      CLAMP' (\\<lambda>x. inverse (CLAMP f x)) &&&\n      CLAMP real = CLAMP' (MASTER_BOUND 1 0 0)) &&&\n     (CLAMP (\\<lambda>x. real x powr a) = CLAMP' (MASTER_BOUND a 0 0) &&&\n      CLAMP (\\<lambda>x. real x ^ a') =\n      CLAMP' (MASTER_BOUND (real a') 0 0)) &&&\n     CLAMP (\\<lambda>x. ln (real x)) = CLAMP' (MASTER_BOUND 0 1 0) &&&\n     CLAMP (\\<lambda>x. ln (real x) powr b) =\n     CLAMP' (MASTER_BOUND 0 b 0)) &&&\n    ((CLAMP (\\<lambda>x. ln (real x) ^ b') =\n      CLAMP' (MASTER_BOUND 0 (real b') 0) &&&\n      CLAMP (\\<lambda>x. ln (ln (real x))) =\n      CLAMP' (MASTER_BOUND 0 0 1)) &&&\n     CLAMP (\\<lambda>x. ln (ln (real x)) powr c) =\n     CLAMP' (MASTER_BOUND 0 0 c) &&&\n     CLAMP (\\<lambda>x. ln (ln (real x)) ^ c') =\n     CLAMP' (MASTER_BOUND 0 0 (real c'))) &&&\n    (CLAMP' (CLAMP f) = CLAMP' f &&&\n     CLAMP'\n      (\\<lambda>x.\n          CLAMP' (MASTER_BOUND a1 b1 c1) x *\n          CLAMP' (MASTER_BOUND a2 b2 c2) x) =\n     CLAMP' (MASTER_BOUND (a1 + a2) (b1 + b2) (c1 + c2))) &&&\n    CLAMP'\n     (\\<lambda>x.\n         CLAMP' (MASTER_BOUND a1 b1 c1) x /\n         CLAMP' (MASTER_BOUND a2 b2 c2) x) =\n    CLAMP' (MASTER_BOUND (a1 - a2) (b1 - b2) (c1 - c2)) &&&\n    CLAMP' (\\<lambda>x. inverse (MASTER_BOUND a1 b1 c1 x)) =\n    CLAMP' (MASTER_BOUND (- a1) (- b1) (- c1))", "by (insert ln_1_imp_less_3')\n   (rule ext, simp add: CLAMP_def CLAMP'_def MASTER_BOUND_def \n      powr_realpow powr_one[OF ln_ln_nonneg'] powr_realpow[OF ln_ln_pos] powr_add\n      powr_diff powr_minus)+"], ["", "lemma numeral_assoc_simps:\n  \"((a::real) + numeral b) + numeral c = a + numeral (b + c)\"\n  \"(a + numeral b) - numeral c = a + neg_numeral_class.sub b c\"\n  \"(a - numeral b) + numeral c = a + neg_numeral_class.sub c b\"\n  \"(a - numeral b) - numeral c = a - numeral (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + numeral b + numeral c = a + numeral (b + c) &&&\n     a + numeral b - numeral c = a + neg_numeral_class.sub b c) &&&\n    a - numeral b + numeral c = a + neg_numeral_class.sub c b &&&\n    a - numeral b - numeral c = a - numeral (b + c)", "by simp_all"], ["", "lemmas CLAMP_aux =\n  arith_simps numeral_assoc_simps of_nat_power of_nat_mult of_nat_numeral\n  one_add_one numeral_One [symmetric]"], ["", "lemmas CLAMP_postproc = numeral_One"], ["", "context master_theorem_function\nbegin"], ["", "lemma master1_bigo_automation:\n  assumes \"g \\<in> O(\\<lambda>x. real x powr p')\" \"1 < (\\<Sum>i<k. as ! i * bs ! i powr p')\" \n  shows   \"f \\<in> O(MASTER_BOUND p 0 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> O(MASTER_BOUND p 0 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> O(MASTER_BOUND p 0 0)", "have \"MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x::nat. x powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "unfolding MASTER_BOUND_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p * ln (real x) powr 0 * ln (ln (real x)) powr 0)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "by (intro landau_real_nat_transfer bigthetaI_cong \n          eventually_mono[OF eventually_ge_at_top[of \"3::real\"]]) (auto dest!: ln_1_imp_less_3)"], ["proof (state)\nthis:\n  MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p)\n\ngoal (1 subgoal):\n 1. f \\<in> O(MASTER_BOUND p 0 0)", "from landau_o.big.cong_bigtheta[OF this] master1_bigo[OF assms]"], ["proof (chain)\npicking this:\n  O(MASTER_BOUND p 0 0) = O(\\<lambda>x. real x powr p)\n  f \\<in> O(\\<lambda>x. real x powr p)", "show ?thesis"], ["proof (prove)\nusing this:\n  O(MASTER_BOUND p 0 0) = O(\\<lambda>x. real x powr p)\n  f \\<in> O(\\<lambda>x. real x powr p)\n\ngoal (1 subgoal):\n 1. f \\<in> O(MASTER_BOUND p 0 0)", "by simp"], ["proof (state)\nthis:\n  f \\<in> O(MASTER_BOUND p 0 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma master1_automation:\n  assumes \"g \\<in> O(MASTER_BOUND'' p')\" \"1 < (\\<Sum>i<k. as ! i * bs ! i powr p')\" \n          \"eventually (\\<lambda>x. f x > 0) at_top\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p 0 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "have A: \"MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x::nat. x powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "unfolding MASTER_BOUND_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p * ln (real x) powr 0 * ln (ln (real x)) powr 0)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "by (intro landau_real_nat_transfer bigthetaI_cong \n      eventually_mono[OF eventually_ge_at_top[of \"3::real\"]]) (auto dest!: ln_1_imp_less_3)"], ["proof (state)\nthis:\n  MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "have B: \"O(MASTER_BOUND'' p') = O(\\<lambda>x::nat. real x powr p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. O(MASTER_BOUND'' p') = O(\\<lambda>x. real x powr p')", "using eventually_ge_at_top[of \"2::nat\"]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) 2) sequentially\n\ngoal (1 subgoal):\n 1. O(MASTER_BOUND'' p') = O(\\<lambda>x. real x powr p')", "by (intro landau_o.big.cong) (auto elim!: eventually_mono simp: MASTER_BOUND''_def)"], ["proof (state)\nthis:\n  O(MASTER_BOUND'' p') = O(\\<lambda>x. real x powr p')\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "from landau_theta.cong_bigtheta[OF A] B assms(1) master1[OF _ assms(2-)]"], ["proof (chain)\npicking this:\n  \\<Theta>(MASTER_BOUND p 0 0) = \\<Theta>(\\<lambda>x. real x powr p)\n  O(MASTER_BOUND'' p') = O(\\<lambda>x. real x powr p')\n  g \\<in> O(MASTER_BOUND'' p')\n  g \\<in> O(\\<lambda>x. real x powr p') \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>(MASTER_BOUND p 0 0) = \\<Theta>(\\<lambda>x. real x powr p)\n  O(MASTER_BOUND'' p') = O(\\<lambda>x. real x powr p')\n  g \\<in> O(MASTER_BOUND'' p')\n  g \\<in> O(\\<lambda>x. real x powr p') \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "by simp"], ["proof (state)\nthis:\n  f \\<in> \\<Theta>(MASTER_BOUND p 0 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma master2_1_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND' p p')\" \"p' < -1\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p 0 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "have A: \"MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x::nat. x powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "unfolding MASTER_BOUND_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p * ln (real x) powr 0 * ln (ln (real x)) powr 0)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "by (intro landau_real_nat_transfer bigthetaI_cong \n          eventually_mono[OF eventually_ge_at_top[of \"3::real\"]]) (auto dest!: ln_1_imp_less_3)"], ["proof (state)\nthis:\n  MASTER_BOUND p 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "have B: \"\\<Theta>(MASTER_BOUND' p p') = \\<Theta>(\\<lambda>x::nat. real x powr p * ln (real x) powr p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(MASTER_BOUND' p p') =\n    \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')", "by (subst CLAMP, (subst MASTER_BOUND_postproc MASTER_BOUND_UNCLAMP)+, simp only: UNCLAMP)"], ["proof (state)\nthis:\n  \\<Theta>(MASTER_BOUND' p p') =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "from landau_theta.cong_bigtheta[OF A] B assms(1) master2_1[OF _ assms(2-)]"], ["proof (chain)\npicking this:\n  \\<Theta>(MASTER_BOUND p 0 0) = \\<Theta>(\\<lambda>x. real x powr p)\n  \\<Theta>(MASTER_BOUND' p p') =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')\n  g \\<in> \\<Theta>(MASTER_BOUND' p p')\n  g \\<in> \\<Theta>(\\<lambda>x.\n                      real x powr p * ln (real x) powr p') \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>(MASTER_BOUND p 0 0) = \\<Theta>(\\<lambda>x. real x powr p)\n  \\<Theta>(MASTER_BOUND' p p') =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')\n  g \\<in> \\<Theta>(MASTER_BOUND' p p')\n  g \\<in> \\<Theta>(\\<lambda>x.\n                      real x powr p * ln (real x) powr p') \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 0)", "by simp"], ["proof (state)\nthis:\n  f \\<in> \\<Theta>(MASTER_BOUND p 0 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma master2_2_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND' p (-1))\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p 0 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 1)", "have A: \"MASTER_BOUND p 0 1 \\<in> \\<Theta>(\\<lambda>x::nat. x powr p * ln (ln x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MASTER_BOUND p 0 1\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))", "unfolding MASTER_BOUND_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p * ln (real x) powr 0 * ln (ln (real x)) powr 1)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))", "using eventually_ge_at_top[of \"3::real\"]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) 3) at_top\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p * ln (real x) powr 0 * ln (ln (real x)) powr 1)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))", "apply (intro landau_real_nat_transfer, intro bigthetaI_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eventually ((\\<le>) 3) at_top;\n     eventually ((\\<le>) 3) at_top\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_top.\n                         x powr p * ln x powr 0 * ln (ln x) powr 1 =\n                         x powr p * ln (ln x)", "apply (elim eventually_mono, subst powr_one[OF ln_ln_nonneg])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>eventually ((\\<le>) 3) at_top; 3 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> 3 \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>eventually ((\\<le>) 3) at_top; 3 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x powr p * ln x powr 0 * ln (ln x) =\n                         x powr p * ln (ln x)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  MASTER_BOUND p 0 1\n  \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 1)", "have B: \"\\<Theta>(MASTER_BOUND' p (-1)) = \\<Theta>(\\<lambda>x::nat. real x powr p / ln (real x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(MASTER_BOUND' p (- 1)) =\n    \\<Theta>(\\<lambda>x. real x powr p / ln (real x))", "by (subst CLAMP, (subst MASTER_BOUND_postproc MASTER_BOUND_UNCLAMP)+, simp only: UNCLAMP)"], ["proof (state)\nthis:\n  \\<Theta>(MASTER_BOUND' p (- 1)) =\n  \\<Theta>(\\<lambda>x. real x powr p / ln (real x))\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 1)", "from landau_theta.cong_bigtheta[OF A] B assms(1) master2_2"], ["proof (chain)\npicking this:\n  \\<Theta>(MASTER_BOUND p 0 1) =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))\n  \\<Theta>(MASTER_BOUND' p (- 1)) =\n  \\<Theta>(\\<lambda>x. real x powr p / ln (real x))\n  g \\<in> \\<Theta>(MASTER_BOUND' p (- 1))\n  g \\<in> \\<Theta>(\\<lambda>x.\n                      real x powr p / ln (real x)) \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>(MASTER_BOUND p 0 1) =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))\n  \\<Theta>(MASTER_BOUND' p (- 1)) =\n  \\<Theta>(\\<lambda>x. real x powr p / ln (real x))\n  g \\<in> \\<Theta>(MASTER_BOUND' p (- 1))\n  g \\<in> \\<Theta>(\\<lambda>x.\n                      real x powr p / ln (real x)) \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (ln (real x)))\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p 0 1)", "by simp"], ["proof (state)\nthis:\n  f \\<in> \\<Theta>(MASTER_BOUND p 0 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma master2_3_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND' p (p' - 1))\" \"p' > 0\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p p' 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p p' 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p p' 0)", "have A: \"MASTER_BOUND p p' 0 \\<in> \\<Theta>(\\<lambda>x::nat. x powr p * ln x powr p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MASTER_BOUND p p' 0\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')", "unfolding MASTER_BOUND_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p * ln (real x) powr p' * ln (ln (real x)) powr 0)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')", "using eventually_ge_at_top[of \"3::real\"]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) 3) at_top\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p * ln (real x) powr p' * ln (ln (real x)) powr 0)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')", "apply (intro landau_real_nat_transfer, intro bigthetaI_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eventually ((\\<le>) 3) at_top;\n     eventually ((\\<le>) 3) at_top\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_top.\n                         x powr p * ln x powr p' * ln (ln x) powr 0 =\n                         x powr p * ln x powr p'", "apply (elim eventually_mono, auto dest: ln_1_imp_less_3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  MASTER_BOUND p p' 0\n  \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p p' 0)", "have B: \"\\<Theta>(MASTER_BOUND' p (p' - 1)) = \\<Theta>(\\<lambda>x::nat. real x powr p * ln x powr (p' - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(MASTER_BOUND' p (p' - 1)) =\n    \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr (p' - 1))", "by (subst CLAMP, (subst MASTER_BOUND_postproc MASTER_BOUND_UNCLAMP)+, simp only: UNCLAMP)"], ["proof (state)\nthis:\n  \\<Theta>(MASTER_BOUND' p (p' - 1)) =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr (p' - 1))\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p p' 0)", "from landau_theta.cong_bigtheta[OF A] B assms(1) master2_3[OF _ assms(2-)]"], ["proof (chain)\npicking this:\n  \\<Theta>(MASTER_BOUND p p' 0) =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')\n  \\<Theta>(MASTER_BOUND' p (p' - 1)) =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr (p' - 1))\n  g \\<in> \\<Theta>(MASTER_BOUND' p (p' - 1))\n  g \\<in> \\<Theta>(\\<lambda>x.\n                      real x powr p *\n                      ln (real x) powr (p' - 1)) \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>(MASTER_BOUND p p' 0) =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')\n  \\<Theta>(MASTER_BOUND' p (p' - 1)) =\n  \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr (p' - 1))\n  g \\<in> \\<Theta>(MASTER_BOUND' p (p' - 1))\n  g \\<in> \\<Theta>(\\<lambda>x.\n                      real x powr p *\n                      ln (real x) powr (p' - 1)) \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p * ln (real x) powr p')\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p p' 0)", "by simp"], ["proof (state)\nthis:\n  f \\<in> \\<Theta>(MASTER_BOUND p p' 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma master3_automation:\n  assumes \"g \\<in> \\<Theta>(MASTER_BOUND'' p')\" \"1 > (\\<Sum>i<k. as ! i * bs ! i powr p')\"\n  shows   \"f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)", "have A: \"MASTER_BOUND p' 0 0 \\<in> \\<Theta>(\\<lambda>x::nat. x powr p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MASTER_BOUND p' 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p')", "unfolding MASTER_BOUND_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p' * ln (real x) powr 0 * ln (ln (real x)) powr 0)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p')", "using eventually_ge_at_top[of \"3::real\"]"], ["proof (prove)\nusing this:\n  eventually ((\\<le>) 3) at_top\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x powr p' * ln (real x) powr 0 * ln (ln (real x)) powr 0)\n    \\<in> \\<Theta>(\\<lambda>x. real x powr p')", "apply (intro landau_real_nat_transfer, intro bigthetaI_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eventually ((\\<le>) 3) at_top;\n     eventually ((\\<le>) 3) at_top\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_top.\n                         x powr p' * ln x powr 0 * ln (ln x) powr 0 =\n                         x powr p'", "apply (elim eventually_mono, auto dest: ln_1_imp_less_3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  MASTER_BOUND p' 0 0 \\<in> \\<Theta>(\\<lambda>x. real x powr p')\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)", "have B: \"\\<Theta>(MASTER_BOUND'' p') = \\<Theta>(\\<lambda>x::nat. real x powr p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>(MASTER_BOUND'' p') = \\<Theta>(\\<lambda>x. real x powr p')", "by (subst CLAMP, (subst MASTER_BOUND_postproc)+, simp only: UNCLAMP)"], ["proof (state)\nthis:\n  \\<Theta>(MASTER_BOUND'' p') = \\<Theta>(\\<lambda>x. real x powr p')\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)", "from landau_theta.cong_bigtheta[OF A] B assms(1) master3[OF _ assms(2-)]"], ["proof (chain)\npicking this:\n  \\<Theta>(MASTER_BOUND p' 0 0) = \\<Theta>(\\<lambda>x. real x powr p')\n  \\<Theta>(MASTER_BOUND'' p') = \\<Theta>(\\<lambda>x. real x powr p')\n  g \\<in> \\<Theta>(MASTER_BOUND'' p')\n  g \\<in> \\<Theta>(\\<lambda>x. real x powr p') \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>(MASTER_BOUND p' 0 0) = \\<Theta>(\\<lambda>x. real x powr p')\n  \\<Theta>(MASTER_BOUND'' p') = \\<Theta>(\\<lambda>x. real x powr p')\n  g \\<in> \\<Theta>(MASTER_BOUND'' p')\n  g \\<in> \\<Theta>(\\<lambda>x. real x powr p') \\<Longrightarrow>\n  f \\<in> \\<Theta>(\\<lambda>x. real x powr p')\n\ngoal (1 subgoal):\n 1. f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)", "by simp"], ["proof (state)\nthis:\n  f \\<in> \\<Theta>(MASTER_BOUND p' 0 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas master_automation = \n  master1_automation master2_1_automation master2_2_automation \n  master2_2_automation master3_automation"], ["", "ML \\<open>\n\nfun generalize_master_thm ctxt thm =\n  let\n    val ([p'], ctxt') = Variable.variant_fixes [\"p''\"] ctxt\n    val p' = Free (p', HOLogic.realT)\n    val a = @{term \"nth as\"} $ Bound 0\n    val b = @{term \"Transcendental.powr :: real => real => real\"} $ \n              (@{term \"nth bs\"} $ Bound 0) $ p'\n    val f = Abs (\"i\", HOLogic.natT, @{term \"(*) :: real => real => real\"} $ a $ b)\n    val sum = @{term \"sum :: (nat => real) => nat set => real\"} $ f $ @{term \"{..<k}\"}\n    val prop = HOLogic.mk_Trueprop (HOLogic.mk_eq (sum, @{term \"1::real\"}))\n    val cprop = Thm.cterm_of ctxt' prop\n  in\n    thm\n    |> Local_Defs.unfold ctxt' [Thm.assume cprop RS @{thm p_unique}]\n    |> Thm.implies_intr cprop\n    |> rotate_prems 1\n    |> singleton (Variable.export ctxt' ctxt)\n  end\n\nfun generalize_master_thm' (binding, thm) ctxt =\n  Local_Theory.note ((binding, []), [generalize_master_thm ctxt thm]) ctxt |> snd\n\n\\<close>"], ["", "local_setup \\<open>\n  fold generalize_master_thm' \n    [(@{binding master1_automation'}, @{thm master1_automation}), \n     (@{binding master1_bigo_automation'}, @{thm master1_bigo_automation}), \n     (@{binding master2_1_automation'}, @{thm master2_1_automation}),\n     (@{binding master2_2_automation'}, @{thm master2_2_automation}),\n     (@{binding master2_3_automation'}, @{thm master2_3_automation}), \n     (@{binding master3_automation'}, @{thm master3_automation})]\n\\<close>"], ["", "end"], ["", "definition \"arith_consts (x :: real) (y :: nat) = \n  (if \\<not> (-x) + 3 / x * 5 - 1 \\<le> x \\<and> True \\<or> True \\<longrightarrow> True then \n  x < inverse 3 powr 21 else x = real (Suc 0 ^ 2 + \n  (if 42 - x \\<le> 1 \\<and> 1 div y = y mod 2 \\<or> y < Numeral1 then 0 else 0)) + Numeral1)\""], ["", "ML_file \\<open>akra_bazzi.ML\\<close>"], ["", "hide_const arith_consts"], ["", "method_setup master_theorem = \\<open>\n  Akra_Bazzi.setup_master_theorem\n\\<close> \"automatically apply the Master theorem for recursive functions\""], ["", "method_setup akra_bazzi_termination = \\<open>\n  Scan.succeed (fn ctxt => SIMPLE_METHOD' (Akra_Bazzi.akra_bazzi_termination_tac ctxt))\n\\<close> \"prove termination of Akra-Bazzi functions\""], ["", "hide_const CLAMP CLAMP' MASTER_BOUND MASTER_BOUND' MASTER_BOUND''"], ["", "end"]]}