{"file_name": "/home/qj213/afp-2021-10-22/thys/Akra_Bazzi/Eval_Numeral.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Akra_Bazzi", "problem_names": ["lemma real_numeral_to_Ratreal:\n  \"(0::real) = Ratreal (Frct (0, 1))\"\n  \"(1::real) = Ratreal (Frct (1, 1))\"\n  \"(numeral x :: real) = Ratreal (Frct (numeral x, 1))\"\n  \"(1::int) = numeral Num.One\"", "lemma real_equals_code: \"Ratreal x = Ratreal y \\<longleftrightarrow> x = y\"", "lemma Rat_normalize_idempotent: \"Rat.normalize (Rat.normalize x) = Rat.normalize x\"", "lemma uminus_pow_Numeral1: \"(-(x::_::monoid_mult)) ^ Numeral1 = -x\"", "lemmas power_numeral_simps = power_0 uminus_pow_Numeral1 power_minus_Bit0 power_minus_Bit1", "lemma Fract_normalize: \"Fract (fst (Rat.normalize (x,y))) (snd (Rat.normalize (x,y))) = Fract x y\"", "lemma Frct_add: \"Frct (a, numeral b) + Frct (c, numeral d) =\n                   Frct (Rat.normalize (a * numeral d + c * numeral b, numeral (b*d)))\"", "lemma Frct_uminus: \"-(Frct (a,b)) = Frct (-a,b)\"", "lemma Frct_diff: \"Frct (a, numeral b) - Frct (c, numeral d) =\n                    Frct (Rat.normalize (a * numeral d - c * numeral b, numeral (b*d)))\"", "lemma Frct_mult: \"Frct (a, numeral b) * Frct (c, numeral d) = Frct (a*c, numeral (b*d))\"", "lemma Frct_inverse: \"inverse (Frct (a, b)) = Frct (b, a)\"", "lemma Frct_divide: \"Frct (a, numeral b) / Frct (c, numeral d) = Frct (a*numeral d, numeral b * c)\"", "lemma Frct_pow: \"Frct (a, numeral b) ^ c = Frct (a ^ c, numeral b ^ c)\"", "lemma Frct_less: \"Frct (a, numeral b) < Frct (c, numeral d) \\<longleftrightarrow> a * numeral d < c * numeral b\"", "lemma Frct_le: \"Frct (a, numeral b) \\<le> Frct (c, numeral d) \\<longleftrightarrow> a * numeral d \\<le> c * numeral b\"", "lemma Frct_equals: \"Frct (a, numeral b) = Frct (c, numeral d) \\<longleftrightarrow> a * numeral d = c * numeral b\"", "lemma real_power_code: \"(Ratreal x) ^ y = Ratreal (x ^ y)\"", "lemmas real_arith_code =\n  real_plus_code real_minus_code real_times_code real_uminus_code real_inverse_code\n  real_divide_code real_power_code real_less_code real_less_eq_code real_equals_code", "lemmas rat_arith_code =\n  Frct_add Frct_uminus Frct_diff Frct_mult Frct_inverse Frct_divide Frct_pow\n  Frct_less Frct_le Frct_equals", "lemma gcd_numeral_red: \"gcd (numeral x::int) (numeral y) = gcd (numeral y) (numeral x mod numeral y)\"", "lemma divmod_one:\n  \"divmod (Num.One) (Num.One) = (Numeral1, 0)\"\n  \"divmod (Num.One) (Num.Bit0 x) = (0, Numeral1)\"\n  \"divmod (Num.One) (Num.Bit1 x) = (0, Numeral1)\"\n  \"divmod x (Num.One) = (numeral x, 0)\"", "lemmas divmod_numeral_simps =\n  div_0 div_by_0 mod_0 mod_by_0\n  fst_divmod [symmetric]\n  snd_divmod [symmetric]\n  divmod_cancel\n  divmod_steps [simplified rel_simps if_True] divmod_trivial\n  rel_simps", "lemma Suc_0_to_numeral: \"Suc 0 = Numeral1\"", "lemmas Suc_to_numeral = Suc_0_to_numeral Num.Suc_1 Num.Suc_numeral", "lemma rat_powr:\n  \"0 powr y = 0\"\n  \"x > 0 \\<Longrightarrow> x powr Ratreal (Frct (0, Numeral1)) = Ratreal (Frct (Numeral1, Numeral1))\"\n  \"x > 0 \\<Longrightarrow> x powr Ratreal (Frct (numeral a, Numeral1)) = x ^ numeral a\"\n  \"x > 0 \\<Longrightarrow> x powr Ratreal (Frct (-numeral a, Numeral1)) = inverse (x ^ numeral a)\"", "lemmas eval_numeral_simps =\n  real_numeral_to_Ratreal real_arith_code rat_arith_code Num.arith_simps\n  Rat.normalize_def fst_conv snd_conv gcd_0_int gcd_0_left_int gcd.bottom_right_bottom gcd.bottom_left_bottom\n  gcd_neg1_int gcd_neg2_int gcd_numeral_red zmod_numeral_Bit0 zmod_numeral_Bit1 power_numeral_simps\n  divmod_numeral_simps numeral_One [symmetric] Groups.Let_0 Num.Let_numeral Suc_to_numeral power_numeral\n  greaterThanLessThan_iff atLeastAtMost_iff atLeastLessThan_iff greaterThanAtMost_iff rat_powr\n  Num.pow.simps Num.sqr.simps Product_Type.split of_int_numeral of_int_neg_numeral of_nat_numeral", "lemma \"21254387548659589512*314213523632464357453884361*2342523623324234*564327438587241734743*\n          12561712738645824362329316482973164398214286 powr 2 /\n         (1130246312978423123+231212374631082764842731842*122474378389424362347451251263) >\n        (12313244512931247243543279768645745929475829310651205623844::real)\""], "translations": [["", "lemma real_numeral_to_Ratreal:\n  \"(0::real) = Ratreal (Frct (0, 1))\"\n  \"(1::real) = Ratreal (Frct (1, 1))\"\n  \"(numeral x :: real) = Ratreal (Frct (numeral x, 1))\"\n  \"(1::int) = numeral Num.One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 = Ratreal (Frct (0, 1)) &&& 1 = Ratreal (Frct (1, 1))) &&&\n    numeral x = Ratreal (Frct (numeral x, 1)) &&& 1 = Numeral1", "by (simp_all add: rat_number_collapse)"], ["", "lemma real_equals_code: \"Ratreal x = Ratreal y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ratreal x = Ratreal y) = (x = y)", "by simp"], ["", "lemma Rat_normalize_idempotent: \"Rat.normalize (Rat.normalize x) = Rat.normalize x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rat.normalize (Rat.normalize x) = Rat.normalize x", "apply (cases \"Rat.normalize x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       Rat.normalize x = (a, b) \\<Longrightarrow>\n       Rat.normalize (Rat.normalize x) = Rat.normalize x", "using Rat.normalize_stable[OF normalize_denom_pos normalize_coprime]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Rat.normalize ?r2 = (?p2, ?q);\n   Rat.normalize ?r1 = (?p, ?q)\\<rbrakk>\n  \\<Longrightarrow> Rat.normalize (?p, ?q) = (?p, ?q)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       Rat.normalize x = (a, b) \\<Longrightarrow>\n       Rat.normalize (Rat.normalize x) = Rat.normalize x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma uminus_pow_Numeral1: \"(-(x::_::monoid_mult)) ^ Numeral1 = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x) ^ Numeral1 = - x", "by simp"], ["", "lemmas power_numeral_simps = power_0 uminus_pow_Numeral1 power_minus_Bit0 power_minus_Bit1"], ["", "lemma Fract_normalize: \"Fract (fst (Rat.normalize (x,y))) (snd (Rat.normalize (x,y))) = Fract x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fract (fst (Rat.normalize (x, y))) (snd (Rat.normalize (x, y))) =\n    Fract x y", "by (rule quotient_of_inject) (simp add: quotient_of_Fract Rat_normalize_idempotent)"], ["", "lemma Frct_add: \"Frct (a, numeral b) + Frct (c, numeral d) =\n                   Frct (Rat.normalize (a * numeral d + c * numeral b, numeral (b*d)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Frct (a, numeral b) + Frct (c, numeral d) =\n    Frct (Rat.normalize (a * numeral d + c * numeral b, numeral (b * d)))", "by (auto simp: rat_number_collapse Fract_normalize)"], ["", "lemma Frct_uminus: \"-(Frct (a,b)) = Frct (-a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Frct (a, b) = Frct (- a, b)", "by simp"], ["", "lemma Frct_diff: \"Frct (a, numeral b) - Frct (c, numeral d) =\n                    Frct (Rat.normalize (a * numeral d - c * numeral b, numeral (b*d)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Frct (a, numeral b) - Frct (c, numeral d) =\n    Frct (Rat.normalize (a * numeral d - c * numeral b, numeral (b * d)))", "by (auto simp: rat_number_collapse Fract_normalize)"], ["", "lemma Frct_mult: \"Frct (a, numeral b) * Frct (c, numeral d) = Frct (a*c, numeral (b*d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Frct (a, numeral b) * Frct (c, numeral d) =\n    Frct (a * c, numeral (b * d))", "by simp"], ["", "lemma Frct_inverse: \"inverse (Frct (a, b)) = Frct (b, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (Frct (a, b)) = Frct (b, a)", "by simp"], ["", "lemma Frct_divide: \"Frct (a, numeral b) / Frct (c, numeral d) = Frct (a*numeral d, numeral b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Frct (a, numeral b) / Frct (c, numeral d) =\n    Frct (a * numeral d, numeral b * c)", "by simp"], ["", "lemma Frct_pow: \"Frct (a, numeral b) ^ c = Frct (a ^ c, numeral b ^ c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Frct (a, numeral b) ^ c = Frct (a ^ c, numeral b ^ c)", "by (induction c) (simp_all add: rat_number_collapse)"], ["", "lemma Frct_less: \"Frct (a, numeral b) < Frct (c, numeral d) \\<longleftrightarrow> a * numeral d < c * numeral b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Frct (a, numeral b) < Frct (c, numeral d)) =\n    (a * numeral d < c * numeral b)", "by simp"], ["", "lemma Frct_le: \"Frct (a, numeral b) \\<le> Frct (c, numeral d) \\<longleftrightarrow> a * numeral d \\<le> c * numeral b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Frct (a, numeral b) \\<le> Frct (c, numeral d)) =\n    (a * numeral d \\<le> c * numeral b)", "by simp"], ["", "lemma Frct_equals: \"Frct (a, numeral b) = Frct (c, numeral d) \\<longleftrightarrow> a * numeral d = c * numeral b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Frct (a, numeral b) = Frct (c, numeral d)) =\n    (a * numeral d = c * numeral b)", "apply (intro iffI antisym)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Frct (a, numeral b) = Frct (c, numeral d) \\<Longrightarrow>\n    a * numeral d \\<le> c * numeral b\n 2. Frct (a, numeral b) = Frct (c, numeral d) \\<Longrightarrow>\n    c * numeral b \\<le> a * numeral d\n 3. a * numeral d = c * numeral b \\<Longrightarrow>\n    Frct (a, numeral b) \\<le> Frct (c, numeral d)\n 4. a * numeral d = c * numeral b \\<Longrightarrow>\n    Frct (c, numeral d) \\<le> Frct (a, numeral b)", "apply (subst Frct_le[symmetric], simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. a * numeral d = c * numeral b \\<Longrightarrow>\n    Frct (a, numeral b) \\<le> Frct (c, numeral d)\n 2. a * numeral d = c * numeral b \\<Longrightarrow>\n    Frct (c, numeral d) \\<le> Frct (a, numeral b)", "apply (subst Frct_le, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma real_power_code: \"(Ratreal x) ^ y = Ratreal (x ^ y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ratreal x ^ y = Ratreal (x ^ y)", "by (simp add: of_rat_power)"], ["", "lemmas real_arith_code =\n  real_plus_code real_minus_code real_times_code real_uminus_code real_inverse_code\n  real_divide_code real_power_code real_less_code real_less_eq_code real_equals_code"], ["", "lemmas rat_arith_code =\n  Frct_add Frct_uminus Frct_diff Frct_mult Frct_inverse Frct_divide Frct_pow\n  Frct_less Frct_le Frct_equals"], ["", "lemma gcd_numeral_red: \"gcd (numeral x::int) (numeral y) = gcd (numeral y) (numeral x mod numeral y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (numeral x) (numeral y) = gcd (numeral y) (numeral x mod numeral y)", "by (fact gcd_red_int)"], ["", "lemma divmod_one:\n  \"divmod (Num.One) (Num.One) = (Numeral1, 0)\"\n  \"divmod (Num.One) (Num.Bit0 x) = (0, Numeral1)\"\n  \"divmod (Num.One) (Num.Bit1 x) = (0, Numeral1)\"\n  \"divmod x (Num.One) = (numeral x, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (divmod num.One num.One = (Numeral1, 0::'a) &&&\n     divmod num.One (num.Bit0 x) = (0::'b, Numeral1)) &&&\n    divmod num.One (num.Bit1 x) = (0::'c, Numeral1) &&&\n    divmod x num.One = (numeral x, 0::'d)", "unfolding divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Numeral1 div Numeral1, Numeral1 mod Numeral1) = (Numeral1, 0::'a) &&&\n     (Numeral1 div numeral (num.Bit0 x),\n      Numeral1 mod numeral (num.Bit0 x)) =\n     (0::'b, Numeral1)) &&&\n    (Numeral1 div numeral (num.Bit1 x), Numeral1 mod numeral (num.Bit1 x)) =\n    (0::'c, Numeral1) &&&\n    (numeral x div Numeral1, numeral x mod Numeral1) = (numeral x, 0::'d)", "by simp_all"], ["", "lemmas divmod_numeral_simps =\n  div_0 div_by_0 mod_0 mod_by_0\n  fst_divmod [symmetric]\n  snd_divmod [symmetric]\n  divmod_cancel\n  divmod_steps [simplified rel_simps if_True] divmod_trivial\n  rel_simps"], ["", "lemma Suc_0_to_numeral: \"Suc 0 = Numeral1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = Numeral1", "by simp"], ["", "lemmas Suc_to_numeral = Suc_0_to_numeral Num.Suc_1 Num.Suc_numeral"], ["", "lemma rat_powr:\n  \"0 powr y = 0\"\n  \"x > 0 \\<Longrightarrow> x powr Ratreal (Frct (0, Numeral1)) = Ratreal (Frct (Numeral1, Numeral1))\"\n  \"x > 0 \\<Longrightarrow> x powr Ratreal (Frct (numeral a, Numeral1)) = x ^ numeral a\"\n  \"x > 0 \\<Longrightarrow> x powr Ratreal (Frct (-numeral a, Numeral1)) = inverse (x ^ numeral a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) powr y = (0::'a) &&&\n     (0 < x \\<Longrightarrow>\n      x powr Ratreal (Frct (0, Numeral1)) =\n      Ratreal (Frct (Numeral1, Numeral1)))) &&&\n    (0 < x \\<Longrightarrow>\n     x powr Ratreal (Frct (numeral a, Numeral1)) = x ^ numeral a) &&&\n    (0 < x \\<Longrightarrow>\n     x powr Ratreal (Frct (- numeral a, Numeral1)) =\n     inverse (x ^ numeral a))", "by (simp_all add: rat_number_collapse powr_minus)"], ["", "lemmas eval_numeral_simps =\n  real_numeral_to_Ratreal real_arith_code rat_arith_code Num.arith_simps\n  Rat.normalize_def fst_conv snd_conv gcd_0_int gcd_0_left_int gcd.bottom_right_bottom gcd.bottom_left_bottom\n  gcd_neg1_int gcd_neg2_int gcd_numeral_red zmod_numeral_Bit0 zmod_numeral_Bit1 power_numeral_simps\n  divmod_numeral_simps numeral_One [symmetric] Groups.Let_0 Num.Let_numeral Suc_to_numeral power_numeral\n  greaterThanLessThan_iff atLeastAtMost_iff atLeastLessThan_iff greaterThanAtMost_iff rat_powr\n  Num.pow.simps Num.sqr.simps Product_Type.split of_int_numeral of_int_neg_numeral of_nat_numeral"], ["", "ML \\<open>\nsignature EVAL_NUMERAL =\nsig\n  val eval_numeral_tac : Proof.context -> int -> tactic\nend\n\nstructure Eval_Numeral : EVAL_NUMERAL =\nstruct\n\nfun eval_numeral_tac ctxt =\n  let\n    val ctxt' = put_simpset HOL_ss ctxt addsimps @{thms eval_numeral_simps}\n  in\n    SELECT_GOAL (SOLVE (Simplifier.simp_tac ctxt' 1))\n  end\n\nend\n\\<close>"], ["", "lemma \"21254387548659589512*314213523632464357453884361*2342523623324234*564327438587241734743*\n          12561712738645824362329316482973164398214286 powr 2 /\n         (1130246312978423123+231212374631082764842731842*122474378389424362347451251263) >\n        (12313244512931247243543279768645745929475829310651205623844::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 12313244512931247243543279768645745929475829310651205623844\n    < 21254387548659589512 * 314213523632464357453884361 *\n      2342523623324234 *\n      564327438587241734743 *\n      12561712738645824362329316482973164398214286 powr 2 /\n      (1130246312978423123 +\n       231212374631082764842731842 * 122474378389424362347451251263)", "by (tactic \\<open>Eval_Numeral.eval_numeral_tac @{context} 1\\<close>)"], ["", "end"]]}