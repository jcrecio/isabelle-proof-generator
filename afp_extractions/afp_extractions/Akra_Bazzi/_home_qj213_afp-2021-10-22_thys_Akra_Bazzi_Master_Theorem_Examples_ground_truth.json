{"file_name": "/home/qj213/afp-2021-10-22/thys/Akra_Bazzi/Master_Theorem_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Akra_Bazzi", "problem_names": ["lemma merge_sort_nonneg[simp]: \"(\\<And>n. t n \\<ge> 0) \\<Longrightarrow> merge_sort_cost t x \\<ge> 0\"", "lemma \"t \\<in> \\<Theta>(\\<lambda>n. real n) \\<Longrightarrow> (\\<And>n. t n \\<ge> 0) \\<Longrightarrow> merge_sort_cost t \\<in> \\<Theta>(\\<lambda>n. real n * ln (real n))\"", "lemma karatsuba_cost_nonneg[simp]: \"karatsuba_cost n \\<ge> 0\"", "lemma \"karatsuba_cost \\<in> O(\\<lambda>n. real n powr log 2 3)\"", "lemma karatsuba_cost_pos: \"n \\<ge> 1 \\<Longrightarrow> karatsuba_cost n > 0\"", "lemma \"karatsuba_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 3)\"", "lemma strassen_cost_nonneg[simp]: \"strassen_cost n \\<ge> 0\"", "lemma \"strassen_cost \\<in> O(\\<lambda>n. real n powr log 2 7)\"", "lemma strassen_cost_pos: \"n \\<ge> 1 \\<Longrightarrow> strassen_cost n > 0\"", "lemma \"strassen_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 7)\"", "lemma \"select_cost \\<in> \\<Theta>(\\<lambda>n. real n)\"", "lemma \"dec_cost \\<in> \\<Theta>(\\<lambda>x::nat. ln x / x)\"", "lemma \"drmota1 \\<in> \\<Theta>(\\<lambda>n::real. n^2 * ln (ln n))\"", "lemma \"drmota2 \\<in> \\<Theta>(\\<lambda>x. ln (real x))\"", "lemma boncelet_phrase_length:\n  fixes p \\<delta> :: real assumes p: \"p > 0\" \"p < 1\" and \\<delta>: \"\\<delta> > 0\" \"\\<delta> < 1\" \"2*p + \\<delta> < 2\"\n  fixes d :: \"nat \\<Rightarrow> real\"\n  defines \"q \\<equiv> 1 - p\"\n  assumes d_nonneg: \"\\<And>n. d n \\<ge> 0\"\n  assumes d_rec: \"\\<And>n. n \\<ge> 2 \\<Longrightarrow> d n = 1 + p * d (nat \\<lfloor>p * real n + \\<delta>\\<rfloor>) + q * d (nat \\<lfloor>q * real n - \\<delta>\\<rfloor>)\"\n  shows   \"d \\<in> \\<Theta>(\\<lambda>x. ln x)\"", "lemma foo_cost_nonneg [simp]: \"foo_cost n \\<ge> 0\"", "lemma \"foo_cost \\<in> \\<Theta>(\\<lambda>n. real n powr akra_bazzi_exponent [1,1] [1/3,3/4])\"", "lemma \"akra_bazzi_exponent [1,1] [1/3,3/4] \\<in> {1.1519623..1.1519624}\"", "lemma \"a \\<ge> 0 \\<Longrightarrow> select_cost' \\<in> \\<Theta>(\\<lambda>n. real n)\"", "lemma baz_cost_nonneg [simp]: \"a \\<ge> 0 \\<Longrightarrow> baz_cost (a, n) \\<ge> 0\"", "lemma\n  assumes \"a > 0\"\n  shows   \"(\\<lambda>x. baz_cost (a, x)) \\<in> \\<Theta>(\\<lambda>x. x powr log 2 3)\"", "lemma ham_sandwich_cost_pos [simp]: \"ham_sandwich_cost n > 0\"", "lemma \\<phi>_pos [simp]: \"\\<phi> > 0\" and \\<phi>_nonneg [simp]: \"\\<phi> \\<ge> 0\" and \\<phi>_nonzero [simp]: \"\\<phi> \\<noteq> 0\"", "lemma \"ham_sandwich_cost \\<in> \\<Theta>(\\<lambda>n. n powr (log 2 \\<phi>))\""], "translations": [["", "lemma merge_sort_nonneg[simp]: \"(\\<And>n. t n \\<ge> 0) \\<Longrightarrow> merge_sort_cost t x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. 0 \\<le> t n) \\<Longrightarrow> 0 \\<le> merge_sort_cost t x", "by (induction t x rule: merge_sort_cost.induct) (simp_all del: One_nat_def)"], ["", "lemma \"t \\<in> \\<Theta>(\\<lambda>n. real n) \\<Longrightarrow> (\\<And>n. t n \\<ge> 0) \\<Longrightarrow> merge_sort_cost t \\<in> \\<Theta>(\\<lambda>n. real n * ln (real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> \\<Theta>(real); \\<And>n. 0 \\<le> t n\\<rbrakk>\n    \\<Longrightarrow> merge_sort_cost t\n                      \\<in> \\<Theta>(\\<lambda>n. real n * ln (real n))", "by (master_theorem 2.3) simp_all"], ["", "subsection \\<open>Karatsuba multiplication\\<close>"], ["", "function karatsuba_cost :: \"nat \\<Rightarrow> real\" where\n  \"karatsuba_cost 0 = 0\"\n| \"karatsuba_cost 1 = 1\"\n| \"n \\<ge> 2 \\<Longrightarrow> karatsuba_cost n = \n     3 * karatsuba_cost (nat \\<lceil>real n / 2\\<rceil>) + real n\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = 0 \\<Longrightarrow> P; x = 1 \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>2 \\<le> n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. 0 = 0 \\<Longrightarrow> 0 = 0\n 3. 0 = 1 \\<Longrightarrow> 0 = 1\n 4. \\<And>n.\n       \\<lbrakk>2 \\<le> n; 0 = n\\<rbrakk>\n       \\<Longrightarrow> 0 =\n                         3 *\n                         karatsuba_cost_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>) +\n                         real n\n 5. 1 = 1 \\<Longrightarrow> 1 = 1\n 6. \\<And>n.\n       \\<lbrakk>2 \\<le> n; 1 = n\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         3 *\n                         karatsuba_cost_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>) +\n                         real n\n 7. \\<And>n na.\n       \\<lbrakk>2 \\<le> n; 2 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 3 *\n                         karatsuba_cost_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>) +\n                         real n =\n                         3 *\n                         karatsuba_cost_sumC\n                          (nat \\<lceil>real na / 2\\<rceil>) +\n                         real na", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All karatsuba_cost_dom", "by akra_bazzi_termination simp_all"], ["", "lemma karatsuba_cost_nonneg[simp]: \"karatsuba_cost n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> karatsuba_cost n", "by (induction n rule: karatsuba_cost.induct) (simp_all del: One_nat_def)"], ["", "lemma \"karatsuba_cost \\<in> O(\\<lambda>n. real n powr log 2 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_cost \\<in> O(\\<lambda>n. real n powr log 2 3)", "by (master_theorem 1 p': 1) (simp_all add: powr_divide)"], ["", "lemma karatsuba_cost_pos: \"n \\<ge> 1 \\<Longrightarrow> karatsuba_cost n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> n \\<Longrightarrow> 0 < karatsuba_cost n", "by (induction n rule: karatsuba_cost.induct) (auto intro!: add_nonneg_pos simp del: One_nat_def)"], ["", "lemma \"karatsuba_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 3)", "using karatsuba_cost_pos"], ["proof (prove)\nusing this:\n  1 \\<le> ?n \\<Longrightarrow> 0 < karatsuba_cost ?n\n\ngoal (1 subgoal):\n 1. karatsuba_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 3)", "by (master_theorem 1 p': 1) (auto simp add: powr_divide eventually_at_top_linorder)"], ["", "subsection \\<open>Strassen matrix multiplication\\<close>"], ["", "function strassen_cost :: \"nat \\<Rightarrow> real\" where\n  \"strassen_cost 0 = 0\"\n| \"strassen_cost 1 = 1\"\n| \"n \\<ge> 2 \\<Longrightarrow> strassen_cost n = 7 * strassen_cost (nat \\<lceil>real n / 2\\<rceil>) + real (n^2)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = 0 \\<Longrightarrow> P; x = 1 \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>2 \\<le> n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. 0 = 0 \\<Longrightarrow> 0 = 0\n 3. 0 = 1 \\<Longrightarrow> 0 = 1\n 4. \\<And>n.\n       \\<lbrakk>2 \\<le> n; 0 = n\\<rbrakk>\n       \\<Longrightarrow> 0 =\n                         7 *\n                         strassen_cost_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>) +\n                         real (n\\<^sup>2)\n 5. 1 = 1 \\<Longrightarrow> 1 = 1\n 6. \\<And>n.\n       \\<lbrakk>2 \\<le> n; 1 = n\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         7 *\n                         strassen_cost_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>) +\n                         real (n\\<^sup>2)\n 7. \\<And>n na.\n       \\<lbrakk>2 \\<le> n; 2 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 7 *\n                         strassen_cost_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>) +\n                         real (n\\<^sup>2) =\n                         7 *\n                         strassen_cost_sumC\n                          (nat \\<lceil>real na / 2\\<rceil>) +\n                         real (na\\<^sup>2)", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All strassen_cost_dom", "by akra_bazzi_termination simp_all"], ["", "lemma strassen_cost_nonneg[simp]: \"strassen_cost n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> strassen_cost n", "by (induction n rule: strassen_cost.induct) (simp_all del: One_nat_def)"], ["", "lemma \"strassen_cost \\<in> O(\\<lambda>n. real n powr log 2 7)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strassen_cost \\<in> O(\\<lambda>n. real n powr log 2 7)", "by (master_theorem 1 p': 2) (auto simp: powr_divide eventually_at_top_linorder)"], ["", "lemma strassen_cost_pos: \"n \\<ge> 1 \\<Longrightarrow> strassen_cost n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> n \\<Longrightarrow> 0 < strassen_cost n", "by (cases n rule: strassen_cost.cases) (simp_all add: add_nonneg_pos del: One_nat_def)"], ["", "lemma \"strassen_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 7)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strassen_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 7)", "using strassen_cost_pos"], ["proof (prove)\nusing this:\n  1 \\<le> ?n \\<Longrightarrow> 0 < strassen_cost ?n\n\ngoal (1 subgoal):\n 1. strassen_cost \\<in> \\<Theta>(\\<lambda>n. real n powr log 2 7)", "by (master_theorem 1 p': 2) (auto simp: powr_divide eventually_at_top_linorder)"], ["", "subsection \\<open>Deterministic select\\<close>"], ["", "(* This is not possible with the standard Master theorem from literature *)"], ["", "function select_cost :: \"nat \\<Rightarrow> real\" where\n  \"n \\<le> 20 \\<Longrightarrow> select_cost n = 0\"\n| \"n > 20 \\<Longrightarrow> select_cost n = \n     select_cost (nat \\<lfloor>real n / 5\\<rfloor>) + select_cost (nat \\<lfloor>7 * real n / 10\\<rfloor> + 6) + 12 * real n / 5\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n \\<le> 20; x = n\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>20 < n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na.\n       \\<lbrakk>n \\<le> 20; na \\<le> 20; n = na\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 3. \\<And>n na.\n       \\<lbrakk>n \\<le> 20; 20 < na; n = na\\<rbrakk>\n       \\<Longrightarrow> 0 =\n                         select_cost_sumC\n                          (nat \\<lfloor>real na / 5\\<rfloor>) +\n                         select_cost_sumC\n                          (nat \\<lfloor>7 * real na / 10\\<rfloor> + 6) +\n                         12 * real na / 5\n 4. \\<And>n na.\n       \\<lbrakk>20 < n; 20 < na; n = na\\<rbrakk>\n       \\<Longrightarrow> select_cost_sumC\n                          (nat \\<lfloor>real n / 5\\<rfloor>) +\n                         select_cost_sumC\n                          (nat \\<lfloor>7 * real n / 10\\<rfloor> + 6) +\n                         12 * real n / 5 =\n                         select_cost_sumC\n                          (nat \\<lfloor>real na / 5\\<rfloor>) +\n                         select_cost_sumC\n                          (nat \\<lfloor>7 * real na / 10\\<rfloor> + 6) +\n                         12 * real na / 5", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All select_cost_dom", "by akra_bazzi_termination simp_all"], ["", "lemma \"select_cost \\<in> \\<Theta>(\\<lambda>n. real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_cost \\<in> \\<Theta>(real)", "by (master_theorem 3) auto"], ["", "subsection \\<open>Decreasing function\\<close>"], ["", "function dec_cost :: \"nat \\<Rightarrow> real\" where\n  \"n \\<le> 2 \\<Longrightarrow> dec_cost n = 1\"\n| \"n > 2 \\<Longrightarrow> dec_cost n = 0.5*dec_cost (nat \\<lfloor>real n / 2\\<rfloor>) + 1 / real n\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n \\<le> 2; x = n\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>n. \\<lbrakk>2 < n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na.\n       \\<lbrakk>n \\<le> 2; na \\<le> 2; n = na\\<rbrakk>\n       \\<Longrightarrow> 1 = 1\n 3. \\<And>n na.\n       \\<lbrakk>n \\<le> 2; 2 < na; n = na\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         5 / 10 *\n                         dec_cost_sumC (nat \\<lfloor>real na / 2\\<rfloor>) +\n                         1 / real na\n 4. \\<And>n na.\n       \\<lbrakk>2 < n; 2 < na; n = na\\<rbrakk>\n       \\<Longrightarrow> 5 / 10 *\n                         dec_cost_sumC (nat \\<lfloor>real n / 2\\<rfloor>) +\n                         1 / real n =\n                         5 / 10 *\n                         dec_cost_sumC (nat \\<lfloor>real na / 2\\<rfloor>) +\n                         1 / real na", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All dec_cost_dom", "by akra_bazzi_termination simp_all"], ["", "lemma \"dec_cost \\<in> \\<Theta>(\\<lambda>x::nat. ln x / x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_cost \\<in> \\<Theta>(\\<lambda>x. ln (real x) / real x)", "by (master_theorem 2.3) simp_all"], ["", "subsection \\<open>Example taken from Drmota and Szpakowski\\<close>"], ["", "function drmota1 :: \"nat \\<Rightarrow> real\" where\n  \"n < 20 \\<Longrightarrow> drmota1 n = 1\"\n| \"n \\<ge> 20 \\<Longrightarrow> drmota1 n = 2 * drmota1 (nat \\<lfloor>real n/2\\<rfloor>) + 8/9 * drmota1 (nat \\<lfloor>3*real n/4\\<rfloor>) + real n^2 / ln (real n)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < 20; x = n\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>20 \\<le> n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na.\n       \\<lbrakk>n < 20; na < 20; n = na\\<rbrakk> \\<Longrightarrow> 1 = 1\n 3. \\<And>n na.\n       \\<lbrakk>n < 20; 20 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         2 *\n                         drmota1_sumC (nat \\<lfloor>real na / 2\\<rfloor>) +\n                         8 / 9 *\n                         drmota1_sumC\n                          (nat \\<lfloor>3 * real na / 4\\<rfloor>) +\n                         (real na)\\<^sup>2 / ln (real na)\n 4. \\<And>n na.\n       \\<lbrakk>20 \\<le> n; 20 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 2 *\n                         drmota1_sumC (nat \\<lfloor>real n / 2\\<rfloor>) +\n                         8 / 9 *\n                         drmota1_sumC\n                          (nat \\<lfloor>3 * real n / 4\\<rfloor>) +\n                         (real n)\\<^sup>2 / ln (real n) =\n                         2 *\n                         drmota1_sumC (nat \\<lfloor>real na / 2\\<rfloor>) +\n                         8 / 9 *\n                         drmota1_sumC\n                          (nat \\<lfloor>3 * real na / 4\\<rfloor>) +\n                         (real na)\\<^sup>2 / ln (real na)", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All drmota1_dom", "by akra_bazzi_termination simp_all"], ["", "lemma \"drmota1 \\<in> \\<Theta>(\\<lambda>n::real. n^2 * ln (ln n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drmota1 \\<in> \\<Theta>(\\<lambda>x. (real x)\\<^sup>2 * ln (ln (real x)))", "by (master_theorem 2.2) (simp_all add: power_divide)"], ["", "function drmota2 :: \"nat \\<Rightarrow> real\" where\n  \"n < 20 \\<Longrightarrow> drmota2 n = 1\"\n| \"n \\<ge> 20 \\<Longrightarrow> drmota2 n = 1/3 * drmota2 (nat \\<lfloor>real n/3 + 1/2\\<rfloor>) + 2/3 * drmota2 (nat \\<lfloor>2*real n/3 - 1/2\\<rfloor>) + 1\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < 20; x = n\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>20 \\<le> n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na.\n       \\<lbrakk>n < 20; na < 20; n = na\\<rbrakk> \\<Longrightarrow> 1 = 1\n 3. \\<And>n na.\n       \\<lbrakk>n < 20; 20 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         1 / 3 *\n                         drmota2_sumC\n                          (nat \\<lfloor>real na / 3 + 1 / 2\\<rfloor>) +\n                         2 / 3 *\n                         drmota2_sumC\n                          (nat \\<lfloor>2 * real na / 3 - 1 / 2\\<rfloor>) +\n                         1\n 4. \\<And>n na.\n       \\<lbrakk>20 \\<le> n; 20 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 1 / 3 *\n                         drmota2_sumC\n                          (nat \\<lfloor>real n / 3 + 1 / 2\\<rfloor>) +\n                         2 / 3 *\n                         drmota2_sumC\n                          (nat \\<lfloor>2 * real n / 3 - 1 / 2\\<rfloor>) +\n                         1 =\n                         1 / 3 *\n                         drmota2_sumC\n                          (nat \\<lfloor>real na / 3 + 1 / 2\\<rfloor>) +\n                         2 / 3 *\n                         drmota2_sumC\n                          (nat \\<lfloor>2 * real na / 3 - 1 / 2\\<rfloor>) +\n                         1", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All drmota2_dom", "by akra_bazzi_termination simp_all"], ["", "lemma \"drmota2 \\<in> \\<Theta>(\\<lambda>x. ln (real x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drmota2 \\<in> \\<Theta>(\\<lambda>x. ln (real x))", "by master_theorem simp_all"], ["", "(* Average phrase length of Boncelet arithmetic coding. See Drmota and Szpankowski. *)"], ["", "lemma boncelet_phrase_length:\n  fixes p \\<delta> :: real assumes p: \"p > 0\" \"p < 1\" and \\<delta>: \"\\<delta> > 0\" \"\\<delta> < 1\" \"2*p + \\<delta> < 2\"\n  fixes d :: \"nat \\<Rightarrow> real\"\n  defines \"q \\<equiv> 1 - p\"\n  assumes d_nonneg: \"\\<And>n. d n \\<ge> 0\"\n  assumes d_rec: \"\\<And>n. n \\<ge> 2 \\<Longrightarrow> d n = 1 + p * d (nat \\<lfloor>p * real n + \\<delta>\\<rfloor>) + q * d (nat \\<lfloor>q * real n - \\<delta>\\<rfloor>)\"\n  shows   \"d \\<in> \\<Theta>(\\<lambda>x. ln x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in> \\<Theta>(\\<lambda>x. ln (real x))", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  0 < \\<delta>\n  \\<delta> < 1\n  2 * p + \\<delta> < 2\n  q \\<equiv> 1 - p\n  0 \\<le> d ?n\n  2 \\<le> ?n \\<Longrightarrow>\n  d ?n =\n  1 + p * d (nat \\<lfloor>p * real ?n + \\<delta>\\<rfloor>) +\n  q * d (nat \\<lfloor>q * real ?n - \\<delta>\\<rfloor>)\n\ngoal (1 subgoal):\n 1. d \\<in> \\<Theta>(\\<lambda>x. ln (real x))", "by (master_theorem recursion: d_rec, simp_all)"], ["", "subsection \\<open>Transcendental exponents\\<close>"], ["", "(* Certain number-theoretic conjectures would imply that if all the parameters are rational,\n   the Akra-Bazzi parameter is either rational or transcendental. That makes this case \n   probably transcendental *)"], ["", "function foo_cost :: \"nat \\<Rightarrow> real\" where\n  \"n < 200 \\<Longrightarrow> foo_cost n = 0\"\n| \"n \\<ge> 200 \\<Longrightarrow> foo_cost n = \n     foo_cost (nat \\<lfloor>real n / 3\\<rfloor>) + foo_cost (nat \\<lfloor>3 * real n / 4\\<rfloor> + 42) + real n\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < 200; x = n\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>200 \\<le> n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na.\n       \\<lbrakk>n < 200; na < 200; n = na\\<rbrakk> \\<Longrightarrow> 0 = 0\n 3. \\<And>n na.\n       \\<lbrakk>n < 200; 200 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 0 =\n                         foo_cost_sumC (nat \\<lfloor>real na / 3\\<rfloor>) +\n                         foo_cost_sumC\n                          (nat \\<lfloor>3 * real na / 4\\<rfloor> + 42) +\n                         real na\n 4. \\<And>n na.\n       \\<lbrakk>200 \\<le> n; 200 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> foo_cost_sumC (nat \\<lfloor>real n / 3\\<rfloor>) +\n                         foo_cost_sumC\n                          (nat \\<lfloor>3 * real n / 4\\<rfloor> + 42) +\n                         real n =\n                         foo_cost_sumC (nat \\<lfloor>real na / 3\\<rfloor>) +\n                         foo_cost_sumC\n                          (nat \\<lfloor>3 * real na / 4\\<rfloor> + 42) +\n                         real na", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All foo_cost_dom", "by akra_bazzi_termination simp_all"], ["", "lemma foo_cost_nonneg [simp]: \"foo_cost n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> foo_cost n", "by (induction n rule: foo_cost.induct) simp_all"], ["", "lemma \"foo_cost \\<in> \\<Theta>(\\<lambda>n. real n powr akra_bazzi_exponent [1,1] [1/3,3/4])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foo_cost\n    \\<in> \\<Theta>(\\<lambda>n.\n                      real n powr akra_bazzi_exponent [1, 1] [1 / 3, 3 / 4])", "proof (master_theorem 1 p': 1)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 200\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> foo_cost x\n 2. \\<And>x.\n       200 \\<le> x \\<Longrightarrow>\n       foo_cost x =\n       real x +\n       (foo_cost (nat \\<lfloor>real x / 3\\<rfloor>) +\n        foo_cost (nat \\<lfloor>3 * real x / 4\\<rfloor> + 42))\n 3. \\<And>x. 200 \\<le> x \\<Longrightarrow> 0 \\<le> real x\n 4. real \\<in> O(real)\n 5. 1 < (1 / 3) powr 1 + (3 / 4) powr 1\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < foo_cost x", "have \"\\<forall>n\\<ge>200. foo_cost n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>200. 0 < foo_cost n", "by (simp add: add_nonneg_pos)"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>200. 0 < foo_cost n\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 200\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> foo_cost x\n 2. \\<And>x.\n       200 \\<le> x \\<Longrightarrow>\n       foo_cost x =\n       real x +\n       (foo_cost (nat \\<lfloor>real x / 3\\<rfloor>) +\n        foo_cost (nat \\<lfloor>3 * real x / 4\\<rfloor> + 42))\n 3. \\<And>x. 200 \\<le> x \\<Longrightarrow> 0 \\<le> real x\n 4. real \\<in> O(real)\n 5. 1 < (1 / 3) powr 1 + (3 / 4) powr 1\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < foo_cost x", "thus \"eventually (\\<lambda>n. foo_cost n > 0) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>200. 0 < foo_cost n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 < foo_cost n", "unfolding eventually_at_top_linorder"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>200. 0 < foo_cost n\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. 0 < foo_cost n", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. 0 < foo_cost n\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 200\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> foo_cost x\n 2. \\<And>x.\n       200 \\<le> x \\<Longrightarrow>\n       foo_cost x =\n       real x +\n       (foo_cost (nat \\<lfloor>real x / 3\\<rfloor>) +\n        foo_cost (nat \\<lfloor>3 * real x / 4\\<rfloor> + 42))\n 3. \\<And>x. 200 \\<le> x \\<Longrightarrow> 0 \\<le> real x\n 4. real \\<in> O(real)\n 5. 1 < (1 / 3) powr 1 + (3 / 4) powr 1", "qed simp_all"], ["", "lemma \"akra_bazzi_exponent [1,1] [1/3,3/4] \\<in> {1.1519623..1.1519624}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. akra_bazzi_exponent [1, 1] [1 / 3, 3 / 4]\n    \\<in> {11519623 / 10 ^ 7..11519624 / 10 ^ 7}", "by (akra_bazzi_approximate 29)"], ["", "subsection \\<open>Functions in locale contexts\\<close>"], ["", "locale det_select =\n  fixes b :: real\n  assumes b: \"b > 0\" \"b < 7/10\"\nbegin"], ["", "function select_cost' :: \"nat \\<Rightarrow> real\" where\n  \"n \\<le> 20 \\<Longrightarrow> select_cost' n = 0\"\n| \"n > 20 \\<Longrightarrow> select_cost' n = \n     select_cost' (nat \\<lfloor>real n / 5\\<rfloor>) + select_cost' (nat \\<lfloor>b * real n\\<rfloor> + 6) + 6 * real n + 5\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n \\<le> 20; x = n\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>20 < n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na.\n       \\<lbrakk>n \\<le> 20; na \\<le> 20; n = na\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 3. \\<And>n na.\n       \\<lbrakk>n \\<le> 20; 20 < na; n = na\\<rbrakk>\n       \\<Longrightarrow> 0 =\n                         select_cost'_sumC\n                          (nat \\<lfloor>real na / 5\\<rfloor>) +\n                         select_cost'_sumC\n                          (nat \\<lfloor>b * real na\\<rfloor> + 6) +\n                         6 * real na +\n                         5\n 4. \\<And>n na.\n       \\<lbrakk>20 < n; 20 < na; n = na\\<rbrakk>\n       \\<Longrightarrow> select_cost'_sumC\n                          (nat \\<lfloor>real n / 5\\<rfloor>) +\n                         select_cost'_sumC\n                          (nat \\<lfloor>b * real n\\<rfloor> + 6) +\n                         6 * real n +\n                         5 =\n                         select_cost'_sumC\n                          (nat \\<lfloor>real na / 5\\<rfloor>) +\n                         select_cost'_sumC\n                          (nat \\<lfloor>b * real na\\<rfloor> + 6) +\n                         6 * real na +\n                         5", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All select_cost'_dom", "using b"], ["proof (prove)\nusing this:\n  0 < b\n  b < 7 / 10\n\ngoal (1 subgoal):\n 1. All select_cost'_dom", "by akra_bazzi_termination simp_all"], ["", "lemma \"a \\<ge> 0 \\<Longrightarrow> select_cost' \\<in> \\<Theta>(\\<lambda>n. real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> a \\<Longrightarrow> select_cost' \\<in> \\<Theta>(real)", "using b"], ["proof (prove)\nusing this:\n  0 < b\n  b < 7 / 10\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> a \\<Longrightarrow> select_cost' \\<in> \\<Theta>(real)", "by (master_theorem 3, force+)"], ["", "end"], ["", "subsection \\<open>Non-curried functions\\<close>"], ["", "(* Note: either a or b could be seen as recursion variables. *)"], ["", "function baz_cost :: \"nat \\<times> nat \\<Rightarrow> real\" where\n  \"n \\<le> 2 \\<Longrightarrow> baz_cost (a, n) = 0\"\n| \"n > 2 \\<Longrightarrow> baz_cost (a, n) = 3 * baz_cost (a, nat \\<lfloor>real n / 2\\<rfloor>) + real a\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n a.\n                   \\<lbrakk>n \\<le> 2; x = (a, n)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>n a.\n           \\<lbrakk>2 < n; x = (a, n)\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n a na aa.\n       \\<lbrakk>n \\<le> 2; na \\<le> 2; (a, n) = (aa, na)\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 3. \\<And>n a na aa.\n       \\<lbrakk>n \\<le> 2; 2 < na; (a, n) = (aa, na)\\<rbrakk>\n       \\<Longrightarrow> 0 =\n                         3 *\n                         baz_cost_sumC\n                          (aa, nat \\<lfloor>real na / 2\\<rfloor>) +\n                         real aa\n 4. \\<And>n a na aa.\n       \\<lbrakk>2 < n; 2 < na; (a, n) = (aa, na)\\<rbrakk>\n       \\<Longrightarrow> 3 *\n                         baz_cost_sumC\n                          (a, nat \\<lfloor>real n / 2\\<rfloor>) +\n                         real a =\n                         3 *\n                         baz_cost_sumC\n                          (aa, nat \\<lfloor>real na / 2\\<rfloor>) +\n                         real aa", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All baz_cost_dom", "by akra_bazzi_termination simp_all"], ["", "lemma baz_cost_nonneg [simp]: \"a \\<ge> 0 \\<Longrightarrow> baz_cost (a, n) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<Longrightarrow> 0 \\<le> baz_cost (a, n)", "by (induction a n rule: baz_cost.induct[split_format (complete)]) simp_all"], ["", "lemma\n  assumes \"a > 0\"\n  shows   \"(\\<lambda>x. baz_cost (a, x)) \\<in> \\<Theta>(\\<lambda>x. x powr log 2 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. baz_cost (a, x))\n    \\<in> \\<Theta>(\\<lambda>x. real x powr log 2 3)", "proof (master_theorem 1 p': 0)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < Suc 2\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> baz_cost (a, x)\n 2. \\<And>x.\n       Suc 2 \\<le> x \\<Longrightarrow>\n       baz_cost (a, x) =\n       real a + 3 * baz_cost (a, nat \\<lfloor>real x / 2\\<rfloor>)\n 3. \\<And>x. Suc 2 \\<le> x \\<Longrightarrow> 0 \\<le> real a\n 4. (\\<lambda>n. real a) \\<in> O(\\<lambda>x. 1)\n 5. \\<forall>\\<^sub>F x in sequentially. 0 < baz_cost (a, x)\n 6. 3 * (1 / 2) powr log 2 3 = 1", "from assms"], ["proof (chain)\npicking this:\n  0 < a", "have \"\\<forall>x\\<ge>3. baz_cost (a, x) > 0\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<ge>3. 0 < baz_cost (a, x)", "by (auto intro: add_nonneg_pos)"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>3. 0 < baz_cost (a, x)\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < Suc 2\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> baz_cost (a, x)\n 2. \\<And>x.\n       Suc 2 \\<le> x \\<Longrightarrow>\n       baz_cost (a, x) =\n       real a + 3 * baz_cost (a, nat \\<lfloor>real x / 2\\<rfloor>)\n 3. \\<And>x. Suc 2 \\<le> x \\<Longrightarrow> 0 \\<le> real a\n 4. (\\<lambda>n. real a) \\<in> O(\\<lambda>x. 1)\n 5. \\<forall>\\<^sub>F x in sequentially. 0 < baz_cost (a, x)\n 6. 3 * (1 / 2) powr log 2 3 = 1", "thus \"eventually (\\<lambda>x. baz_cost (a, x) > 0) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<ge>3. 0 < baz_cost (a, x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially. 0 < baz_cost (a, x)", "by (force simp: eventually_at_top_linorder)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in sequentially. 0 < baz_cost (a, x)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < Suc 2\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> baz_cost (a, x)\n 2. \\<And>x.\n       Suc 2 \\<le> x \\<Longrightarrow>\n       baz_cost (a, x) =\n       real a + 3 * baz_cost (a, nat \\<lfloor>real x / 2\\<rfloor>)\n 3. \\<And>x. Suc 2 \\<le> x \\<Longrightarrow> 0 \\<le> real a\n 4. (\\<lambda>n. real a) \\<in> O(\\<lambda>x. 1)\n 5. 3 * (1 / 2) powr log 2 3 = 1", "qed (insert assms, simp_all add: powr_divide)"], ["", "(* Non-\"Akra-Bazzi\" variables may even be modified without impacting the termination proof.\n   However, the Akra-Bazzi theorem and the Master theorem itself do not apply anymore, \n   because bar_cost cannot be seen as a recursive function with one parameter *)"], ["", "function bar_cost :: \"nat \\<times> nat \\<Rightarrow> real\" where\n  \"n \\<le> 2 \\<Longrightarrow> bar_cost (a, n) = 0\"\n| \"n > 2 \\<Longrightarrow> bar_cost (a, n) = 3 * bar_cost (2 * a, nat \\<lfloor>real n / 2\\<rfloor>) + real a\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n a.\n                   \\<lbrakk>n \\<le> 2; x = (a, n)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>n a.\n           \\<lbrakk>2 < n; x = (a, n)\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n a na aa.\n       \\<lbrakk>n \\<le> 2; na \\<le> 2; (a, n) = (aa, na)\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 3. \\<And>n a na aa.\n       \\<lbrakk>n \\<le> 2; 2 < na; (a, n) = (aa, na)\\<rbrakk>\n       \\<Longrightarrow> 0 =\n                         3 *\n                         bar_cost_sumC\n                          (2 * aa, nat \\<lfloor>real na / 2\\<rfloor>) +\n                         real aa\n 4. \\<And>n a na aa.\n       \\<lbrakk>2 < n; 2 < na; (a, n) = (aa, na)\\<rbrakk>\n       \\<Longrightarrow> 3 *\n                         bar_cost_sumC\n                          (2 * a, nat \\<lfloor>real n / 2\\<rfloor>) +\n                         real a =\n                         3 *\n                         bar_cost_sumC\n                          (2 * aa, nat \\<lfloor>real na / 2\\<rfloor>) +\n                         real aa", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All bar_cost_dom", "by akra_bazzi_termination simp_all"], ["", "subsection \\<open>Ham-sandwich trees\\<close>"], ["", "(* f(n) = f(n/4) + f(n/2) + 1 *)"], ["", "function ham_sandwich_cost :: \"nat \\<Rightarrow> real\" where\n  \"n < 4 \\<Longrightarrow> ham_sandwich_cost n = 1\"\n| \"n \\<ge> 4 \\<Longrightarrow> ham_sandwich_cost n = \n      ham_sandwich_cost (nat \\<lfloor>n/4\\<rfloor>) + ham_sandwich_cost (nat \\<lfloor>n/2\\<rfloor>) + 1\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n. \\<lbrakk>n < 4; x = n\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>4 \\<le> n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na.\n       \\<lbrakk>n < 4; na < 4; n = na\\<rbrakk> \\<Longrightarrow> 1 = 1\n 3. \\<And>n na.\n       \\<lbrakk>n < 4; 4 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         ham_sandwich_cost_sumC\n                          (nat \\<lfloor>real na / 4\\<rfloor>) +\n                         ham_sandwich_cost_sumC\n                          (nat \\<lfloor>real na / 2\\<rfloor>) +\n                         1\n 4. \\<And>n na.\n       \\<lbrakk>4 \\<le> n; 4 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> ham_sandwich_cost_sumC\n                          (nat \\<lfloor>real n / 4\\<rfloor>) +\n                         ham_sandwich_cost_sumC\n                          (nat \\<lfloor>real n / 2\\<rfloor>) +\n                         1 =\n                         ham_sandwich_cost_sumC\n                          (nat \\<lfloor>real na / 4\\<rfloor>) +\n                         ham_sandwich_cost_sumC\n                          (nat \\<lfloor>real na / 2\\<rfloor>) +\n                         1", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All ham_sandwich_cost_dom", "by akra_bazzi_termination simp_all"], ["", "lemma ham_sandwich_cost_pos [simp]: \"ham_sandwich_cost n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ham_sandwich_cost n", "by (induction n rule: ham_sandwich_cost.induct) simp_all"], ["", "text \\<open>The golden ratio\\<close>"], ["", "definition \"\\<phi> = ((1 + sqrt 5) / 2 :: real)\""], ["", "lemma \\<phi>_pos [simp]: \"\\<phi> > 0\" and \\<phi>_nonneg [simp]: \"\\<phi> \\<ge> 0\" and \\<phi>_nonzero [simp]: \"\\<phi> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<phi> &&& 0 \\<le> \\<phi> &&& \\<phi> \\<noteq> 0", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < \\<phi>\n 2. 0 \\<le> \\<phi>\n 3. \\<phi> \\<noteq> 0", "show \"\\<phi> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<phi>", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (1 + sqrt 5) / 2", "by (simp add: add_pos_nonneg)"], ["proof (state)\nthis:\n  0 < \\<phi>\n\ngoal (2 subgoals):\n 1. 0 \\<le> \\<phi>\n 2. \\<phi> \\<noteq> 0", "thus \"\\<phi> \\<ge> 0\" \"\\<phi> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < \\<phi>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<phi> &&& \\<phi> \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  0 \\<le> \\<phi>\n  \\<phi> \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"ham_sandwich_cost \\<in> \\<Theta>(\\<lambda>n. n powr (log 2 \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ham_sandwich_cost \\<in> \\<Theta>(\\<lambda>x. real x powr log 2 \\<phi>)", "proof (master_theorem 1 p': 0)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x\n 7. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "have \"(1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> =\n            inverse (2 powr log 2 \\<phi>)^2 + inverse (2 powr log 2 \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> =\n    (inverse (2 powr log 2 \\<phi>))\\<^sup>2 + inverse (2 powr log 2 \\<phi>)", "by (simp add: powr_divide field_simps powr_powr power2_eq_square powr_mult[symmetric]\n                 del: powr_log_cancel)"], ["proof (state)\nthis:\n  (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> =\n  (inverse (2 powr log 2 \\<phi>))\\<^sup>2 + inverse (2 powr log 2 \\<phi>)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x\n 7. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "also"], ["proof (state)\nthis:\n  (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> =\n  (inverse (2 powr log 2 \\<phi>))\\<^sup>2 + inverse (2 powr log 2 \\<phi>)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x\n 7. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "have \"... = inverse (\\<phi>^2) + inverse \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse (2 powr log 2 \\<phi>))\\<^sup>2 +\n    inverse (2 powr log 2 \\<phi>) =\n    inverse (\\<phi>\\<^sup>2) + inverse \\<phi>", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (inverse (2 powr log 2 \\<phi>))\\<^sup>2 + inverse (2 powr log 2 \\<phi>) =\n  inverse (\\<phi>\\<^sup>2) + inverse \\<phi>\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x\n 7. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "also"], ["proof (state)\nthis:\n  (inverse (2 powr log 2 \\<phi>))\\<^sup>2 + inverse (2 powr log 2 \\<phi>) =\n  inverse (\\<phi>\\<^sup>2) + inverse \\<phi>\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x\n 7. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "have \"\\<phi> + 1 = \\<phi>*\\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> + 1 = \\<phi> * \\<phi>", "by (simp add: \\<phi>_def field_simps)"], ["proof (state)\nthis:\n  \\<phi> + 1 = \\<phi> * \\<phi>\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x\n 7. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "hence \"inverse (\\<phi>^2) + inverse \\<phi> = 1\""], ["proof (prove)\nusing this:\n  \\<phi> + 1 = \\<phi> * \\<phi>\n\ngoal (1 subgoal):\n 1. inverse (\\<phi>\\<^sup>2) + inverse \\<phi> = 1", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  inverse (\\<phi>\\<^sup>2) + inverse \\<phi> = 1\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x\n 7. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "finally"], ["proof (chain)\npicking this:\n  (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "show \"(1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1\""], ["proof (prove)\nusing this:\n  (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1\n\ngoal (1 subgoal):\n 1. (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1", "by simp"], ["proof (state)\nthis:\n  (1 / 4) powr log 2 \\<phi> + (1 / 2) powr log 2 \\<phi> = 1\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 4\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ham_sandwich_cost x\n 2. \\<And>x.\n       4 \\<le> x \\<Longrightarrow>\n       ham_sandwich_cost x =\n       1 +\n       (ham_sandwich_cost (nat \\<lfloor>real x / 4\\<rfloor>) +\n        ham_sandwich_cost (nat \\<lfloor>real x / 2\\<rfloor>))\n 3. \\<And>x. 4 \\<le> x \\<Longrightarrow> 0 \\<le> 1\n 4. 0 < (1 - 1 / 4) * 4\n 5. (\\<lambda>n. 1) \\<in> O(\\<lambda>x. 1)\n 6. \\<forall>\\<^sub>F x in sequentially. 0 < ham_sandwich_cost x", "qed simp_all"], ["", "end"]]}