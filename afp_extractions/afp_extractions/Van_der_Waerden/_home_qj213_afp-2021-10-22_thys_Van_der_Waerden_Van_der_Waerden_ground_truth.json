{"file_name": "/home/qj213/afp-2021-10-22/thys/Van_der_Waerden/Van_der_Waerden.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Van_der_Waerden", "problem_names": ["lemma multi_to_arith_prog: \n  \"multi_arith_prog 1 start steps c = \n    arith_prog start (steps 0) (c 0)\"", "lemma arith_prog_to_multi: \n  \"arith_prog start step c = \n    multi_arith_prog 1 start (\\<lambda>_. step) (\\<lambda>_. c)\"", "lemma arith_prog_mono: \n  assumes \"c \\<le> c'\"\n  shows   \"arith_prog start step c \\<le> arith_prog start step c'\"", "lemma is_arith_prog_onD:\n  assumes \"is_arith_prog_on l start step a b\"\n  assumes \"c \\<in> {0..<l}\"\n  shows   \"arith_prog start step c \\<in> {a..b}\"", "lemma multi_arith_prog_mono:\n  assumes \"\\<And>i. i < m \\<Longrightarrow> c i \\<le> c' i\"\n  shows   \"multi_arith_prog m start steps c \\<le> \n            multi_arith_prog m start steps c'\"", "lemma is_multi_arith_prog_onD:\n  assumes \"is_multi_arith_prog_on l m start steps a b\"\n  assumes \"c \\<in> {0..<m} \\<rightarrow> {0..<l}\"\n  shows   \"multi_arith_prog m start steps c \\<in> {a..b}\"", "lemma vdwE:\n  assumes \"vdw k l n\"\n          \"b + 1 \\<ge> a + int n\" \n          \"col \\<in> {a..b} \\<rightarrow> {..<k}\"\n  obtains j start step where\n    \"j < k\" \"step > 0\" \n    \"is_arith_prog_on l start step a b\"\n    \"arith_prog start step ` {..<l} \\<subseteq> col -` {j} \\<inter> {a..b}\"", "lemma vdw_imp_pos:\n  assumes \"vdw k l n\" \n          \"l > 0\"\n  shows \"n > 0\"", "lemma vdw_0_left [simp, intro]: \"n>0 \\<Longrightarrow> vdw 0 l n\"", "lemma vdw_1_left: \n  assumes \"l>0\" \n  shows \"vdw 1 l l\"", "lemma vdw_1_right: \"vdw k 1 1\"", "lemma vdw_2_right: \"vdw k 2 (k+1)\"", "lemma vdw_lemmaE:\n  fixes a b :: int\n  assumes \"vdw_lemma k m l n\"\n    \"b + 1 \\<ge> a + int n\" \"col \\<in> {a..b} \\<rightarrow> {..<k}\"\n  obtains start steps where\n    \"\\<And>i. i < m \\<Longrightarrow> steps i > 0\"\n    \"is_multi_arith_prog_on (l+1) m start steps a b\"\n    \"let f = multi_arith_prog m start steps\n     in  \\<forall>c \\<in> {0..<m} \\<rightarrow> {0..l}. \\<forall>s<m. (\\<forall> j \\<le> s. c j < l) \\<longrightarrow>\n            col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\"", "lemma sum_mod_poly: \n  assumes \"(k::nat)>0\" \n  shows \"(k - 1) * (\\<Sum> n\\<in>{..<q}. k^n) < k^q \"", "lemma vdw_imp_vdw_lemma:\n  fixes l\n  assumes vdw_assms: \"\\<And>k'. k'>0 \\<Longrightarrow> \\<exists>n_k'. vdw k' l n_k'\"\n    and \"l \\<ge> 2\"\n    and \"m > 0\"\n    and \"k > 0\"\n  shows   \"\\<exists>N. vdw_lemma k m l N\"", "lemma vdw_lemma_imp_vdw:\n  assumes \"vdw_lemma k k l N\"\n  shows   \"vdw k (Suc l) N\"", "theorem van_der_Waerden: assumes \"l>0\" \"k>0\" shows \"\\<exists>n. vdw k l n\""], "translations": [["", "lemma multi_to_arith_prog: \n  \"multi_arith_prog 1 start steps c = \n    arith_prog start (steps 0) (c 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multi_arith_prog 1 start steps c = arith_prog start (steps 0) (c 0)", "unfolding multi_arith_prog_def arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int (\\<Sum>i<1. c i * steps i) = start + int (c 0 * steps 0)", "by auto"], ["", "lemma arith_prog_to_multi: \n  \"arith_prog start step c = \n    multi_arith_prog 1 start (\\<lambda>_. step) (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step c =\n    multi_arith_prog 1 start (\\<lambda>_. step) (\\<lambda>_. c)", "unfolding multi_arith_prog_def arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int (c * step) = start + int (\\<Sum>i<1. c * step)", "by auto"], ["", "text \\<open>To show that an arithmetic progression is well-defined, we introduce the following predicate.\nIt assures that \\<open>arith_prog start step ` [0..<l]\\<close> is contained in the integer interval $[a..b]$.\\<close>"], ["", "definition is_arith_prog_on :: \n    \"nat \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" \n  where \"is_arith_prog_on l start step a b \\<longleftrightarrow>\n    (start \\<ge> a \\<and> arith_prog start step (l-1) \\<le> b)\""], ["", "text \\<open>Furthermore, we have monotonicity for arithmetic progressions.\\<close>"], ["", "lemma arith_prog_mono: \n  assumes \"c \\<le> c'\"\n  shows   \"arith_prog start step c \\<le> arith_prog start step c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step c \\<le> arith_prog start step c'", "using assms"], ["proof (prove)\nusing this:\n  c \\<le> c'\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<le> arith_prog start step c'", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  c \\<le> c'\n\ngoal (1 subgoal):\n 1. start + int (c * step) \\<le> start + int (c' * step)", "by (auto intro: mult_mono)"], ["", "text \\<open>Now, we state the well-definedness of an arithmetic progression of length $l$ in an integer\ninterval $[a..b]$. \nIndeed, \\<open>is_arith_prog_on\\<close> guarantees that every element of \\<open>arith_prog start step\\<close> of length $l$ \n  lies in $[a..b]$.\\<close>"], ["", "lemma is_arith_prog_onD:\n  assumes \"is_arith_prog_on l start step a b\"\n  assumes \"c \\<in> {0..<l}\"\n  shows   \"arith_prog start step c \\<in> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "have \"arith_prog start step 0 \\<le> arith_prog start step c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step 0 \\<le> arith_prog start step c", "by (rule arith_prog_mono) auto"], ["proof (state)\nthis:\n  arith_prog start step 0 \\<le> arith_prog start step c\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "hence \"arith_prog start step c \\<ge> a\""], ["proof (prove)\nusing this:\n  arith_prog start step 0 \\<le> arith_prog start step c\n\ngoal (1 subgoal):\n 1. a \\<le> arith_prog start step c", "using assms"], ["proof (prove)\nusing this:\n  arith_prog start step 0 \\<le> arith_prog start step c\n  is_arith_prog_on l start step a b\n  c \\<in> {0..<l}\n\ngoal (1 subgoal):\n 1. a \\<le> arith_prog start step c", "by (simp add: arith_prog_def is_arith_prog_on_def \n                      add_increasing2)"], ["proof (state)\nthis:\n  a \\<le> arith_prog start step c\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "moreover"], ["proof (state)\nthis:\n  a \\<le> arith_prog start step c\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "have \"arith_prog start step (l-1) \\<ge> \n                   arith_prog start step c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step c \\<le> arith_prog start step (l - 1)", "by (rule arith_prog_mono) (use assms(2) in auto)"], ["proof (state)\nthis:\n  arith_prog start step c \\<le> arith_prog start step (l - 1)\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "hence \"arith_prog start step c \\<le> b\""], ["proof (prove)\nusing this:\n  arith_prog start step c \\<le> arith_prog start step (l - 1)\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<le> b", "using assms"], ["proof (prove)\nusing this:\n  arith_prog start step c \\<le> arith_prog start step (l - 1)\n  is_arith_prog_on l start step a b\n  c \\<in> {0..<l}\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<le> b", "unfolding arith_prog_def is_arith_prog_on_def"], ["proof (prove)\nusing this:\n  start + int (c * step) \\<le> start + int ((l - 1) * step)\n  a \\<le> start \\<and> start + int ((l - 1) * step) \\<le> b\n  c \\<in> {0..<l}\n\ngoal (1 subgoal):\n 1. start + int (c * step) \\<le> b", "by linarith"], ["proof (state)\nthis:\n  arith_prog start step c \\<le> b\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> arith_prog start step c\n  arith_prog start step c \\<le> b", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> arith_prog start step c\n  arith_prog start step c \\<le> b\n\ngoal (1 subgoal):\n 1. arith_prog start step c \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  arith_prog start step c \\<in> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We also need a predicate for an $m$-fold arithmetic progression to be well-defined. \nIt assures that \\<open>multi_arith_prog start step ` [0..<l]^m\\<close> is contained in $[a..b]$.\\<close>"], ["", "definition is_multi_arith_prog_on :: \n    \"nat \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" \n  where \"is_multi_arith_prog_on l m start steps a b \\<longleftrightarrow>\n     (start \\<ge> a \\<and> multi_arith_prog m start steps (\\<lambda>_. l-1) \\<le> b)\""], ["", "text \\<open>Moreover, we have monotonicity for $m$-fold arithmetic progressions as well.\\<close>"], ["", "lemma multi_arith_prog_mono:\n  assumes \"\\<And>i. i < m \\<Longrightarrow> c i \\<le> c' i\"\n  shows   \"multi_arith_prog m start steps c \\<le> \n            multi_arith_prog m start steps c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<le> multi_arith_prog m start steps c'", "using assms"], ["proof (prove)\nusing this:\n  ?i < m \\<Longrightarrow> c ?i \\<le> c' ?i\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<le> multi_arith_prog m start steps c'", "unfolding multi_arith_prog_def"], ["proof (prove)\nusing this:\n  ?i < m \\<Longrightarrow> c ?i \\<le> c' ?i\n\ngoal (1 subgoal):\n 1. start + int (\\<Sum>i<m. c i * steps i)\n    \\<le> start + int (\\<Sum>i<m. c' i * steps i)", "by (auto intro!: sum_mono intro: mult_right_mono)"], ["", "text \\<open>Finally, we get the well-definedness for $m$-fold arithmetic progressions of length $l$.\nHere, \\<open>is_multi_arith_prog_on\\<close> guarantees that every element of \\<open>multi_arith_prog start step\\<close> \n  of length $l$ lies in $[a..b]$.\\<close>"], ["", "lemma is_multi_arith_prog_onD:\n  assumes \"is_multi_arith_prog_on l m start steps a b\"\n  assumes \"c \\<in> {0..<m} \\<rightarrow> {0..<l}\"\n  shows   \"multi_arith_prog m start steps c \\<in> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "have \"multi_arith_prog m start steps (\\<lambda>_. 0) \\<le> \n          multi_arith_prog m start steps c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps (\\<lambda>_. 0)\n    \\<le> multi_arith_prog m start steps c", "by (rule multi_arith_prog_mono) auto"], ["proof (state)\nthis:\n  multi_arith_prog m start steps (\\<lambda>_. 0)\n  \\<le> multi_arith_prog m start steps c\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "hence \"multi_arith_prog m start steps c \\<ge> a\""], ["proof (prove)\nusing this:\n  multi_arith_prog m start steps (\\<lambda>_. 0)\n  \\<le> multi_arith_prog m start steps c\n\ngoal (1 subgoal):\n 1. a \\<le> multi_arith_prog m start steps c", "using assms"], ["proof (prove)\nusing this:\n  multi_arith_prog m start steps (\\<lambda>_. 0)\n  \\<le> multi_arith_prog m start steps c\n  is_multi_arith_prog_on l m start steps a b\n  c \\<in> {0..<m} \\<rightarrow> {0..<l}\n\ngoal (1 subgoal):\n 1. a \\<le> multi_arith_prog m start steps c", "by (simp add: multi_arith_prog_def \n       is_multi_arith_prog_on_def)"], ["proof (state)\nthis:\n  a \\<le> multi_arith_prog m start steps c\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "moreover"], ["proof (state)\nthis:\n  a \\<le> multi_arith_prog m start steps c\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "have \"multi_arith_prog m start steps (\\<lambda>_. l-1) \\<ge> \n                   multi_arith_prog m start steps c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c\n    \\<le> multi_arith_prog m start steps (\\<lambda>_. l - 1)", "by (rule multi_arith_prog_mono) (use assms in force)"], ["proof (state)\nthis:\n  multi_arith_prog m start steps c\n  \\<le> multi_arith_prog m start steps (\\<lambda>_. l - 1)\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "hence \"multi_arith_prog m start steps c \\<le> b\""], ["proof (prove)\nusing this:\n  multi_arith_prog m start steps c\n  \\<le> multi_arith_prog m start steps (\\<lambda>_. l - 1)\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<le> b", "using assms"], ["proof (prove)\nusing this:\n  multi_arith_prog m start steps c\n  \\<le> multi_arith_prog m start steps (\\<lambda>_. l - 1)\n  is_multi_arith_prog_on l m start steps a b\n  c \\<in> {0..<m} \\<rightarrow> {0..<l}\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<le> b", "by (simp add: multi_arith_prog_def \n        is_multi_arith_prog_on_def)"], ["proof (state)\nthis:\n  multi_arith_prog m start steps c \\<le> b\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> multi_arith_prog m start steps c\n  multi_arith_prog m start steps c \\<le> b", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> multi_arith_prog m start steps c\n  multi_arith_prog m start steps c \\<le> b\n\ngoal (1 subgoal):\n 1. multi_arith_prog m start steps c \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  multi_arith_prog m start steps c \\<in> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Van der Waerden's Theorem\\<close>"], ["", "text \\<open>The property for a number $n$ to fulfill Van der Waerden's theorem is the following:\\\\\nFor a $k$-colouring col of $[a..b]$ there exist\n\\begin{itemize}\n\\item $start$: starting value of an arithmetic progression\n\\item $step$:  step length of an arithmetic progression\n\\item $j$: colour \n\\end{itemize}\nsuch that \\<open>arith_prog start step\\<close> is a valid arithmetic progression of length $l$ lying \nin $[a..b]$ of the same colour $j$.\n\nThe following variables will be used:\\\\\n\\begin{tabular}{lcp{8cm}}\n$k$:& \\<open>nat\\<close>& number of colours in segment colouring on $[a..b]$\\\\\n$l$:& \\<open>nat\\<close>& length of arithmetic progression\\\\\n$n$:& \\<open>nat\\<close>& number fulfilling Van der Waerden's Theorem\\\\\n\\end{tabular}\n\\<close>"], ["", "definition vdw :: \n    \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" \n  where \"vdw k l n \\<longleftrightarrow>\n     (\\<forall>a b col. b + 1 \\<ge> a + int n \\<and> col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n       (\\<exists>j start step. j < k \\<and> step > 0 \\<and> \n        is_arith_prog_on l start step a b \\<and>\n        arith_prog start step ` {..<l} \\<subseteq> col -` {j} \\<inter> {a..b}))\""], ["", "text \\<open>To better work with the property of Van der Waerden's theorem, we introduce an \n  elimination rule.\\<close>"], ["", "lemma vdwE:\n  assumes \"vdw k l n\"\n          \"b + 1 \\<ge> a + int n\" \n          \"col \\<in> {a..b} \\<rightarrow> {..<k}\"\n  obtains j start step where\n    \"j < k\" \"step > 0\" \n    \"is_arith_prog_on l start step a b\"\n    \"arith_prog start step ` {..<l} \\<subseteq> col -` {j} \\<inter> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k; 0 < step; is_arith_prog_on l start step a b;\n         arith_prog start step ` {..<l}\n         \\<subseteq> col -` {j} \\<inter> {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms that"], ["proof (prove)\nusing this:\n  vdw k l n\n  a + int n \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  \\<lbrakk>?j < k; 0 < ?step; is_arith_prog_on l ?start ?step a b;\n   arith_prog ?start ?step ` {..<l}\n   \\<subseteq> col -` {?j} \\<inter> {a..b}\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k; 0 < step; is_arith_prog_on l start step a b;\n         arith_prog start step ` {..<l}\n         \\<subseteq> col -` {j} \\<inter> {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vdw_def"], ["proof (prove)\nusing this:\n  \\<forall>a b col.\n     a + int n \\<le> b + 1 \\<and>\n     col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n     (\\<exists>j start step.\n         j < k \\<and>\n         0 < step \\<and>\n         is_arith_prog_on l start step a b \\<and>\n         arith_prog start step ` {..<l}\n         \\<subseteq> col -` {j} \\<inter> {a..b})\n  a + int n \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  \\<lbrakk>?j < k; 0 < ?step; is_arith_prog_on l ?start ?step a b;\n   arith_prog ?start ?step ` {..<l}\n   \\<subseteq> col -` {?j} \\<inter> {a..b}\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k; 0 < step; is_arith_prog_on l start step a b;\n         arith_prog start step ` {..<l}\n         \\<subseteq> col -` {j} \\<inter> {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "text \\<open>Van der Waerden's theorem implies that the number fulfilling it is positive. This is show \nin the following lemma.\\<close>"], ["", "lemma vdw_imp_pos:\n  assumes \"vdw k l n\" \n          \"l > 0\"\n  shows \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "proof (rule Nat.gr0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "assume [simp]: \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  vdw k l n\n  0 < l\n\ngoal (1 subgoal):\n 1. False", "by (elim vdwE[where a = 1 and b = 0 and col = \"\\<lambda>_. 0\"]) \n       (auto simp: lessThan_empty_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Van der Waerden's Theorem is trivial for a non-existent colouring. \nIt also makes no sense for arithmetic progressions of length 0.\\<close>"], ["", "lemma vdw_0_left [simp, intro]: \"n>0 \\<Longrightarrow> vdw 0 l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> vdw 0 l n", "by (auto simp: vdw_def)"], ["", "text \\<open>In the case of $k=1$, Van der Waerden's Theorem holds. Then every number has the same colour,\nhence also the arithmetic progression. A possible choice for the number fulfilling Van der \nWaerden Theorem is $l$.\\<close>"], ["", "lemma vdw_1_left: \n  assumes \"l>0\" \n  shows \"vdw 1 l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vdw 1 l l", "unfolding vdw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b col.\n       a + int l \\<le> b + 1 \\<and>\n       col \\<in> {a..b} \\<rightarrow> {..<1} \\<longrightarrow>\n       (\\<exists>j start step.\n           j < 1 \\<and>\n           0 < step \\<and>\n           is_arith_prog_on l start step a b \\<and>\n           arith_prog start step ` {..<l}\n           \\<subseteq> col -` {j} \\<inter> {a..b})", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "case (1 a b col)"], ["proof (state)\nthis:\n  a + int l \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"arith_prog a 1 ` {..<l} \\<subseteq> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog a 1 ` {..<l} \\<subseteq> {a..b}", "using 1(1)"], ["proof (prove)\nusing this:\n  a + int l \\<le> b + 1\n\ngoal (1 subgoal):\n 1. arith_prog a 1 ` {..<l} \\<subseteq> {a..b}", "by (auto simp: arith_prog_def)"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<l} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "also"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<l} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"{a..b} = col -` {0} \\<inter> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a..b} = col -` {0} \\<inter> {a..b}", "using 1(2)"], ["proof (prove)\nusing this:\n  col \\<in> {a..b} \\<rightarrow> {..<1}\n\ngoal (1 subgoal):\n 1. {a..b} = col -` {0} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  {a..b} = col -` {0} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "finally"], ["proof (chain)\npicking this:\n  arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}", "have \"arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}\""], ["proof (prove)\nusing this:\n  arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "moreover"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"is_arith_prog_on l a 1 a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arith_prog_on l a 1 a b", "unfolding is_arith_prog_on_def arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> a \\<and> a + int ((l - 1) * 1) \\<le> b", "using 1 assms"], ["proof (prove)\nusing this:\n  a + int l \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<1}\n  0 < l\n\ngoal (1 subgoal):\n 1. a \\<le> a \\<and> a + int ((l - 1) * 1) \\<le> b", "by auto"], ["proof (state)\nthis:\n  is_arith_prog_on l a 1 a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int l \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < 1 \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on l start step a b \\<and>\n                            arith_prog start step ` {..<l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}\n  is_arith_prog_on l a 1 a b", "show \"\\<exists>j start step. j < 1 \\<and> 0 < step \\<and> \n        is_arith_prog_on l start step a b \\<and>\n        arith_prog start step ` {..<l} \\<subseteq> col -` {j} \\<inter> {a..b}\""], ["proof (prove)\nusing this:\n  arith_prog a 1 ` {..<l} \\<subseteq> col -` {0} \\<inter> {a..b}\n  is_arith_prog_on l a 1 a b\n\ngoal (1 subgoal):\n 1. \\<exists>j start step.\n       j < 1 \\<and>\n       0 < step \\<and>\n       is_arith_prog_on l start step a b \\<and>\n       arith_prog start step ` {..<l} \\<subseteq> col -` {j} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  \\<exists>j start step.\n     j < 1 \\<and>\n     0 < step \\<and>\n     is_arith_prog_on l start step a b \\<and>\n     arith_prog start step ` {..<l} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the case $l=1$, Van der Waerden's Theorem holds. As the length of the arithmetic \nprogression is $1$, it consists of just one element. Thus every nonempty integer interval fulfills \nthe Van der Waerden property. We can prove $N_{k,1}$ to be $1$.\\<close>"], ["", "lemma vdw_1_right: \"vdw k 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vdw k 1 1", "unfolding vdw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b col.\n       a + int 1 \\<le> b + 1 \\<and>\n       col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n       (\\<exists>j start step.\n           j < k \\<and>\n           0 < step \\<and>\n           is_arith_prog_on 1 start step a b \\<and>\n           arith_prog start step ` {..<1}\n           \\<subseteq> col -` {j} \\<inter> {a..b})", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "fix a b :: int and col :: \"int \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "assume *: \"a + int 1 \\<le> b + 1\" \"col \\<in> {a..b} \\<rightarrow> {..<k}\""], ["proof (state)\nthis:\n  a + int 1 \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"col a < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col a < k", "using *"], ["proof (prove)\nusing this:\n  a + int 1 \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. col a < k", "by auto"], ["proof (state)\nthis:\n  col a < k\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"arith_prog a 1 ` {..<1} = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog a 1 ` {..<1} = {a}", "using *(1)"], ["proof (prove)\nusing this:\n  a + int 1 \\<le> b + 1\n\ngoal (1 subgoal):\n 1. arith_prog a 1 ` {..<1} = {a}", "by (auto simp: arith_prog_def)"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<1} = {a}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "also"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<1} = {a}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"{a} \\<subseteq> col -` {col a} \\<inter> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<subseteq> col -` {col a} \\<inter> {a..b}", "using *"], ["proof (prove)\nusing this:\n  a + int 1 \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. {a} \\<subseteq> col -` {col a} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  {a} \\<subseteq> col -` {col a} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "finally"], ["proof (chain)\npicking this:\n  arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}", "have \"arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}\""], ["proof (prove)\nusing this:\n  arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "moreover"], ["proof (state)\nthis:\n  arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"is_arith_prog_on 1 a 1 a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arith_prog_on 1 a 1 a b", "unfolding is_arith_prog_on_def arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> a \\<and> a + int ((1 - 1) * 1) \\<le> b", "using *"], ["proof (prove)\nusing this:\n  a + int 1 \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. a \\<le> a \\<and> a + int ((1 - 1) * 1) \\<le> b", "by auto"], ["proof (state)\nthis:\n  is_arith_prog_on 1 a 1 a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int 1 \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 1 start step a b \\<and>\n                            arith_prog start step ` {..<1}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}\n  is_arith_prog_on 1 a 1 a b", "show  \"\\<exists>j start step.\n          j < k \\<and> 0 < step \\<and> is_arith_prog_on 1 start step a b \\<and>\n          arith_prog start step ` {..<1} \\<subseteq> col -` {j} \\<inter> {a..b}\""], ["proof (prove)\nusing this:\n  arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}\n  is_arith_prog_on 1 a 1 a b\n\ngoal (1 subgoal):\n 1. \\<exists>j start step.\n       j < k \\<and>\n       0 < step \\<and>\n       is_arith_prog_on 1 start step a b \\<and>\n       arith_prog start step ` {..<1} \\<subseteq> col -` {j} \\<inter> {a..b}", "using \\<open>col a <k\\<close>"], ["proof (prove)\nusing this:\n  arith_prog a 1 ` {..<1} \\<subseteq> col -` {col a} \\<inter> {a..b}\n  is_arith_prog_on 1 a 1 a b\n  col a < k\n\ngoal (1 subgoal):\n 1. \\<exists>j start step.\n       j < k \\<and>\n       0 < step \\<and>\n       is_arith_prog_on 1 start step a b \\<and>\n       arith_prog start step ` {..<1} \\<subseteq> col -` {j} \\<inter> {a..b}", "by blast"], ["proof (state)\nthis:\n  \\<exists>j start step.\n     j < k \\<and>\n     0 < step \\<and>\n     is_arith_prog_on 1 start step a b \\<and>\n     arith_prog start step ` {..<1} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the case $l=2$, Van der Waerden's Theorem holds as well. Here, any two distinct numbers \nform an arithmetic progression of length $2$. Thus we only have to find two numbers with the same \ncolour.\nUsing the pigeonhole principle on $k+1$ values, we can find two integers with the same colour.\\<close>"], ["", "lemma vdw_2_right: \"vdw k 2 (k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vdw k 2 (k + 1)", "unfolding vdw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b col.\n       a + int (k + 1) \\<le> b + 1 \\<and>\n       col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n       (\\<exists>j start step.\n           j < k \\<and>\n           0 < step \\<and>\n           is_arith_prog_on 2 start step a b \\<and>\n           arith_prog start step ` {..<2}\n           \\<subseteq> col -` {j} \\<inter> {a..b})", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "fix a b :: int and col :: \"int \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "assume *: \"a + int (k + 1) \\<le> b + 1\" \"col \\<in> {a..b} \\<rightarrow> {..<k}\""], ["proof (state)\nthis:\n  a + int (k + 1) \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"col ` {a..b} \\<subseteq> {..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col ` {a..b} \\<subseteq> {..<k}", "using *(2)"], ["proof (prove)\nusing this:\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. col ` {a..b} \\<subseteq> {..<k}", "by auto"], ["proof (state)\nthis:\n  col ` {a..b} \\<subseteq> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "moreover"], ["proof (state)\nthis:\n  col ` {a..b} \\<subseteq> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"k+1 \\<le> card {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k + 1 \\<le> card {a..b}", "using *(1)"], ["proof (prove)\nusing this:\n  a + int (k + 1) \\<le> b + 1\n\ngoal (1 subgoal):\n 1. k + 1 \\<le> card {a..b}", "by auto"], ["proof (state)\nthis:\n  k + 1 \\<le> card {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  col ` {a..b} \\<subseteq> {..<k}\n  k + 1 \\<le> card {a..b}", "have \"card (col ` {a..b}) < card {a..b}\""], ["proof (prove)\nusing this:\n  col ` {a..b} \\<subseteq> {..<k}\n  k + 1 \\<le> card {a..b}\n\ngoal (1 subgoal):\n 1. card (col ` {a..b}) < card {a..b}", "using *"], ["proof (prove)\nusing this:\n  col ` {a..b} \\<subseteq> {..<k}\n  k + 1 \\<le> card {a..b}\n  a + int (k + 1) \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. card (col ` {a..b}) < card {a..b}", "by (metis card_lessThan card_mono finite_lessThan le_less_trans \n        less_add_one not_le)"], ["proof (state)\nthis:\n  card (col ` {a..b}) < card {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "then"], ["proof (chain)\npicking this:\n  card (col ` {a..b}) < card {a..b}", "have \"\\<not> inj_on col {a..b}\""], ["proof (prove)\nusing this:\n  card (col ` {a..b}) < card {a..b}\n\ngoal (1 subgoal):\n 1. \\<not> inj_on col {a..b}", "using pigeonhole[of col \"{a..b}\"]"], ["proof (prove)\nusing this:\n  card (col ` {a..b}) < card {a..b}\n  card (col ` {a..b}) < card {a..b} \\<Longrightarrow>\n  \\<not> inj_on col {a..b}\n\ngoal (1 subgoal):\n 1. \\<not> inj_on col {a..b}", "by auto"], ["proof (state)\nthis:\n  \\<not> inj_on col {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "then"], ["proof (chain)\npicking this:\n  \\<not> inj_on col {a..b}", "obtain start start_step \n    where pigeon: \"col start = col start_step\" \n      \"start < start_step\"\n      \"start \\<in> {a..b}\" \n      \"start_step \\<in> {a..b}\""], ["proof (prove)\nusing this:\n  \\<not> inj_on col {a..b}\n\ngoal (1 subgoal):\n 1. (\\<And>start start_step.\n        \\<lbrakk>col start = col start_step; start < start_step;\n         start \\<in> {a..b}; start_step \\<in> {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inj_onI[of \"{a..b}\" col]"], ["proof (prove)\nusing this:\n  \\<not> inj_on col {a..b}\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> {a..b}; y \\<in> {a..b}; col x = col y\\<rbrakk>\n      \\<Longrightarrow> x = y) \\<Longrightarrow>\n  inj_on col {a..b}\n\ngoal (1 subgoal):\n 1. (\\<And>start start_step.\n        \\<lbrakk>col start = col start_step; start < start_step;\n         start \\<in> {a..b}; start_step \\<in> {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  col start = col start_step\n  start < start_step\n  start \\<in> {a..b}\n  start_step \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define step where \"step = nat (start_step - start)\""], ["proof (state)\nthis:\n  step = nat (start_step - start)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define j where \"j = col start\""], ["proof (state)\nthis:\n  j = col start\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"j < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < k", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col start < k", "using *(2) pigeon(3)"], ["proof (prove)\nusing this:\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  start \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. col start < k", "by auto"], ["proof (state)\nthis:\n  j < k\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "moreover"], ["proof (state)\nthis:\n  j < k\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"0 < step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < step", "unfolding step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < nat (start_step - start)", "using pigeon(2)"], ["proof (prove)\nusing this:\n  start < start_step\n\ngoal (1 subgoal):\n 1. 0 < nat (start_step - start)", "by auto"], ["proof (state)\nthis:\n  0 < step\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "moreover"], ["proof (state)\nthis:\n  0 < step\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"is_arith_prog_on 2 start step a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arith_prog_on 2 start step a b", "unfolding is_arith_prog_on_def arith_prog_def step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> start \\<and>\n    start + int ((2 - 1) * nat (start_step - start)) \\<le> b", "using pigeon"], ["proof (prove)\nusing this:\n  col start = col start_step\n  start < start_step\n  start \\<in> {a..b}\n  start_step \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. a \\<le> start \\<and>\n    start + int ((2 - 1) * nat (start_step - start)) \\<le> b", "by auto"], ["proof (state)\nthis:\n  is_arith_prog_on 2 start step a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "moreover"], ["proof (state)\nthis:\n  is_arith_prog_on 2 start step a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "{"], ["proof (state)\nthis:\n  is_arith_prog_on 2 start step a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"arith_prog start step i \\<in> {start, start_step}\" if \"i<2\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {start, start_step}", "using that arith_prog_def step_def"], ["proof (prove)\nusing this:\n  i < 2\n  arith_prog ?start ?step ?i = ?start + int (?i * ?step)\n  step = nat (start_step - start)\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {start, start_step}", "by (auto simp: less_2_cases_iff)"], ["proof (state)\nthis:\n  ?i < 2 \\<Longrightarrow>\n  arith_prog start step ?i \\<in> {start, start_step}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "also"], ["proof (state)\nthis:\n  ?i < 2 \\<Longrightarrow>\n  arith_prog start step ?i \\<in> {start, start_step}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"\\<dots> \\<subseteq> col -` {j} \\<inter> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {start, start_step} \\<subseteq> col -` {j} \\<inter> {a..b}", "using pigeon"], ["proof (prove)\nusing this:\n  col start = col start_step\n  start < start_step\n  start \\<in> {a..b}\n  start_step \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. {start, start_step} \\<subseteq> col -` {j} \\<inter> {a..b}", "unfolding j_def"], ["proof (prove)\nusing this:\n  col start = col start_step\n  start < start_step\n  start \\<in> {a..b}\n  start_step \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. {start, start_step} \\<subseteq> col -` {col start} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  {start, start_step} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "finally"], ["proof (chain)\npicking this:\n  ?i1 < 2 \\<Longrightarrow>\n  arith_prog start step ?i1 \\<in> col -` {j} \\<inter> {a..b}", "have \"arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}\""], ["proof (prove)\nusing this:\n  ?i1 < 2 \\<Longrightarrow>\n  arith_prog start step ?i1 \\<in> col -` {j} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "}"], ["proof (state)\nthis:\n  arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int (k + 1) \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on 2 start step a b \\<and>\n                            arith_prog start step ` {..<2}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  j < k\n  0 < step\n  is_arith_prog_on 2 start step a b\n  arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}", "show \"\\<exists>j start step.\n          j < k \\<and>\n          0 < step \\<and>\n          is_arith_prog_on 2 start step a b \\<and>\n          arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}\""], ["proof (prove)\nusing this:\n  j < k\n  0 < step\n  is_arith_prog_on 2 start step a b\n  arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<exists>j start step.\n       j < k \\<and>\n       0 < step \\<and>\n       is_arith_prog_on 2 start step a b \\<and>\n       arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}", "by blast"], ["proof (state)\nthis:\n  \\<exists>j start step.\n     j < k \\<and>\n     0 < step \\<and>\n     is_arith_prog_on 2 start step a b \\<and>\n     arith_prog start step ` {..<2} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In order to prove Van der Waerden's Theorem, we first prove a slightly different lemma.\nThe statement goes as follows:\\\\\nFor a $k$-colouring $col$ on $[a..b]$ there exist\n\\begin{itemize}\n\\item  $start$: starting value of an arithmetic progression\n\\item  $steps$: step length of an arithmetic progression\n\\end{itemize}\nsuch that \\<open>f = multi_arith_prog m start step\\<close> is a valid $m$-fold arithmetic progression of \nlength $l$ lying in $[a..b]$ such that for every $s<m$ have: if $c j < l$ for all $j\\leq s$ then\n$f(c_0, c_1, \\dots, c_{m-1})$ and $f(0,\\dots,0, c_{s+1},\\dots, c_{m-1})$ have the same colour.\n\nThe property of the lemma uses the following variables:\\\\\n\\begin{tabular}{lcp{8cm}}\n$k$:& \\<open>nat\\<close>& number of colours in segment colouring of $[a..b]$\\\\\n$m$:& \\<open>nat\\<close>& dimension of $m$-fold arithmetic progression\\\\\n$l$:& \\<open>nat\\<close>& $l+1$ is length of $m$-fold arithmetic progression\\\\\n$n$:& \\<open>nat\\<close>& number fulfilling \\<open>vdw_lemma\\<close>\\\\\n\\end{tabular}\n\\<close>"], ["", "definition vdw_lemma :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"vdw_lemma k m l n \\<longleftrightarrow>\n     (\\<forall>a b col. b + 1 \\<ge> a + int n \\<and> col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n       (\\<exists>start steps. (\\<forall>i<m. steps i > 0) \\<and> \n        is_multi_arith_prog_on (l+1) m start steps a b \\<and> (\n           let f = multi_arith_prog m start steps\n           in  (\\<forall>c \\<in> {0..<m} \\<rightarrow> {0..l}. \\<forall>s<m. (\\<forall> j \\<le> s. c j < l) \\<longrightarrow>\n                  col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))))))\""], ["", "text \\<open>To better work with this property, we introduce an elimination rule for \\<open>vdw_lemma\\<close>.\\<close>"], ["", "lemma vdw_lemmaE:\n  fixes a b :: int\n  assumes \"vdw_lemma k m l n\"\n    \"b + 1 \\<ge> a + int n\" \"col \\<in> {a..b} \\<rightarrow> {..<k}\"\n  obtains start steps where\n    \"\\<And>i. i < m \\<Longrightarrow> steps i > 0\"\n    \"is_multi_arith_prog_on (l+1) m start steps a b\"\n    \"let f = multi_arith_prog m start steps\n     in  \\<forall>c \\<in> {0..<m} \\<rightarrow> {0..l}. \\<forall>s<m. (\\<forall> j \\<le> s. c j < l) \\<longrightarrow>\n            col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>steps start.\n        \\<lbrakk>\\<And>i. i < m \\<Longrightarrow> 0 < steps i;\n         is_multi_arith_prog_on (l + 1) m start steps a b;\n         let f = multi_arith_prog m start steps\n         in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n               \\<forall>s<m.\n                  (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                  col (f c) =\n                  col (f (\\<lambda>i.\n                             if i \\<le> s then 0 else c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms that"], ["proof (prove)\nusing this:\n  vdw_lemma k m l n\n  a + int n \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  \\<lbrakk>\\<And>i. i < m \\<Longrightarrow> 0 < ?steps i;\n   is_multi_arith_prog_on (l + 1) m ?start ?steps a b;\n   let f = multi_arith_prog m ?start ?steps\n   in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n         \\<forall>s<m.\n            (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n            col (f c) =\n            col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>steps start.\n        \\<lbrakk>\\<And>i. i < m \\<Longrightarrow> 0 < steps i;\n         is_multi_arith_prog_on (l + 1) m start steps a b;\n         let f = multi_arith_prog m start steps\n         in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n               \\<forall>s<m.\n                  (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                  col (f c) =\n                  col (f (\\<lambda>i.\n                             if i \\<le> s then 0 else c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vdw_lemma_def"], ["proof (prove)\nusing this:\n  \\<forall>a b col.\n     a + int n \\<le> b + 1 \\<and>\n     col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n     (\\<exists>start steps.\n         (\\<forall>i<m. 0 < steps i) \\<and>\n         is_multi_arith_prog_on (l + 1) m start steps a b \\<and>\n         (let f = multi_arith_prog m start steps\n          in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                \\<forall>s<m.\n                   (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                   col (f c) =\n                   col (f (\\<lambda>i. if i \\<le> s then 0 else c i))))\n  a + int n \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  \\<lbrakk>\\<And>i. i < m \\<Longrightarrow> 0 < ?steps i;\n   is_multi_arith_prog_on (l + 1) m ?start ?steps a b;\n   let f = multi_arith_prog m ?start ?steps\n   in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n         \\<forall>s<m.\n            (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n            col (f c) =\n            col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>steps start.\n        \\<lbrakk>\\<And>i. i < m \\<Longrightarrow> 0 < steps i;\n         is_multi_arith_prog_on (l + 1) m start steps a b;\n         let f = multi_arith_prog m start steps\n         in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n               \\<forall>s<m.\n                  (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                  col (f c) =\n                  col (f (\\<lambda>i.\n                             if i \\<le> s then 0 else c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "text \\<open>To simplify the following proof, we show the following formula.\\<close>"], ["", "lemma sum_mod_poly: \n  assumes \"(k::nat)>0\" \n  shows \"(k - 1) * (\\<Sum> n\\<in>{..<q}. k^n) < k^q \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "have \"int ((k - 1) * (\\<Sum>n<q. k ^ n)) = \n        (int k - 1) * (\\<Sum>n<q. int k ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((k - 1) * sum ((^) k) {..<q}) =\n    (int k - 1) * sum ((^) (int k)) {..<q}", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. int ((k - 1) * sum ((^) k) {..<q}) =\n    (int k - 1) * sum ((^) (int k)) {..<q}", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  int ((k - 1) * sum ((^) k) {..<q}) =\n  (int k - 1) * sum ((^) (int k)) {..<q}\n\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "also"], ["proof (state)\nthis:\n  int ((k - 1) * sum ((^) k) {..<q}) =\n  (int k - 1) * sum ((^) (int k)) {..<q}\n\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "have \"\\<dots> = int k ^ q - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int k - 1) * sum ((^) (int k)) {..<q} = int k ^ q - 1", "by (induction q) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (int k - 1) * sum ((^) (int k)) {..<q} = int k ^ q - 1\n\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "also"], ["proof (state)\nthis:\n  (int k - 1) * sum ((^) (int k)) {..<q} = int k ^ q - 1\n\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "have \"\\<dots> < int (k ^ q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int k ^ q - 1 < int (k ^ q)", "by simp"], ["proof (state)\nthis:\n  int k ^ q - 1 < int (k ^ q)\n\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "finally"], ["proof (chain)\npicking this:\n  int ((k - 1) * sum ((^) k) {..<q}) < int (k ^ q)", "show ?thesis"], ["proof (prove)\nusing this:\n  int ((k - 1) * sum ((^) k) {..<q}) < int (k ^ q)\n\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "by linarith"], ["proof (state)\nthis:\n  (k - 1) * sum ((^) k) {..<q} < k ^ q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The proof of Van der Waerden's Theorem now proceeds in three steps:\\\\\n\\begin{itemize}\n\\item Firstly, we show that the \\<open>vdw\\<close> property for all $k$ proves the \\<open>vdw_lemma\\<close> for fixed $l$ but \narbitrary $k$ and $m$. This is done by induction over $m$.\n\\item Secondly, we show that \\<open>vdw_lemma\\<close> implies the induction step of \\<open>vdw\\<close> using the pigeonhole \nprinciple.\n\\item Lastly, we combine the previous steps in an induction over $l$ to show Van der Waerden's \nTheorem in the general setting.\n\\end{itemize}\\<close>"], ["", "text \\<open>Firstly, we need to show that \\<open>vdw\\<close> for arbitrary $k$ implies \\<open>vdw_lemma\\<close> for fixed $l$.\nAs mentioned earlier, we use induction over $m$.\\<close>"], ["", "lemma vdw_imp_vdw_lemma:\n  fixes l\n  assumes vdw_assms: \"\\<And>k'. k'>0 \\<Longrightarrow> \\<exists>n_k'. vdw k' l n_k'\"\n    and \"l \\<ge> 2\"\n    and \"m > 0\"\n    and \"k > 0\"\n  shows   \"\\<exists>N. vdw_lemma k m l N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. vdw_lemma k m l N", "using \\<open>m>0\\<close> \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  0 < m\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>N. vdw_lemma k m l N", "proof (induction m rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y; 0 < k\\<rbrakk>\n                   \\<Longrightarrow> Ex (vdw_lemma k y l);\n        0 < x; 0 < k\\<rbrakk>\n       \\<Longrightarrow> Ex (vdw_lemma k x l)", "case (less m)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < m; 0 < ?y; 0 < k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. vdw_lemma k ?y l a\n  0 < m\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y; 0 < k\\<rbrakk>\n                   \\<Longrightarrow> Ex (vdw_lemma k y l);\n        0 < x; 0 < k\\<rbrakk>\n       \\<Longrightarrow> Ex (vdw_lemma k x l)", "consider  \"m=1\" | \"m>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 1 \\<Longrightarrow> thesis;\n     1 < m \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using less.prems"], ["proof (prove)\nusing this:\n  0 < m\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 1 \\<Longrightarrow> thesis;\n     1 < m \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>m = 1 \\<Longrightarrow> ?thesis;\n   1 < m \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y; 0 < k\\<rbrakk>\n                   \\<Longrightarrow> Ex (vdw_lemma k y l);\n        0 < x; 0 < k\\<rbrakk>\n       \\<Longrightarrow> Ex (vdw_lemma k x l)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>m = 1 \\<Longrightarrow> ?thesis;\n   1 < m \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>m = 1 \\<Longrightarrow> ?thesis;\n   1 < m \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw_lemma k m l a", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 1 \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a\n 2. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "text \\<open> Case $m=1$: Show \\<open>vdw_lemma\\<close> for arithmetic progression, Induction start. \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 1 \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a\n 2. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "assume \"m = 1\""], ["proof (state)\nthis:\n  m = 1\n\ngoal (2 subgoals):\n 1. m = 1 \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a\n 2. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "obtain n where vdw: \"vdw k l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. vdw k l n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using vdw_assms \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  0 < ?k' \\<Longrightarrow> \\<exists>n_k'. vdw ?k' l n_k'\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<And>n. vdw k l n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  vdw k l n\n\ngoal (2 subgoals):\n 1. m = 1 \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a\n 2. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "define N where \"N = 2*n\""], ["proof (state)\nthis:\n  N = 2 * n\n\ngoal (2 subgoals):\n 1. m = 1 \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a\n 2. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "have \"l>0\" and \"l>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l &&& 1 < l", "using \\<open>l\\<ge>2\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> l\n\ngoal (1 subgoal):\n 1. 0 < l &&& 1 < l", "by auto"], ["proof (state)\nthis:\n  0 < l\n  1 < l\n\ngoal (2 subgoals):\n 1. m = 1 \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a\n 2. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "have \"vdw_lemma k m l N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vdw_lemma k m l N", "unfolding vdw_lemma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b col.\n       a + int N \\<le> b + 1 \\<and>\n       col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n       (\\<exists>start steps.\n           (\\<forall>i<m. 0 < steps i) \\<and>\n           is_multi_arith_prog_on (l + 1) m start steps a b \\<and>\n           (let f = multi_arith_prog m start steps\n            in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                  \\<forall>s<m.\n                     (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                     col (f c) =\n                     col (f (\\<lambda>i. if i \\<le> s then 0 else c i))))", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "case (1 a b col)"], ["proof (state)\nthis:\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "text \\<open> Divide $[a..b]$ in two intervals $I_1$, $I_2$ of same length and obtain arithmetic \n        progression of length $l$ in $I_1$. \\<close>"], ["proof (state)\nthis:\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have col_restr: \"col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}", "using 1"], ["proof (prove)\nusing this:\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}", "by (auto simp: N_def)"], ["proof (state)\nthis:\n  col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "then"], ["proof (chain)\npicking this:\n  col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}", "obtain j start step where prog:\n        \"j < k\" \"step > 0\" \n        \"is_arith_prog_on l start step a (a + int n -1)\"\n        \"arith_prog start step ` {..<l} \\<subseteq> \n          col -` {j} \\<inter> {a..a + int n - 1}\""], ["proof (prove)\nusing this:\n  col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k; 0 < step;\n         is_arith_prog_on l start step a (a + int n - 1);\n         arith_prog start step ` {..<l}\n         \\<subseteq> col -` {j} \\<inter> {a..a + int n - 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vdw 1"], ["proof (prove)\nusing this:\n  col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}\n  vdw k l n\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k; 0 < step;\n         is_arith_prog_on l start step a (a + int n - 1);\n         arith_prog start step ` {..<l}\n         \\<subseteq> col -` {j} \\<inter> {a..a + int n - 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding N_def"], ["proof (prove)\nusing this:\n  col \\<in> {a..a + int n - 1} \\<rightarrow> {..<k}\n  vdw k l n\n  a + int (2 * n) \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k; 0 < step;\n         is_arith_prog_on l start step a (a + int n - 1);\n         arith_prog start step ` {..<l}\n         \\<subseteq> col -` {j} \\<inter> {a..a + int n - 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim vdwE)(auto simp:is_arith_prog_on_def)"], ["proof (state)\nthis:\n  j < k\n  0 < step\n  is_arith_prog_on l start step a (a + int n - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col -` {j} \\<inter> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have range_prog_lessThan_l: \n        \"arith_prog start step i \\<in> {a..a + int n -1}\" if \"i < l\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + int n - 1}", "using that prog"], ["proof (prove)\nusing this:\n  i < l\n  j < k\n  0 < step\n  is_arith_prog_on l start step a (a + int n - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col -` {j} \\<inter> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + int n - 1}", "by auto"], ["proof (state)\nthis:\n  ?i < l \\<Longrightarrow> arith_prog start step ?i \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have \"{a..a + int n-1}\\<subseteq>{a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a..a + int n - 1} \\<subseteq> {a..b}", "using N_def \"1\"(1)"], ["proof (prove)\nusing this:\n  N = 2 * n\n  a + int N \\<le> b + 1\n\ngoal (1 subgoal):\n 1. {a..a + int n - 1} \\<subseteq> {a..b}", "by auto"], ["proof (state)\nthis:\n  {a..a + int n - 1} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "then"], ["proof (chain)\npicking this:\n  {a..a + int n - 1} \\<subseteq> {a..b}", "have \"a + 2* int n - 1 \\<le> b\""], ["proof (prove)\nusing this:\n  {a..a + int n - 1} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. a + 2 * int n - 1 \\<le> b", "using 1(1)"], ["proof (prove)\nusing this:\n  {a..a + int n - 1} \\<subseteq> {a..b}\n  a + int N \\<le> b + 1\n\ngoal (1 subgoal):\n 1. a + 2 * int n - 1 \\<le> b", "unfolding N_def"], ["proof (prove)\nusing this:\n  {a..a + int n - 1} \\<subseteq> {a..b}\n  a + int (2 * n) \\<le> b + 1\n\ngoal (1 subgoal):\n 1. a + 2 * int n - 1 \\<le> b", "by auto"], ["proof (state)\nthis:\n  a + 2 * int n - 1 \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "text \\<open> Show that \\<open>arith_prog start step\\<close> is an arithmetic progression of length $l+1$\n         in $[a..b]$. \\<close>"], ["proof (state)\nthis:\n  a + 2 * int n - 1 \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have prog_in_ivl: \"arith_prog start step i \\<in> {a..b}\" \n        if \"i \\<le> l\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..b}", "proof (cases \"i=l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}\n 2. i \\<noteq> l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "case False"], ["proof (state)\nthis:\n  i \\<noteq> l\n\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}\n 2. i \\<noteq> l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "have \"i<l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < l", "using that False"], ["proof (prove)\nusing this:\n  i \\<le> l\n  i \\<noteq> l\n\ngoal (1 subgoal):\n 1. i < l", "by auto"], ["proof (state)\nthis:\n  i < l\n\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}\n 2. i \\<noteq> l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "then"], ["proof (chain)\npicking this:\n  i < l", "show ?thesis"], ["proof (prove)\nusing this:\n  i < l\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..b}", "using range_prog_lessThan_l \\<open>{a..a + int n-1}\\<subseteq>{a..b}\\<close>"], ["proof (prove)\nusing this:\n  i < l\n  ?i < l \\<Longrightarrow> arith_prog start step ?i \\<in> {a..a + int n - 1}\n  {a..a + int n - 1} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..b}", "by force"], ["proof (state)\nthis:\n  arith_prog start step i \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "case True"], ["proof (state)\nthis:\n  i = l\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "text \\<open> Show $\\<open>step\\<close>\\leq |I_1|$ then have \\<open>arith_prog start step (l+1)\\<in>[a..b]\\<close> as \n           \\<open>arith_prog start step (l+1) = arith_prog start step l + step\\<close> \\<close>"], ["proof (state)\nthis:\n  i = l\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "have \"start \\<in> {a..a + int n -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start \\<in> {a..a + int n - 1}", "using range_prog_lessThan_l[of 0]"], ["proof (prove)\nusing this:\n  0 < l \\<Longrightarrow> arith_prog start step 0 \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. start \\<in> {a..a + int n - 1}", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  0 < l \\<Longrightarrow> start + int (0 * step) \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. start \\<in> {a..a + int n - 1}", "by (simp add: \\<open>0 < l\\<close>)"], ["proof (state)\nthis:\n  start \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "moreover"], ["proof (state)\nthis:\n  start \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "have \"start + int step \\<in> {a..a + int n -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int step \\<in> {a..a + int n - 1}", "using range_prog_lessThan_l[of 1]"], ["proof (prove)\nusing this:\n  1 < l \\<Longrightarrow> arith_prog start step 1 \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. start + int step \\<in> {a..a + int n - 1}", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  1 < l \\<Longrightarrow> start + int (1 * step) \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. start + int step \\<in> {a..a + int n - 1}", "by (metis \\<open>1 < l\\<close> mult.left_neutral)"], ["proof (state)\nthis:\n  start + int step \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  start \\<in> {a..a + int n - 1}\n  start + int step \\<in> {a..a + int n - 1}", "have \"step \\<le> n\""], ["proof (prove)\nusing this:\n  start \\<in> {a..a + int n - 1}\n  start + int step \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. step \\<le> n", "by auto"], ["proof (state)\nthis:\n  step \\<le> n\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "have \"arith_prog start step (l-1) \\<in> {a..a + int n -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step (l - 1) \\<in> {a..a + int n - 1}", "using range_prog_lessThan_l[of \"l-1\"]"], ["proof (prove)\nusing this:\n  l - 1 < l \\<Longrightarrow>\n  arith_prog start step (l - 1) \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step (l - 1) \\<in> {a..a + int n - 1}", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  l - 1 < l \\<Longrightarrow>\n  start + int ((l - 1) * step) \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. start + int ((l - 1) * step) \\<in> {a..a + int n - 1}", "using \\<open>0 < l\\<close> diff_less less_numeral_extra(1)"], ["proof (prove)\nusing this:\n  l - 1 < l \\<Longrightarrow>\n  start + int ((l - 1) * step) \\<in> {a..a + int n - 1}\n  0 < l\n  \\<lbrakk>0 < ?n; 0 < ?m\\<rbrakk> \\<Longrightarrow> ?m - ?n < ?m\n  (0::?'a) < (1::?'a)\n\ngoal (1 subgoal):\n 1. start + int ((l - 1) * step) \\<in> {a..a + int n - 1}", "by blast"], ["proof (state)\nthis:\n  arith_prog start step (l - 1) \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "moreover"], ["proof (state)\nthis:\n  arith_prog start step (l - 1) \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "have \"arith_prog start step l = \n                        arith_prog start step (l-1) + int step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step l = arith_prog start step (l - 1) + int step", "unfolding arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int (l * step) = start + int ((l - 1) * step) + int step", "using \\<open>0 < l\\<close> mult_eq_if"], ["proof (prove)\nusing this:\n  0 < l\n  ?m * ?n = (if ?m = 0 then 0 else ?n + (?m - 1) * ?n)\n\ngoal (1 subgoal):\n 1. start + int (l * step) = start + int ((l - 1) * step) + int step", "by force"], ["proof (state)\nthis:\n  arith_prog start step l = arith_prog start step (l - 1) + int step\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  arith_prog start step (l - 1) \\<in> {a..a + int n - 1}\n  arith_prog start step l = arith_prog start step (l - 1) + int step", "have \"arith_prog start step l \\<in> {a..b}\""], ["proof (prove)\nusing this:\n  arith_prog start step (l - 1) \\<in> {a..a + int n - 1}\n  arith_prog start step l = arith_prog start step (l - 1) + int step\n\ngoal (1 subgoal):\n 1. arith_prog start step l \\<in> {a..b}", "using \\<open>step\\<le>n\\<close> N_def \\<open>a + 2* int n -1 \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  arith_prog start step (l - 1) \\<in> {a..a + int n - 1}\n  arith_prog start step l = arith_prog start step (l - 1) + int step\n  step \\<le> n\n  N = 2 * n\n  a + 2 * int n - 1 \\<le> b\n\ngoal (1 subgoal):\n 1. arith_prog start step l \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  arith_prog start step l \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow> arith_prog start step i \\<in> {a..b}", "then"], ["proof (chain)\npicking this:\n  arith_prog start step l \\<in> {a..b}", "show ?thesis"], ["proof (prove)\nusing this:\n  arith_prog start step l \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..b}", "using range_prog_lessThan_l"], ["proof (prove)\nusing this:\n  arith_prog start step l \\<in> {a..b}\n  ?i < l \\<Longrightarrow> arith_prog start step ?i \\<in> {a..a + int n - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..b}", "using True"], ["proof (prove)\nusing this:\n  arith_prog start step l \\<in> {a..b}\n  ?i < l \\<Longrightarrow> arith_prog start step ?i \\<in> {a..a + int n - 1}\n  i = l\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..b}", "by force"], ["proof (state)\nthis:\n  arith_prog start step i \\<in> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<le> l \\<Longrightarrow> arith_prog start step ?i \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have col_prog_eq: \"col (arith_prog start step k) = j\" \n        if \"k < l\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (arith_prog start step k) = j", "using prog that"], ["proof (prove)\nusing this:\n  j < k\n  0 < step\n  is_arith_prog_on l start step a (a + int n - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col -` {j} \\<inter> {a..a + int n - 1}\n  k < l\n\ngoal (1 subgoal):\n 1. col (arith_prog start step k) = j", "by blast"], ["proof (state)\nthis:\n  ?k < l \\<Longrightarrow> col (arith_prog start step ?k) = j\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "define steps :: \"nat \\<Rightarrow> nat\" where steps_def: \"steps = (\\<lambda>i. step)\""], ["proof (state)\nthis:\n  steps = (\\<lambda>i. step)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "define f where \"f = multi_arith_prog 1 start steps\""], ["proof (state)\nthis:\n  f = multi_arith_prog 1 start steps\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have rel_prop_1: \n        \"col (f c) = col (f (\\<lambda>i. if i < s then 0 else c i))\"\n        if \"c \\<in> {0..<1} \\<rightarrow> {0..l}\" \"s<1\" \"\\<forall>j\\<le>s. c j < l\" for c s"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (f c) = col (f (\\<lambda>i. if i < s then 0 else c i))", "using that"], ["proof (prove)\nusing this:\n  c \\<in> {0..<1} \\<rightarrow> {0..l}\n  s < 1\n  \\<forall>j\\<le>s. c j < l\n\ngoal (1 subgoal):\n 1. col (f c) = col (f (\\<lambda>i. if i < s then 0 else c i))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?c \\<in> {0..<1} \\<rightarrow> {0..l}; ?s < 1;\n   \\<forall>j\\<le>?s. ?c j < l\\<rbrakk>\n  \\<Longrightarrow> col (f ?c) =\n                    col (f (\\<lambda>i. if i < ?s then 0 else ?c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have arith_prog_on: \n        \"is_multi_arith_prog_on (l+1) m start steps a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start steps a b", "using prog(3)"], ["proof (prove)\nusing this:\n  is_arith_prog_on l start step a (a + int n - 1)\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start steps a b", "unfolding is_arith_prog_on_def is_multi_arith_prog_on_def"], ["proof (prove)\nusing this:\n  a \\<le> start \\<and> arith_prog start step (l - 1) \\<le> a + int n - 1\n\ngoal (1 subgoal):\n 1. a \\<le> start \\<and>\n    multi_arith_prog m start steps (\\<lambda>_. l + 1 - 1) \\<le> b", "using \\<open>m=1\\<close> arith_prog_to_multi steps_def prog_in_ivl"], ["proof (prove)\nusing this:\n  a \\<le> start \\<and> arith_prog start step (l - 1) \\<le> a + int n - 1\n  m = 1\n  arith_prog ?start ?step ?c =\n  multi_arith_prog 1 ?start (\\<lambda>_. ?step) (\\<lambda>_. ?c)\n  steps = (\\<lambda>i. step)\n  ?i \\<le> l \\<Longrightarrow> arith_prog start step ?i \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. a \\<le> start \\<and>\n    multi_arith_prog m start steps (\\<lambda>_. l + 1 - 1) \\<le> b", "by auto"], ["proof (state)\nthis:\n  is_multi_arith_prog_on (l + 1) m start steps a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>start steps.\n       (\\<forall>i<m. 0 < steps i) \\<and>\n       is_multi_arith_prog_on (l + 1) m start steps a b \\<and>\n       (let f = multi_arith_prog m start steps\n        in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n              \\<forall>s<m.\n                 (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                 col (f c) =\n                 col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "by (rule exI[of _ start], rule exI[of _ steps])\n           (use rel_prop_1 \\<open>step > 0\\<close> \\<open>m = 1\\<close> arith_prog_on col_prog_eq\n             multi_to_arith_prog in \\<open>auto simp: f_def Let_def steps_def\\<close>)"], ["proof (state)\nthis:\n  \\<exists>start steps.\n     (\\<forall>i<m. 0 < steps i) \\<and>\n     is_multi_arith_prog_on (l + 1) m start steps a b \\<and>\n     (let f = multi_arith_prog m start steps\n      in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n            \\<forall>s<m.\n               (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n               col (f c) =\n               col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vdw_lemma k m l N\n\ngoal (2 subgoals):\n 1. m = 1 \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a\n 2. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "then"], ["proof (chain)\npicking this:\n  vdw_lemma k m l N", "show ?case"], ["proof (prove)\nusing this:\n  vdw_lemma k m l N\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw_lemma k m l a", ".."], ["proof (state)\nthis:\n  \\<exists>a. vdw_lemma k m l a\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "text \\<open> Case $m>1$: Show \\<open>vdw_lemma\\<close> for $m$-fold arithmetic progression, \n          Induction step $(m-1) \\longrightarrow m$. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "assume \"m>1\""], ["proof (state)\nthis:\n  1 < m\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "obtain q where vdw_lemma_IH:\"vdw_lemma k (m-1) l q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        vdw_lemma k (m - 1) l q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>1 < m\\<close> less"], ["proof (prove)\nusing this:\n  1 < m\n  \\<lbrakk>?y < m; 0 < ?y; 0 < k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. vdw_lemma k ?y l a\n  0 < m\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        vdw_lemma k (m - 1) l q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  vdw_lemma k (m - 1) l q\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "have \"k^q>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k ^ q", "using \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. 0 < k ^ q", "by auto"], ["proof (state)\nthis:\n  0 < k ^ q\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "obtain n_kq where vdw: \"vdw (k^q) l n_kq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n_kq.\n        vdw (k ^ q) l n_kq \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vdw_assms \\<open>k^q>0\\<close>"], ["proof (prove)\nusing this:\n  0 < ?k' \\<Longrightarrow> \\<exists>n_k'. vdw ?k' l n_k'\n  0 < k ^ q\n\ngoal (1 subgoal):\n 1. (\\<And>n_kq.\n        vdw (k ^ q) l n_kq \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vdw (k ^ q) l n_kq\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "define N where \"N = q + 2 * n_kq\""], ["proof (state)\nthis:\n  N = q + 2 * n_kq\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "text \\<open>Idea: $[a..b] = I_1 \\cup I_2$ where $|I_1| = 2*n_{k,q}$ and $|I_2| = q$.\n                Divide $I_1$ into blocks of length $q$ and define a new colouring on the set of \n                $q$-blocks where the colour of the block is the $k$-basis representation where \n                the $i$-th digit corresponds to the colour of the $i$-th element in the block. \n                Get an arithmetic progression of $q$-blocks of length $l+1$ in $I_1$, such that\n                the first $l$ $q$-blocks have the same colour. \n                The step of the block-arithmetic progression is going to be the additional \n                step in the induction over $m$. \\<close>"], ["proof (state)\nthis:\n  N = q + 2 * n_kq\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "have \"vdw_lemma k m l N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vdw_lemma k m l N", "unfolding vdw_lemma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b col.\n       a + int N \\<le> b + 1 \\<and>\n       col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n       (\\<exists>start steps.\n           (\\<forall>i<m. 0 < steps i) \\<and>\n           is_multi_arith_prog_on (l + 1) m start steps a b \\<and>\n           (let f = multi_arith_prog m start steps\n            in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                  \\<forall>s<m.\n                     (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                     col (f c) =\n                     col (f (\\<lambda>i. if i \\<le> s then 0 else c i))))", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "case (1 a b col)"], ["proof (state)\nthis:\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have \"n_kq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n_kq", "using vdw_imp_pos vdw \\<open>l\\<ge>2\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>vdw ?k ?l ?n; 0 < ?l\\<rbrakk> \\<Longrightarrow> 0 < ?n\n  vdw (k ^ q) l n_kq\n  2 \\<le> l\n\ngoal (1 subgoal):\n 1. 0 < n_kq", "by auto"], ["proof (state)\nthis:\n  0 < n_kq\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "then"], ["proof (chain)\npicking this:\n  0 < n_kq", "have \"N>0\""], ["proof (prove)\nusing this:\n  0 < n_kq\n\ngoal (1 subgoal):\n 1. 0 < N", "by (simp add:N_def)"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "then"], ["proof (chain)\npicking this:\n  0 < N", "have \"a\\<le>b\""], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. a \\<le> b", "using 1"], ["proof (prove)\nusing this:\n  0 < N\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. a \\<le> b", "by auto"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "then"], ["proof (chain)\npicking this:\n  a \\<le> b", "have \"k>0\""], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. 0 < k", "using 1"], ["proof (prove)\nusing this:\n  a \\<le> b\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. 0 < k", "by (intro Nat.gr0I) force"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have \"l>0\" and \"l>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l &&& 1 < l", "using \\<open>l\\<ge>2\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> l\n\ngoal (1 subgoal):\n 1. 0 < l &&& 1 < l", "by auto"], ["proof (state)\nthis:\n  0 < l\n  1 < l\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "interpret digits k"], ["proof (prove)\ngoal (1 subgoal):\n 1. digits k", "by (simp add: \\<open>0 < k\\<close> digits_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "define col1 where \"col1 = (\\<lambda> x. from_digits q (\\<lambda>y. col (x + y)))\""], ["proof (state)\nthis:\n  col1 = (\\<lambda>x. from_digits q (\\<lambda>xa. col (x + int xa)))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have range_col1: \"col1\\<in>{a..a + int n_kq - 1} \\<rightarrow> {..<k^q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col1 \\<in> {a..a + int n_kq - 1} \\<rightarrow> {..<k ^ q}", "unfolding Pi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col1\n    \\<in> {f. \\<forall>x.\n                 x \\<in> {a..a + int n_kq - 1} \\<longrightarrow>\n                 f x \\<in> {..<k ^ q}}", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "assume \"x\\<in>{a..a + int n_kq - 1}\""], ["proof (state)\nthis:\n  x \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "then"], ["proof (chain)\npicking this:\n  x \\<in> {a..a + int n_kq - 1}", "have col_xn:\"col (x + int n)\\<in>{..<k}\" if \"n<q\" for n :: nat"], ["proof (prove)\nusing this:\n  x \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. col (x + int n) \\<in> {..<k}", "using that 1 PiE N_def"], ["proof (prove)\nusing this:\n  x \\<in> {a..a + int n_kq - 1}\n  n < q\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  \\<lbrakk>?f \\<in> Pi ?A ?B; ?f ?x \\<in> ?B ?x \\<Longrightarrow> ?Q;\n   ?x \\<notin> ?A \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n  N = q + 2 * n_kq\n\ngoal (1 subgoal):\n 1. col (x + int n) \\<in> {..<k}", "by auto"], ["proof (state)\nthis:\n  ?n < q \\<Longrightarrow> col (x + int ?n) \\<in> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "have col_xn_upper_bound:\"col (x + int n) \\<le> k - 1\" \n          if \"n<q\" for n ::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (x + int n) \\<le> k - 1", "using that col_xn[of n] \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  n < q\n  n < q \\<Longrightarrow> col (x + int n) \\<in> {..<k}\n  0 < k\n\ngoal (1 subgoal):\n 1. col (x + int n) \\<le> k - 1", "by (auto)"], ["proof (state)\nthis:\n  ?n < q \\<Longrightarrow> col (x + int ?n) \\<le> k - 1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "have \"(\\<Sum>n<q. col (x + int n) * k ^ n)\\<le> \n               (\\<Sum>n<q. (k-1) *  k ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<q. col (x + int n) * k ^ n) \\<le> (\\<Sum>n<q. (k - 1) * k ^ n)", "using col_xn_upper_bound"], ["proof (prove)\nusing this:\n  ?n < q \\<Longrightarrow> col (x + int ?n) \\<le> k - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n<q. col (x + int n) * k ^ n) \\<le> (\\<Sum>n<q. (k - 1) * k ^ n)", "by (intro sum_mono mult_right_mono) \n            auto"], ["proof (state)\nthis:\n  (\\<Sum>n<q. col (x + int n) * k ^ n) \\<le> (\\<Sum>n<q. (k - 1) * k ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "also"], ["proof (state)\nthis:\n  (\\<Sum>n<q. col (x + int n) * k ^ n) \\<le> (\\<Sum>n<q. (k - 1) * k ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "have \"\\<dots> = (k-1) * (\\<Sum>n<q. k ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<q. (k - 1) * k ^ n) = (k - 1) * sum ((^) k) {..<q}", "by (rule sum_distrib_left[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>n<q. (k - 1) * k ^ n) = (k - 1) * sum ((^) k) {..<q}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "also"], ["proof (state)\nthis:\n  (\\<Sum>n<q. (k - 1) * k ^ n) = (k - 1) * sum ((^) k) {..<q}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "have \"\\<dots> < k^q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "using sum_mod_poly \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  0 < ?k \\<Longrightarrow> (?k - 1) * sum ((^) ?k) {..<?q} < ?k ^ ?q\n  0 < k\n\ngoal (1 subgoal):\n 1. (k - 1) * sum ((^) k) {..<q} < k ^ q", "by auto"], ["proof (state)\nthis:\n  (k - 1) * sum ((^) k) {..<q} < k ^ q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {a..a + int n_kq - 1} \\<Longrightarrow> col1 x < k ^ q", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>n<q. col (x + int n) * k ^ n) < k ^ q", "show \"col1 x <k^q\""], ["proof (prove)\nusing this:\n  (\\<Sum>n<q. col (x + int n) * k ^ n) < k ^ q\n\ngoal (1 subgoal):\n 1. col1 x < k ^ q", "unfolding col1_def from_digits_altdef"], ["proof (prove)\nusing this:\n  (\\<Sum>n<q. col (x + int n) * k ^ n) < k ^ q\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<q. col (x + int i) * k ^ i) < k ^ q", "by auto"], ["proof (state)\nthis:\n  col1 x < k ^ q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  col1 \\<in> {a..a + int n_kq - 1} \\<rightarrow> {..<k ^ q}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "obtain j start step where prog:\n        \"j < k^q\" \"step > 0\" \n        \"is_arith_prog_on l start step a (a + int n_kq - 1)\"\n        \"arith_prog start step ` {..<l} \\<subseteq> \n          col1 -` {j} \\<inter> {a..a + int n_kq -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k ^ q; 0 < step;\n         is_arith_prog_on l start step a (a + int n_kq - 1);\n         arith_prog start step ` {..<l}\n         \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vdw range_col1"], ["proof (prove)\nusing this:\n  vdw (k ^ q) l n_kq\n  col1 \\<in> {a..a + int n_kq - 1} \\<rightarrow> {..<k ^ q}\n\ngoal (1 subgoal):\n 1. (\\<And>j step start.\n        \\<lbrakk>j < k ^ q; 0 < step;\n         is_arith_prog_on l start step a (a + int n_kq - 1);\n         arith_prog start step ` {..<l}\n         \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim vdwE) (auto simp: \\<open>k>0\\<close>)"], ["proof (state)\nthis:\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have range_prog_lessThan_l: \n        \"arith_prog start step i \\<in> {a..a + int n_kq -1}\" \n        if \"i < l\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + int n_kq - 1}", "using that prog"], ["proof (prove)\nusing this:\n  i < l\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + int n_kq - 1}", "by auto"], ["proof (state)\nthis:\n  ?i < l \\<Longrightarrow>\n  arith_prog start step ?i \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have prog_in_ivl: \n        \"arith_prog start step i \\<in> {a..a + 2 * int n_kq -1}\" \n        if \"i \\<le> l\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "proof (cases \"i=l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n 2. i \\<noteq> l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "case False"], ["proof (state)\nthis:\n  i \\<noteq> l\n\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n 2. i \\<noteq> l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> l", "have \"i<l\""], ["proof (prove)\nusing this:\n  i \\<noteq> l\n\ngoal (1 subgoal):\n 1. i < l", "using that"], ["proof (prove)\nusing this:\n  i \\<noteq> l\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. i < l", "by auto"], ["proof (state)\nthis:\n  i < l\n\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n 2. i \\<noteq> l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "then"], ["proof (chain)\npicking this:\n  i < l", "show ?thesis"], ["proof (prove)\nusing this:\n  i < l\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "using prog"], ["proof (prove)\nusing this:\n  i < l\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "by auto"], ["proof (state)\nthis:\n  arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "case True"], ["proof (state)\nthis:\n  i = l\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "have \"start \\<in> {a..a + int n_kq -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start \\<in> {a..a + int n_kq - 1}", "using range_prog_lessThan_l[of 0]"], ["proof (prove)\nusing this:\n  0 < l \\<Longrightarrow>\n  arith_prog start step 0 \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. start \\<in> {a..a + int n_kq - 1}", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  0 < l \\<Longrightarrow> start + int (0 * step) \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. start \\<in> {a..a + int n_kq - 1}", "by (simp add: \\<open>0 < l\\<close>)"], ["proof (state)\nthis:\n  start \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "moreover"], ["proof (state)\nthis:\n  start \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "have \"start + step \\<in> {a..a + int n_kq -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int step \\<in> {a..a + int n_kq - 1}", "using range_prog_lessThan_l[of 1]"], ["proof (prove)\nusing this:\n  1 < l \\<Longrightarrow>\n  arith_prog start step 1 \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. start + int step \\<in> {a..a + int n_kq - 1}", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  1 < l \\<Longrightarrow> start + int (1 * step) \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. start + int step \\<in> {a..a + int n_kq - 1}", "by (metis \\<open>1 < l\\<close> mult.left_neutral)"], ["proof (state)\nthis:\n  start + int step \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "ultimately"], ["proof (chain)\npicking this:\n  start \\<in> {a..a + int n_kq - 1}\n  start + int step \\<in> {a..a + int n_kq - 1}", "have \"step \\<le> n_kq\""], ["proof (prove)\nusing this:\n  start \\<in> {a..a + int n_kq - 1}\n  start + int step \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. step \\<le> n_kq", "by auto"], ["proof (state)\nthis:\n  step \\<le> n_kq\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "have \"arith_prog start step (l-1) \\<in> {a..a + int n_kq -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}", "using range_prog_lessThan_l[of \"l-1\"]"], ["proof (prove)\nusing this:\n  l - 1 < l \\<Longrightarrow>\n  arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  l - 1 < l \\<Longrightarrow>\n  start + int ((l - 1) * step) \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. start + int ((l - 1) * step) \\<in> {a..a + int n_kq - 1}", "using \\<open>0 < l\\<close> diff_less less_numeral_extra(1)"], ["proof (prove)\nusing this:\n  l - 1 < l \\<Longrightarrow>\n  start + int ((l - 1) * step) \\<in> {a..a + int n_kq - 1}\n  0 < l\n  \\<lbrakk>0 < ?n; 0 < ?m\\<rbrakk> \\<Longrightarrow> ?m - ?n < ?m\n  (0::?'a) < (1::?'a)\n\ngoal (1 subgoal):\n 1. start + int ((l - 1) * step) \\<in> {a..a + int n_kq - 1}", "by blast"], ["proof (state)\nthis:\n  arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "moreover"], ["proof (state)\nthis:\n  arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "have \"arith_prog start step l = \n            arith_prog start step (l-1) + step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step l = arith_prog start step (l - 1) + int step", "unfolding arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int (l * step) = start + int ((l - 1) * step) + int step", "using \\<open>0 < l\\<close> mult_eq_if"], ["proof (prove)\nusing this:\n  0 < l\n  ?m * ?n = (if ?m = 0 then 0 else ?n + (?m - 1) * ?n)\n\ngoal (1 subgoal):\n 1. start + int (l * step) = start + int ((l - 1) * step) + int step", "by force"], ["proof (state)\nthis:\n  arith_prog start step l = arith_prog start step (l - 1) + int step\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "ultimately"], ["proof (chain)\npicking this:\n  arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}\n  arith_prog start step l = arith_prog start step (l - 1) + int step", "have \"arith_prog start step l \\<in> \n            {a..a + 2 * int n_kq - 1}\""], ["proof (prove)\nusing this:\n  arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}\n  arith_prog start step l = arith_prog start step (l - 1) + int step\n\ngoal (1 subgoal):\n 1. arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}", "using \\<open>step\\<le>n_kq\\<close>"], ["proof (prove)\nusing this:\n  arith_prog start step (l - 1) \\<in> {a..a + int n_kq - 1}\n  arith_prog start step l = arith_prog start step (l - 1) + int step\n  step \\<le> n_kq\n\ngoal (1 subgoal):\n 1. arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}", "by auto"], ["proof (state)\nthis:\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal (1 subgoal):\n 1. i = l \\<Longrightarrow>\n    arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "then"], ["proof (chain)\npicking this:\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "using range_prog_lessThan_l"], ["proof (prove)\nusing this:\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n  ?i < l \\<Longrightarrow>\n  arith_prog start step ?i \\<in> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "using True"], ["proof (prove)\nusing this:\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n  ?i < l \\<Longrightarrow>\n  arith_prog start step ?i \\<in> {a..a + int n_kq - 1}\n  i = l\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "by force"], ["proof (state)\nthis:\n  arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<le> l \\<Longrightarrow>\n  arith_prog start step ?i \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have col_prog_eq: \"col1 (arith_prog start step k) = j\" \n        if \"k < l\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. col1 (arith_prog start step k) = j", "using prog that"], ["proof (prove)\nusing this:\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n  k < l\n\ngoal (1 subgoal):\n 1. col1 (arith_prog start step k) = j", "by blast"], ["proof (state)\nthis:\n  ?k < l \\<Longrightarrow> col1 (arith_prog start step ?k) = j\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have digit_col1:\"digit (col1 x) y = col (x+int y)\" \n        if \"x\\<in>{a..<a + 2*int n_kq}\" \"y\\<in>{..<q}\" \n        for x::int and y::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. digit (col1 x) y = col (x + int y)", "unfolding col1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. digit (from_digits q (\\<lambda>xa. col (x + int xa))) y =\n    col (x + int y)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {a..<a + 2 * int n_kq}\n  y \\<in> {..<q}\n\ngoal (1 subgoal):\n 1. digit (from_digits q (\\<lambda>xa. col (x + int xa))) y =\n    col (x + int y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {a..<a + 2 * int n_kq}; y \\<in> {..<q}\\<rbrakk>\n    \\<Longrightarrow> digit (from_digits q (\\<lambda>xa. col (x + int xa)))\n                       y =\n                      col (x + int y)", "have \"\\<And>j'. j'<q \\<Longrightarrow> x+j'\\<in>{a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j'. j' < q \\<Longrightarrow> x + int j' \\<in> {a..b}", "using \"1\"(1) N_def that(1)"], ["proof (prove)\nusing this:\n  a + int N \\<le> b + 1\n  N = q + 2 * n_kq\n  x \\<in> {a..<a + 2 * int n_kq}\n\ngoal (1 subgoal):\n 1. \\<And>j'. j' < q \\<Longrightarrow> x + int j' \\<in> {a..b}", "by force"], ["proof (state)\nthis:\n  ?j' < q \\<Longrightarrow> x + int ?j' \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {a..<a + 2 * int n_kq}; y \\<in> {..<q}\\<rbrakk>\n    \\<Longrightarrow> digit (from_digits q (\\<lambda>xa. col (x + int xa)))\n                       y =\n                      col (x + int y)", "then"], ["proof (chain)\npicking this:\n  ?j' < q \\<Longrightarrow> x + int ?j' \\<in> {a..b}", "have \"\\<And>j'. j'<q \\<Longrightarrow> (\\<lambda>y. col (x+int y)) j' < k\""], ["proof (prove)\nusing this:\n  ?j' < q \\<Longrightarrow> x + int ?j' \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>j'. j' < q \\<Longrightarrow> col (x + int j') < k", "using 1 that"], ["proof (prove)\nusing this:\n  ?j' < q \\<Longrightarrow> x + int ?j' \\<in> {a..b}\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  x \\<in> {a..<a + 2 * int n_kq}\n  y \\<in> {..<q}\n\ngoal (1 subgoal):\n 1. \\<And>j'. j' < q \\<Longrightarrow> col (x + int j') < k", "by auto"], ["proof (state)\nthis:\n  ?j' < q \\<Longrightarrow> col (x + int ?j') < k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {a..<a + 2 * int n_kq}; y \\<in> {..<q}\\<rbrakk>\n    \\<Longrightarrow> digit (from_digits q (\\<lambda>xa. col (x + int xa)))\n                       y =\n                      col (x + int y)", "then"], ["proof (chain)\npicking this:\n  ?j' < q \\<Longrightarrow> col (x + int ?j') < k", "show \"digit (from_digits q (\\<lambda>xa. col (x + int xa))) y = \n                    col (x + int y)\""], ["proof (prove)\nusing this:\n  ?j' < q \\<Longrightarrow> col (x + int ?j') < k\n\ngoal (1 subgoal):\n 1. digit (from_digits q (\\<lambda>xa. col (x + int xa))) y =\n    col (x + int y)", "using digit_from_digits that 1"], ["proof (prove)\nusing this:\n  ?j' < q \\<Longrightarrow> col (x + int ?j') < k\n  \\<lbrakk>\\<And>j. j < ?n \\<Longrightarrow> ?d j < k; 0 < ?n;\n   ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> digit (from_digits ?n ?d) ?i = ?d ?i\n  x \\<in> {a..<a + 2 * int n_kq}\n  y \\<in> {..<q}\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. digit (from_digits q (\\<lambda>xa. col (x + int xa))) y =\n    col (x + int y)", "by auto"], ["proof (state)\nthis:\n  digit (from_digits q (\\<lambda>xa. col (x + int xa))) y = col (x + int y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> {a..<a + 2 * int n_kq}; ?y \\<in> {..<q}\\<rbrakk>\n  \\<Longrightarrow> digit (col1 ?x) ?y = col (?x + int ?y)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "text \\<open> Impact on the colour when taking the block-step. \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> {a..<a + 2 * int n_kq}; ?y \\<in> {..<q}\\<rbrakk>\n  \\<Longrightarrow> digit (col1 ?x) ?y = col (?x + int ?y)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have one_step_more:\n        \"col (arith_prog start' step i) = digit j (nat (start'-start))\" \n        if \"start'\\<in>{start..<start+q}\" \"i\\<in>{..<l}\" for start' i"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "have \"start \\<le> start'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start \\<le> start'", "using that"], ["proof (prove)\nusing this:\n  start' \\<in> {start..<start + int q}\n  i \\<in> {..<l}\n\ngoal (1 subgoal):\n 1. start \\<le> start'", "by simp"], ["proof (state)\nthis:\n  start \\<le> start'\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "have shift_arith_prog:\n          \"arith_prog start step i + (start' - start) = \n            arith_prog start' step i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step i + (start' - start) = arith_prog start' step i", "unfolding arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int (i * step) + (start' - start) = start' + int (i * step)", "by simp"], ["proof (state)\nthis:\n  arith_prog start step i + (start' - start) = arith_prog start' step i\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "define diff where \"diff = nat (start'-start)\""], ["proof (state)\nthis:\n  diff = nat (start' - start)\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "have \"diff \\<in>{..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff \\<in> {..<q}", "using that"], ["proof (prove)\nusing this:\n  start' \\<in> {start..<start + int q}\n  i \\<in> {..<l}\n\ngoal (1 subgoal):\n 1. diff \\<in> {..<q}", "unfolding diff_def"], ["proof (prove)\nusing this:\n  start' \\<in> {start..<start + int q}\n  i \\<in> {..<l}\n\ngoal (1 subgoal):\n 1. nat (start' - start) \\<in> {..<q}", "by auto"], ["proof (state)\nthis:\n  diff \\<in> {..<q}\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "have \"col (arith_prog start step i + int diff) = digit j diff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (arith_prog start step i + int diff) = digit j diff", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col (arith_prog start step i + int diff) = digit j diff", "have \"col1 (arith_prog start step i) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col1 (arith_prog start step i) = j", "using col1_def prog that"], ["proof (prove)\nusing this:\n  col1 = (\\<lambda>x. from_digits q (\\<lambda>xa. col (x + int xa)))\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n  start' \\<in> {start..<start + int q}\n  i \\<in> {..<l}\n\ngoal (1 subgoal):\n 1. col1 (arith_prog start step i) = j", "by blast"], ["proof (state)\nthis:\n  col1 (arith_prog start step i) = j\n\ngoal (1 subgoal):\n 1. col (arith_prog start step i + int diff) = digit j diff", "moreover"], ["proof (state)\nthis:\n  col1 (arith_prog start step i) = j\n\ngoal (1 subgoal):\n 1. col (arith_prog start step i + int diff) = digit j diff", "have \" arith_prog start step i\\<in>{a..a + 2 * int n_kq-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "using prog(4) that"], ["proof (prove)\nusing this:\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n  start' \\<in> {start..<start + int q}\n  i \\<in> {..<l}\n\ngoal (1 subgoal):\n 1. arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "by auto"], ["proof (state)\nthis:\n  arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal (1 subgoal):\n 1. col (arith_prog start step i + int diff) = digit j diff", "ultimately"], ["proof (chain)\npicking this:\n  col1 (arith_prog start step i) = j\n  arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  col1 (arith_prog start step i) = j\n  arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal (1 subgoal):\n 1. col (arith_prog start step i + int diff) = digit j diff", "using digit_col1[where x = \"arith_prog start step i\" \n                and y = \"diff\"] \n              prog 1 \\<open>diff \\<in>{..<q}\\<close>"], ["proof (prove)\nusing this:\n  col1 (arith_prog start step i) = j\n  arith_prog start step i \\<in> {a..a + 2 * int n_kq - 1}\n  \\<lbrakk>arith_prog start step i \\<in> {a..<a + 2 * int n_kq};\n   diff \\<in> {..<q}\\<rbrakk>\n  \\<Longrightarrow> digit (col1 (arith_prog start step i)) diff =\n                    col (arith_prog start step i + int diff)\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  diff \\<in> {..<q}\n\ngoal (1 subgoal):\n 1. col (arith_prog start step i + int diff) = digit j diff", "by auto"], ["proof (state)\nthis:\n  col (arith_prog start step i + int diff) = digit j diff\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  col (arith_prog start step i + int diff) = digit j diff\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "then"], ["proof (chain)\npicking this:\n  col (arith_prog start step i + int diff) = digit j diff", "show ?thesis"], ["proof (prove)\nusing this:\n  col (arith_prog start step i + int diff) = digit j diff\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "unfolding diff_def 1"], ["proof (prove)\nusing this:\n  col (arith_prog start step i + int (nat (start' - start))) =\n  digit j (nat (start' - start))\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = digit j (nat (start' - start))", "by (auto simp: \\<open>start\\<le>start'\\<close> shift_arith_prog)"], ["proof (state)\nthis:\n  col (arith_prog start' step i) = digit j (nat (start' - start))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?start' \\<in> {start..<start + int q}; ?i \\<in> {..<l}\\<rbrakk>\n  \\<Longrightarrow> col (arith_prog ?start' step ?i) =\n                    digit j (nat (?start' - start))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have one_step_more': \"col (arith_prog start' step i) =\n        col (arith_prog start' step 0)\"\n        if \"start'\\<in>{start..<start+q}\" \"i\\<in>{..<l}\" for start' i"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = col (arith_prog start' step 0)", "using that one_step_more[of start' 0] \n          one_step_more[of start' i]"], ["proof (prove)\nusing this:\n  start' \\<in> {start..<start + int q}\n  i \\<in> {..<l}\n  \\<lbrakk>start' \\<in> {start..<start + int q}; 0 \\<in> {..<l}\\<rbrakk>\n  \\<Longrightarrow> col (arith_prog start' step 0) =\n                    digit j (nat (start' - start))\n  \\<lbrakk>start' \\<in> {start..<start + int q}; i \\<in> {..<l}\\<rbrakk>\n  \\<Longrightarrow> col (arith_prog start' step i) =\n                    digit j (nat (start' - start))\n\ngoal (1 subgoal):\n 1. col (arith_prog start' step i) = col (arith_prog start' step 0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?start' \\<in> {start..<start + int q}; ?i \\<in> {..<l}\\<rbrakk>\n  \\<Longrightarrow> col (arith_prog ?start' step ?i) =\n                    col (arith_prog ?start' step 0)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have start_q: \"start + int q \\<le> start + int q - 1 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start + int q \\<le> start + int q - 1 + 1", "by linarith"], ["proof (state)\nthis:\n  start + int q \\<le> start + int q - 1 + 1\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have \"{start..start + int q-1} \\<subseteq> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {start..start + int q - 1} \\<subseteq> {a..b}", "using prog N_def 1(1)"], ["proof (prove)\nusing this:\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n  N = q + 2 * n_kq\n  a + int N \\<le> b + 1\n\ngoal (1 subgoal):\n 1. {start..start + int q - 1} \\<subseteq> {a..b}", "by (force simp: arith_prog_def is_arith_prog_on_def)"], ["proof (state)\nthis:\n  {start..start + int q - 1} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "then"], ["proof (chain)\npicking this:\n  {start..start + int q - 1} \\<subseteq> {a..b}", "have col': \"col \\<in> {start..start + int q-1} \\<rightarrow> {..<k}\""], ["proof (prove)\nusing this:\n  {start..start + int q - 1} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. col \\<in> {start..start + int q - 1} \\<rightarrow> {..<k}", "using 1 prog(4)"], ["proof (prove)\nusing this:\n  {start..start + int q - 1} \\<subseteq> {a..b}\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. col \\<in> {start..start + int q - 1} \\<rightarrow> {..<k}", "by auto"], ["proof (state)\nthis:\n  col \\<in> {start..start + int q - 1} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "text \\<open> Obtain an $(m-1)$-fold arithmetic progression in the starting $q$-bolck of the \n             block arithmetic progression. \\<close>"], ["proof (state)\nthis:\n  col \\<in> {start..start + int q - 1} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "obtain start_m steps_m where\n        step_m_pos: \"\\<And>i. i < m - 1 \\<Longrightarrow> 0 < steps_m i\" and\n        is_multi_arith_prog: \"is_multi_arith_prog_on (l+1) (m - 1) \n          start_m steps_m start (start + int q - 1)\" and\n        g_aux: \"let g = multi_arith_prog (m - 1) start_m steps_m\n          in  \\<forall>c\\<in>{0..<m - 1} \\<rightarrow> {0..l}. \\<forall>s<m - 1. (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n          col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>steps_m start_m.\n        \\<lbrakk>\\<And>i. i < m - 1 \\<Longrightarrow> 0 < steps_m i;\n         is_multi_arith_prog_on (l + 1) (m - 1) start_m steps_m start\n          (start + int q - 1);\n         let g = multi_arith_prog (m - 1) start_m steps_m\n         in \\<forall>c\\<in>{0..<m - 1} \\<rightarrow> {0..l}.\n               \\<forall>s<m - 1.\n                  (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                  col (g c) =\n                  col (g (\\<lambda>i.\n                             if i \\<le> s then 0 else c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule vdw_lemmaE[OF vdw_lemma_IH start_q col']) blast"], ["proof (state)\nthis:\n  ?i < m - 1 \\<Longrightarrow> 0 < steps_m ?i\n  is_multi_arith_prog_on (l + 1) (m - 1) start_m steps_m start\n   (start + int q - 1)\n  let g = multi_arith_prog (m - 1) start_m steps_m\n  in \\<forall>c\\<in>{0..<m - 1} \\<rightarrow> {0..l}.\n        \\<forall>s<m - 1.\n           (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n           col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "define g where \"g = multi_arith_prog (m-1) start_m steps_m\""], ["proof (state)\nthis:\n  g = multi_arith_prog (m - 1) start_m steps_m\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have g: \"col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))\"\n        if \"c \\<in> {0..<(m-1)} \\<rightarrow> {0..l}\" \"s < m - 1\" \"\\<forall>j \\<le> s. c j < l\"\n        for c s"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))", "using g_aux that"], ["proof (prove)\nusing this:\n  let g = multi_arith_prog (m - 1) start_m steps_m\n  in \\<forall>c\\<in>{0..<m - 1} \\<rightarrow> {0..l}.\n        \\<forall>s<m - 1.\n           (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n           col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))\n  c \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  s < m - 1\n  \\<forall>j\\<le>s. c j < l\n\ngoal (1 subgoal):\n 1. col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))", "unfolding g_def Let_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{0..<m - 1} \\<rightarrow> {0..l}.\n     \\<forall>s<m - 1.\n        (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n        col (multi_arith_prog (m - 1) start_m steps_m c) =\n        col (multi_arith_prog (m - 1) start_m steps_m\n              (\\<lambda>i. if i \\<le> s then 0 else c i))\n  c \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  s < m - 1\n  \\<forall>j\\<le>s. c j < l\n\ngoal (1 subgoal):\n 1. col (multi_arith_prog (m - 1) start_m steps_m c) =\n    col (multi_arith_prog (m - 1) start_m steps_m\n          (\\<lambda>i. if i \\<le> s then 0 else c i))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?c \\<in> {0..<m - 1} \\<rightarrow> {0..l}; ?s < m - 1;\n   \\<forall>j\\<le>?s. ?c j < l\\<rbrakk>\n  \\<Longrightarrow> col (g ?c) =\n                    col (g (\\<lambda>i. if i \\<le> ?s then 0 else ?c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have range_g: \"g c \\<in> {start..start + int q - 1}\"\n        if \"c \\<in> {0..<m - 1} \\<rightarrow> {0..<(l+1)}\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. g c \\<in> {start..start + int q - 1}", "using is_multi_arith_prog_onD[OF is_multi_arith_prog that]"], ["proof (prove)\nusing this:\n  multi_arith_prog (m - 1) start_m steps_m c\n  \\<in> {start..start + int q - 1}\n\ngoal (1 subgoal):\n 1. g c \\<in> {start..start + int q - 1}", "by (auto simp: g_def)"], ["proof (state)\nthis:\n  ?c \\<in> {0..<m - 1} \\<rightarrow> {0..<l + 1} \\<Longrightarrow>\n  g ?c \\<in> {start..start + int q - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "text \\<open>Obtain an $m$-fold arithmetic progression by adding the block-step.\\<close>"], ["proof (state)\nthis:\n  ?c \\<in> {0..<m - 1} \\<rightarrow> {0..<l + 1} \\<Longrightarrow>\n  g ?c \\<in> {start..start + int q - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "define steps :: \"nat \\<Rightarrow> nat\" where steps_def: \n        \"steps = (\\<lambda>i.  (if i=0 then step else steps_m (i-1)))\""], ["proof (state)\nthis:\n  steps = (\\<lambda>i. if i = 0 then step else steps_m (i - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "define f where \"f = multi_arith_prog m start_m steps\""], ["proof (state)\nthis:\n  f = multi_arith_prog m start_m steps\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have f_step_g: \"f c = int (c 0*step) + g (c \\<circ> Suc)\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "have \"f c = start_m + int (\\<Sum>i<Suc (m-1). c i * steps i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f c = start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i)", "using f_def"], ["proof (prove)\nusing this:\n  f = multi_arith_prog m start_m steps\n\ngoal (1 subgoal):\n 1. f c = start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i)", "unfolding multi_arith_prog_def"], ["proof (prove)\nusing this:\n  f = (\\<lambda>c. start_m + int (\\<Sum>i<m. c i * steps i))\n\ngoal (1 subgoal):\n 1. f c = start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i)", "using less.prems"], ["proof (prove)\nusing this:\n  f = (\\<lambda>c. start_m + int (\\<Sum>i<m. c i * steps i))\n  0 < m\n  0 < k\n\ngoal (1 subgoal):\n 1. f c = start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i)", "by auto"], ["proof (state)\nthis:\n  f c = start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i)\n\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "also"], ["proof (state)\nthis:\n  f c = start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i)\n\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "have \"\\<dots> = start_m + int (c 0 * steps 0) + \n                       int (\\<Sum>i<m-1. c (Suc i) * steps (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i) =\n    start_m + int (c 0 * steps 0) +\n    int (\\<Sum>i<m - 1. c (Suc i) * steps (Suc i))", "using sum.lessThan_Suc_shift[where n = \"m-1\"]"], ["proof (prove)\nusing this:\n  sum ?g {..<Suc (m - 1)} = ?g 0 + (\\<Sum>i<m - 1. ?g (Suc i))\n\ngoal (1 subgoal):\n 1. start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i) =\n    start_m + int (c 0 * steps 0) +\n    int (\\<Sum>i<m - 1. c (Suc i) * steps (Suc i))", "by auto"], ["proof (state)\nthis:\n  start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i) =\n  start_m + int (c 0 * steps 0) +\n  int (\\<Sum>i<m - 1. c (Suc i) * steps (Suc i))\n\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "also"], ["proof (state)\nthis:\n  start_m + int (\\<Sum>i<Suc (m - 1). c i * steps i) =\n  start_m + int (c 0 * steps 0) +\n  int (\\<Sum>i<m - 1. c (Suc i) * steps (Suc i))\n\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "have \"\\<dots> = start_m + int (c 0 * step) + \n                       int (\\<Sum>i<m-1. c (Suc i) * steps_m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_m + int (c 0 * steps 0) +\n    int (\\<Sum>i<m - 1. c (Suc i) * steps (Suc i)) =\n    start_m + int (c 0 * step) + int (\\<Sum>i<m - 1. c (Suc i) * steps_m i)", "using steps_def"], ["proof (prove)\nusing this:\n  steps = (\\<lambda>i. if i = 0 then step else steps_m (i - 1))\n\ngoal (1 subgoal):\n 1. start_m + int (c 0 * steps 0) +\n    int (\\<Sum>i<m - 1. c (Suc i) * steps (Suc i)) =\n    start_m + int (c 0 * step) + int (\\<Sum>i<m - 1. c (Suc i) * steps_m i)", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  start_m + int (c 0 * steps 0) +\n  int (\\<Sum>i<m - 1. c (Suc i) * steps (Suc i)) =\n  start_m + int (c 0 * step) + int (\\<Sum>i<m - 1. c (Suc i) * steps_m i)\n\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "finally"], ["proof (chain)\npicking this:\n  f c =\n  start_m + int (c 0 * step) + int (\\<Sum>i<m - 1. c (Suc i) * steps_m i)", "show ?thesis"], ["proof (prove)\nusing this:\n  f c =\n  start_m + int (c 0 * step) + int (\\<Sum>i<m - 1. c (Suc i) * steps_m i)\n\ngoal (1 subgoal):\n 1. f c = int (c 0 * step) + g (c \\<circ> Suc)", "unfolding multi_arith_prog_def g_def"], ["proof (prove)\nusing this:\n  f c =\n  start_m + int (c 0 * step) + int (\\<Sum>i<m - 1. c (Suc i) * steps_m i)\n\ngoal (1 subgoal):\n 1. f c =\n    int (c 0 * step) +\n    (start_m + int (\\<Sum>i<m - 1. (c \\<circ> Suc) i * steps_m i))", "by simp"], ["proof (state)\nthis:\n  f c = int (c 0 * step) + g (c \\<circ> Suc)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ?c = int (?c 0 * step) + g (?c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "text \\<open> Show that this $m$-fold arithmetic progression fulfills all needed properties. \\<close>"], ["proof (state)\nthis:\n  f ?c = int (?c 0 * step) + g (?c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have steps_gr_0: \"\\<forall>i<m. 0 < steps i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<m. 0 < steps i", "unfolding steps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<m. 0 < (if i = 0 then step else steps_m (i - 1))", "using step_m_pos prog"], ["proof (prove)\nusing this:\n  ?i < m - 1 \\<Longrightarrow> 0 < steps_m ?i\n  j < k ^ q\n  0 < step\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n  arith_prog start step ` {..<l}\n  \\<subseteq> col1 -` {j} \\<inter> {a..a + int n_kq - 1}\n\ngoal (1 subgoal):\n 1. \\<forall>i<m. 0 < (if i = 0 then step else steps_m (i - 1))", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<m. 0 < steps i\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have is_multi_on_f: \n        \"is_multi_arith_prog_on (l+1) m start_m steps a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "have \"a \\<le> start_m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> start_m", "using is_multi_arith_prog"], ["proof (prove)\nusing this:\n  is_multi_arith_prog_on (l + 1) (m - 1) start_m steps_m start\n   (start + int q - 1)\n\ngoal (1 subgoal):\n 1. a \\<le> start_m", "unfolding is_multi_arith_prog_on_def"], ["proof (prove)\nusing this:\n  start \\<le> start_m \\<and>\n  multi_arith_prog (m - 1) start_m steps_m (\\<lambda>_. l + 1 - 1)\n  \\<le> start + int q - 1\n\ngoal (1 subgoal):\n 1. a \\<le> start_m", "using is_arith_prog_on_def prog(3)"], ["proof (prove)\nusing this:\n  start \\<le> start_m \\<and>\n  multi_arith_prog (m - 1) start_m steps_m (\\<lambda>_. l + 1 - 1)\n  \\<le> start + int q - 1\n  is_arith_prog_on ?l ?start ?step ?a ?b =\n  (?a \\<le> ?start \\<and> arith_prog ?start ?step (?l - 1) \\<le> ?b)\n  is_arith_prog_on l start step a (a + int n_kq - 1)\n\ngoal (1 subgoal):\n 1. a \\<le> start_m", "by force"], ["proof (state)\nthis:\n  a \\<le> start_m\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "moreover"], ["proof (state)\nthis:\n  a \\<le> start_m\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "{"], ["proof (state)\nthis:\n  a \\<le> start_m\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "have \"f (\\<lambda>_. l) = arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<lambda>_. l) = arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l", "using f_step_g"], ["proof (prove)\nusing this:\n  f ?c = int (?c 0 * step) + g (?c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. f (\\<lambda>_. l) = arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  f ?c = int (?c 0 * step) + g (?c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. f (\\<lambda>_. l) = g ((\\<lambda>_. l) \\<circ> Suc) + int (l * step)", "by auto"], ["proof (state)\nthis:\n  f (\\<lambda>_. l) = arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "also"], ["proof (state)\nthis:\n  f (\\<lambda>_. l) = arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "have \"g ((\\<lambda>_. l) \\<circ> Suc) \\<le> start + q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ((\\<lambda>_. l) \\<circ> Suc) \\<le> start + int q", "using range_g[of \"(\\<lambda>_. l) \\<circ> Suc\"]"], ["proof (prove)\nusing this:\n  (\\<lambda>_. l) \\<circ> Suc\n  \\<in> {0..<m - 1} \\<rightarrow> {0..<l + 1} \\<Longrightarrow>\n  g ((\\<lambda>_. l) \\<circ> Suc) \\<in> {start..start + int q - 1}\n\ngoal (1 subgoal):\n 1. g ((\\<lambda>_. l) \\<circ> Suc) \\<le> start + int q", "by auto"], ["proof (state)\nthis:\n  g ((\\<lambda>_. l) \\<circ> Suc) \\<le> start + int q\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "then"], ["proof (chain)\npicking this:\n  g ((\\<lambda>_. l) \\<circ> Suc) \\<le> start + int q", "have \"arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l \\<le> \n            arith_prog start step l + q\""], ["proof (prove)\nusing this:\n  g ((\\<lambda>_. l) \\<circ> Suc) \\<le> start + int q\n\ngoal (1 subgoal):\n 1. arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l\n    \\<le> arith_prog start step l + int q", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  g ((\\<lambda>_. l) \\<circ> Suc) \\<le> start + int q\n\ngoal (1 subgoal):\n 1. g ((\\<lambda>_. l) \\<circ> Suc) + int (l * step)\n    \\<le> start + int (l * step) + int q", "by auto"], ["proof (state)\nthis:\n  arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l\n  \\<le> arith_prog start step l + int q\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "also"], ["proof (state)\nthis:\n  arith_prog (g ((\\<lambda>_. l) \\<circ> Suc)) step l\n  \\<le> arith_prog start step l + int q\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "have \"\\<dots>\\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog start step l + int q \\<le> b", "using prog_in_ivl[of l]"], ["proof (prove)\nusing this:\n  l \\<le> l \\<Longrightarrow>\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n\ngoal (1 subgoal):\n 1. arith_prog start step l + int q \\<le> b", "using is_multi_arith_prog"], ["proof (prove)\nusing this:\n  l \\<le> l \\<Longrightarrow>\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n  is_multi_arith_prog_on (l + 1) (m - 1) start_m steps_m start\n   (start + int q - 1)\n\ngoal (1 subgoal):\n 1. arith_prog start step l + int q \\<le> b", "unfolding is_multi_arith_prog_on_def"], ["proof (prove)\nusing this:\n  l \\<le> l \\<Longrightarrow>\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n  start \\<le> start_m \\<and>\n  multi_arith_prog (m - 1) start_m steps_m (\\<lambda>_. l + 1 - 1)\n  \\<le> start + int q - 1\n\ngoal (1 subgoal):\n 1. arith_prog start step l + int q \\<le> b", "using \"1\"(1) N_def"], ["proof (prove)\nusing this:\n  l \\<le> l \\<Longrightarrow>\n  arith_prog start step l \\<in> {a..a + 2 * int n_kq - 1}\n  start \\<le> start_m \\<and>\n  multi_arith_prog (m - 1) start_m steps_m (\\<lambda>_. l + 1 - 1)\n  \\<le> start + int q - 1\n  a + int N \\<le> b + 1\n  N = q + 2 * n_kq\n\ngoal (1 subgoal):\n 1. arith_prog start step l + int q \\<le> b", "by auto"], ["proof (state)\nthis:\n  arith_prog start step l + int q \\<le> b\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "finally"], ["proof (chain)\npicking this:\n  f (\\<lambda>_. l) \\<le> b", "have \"f (\\<lambda>_. l) \\<le> b\""], ["proof (prove)\nusing this:\n  f (\\<lambda>_. l) \\<le> b\n\ngoal (1 subgoal):\n 1. f (\\<lambda>_. l) \\<le> b", "by auto"], ["proof (state)\nthis:\n  f (\\<lambda>_. l) \\<le> b\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "}"], ["proof (state)\nthis:\n  f (\\<lambda>_. l) \\<le> b\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> start_m\n  f (\\<lambda>_. l) \\<le> b", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> start_m\n  f (\\<lambda>_. l) \\<le> b\n\ngoal (1 subgoal):\n 1. is_multi_arith_prog_on (l + 1) m start_m steps a b", "unfolding is_multi_arith_prog_on_def f_def"], ["proof (prove)\nusing this:\n  a \\<le> start_m\n  multi_arith_prog m start_m steps (\\<lambda>_. l) \\<le> b\n\ngoal (1 subgoal):\n 1. a \\<le> start_m \\<and>\n    multi_arith_prog m start_m steps (\\<lambda>_. l + 1 - 1) \\<le> b", "by auto"], ["proof (state)\nthis:\n  is_multi_arith_prog_on (l + 1) m start_m steps a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_multi_arith_prog_on (l + 1) m start_m steps a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "text \\<open> Show the relational property for all $s$. \\<close>"], ["proof (state)\nthis:\n  is_multi_arith_prog_on (l + 1) m start_m steps a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "have rel_prop_1: \n        \"col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\"\n        if \"c \\<in> {0..<m} \\<rightarrow> {0..l}\" \"s<m\" \"\\<forall>j\\<le>s. c j < l\" for c s"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "proof (cases \"s = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "case True"], ["proof (state)\nthis:\n  s = 0\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"c 0 < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c 0 < l", "using that(3) True"], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>s. c j < l\n  s = 0\n\ngoal (1 subgoal):\n 1. c 0 < l", "by auto"], ["proof (state)\nthis:\n  c 0 < l\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have range_c_Suc: \"c \\<circ> Suc \\<in> {0..<m-1} \\<rightarrow> {0..l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}", "using that(1)"], ["proof (prove)\nusing this:\n  c \\<in> {0..<m} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}", "by auto"], ["proof (state)\nthis:\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"f c = arith_prog (g (c \\<circ> Suc)) step (c 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f c = arith_prog (g (c \\<circ> Suc)) step (c 0)", "using f_step_g"], ["proof (prove)\nusing this:\n  f ?c = int (?c 0 * step) + g (?c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. f c = arith_prog (g (c \\<circ> Suc)) step (c 0)", "unfolding arith_prog_def"], ["proof (prove)\nusing this:\n  f ?c = int (?c 0 * step) + g (?c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. f c = g (c \\<circ> Suc) + int (c 0 * step)", "by auto"], ["proof (state)\nthis:\n  f c = arith_prog (g (c \\<circ> Suc)) step (c 0)\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "then"], ["proof (chain)\npicking this:\n  f c = arith_prog (g (c \\<circ> Suc)) step (c 0)", "have \"col (f c) = col (arith_prog (g (c \\<circ> Suc)) step 0)\""], ["proof (prove)\nusing this:\n  f c = arith_prog (g (c \\<circ> Suc)) step (c 0)\n\ngoal (1 subgoal):\n 1. col (f c) = col (arith_prog (g (c \\<circ> Suc)) step 0)", "using one_step_more'[of \"g (c \\<circ> Suc)\" \"c 0\"] \\<open>c 0 < l\\<close>\n            range_g[of \"c \\<circ> Suc\"] range_c_Suc \n            atLeastLessThanSuc_atLeastAtMost"], ["proof (prove)\nusing this:\n  f c = arith_prog (g (c \\<circ> Suc)) step (c 0)\n  \\<lbrakk>g (c \\<circ> Suc) \\<in> {start..<start + int q};\n   c 0 \\<in> {..<l}\\<rbrakk>\n  \\<Longrightarrow> col (arith_prog (g (c \\<circ> Suc)) step (c 0)) =\n                    col (arith_prog (g (c \\<circ> Suc)) step 0)\n  c 0 < l\n  c \\<circ> Suc\n  \\<in> {0..<m - 1} \\<rightarrow> {0..<l + 1} \\<Longrightarrow>\n  g (c \\<circ> Suc) \\<in> {start..start + int q - 1}\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  {?l..<Suc ?u} = {?l..?u}\n\ngoal (1 subgoal):\n 1. col (f c) = col (arith_prog (g (c \\<circ> Suc)) step 0)", "by auto"], ["proof (state)\nthis:\n  col (f c) = col (arith_prog (g (c \\<circ> Suc)) step 0)\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  col (f c) = col (arith_prog (g (c \\<circ> Suc)) step 0)\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "{"], ["proof (state)\nthis:\n  col (f c) = col (arith_prog (g (c \\<circ> Suc)) step 0)\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"(\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n                   (\\<Sum>x=1..<m. int(c x) * int (steps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n    (\\<Sum>x = 1..<m. int (c x) * int (steps x))", "by(rule sum.reindex_bij_witness[of _ \"(\\<lambda>x. x-1)\" \"Suc\"]) \n              (auto simp: steps_def split:if_splits)"], ["proof (state)\nthis:\n  (\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n  (\\<Sum>x = 1..<m. int (c x) * int (steps x))\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n  (\\<Sum>x = 1..<m. int (c x) * int (steps x))\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"\\<dots> = (\\<Sum>x<m. int (if x = 0 then 0 else c x) * \n            int (steps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 1..<m. int (c x) * int (steps x)) =\n    (\\<Sum>x<m. int (if x = 0 then 0 else c x) * int (steps x))", "by (rule sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>x = 1..<m. int (c x) * int (steps x)) =\n  (\\<Sum>x<m. int (if x = 0 then 0 else c x) * int (steps x))\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n  (\\<Sum>x<m. int (if x = 0 then 0 else c x) * int (steps x))", "have \"arith_prog (g (c \\<circ> Suc)) step 0 = \n            f (\\<lambda>i. if i \\<le> s then 0 else c i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n  (\\<Sum>x<m. int (if x = 0 then 0 else c x) * int (steps x))\n\ngoal (1 subgoal):\n 1. arith_prog (g (c \\<circ> Suc)) step 0 =\n    f (\\<lambda>i. if i \\<le> s then 0 else c i)", "unfolding f_def g_def multi_arith_prog_def arith_prog_def"], ["proof (prove)\nusing this:\n  (\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n  (\\<Sum>x<m. int (if x = 0 then 0 else c x) * int (steps x))\n\ngoal (1 subgoal):\n 1. start_m + int (\\<Sum>i<m - 1. (c \\<circ> Suc) i * steps_m i) +\n    int (0 * step) =\n    start_m + int (\\<Sum>i<m. (if i \\<le> s then 0 else c i) * steps i)", "using True"], ["proof (prove)\nusing this:\n  (\\<Sum>x<m - 1. int (c (Suc x)) * int (steps_m x)) =\n  (\\<Sum>x<m. int (if x = 0 then 0 else c x) * int (steps x))\n  s = 0\n\ngoal (1 subgoal):\n 1. start_m + int (\\<Sum>i<m - 1. (c \\<circ> Suc) i * steps_m i) +\n    int (0 * step) =\n    start_m + int (\\<Sum>i<m. (if i \\<le> s then 0 else c i) * steps i)", "by auto"], ["proof (state)\nthis:\n  arith_prog (g (c \\<circ> Suc)) step 0 =\n  f (\\<lambda>i. if i \\<le> s then 0 else c i)\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "}"], ["proof (state)\nthis:\n  arith_prog (g (c \\<circ> Suc)) step 0 =\n  f (\\<lambda>i. if i \\<le> s then 0 else c i)\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n 2. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "finally"], ["proof (chain)\npicking this:\n  col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "show ?thesis"], ["proof (prove)\nusing this:\n  col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal (1 subgoal):\n 1. col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "by auto"], ["proof (state)\nthis:\n  col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "case False"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "hence s_greater_0: \"s > 0\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < s", "by auto"], ["proof (state)\nthis:\n  0 < s\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have range_c_Suc: \"c \\<circ> Suc \\<in> {0..<m-1} \\<rightarrow> {0..l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}", "using that(1)"], ["proof (prove)\nusing this:\n  c \\<in> {0..<m} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}", "by auto"], ["proof (state)\nthis:\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"c 0 < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c 0 < l", "using \\<open>s>0\\<close> that"], ["proof (prove)\nusing this:\n  0 < s\n  c \\<in> {0..<m} \\<rightarrow> {0..l}\n  s < m\n  \\<forall>j\\<le>s. c j < l\n\ngoal (1 subgoal):\n 1. c 0 < l", "by auto"], ["proof (state)\nthis:\n  c 0 < l\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have g_IH:\n          \"col (g c') = col (g (\\<lambda>i. if i \\<le> s' then 0 else c' i))\" \n          if \"c' \\<in> {0..<m-1} \\<rightarrow> {0..l}\" \"s'<m-1\" \"\\<forall>j\\<le>s'. c' j < l\" \n          for c' s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (g c') = col (g (\\<lambda>i. if i \\<le> s' then 0 else c' i))", "using g_aux that"], ["proof (prove)\nusing this:\n  let g = multi_arith_prog (m - 1) start_m steps_m\n  in \\<forall>c\\<in>{0..<m - 1} \\<rightarrow> {0..l}.\n        \\<forall>s<m - 1.\n           (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n           col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))\n  c' \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  s' < m - 1\n  \\<forall>j\\<le>s'. c' j < l\n\ngoal (1 subgoal):\n 1. col (g c') = col (g (\\<lambda>i. if i \\<le> s' then 0 else c' i))", "unfolding multi_arith_prog_def g_def"], ["proof (prove)\nusing this:\n  let g = \\<lambda>c. start_m + int (\\<Sum>i<m - 1. c i * steps_m i)\n  in \\<forall>c\\<in>{0..<m - 1} \\<rightarrow> {0..l}.\n        \\<forall>s<m - 1.\n           (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n           col (g c) = col (g (\\<lambda>i. if i \\<le> s then 0 else c i))\n  c' \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  s' < m - 1\n  \\<forall>j\\<le>s'. c' j < l\n\ngoal (1 subgoal):\n 1. col (start_m + int (\\<Sum>i<m - 1. c' i * steps_m i)) =\n    col (start_m +\n         int (\\<Sum>i<m - 1. (if i \\<le> s' then 0 else c' i) * steps_m i))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?c' \\<in> {0..<m - 1} \\<rightarrow> {0..l}; ?s' < m - 1;\n   \\<forall>j\\<le>?s'. ?c' j < l\\<rbrakk>\n  \\<Longrightarrow> col (g ?c') =\n                    col (g (\\<lambda>i. if i \\<le> ?s' then 0 else ?c' i))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have g_shift_IH: \"col (g (c \\<circ> Suc)) = \n          col (g ((\\<lambda>i. if i\\<in>{1..t} then 0 else c i) \\<circ> Suc))\" \n          if \"c \\<in> {1..<m} \\<rightarrow> {0..l}\" \"t\\<in>{1..<m}\" \"\\<forall>j\\<in>{1..t}. c j < l\"\n          for c t"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "have \"(\\<lambda>i. (if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i)) =\n                (\\<lambda>i. (if i \\<in> {1..t} then 0 else c i)) \\<circ> Suc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n    (\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc", "using that"], ["proof (prove)\nusing this:\n  c \\<in> {1..<m} \\<rightarrow> {0..l}\n  t \\<in> {1..<m}\n  \\<forall>j\\<in>{1..t}. c j < l\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n    (\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc", "by (auto split: if_splits simp:fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n  (\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n  (\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc", "have right: \n            \"g (\\<lambda>i. if i \\<le> (t-1) then 0 else (c \\<circ> Suc) i) = \n             g ((\\<lambda>i. if i\\<in>{1..t} then 0 else c i) \\<circ> Suc)\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n  (\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc\n\ngoal (1 subgoal):\n 1. g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n    g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc)", "by auto"], ["proof (state)\nthis:\n  g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n  g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "have \"(c \\<circ> Suc)\\<in> {0..<m-1} \\<rightarrow> {0..l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}", "using that(1)"], ["proof (prove)\nusing this:\n  c \\<in> {1..<m} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}", "by auto"], ["proof (state)\nthis:\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "moreover"], ["proof (state)\nthis:\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "have \"t-1<m-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - 1 < m - 1", "using that(2)"], ["proof (prove)\nusing this:\n  t \\<in> {1..<m}\n\ngoal (1 subgoal):\n 1. t - 1 < m - 1", "by auto"], ["proof (state)\nthis:\n  t - 1 < m - 1\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "moreover"], ["proof (state)\nthis:\n  t - 1 < m - 1\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "have\"\\<forall>j\\<le>t-1. (c \\<circ> Suc) j < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>t - 1. (c \\<circ> Suc) j < l", "using that"], ["proof (prove)\nusing this:\n  c \\<in> {1..<m} \\<rightarrow> {0..l}\n  t \\<in> {1..<m}\n  \\<forall>j\\<in>{1..t}. c j < l\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>t - 1. (c \\<circ> Suc) j < l", "by auto"], ["proof (state)\nthis:\n  \\<forall>j\\<le>t - 1. (c \\<circ> Suc) j < l\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "ultimately"], ["proof (chain)\npicking this:\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  t - 1 < m - 1\n  \\<forall>j\\<le>t - 1. (c \\<circ> Suc) j < l", "have \"col (g (c \\<circ> Suc)) = \n            col (g (\\<lambda>i. (if i \\<le> t-1 then 0 else (c \\<circ> Suc) i)))\""], ["proof (prove)\nusing this:\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  t - 1 < m - 1\n  \\<forall>j\\<le>t - 1. (c \\<circ> Suc) j < l\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i))", "using g_IH[of \"(c \\<circ> Suc)\" \"t-1\"]"], ["proof (prove)\nusing this:\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  t - 1 < m - 1\n  \\<forall>j\\<le>t - 1. (c \\<circ> Suc) j < l\n  \\<lbrakk>c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l};\n   t - 1 < m - 1; \\<forall>j\\<le>t - 1. (c \\<circ> Suc) j < l\\<rbrakk>\n  \\<Longrightarrow> col (g (c \\<circ> Suc)) =\n                    col (g (\\<lambda>i.\n                               if i \\<le> t - 1 then 0\n                               else (c \\<circ> Suc) i))\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i))", "by auto"], ["proof (state)\nthis:\n  col (g (c \\<circ> Suc)) =\n  col (g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i))\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "with right"], ["proof (chain)\npicking this:\n  g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n  g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc)\n  col (g (c \\<circ> Suc)) =\n  col (g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i))", "show ?thesis"], ["proof (prove)\nusing this:\n  g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i) =\n  g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc)\n  col (g (c \\<circ> Suc)) =\n  col (g (\\<lambda>i. if i \\<le> t - 1 then 0 else (c \\<circ> Suc) i))\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))", "by auto"], ["proof (state)\nthis:\n  col (g (c \\<circ> Suc)) =\n  col (g ((\\<lambda>i. if i \\<in> {1..t} then 0 else c i) \\<circ> Suc))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?c \\<in> {1..<m} \\<rightarrow> {0..l}; ?t \\<in> {1..<m};\n   \\<forall>j\\<in>{1..?t}. ?c j < l\\<rbrakk>\n  \\<Longrightarrow> col (g (?c \\<circ> Suc)) =\n                    col (g ((\\<lambda>i.\n                                if i \\<in> {1..?t} then 0 else ?c i) \\<circ>\n                            Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"col (f c) = col (int (c 0 * step) + g (c \\<circ> Suc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (f c) = col (int (c 0 * step) + g (c \\<circ> Suc))", "using f_step_g"], ["proof (prove)\nusing this:\n  f ?c = int (?c 0 * step) + g (?c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. col (f c) = col (int (c 0 * step) + g (c \\<circ> Suc))", "by simp"], ["proof (state)\nthis:\n  col (f c) = col (int (c 0 * step) + g (c \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  col (f c) = col (int (c 0 * step) + g (c \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"int (c 0 * step) + g (c \\<circ> Suc) = \n          arith_prog (g (c \\<circ> Suc)) step (c 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (c 0 * step) + g (c \\<circ> Suc) =\n    arith_prog (g (c \\<circ> Suc)) step (c 0)", "by (simp add: arith_prog_def)"], ["proof (state)\nthis:\n  int (c 0 * step) + g (c \\<circ> Suc) =\n  arith_prog (g (c \\<circ> Suc)) step (c 0)\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  int (c 0 * step) + g (c \\<circ> Suc) =\n  arith_prog (g (c \\<circ> Suc)) step (c 0)\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"col \\<dots> = col (arith_prog (g (c \\<circ> Suc)) step 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (arith_prog (g (c \\<circ> Suc)) step (c 0)) =\n    col (arith_prog (g (c \\<circ> Suc)) step 0)", "using one_step_more'[of \"g (c \\<circ> Suc)\" \"c 0\"] \\<open>c 0 < l\\<close> \n            range_g[of \"c \\<circ> Suc\"] range_c_Suc \n            atLeastLessThanSuc_atLeastAtMost"], ["proof (prove)\nusing this:\n  \\<lbrakk>g (c \\<circ> Suc) \\<in> {start..<start + int q};\n   c 0 \\<in> {..<l}\\<rbrakk>\n  \\<Longrightarrow> col (arith_prog (g (c \\<circ> Suc)) step (c 0)) =\n                    col (arith_prog (g (c \\<circ> Suc)) step 0)\n  c 0 < l\n  c \\<circ> Suc\n  \\<in> {0..<m - 1} \\<rightarrow> {0..<l + 1} \\<Longrightarrow>\n  g (c \\<circ> Suc) \\<in> {start..start + int q - 1}\n  c \\<circ> Suc \\<in> {0..<m - 1} \\<rightarrow> {0..l}\n  {?l..<Suc ?u} = {?l..?u}\n\ngoal (1 subgoal):\n 1. col (arith_prog (g (c \\<circ> Suc)) step (c 0)) =\n    col (arith_prog (g (c \\<circ> Suc)) step 0)", "by auto"], ["proof (state)\nthis:\n  col (arith_prog (g (c \\<circ> Suc)) step (c 0)) =\n  col (arith_prog (g (c \\<circ> Suc)) step 0)\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  col (arith_prog (g (c \\<circ> Suc)) step (c 0)) =\n  col (arith_prog (g (c \\<circ> Suc)) step 0)\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"\\<dots> = col (g (c \\<circ> Suc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (arith_prog (g (c \\<circ> Suc)) step 0) = col (g (c \\<circ> Suc))", "unfolding arith_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc) + int (0 * step)) = col (g (c \\<circ> Suc))", "by auto"], ["proof (state)\nthis:\n  col (arith_prog (g (c \\<circ> Suc)) step 0) = col (g (c \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  col (arith_prog (g (c \\<circ> Suc)) step 0) = col (g (c \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"\\<dots> = col (g ((\\<lambda>i. if  i\\<in>{1..s} then 0 else c i) \\<circ>\n          Suc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..s} then 0 else c i) \\<circ> Suc))", "using g_shift_IH[of \"c\" s] \\<open>s>0\\<close> that"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<in> {1..<m} \\<rightarrow> {0..l}; s \\<in> {1..<m};\n   \\<forall>j\\<in>{1..s}. c j < l\\<rbrakk>\n  \\<Longrightarrow> col (g (c \\<circ> Suc)) =\n                    col (g ((\\<lambda>i.\n                                if i \\<in> {1..s} then 0 else c i) \\<circ>\n                            Suc))\n  0 < s\n  c \\<in> {0..<m} \\<rightarrow> {0..l}\n  s < m\n  \\<forall>j\\<le>s. c j < l\n\ngoal (1 subgoal):\n 1. col (g (c \\<circ> Suc)) =\n    col (g ((\\<lambda>i. if i \\<in> {1..s} then 0 else c i) \\<circ> Suc))", "by force"], ["proof (state)\nthis:\n  col (g (c \\<circ> Suc)) =\n  col (g ((\\<lambda>i. if i \\<in> {1..s} then 0 else c i) \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  col (g (c \\<circ> Suc)) =\n  col (g ((\\<lambda>i. if i \\<in> {1..s} then 0 else c i) \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"\\<dots> = col ((\\<lambda>c. int (c 0 * step) + \n          g (c \\<circ> Suc))(\\<lambda>i. if i\\<le>s then 0 else c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (g ((\\<lambda>i. if i \\<in> {1..s} then 0 else c i) \\<circ> Suc)) =\n    col (int ((if 0 \\<le> s then 0 else c 0) * step) +\n         g ((\\<lambda>i. if i \\<le> s then 0 else c i) \\<circ> Suc))", "by (auto simp: g_def multi_arith_prog_def)"], ["proof (state)\nthis:\n  col (g ((\\<lambda>i. if i \\<in> {1..s} then 0 else c i) \\<circ> Suc)) =\n  col (int ((if 0 \\<le> s then 0 else c 0) * step) +\n       g ((\\<lambda>i. if i \\<le> s then 0 else c i) \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "also"], ["proof (state)\nthis:\n  col (g ((\\<lambda>i. if i \\<in> {1..s} then 0 else c i) \\<circ> Suc)) =\n  col (int ((if 0 \\<le> s then 0 else c 0) * step) +\n       g ((\\<lambda>i. if i \\<le> s then 0 else c i) \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "have \"\\<dots> = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (int ((if 0 \\<le> s then 0 else c 0) * step) +\n         g ((\\<lambda>i. if i \\<le> s then 0 else c i) \\<circ> Suc)) =\n    col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "unfolding f_step_g"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (int ((if 0 \\<le> s then 0 else c 0) * step) +\n         g ((\\<lambda>i. if i \\<le> s then 0 else c i) \\<circ> Suc)) =\n    col (int ((if 0 \\<le> s then 0 else c 0) * step) +\n         g ((\\<lambda>i. if i \\<le> s then 0 else c i) \\<circ> Suc))", "by auto"], ["proof (state)\nthis:\n  col (int ((if 0 \\<le> s then 0 else c 0) * step) +\n       g ((\\<lambda>i. if i \\<le> s then 0 else c i) \\<circ> Suc)) =\n  col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow>\n    col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "finally"], ["proof (chain)\npicking this:\n  col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "show ?thesis"], ["proof (prove)\nusing this:\n  col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal (1 subgoal):\n 1. col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "by simp"], ["proof (state)\nthis:\n  col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?c \\<in> {0..<m} \\<rightarrow> {0..l}; ?s < m;\n   \\<forall>j\\<le>?s. ?c j < l\\<rbrakk>\n  \\<Longrightarrow> col (f ?c) =\n                    col (f (\\<lambda>i. if i \\<le> ?s then 0 else ?c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>start steps.\n                            (\\<forall>i<m. 0 < steps i) \\<and>\n                            is_multi_arith_prog_on (l + 1) m start steps a\n                             b \\<and>\n                            (let f = multi_arith_prog m start steps\n                             in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n                                   \\<forall>s<m.\n(\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\ncol (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>start steps.\n       (\\<forall>i<m. 0 < steps i) \\<and>\n       is_multi_arith_prog_on (l + 1) m start steps a b \\<and>\n       (let f = multi_arith_prog m start steps\n        in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n              \\<forall>s<m.\n                 (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                 col (f c) =\n                 col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))", "by (rule exI[of _ start_m], rule exI[of _ steps])\n           (use steps_gr_0 is_multi_on_f rel_prop_1 in \n             \\<open>auto simp: f_def Let_def steps_def\\<close>)"], ["proof (state)\nthis:\n  \\<exists>start steps.\n     (\\<forall>i<m. 0 < steps i) \\<and>\n     is_multi_arith_prog_on (l + 1) m start steps a b \\<and>\n     (let f = multi_arith_prog m start steps\n      in \\<forall>c\\<in>{0..<m} \\<rightarrow> {0..l}.\n            \\<forall>s<m.\n               (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n               col (f c) =\n               col (f (\\<lambda>i. if i \\<le> s then 0 else c i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vdw_lemma k m l N\n\ngoal (1 subgoal):\n 1. 1 < m \\<Longrightarrow> \\<exists>a. vdw_lemma k m l a", "then"], ["proof (chain)\npicking this:\n  vdw_lemma k m l N", "show ?case"], ["proof (prove)\nusing this:\n  vdw_lemma k m l N\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw_lemma k m l a", ".."], ["proof (state)\nthis:\n  \\<exists>a. vdw_lemma k m l a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. vdw_lemma k m l a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Secondly, we show that \\<open>vdw_lemma\\<close> implies the induction step of Van der Waerden's Theorem\nusing the pigeonhole principle. \\<close>"], ["", "lemma vdw_lemma_imp_vdw:\n  assumes \"vdw_lemma k k l N\"\n  shows   \"vdw k (Suc l) N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vdw k (Suc l) N", "unfolding vdw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b col.\n       a + int N \\<le> b + 1 \\<and>\n       col \\<in> {a..b} \\<rightarrow> {..<k} \\<longrightarrow>\n       (\\<exists>j start step.\n           j < k \\<and>\n           0 < step \\<and>\n           is_arith_prog_on (Suc l) start step a b \\<and>\n           arith_prog start step ` {..<Suc l}\n           \\<subseteq> col -` {j} \\<inter> {a..b})", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "text \\<open>Idea: Proof uses pigeonhole principle to guarantee the existence of an arithmetic \n            progression of length $l+1$ with the same colour. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "case (1 a b col)"], ["proof (state)\nthis:\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "obtain start steps where prog:\n    \"\\<And>i. i < k \\<Longrightarrow> steps i > 0\"\n    \"is_multi_arith_prog_on (l+1) k start steps a b\"\n    \"let f = multi_arith_prog k start steps\n     in  \\<forall>c \\<in> {0..<k} \\<rightarrow> {0..l}. \\<forall>s<k. (\\<forall> j \\<le> s. c j < l) \\<longrightarrow>\n            col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>steps start.\n        \\<lbrakk>\\<And>i. i < k \\<Longrightarrow> 0 < steps i;\n         is_multi_arith_prog_on (l + 1) k start steps a b;\n         let f = multi_arith_prog k start steps\n         in \\<forall>c\\<in>{0..<k} \\<rightarrow> {0..l}.\n               \\<forall>s<k.\n                  (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                  col (f c) =\n                  col (f (\\<lambda>i.\n                             if i \\<le> s then 0 else c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms 1"], ["proof (prove)\nusing this:\n  vdw_lemma k k l N\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. (\\<And>steps start.\n        \\<lbrakk>\\<And>i. i < k \\<Longrightarrow> 0 < steps i;\n         is_multi_arith_prog_on (l + 1) k start steps a b;\n         let f = multi_arith_prog k start steps\n         in \\<forall>c\\<in>{0..<k} \\<rightarrow> {0..l}.\n               \\<forall>s<k.\n                  (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n                  col (f c) =\n                  col (f (\\<lambda>i.\n                             if i \\<le> s then 0 else c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim vdw_lemmaE[where a=a and b=b and col=col and m=k \n          and k=k and l=l and n=N]) auto"], ["proof (state)\nthis:\n  ?i < k \\<Longrightarrow> 0 < steps ?i\n  is_multi_arith_prog_on (l + 1) k start steps a b\n  let f = multi_arith_prog k start steps\n  in \\<forall>c\\<in>{0..<k} \\<rightarrow> {0..l}.\n        \\<forall>s<k.\n           (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n           col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "text \\<open> Obtain a $k$-fold arithmetic progression $f$ of length $l$ from assumptions. \\<close>"], ["proof (state)\nthis:\n  ?i < k \\<Longrightarrow> 0 < steps ?i\n  is_multi_arith_prog_on (l + 1) k start steps a b\n  let f = multi_arith_prog k start steps\n  in \\<forall>c\\<in>{0..<k} \\<rightarrow> {0..l}.\n        \\<forall>s<k.\n           (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n           col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define f where \"f = multi_arith_prog k start steps\""], ["proof (state)\nthis:\n  f = multi_arith_prog k start steps\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have rel_propE: \"col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\"\n    if \"c \\<in> {0..<k} \\<rightarrow> {0..l}\" \"s<k\" \"\\<forall> j \\<le> s. c j < l\"\n    for c s"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "using prog(3) that"], ["proof (prove)\nusing this:\n  let f = multi_arith_prog k start steps\n  in \\<forall>c\\<in>{0..<k} \\<rightarrow> {0..l}.\n        \\<forall>s<k.\n           (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n           col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))\n  c \\<in> {0..<k} \\<rightarrow> {0..l}\n  s < k\n  \\<forall>j\\<le>s. c j < l\n\ngoal (1 subgoal):\n 1. col (f c) = col (f (\\<lambda>i. if i \\<le> s then 0 else c i))", "unfolding f_def Let_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>{0..<k} \\<rightarrow> {0..l}.\n     \\<forall>s<k.\n        (\\<forall>j\\<le>s. c j < l) \\<longrightarrow>\n        col (multi_arith_prog k start steps c) =\n        col (multi_arith_prog k start steps\n              (\\<lambda>i. if i \\<le> s then 0 else c i))\n  c \\<in> {0..<k} \\<rightarrow> {0..l}\n  s < k\n  \\<forall>j\\<le>s. c j < l\n\ngoal (1 subgoal):\n 1. col (multi_arith_prog k start steps c) =\n    col (multi_arith_prog k start steps\n          (\\<lambda>i. if i \\<le> s then 0 else c i))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?c \\<in> {0..<k} \\<rightarrow> {0..l}; ?s < k;\n   \\<forall>j\\<le>?s. ?c j < l\\<rbrakk>\n  \\<Longrightarrow> col (f ?c) =\n                    col (f (\\<lambda>i. if i \\<le> ?s then 0 else ?c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "text \\<open>There are $k+1$ values $a_r = f(0,\\dots,0,l,\\dots,l)$ with $0\\leq r\\leq k$ zeros.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?c \\<in> {0..<k} \\<rightarrow> {0..l}; ?s < k;\n   \\<forall>j\\<le>?s. ?c j < l\\<rbrakk>\n  \\<Longrightarrow> col (f ?c) =\n                    col (f (\\<lambda>i. if i \\<le> ?s then 0 else ?c i))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define a_r where \"a_r = (\\<lambda>r. f (\\<lambda>i. (if i<r then 0 else l)))\""], ["proof (state)\nthis:\n  a_r = (\\<lambda>r. f (\\<lambda>i. if i < r then 0 else l))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have range_col_a_r: \"col (a_r x) < k\" if \"x < k+1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (a_r x) < k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col (a_r x) < k", "have \"a_r x \\<in> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_r x \\<in> {a..b}", "unfolding a_r_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. multi_arith_prog k start steps (\\<lambda>i. if i < x then 0 else l)\n    \\<in> {a..b}", "by (intro is_multi_arith_prog_onD[OF prog(2)]) auto"], ["proof (state)\nthis:\n  a_r x \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. col (a_r x) < k", "thus ?thesis"], ["proof (prove)\nusing this:\n  a_r x \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. col (a_r x) < k", "using 1"], ["proof (prove)\nusing this:\n  a_r x \\<in> {a..b}\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. col (a_r x) < k", "by blast"], ["proof (state)\nthis:\n  col (a_r x) < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < k + 1 \\<Longrightarrow> col (a_r ?x) < k\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "then"], ["proof (chain)\npicking this:\n  ?x < k + 1 \\<Longrightarrow> col (a_r ?x) < k", "have \"(col \\<circ> a_r) ` {..<k + 1} \\<subseteq> {..<k}\""], ["proof (prove)\nusing this:\n  ?x < k + 1 \\<Longrightarrow> col (a_r ?x) < k\n\ngoal (1 subgoal):\n 1. (col \\<circ> a_r) ` {..<k + 1} \\<subseteq> {..<k}", "using 1(2)"], ["proof (prove)\nusing this:\n  ?x < k + 1 \\<Longrightarrow> col (a_r ?x) < k\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n\ngoal (1 subgoal):\n 1. (col \\<circ> a_r) ` {..<k + 1} \\<subseteq> {..<k}", "by auto"], ["proof (state)\nthis:\n  (col \\<circ> a_r) ` {..<k + 1} \\<subseteq> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "then"], ["proof (chain)\npicking this:\n  (col \\<circ> a_r) ` {..<k + 1} \\<subseteq> {..<k}", "have \"card ((col \\<circ> a_r) ` {..<k + 1}) \\<le> card {..<k}\""], ["proof (prove)\nusing this:\n  (col \\<circ> a_r) ` {..<k + 1} \\<subseteq> {..<k}\n\ngoal (1 subgoal):\n 1. card ((col \\<circ> a_r) ` {..<k + 1}) \\<le> card {..<k}", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card ((col \\<circ> a_r) ` {..<k + 1}) \\<le> card {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "then"], ["proof (chain)\npicking this:\n  card ((col \\<circ> a_r) ` {..<k + 1}) \\<le> card {..<k}", "have \"\\<not> inj_on (col \\<circ> a_r) {..<k+1}\""], ["proof (prove)\nusing this:\n  card ((col \\<circ> a_r) ` {..<k + 1}) \\<le> card {..<k}\n\ngoal (1 subgoal):\n 1. \\<not> inj_on (col \\<circ> a_r) {..<k + 1}", "using pigeonhole[of \"col \\<circ> a_r\" \"{..<k+1}\"]"], ["proof (prove)\nusing this:\n  card ((col \\<circ> a_r) ` {..<k + 1}) \\<le> card {..<k}\n  card ((col \\<circ> a_r) ` {..<k + 1}) < card {..<k + 1} \\<Longrightarrow>\n  \\<not> inj_on (col \\<circ> a_r) {..<k + 1}\n\ngoal (1 subgoal):\n 1. \\<not> inj_on (col \\<circ> a_r) {..<k + 1}", "by auto"], ["proof (state)\nthis:\n  \\<not> inj_on (col \\<circ> a_r) {..<k + 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "text \\<open>Using the pigeonhole principle get $r_1$ and $r_2$ where $a_{r_1}$ and $a_{r_2}$ have the \n    same colour.\\<close>"], ["proof (state)\nthis:\n  \\<not> inj_on (col \\<circ> a_r) {..<k + 1}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "then"], ["proof (chain)\npicking this:\n  \\<not> inj_on (col \\<circ> a_r) {..<k + 1}", "obtain r1 r2 where pigeon_cols:\n      \"r1\\<in>{..<k+1}\" \n      \"r2\\<in>{..<k+1}\" \n      \"r1 < r2\" \n      \"(col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\""], ["proof (prove)\nusing this:\n  \\<not> inj_on (col \\<circ> a_r) {..<k + 1}\n\ngoal (1 subgoal):\n 1. (\\<And>r1 r2.\n        \\<lbrakk>r1 \\<in> {..<k + 1}; r2 \\<in> {..<k + 1}; r1 < r2;\n         (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting) linear linorder_inj_onI)"], ["proof (state)\nthis:\n  r1 \\<in> {..<k + 1}\n  r2 \\<in> {..<k + 1}\n  r1 < r2\n  (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "text \\<open> Show that the following function $h$ is an arithmetic progression which fulfills all\n         properties for Van der Waerden's Theorem. \\<close>"], ["proof (state)\nthis:\n  r1 \\<in> {..<k + 1}\n  r2 \\<in> {..<k + 1}\n  r1 < r2\n  (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define h where \n    \"h = (\\<lambda>x. f (\\<lambda>i. (if i<r1 then 0 else (if i<r2 then x else l))))\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>x.\n      f (\\<lambda>i. if i < r1 then 0 else if i < r2 then x else l))\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"h 0 = a_r r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h 0 = a_r r2", "unfolding h_def a_r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<lambda>i. if i < r1 then 0 else if i < r2 then 0 else l) =\n    f (\\<lambda>i. if i < r2 then 0 else l)", "using \\<open>r1<r2\\<close>"], ["proof (prove)\nusing this:\n  r1 < r2\n\ngoal (1 subgoal):\n 1. f (\\<lambda>i. if i < r1 then 0 else if i < r2 then 0 else l) =\n    f (\\<lambda>i. if i < r2 then 0 else l)", "by (intro arg_cong[where f = f]) auto"], ["proof (state)\nthis:\n  h 0 = a_r r2\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "moreover"], ["proof (state)\nthis:\n  h 0 = a_r r2\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have \"h l = a_r r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h l = a_r r1", "unfolding h_def a_r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<lambda>i. if i < r1 then 0 else if i < r2 then l else l) =\n    f (\\<lambda>i. if i < r1 then 0 else l)", "using \\<open>r1<r2\\<close>"], ["proof (prove)\nusing this:\n  r1 < r2\n\ngoal (1 subgoal):\n 1. f (\\<lambda>i. if i < r1 then 0 else if i < r2 then l else l) =\n    f (\\<lambda>i. if i < r1 then 0 else l)", "by (metis le_eq_less_or_eq less_le_trans)"], ["proof (state)\nthis:\n  h l = a_r r1\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "ultimately"], ["proof (chain)\npicking this:\n  h 0 = a_r r2\n  h l = a_r r1", "have \"col (h 0) = col (h l)\""], ["proof (prove)\nusing this:\n  h 0 = a_r r2\n  h l = a_r r1\n\ngoal (1 subgoal):\n 1. col (h 0) = col (h l)", "using pigeon_cols(4)"], ["proof (prove)\nusing this:\n  h 0 = a_r r2\n  h l = a_r r1\n  (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\n\ngoal (1 subgoal):\n 1. col (h 0) = col (h l)", "by auto"], ["proof (state)\nthis:\n  col (h 0) = col (h l)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have h_col: \"col (h 0) = col (h i)\" if \"i\\<in>{..<l+1}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (h 0) = col (h i)", "proof (cases \"i=l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow> col (h 0) = col (h i)\n 2. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "case True"], ["proof (state)\nthis:\n  i = l\n\ngoal (2 subgoals):\n 1. i = l \\<Longrightarrow> col (h 0) = col (h i)\n 2. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "then"], ["proof (chain)\npicking this:\n  i = l", "show ?thesis"], ["proof (prove)\nusing this:\n  i = l\n\ngoal (1 subgoal):\n 1. col (h 0) = col (h i)", "using \\<open>col (h 0) = col (h l)\\<close>"], ["proof (prove)\nusing this:\n  i = l\n  col (h 0) = col (h l)\n\ngoal (1 subgoal):\n 1. col (h 0) = col (h i)", "by auto"], ["proof (state)\nthis:\n  col (h 0) = col (h i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> l\n\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> l", "have \"i<l\""], ["proof (prove)\nusing this:\n  i \\<noteq> l\n\ngoal (1 subgoal):\n 1. i < l", "using that"], ["proof (prove)\nusing this:\n  i \\<noteq> l\n  i \\<in> {..<l + 1}\n\ngoal (1 subgoal):\n 1. i < l", "by auto"], ["proof (state)\nthis:\n  i < l\n\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "let ?c = \"(\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "have \"?c\\<in>{0..<k} \\<rightarrow> {0..l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n    \\<in> {0..<k} \\<rightarrow> {0..l}", "using that"], ["proof (prove)\nusing this:\n  i \\<in> {..<l + 1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n    \\<in> {0..<k} \\<rightarrow> {0..l}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n  \\<in> {0..<k} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n  \\<in> {0..<k} \\<rightarrow> {0..l}\n\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "have \"(\\<forall>j\\<le>r2-1. ?c j < l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>r2 - 1.\n       (if j < r1 then 0 else if j < r2 then i else l) < l", "using \\<open>i<l\\<close> pigeon_cols(3)"], ["proof (prove)\nusing this:\n  i < l\n  r1 < r2\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>r2 - 1.\n       (if j < r1 then 0 else if j < r2 then i else l) < l", "by force"], ["proof (state)\nthis:\n  \\<forall>j\\<le>r2 - 1. (if j < r1 then 0 else if j < r2 then i else l) < l\n\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n  \\<in> {0..<k} \\<rightarrow> {0..l}\n  \\<forall>j\\<le>r2 - 1. (if j < r1 then 0 else if j < r2 then i else l) < l", "have \"col (f ?c) = \n      col (f (\\<lambda>i. if i \\<le> r2-1 then 0 else ?c i))\""], ["proof (prove)\nusing this:\n  (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n  \\<in> {0..<k} \\<rightarrow> {0..l}\n  \\<forall>j\\<le>r2 - 1. (if j < r1 then 0 else if j < r2 then i else l) < l\n\ngoal (1 subgoal):\n 1. col (f (\\<lambda>idx.\n               if idx < r1 then 0 else if idx < r2 then i else l)) =\n    col (f (\\<lambda>ia.\n               if ia \\<le> r2 - 1 then 0\n               else if ia < r1 then 0 else if ia < r2 then i else l))", "using rel_propE[of ?c \"r2-1\"] pigeon_cols"], ["proof (prove)\nusing this:\n  (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n  \\<in> {0..<k} \\<rightarrow> {0..l}\n  \\<forall>j\\<le>r2 - 1. (if j < r1 then 0 else if j < r2 then i else l) < l\n  \\<lbrakk>(\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)\n           \\<in> {0..<k} \\<rightarrow> {0..l};\n   r2 - 1 < k;\n   \\<forall>j\\<le>r2 - 1.\n      (if j < r1 then 0 else if j < r2 then i else l) < l\\<rbrakk>\n  \\<Longrightarrow> col (f (\\<lambda>idx.\n                               if idx < r1 then 0\n                               else if idx < r2 then i else l)) =\n                    col (f (\\<lambda>ia.\n                               if ia \\<le> r2 - 1 then 0\n                               else if ia < r1 then 0\n                                    else if ia < r2 then i else l))\n  r1 \\<in> {..<k + 1}\n  r2 \\<in> {..<k + 1}\n  r1 < r2\n  (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\n\ngoal (1 subgoal):\n 1. col (f (\\<lambda>idx.\n               if idx < r1 then 0 else if idx < r2 then i else l)) =\n    col (f (\\<lambda>ia.\n               if ia \\<le> r2 - 1 then 0\n               else if ia < r1 then 0 else if ia < r2 then i else l))", "by simp"], ["proof (state)\nthis:\n  col (f (\\<lambda>idx.\n             if idx < r1 then 0 else if idx < r2 then i else l)) =\n  col (f (\\<lambda>ia.\n             if ia \\<le> r2 - 1 then 0\n             else if ia < r1 then 0 else if ia < r2 then i else l))\n\ngoal (1 subgoal):\n 1. i \\<noteq> l \\<Longrightarrow> col (h 0) = col (h i)", "then"], ["proof (chain)\npicking this:\n  col (f (\\<lambda>idx.\n             if idx < r1 then 0 else if idx < r2 then i else l)) =\n  col (f (\\<lambda>ia.\n             if ia \\<le> r2 - 1 then 0\n             else if ia < r1 then 0 else if ia < r2 then i else l))", "show ?thesis"], ["proof (prove)\nusing this:\n  col (f (\\<lambda>idx.\n             if idx < r1 then 0 else if idx < r2 then i else l)) =\n  col (f (\\<lambda>ia.\n             if ia \\<le> r2 - 1 then 0\n             else if ia < r1 then 0 else if ia < r2 then i else l))\n\ngoal (1 subgoal):\n 1. col (h 0) = col (h i)", "unfolding h_def f_def"], ["proof (prove)\nusing this:\n  col (multi_arith_prog k start steps\n        (\\<lambda>idx. if idx < r1 then 0 else if idx < r2 then i else l)) =\n  col (multi_arith_prog k start steps\n        (\\<lambda>ia.\n            if ia \\<le> r2 - 1 then 0\n            else if ia < r1 then 0 else if ia < r2 then i else l))\n\ngoal (1 subgoal):\n 1. col (multi_arith_prog k start steps\n          (\\<lambda>i. if i < r1 then 0 else if i < r2 then 0 else l)) =\n    col (multi_arith_prog k start steps\n          (\\<lambda>ia. if ia < r1 then 0 else if ia < r2 then i else l))", "by (smt (z3) Nat.lessE One_nat_def add_diff_cancel_left' \n          le_less less_Suc_eq_le multi_arith_prog_mono plus_1_eq_Suc)"], ["proof (state)\nthis:\n  col (h 0) = col (h i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {..<l + 1} \\<Longrightarrow> col (h 0) = col (h ?i)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define h_start where \"h_start = start + l*(\\<Sum>i\\<in>{r2..<k}. steps i)\""], ["proof (state)\nthis:\n  h_start = start + int (l * sum steps {r2..<k})\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define h_step where \"h_step = (\\<Sum>i\\<in>{r1..<r2}. steps i)\""], ["proof (state)\nthis:\n  h_step = sum steps {r1..<r2}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have h_arith_prog: \"h = arith_prog h_start h_step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = arith_prog h_start h_step", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h = arith_prog h_start h_step", "have \"(\\<Sum>x<k. int (if x < r1 then 0 else if x < r2 then y else l)\n        * int (steps x)) =\n      int l * (\\<Sum>x = r2..<k. int (steps x)) + \n        int y * (\\<Sum>x = r1..<r2. int (steps x))\"\n      for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "proof (cases \"r2 = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "case True"], ["proof (state)\nthis:\n  r2 = k\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "then"], ["proof (chain)\npicking this:\n  r2 = k", "have \"r1<k\""], ["proof (prove)\nusing this:\n  r2 = k\n\ngoal (1 subgoal):\n 1. r1 < k", "using pigeon_cols"], ["proof (prove)\nusing this:\n  r2 = k\n  r1 \\<in> {..<k + 1}\n  r2 \\<in> {..<k + 1}\n  r1 < r2\n  (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\n\ngoal (1 subgoal):\n 1. r1 < k", "by auto"], ["proof (state)\nthis:\n  r1 < k\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "with True"], ["proof (chain)\npicking this:\n  r2 = k\n  r1 < k", "have \n        \"(\\<Sum>x<k. int (if x < r1 then 0 else if x < r2 then y else l)\n           * int (steps x)) =\n         (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x))\""], ["proof (prove)\nusing this:\n  r2 = k\n  r1 < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x)) =\n  (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x))\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x)) =\n  (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x))\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"\\<dots> = (\\<Sum>x<r1. int (if x < r1 then 0 else y) *\n          int (steps x)) + (\\<Sum>x=r1..<k. int (if x < r1 then 0 else y)\n          * int (steps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x)) =\n    (\\<Sum>x<r1. int (if x < r1 then 0 else y) * int (steps x)) +\n    (\\<Sum>x = r1..<k. int (if x < r1 then 0 else y) * int (steps x))", "using split_sum_mid_less[of r1 k \n            \"(\\<lambda>x. int (if x < r1 then 0 else y) * int (steps x))\"] \n            \\<open>r1<k\\<close>"], ["proof (prove)\nusing this:\n  r1 < k \\<Longrightarrow>\n  (\\<Sum>j<k. int (if j < r1 then 0 else y) * int (steps j)) =\n  (\\<Sum>j<r1. int (if j < r1 then 0 else y) * int (steps j)) +\n  (\\<Sum>j = r1..<k. int (if j < r1 then 0 else y) * int (steps j))\n  r1 < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x)) =\n    (\\<Sum>x<r1. int (if x < r1 then 0 else y) * int (steps x)) +\n    (\\<Sum>x = r1..<k. int (if x < r1 then 0 else y) * int (steps x))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x)) =\n  (\\<Sum>x<r1. int (if x < r1 then 0 else y) * int (steps x)) +\n  (\\<Sum>x = r1..<k. int (if x < r1 then 0 else y) * int (steps x))\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x<k. int (if x < r1 then 0 else y) * int (steps x)) =\n  (\\<Sum>x<r1. int (if x < r1 then 0 else y) * int (steps x)) +\n  (\\<Sum>x = r1..<k. int (if x < r1 then 0 else y) * int (steps x))\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"\\<dots> = (\\<Sum>x=r1..<k. int y * int (steps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<r1. int (if x < r1 then 0 else y) * int (steps x)) +\n    (\\<Sum>x = r1..<k. int (if x < r1 then 0 else y) * int (steps x)) =\n    (\\<Sum>x = r1..<k. int y * int (steps x))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x<r1. int (if x < r1 then 0 else y) * int (steps x)) +\n  (\\<Sum>x = r1..<k. int (if x < r1 then 0 else y) * int (steps x)) =\n  (\\<Sum>x = r1..<k. int y * int (steps x))\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x<r1. int (if x < r1 then 0 else y) * int (steps x)) +\n  (\\<Sum>x = r1..<k. int (if x < r1 then 0 else y) * int (steps x)) =\n  (\\<Sum>x = r1..<k. int y * int (steps x))\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"\\<dots> = int y * (\\<Sum>x=r1..<k. int (steps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = r1..<k. int y * int (steps x)) =\n    int y * (\\<Sum>x = r1..<k. int (steps x))", "by (auto simp: sum_distrib_left[of \"int y\"])"], ["proof (state)\nthis:\n  (\\<Sum>x = r1..<k. int y * int (steps x)) =\n  int y * (\\<Sum>x = r1..<k. int (steps x))\n\ngoal (2 subgoals):\n 1. r2 = k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))\n 2. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x)) =\n  int y * (\\<Sum>x = r1..<k. int (steps x))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x)) =\n  int y * (\\<Sum>x = r1..<k. int (steps x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "using True"], ["proof (prove)\nusing this:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x)) =\n  int y * (\\<Sum>x = r1..<k. int (steps x))\n  r2 = k\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x)) =\n  int l * (\\<Sum>x = r2..<k. int (steps x)) +\n  int y * (\\<Sum>x = r1..<r2. int (steps x))\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "case False"], ["proof (state)\nthis:\n  r2 \\<noteq> k\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "then"], ["proof (chain)\npicking this:\n  r2 \\<noteq> k", "have \"r2<k\""], ["proof (prove)\nusing this:\n  r2 \\<noteq> k\n\ngoal (1 subgoal):\n 1. r2 < k", "using pigeon_cols"], ["proof (prove)\nusing this:\n  r2 \\<noteq> k\n  r1 \\<in> {..<k + 1}\n  r2 \\<in> {..<k + 1}\n  r1 < r2\n  (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\n\ngoal (1 subgoal):\n 1. r2 < k", "by auto"], ["proof (state)\nthis:\n  r2 < k\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "define aux_left where \"aux_left = \n        (\\<lambda>x. int (if x < r1 then 0 else if x < r2 then y else l)\n          * int (steps x))\""], ["proof (state)\nthis:\n  aux_left =\n  (\\<lambda>x.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x))\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"(\\<Sum>x<k. aux_left x) = (\\<Sum>x=r1..<k. aux_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum aux_left {..<k} = sum aux_left {r1..<k}", "by (intro sum.mono_neutral_right) (auto simp: aux_left_def)"], ["proof (state)\nthis:\n  sum aux_left {..<k} = sum aux_left {r1..<k}\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "also"], ["proof (state)\nthis:\n  sum aux_left {..<k} = sum aux_left {r1..<k}\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"{r1..<k} = {r1..<r2} \\<union> {r2..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {r1..<k} = {r1..<r2} \\<union> {r2..<k}", "using \\<open>r1 < r2\\<close> \\<open>r2 < k\\<close>"], ["proof (prove)\nusing this:\n  r1 < r2\n  r2 < k\n\ngoal (1 subgoal):\n 1. {r1..<k} = {r1..<r2} \\<union> {r2..<k}", "by auto"], ["proof (state)\nthis:\n  {r1..<k} = {r1..<r2} \\<union> {r2..<k}\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "also"], ["proof (state)\nthis:\n  {r1..<k} = {r1..<r2} \\<union> {r2..<k}\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"(\\<Sum>x\\<in>\\<dots>. aux_left x) = (\\<Sum>x=r1..<r2. aux_left x) + \n        (\\<Sum>x=r2..<k. aux_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum aux_left ({r1..<r2} \\<union> {r2..<k}) =\n    sum aux_left {r1..<r2} + sum aux_left {r2..<k}", "by (intro sum.union_disjoint) auto"], ["proof (state)\nthis:\n  sum aux_left ({r1..<r2} \\<union> {r2..<k}) =\n  sum aux_left {r1..<r2} + sum aux_left {r2..<k}\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "also"], ["proof (state)\nthis:\n  sum aux_left ({r1..<r2} \\<union> {r2..<k}) =\n  sum aux_left {r1..<r2} + sum aux_left {r2..<k}\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"(\\<Sum>x=r1..<r2. aux_left x) =\n        (\\<Sum>x=r1..<r2. int y * int (steps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum aux_left {r1..<r2} = (\\<Sum>x = r1..<r2. int y * int (steps x))", "by (intro sum.cong) (auto simp: aux_left_def)"], ["proof (state)\nthis:\n  sum aux_left {r1..<r2} = (\\<Sum>x = r1..<r2. int y * int (steps x))\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "also"], ["proof (state)\nthis:\n  sum aux_left {r1..<r2} = (\\<Sum>x = r1..<r2. int y * int (steps x))\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "have \"(\\<Sum>x=r2..<k. aux_left x) = \n        (\\<Sum>x=r2..<k. int l * int (steps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum aux_left {r2..<k} = (\\<Sum>x = r2..<k. int l * int (steps x))", "using \\<open>r1 < r2\\<close>"], ["proof (prove)\nusing this:\n  r1 < r2\n\ngoal (1 subgoal):\n 1. sum aux_left {r2..<k} = (\\<Sum>x = r2..<k. int l * int (steps x))", "by (intro sum.cong) (auto simp: aux_left_def)"], ["proof (state)\nthis:\n  sum aux_left {r2..<k} = (\\<Sum>x = r2..<k. int l * int (steps x))\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> k \\<Longrightarrow>\n    (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "finally"], ["proof (chain)\npicking this:\n  sum aux_left {..<k} =\n  (\\<Sum>x = r1..<r2. int y * int (steps x)) +\n  (\\<Sum>x = r2..<k. int l * int (steps x))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum aux_left {..<k} =\n  (\\<Sum>x = r1..<r2. int y * int (steps x)) +\n  (\\<Sum>x = r2..<k. int l * int (steps x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<k.\n        int (if x < r1 then 0 else if x < r2 then y else l) *\n        int (steps x)) =\n    int l * (\\<Sum>x = r2..<k. int (steps x)) +\n    int y * (\\<Sum>x = r1..<r2. int (steps x))", "by (simp add: aux_left_def sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then y else l) * int (steps x)) =\n  int l * (\\<Sum>x = r2..<k. int (steps x)) +\n  int y * (\\<Sum>x = r1..<r2. int (steps x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then ?y else l) *\n      int (steps x)) =\n  int l * (\\<Sum>x = r2..<k. int (steps x)) +\n  int ?y * (\\<Sum>x = r1..<r2. int (steps x))\n\ngoal (1 subgoal):\n 1. h = arith_prog h_start h_step", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then ?y else l) *\n      int (steps x)) =\n  int l * (\\<Sum>x = r2..<k. int (steps x)) +\n  int ?y * (\\<Sum>x = r1..<r2. int (steps x))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then ?y else l) *\n      int (steps x)) =\n  int l * (\\<Sum>x = r2..<k. int (steps x)) +\n  int ?y * (\\<Sum>x = r1..<r2. int (steps x))\n\ngoal (1 subgoal):\n 1. h = arith_prog h_start h_step", "unfolding arith_prog_def h_start_def h_step_def h_def f_def\n        multi_arith_prog_def"], ["proof (prove)\nusing this:\n  (\\<Sum>x<k.\n      int (if x < r1 then 0 else if x < r2 then ?y else l) *\n      int (steps x)) =\n  int l * (\\<Sum>x = r2..<k. int (steps x)) +\n  int ?y * (\\<Sum>x = r1..<r2. int (steps x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        start +\n        int (\\<Sum>i<k.\n                (if i < r1 then 0 else if i < r2 then x else l) *\n                steps i)) =\n    (\\<lambda>i.\n        start + int (l * sum steps {r2..<k}) +\n        int (i * sum steps {r1..<r2}))", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  h = arith_prog h_start h_step\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h = arith_prog h_start h_step\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "define j where \"j = col (h 0)\""], ["proof (state)\nthis:\n  j = col (h 0)\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have case_j: \"j<k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < k", "using 1 range_col_a_r \\<open>col (h 0) = col (h l)\\<close> \n      \\<open>h l = a_r r1\\<close> j_def pigeon_cols(1)"], ["proof (prove)\nusing this:\n  a + int N \\<le> b + 1\n  col \\<in> {a..b} \\<rightarrow> {..<k}\n  ?x < k + 1 \\<Longrightarrow> col (a_r ?x) < k\n  col (h 0) = col (h l)\n  h l = a_r r1\n  j = col (h 0)\n  r1 \\<in> {..<k + 1}\n\ngoal (1 subgoal):\n 1. j < k", "by auto"], ["proof (state)\nthis:\n  j < k\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have case_step: \"h_step > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < h_step", "unfolding h_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sum steps {r1..<r2}", "using pigeon_cols"], ["proof (prove)\nusing this:\n  r1 \\<in> {..<k + 1}\n  r2 \\<in> {..<k + 1}\n  r1 < r2\n  (col \\<circ> a_r) r1 = (col \\<circ> a_r) r2\n\ngoal (1 subgoal):\n 1. 0 < sum steps {r1..<r2}", "by (intro sum_pos prog(1)) auto"], ["proof (state)\nthis:\n  0 < h_step\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have range_h: \"h i \\<in> {a..b}\" if \"i < l + 1\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. h i \\<in> {a..b}", "unfolding h_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. multi_arith_prog k start steps\n     (\\<lambda>ia. if ia < r1 then 0 else if ia < r2 then i else l)\n    \\<in> {a..b}", "by (rule is_multi_arith_prog_onD[OF prog(2)])\n      (use that in auto)"], ["proof (state)\nthis:\n  ?i < l + 1 \\<Longrightarrow> h ?i \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have case_on: \"is_arith_prog_on (l+1) h_start h_step a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arith_prog_on (l + 1) h_start h_step a b", "unfolding is_arith_prog_on_def h_arith_prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> h_start \\<and> arith_prog h_start h_step (l + 1 - 1) \\<le> b", "using range_h[of 0] range_h[of l]"], ["proof (prove)\nusing this:\n  0 < l + 1 \\<Longrightarrow> h 0 \\<in> {a..b}\n  l < l + 1 \\<Longrightarrow> h l \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. a \\<le> h_start \\<and> arith_prog h_start h_step (l + 1 - 1) \\<le> b", "by (auto simp: Max_ge[of \"{a..b}\"] Min_le[of \"{a..b}\"] \n        h_arith_prog arith_prog_def)"], ["proof (state)\nthis:\n  is_arith_prog_on (l + 1) h_start h_step a b\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "have case_col: \"h ` {..<Suc l} \\<subseteq> col -` {j} \\<inter> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ` {..<Suc l} \\<subseteq> col -` {j} \\<inter> {a..b}", "using h_col range_h"], ["proof (prove)\nusing this:\n  ?i \\<in> {..<l + 1} \\<Longrightarrow> col (h 0) = col (h ?i)\n  ?i < l + 1 \\<Longrightarrow> h ?i \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. h ` {..<Suc l} \\<subseteq> col -` {j} \\<inter> {a..b}", "unfolding j_def"], ["proof (prove)\nusing this:\n  ?i \\<in> {..<l + 1} \\<Longrightarrow> col (h 0) = col (h ?i)\n  ?i < l + 1 \\<Longrightarrow> h ?i \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. h ` {..<Suc l} \\<subseteq> col -` {col (h 0)} \\<inter> {a..b}", "by auto"], ["proof (state)\nthis:\n  h ` {..<Suc l} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>a b col.\n       \\<lbrakk>a + int N \\<le> b + 1;\n        col \\<in> {a..b} \\<rightarrow> {..<k}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j start step.\n                            j < k \\<and>\n                            0 < step \\<and>\n                            is_arith_prog_on (Suc l) start step a b \\<and>\n                            arith_prog start step ` {..<Suc l}\n                            \\<subseteq> col -` {j} \\<inter> {a..b}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j start step.\n       j < k \\<and>\n       0 < step \\<and>\n       is_arith_prog_on (Suc l) start step a b \\<and>\n       arith_prog start step ` {..<Suc l}\n       \\<subseteq> col -` {j} \\<inter> {a..b}", "using case_j case_step case_on case_col"], ["proof (prove)\nusing this:\n  j < k\n  0 < h_step\n  is_arith_prog_on (l + 1) h_start h_step a b\n  h ` {..<Suc l} \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal (1 subgoal):\n 1. \\<exists>j start step.\n       j < k \\<and>\n       0 < step \\<and>\n       is_arith_prog_on (Suc l) start step a b \\<and>\n       arith_prog start step ` {..<Suc l}\n       \\<subseteq> col -` {j} \\<inter> {a..b}", "by (auto simp: h_arith_prog)"], ["proof (state)\nthis:\n  \\<exists>j start step.\n     j < k \\<and>\n     0 < step \\<and>\n     is_arith_prog_on (Suc l) start step a b \\<and>\n     arith_prog start step ` {..<Suc l}\n     \\<subseteq> col -` {j} \\<inter> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Lastly, we assemble all lemmas to finally prove Van der Waerden's Theorem by induction on \n$l$. The cases $l=1$ and the induction start $l=2$ are treated separately and have been shown \nearlier.\\<close>"], ["", "theorem van_der_Waerden: assumes \"l>0\" \"k>0\" shows \"\\<exists>n. vdw k l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. vdw k l n", "using assms"], ["proof (prove)\nusing this:\n  0 < l\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>n. vdw k l n", "proof (induction l arbitrary: k rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>\\<And>y k.\n                   \\<lbrakk>y < x; 0 < y; 0 < k\\<rbrakk>\n                   \\<Longrightarrow> Ex (vdw k y);\n        0 < x; 0 < k\\<rbrakk>\n       \\<Longrightarrow> Ex (vdw k x)", "case (less l)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < l; 0 < ?y; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. vdw ?k ?y a\n  0 < l\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>\\<And>y k.\n                   \\<lbrakk>y < x; 0 < y; 0 < k\\<rbrakk>\n                   \\<Longrightarrow> Ex (vdw k y);\n        0 < x; 0 < k\\<rbrakk>\n       \\<Longrightarrow> Ex (vdw k x)", "consider  \"l=1\" | \"l=2\" | \"l>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = 1 \\<Longrightarrow> thesis; l = 2 \\<Longrightarrow> thesis;\n     2 < l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using less.prems"], ["proof (prove)\nusing this:\n  0 < l\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = 1 \\<Longrightarrow> thesis; l = 2 \\<Longrightarrow> thesis;\n     2 < l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>l = 1 \\<Longrightarrow> ?thesis; l = 2 \\<Longrightarrow> ?thesis;\n   2 < l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>\\<And>y k.\n                   \\<lbrakk>y < x; 0 < y; 0 < k\\<rbrakk>\n                   \\<Longrightarrow> Ex (vdw k y);\n        0 < x; 0 < k\\<rbrakk>\n       \\<Longrightarrow> Ex (vdw k x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>l = 1 \\<Longrightarrow> ?thesis; l = 2 \\<Longrightarrow> ?thesis;\n   2 < l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>l = 1 \\<Longrightarrow> ?thesis; l = 2 \\<Longrightarrow> ?thesis;\n   2 < l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw k l a", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. l = 1 \\<Longrightarrow> \\<exists>a. vdw k l a\n 2. l = 2 \\<Longrightarrow> \\<exists>a. vdw k l a\n 3. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "assume \"l=1\""], ["proof (state)\nthis:\n  l = 1\n\ngoal (3 subgoals):\n 1. l = 1 \\<Longrightarrow> \\<exists>a. vdw k l a\n 2. l = 2 \\<Longrightarrow> \\<exists>a. vdw k l a\n 3. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "then"], ["proof (chain)\npicking this:\n  l = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  l = 1\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw k l a", "using vdw_1_right"], ["proof (prove)\nusing this:\n  l = 1\n  vdw ?k 1 1\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw k l a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. vdw k l a\n\ngoal (2 subgoals):\n 1. l = 2 \\<Longrightarrow> \\<exists>a. vdw k l a\n 2. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 2 \\<Longrightarrow> \\<exists>a. vdw k l a\n 2. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "assume \"l=2\""], ["proof (state)\nthis:\n  l = 2\n\ngoal (2 subgoals):\n 1. l = 2 \\<Longrightarrow> \\<exists>a. vdw k l a\n 2. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "then"], ["proof (chain)\npicking this:\n  l = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  l = 2\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw k l a", "using vdw_2_right"], ["proof (prove)\nusing this:\n  l = 2\n  vdw ?k 2 (?k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw k l a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. vdw k l a\n\ngoal (1 subgoal):\n 1. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "assume \"l > 2\""], ["proof (state)\nthis:\n  2 < l\n\ngoal (1 subgoal):\n 1. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "then"], ["proof (chain)\npicking this:\n  2 < l", "have \"2\\<le>l-1\""], ["proof (prove)\nusing this:\n  2 < l\n\ngoal (1 subgoal):\n 1. 2 \\<le> l - 1", "by auto"], ["proof (state)\nthis:\n  2 \\<le> l - 1\n\ngoal (1 subgoal):\n 1. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "from less.IH[of \"l-1\"] \\<open>l>2\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>l - 1 < l; 0 < l - 1; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. vdw ?k (l - 1) a\n  2 < l", "have \"\\<And>k'. k'>0 \\<Longrightarrow> \\<exists>n. vdw k' (l-1) n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>l - 1 < l; 0 < l - 1; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. vdw ?k (l - 1) a\n  2 < l\n\ngoal (1 subgoal):\n 1. \\<And>k'. 0 < k' \\<Longrightarrow> \\<exists>n. vdw k' (l - 1) n", "by auto"], ["proof (state)\nthis:\n  0 < ?k' \\<Longrightarrow> \\<exists>n. vdw ?k' (l - 1) n\n\ngoal (1 subgoal):\n 1. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "with vdw_imp_vdw_lemma[of \"l-1\" k k] \\<open>l-1\\<ge>2\\<close> \\<open>k>0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>k'.\n              0 < k' \\<Longrightarrow> \\<exists>n_k'. vdw k' (l - 1) n_k';\n   2 \\<le> l - 1; 0 < k; 0 < k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>N. vdw_lemma k k (l - 1) N\n  2 \\<le> l - 1\n  0 < k\n  0 < ?k' \\<Longrightarrow> \\<exists>n. vdw ?k' (l - 1) n", "obtain N where \"vdw_lemma k k (l-1) N\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k'.\n              0 < k' \\<Longrightarrow> \\<exists>n_k'. vdw k' (l - 1) n_k';\n   2 \\<le> l - 1; 0 < k; 0 < k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>N. vdw_lemma k k (l - 1) N\n  2 \\<le> l - 1\n  0 < k\n  0 < ?k' \\<Longrightarrow> \\<exists>n. vdw ?k' (l - 1) n\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        vdw_lemma k k (l - 1) N \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vdw_lemma k k (l - 1) N\n\ngoal (1 subgoal):\n 1. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "then"], ["proof (chain)\npicking this:\n  vdw_lemma k k (l - 1) N", "have \"vdw k l N\""], ["proof (prove)\nusing this:\n  vdw_lemma k k (l - 1) N\n\ngoal (1 subgoal):\n 1. vdw k l N", "using vdw_lemma_imp_vdw[of k \"l-1\" N]"], ["proof (prove)\nusing this:\n  vdw_lemma k k (l - 1) N\n  vdw_lemma k k (l - 1) N \\<Longrightarrow> vdw k (Suc (l - 1)) N\n\ngoal (1 subgoal):\n 1. vdw k l N", "by (simp add: less.prems(1))"], ["proof (state)\nthis:\n  vdw k l N\n\ngoal (1 subgoal):\n 1. 2 < l \\<Longrightarrow> \\<exists>a. vdw k l a", "then"], ["proof (chain)\npicking this:\n  vdw k l N", "show ?thesis"], ["proof (prove)\nusing this:\n  vdw k l N\n\ngoal (1 subgoal):\n 1. \\<exists>a. vdw k l a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. vdw k l a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. vdw k l a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}