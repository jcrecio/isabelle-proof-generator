{"file_name": "/home/qj213/afp-2021-10-22/thys/Kruskal/Graph_Definition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kruskal", "problem_names": ["lemma nodes_delete_edge[simp]:\n  \"nodes (delete_edge v e v' G) = nodes G\"", "lemma edges_delete_edge[simp]:\n  \"edges (delete_edge v e v' G) = edges G - {(v,e,v')}\"", "lemma subgraph_node:\n  assumes \"subgraph H G\"\n  shows \"v \\<in> nodes G \\<longleftrightarrow> v \\<in> nodes H\"", "lemma delete_add_edge:\n  assumes \"a \\<in> nodes H\"\n  assumes \"c \\<in> nodes H\"\n  assumes \"(a, w, c) \\<notin> edges H\"\n  shows \"delete_edge a w c (add_edge a w c H) = H\"", "lemma swap_delete_add_edge:\n  assumes \"(a, b, c) \\<noteq> (x, y, z)\"\n  shows \"delete_edge a b c (add_edge x y z H) = add_edge x y z (delete_edge a b c H)\"", "lemma swap_delete_edges: \"delete_edge a b c (delete_edge x y z H)\n           = delete_edge x y z (delete_edge a b c H)\"", "lemma valid_subgraph:\n    assumes \"subgraph H G\"\n    shows \"valid_graph H\"", "lemma is_path_undir_simps[simp, intro!]:\n    \"is_path_undir G v [] v \\<longleftrightarrow> v\\<in>V\"\n    \"is_path_undir G v [(v,w,v')] v' \\<longleftrightarrow> (v,w,v')\\<in>E \\<or> (v',w,v)\\<in>E\"", "lemma is_path_undir_memb[simp]:\n    \"is_path_undir G v p v' \\<Longrightarrow> v\\<in>V \\<and> v'\\<in>V\"", "lemma is_path_undir_memb_edges:\n    assumes \"is_path_undir G v p v'\"\n    shows \"\\<forall>(a,w,b) \\<in> set p. (a,w,b) \\<in> E \\<or> (b,w,a) \\<in> E\"", "lemma is_path_undir_split:\n    \"is_path_undir G v (p1@p2) v' \\<longleftrightarrow> (\\<exists>u. is_path_undir G v p1 u \\<and> is_path_undir G u p2 v')\"", "lemma is_path_undir_split'[simp]:\n    \"is_path_undir G v (p1@(u,w,u')#p2) v'\n      \\<longleftrightarrow> is_path_undir G v p1 u \\<and> ((u,w,u')\\<in>E \\<or> (u',w,u)\\<in>E) \\<and> is_path_undir G u' p2 v'\"", "lemma is_path_undir_sym:\n    assumes \"is_path_undir G v p v'\"\n    shows \"is_path_undir G v' (rev (map (\\<lambda>(u, w, u'). (u', w, u)) p)) v\"", "lemma is_path_undir_subgraph:\n    assumes \"is_path_undir H x p y\"\n    assumes \"subgraph H G\"\n    shows \"is_path_undir G x p y\"", "lemma no_path_in_empty_graph:\n    assumes \"E = {}\"\n    assumes \"p \\<noteq> []\"\n    shows \"\\<not>is_path_undir G v p v\"", "lemma is_path_undir_split_distinct:\n    assumes \"is_path_undir G v p v'\"\n    assumes \"(a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\"\n    shows \"(\\<exists>p' p'' u u'.\n            is_path_undir G v p' u \\<and> is_path_undir G u' p'' v' \\<and>\n            length p' < length p \\<and> length p'' < length p \\<and>\n            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n            (a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p' \\<and>\n            (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p'')\"", "lemma add_edge_is_path:\n    assumes \"is_path_undir G x p y\"\n    shows \"is_path_undir (add_edge a b c G) x p y\"", "lemma add_edge_was_path:\n    assumes \"is_path_undir (add_edge a b c G) x p y\"\n    assumes \"(a, b, c) \\<notin> set p\"\n    assumes \"(c, b, a) \\<notin> set p\"\n    assumes \"a \\<in> V\"\n    assumes \"c \\<in> V\"\n    shows \"is_path_undir G x p y\"", "lemma delete_edge_is_path:\n    assumes \"is_path_undir G x p y\"\n    assumes \"(a, b, c) \\<notin> set p\"\n    assumes \"(c, b, a) \\<notin> set p\"\n    shows \"is_path_undir (delete_edge a b c G) x p y\"", "lemma delete_node_is_path:\n    assumes \"is_path_undir G x p y\"\n    assumes \"x \\<noteq> v\"\n    assumes \"v \\<notin> fst`set p \\<union> snd`snd`set p\"\n    shows \"is_path_undir (delete_node v G) x p y\"", "lemma delete_edge_was_path:\n    assumes \"is_path_undir (delete_edge a b c G) x p y\"\n    shows \"is_path_undir G x p y\"", "lemma subset_was_path:\n    assumes \"is_path_undir H x p y\"\n    assumes \"edges H \\<subseteq> E\"\n    assumes \"nodes H \\<subseteq> V\"\n    shows \"is_path_undir G x p y\"", "lemma delete_node_was_path:\n    assumes \"is_path_undir (delete_node v G) x p y\"\n    shows \"is_path_undir G x p y\"", "lemma add_edge_preserve_subgraph:\n    assumes \"subgraph H G\"\n    assumes \"(a, w, b) \\<in> E\"\n    shows \"subgraph (add_edge a w b H) G\"", "lemma delete_edge_preserve_subgraph:\n    assumes \"subgraph H G\"\n    shows \"subgraph (delete_edge a w b H) G\"", "lemma add_delete_edge:\n    assumes \"(a, w, c) \\<in> E\"\n    shows \"add_edge a w c (delete_edge a w c G) = G\"", "lemma swap_add_edge_in_path:\n    assumes \"is_path_undir (add_edge a w b G) v p v'\"\n    assumes \"(a,w',a') \\<in> E \\<or> (a',w',a) \\<in> E\"\n    shows \"\\<exists>p. is_path_undir (add_edge a' w'' b G) v p v'\"", "lemma induce_maximally_connected:\n    assumes \"subgraph H G\"\n    assumes \"\\<forall>(a,w,b)\\<in>E. nodes_connected H a b\"\n    shows \"maximally_connected H G\"", "lemma add_edge_maximally_connected:\n    assumes \"maximally_connected H G\"\n    assumes \"subgraph H G\"\n    assumes \"(a, w, b) \\<in> E\"\n    shows \"maximally_connected (add_edge a w b H) G\"", "lemma delete_edge_maximally_connected:\n    assumes \"maximally_connected H G\"\n    assumes \"subgraph H G\"\n    assumes pab: \"is_path_undir (delete_edge a w b H) a pab b\"\n    shows \"maximally_connected (delete_edge a w b H) G\"", "lemma connected_impl_maximally_connected:\n    assumes \"connected_graph H\"\n    assumes subgraph: \"subgraph H G\"\n    shows \"maximally_connected H G\"", "lemma add_edge_is_connected:\n    \"nodes_connected (add_edge a b c G) a c\"\n    \"nodes_connected (add_edge a b c G) c a\"", "lemma swap_edges:\n    assumes \"nodes_connected (add_edge a w b G) v v'\"\n    assumes \"a \\<in> V\"\n    assumes \"b \\<in> V\"\n    assumes \"\\<not> nodes_connected G v v'\"\n    shows \"nodes_connected (add_edge v w' v' G) a b\"", "lemma subgraph_impl_connected:\n    assumes \"connected_graph H\"\n    assumes subgraph: \"subgraph H G\"\n    shows \"connected_graph G\"", "lemma add_node_connected:\n    assumes \"\\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\"\n    assumes \"(v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\"\n    assumes \"v \\<noteq> v'\"\n    shows \"\\<forall>a\\<in>V. \\<forall>b\\<in>V. nodes_connected G a b\"", "lemma maximally_connected_impl_connected:\n    assumes \"maximally_connected H G\"\n    assumes subgraph: \"subgraph H G\"\n    shows \"connected_graph H\"", "lemmas delete_edge_valid' = delete_edge_valid[OF valid_graph_axioms]", "lemma delete_edge_from_path:\n    assumes \"nodes_connected G a b\"\n    assumes \"subgraph H G\"\n    assumes \"\\<not> nodes_connected H a b\"\n    shows \"\\<exists>(x, w, y) \\<in> E - edges H.  (\\<not> nodes_connected (delete_edge x w y G) a b) \\<and>\n      (nodes_connected (add_edge a w' b (delete_edge x w y G)) x y)\"", "lemma forest_add_edge:\n    assumes \"a \\<in> V\"\n    assumes \"b \\<in> V\"\n    assumes \"\\<not> nodes_connected G a b\"\n    shows \"forest (add_edge a w b G)\"", "lemma forest_subsets:\n    assumes \"valid_graph H\"\n    assumes \"edges H \\<subseteq> E\"\n    assumes \"nodes H \\<subseteq> V\"\n    shows \"forest H\"", "lemma subgraph_forest:\n    assumes \"subgraph H G\"\n    shows \"forest H\"", "lemma forest_delete_edge: \"forest (delete_edge a w c G)\"", "lemma forest_delete_node: \"forest (delete_node n G)\"", "lemma finite_subgraphs: \"finite {T. subgraph T G}\"", "lemma minimum_spanning_forest_impl_tree:\n  assumes \"minimum_spanning_forest F G\"\n  assumes valid_G: \"valid_graph G\"\n  assumes \"connected_graph F\"\n  shows \"minimum_spanning_tree F G\"", "lemma minimum_spanning_forest_impl_tree2:\n  assumes \"minimum_spanning_forest F G\"\n  assumes connected_G: \"connected_graph G\"\n  shows \"minimum_spanning_tree F G\""], "translations": [["", "lemma nodes_delete_edge[simp]:\n  \"nodes (delete_edge v e v' G) = nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (delete_edge v e v' G) = nodes G", "by (simp add: delete_edge_def)"], ["", "lemma edges_delete_edge[simp]:\n  \"edges (delete_edge v e v' G) = edges G - {(v,e,v')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (delete_edge v e v' G) = edges G - {(v, e, v')}", "by (simp add: delete_edge_def)"], ["", "lemma subgraph_node:\n  assumes \"subgraph H G\"\n  shows \"v \\<in> nodes G \\<longleftrightarrow> v \\<in> nodes H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> nodes G) = (v \\<in> nodes H)", "using assms"], ["proof (prove)\nusing this:\n  subgraph H G\n\ngoal (1 subgoal):\n 1. (v \\<in> nodes G) = (v \\<in> nodes H)", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = nodes G \\<and> edges H \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. (v \\<in> nodes G) = (v \\<in> nodes H)", "by simp"], ["", "lemma delete_add_edge:\n  assumes \"a \\<in> nodes H\"\n  assumes \"c \\<in> nodes H\"\n  assumes \"(a, w, c) \\<notin> edges H\"\n  shows \"delete_edge a w c (add_edge a w c H) = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edge a w c (add_edge a w c H) = H", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> nodes H\n  c \\<in> nodes H\n  (a, w, c) \\<notin> edges H\n\ngoal (1 subgoal):\n 1. delete_edge a w c (add_edge a w c H) = H", "unfolding delete_edge_def add_edge_def"], ["proof (prove)\nusing this:\n  a \\<in> nodes H\n  c \\<in> nodes H\n  (a, w, c) \\<notin> edges H\n\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = {a, c} \\<union> nodes H,\n                  edges = insert (a, w, c) (edges H)\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = {a, c} \\<union> nodes H,\n             edges = insert (a, w, c) (edges H)\\<rparr> -\n         {(a, w, c)}\\<rparr> =\n    H", "by (simp add: insert_absorb)"], ["", "lemma swap_delete_add_edge:\n  assumes \"(a, b, c) \\<noteq> (x, y, z)\"\n  shows \"delete_edge a b c (add_edge x y z H) = add_edge x y z (delete_edge a b c H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edge a b c (add_edge x y z H) =\n    add_edge x y z (delete_edge a b c H)", "using assms"], ["proof (prove)\nusing this:\n  (a, b, c) \\<noteq> (x, y, z)\n\ngoal (1 subgoal):\n 1. delete_edge a b c (add_edge x y z H) =\n    add_edge x y z (delete_edge a b c H)", "unfolding delete_edge_def add_edge_def"], ["proof (prove)\nusing this:\n  (a, b, c) \\<noteq> (x, y, z)\n\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = {x, z} \\<union> nodes H,\n                  edges = insert (x, y, z) (edges H)\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = {x, z} \\<union> nodes H,\n             edges = insert (x, y, z) (edges H)\\<rparr> -\n         {(a, b, c)}\\<rparr> =\n    \\<lparr>nodes =\n              {x, z} \\<union>\n              nodes\n               \\<lparr>nodes = nodes H,\n                  edges = edges H - {(a, b, c)}\\<rparr>,\n       edges =\n         insert (x, y, z)\n          (edges\n            \\<lparr>nodes = nodes H,\n               edges = edges H - {(a, b, c)}\\<rparr>)\\<rparr>", "by auto"], ["", "lemma swap_delete_edges: \"delete_edge a b c (delete_edge x y z H)\n           = delete_edge x y z (delete_edge a b c H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edge a b c (delete_edge x y z H) =\n    delete_edge x y z (delete_edge a b c H)", "unfolding delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = nodes H,\n                  edges = edges H - {(x, y, z)}\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = nodes H, edges = edges H - {(x, y, z)}\\<rparr> -\n         {(a, b, c)}\\<rparr> =\n    \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = nodes H,\n                  edges = edges H - {(a, b, c)}\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = nodes H, edges = edges H - {(a, b, c)}\\<rparr> -\n         {(x, y, z)}\\<rparr>", "by auto"], ["", "context valid_graph\nbegin"], ["", "lemma valid_subgraph:\n    assumes \"subgraph H G\"\n    shows \"valid_graph H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph H", "using assms E_valid"], ["proof (prove)\nusing this:\n  subgraph H G\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. valid_graph H", "unfolding subgraph_def valid_graph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst ` edges H \\<subseteq> nodes H \\<and>\n    snd ` snd ` edges H \\<subseteq> nodes H", "by blast"], ["", "lemma is_path_undir_simps[simp, intro!]:\n    \"is_path_undir G v [] v \\<longleftrightarrow> v\\<in>V\"\n    \"is_path_undir G v [(v,w,v')] v' \\<longleftrightarrow> (v,w,v')\\<in>E \\<or> (v',w,v)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G v [] v = (v \\<in> V) &&&\n    is_path_undir G v [(v, w, v')] v' =\n    ((v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E)", "by (auto dest: E_validD)"], ["", "lemma is_path_undir_memb[simp]:\n    \"is_path_undir G v p v' \\<Longrightarrow> v\\<in>V \\<and> v'\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G v p v' \\<Longrightarrow> v \\<in> V \\<and> v' \\<in> V", "apply (induct p arbitrary: v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       is_path_undir G v [] v' \\<Longrightarrow> v \\<in> V \\<and> v' \\<in> V\n 2. \\<And>a p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   v \\<in> V \\<and> v' \\<in> V;\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V \\<and> v' \\<in> V", "apply (auto dest: E_validD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_path_undir_memb_edges:\n    assumes \"is_path_undir G v p v'\"\n    shows \"\\<forall>(a,w,b) \\<in> set p. (a,w,b) \\<in> E \\<or> (b,w,a) \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>set p. (a, w, b) \\<in> E \\<or> (b, w, a) \\<in> E", "using assms"], ["proof (prove)\nusing this:\n  is_path_undir G v p v'\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>set p. (a, w, b) \\<in> E \\<or> (b, w, a) \\<in> E", "by (induct p arbitrary: v) fastforce+"], ["", "lemma is_path_undir_split:\n    \"is_path_undir G v (p1@p2) v' \\<longleftrightarrow> (\\<exists>u. is_path_undir G v p1 u \\<and> is_path_undir G u p2 v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G v (p1 @ p2) v' =\n    (\\<exists>u. is_path_undir G v p1 u \\<and> is_path_undir G u p2 v')", "by (induct p1 arbitrary: v) auto"], ["", "lemma is_path_undir_split'[simp]:\n    \"is_path_undir G v (p1@(u,w,u')#p2) v'\n      \\<longleftrightarrow> is_path_undir G v p1 u \\<and> ((u,w,u')\\<in>E \\<or> (u',w,u)\\<in>E) \\<and> is_path_undir G u' p2 v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G v (p1 @ (u, w, u') # p2) v' =\n    (is_path_undir G v p1 u \\<and>\n     ((u, w, u') \\<in> E \\<or> (u', w, u) \\<in> E) \\<and>\n     is_path_undir G u' p2 v')", "by (auto simp add: is_path_undir_split)"], ["", "lemma is_path_undir_sym:\n    assumes \"is_path_undir G v p v'\"\n    shows \"is_path_undir G v' (rev (map (\\<lambda>(u, w, u'). (u', w, u)) p)) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G v' (rev (map (\\<lambda>(u, w, u'). (u', w, u)) p)) v", "using assms"], ["proof (prove)\nusing this:\n  is_path_undir G v p v'\n\ngoal (1 subgoal):\n 1. is_path_undir G v' (rev (map (\\<lambda>(u, w, u'). (u', w, u)) p)) v", "by (induct p arbitrary: v) (auto simp: E_validD)"], ["", "lemma is_path_undir_subgraph:\n    assumes \"is_path_undir H x p y\"\n    assumes \"subgraph H G\"\n    shows \"is_path_undir G x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "using assms is_path_undir.simps"], ["proof (prove)\nusing this:\n  is_path_undir H x p y\n  subgraph H G\n  is_path_undir ?G ?v [] ?v' = (?v = ?v' \\<and> ?v' \\<in> nodes ?G)\n  is_path_undir ?G ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges ?G \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges ?G) \\<and>\n   is_path_undir ?G ?v2.0 ?p ?v')\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  is_path_undir H x p y\n  nodes H = V \\<and> edges H \\<subseteq> E\n  is_path_undir ?G ?v [] ?v' = (?v = ?v' \\<and> ?v' \\<in> nodes ?G)\n  is_path_undir ?G ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges ?G \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges ?G) \\<and>\n   is_path_undir ?G ?v2.0 ?p ?v')\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "by (induction p arbitrary: x y) auto"], ["", "lemma no_path_in_empty_graph:\n    assumes \"E = {}\"\n    assumes \"p \\<noteq> []\"\n    shows \"\\<not>is_path_undir G v p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_path_undir G v p v", "using assms"], ["proof (prove)\nusing this:\n  E = {}\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> is_path_undir G v p v", "by (cases p) auto"], ["", "lemma is_path_undir_split_distinct:\n    assumes \"is_path_undir G v p v'\"\n    assumes \"(a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\"\n    shows \"(\\<exists>p' p'' u u'.\n            is_path_undir G v p' u \\<and> is_path_undir G u' p'' v' \\<and>\n            length p' < length p \\<and> length p'' < length p \\<and>\n            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n            (a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p' \\<and>\n            (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p' p'' u u'.\n       is_path_undir G v p' u \\<and>\n       is_path_undir G u' p'' v' \\<and>\n       length p' < length p \\<and>\n       length p'' < length p \\<and>\n       (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n       (a, w, b) \\<notin> set p' \\<and>\n       (b, w, a) \\<notin> set p' \\<and>\n       (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "using assms"], ["proof (prove)\nusing this:\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<exists>p' p'' u u'.\n       is_path_undir G v p' u \\<and>\n       is_path_undir G u' p'' v' \\<and>\n       length p' < length p \\<and>\n       length p'' < length p \\<and>\n       (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n       (a, w, b) \\<notin> set p' \\<and>\n       (b, w, a) \\<notin> set p' \\<and>\n       (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "proof (induction n == \"length p\" arbitrary: p v v' rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "case 1"], ["proof (state)\nthis:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p", "obtain u u' where \"(u, w, u') \\<in> set p\" and u: \"u \\<in> {a, b} \\<and> u' \\<in> {a, b}\""], ["proof (prove)\nusing this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>u u'.\n        \\<lbrakk>(u, w, u') \\<in> set p;\n         u \\<in> {a, b} \\<and> u' \\<in> {a, b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (u, w, u') \\<in> set p\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "with split_list"], ["proof (chain)\npicking this:\n  ?x \\<in> set ?xs \\<Longrightarrow> \\<exists>ys zs. ?xs = ys @ ?x # zs\n  (u, w, u') \\<in> set p\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}", "obtain p' p''\n      where p: \"p = p' @ (u, w, u') # p''\""], ["proof (prove)\nusing this:\n  ?x \\<in> set ?xs \\<Longrightarrow> \\<exists>ys zs. ?xs = ys @ ?x # zs\n  (u, w, u') \\<in> set p\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n\ngoal (1 subgoal):\n 1. (\\<And>p' p''.\n        p = p' @ (u, w, u') # p'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  p = p' @ (u, w, u') # p''\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "then"], ["proof (chain)\npicking this:\n  p = p' @ (u, w, u') # p''", "have len_p': \"length p' < length p\" and len_p'': \"length p'' < length p\""], ["proof (prove)\nusing this:\n  p = p' @ (u, w, u') # p''\n\ngoal (1 subgoal):\n 1. length p' < length p &&& length p'' < length p", "by auto"], ["proof (state)\nthis:\n  length p' < length p\n  length p'' < length p\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "from 1 p"], ["proof (chain)\npicking this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n  p = p' @ (u, w, u') # p''", "have p': \"is_path_undir G v p' u\" and p'': \"is_path_undir G u' p'' v'\""], ["proof (prove)\nusing this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n  p = p' @ (u, w, u') # p''\n\ngoal (1 subgoal):\n 1. is_path_undir G v p' u &&& is_path_undir G u' p'' v'", "by auto"], ["proof (state)\nthis:\n  is_path_undir G v p' u\n  is_path_undir G u' p'' v'\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "from 1 len_p' p'"], ["proof (chain)\npicking this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n  length p' < length p\n  is_path_undir G v p' u", "have \"(a, w, b) \\<in> set p' \\<or> (b, w, a) \\<in> set p' \\<longrightarrow> (\\<exists>p'2 u2.\n            is_path_undir G v p'2 u2 \\<and>\n            length p'2 < length p' \\<and>\n            u2 \\<in> {a, b} \\<and>\n            (a, w, b) \\<notin> set p'2 \\<and> (b, w, a) \\<notin> set p'2)\""], ["proof (prove)\nusing this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n  length p' < length p\n  is_path_undir G v p' u\n\ngoal (1 subgoal):\n 1. (a, w, b) \\<in> set p' \\<or> (b, w, a) \\<in> set p' \\<longrightarrow>\n    (\\<exists>p'2 u2.\n        is_path_undir G v p'2 u2 \\<and>\n        length p'2 < length p' \\<and>\n        u2 \\<in> {a, b} \\<and>\n        (a, w, b) \\<notin> set p'2 \\<and> (b, w, a) \\<notin> set p'2)", "by metis"], ["proof (state)\nthis:\n  (a, w, b) \\<in> set p' \\<or> (b, w, a) \\<in> set p' \\<longrightarrow>\n  (\\<exists>p'2 u2.\n      is_path_undir G v p'2 u2 \\<and>\n      length p'2 < length p' \\<and>\n      u2 \\<in> {a, b} \\<and>\n      (a, w, b) \\<notin> set p'2 \\<and> (b, w, a) \\<notin> set p'2)\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "with len_p' p' u"], ["proof (chain)\npicking this:\n  length p' < length p\n  is_path_undir G v p' u\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<in> set p' \\<or> (b, w, a) \\<in> set p' \\<longrightarrow>\n  (\\<exists>p'2 u2.\n      is_path_undir G v p'2 u2 \\<and>\n      length p'2 < length p' \\<and>\n      u2 \\<in> {a, b} \\<and>\n      (a, w, b) \\<notin> set p'2 \\<and> (b, w, a) \\<notin> set p'2)", "have p': \"\\<exists>p' u. is_path_undir G v p' u \\<and> length p' < length p \\<and>\n      u \\<in> {a,b} \\<and> (a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p'\""], ["proof (prove)\nusing this:\n  length p' < length p\n  is_path_undir G v p' u\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<in> set p' \\<or> (b, w, a) \\<in> set p' \\<longrightarrow>\n  (\\<exists>p'2 u2.\n      is_path_undir G v p'2 u2 \\<and>\n      length p'2 < length p' \\<and>\n      u2 \\<in> {a, b} \\<and>\n      (a, w, b) \\<notin> set p'2 \\<and> (b, w, a) \\<notin> set p'2)\n\ngoal (1 subgoal):\n 1. \\<exists>p' u.\n       is_path_undir G v p' u \\<and>\n       length p' < length p \\<and>\n       u \\<in> {a, b} \\<and>\n       (a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>p' u.\n     is_path_undir G v p' u \\<and>\n     length p' < length p \\<and>\n     u \\<in> {a, b} \\<and>\n     (a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p'\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "from 1 len_p'' p''"], ["proof (chain)\npicking this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n  length p'' < length p\n  is_path_undir G u' p'' v'", "have \"(a, w, b) \\<in> set p'' \\<or> (b, w, a) \\<in> set p'' \\<longrightarrow> (\\<exists>p''2 u'2.\n            is_path_undir G u'2 p''2 v' \\<and>\n            length p''2 < length p'' \\<and>\n            u'2 \\<in> {a, b} \\<and>\n            (a, w, b) \\<notin> set p''2 \\<and> (b, w, a) \\<notin> set p''2)\""], ["proof (prove)\nusing this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            (a, w, b) \\<in> set x \\<or>\n            (b, w, a) \\<in> set x \\<longrightarrow>\n            (\\<exists>p' p'' u u'.\n                is_path_undir G xa p' u \\<and>\n                is_path_undir G u' p'' xb \\<and>\n                length p' < length x \\<and>\n                length p'' < length x \\<and>\n                (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                (a, w, b) \\<notin> set p' \\<and>\n                (b, w, a) \\<notin> set p' \\<and>\n                (a, w, b) \\<notin> set p'' \\<and>\n                (b, w, a) \\<notin> set p''))\n  is_path_undir G v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n  length p'' < length p\n  is_path_undir G u' p'' v'\n\ngoal (1 subgoal):\n 1. (a, w, b) \\<in> set p'' \\<or> (b, w, a) \\<in> set p'' \\<longrightarrow>\n    (\\<exists>p''2 u'2.\n        is_path_undir G u'2 p''2 v' \\<and>\n        length p''2 < length p'' \\<and>\n        u'2 \\<in> {a, b} \\<and>\n        (a, w, b) \\<notin> set p''2 \\<and> (b, w, a) \\<notin> set p''2)", "by metis"], ["proof (state)\nthis:\n  (a, w, b) \\<in> set p'' \\<or> (b, w, a) \\<in> set p'' \\<longrightarrow>\n  (\\<exists>p''2 u'2.\n      is_path_undir G u'2 p''2 v' \\<and>\n      length p''2 < length p'' \\<and>\n      u'2 \\<in> {a, b} \\<and>\n      (a, w, b) \\<notin> set p''2 \\<and> (b, w, a) \\<notin> set p''2)\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "with len_p'' p'' u"], ["proof (chain)\npicking this:\n  length p'' < length p\n  is_path_undir G u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<in> set p'' \\<or> (b, w, a) \\<in> set p'' \\<longrightarrow>\n  (\\<exists>p''2 u'2.\n      is_path_undir G u'2 p''2 v' \\<and>\n      length p''2 < length p'' \\<and>\n      u'2 \\<in> {a, b} \\<and>\n      (a, w, b) \\<notin> set p''2 \\<and> (b, w, a) \\<notin> set p''2)", "have \"\\<exists>p'' u'. is_path_undir G u' p'' v'\\<and> length p'' < length p \\<and>\n      u' \\<in> {a,b} \\<and> (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\""], ["proof (prove)\nusing this:\n  length p'' < length p\n  is_path_undir G u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<in> set p'' \\<or> (b, w, a) \\<in> set p'' \\<longrightarrow>\n  (\\<exists>p''2 u'2.\n      is_path_undir G u'2 p''2 v' \\<and>\n      length p''2 < length p'' \\<and>\n      u'2 \\<in> {a, b} \\<and>\n      (a, w, b) \\<notin> set p''2 \\<and> (b, w, a) \\<notin> set p''2)\n\ngoal (1 subgoal):\n 1. \\<exists>p'' u'.\n       is_path_undir G u' p'' v' \\<and>\n       length p'' < length p \\<and>\n       u' \\<in> {a, b} \\<and>\n       (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>p'' u'.\n     is_path_undir G u' p'' v' \\<and>\n     length p'' < length p \\<and>\n     u' \\<in> {a, b} \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. \\<And>p v v'.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          (a, w, b) \\<in> set x \\<or>\n                          (b, w, a) \\<in> set x \\<longrightarrow>\n                          (\\<exists>p' p'' u u'.\n                              is_path_undir G xa p' u \\<and>\n                              is_path_undir G u' p'' xb \\<and>\n                              length p' < length x \\<and>\n                              length p'' < length x \\<and>\n                              (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                              (a, w, b) \\<notin> set p' \\<and>\n                              (b, w, a) \\<notin> set p' \\<and>\n                              (a, w, b) \\<notin> set p'' \\<and>\n                              (b, w, a) \\<notin> set p''));\n        is_path_undir G v p v';\n        (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p' p'' u u'.\n                            is_path_undir G v p' u \\<and>\n                            is_path_undir G u' p'' v' \\<and>\n                            length p' < length p \\<and>\n                            length p'' < length p \\<and>\n                            (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n                            (a, w, b) \\<notin> set p' \\<and>\n                            (b, w, a) \\<notin> set p' \\<and>\n                            (a, w, b) \\<notin> set p'' \\<and>\n                            (b, w, a) \\<notin> set p''", "with p'"], ["proof (chain)\npicking this:\n  \\<exists>p' u.\n     is_path_undir G v p' u \\<and>\n     length p' < length p \\<and>\n     u \\<in> {a, b} \\<and>\n     (a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p'\n  \\<exists>p'' u'.\n     is_path_undir G u' p'' v' \\<and>\n     length p'' < length p \\<and>\n     u' \\<in> {a, b} \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>p' u.\n     is_path_undir G v p' u \\<and>\n     length p' < length p \\<and>\n     u \\<in> {a, b} \\<and>\n     (a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p'\n  \\<exists>p'' u'.\n     is_path_undir G u' p'' v' \\<and>\n     length p'' < length p \\<and>\n     u' \\<in> {a, b} \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. \\<exists>p' p'' u u'.\n       is_path_undir G v p' u \\<and>\n       is_path_undir G u' p'' v' \\<and>\n       length p' < length p \\<and>\n       length p'' < length p \\<and>\n       (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n       (a, w, b) \\<notin> set p' \\<and>\n       (b, w, a) \\<notin> set p' \\<and>\n       (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "by auto"], ["proof (state)\nthis:\n  \\<exists>p' p'' u u'.\n     is_path_undir G v p' u \\<and>\n     is_path_undir G u' p'' v' \\<and>\n     length p' < length p \\<and>\n     length p'' < length p \\<and>\n     (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n     (a, w, b) \\<notin> set p' \\<and>\n     (b, w, a) \\<notin> set p' \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_edge_is_path:\n    assumes \"is_path_undir G x p y\"\n    shows \"is_path_undir (add_edge a b c G) x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a b c G) x p y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a b c G) x p y", "from E_valid"], ["proof (chain)\npicking this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V", "have \"valid_graph (add_edge a b c G)\""], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. valid_graph (add_edge a b c G)", "unfolding valid_graph_def add_edge_def"], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst `\n    edges\n     \\<lparr>nodes = {a, c} \\<union> V, edges = insert (a, b, c) E\\<rparr>\n    \\<subseteq> nodes\n                 \\<lparr>nodes = {a, c} \\<union> V,\n                    edges = insert (a, b, c) E\\<rparr> \\<and>\n    snd `\n    snd `\n    edges\n     \\<lparr>nodes = {a, c} \\<union> V, edges = insert (a, b, c) E\\<rparr>\n    \\<subseteq> nodes\n                 \\<lparr>nodes = {a, c} \\<union> V,\n                    edges = insert (a, b, c) E\\<rparr>", "by auto"], ["proof (state)\nthis:\n  valid_graph (add_edge a b c G)\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a b c G) x p y", "with assms is_path_undir.simps[of \"add_edge a b c G\"]"], ["proof (chain)\npicking this:\n  is_path_undir G x p y\n  is_path_undir (add_edge a b c G) ?v [] ?v' =\n  (?v = ?v' \\<and> ?v' \\<in> nodes (add_edge a b c G))\n  is_path_undir (add_edge a b c G) ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges (add_edge a b c G) \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges (add_edge a b c G)) \\<and>\n   is_path_undir (add_edge a b c G) ?v2.0 ?p ?v')\n  valid_graph (add_edge a b c G)", "show \"is_path_undir (add_edge a b c G) x p y\""], ["proof (prove)\nusing this:\n  is_path_undir G x p y\n  is_path_undir (add_edge a b c G) ?v [] ?v' =\n  (?v = ?v' \\<and> ?v' \\<in> nodes (add_edge a b c G))\n  is_path_undir (add_edge a b c G) ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges (add_edge a b c G) \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges (add_edge a b c G)) \\<and>\n   is_path_undir (add_edge a b c G) ?v2.0 ?p ?v')\n  valid_graph (add_edge a b c G)\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a b c G) x p y", "by (induction p arbitrary: x y) auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a b c G) x p y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_edge_was_path:\n    assumes \"is_path_undir (add_edge a b c G) x p y\"\n    assumes \"(a, b, c) \\<notin> set p\"\n    assumes \"(c, b, a) \\<notin> set p\"\n    assumes \"a \\<in> V\"\n    assumes \"c \\<in> V\"\n    shows \"is_path_undir G x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "from E_valid"], ["proof (chain)\npicking this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V", "have \"valid_graph (add_edge a b c G)\""], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. valid_graph (add_edge a b c G)", "unfolding valid_graph_def add_edge_def"], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst `\n    edges\n     \\<lparr>nodes = {a, c} \\<union> V, edges = insert (a, b, c) E\\<rparr>\n    \\<subseteq> nodes\n                 \\<lparr>nodes = {a, c} \\<union> V,\n                    edges = insert (a, b, c) E\\<rparr> \\<and>\n    snd `\n    snd `\n    edges\n     \\<lparr>nodes = {a, c} \\<union> V, edges = insert (a, b, c) E\\<rparr>\n    \\<subseteq> nodes\n                 \\<lparr>nodes = {a, c} \\<union> V,\n                    edges = insert (a, b, c) E\\<rparr>", "by auto"], ["proof (state)\nthis:\n  valid_graph (add_edge a b c G)\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "with assms is_path_undir.simps[of \"add_edge a b c G\"]"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a b c G) x p y\n  (a, b, c) \\<notin> set p\n  (c, b, a) \\<notin> set p\n  a \\<in> V\n  c \\<in> V\n  is_path_undir (add_edge a b c G) ?v [] ?v' =\n  (?v = ?v' \\<and> ?v' \\<in> nodes (add_edge a b c G))\n  is_path_undir (add_edge a b c G) ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges (add_edge a b c G) \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges (add_edge a b c G)) \\<and>\n   is_path_undir (add_edge a b c G) ?v2.0 ?p ?v')\n  valid_graph (add_edge a b c G)", "show \"is_path_undir G x p y\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a b c G) x p y\n  (a, b, c) \\<notin> set p\n  (c, b, a) \\<notin> set p\n  a \\<in> V\n  c \\<in> V\n  is_path_undir (add_edge a b c G) ?v [] ?v' =\n  (?v = ?v' \\<and> ?v' \\<in> nodes (add_edge a b c G))\n  is_path_undir (add_edge a b c G) ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges (add_edge a b c G) \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges (add_edge a b c G)) \\<and>\n   is_path_undir (add_edge a b c G) ?v2.0 ?p ?v')\n  valid_graph (add_edge a b c G)\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "by (induction p arbitrary: x y) auto"], ["proof (state)\nthis:\n  is_path_undir G x p y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_edge_is_path:\n    assumes \"is_path_undir G x p y\"\n    assumes \"(a, b, c) \\<notin> set p\"\n    assumes \"(c, b, a) \\<notin> set p\"\n    shows \"is_path_undir (delete_edge a b c G) x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir (delete_edge a b c G) x p y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_path_undir (delete_edge a b c G) x p y", "from E_valid"], ["proof (chain)\npicking this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V", "have \"valid_graph (delete_edge a b c G)\""], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. valid_graph (delete_edge a b c G)", "unfolding valid_graph_def delete_edge_def"], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst ` edges \\<lparr>nodes = V, edges = E - {(a, b, c)}\\<rparr>\n    \\<subseteq> nodes\n                 \\<lparr>nodes = V, edges = E - {(a, b, c)}\\<rparr> \\<and>\n    snd ` snd ` edges \\<lparr>nodes = V, edges = E - {(a, b, c)}\\<rparr>\n    \\<subseteq> nodes \\<lparr>nodes = V, edges = E - {(a, b, c)}\\<rparr>", "by auto"], ["proof (state)\nthis:\n  valid_graph (delete_edge a b c G)\n\ngoal (1 subgoal):\n 1. is_path_undir (delete_edge a b c G) x p y", "with assms is_path_undir.simps[of \"delete_edge a b c G\"]"], ["proof (chain)\npicking this:\n  is_path_undir G x p y\n  (a, b, c) \\<notin> set p\n  (c, b, a) \\<notin> set p\n  is_path_undir (delete_edge a b c G) ?v [] ?v' =\n  (?v = ?v' \\<and> ?v' \\<in> nodes (delete_edge a b c G))\n  is_path_undir (delete_edge a b c G) ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges (delete_edge a b c G) \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges (delete_edge a b c G)) \\<and>\n   is_path_undir (delete_edge a b c G) ?v2.0 ?p ?v')\n  valid_graph (delete_edge a b c G)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_path_undir G x p y\n  (a, b, c) \\<notin> set p\n  (c, b, a) \\<notin> set p\n  is_path_undir (delete_edge a b c G) ?v [] ?v' =\n  (?v = ?v' \\<and> ?v' \\<in> nodes (delete_edge a b c G))\n  is_path_undir (delete_edge a b c G) ?v ((?v1.0, ?w, ?v2.0) # ?p) ?v' =\n  (?v = ?v1.0 \\<and>\n   ((?v1.0, ?w, ?v2.0) \\<in> edges (delete_edge a b c G) \\<or>\n    (?v2.0, ?w, ?v1.0) \\<in> edges (delete_edge a b c G)) \\<and>\n   is_path_undir (delete_edge a b c G) ?v2.0 ?p ?v')\n  valid_graph (delete_edge a b c G)\n\ngoal (1 subgoal):\n 1. is_path_undir (delete_edge a b c G) x p y", "by (induction p arbitrary: x y) auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge a b c G) x p y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_node_is_path:\n    assumes \"is_path_undir G x p y\"\n    assumes \"x \\<noteq> v\"\n    assumes \"v \\<notin> fst`set p \\<union> snd`snd`set p\"\n    shows \"is_path_undir (delete_node v G) x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir (delete_node v G) x p y", "using assms"], ["proof (prove)\nusing this:\n  is_path_undir G x p y\n  x \\<noteq> v\n  v \\<notin> fst ` set p \\<union> snd ` snd ` set p\n\ngoal (1 subgoal):\n 1. is_path_undir (delete_node v G) x p y", "unfolding delete_node_def"], ["proof (prove)\nusing this:\n  is_path_undir G x p y\n  x \\<noteq> v\n  v \\<notin> fst ` set p \\<union> snd ` snd ` set p\n\ngoal (1 subgoal):\n 1. is_path_undir\n     \\<lparr>nodes = V - {v},\n        edges = E \\<inter> (- {v}) \\<times> UNIV \\<times> - {v}\\<rparr>\n     x p y", "by (induction p arbitrary: x y) auto"], ["", "lemma delete_edge_was_path:\n    assumes \"is_path_undir (delete_edge a b c G) x p y\"\n    shows \"is_path_undir G x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "using assms"], ["proof (prove)\nusing this:\n  is_path_undir (delete_edge a b c G) x p y\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "by (induction p arbitrary: x y) auto"], ["", "lemma subset_was_path:\n    assumes \"is_path_undir H x p y\"\n    assumes \"edges H \\<subseteq> E\"\n    assumes \"nodes H \\<subseteq> V\"\n    shows \"is_path_undir G x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "using assms"], ["proof (prove)\nusing this:\n  is_path_undir H x p y\n  edges H \\<subseteq> E\n  nodes H \\<subseteq> V\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "by (induction p arbitrary: x y) auto"], ["", "lemma delete_node_was_path:\n    assumes \"is_path_undir (delete_node v G) x p y\"\n    shows \"is_path_undir G x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "using assms"], ["proof (prove)\nusing this:\n  is_path_undir (delete_node v G) x p y\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "unfolding delete_node_def"], ["proof (prove)\nusing this:\n  is_path_undir\n   \\<lparr>nodes = V - {v},\n      edges = E \\<inter> (- {v}) \\<times> UNIV \\<times> - {v}\\<rparr>\n   x p y\n\ngoal (1 subgoal):\n 1. is_path_undir G x p y", "by (induction p arbitrary: x y) auto"], ["", "lemma add_edge_preserve_subgraph:\n    assumes \"subgraph H G\"\n    assumes \"(a, w, b) \\<in> E\"\n    shows \"subgraph (add_edge a w b H) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgraph (add_edge a w b H) G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subgraph (add_edge a w b H) G", "from assms E_validD"], ["proof (chain)\npicking this:\n  subgraph H G\n  (a, w, b) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V", "have \"a \\<in> nodes H \\<and> b \\<in> nodes H\""], ["proof (prove)\nusing this:\n  subgraph H G\n  (a, w, b) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. a \\<in> nodes H \\<and> b \\<in> nodes H", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n  (a, w, b) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. a \\<in> nodes H \\<and> b \\<in> nodes H", "by simp"], ["proof (state)\nthis:\n  a \\<in> nodes H \\<and> b \\<in> nodes H\n\ngoal (1 subgoal):\n 1. subgraph (add_edge a w b H) G", "with assms"], ["proof (chain)\npicking this:\n  subgraph H G\n  (a, w, b) \\<in> E\n  a \\<in> nodes H \\<and> b \\<in> nodes H", "show ?thesis"], ["proof (prove)\nusing this:\n  subgraph H G\n  (a, w, b) \\<in> E\n  a \\<in> nodes H \\<and> b \\<in> nodes H\n\ngoal (1 subgoal):\n 1. subgraph (add_edge a w b H) G", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n  (a, w, b) \\<in> E\n  a \\<in> nodes H \\<and> b \\<in> nodes H\n\ngoal (1 subgoal):\n 1. nodes (add_edge a w b H) = V \\<and>\n    edges (add_edge a w b H) \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  subgraph (add_edge a w b H) G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_edge_preserve_subgraph:\n    assumes \"subgraph H G\"\n    shows \"subgraph (delete_edge a w b H) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgraph (delete_edge a w b H) G", "using assms"], ["proof (prove)\nusing this:\n  subgraph H G\n\ngoal (1 subgoal):\n 1. subgraph (delete_edge a w b H) G", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n\ngoal (1 subgoal):\n 1. nodes (delete_edge a w b H) = V \\<and>\n    edges (delete_edge a w b H) \\<subseteq> E", "by auto"], ["", "lemma add_delete_edge:\n    assumes \"(a, w, c) \\<in> E\"\n    shows \"add_edge a w c (delete_edge a w c G) = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_edge a w c (delete_edge a w c G) = G", "using assms E_validD"], ["proof (prove)\nusing this:\n  (a, w, c) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. add_edge a w c (delete_edge a w c G) = G", "unfolding delete_edge_def add_edge_def"], ["proof (prove)\nusing this:\n  (a, w, c) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              {a, c} \\<union>\n              nodes \\<lparr>nodes = V, edges = E - {(a, w, c)}\\<rparr>,\n       edges =\n         insert (a, w, c)\n          (edges\n            \\<lparr>nodes = V, edges = E - {(a, w, c)}\\<rparr>)\\<rparr> =\n    G", "by (simp add: insert_absorb)"], ["", "lemma swap_add_edge_in_path:\n    assumes \"is_path_undir (add_edge a w b G) v p v'\"\n    assumes \"(a,w',a') \\<in> E \\<or> (a',w',a) \\<in> E\"\n    shows \"\\<exists>p. is_path_undir (add_edge a' w'' b G) v p v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a' w'' b G) v v'", "using assms(1)"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a w b G) v p v'\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a' w'' b G) v v'", "proof (induction p arbitrary: v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       is_path_undir (add_edge a w b G) v [] v' \\<Longrightarrow>\n       nodes_connected (add_edge a' w'' b G) v v'\n 2. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "case Nil"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b G) v [] v'\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       is_path_undir (add_edge a w b G) v [] v' \\<Longrightarrow>\n       nodes_connected (add_edge a' w'' b G) v v'\n 2. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "with assms(2) E_validD"], ["proof (chain)\npicking this:\n  (a, w', a') \\<in> E \\<or> (a', w', a) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n  is_path_undir (add_edge a w b G) v [] v'", "have \"is_path_undir (add_edge a' w'' b G) v [] v'\""], ["proof (prove)\nusing this:\n  (a, w', a') \\<in> E \\<or> (a', w', a) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n  is_path_undir (add_edge a w b G) v [] v'\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a' w'' b G) v [] v'", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a' w'' b G) v [] v'\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       is_path_undir (add_edge a w b G) v [] v' \\<Longrightarrow>\n       nodes_connected (add_edge a' w'' b G) v v'\n 2. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "then"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a' w'' b G) v [] v'", "show ?case"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a' w'' b G) v [] v'\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a' w'' b G) v v'", "by blast"], ["proof (state)\nthis:\n  nodes_connected (add_edge a' w'' b G) v v'\n\ngoal (1 subgoal):\n 1. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "case (Cons e p')"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b G) ?v p' v' \\<Longrightarrow>\n  nodes_connected (add_edge a' w'' b G) ?v v'\n  is_path_undir (add_edge a w b G) v (e # p') v'\n\ngoal (1 subgoal):\n 1. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "then"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a w b G) ?v p' v' \\<Longrightarrow>\n  nodes_connected (add_edge a' w'' b G) ?v v'\n  is_path_undir (add_edge a w b G) v (e # p') v'", "obtain v2 x e_w where \"e = (v2, e_w, x)\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a w b G) ?v p' v' \\<Longrightarrow>\n  nodes_connected (add_edge a' w'' b G) ?v v'\n  is_path_undir (add_edge a w b G) v (e # p') v'\n\ngoal (1 subgoal):\n 1. (\\<And>v2 e_w x.\n        e = (v2, e_w, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod_cases3"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a w b G) ?v p' v' \\<Longrightarrow>\n  nodes_connected (add_edge a' w'' b G) ?v v'\n  is_path_undir (add_edge a w b G) v (e # p') v'\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>v2 e_w x.\n        e = (v2, e_w, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e = (v2, e_w, x)\n\ngoal (1 subgoal):\n 1. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "with Cons(2)"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a w b G) v (e # p') v'\n  e = (v2, e_w, x)", "have e: \"e = (v, e_w, x)\" and\n         edge_e: \"(v, e_w, x) \\<in> edges (add_edge a w b G)\n                   \\<or> (x, e_w, v) \\<in> edges (add_edge a w b G)\" and\n         p': \"is_path_undir (add_edge a w b G) x p' v'\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a w b G) v (e # p') v'\n  e = (v2, e_w, x)\n\ngoal (1 subgoal):\n 1. e = (v, e_w, x) &&&\n    (v, e_w, x) \\<in> edges (add_edge a w b G) \\<or>\n    (x, e_w, v) \\<in> edges (add_edge a w b G) &&&\n    is_path_undir (add_edge a w b G) x p' v'", "by auto"], ["proof (state)\nthis:\n  e = (v, e_w, x)\n  (v, e_w, x) \\<in> edges (add_edge a w b G) \\<or>\n  (x, e_w, v) \\<in> edges (add_edge a w b G)\n  is_path_undir (add_edge a w b G) x p' v'\n\ngoal (1 subgoal):\n 1. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "have \"\\<exists>p. is_path_undir (add_edge a' w'' b G) v p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a' w'' b G) v x", "proof (cases \"e = (a, w, b) \\<or> e = (b, w, a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = (a, w, b) \\<or> e = (b, w, a) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x\n 2. \\<not> (e = (a, w, b) \\<or> e = (b, w, a)) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x", "case True"], ["proof (state)\nthis:\n  e = (a, w, b) \\<or> e = (b, w, a)\n\ngoal (2 subgoals):\n 1. e = (a, w, b) \\<or> e = (b, w, a) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x\n 2. \\<not> (e = (a, w, b) \\<or> e = (b, w, a)) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x", "from True e assms(2) E_validD"], ["proof (chain)\npicking this:\n  e = (a, w, b) \\<or> e = (b, w, a)\n  e = (v, e_w, x)\n  (a, w', a') \\<in> E \\<or> (a', w', a) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V", "have \"is_path_undir (add_edge a' w'' b G) v [(a,w',a'), (a',w'',b)] x\n          \\<or> is_path_undir (add_edge a' w'' b G) v [(b,w'',a'), (a',w',a)] x\""], ["proof (prove)\nusing this:\n  e = (a, w, b) \\<or> e = (b, w, a)\n  e = (v, e_w, x)\n  (a, w', a') \\<in> E \\<or> (a', w', a) \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a' w'' b G) v [(a, w', a'), (a', w'', b)]\n     x \\<or>\n    is_path_undir (add_edge a' w'' b G) v [(b, w'', a'), (a', w', a)] x", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a' w'' b G) v [(a, w', a'), (a', w'', b)] x \\<or>\n  is_path_undir (add_edge a' w'' b G) v [(b, w'', a'), (a', w', a)] x\n\ngoal (2 subgoals):\n 1. e = (a, w, b) \\<or> e = (b, w, a) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x\n 2. \\<not> (e = (a, w, b) \\<or> e = (b, w, a)) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x", "then"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a' w'' b G) v [(a, w', a'), (a', w'', b)] x \\<or>\n  is_path_undir (add_edge a' w'' b G) v [(b, w'', a'), (a', w', a)] x", "show ?thesis"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a' w'' b G) v [(a, w', a'), (a', w'', b)] x \\<or>\n  is_path_undir (add_edge a' w'' b G) v [(b, w'', a'), (a', w', a)] x\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a' w'' b G) v x", "by blast"], ["proof (state)\nthis:\n  nodes_connected (add_edge a' w'' b G) v x\n\ngoal (1 subgoal):\n 1. \\<not> (e = (a, w, b) \\<or> e = (b, w, a)) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (e = (a, w, b) \\<or> e = (b, w, a)) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x", "case False"], ["proof (state)\nthis:\n  \\<not> (e = (a, w, b) \\<or> e = (b, w, a))\n\ngoal (1 subgoal):\n 1. \\<not> (e = (a, w, b) \\<or> e = (b, w, a)) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x", "with edge_e e"], ["proof (chain)\npicking this:\n  (v, e_w, x) \\<in> edges (add_edge a w b G) \\<or>\n  (x, e_w, v) \\<in> edges (add_edge a w b G)\n  e = (v, e_w, x)\n  \\<not> (e = (a, w, b) \\<or> e = (b, w, a))", "have \"is_path_undir (add_edge a' w'' b G) v [e] x\""], ["proof (prove)\nusing this:\n  (v, e_w, x) \\<in> edges (add_edge a w b G) \\<or>\n  (x, e_w, v) \\<in> edges (add_edge a w b G)\n  e = (v, e_w, x)\n  \\<not> (e = (a, w, b) \\<or> e = (b, w, a))\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a' w'' b G) v [e] x", "by (auto simp: E_validD)"], ["proof (state)\nthis:\n  is_path_undir (add_edge a' w'' b G) v [e] x\n\ngoal (1 subgoal):\n 1. \\<not> (e = (a, w, b) \\<or> e = (b, w, a)) \\<Longrightarrow>\n    nodes_connected (add_edge a' w'' b G) v x", "then"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a' w'' b G) v [e] x", "show ?thesis"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a' w'' b G) v [e] x\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a' w'' b G) v x", "by auto"], ["proof (state)\nthis:\n  nodes_connected (add_edge a' w'' b G) v x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected (add_edge a' w'' b G) v x\n\ngoal (1 subgoal):\n 1. \\<And>aa p v.\n       \\<lbrakk>\\<And>v.\n                   is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n                   nodes_connected (add_edge a' w'' b G) v v';\n        is_path_undir (add_edge a w b G) v (aa # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected (add_edge a' w'' b G) v v'", "with p' Cons.IH \n     and valid_graph.is_path_undir_split[OF add_edge_valid[OF valid_graph.intro[OF E_valid]]]"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a w b G) x p' v'\n  is_path_undir (add_edge a w b G) ?v p' v' \\<Longrightarrow>\n  nodes_connected (add_edge a' w'' b G) ?v v'\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 G) ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 G) ?v ?p1.0 u \\<and>\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 G) u ?p2.0 ?v')\n  nodes_connected (add_edge a' w'' b G) v x", "show ?case"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a w b G) x p' v'\n  is_path_undir (add_edge a w b G) ?v p' v' \\<Longrightarrow>\n  nodes_connected (add_edge a' w'' b G) ?v v'\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 G) ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 G) ?v ?p1.0 u \\<and>\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 G) u ?p2.0 ?v')\n  nodes_connected (add_edge a' w'' b G) v x\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a' w'' b G) v v'", "by blast"], ["proof (state)\nthis:\n  nodes_connected (add_edge a' w'' b G) v v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induce_maximally_connected:\n    assumes \"subgraph H G\"\n    assumes \"\\<forall>(a,w,b)\\<in>E. nodes_connected H a b\"\n    shows \"maximally_connected H G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximally_connected H G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. maximally_connected H G", "from valid_subgraph[OF \\<open>subgraph H G\\<close>]"], ["proof (chain)\npicking this:\n  valid_graph H", "have valid_H: \"valid_graph H\""], ["proof (prove)\nusing this:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. valid_graph H", "."], ["proof (state)\nthis:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. maximally_connected H G", "have \"(nodes_connected G v v') \\<longrightarrow> (nodes_connected H v v')\" (is \"?lhs \\<longrightarrow> ?rhs\")\n      if \"v\\<in>V\" and \"v'\\<in>V\" for v v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow> nodes_connected H v v'", "assume ?lhs"], ["proof (state)\nthis:\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow> nodes_connected H v v'", "then"], ["proof (chain)\npicking this:\n  nodes_connected G v v'", "obtain p where \"is_path_undir G v p v'\""], ["proof (prove)\nusing this:\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir G v p v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_path_undir G v p v'\n\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow> nodes_connected H v v'", "then"], ["proof (chain)\npicking this:\n  is_path_undir G v p v'", "show ?rhs"], ["proof (prove)\nusing this:\n  is_path_undir G v p v'\n\ngoal (1 subgoal):\n 1. nodes_connected H v v'", "proof (induction p arbitrary: v v')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v v'.\n       is_path_undir G v [] v' \\<Longrightarrow> nodes_connected H v v'\n 2. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "case Nil"], ["proof (state)\nthis:\n  is_path_undir G v [] v'\n\ngoal (2 subgoals):\n 1. \\<And>v v'.\n       is_path_undir G v [] v' \\<Longrightarrow> nodes_connected H v v'\n 2. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "with subgraph_node[OF assms(1)]"], ["proof (chain)\npicking this:\n  (?v \\<in> V) = (?v \\<in> nodes H)\n  is_path_undir G v [] v'", "show ?case"], ["proof (prove)\nusing this:\n  (?v \\<in> V) = (?v \\<in> nodes H)\n  is_path_undir G v [] v'\n\ngoal (1 subgoal):\n 1. nodes_connected H v v'", "by (metis is_path_undir.simps(1))"], ["proof (state)\nthis:\n  nodes_connected H v v'\n\ngoal (1 subgoal):\n 1. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "case (Cons e p)"], ["proof (state)\nthis:\n  is_path_undir G ?v p ?v' \\<Longrightarrow> nodes_connected H ?v ?v'\n  is_path_undir G v (e # p) v'\n\ngoal (1 subgoal):\n 1. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "from prod_cases3"], ["proof (chain)\npicking this:\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain a w b where awb: \"e = (a, w, b)\""], ["proof (prove)\nusing this:\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a w b. e = (a, w, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  e = (a, w, b)\n\ngoal (1 subgoal):\n 1. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "with assms Cons.prems valid_graph.is_path_undir_sym[OF valid_H, of b _ a]"], ["proof (chain)\npicking this:\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  is_path_undir G v (e # p) v'\n  is_path_undir H b ?p a \\<Longrightarrow>\n  is_path_undir H a (rev (map (\\<lambda>(u, w, u'). (u', w, u)) ?p)) b\n  e = (a, w, b)", "obtain p' where p': \"is_path_undir H a p' b\""], ["proof (prove)\nusing this:\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  is_path_undir G v (e # p) v'\n  is_path_undir H b ?p a \\<Longrightarrow>\n  is_path_undir H a (rev (map (\\<lambda>(u, w, u'). (u', w, u)) ?p)) b\n  e = (a, w, b)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        is_path_undir H a p' b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  is_path_undir H a p' b\n\ngoal (1 subgoal):\n 1. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "from assms awb Cons.prems Cons.IH[of b v']"], ["proof (chain)\npicking this:\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  e = (a, w, b)\n  is_path_undir G v (e # p) v'\n  is_path_undir G b p v' \\<Longrightarrow> nodes_connected H b v'", "obtain p'' where \"is_path_undir H b p'' v'\""], ["proof (prove)\nusing this:\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  e = (a, w, b)\n  is_path_undir G v (e # p) v'\n  is_path_undir G b p v' \\<Longrightarrow> nodes_connected H b v'\n\ngoal (1 subgoal):\n 1. (\\<And>p''.\n        is_path_undir H b p'' v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  e = (a, w, b)\n  is_path_undir G v (e # p) v'\n  is_path_undir G b p v' \\<Longrightarrow> nodes_connected H b v'\n\ngoal (1 subgoal):\n 1. (\\<And>p''.\n        is_path_undir H b p'' v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir H b p'' v'\n\ngoal (1 subgoal):\n 1. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "with Cons.prems awb assms p' valid_graph.is_path_undir_split[OF valid_H]"], ["proof (chain)\npicking this:\n  is_path_undir G v (e # p) v'\n  e = (a, w, b)\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  is_path_undir H a p' b\n  is_path_undir H ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir H ?v ?p1.0 u \\<and> is_path_undir H u ?p2.0 ?v')\n  is_path_undir H b p'' v'", "have \"is_path_undir H v (p'@p'') v'\""], ["proof (prove)\nusing this:\n  is_path_undir G v (e # p) v'\n  e = (a, w, b)\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  is_path_undir H a p' b\n  is_path_undir H ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir H ?v ?p1.0 u \\<and> is_path_undir H u ?p2.0 ?v')\n  is_path_undir H b p'' v'\n\ngoal (1 subgoal):\n 1. is_path_undir H v (p' @ p'') v'", "by auto"], ["proof (state)\nthis:\n  is_path_undir H v (p' @ p'') v'\n\ngoal (1 subgoal):\n 1. \\<And>a p v v'.\n       \\<lbrakk>\\<And>v v'.\n                   is_path_undir G v p v' \\<Longrightarrow>\n                   nodes_connected H v v';\n        is_path_undir G v (a # p) v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "then"], ["proof (chain)\npicking this:\n  is_path_undir H v (p' @ p'') v'", "show ?case"], ["proof (prove)\nusing this:\n  is_path_undir H v (p' @ p'') v'\n\ngoal (1 subgoal):\n 1. nodes_connected H v v'", ".."], ["proof (state)\nthis:\n  nodes_connected H v v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected H v v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected H ?v ?v'\n\ngoal (1 subgoal):\n 1. maximally_connected H G", "with assms"], ["proof (chain)\npicking this:\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected H ?v ?v'", "show ?thesis"], ["proof (prove)\nusing this:\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected H ?v ?v'\n\ngoal (1 subgoal):\n 1. maximally_connected H G", "unfolding maximally_connected_def"], ["proof (prove)\nusing this:\n  subgraph H G\n  \\<forall>(a, w, b)\\<in>E. nodes_connected H a b\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected H ?v ?v'\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       \\<forall>v'\\<in>V.\n          nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'", "by auto"], ["proof (state)\nthis:\n  maximally_connected H G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_edge_maximally_connected:\n    assumes \"maximally_connected H G\"\n    assumes \"subgraph H G\"\n    assumes \"(a, w, b) \\<in> E\"\n    shows \"maximally_connected (add_edge a w b H) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximally_connected (add_edge a w b H) G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. maximally_connected (add_edge a w b H) G", "have \"(nodes_connected G v v') \\<longrightarrow> (nodes_connected (add_edge a w b H) v v')\"\n      (is \"?lhs \\<longrightarrow> ?rhs\") if vv': \"v \\<in> V\" \"v' \\<in> V\" for v v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<longrightarrow>\n    nodes_connected (add_edge a w b H) v v'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) v v'", "assume ?lhs"], ["proof (state)\nthis:\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) v v'", "with \\<open>maximally_connected H G\\<close> vv'"], ["proof (chain)\npicking this:\n  maximally_connected H G\n  v \\<in> V\n  v' \\<in> V\n  nodes_connected G v v'", "obtain p where \"is_path_undir H v p v'\""], ["proof (prove)\nusing this:\n  maximally_connected H G\n  v \\<in> V\n  v' \\<in> V\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir H v p v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding maximally_connected_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     \\<forall>v'\\<in>V.\n        nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'\n  v \\<in> V\n  v' \\<in> V\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir H v p v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir H v p v'\n\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) v v'", "with valid_graph.add_edge_is_path[OF valid_subgraph[OF \\<open>subgraph H G\\<close>] this]"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge ?a ?b ?c H) v p v'\n  is_path_undir H v p v'", "show ?rhs"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge ?a ?b ?c H) v p v'\n  is_path_undir H v p v'\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) v v'", "by auto"], ["proof (state)\nthis:\n  nodes_connected (add_edge a w b H) v v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (add_edge a w b H) ?v ?v'\n\ngoal (1 subgoal):\n 1. maximally_connected (add_edge a w b H) G", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (add_edge a w b H) ?v ?v'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (add_edge a w b H) ?v ?v'\n\ngoal (1 subgoal):\n 1. maximally_connected (add_edge a w b H) G", "unfolding maximally_connected_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (add_edge a w b H) ?v ?v'\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       \\<forall>v'\\<in>V.\n          nodes_connected G v v' \\<longrightarrow>\n          nodes_connected (add_edge a w b H) v v'", "by auto"], ["proof (state)\nthis:\n  maximally_connected (add_edge a w b H) G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_edge_maximally_connected:\n    assumes \"maximally_connected H G\"\n    assumes \"subgraph H G\"\n    assumes pab: \"is_path_undir (delete_edge a w b H) a pab b\"\n    shows \"maximally_connected (delete_edge a w b H) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximally_connected (delete_edge a w b H) G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. maximally_connected (delete_edge a w b H) G", "from valid_subgraph[OF \\<open>subgraph H G\\<close>]"], ["proof (chain)\npicking this:\n  valid_graph H", "have valid_H: \"valid_graph H\""], ["proof (prove)\nusing this:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. valid_graph H", "."], ["proof (state)\nthis:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. maximally_connected (delete_edge a w b H) G", "have \"(nodes_connected G v v') \\<longrightarrow> (nodes_connected (delete_edge a w b H) v v')\" \n      (is \"?lhs \\<longrightarrow> ?rhs\") if vv': \"v \\<in> V\" \"v' \\<in> V\" for v v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "assume ?lhs"], ["proof (state)\nthis:\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "with \\<open>maximally_connected H G\\<close> vv'"], ["proof (chain)\npicking this:\n  maximally_connected H G\n  v \\<in> V\n  v' \\<in> V\n  nodes_connected G v v'", "obtain p where p: \"is_path_undir H v p v'\""], ["proof (prove)\nusing this:\n  maximally_connected H G\n  v \\<in> V\n  v' \\<in> V\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir H v p v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding maximally_connected_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     \\<forall>v'\\<in>V.\n        nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'\n  v \\<in> V\n  v' \\<in> V\n  nodes_connected G v v'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir H v p v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir H v p v'\n\ngoal (1 subgoal):\n 1. nodes_connected G v v' \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) v v'", "proof (cases \"(a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "case True"], ["proof (state)\nthis:\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "with p valid_graph.is_path_undir_split_distinct[OF valid_H p, of a w b]"], ["proof (chain)\npicking this:\n  is_path_undir H v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n  \\<exists>p' p'' u u'.\n     is_path_undir H v p' u \\<and>\n     is_path_undir H u' p'' v' \\<and>\n     length p' < length p \\<and>\n     length p'' < length p \\<and>\n     (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n     (a, w, b) \\<notin> set p' \\<and>\n     (b, w, a) \\<notin> set p' \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p", "obtain p' p'' u u'\n          where \"is_path_undir H v p' u \\<and> is_path_undir H u' p'' v'\" and\n            u: \"(u \\<in> {a, b} \\<and> u' \\<in> {a, b})\" and\n            \"(a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p' \\<and>\n            (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\""], ["proof (prove)\nusing this:\n  is_path_undir H v p v'\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n  \\<exists>p' p'' u u'.\n     is_path_undir H v p' u \\<and>\n     is_path_undir H u' p'' v' \\<and>\n     length p' < length p \\<and>\n     length p'' < length p \\<and>\n     (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n     (a, w, b) \\<notin> set p' \\<and>\n     (b, w, a) \\<notin> set p' \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p' u u' p''.\n        \\<lbrakk>is_path_undir H v p' u \\<and> is_path_undir H u' p'' v';\n         u \\<in> {a, b} \\<and> u' \\<in> {a, b};\n         (a, w, b) \\<notin> set p' \\<and>\n         (b, w, a) \\<notin> set p' \\<and>\n         (a, w, b) \\<notin> set p'' \\<and>\n         (b, w, a) \\<notin> set p''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir H v p' u \\<and> is_path_undir H u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "with valid_graph.delete_edge_is_path[OF valid_H]"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_path_undir H ?x ?p ?y; (?a, ?b, ?c) \\<notin> set ?p;\n   (?c, ?b, ?a) \\<notin> set ?p\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (delete_edge ?a ?b ?c H) ?x ?p ?y\n  is_path_undir H v p' u \\<and> is_path_undir H u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "obtain p' p''\n          where p': \"is_path_undir (delete_edge a w b H) v p' u \\<and>\n                 is_path_undir (delete_edge a w b H) u' p'' v'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_path_undir H ?x ?p ?y; (?a, ?b, ?c) \\<notin> set ?p;\n   (?c, ?b, ?a) \\<notin> set ?p\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (delete_edge ?a ?b ?c H) ?x ?p ?y\n  is_path_undir H v p' u \\<and> is_path_undir H u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. (\\<And>p' p''.\n        is_path_undir (delete_edge a w b H) v p' u \\<and>\n        is_path_undir (delete_edge a w b H) u' p'' v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_path_undir (delete_edge a w b H) v p' u \\<and>\n  is_path_undir (delete_edge a w b H) u' p'' v'\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "note dev_H = delete_edge_valid[OF valid_H]"], ["proof (state)\nthis:\n  valid_graph (delete_edge ?v ?e ?v' H)\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "note * = valid_graph.is_path_undir_split[OF dev_H, of a w b v]"], ["proof (state)\nthis:\n  is_path_undir (delete_edge a w b H) v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v ?p1.0 u \\<and>\n      is_path_undir (delete_edge a w b H) u ?p2.0 ?v')\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "from valid_graph.is_path_undir_sym[OF delete_edge_valid[OF valid_H] pab]"], ["proof (chain)\npicking this:\n  is_path_undir (delete_edge a w b H) b\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) pab)) a", "obtain pab'\n          where \"is_path_undir (delete_edge a w b H) b pab' a\""], ["proof (prove)\nusing this:\n  is_path_undir (delete_edge a w b H) b\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) pab)) a\n\ngoal (1 subgoal):\n 1. (\\<And>pab'.\n        is_path_undir (delete_edge a w b H) b pab' a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge a w b H) b pab' a\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "with assms u p' valid_graph.is_path_undir_split[OF dev_H, of a w b v p' p'' v']\n          *[of p' pab b] *[of \"p'@pab\" p'' v'] *[of p' pab' a] *[of \"p'@pab'\" p'' v']"], ["proof (chain)\npicking this:\n  maximally_connected H G\n  subgraph H G\n  is_path_undir (delete_edge a w b H) a pab b\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  is_path_undir (delete_edge a w b H) v p' u \\<and>\n  is_path_undir (delete_edge a w b H) u' p'' v'\n  is_path_undir (delete_edge a w b H) v (p' @ p'') v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v p' u \\<and>\n      is_path_undir (delete_edge a w b H) u p'' v')\n  is_path_undir (delete_edge a w b H) v (p' @ pab) b =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v p' u \\<and>\n      is_path_undir (delete_edge a w b H) u pab b)\n  is_path_undir (delete_edge a w b H) v ((p' @ pab) @ p'') v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v (p' @ pab) u \\<and>\n      is_path_undir (delete_edge a w b H) u p'' v')\n  is_path_undir (delete_edge a w b H) v (p' @ pab') a =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v p' u \\<and>\n      is_path_undir (delete_edge a w b H) u pab' a)\n  is_path_undir (delete_edge a w b H) v ((p' @ pab') @ p'') v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v (p' @ pab') u \\<and>\n      is_path_undir (delete_edge a w b H) u p'' v')\n  is_path_undir (delete_edge a w b H) b pab' a", "show ?thesis"], ["proof (prove)\nusing this:\n  maximally_connected H G\n  subgraph H G\n  is_path_undir (delete_edge a w b H) a pab b\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  is_path_undir (delete_edge a w b H) v p' u \\<and>\n  is_path_undir (delete_edge a w b H) u' p'' v'\n  is_path_undir (delete_edge a w b H) v (p' @ p'') v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v p' u \\<and>\n      is_path_undir (delete_edge a w b H) u p'' v')\n  is_path_undir (delete_edge a w b H) v (p' @ pab) b =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v p' u \\<and>\n      is_path_undir (delete_edge a w b H) u pab b)\n  is_path_undir (delete_edge a w b H) v ((p' @ pab) @ p'') v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v (p' @ pab) u \\<and>\n      is_path_undir (delete_edge a w b H) u p'' v')\n  is_path_undir (delete_edge a w b H) v (p' @ pab') a =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v p' u \\<and>\n      is_path_undir (delete_edge a w b H) u pab' a)\n  is_path_undir (delete_edge a w b H) v ((p' @ pab') @ p'') v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge a w b H) v (p' @ pab') u \\<and>\n      is_path_undir (delete_edge a w b H) u p'' v')\n  is_path_undir (delete_edge a w b H) b pab' a\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) v v'", "by auto"], ["proof (state)\nthis:\n  nodes_connected (delete_edge a w b H) v v'\n\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "case False"], ["proof (state)\nthis:\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)\n\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    nodes_connected (delete_edge a w b H) v v'", "with valid_graph.delete_edge_is_path[OF valid_H p]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?a, ?b, ?c) \\<notin> set p; (?c, ?b, ?a) \\<notin> set p\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (delete_edge ?a ?b ?c H) v p v'\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b, ?c) \\<notin> set p; (?c, ?b, ?a) \\<notin> set p\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (delete_edge ?a ?b ?c H) v p v'\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) v v'", "by auto"], ["proof (state)\nthis:\n  nodes_connected (delete_edge a w b H) v v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected (delete_edge a w b H) v v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (delete_edge a w b H) ?v ?v'\n\ngoal (1 subgoal):\n 1. maximally_connected (delete_edge a w b H) G", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (delete_edge a w b H) ?v ?v'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (delete_edge a w b H) ?v ?v'\n\ngoal (1 subgoal):\n 1. maximally_connected (delete_edge a w b H) G", "unfolding maximally_connected_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?v ?v' \\<longrightarrow>\n                    nodes_connected (delete_edge a w b H) ?v ?v'\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       \\<forall>v'\\<in>V.\n          nodes_connected G v v' \\<longrightarrow>\n          nodes_connected (delete_edge a w b H) v v'", "by auto"], ["proof (state)\nthis:\n  maximally_connected (delete_edge a w b H) G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma connected_impl_maximally_connected:\n    assumes \"connected_graph H\"\n    assumes subgraph: \"subgraph H G\"\n    shows \"maximally_connected H G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximally_connected H G", "using assms"], ["proof (prove)\nusing this:\n  connected_graph H\n  subgraph H G\n\ngoal (1 subgoal):\n 1. maximally_connected H G", "unfolding connected_graph_def connected_graph_axioms_def maximally_connected_def\n      subgraph_def"], ["proof (prove)\nusing this:\n  valid_graph H \\<and>\n  (\\<forall>v\\<in>nodes H. \\<forall>v'\\<in>nodes H. nodes_connected H v v')\n  nodes H = V \\<and> edges H \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       \\<forall>v'\\<in>V.\n          nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'", "by blast"], ["", "lemma add_edge_is_connected:\n    \"nodes_connected (add_edge a b c G) a c\"\n    \"nodes_connected (add_edge a b c G) c a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a b c G) a c &&&\n    nodes_connected (add_edge a b c G) c a", "using valid_graph.is_path_undir_simps(2)[OF\n        add_edge_valid[OF valid_graph_axioms], of a b c a b c]\n      valid_graph.is_path_undir_simps(2)[OF\n        add_edge_valid[OF valid_graph_axioms], of a b c c b a]"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a b c G) a [(a, b, c)] c =\n  ((a, b, c) \\<in> edges (add_edge a b c G) \\<or>\n   (c, b, a) \\<in> edges (add_edge a b c G))\n  is_path_undir (add_edge a b c G) c [(c, b, a)] a =\n  ((c, b, a) \\<in> edges (add_edge a b c G) \\<or>\n   (a, b, c) \\<in> edges (add_edge a b c G))\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a b c G) a c &&&\n    nodes_connected (add_edge a b c G) c a", "by fastforce+"], ["", "lemma swap_edges:\n    assumes \"nodes_connected (add_edge a w b G) v v'\"\n    assumes \"a \\<in> V\"\n    assumes \"b \\<in> V\"\n    assumes \"\\<not> nodes_connected G v v'\"\n    shows \"nodes_connected (add_edge v w' v' G) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "from assms(1)"], ["proof (chain)\npicking this:\n  nodes_connected (add_edge a w b G) v v'", "obtain p where p: \"is_path_undir (add_edge a w b G) v p v'\""], ["proof (prove)\nusing this:\n  nodes_connected (add_edge a w b G) v v'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir (add_edge a w b G) v p v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b G) v p v'\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "have awb: \"(a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    False", "assume \"\\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)\""], ["proof (state)\nthis:\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)\n\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    False", "with add_edge_was_path[OF p _ _ assms(2,3)] assms(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>(a, w, b) \\<notin> set p; (b, w, a) \\<notin> set p\\<rbrakk>\n  \\<Longrightarrow> is_path_undir G v p v'\n  \\<not> nodes_connected G v v'\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>(a, w, b) \\<notin> set p; (b, w, a) \\<notin> set p\\<rbrakk>\n  \\<Longrightarrow> is_path_undir G v p v'\n  \\<not> nodes_connected G v v'\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "from valid_graph.is_path_undir_split_distinct[OF\n        add_edge_valid[OF valid_graph_axioms] p awb]"], ["proof (chain)\npicking this:\n  \\<exists>p' p'' u u'.\n     is_path_undir (add_edge a w b G) v p' u \\<and>\n     is_path_undir (add_edge a w b G) u' p'' v' \\<and>\n     length p' < length p \\<and>\n     length p'' < length p \\<and>\n     (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n     (a, w, b) \\<notin> set p' \\<and>\n     (b, w, a) \\<notin> set p' \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "obtain p' p'' u u' where\n         \"is_path_undir (add_edge a w b G) v p' u \\<and>\n          is_path_undir (add_edge a w b G) u' p'' v'\" and\n          u: \"u \\<in> {a, b} \\<and> u' \\<in> {a, b}\" and\n          \"(a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p' \\<and>\n          (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p'' \""], ["proof (prove)\nusing this:\n  \\<exists>p' p'' u u'.\n     is_path_undir (add_edge a w b G) v p' u \\<and>\n     is_path_undir (add_edge a w b G) u' p'' v' \\<and>\n     length p' < length p \\<and>\n     length p'' < length p \\<and>\n     (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n     (a, w, b) \\<notin> set p' \\<and>\n     (b, w, a) \\<notin> set p' \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. (\\<And>p' u u' p''.\n        \\<lbrakk>is_path_undir (add_edge a w b G) v p' u \\<and>\n                 is_path_undir (add_edge a w b G) u' p'' v';\n         u \\<in> {a, b} \\<and> u' \\<in> {a, b};\n         (a, w, b) \\<notin> set p' \\<and>\n         (b, w, a) \\<notin> set p' \\<and>\n         (a, w, b) \\<notin> set p'' \\<and>\n         (b, w, a) \\<notin> set p''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b G) v p' u \\<and>\n  is_path_undir (add_edge a w b G) u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "with assms(2,3) add_edge_was_path"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  \\<lbrakk>is_path_undir (add_edge ?a ?b ?c G) ?x ?p ?y;\n   (?a, ?b, ?c) \\<notin> set ?p; (?c, ?b, ?a) \\<notin> set ?p; ?a \\<in> V;\n   ?c \\<in> V\\<rbrakk>\n  \\<Longrightarrow> is_path_undir G ?x ?p ?y\n  is_path_undir (add_edge a w b G) v p' u \\<and>\n  is_path_undir (add_edge a w b G) u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "have paths: \"is_path_undir G v p' u \\<and>\n                 is_path_undir G u' p'' v'\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  \\<lbrakk>is_path_undir (add_edge ?a ?b ?c G) ?x ?p ?y;\n   (?a, ?b, ?c) \\<notin> set ?p; (?c, ?b, ?a) \\<notin> set ?p; ?a \\<in> V;\n   ?c \\<in> V\\<rbrakk>\n  \\<Longrightarrow> is_path_undir G ?x ?p ?y\n  is_path_undir (add_edge a w b G) v p' u \\<and>\n  is_path_undir (add_edge a w b G) u' p'' v'\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. is_path_undir G v p' u \\<and> is_path_undir G u' p'' v'", "by blast"], ["proof (state)\nthis:\n  is_path_undir G v p' u \\<and> is_path_undir G u' p'' v'\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "with is_path_undir_split[of v p' p'' v'] assms(4)"], ["proof (chain)\npicking this:\n  is_path_undir G v (p' @ p'') v' =\n  (\\<exists>u. is_path_undir G v p' u \\<and> is_path_undir G u p'' v')\n  \\<not> nodes_connected G v v'\n  is_path_undir G v p' u \\<and> is_path_undir G u' p'' v'", "have \"u \\<noteq> u'\""], ["proof (prove)\nusing this:\n  is_path_undir G v (p' @ p'') v' =\n  (\\<exists>u. is_path_undir G v p' u \\<and> is_path_undir G u p'' v')\n  \\<not> nodes_connected G v v'\n  is_path_undir G v p' u \\<and> is_path_undir G u' p'' v'\n\ngoal (1 subgoal):\n 1. u \\<noteq> u'", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> u'\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "from paths assms add_edge_is_path"], ["proof (chain)\npicking this:\n  is_path_undir G v p' u \\<and> is_path_undir G u' p'' v'\n  nodes_connected (add_edge a w b G) v v'\n  a \\<in> V\n  b \\<in> V\n  \\<not> nodes_connected G v v'\n  is_path_undir G ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (add_edge ?a ?b ?c G) ?x ?p ?y", "have paths': \"is_path_undir (add_edge v w' v' G) v p' u \\<and>\n                  is_path_undir (add_edge v w' v' G) u' p'' v'\""], ["proof (prove)\nusing this:\n  is_path_undir G v p' u \\<and> is_path_undir G u' p'' v'\n  nodes_connected (add_edge a w b G) v v'\n  a \\<in> V\n  b \\<in> V\n  \\<not> nodes_connected G v v'\n  is_path_undir G ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (add_edge ?a ?b ?c G) ?x ?p ?y\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge v w' v' G) v p' u \\<and>\n    is_path_undir (add_edge v w' v' G) u' p'' v'", "by blast"], ["proof (state)\nthis:\n  is_path_undir (add_edge v w' v' G) v p' u \\<and>\n  is_path_undir (add_edge v w' v' G) u' p'' v'\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "note * = add_edge_valid[OF valid_graph_axioms]"], ["proof (state)\nthis:\n  valid_graph (add_edge ?v ?e ?v' G)\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "from add_edge_is_connected"], ["proof (chain)\npicking this:\n  nodes_connected (add_edge ?a ?b ?c G) ?a ?c\n  nodes_connected (add_edge ?a ?b ?c G) ?c ?a", "obtain p''' where\n      \"is_path_undir (add_edge v w' v' G) v' p''' v\""], ["proof (prove)\nusing this:\n  nodes_connected (add_edge ?a ?b ?c G) ?a ?c\n  nodes_connected (add_edge ?a ?b ?c G) ?c ?a\n\ngoal (1 subgoal):\n 1. (\\<And>p'''.\n        is_path_undir (add_edge v w' v' G) v' p''' v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_path_undir (add_edge v w' v' G) v' p''' v\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "with paths' valid_graph.is_path_undir_split[OF *, of v w' v' u' p'' p''' v]"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge v w' v' G) v p' u \\<and>\n  is_path_undir (add_edge v w' v' G) u' p'' v'\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''') v =\n  (\\<exists>u.\n      is_path_undir (add_edge v w' v' G) u' p'' u \\<and>\n      is_path_undir (add_edge v w' v' G) u p''' v)\n  is_path_undir (add_edge v w' v' G) v' p''' v", "have \"is_path_undir (add_edge v w' v' G) u' (p''@p''') v\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge v w' v' G) v p' u \\<and>\n  is_path_undir (add_edge v w' v' G) u' p'' v'\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''') v =\n  (\\<exists>u.\n      is_path_undir (add_edge v w' v' G) u' p'' u \\<and>\n      is_path_undir (add_edge v w' v' G) u p''' v)\n  is_path_undir (add_edge v w' v' G) v' p''' v\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge v w' v' G) u' (p'' @ p''') v", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''') v\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "with paths' valid_graph.is_path_undir_split[OF *, of v w' v' u' \"p''@p'''\" p' u]"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge v w' v' G) v p' u \\<and>\n  is_path_undir (add_edge v w' v' G) u' p'' v'\n  is_path_undir (add_edge v w' v' G) u' ((p'' @ p''') @ p') u =\n  (\\<exists>ua.\n      is_path_undir (add_edge v w' v' G) u' (p'' @ p''') ua \\<and>\n      is_path_undir (add_edge v w' v' G) ua p' u)\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''') v", "have \"is_path_undir (add_edge v w' v' G) u' (p''@p'''@p') u\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge v w' v' G) v p' u \\<and>\n  is_path_undir (add_edge v w' v' G) u' p'' v'\n  is_path_undir (add_edge v w' v' G) u' ((p'' @ p''') @ p') u =\n  (\\<exists>ua.\n      is_path_undir (add_edge v w' v' G) u' (p'' @ p''') ua \\<and>\n      is_path_undir (add_edge v w' v' G) ua p' u)\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''') v\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge v w' v' G) u' (p'' @ p''' @ p') u", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''' @ p') u\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "with u \\<open>u \\<noteq> u'\\<close> valid_graph.is_path_undir_sym[OF * this]"], ["proof (chain)\npicking this:\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  u \\<noteq> u'\n  is_path_undir (add_edge v w' v' G) u\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) (p'' @ p''' @ p'))) u'\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''' @ p') u", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  u \\<noteq> u'\n  is_path_undir (add_edge v w' v' G) u\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) (p'' @ p''' @ p'))) u'\n  is_path_undir (add_edge v w' v' G) u' (p'' @ p''' @ p') u\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge v w' v' G) a b", "by auto"], ["proof (state)\nthis:\n  nodes_connected (add_edge v w' v' G) a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subgraph_impl_connected:\n    assumes \"connected_graph H\"\n    assumes subgraph: \"subgraph H G\"\n    shows \"connected_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_graph G", "using assms is_path_undir_subgraph[OF _ subgraph] valid_graph_axioms"], ["proof (prove)\nusing this:\n  connected_graph H\n  subgraph H G\n  is_path_undir H ?x ?p ?y \\<Longrightarrow> is_path_undir G ?x ?p ?y\n  valid_graph G\n\ngoal (1 subgoal):\n 1. connected_graph G", "unfolding connected_graph_def connected_graph_axioms_def maximally_connected_def\n      subgraph_def"], ["proof (prove)\nusing this:\n  valid_graph H \\<and>\n  (\\<forall>v\\<in>nodes H. \\<forall>v'\\<in>nodes H. nodes_connected H v v')\n  nodes H = V \\<and> edges H \\<subseteq> E\n  is_path_undir H ?x ?p ?y \\<Longrightarrow> is_path_undir G ?x ?p ?y\n  valid_graph G\n\ngoal (1 subgoal):\n 1. valid_graph G \\<and>\n    (\\<forall>v\\<in>V. \\<forall>v'\\<in>V. nodes_connected G v v')", "by blast"], ["", "lemma add_node_connected:\n    assumes \"\\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\"\n    assumes \"(v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\"\n    assumes \"v \\<noteq> v'\"\n    shows \"\\<forall>a\\<in>V. \\<forall>b\\<in>V. nodes_connected G a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>V. \\<forall>b\\<in>V. nodes_connected G a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>V. \\<forall>b\\<in>V. nodes_connected G a b", "have \"nodes_connected G a b\" if a: \"a\\<in>V\" and b: \"b\\<in>V\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G a b", "proof (cases \"a = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> nodes_connected G a b\n 2. a \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "case True"], ["proof (state)\nthis:\n  a = v\n\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> nodes_connected G a b\n 2. a \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G a b", "proof (cases \"b = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> nodes_connected G a b\n 2. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "case True"], ["proof (state)\nthis:\n  b = v\n\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> nodes_connected G a b\n 2. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "with \\<open>a = v\\<close> a is_path_undir_simps(1)"], ["proof (chain)\npicking this:\n  a = v\n  a \\<in> V\n  is_path_undir G ?v [] ?v = (?v \\<in> V)\n  b = v", "show ?thesis"], ["proof (prove)\nusing this:\n  a = v\n  a \\<in> V\n  is_path_undir G ?v [] ?v = (?v \\<in> V)\n  b = v\n\ngoal (1 subgoal):\n 1. nodes_connected G a b", "by blast"], ["proof (state)\nthis:\n  nodes_connected G a b\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "case False"], ["proof (state)\nthis:\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "from assms(2)"], ["proof (chain)\npicking this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E", "have \"v' \\<in> V\""], ["proof (prove)\nusing this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "by (auto simp: E_validD)"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "with b assms(1) \\<open>b \\<noteq> v\\<close> \\<open>v \\<noteq> v'\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> V\n  \\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\n  b \\<noteq> v\n  v \\<noteq> v'\n  v' \\<in> V", "have \"nodes_connected G v' b\""], ["proof (prove)\nusing this:\n  b \\<in> V\n  \\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\n  b \\<noteq> v\n  v \\<noteq> v'\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. nodes_connected G v' b", "by blast"], ["proof (state)\nthis:\n  nodes_connected G v' b\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "with assms(2) \\<open>a = v\\<close> is_path_undir.simps(2)[of G v v w v' _ b]"], ["proof (chain)\npicking this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\n  a = v\n  is_path_undir G v ((v, w, v') # ?p) b =\n  (v = v \\<and>\n   ((v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E) \\<and>\n   is_path_undir G v' ?p b)\n  nodes_connected G v' b", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\n  a = v\n  is_path_undir G v ((v, w, v') # ?p) b =\n  (v = v \\<and>\n   ((v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E) \\<and>\n   is_path_undir G v' ?p b)\n  nodes_connected G v' b\n\ngoal (1 subgoal):\n 1. nodes_connected G a b", "by blast"], ["proof (state)\nthis:\n  nodes_connected G a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected G a b\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "case False"], ["proof (state)\nthis:\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G a b", "proof (cases \"b = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> nodes_connected G a b\n 2. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "case True"], ["proof (state)\nthis:\n  b = v\n\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> nodes_connected G a b\n 2. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "from assms(2)"], ["proof (chain)\npicking this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E", "have \"v' \\<in> V\""], ["proof (prove)\nusing this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "by (auto simp: E_validD)"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> nodes_connected G a b\n 2. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "with a assms(1) \\<open>a \\<noteq> v\\<close> \\<open>v \\<noteq> v'\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> V\n  \\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\n  a \\<noteq> v\n  v \\<noteq> v'\n  v' \\<in> V", "have \"nodes_connected G a v'\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  \\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\n  a \\<noteq> v\n  v \\<noteq> v'\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. nodes_connected G a v'", "by blast"], ["proof (state)\nthis:\n  nodes_connected G a v'\n\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> nodes_connected G a b\n 2. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "with assms(2) \\<open>b = v\\<close> is_path_undir.simps(2)[of G v v w v' _ a]\n          is_path_undir_sym"], ["proof (chain)\npicking this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\n  b = v\n  is_path_undir G v ((v, w, v') # ?p) a =\n  (v = v \\<and>\n   ((v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E) \\<and>\n   is_path_undir G v' ?p a)\n  is_path_undir G ?v ?p ?v' \\<Longrightarrow>\n  is_path_undir G ?v' (rev (map (\\<lambda>(u, w, u'). (u', w, u)) ?p)) ?v\n  nodes_connected G a v'", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E\n  b = v\n  is_path_undir G v ((v, w, v') # ?p) a =\n  (v = v \\<and>\n   ((v, w, v') \\<in> E \\<or> (v', w, v) \\<in> E) \\<and>\n   is_path_undir G v' ?p a)\n  is_path_undir G ?v ?p ?v' \\<Longrightarrow>\n  is_path_undir G ?v' (rev (map (\\<lambda>(u, w, u'). (u', w, u)) ?p)) ?v\n  nodes_connected G a v'\n\ngoal (1 subgoal):\n 1. nodes_connected G a b", "by blast"], ["proof (state)\nthis:\n  nodes_connected G a b\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "case False"], ["proof (state)\nthis:\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> nodes_connected G a b", "with \\<open>a \\<noteq> v\\<close> assms(1) a b"], ["proof (chain)\npicking this:\n  a \\<noteq> v\n  \\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\n  a \\<in> V\n  b \\<in> V\n  b \\<noteq> v", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> v\n  \\<forall>a\\<in>V - {v}. \\<forall>b\\<in>V - {v}. nodes_connected G a b\n  a \\<in> V\n  b \\<in> V\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. nodes_connected G a b", "by simp"], ["proof (state)\nthis:\n  nodes_connected G a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected G a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> V; ?b \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?a ?b\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>V. \\<forall>b\\<in>V. nodes_connected G a b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> V; ?b \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?a ?b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> V; ?b \\<in> V\\<rbrakk>\n  \\<Longrightarrow> nodes_connected G ?a ?b\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>V. \\<forall>b\\<in>V. nodes_connected G a b", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>V. \\<forall>b\\<in>V. nodes_connected G a b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context connected_graph\nbegin"], ["", "lemma maximally_connected_impl_connected:\n    assumes \"maximally_connected H G\"\n    assumes subgraph: \"subgraph H G\"\n    shows \"connected_graph H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_graph H", "using assms connected_graph_axioms valid_subgraph[OF subgraph]"], ["proof (prove)\nusing this:\n  maximally_connected H G\n  subgraph H G\n  connected_graph G\n  valid_graph H\n\ngoal (1 subgoal):\n 1. connected_graph H", "unfolding connected_graph_def connected_graph_axioms_def maximally_connected_def\n      subgraph_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     \\<forall>v'\\<in>V.\n        nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'\n  nodes H = V \\<and> edges H \\<subseteq> E\n  valid_graph G \\<and>\n  (\\<forall>v\\<in>V. \\<forall>v'\\<in>V. nodes_connected G v v')\n  valid_graph H\n\ngoal (1 subgoal):\n 1. valid_graph H \\<and>\n    (\\<forall>v\\<in>nodes H.\n        \\<forall>v'\\<in>nodes H. nodes_connected H v v')", "by auto"], ["", "end"], ["", "context forest\nbegin"], ["", "lemmas delete_edge_valid' = delete_edge_valid[OF valid_graph_axioms]"], ["", "lemma delete_edge_from_path:\n    assumes \"nodes_connected G a b\"\n    assumes \"subgraph H G\"\n    assumes \"\\<not> nodes_connected H a b\"\n    shows \"\\<exists>(x, w, y) \\<in> E - edges H.  (\\<not> nodes_connected (delete_edge x w y G) a b) \\<and>\n      (nodes_connected (add_edge a w' b (delete_edge x w y G)) x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "from assms(1)"], ["proof (chain)\npicking this:\n  nodes_connected G a b", "obtain p where \"is_path_undir G a p b\""], ["proof (prove)\nusing this:\n  nodes_connected G a b\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir G a p b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir G a p b\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "from this assms(3)"], ["proof (chain)\npicking this:\n  is_path_undir G a p b\n  \\<not> nodes_connected H a b", "show ?thesis"], ["proof (prove)\nusing this:\n  is_path_undir G a p b\n  \\<not> nodes_connected H a b\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "proof (induction n == \"length p\" arbitrary: p a b rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          \\<not> nodes_connected H xa xb \\<longrightarrow>\n                          (\\<exists>(x, w, y)\\<in>E - edges H.\n                              \\<not> nodes_connected (delete_edge x w y G)\nxa xb \\<and>\n                              nodes_connected\n                               (add_edge xa w' xb (delete_edge x w y G)) x\n                               y));\n        is_path_undir G a p b; \\<not> nodes_connected H a b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(x, w, y)\\<in>E - edges H.\n                            \\<not> nodes_connected (delete_edge x w y G) a\n                                    b \\<and>\n                            nodes_connected\n                             (add_edge a w' b (delete_edge x w y G)) x y", "case 1"], ["proof (state)\nthis:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            \\<not> nodes_connected H xa xb \\<longrightarrow>\n            (\\<exists>(x, w, y)\\<in>E - edges H.\n                \\<not> nodes_connected (delete_edge x w y G) xa xb \\<and>\n                nodes_connected (add_edge xa w' xb (delete_edge x w y G)) x\n                 y))\n  is_path_undir G a p b\n  \\<not> nodes_connected H a b\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          \\<not> nodes_connected H xa xb \\<longrightarrow>\n                          (\\<exists>(x, w, y)\\<in>E - edges H.\n                              \\<not> nodes_connected (delete_edge x w y G)\nxa xb \\<and>\n                              nodes_connected\n                               (add_edge xa w' xb (delete_edge x w y G)) x\n                               y));\n        is_path_undir G a p b; \\<not> nodes_connected H a b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(x, w, y)\\<in>E - edges H.\n                            \\<not> nodes_connected (delete_edge x w y G) a\n                                    b \\<and>\n                            nodes_connected\n                             (add_edge a w' b (delete_edge x w y G)) x y", "from valid_subgraph[OF assms(2)]"], ["proof (chain)\npicking this:\n  valid_graph H", "have valid_H: \"valid_graph H\""], ["proof (prove)\nusing this:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. valid_graph H", "."], ["proof (state)\nthis:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>\\<forall>m<length p.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa xb.\n                          is_path_undir G xa x xb \\<longrightarrow>\n                          \\<not> nodes_connected H xa xb \\<longrightarrow>\n                          (\\<exists>(x, w, y)\\<in>E - edges H.\n                              \\<not> nodes_connected (delete_edge x w y G)\nxa xb \\<and>\n                              nodes_connected\n                               (add_edge xa w' xb (delete_edge x w y G)) x\n                               y));\n        is_path_undir G a p b; \\<not> nodes_connected H a b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(x, w, y)\\<in>E - edges H.\n                            \\<not> nodes_connected (delete_edge x w y G) a\n                                    b \\<and>\n                            nodes_connected\n                             (add_edge a w' b (delete_edge x w y G)) x y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with 1(2)"], ["proof (chain)\npicking this:\n  is_path_undir G a p b\n  p = []", "have \"a = b\""], ["proof (prove)\nusing this:\n  is_path_undir G a p b\n  p = []\n\ngoal (1 subgoal):\n 1. a = b", "by simp"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with 1(2) assms(2)"], ["proof (chain)\npicking this:\n  is_path_undir G a p b\n  subgraph H G\n  a = b", "have \"is_path_undir H a [] b\""], ["proof (prove)\nusing this:\n  is_path_undir G a p b\n  subgraph H G\n  a = b\n\ngoal (1 subgoal):\n 1. is_path_undir H a [] b", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  is_path_undir G a p b\n  nodes H = V \\<and> edges H \\<subseteq> E\n  a = b\n\ngoal (1 subgoal):\n 1. is_path_undir H a [] b", "by auto"], ["proof (state)\nthis:\n  is_path_undir H a [] b\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with 1(3)"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected H a b\n  is_path_undir H a [] b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected H a b\n  is_path_undir H a [] b\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "by blast"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "case (Cons e p')"], ["proof (state)\nthis:\n  p = e # p'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "obtain a2 a' w where \"e = (a2, w, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a2 w a'.\n        e = (a2, w, a') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod_cases3"], ["proof (prove)\nusing this:\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a2 w a'.\n        e = (a2, w, a') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e = (a2, w, a')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with 1(2) Cons"], ["proof (chain)\npicking this:\n  is_path_undir G a p b\n  p = e # p'\n  e = (a2, w, a')", "have e: \"e = (a, w, a')\""], ["proof (prove)\nusing this:\n  is_path_undir G a p b\n  p = e # p'\n  e = (a2, w, a')\n\ngoal (1 subgoal):\n 1. e = (a, w, a')", "by simp"], ["proof (state)\nthis:\n  e = (a, w, a')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with 1(2) Cons"], ["proof (chain)\npicking this:\n  is_path_undir G a p b\n  p = e # p'\n  e = (a, w, a')", "obtain e1 e2 where e12: \"e = (e1, w, e2) \\<or> e = (e2, w, e1)\" and\n          edge_e12: \"(e1, w, e2) \\<in> E\""], ["proof (prove)\nusing this:\n  is_path_undir G a p b\n  p = e # p'\n  e = (a, w, a')\n\ngoal (1 subgoal):\n 1. (\\<And>e1 e2.\n        \\<lbrakk>e = (e1, w, e2) \\<or> e = (e2, w, e1);\n         (e1, w, e2) \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  (e1, w, e2) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "from 1(2) Cons e"], ["proof (chain)\npicking this:\n  is_path_undir G a p b\n  p = e # p'\n  e = (a, w, a')", "have \"is_path_undir G a' p' b\""], ["proof (prove)\nusing this:\n  is_path_undir G a p b\n  p = e # p'\n  e = (a, w, a')\n\ngoal (1 subgoal):\n 1. is_path_undir G a' p' b", "by simp"], ["proof (state)\nthis:\n  is_path_undir G a' p' b\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with is_path_undir_split_distinct[OF this, of a w a'] Cons"], ["proof (chain)\npicking this:\n  (a, w, a') \\<in> set p' \\<or> (a', w, a) \\<in> set p' \\<Longrightarrow>\n  \\<exists>p'a p'' u u'.\n     is_path_undir G a' p'a u \\<and>\n     is_path_undir G u' p'' b \\<and>\n     length p'a < length p' \\<and>\n     length p'' < length p' \\<and>\n     (u \\<in> {a, a'} \\<and> u' \\<in> {a, a'}) \\<and>\n     (a, w, a') \\<notin> set p'a \\<and>\n     (a', w, a) \\<notin> set p'a \\<and>\n     (a, w, a') \\<notin> set p'' \\<and> (a', w, a) \\<notin> set p''\n  p = e # p'\n  is_path_undir G a' p' b", "obtain p'_dst u' where  p'_dst: \"is_path_undir G u' p'_dst b \\<and> u' \\<in> {a, a'}\" and\n            e_not_in_p': \"(a, w, a') \\<notin> set p'_dst \\<and> (a', w, a) \\<notin> set p'_dst\" and\n            len_p': \"length p'_dst < length p\""], ["proof (prove)\nusing this:\n  (a, w, a') \\<in> set p' \\<or> (a', w, a) \\<in> set p' \\<Longrightarrow>\n  \\<exists>p'a p'' u u'.\n     is_path_undir G a' p'a u \\<and>\n     is_path_undir G u' p'' b \\<and>\n     length p'a < length p' \\<and>\n     length p'' < length p' \\<and>\n     (u \\<in> {a, a'} \\<and> u' \\<in> {a, a'}) \\<and>\n     (a, w, a') \\<notin> set p'a \\<and>\n     (a', w, a) \\<notin> set p'a \\<and>\n     (a, w, a') \\<notin> set p'' \\<and> (a', w, a) \\<notin> set p''\n  p = e # p'\n  is_path_undir G a' p' b\n\ngoal (1 subgoal):\n 1. (\\<And>u' p'_dst.\n        \\<lbrakk>is_path_undir G u' p'_dst b \\<and> u' \\<in> {a, a'};\n         (a, w, a') \\<notin> set p'_dst \\<and>\n         (a', w, a) \\<notin> set p'_dst;\n         length p'_dst < length p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  is_path_undir G u' p'_dst b \\<and> u' \\<in> {a, a'}\n  (a, w, a') \\<notin> set p'_dst \\<and> (a', w, a) \\<notin> set p'_dst\n  length p'_dst < length p\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       \\<exists>(x, w, y)\\<in>E - edges H.\n          \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n          nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "proof (cases \"u' = a'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u' = a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. u' \\<noteq> a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "case False"], ["proof (state)\nthis:\n  u' \\<noteq> a'\n\ngoal (2 subgoals):\n 1. u' = a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. u' \\<noteq> a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with 1 len_p' p'_dst"], ["proof (chain)\npicking this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            \\<not> nodes_connected H xa xb \\<longrightarrow>\n            (\\<exists>(x, w, y)\\<in>E - edges H.\n                \\<not> nodes_connected (delete_edge x w y G) xa xb \\<and>\n                nodes_connected (add_edge xa w' xb (delete_edge x w y G)) x\n                 y))\n  is_path_undir G a p b\n  \\<not> nodes_connected H a b\n  length p'_dst < length p\n  is_path_undir G u' p'_dst b \\<and> u' \\<in> {a, a'}\n  u' \\<noteq> a'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            \\<not> nodes_connected H xa xb \\<longrightarrow>\n            (\\<exists>(x, w, y)\\<in>E - edges H.\n                \\<not> nodes_connected (delete_edge x w y G) xa xb \\<and>\n                nodes_connected (add_edge xa w' xb (delete_edge x w y G)) x\n                 y))\n  is_path_undir G a p b\n  \\<not> nodes_connected H a b\n  length p'_dst < length p\n  is_path_undir G u' p'_dst b \\<and> u' \\<in> {a, a'}\n  u' \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "by auto"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal (1 subgoal):\n 1. u' = a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u' = a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "case True"], ["proof (state)\nthis:\n  u' = a'\n\ngoal (1 subgoal):\n 1. u' = a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with p'_dst"], ["proof (chain)\npicking this:\n  is_path_undir G u' p'_dst b \\<and> u' \\<in> {a, a'}\n  u' = a'", "have path_p': \"is_path_undir G a' p'_dst b\""], ["proof (prove)\nusing this:\n  is_path_undir G u' p'_dst b \\<and> u' \\<in> {a, a'}\n  u' = a'\n\ngoal (1 subgoal):\n 1. is_path_undir G a' p'_dst b", "by auto"], ["proof (state)\nthis:\n  is_path_undir G a' p'_dst b\n\ngoal (1 subgoal):\n 1. u' = a' \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "proof (cases \"(e1, w, e2) \\<in> edges H\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "case True"], ["proof (state)\nthis:\n  (e1, w, e2) \\<in> edges H\n\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "have \"\\<not> nodes_connected H a' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H a' b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected H a' b \\<Longrightarrow> False", "assume \"nodes_connected H a' b\""], ["proof (state)\nthis:\n  nodes_connected H a' b\n\ngoal (1 subgoal):\n 1. nodes_connected H a' b \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  nodes_connected H a' b", "obtain p_H where \"is_path_undir H a' p_H b\""], ["proof (prove)\nusing this:\n  nodes_connected H a' b\n\ngoal (1 subgoal):\n 1. (\\<And>p_H.\n        is_path_undir H a' p_H b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir H a' p_H b\n\ngoal (1 subgoal):\n 1. nodes_connected H a' b \\<Longrightarrow> False", "with True e12 e"], ["proof (chain)\npicking this:\n  (e1, w, e2) \\<in> edges H\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  is_path_undir H a' p_H b", "have \"is_path_undir H a (e#p_H) b\""], ["proof (prove)\nusing this:\n  (e1, w, e2) \\<in> edges H\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  is_path_undir H a' p_H b\n\ngoal (1 subgoal):\n 1. is_path_undir H a (e # p_H) b", "by auto"], ["proof (state)\nthis:\n  is_path_undir H a (e # p_H) b\n\ngoal (1 subgoal):\n 1. nodes_connected H a' b \\<Longrightarrow> False", "with 1(3)"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected H a b\n  is_path_undir H a (e # p_H) b", "show False"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected H a b\n  is_path_undir H a (e # p_H) b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> nodes_connected H a' b\n\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with path_p' 1(1) len_p'"], ["proof (chain)\npicking this:\n  is_path_undir G a' p'_dst b\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            \\<not> nodes_connected H xa xb \\<longrightarrow>\n            (\\<exists>(x, w, y)\\<in>E - edges H.\n                \\<not> nodes_connected (delete_edge x w y G) xa xb \\<and>\n                nodes_connected (add_edge xa w' xb (delete_edge x w y G)) x\n                 y))\n  length p'_dst < length p\n  \\<not> nodes_connected H a' b", "obtain x z y where xy: \"(x, z, y) \\<in> E - edges H\" and\n              IH1: \"(\\<not>nodes_connected (delete_edge x z y G) a' b)\" and\n              IH2: \"(nodes_connected (add_edge a' w' b (delete_edge x z y G)) x y)\""], ["proof (prove)\nusing this:\n  is_path_undir G a' p'_dst b\n  \\<forall>m<length p.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa xb.\n            is_path_undir G xa x xb \\<longrightarrow>\n            \\<not> nodes_connected H xa xb \\<longrightarrow>\n            (\\<exists>(x, w, y)\\<in>E - edges H.\n                \\<not> nodes_connected (delete_edge x w y G) xa xb \\<and>\n                nodes_connected (add_edge xa w' xb (delete_edge x w y G)) x\n                 y))\n  length p'_dst < length p\n  \\<not> nodes_connected H a' b\n\ngoal (1 subgoal):\n 1. (\\<And>x z y.\n        \\<lbrakk>(x, z, y) \\<in> E - edges H;\n         \\<not> nodes_connected (delete_edge x z y G) a' b;\n         nodes_connected (add_edge a' w' b (delete_edge x z y G)) x\n          y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, z, y) \\<in> E - edges H\n  \\<not> nodes_connected (delete_edge x z y G) a' b\n  nodes_connected (add_edge a' w' b (delete_edge x z y G)) x y\n\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with True"], ["proof (chain)\npicking this:\n  (e1, w, e2) \\<in> edges H\n  (x, z, y) \\<in> E - edges H\n  \\<not> nodes_connected (delete_edge x z y G) a' b\n  nodes_connected (add_edge a' w' b (delete_edge x z y G)) x y", "have xy_neq_e: \"(x,z,y) \\<noteq> (e1, w, e2)\""], ["proof (prove)\nusing this:\n  (e1, w, e2) \\<in> edges H\n  (x, z, y) \\<in> E - edges H\n  \\<not> nodes_connected (delete_edge x z y G) a' b\n  nodes_connected (add_edge a' w' b (delete_edge x z y G)) x y\n\ngoal (1 subgoal):\n 1. (x, z, y) \\<noteq> (e1, w, e2)", "by auto"], ["proof (state)\nthis:\n  (x, z, y) \\<noteq> (e1, w, e2)\n\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "have thm1: \"\\<not> nodes_connected (delete_edge x z y G) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected (delete_edge x z y G) a b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge x z y G) a b \\<Longrightarrow> False", "assume \"nodes_connected (delete_edge x z y G) a b\""], ["proof (state)\nthis:\n  nodes_connected (delete_edge x z y G) a b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge x z y G) a b \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  nodes_connected (delete_edge x z y G) a b", "obtain p_e where \"is_path_undir (delete_edge x z y G) a p_e b\""], ["proof (prove)\nusing this:\n  nodes_connected (delete_edge x z y G) a b\n\ngoal (1 subgoal):\n 1. (\\<And>p_e.\n        is_path_undir (delete_edge x z y G) a p_e b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge x z y G) a p_e b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge x z y G) a b \\<Longrightarrow> False", "with edge_e12 e12 e xy_neq_e"], ["proof (chain)\npicking this:\n  (e1, w, e2) \\<in> E\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  (x, z, y) \\<noteq> (e1, w, e2)\n  is_path_undir (delete_edge x z y G) a p_e b", "have \"is_path_undir (delete_edge x z y G) a' ((a', w, a)#p_e) b\""], ["proof (prove)\nusing this:\n  (e1, w, e2) \\<in> E\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  (x, z, y) \\<noteq> (e1, w, e2)\n  is_path_undir (delete_edge x z y G) a p_e b\n\ngoal (1 subgoal):\n 1. is_path_undir (delete_edge x z y G) a' ((a', w, a) # p_e) b", "by auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge x z y G) a' ((a', w, a) # p_e) b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge x z y G) a b \\<Longrightarrow> False", "with IH1"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected (delete_edge x z y G) a' b\n  is_path_undir (delete_edge x z y G) a' ((a', w, a) # p_e) b", "show False"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected (delete_edge x z y G) a' b\n  is_path_undir (delete_edge x z y G) a' ((a', w, a) # p_e) b\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> nodes_connected (delete_edge x z y G) a b\n\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "from IH2"], ["proof (chain)\npicking this:\n  nodes_connected (add_edge a' w' b (delete_edge x z y G)) x y", "obtain p_xy\n              where \"is_path_undir (add_edge a' w' b (delete_edge x z y G)) x p_xy y\""], ["proof (prove)\nusing this:\n  nodes_connected (add_edge a' w' b (delete_edge x z y G)) x y\n\ngoal (1 subgoal):\n 1. (\\<And>p_xy.\n        is_path_undir (add_edge a' w' b (delete_edge x z y G)) x p_xy\n         y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a' w' b (delete_edge x z y G)) x p_xy y\n\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "from valid_graph.swap_add_edge_in_path[OF delete_edge_valid' this, of w a w'] edge_e12\n              e12 e edges_delete_edge[of x z y G] xy_neq_e"], ["proof (chain)\npicking this:\n  (a', w, a) \\<in> edges (delete_edge x z y G) \\<or>\n  (a, w, a') \\<in> edges (delete_edge x z y G) \\<Longrightarrow>\n  nodes_connected (add_edge a w' b (delete_edge x z y G)) x y\n  (e1, w, e2) \\<in> E\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  edges (delete_edge x z y G) = E - {(x, z, y)}\n  (x, z, y) \\<noteq> (e1, w, e2)", "have thm2: \"nodes_connected (add_edge a w' b (delete_edge x z y G)) x y\""], ["proof (prove)\nusing this:\n  (a', w, a) \\<in> edges (delete_edge x z y G) \\<or>\n  (a, w, a') \\<in> edges (delete_edge x z y G) \\<Longrightarrow>\n  nodes_connected (add_edge a w' b (delete_edge x z y G)) x y\n  (e1, w, e2) \\<in> E\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  edges (delete_edge x z y G) = E - {(x, z, y)}\n  (x, z, y) \\<noteq> (e1, w, e2)\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w' b (delete_edge x z y G)) x y", "by blast"], ["proof (state)\nthis:\n  nodes_connected (add_edge a w' b (delete_edge x z y G)) x y\n\ngoal (2 subgoals):\n 1. (e1, w, e2) \\<in> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n 2. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with thm1"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected (delete_edge x z y G) a b\n  nodes_connected (add_edge a w' b (delete_edge x z y G)) x y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected (delete_edge x z y G) a b\n  nodes_connected (add_edge a w' b (delete_edge x z y G)) x y\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "using xy"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected (delete_edge x z y G) a b\n  nodes_connected (add_edge a w' b (delete_edge x z y G)) x y\n  (x, z, y) \\<in> E - edges H\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "by auto"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal (1 subgoal):\n 1. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "case False"], ["proof (state)\nthis:\n  (e1, w, e2) \\<notin> edges H\n\ngoal (1 subgoal):\n 1. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "have thm1: \"\\<not> nodes_connected (delete_edge e1 w e2 G) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected (delete_edge e1 w e2 G) a b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge e1 w e2 G) a b \\<Longrightarrow> False", "assume \"nodes_connected (delete_edge e1 w e2 G) a b\""], ["proof (state)\nthis:\n  nodes_connected (delete_edge e1 w e2 G) a b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge e1 w e2 G) a b \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  nodes_connected (delete_edge e1 w e2 G) a b", "obtain p_e where p_e: \"is_path_undir (delete_edge e1 w e2 G) a p_e b\""], ["proof (prove)\nusing this:\n  nodes_connected (delete_edge e1 w e2 G) a b\n\ngoal (1 subgoal):\n 1. (\\<And>p_e.\n        is_path_undir (delete_edge e1 w e2 G) a p_e b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge e1 w e2 G) a p_e b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge e1 w e2 G) a b \\<Longrightarrow> False", "from delete_edge_is_path[OF path_p', of e1 w e2] e_not_in_p' e12 e"], ["proof (chain)\npicking this:\n  \\<lbrakk>(e1, w, e2) \\<notin> set p'_dst;\n   (e2, w, e1) \\<notin> set p'_dst\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (delete_edge e1 w e2 G) a' p'_dst b\n  (a, w, a') \\<notin> set p'_dst \\<and> (a', w, a) \\<notin> set p'_dst\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')", "have \"is_path_undir (delete_edge e1 w e2 G) a' p'_dst b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(e1, w, e2) \\<notin> set p'_dst;\n   (e2, w, e1) \\<notin> set p'_dst\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (delete_edge e1 w e2 G) a' p'_dst b\n  (a, w, a') \\<notin> set p'_dst \\<and> (a', w, a) \\<notin> set p'_dst\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n\ngoal (1 subgoal):\n 1. is_path_undir (delete_edge e1 w e2 G) a' p'_dst b", "by auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge e1 w e2 G) a' p'_dst b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge e1 w e2 G) a b \\<Longrightarrow> False", "with valid_graph.is_path_undir_sym[OF delete_edge_valid' this]"], ["proof (chain)\npicking this:\n  is_path_undir (delete_edge e1 w e2 G) b\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) p'_dst)) a'\n  is_path_undir (delete_edge e1 w e2 G) a' p'_dst b", "obtain p_rev where \"is_path_undir (delete_edge e1 w e2 G) b p_rev a'\""], ["proof (prove)\nusing this:\n  is_path_undir (delete_edge e1 w e2 G) b\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) p'_dst)) a'\n  is_path_undir (delete_edge e1 w e2 G) a' p'_dst b\n\ngoal (1 subgoal):\n 1. (\\<And>p_rev.\n        is_path_undir (delete_edge e1 w e2 G) b p_rev a' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge e1 w e2 G) b p_rev a'\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge e1 w e2 G) a b \\<Longrightarrow> False", "with p_e valid_graph.is_path_undir_split[OF delete_edge_valid']"], ["proof (chain)\npicking this:\n  is_path_undir (delete_edge e1 w e2 G) a p_e b\n  is_path_undir (delete_edge ?v1 ?e1 ?v'1 G) ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge ?v1 ?e1 ?v'1 G) ?v ?p1.0 u \\<and>\n      is_path_undir (delete_edge ?v1 ?e1 ?v'1 G) u ?p2.0 ?v')\n  is_path_undir (delete_edge e1 w e2 G) b p_rev a'", "have \"is_path_undir (delete_edge e1 w e2 G) a (p_e@p_rev) a'\""], ["proof (prove)\nusing this:\n  is_path_undir (delete_edge e1 w e2 G) a p_e b\n  is_path_undir (delete_edge ?v1 ?e1 ?v'1 G) ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir (delete_edge ?v1 ?e1 ?v'1 G) ?v ?p1.0 u \\<and>\n      is_path_undir (delete_edge ?v1 ?e1 ?v'1 G) u ?p2.0 ?v')\n  is_path_undir (delete_edge e1 w e2 G) b p_rev a'\n\ngoal (1 subgoal):\n 1. is_path_undir (delete_edge e1 w e2 G) a (p_e @ p_rev) a'", "by auto"], ["proof (state)\nthis:\n  is_path_undir (delete_edge e1 w e2 G) a (p_e @ p_rev) a'\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge e1 w e2 G) a b \\<Longrightarrow> False", "with cycle_free edge_e12 e12 e\n                and valid_graph.is_path_undir_sym[OF delete_edge_valid' this]"], ["proof (chain)\npicking this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  (e1, w, e2) \\<in> E\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  is_path_undir (delete_edge e1 w e2 G) a'\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) (p_e @ p_rev))) a\n  is_path_undir (delete_edge e1 w e2 G) a (p_e @ p_rev) a'", "show False"], ["proof (prove)\nusing this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  (e1, w, e2) \\<in> E\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  is_path_undir (delete_edge e1 w e2 G) a'\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) (p_e @ p_rev))) a\n  is_path_undir (delete_edge e1 w e2 G) a (p_e @ p_rev) a'\n\ngoal (1 subgoal):\n 1. False", "unfolding valid_graph_def"], ["proof (prove)\nusing this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  (e1, w, e2) \\<in> E\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  is_path_undir (delete_edge e1 w e2 G) a'\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) (p_e @ p_rev))) a\n  is_path_undir (delete_edge e1 w e2 G) a (p_e @ p_rev) a'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> nodes_connected (delete_edge e1 w e2 G) a b\n\ngoal (1 subgoal):\n 1. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "note ** = delete_edge_is_path[OF path_p', of e1 w e2]"], ["proof (state)\nthis:\n  \\<lbrakk>(e1, w, e2) \\<notin> set p'_dst;\n   (e2, w, e1) \\<notin> set p'_dst\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (delete_edge e1 w e2 G) a' p'_dst b\n\ngoal (1 subgoal):\n 1. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "from valid_graph.is_path_undir_split[OF add_edge_valid[OF delete_edge_valid']]\n              valid_graph.add_edge_is_path[OF delete_edge_valid' **, of a w' b]\n              valid_graph.is_path_undir_simps(2)[OF add_edge_valid[OF delete_edge_valid'],\n                                                 of a w' b e1 w e2 b w' a]\n              e_not_in_p' e12 e"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 (delete_edge ?v2 ?e2 ?v'2 G)) ?v\n   (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 (delete_edge ?v2 ?e2 ?v'2 G)) ?v\n       ?p1.0 u \\<and>\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 (delete_edge ?v2 ?e2 ?v'2 G)) u\n       ?p2.0 ?v')\n  \\<lbrakk>(e1, w, e2) \\<notin> set p'_dst;\n   (e2, w, e1) \\<notin> set p'_dst\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (add_edge a w' b (delete_edge e1 w e2 G))\n                     a' p'_dst b\n  is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) b [(b, w', a)] a =\n  ((b, w', a) \\<in> edges (add_edge a w' b (delete_edge e1 w e2 G)) \\<or>\n   (a, w', b) \\<in> edges (add_edge a w' b (delete_edge e1 w e2 G)))\n  (a, w, a') \\<notin> set p'_dst \\<and> (a', w, a) \\<notin> set p'_dst\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')", "have \"is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) a' (p'_dst@[(b,w',a)]) a\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 (delete_edge ?v2 ?e2 ?v'2 G)) ?v\n   (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 (delete_edge ?v2 ?e2 ?v'2 G)) ?v\n       ?p1.0 u \\<and>\n      is_path_undir (add_edge ?v1 ?e1 ?v'1 (delete_edge ?v2 ?e2 ?v'2 G)) u\n       ?p2.0 ?v')\n  \\<lbrakk>(e1, w, e2) \\<notin> set p'_dst;\n   (e2, w, e1) \\<notin> set p'_dst\\<rbrakk>\n  \\<Longrightarrow> is_path_undir (add_edge a w' b (delete_edge e1 w e2 G))\n                     a' p'_dst b\n  is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) b [(b, w', a)] a =\n  ((b, w', a) \\<in> edges (add_edge a w' b (delete_edge e1 w e2 G)) \\<or>\n   (a, w', b) \\<in> edges (add_edge a w' b (delete_edge e1 w e2 G)))\n  (a, w, a') \\<notin> set p'_dst \\<and> (a', w, a) \\<notin> set p'_dst\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) a'\n     (p'_dst @ [(b, w', a)]) a", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) a'\n   (p'_dst @ [(b, w', a)]) a\n\ngoal (1 subgoal):\n 1. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with valid_graph.is_path_undir_sym[OF add_edge_valid[OF delete_edge_valid'] this]\n              e12 e"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) a\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) (p'_dst @ [(b, w', a)]))) a'\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) a'\n   (p'_dst @ [(b, w', a)]) a", "have \"nodes_connected (add_edge a w' b (delete_edge e1 w e2 G)) e1 e2\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) a\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) (p'_dst @ [(b, w', a)]))) a'\n  e = (e1, w, e2) \\<or> e = (e2, w, e1)\n  e = (a, w, a')\n  is_path_undir (add_edge a w' b (delete_edge e1 w e2 G)) a'\n   (p'_dst @ [(b, w', a)]) a\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w' b (delete_edge e1 w e2 G)) e1 e2", "by blast"], ["proof (state)\nthis:\n  nodes_connected (add_edge a w' b (delete_edge e1 w e2 G)) e1 e2\n\ngoal (1 subgoal):\n 1. (e1, w, e2) \\<notin> edges H \\<Longrightarrow>\n    \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "with thm1"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected (delete_edge e1 w e2 G) a b\n  nodes_connected (add_edge a w' b (delete_edge e1 w e2 G)) e1 e2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected (delete_edge e1 w e2 G) a b\n  nodes_connected (add_edge a w' b (delete_edge e1 w e2 G)) e1 e2\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "using False edge_e12"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected (delete_edge e1 w e2 G) a b\n  nodes_connected (add_edge a w' b (delete_edge e1 w e2 G)) e1 e2\n  (e1, w, e2) \\<notin> edges H\n  (e1, w, e2) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<exists>(x, w, y)\\<in>E - edges H.\n       \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n       nodes_connected (add_edge a w' b (delete_edge x w y G)) x y", "by auto"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(x, w, y)\\<in>E - edges H.\n     \\<not> nodes_connected (delete_edge x w y G) a b \\<and>\n     nodes_connected (add_edge a w' b (delete_edge x w y G)) x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma forest_add_edge:\n    assumes \"a \\<in> V\"\n    assumes \"b \\<in> V\"\n    assumes \"\\<not> nodes_connected G a b\"\n    shows \"forest (add_edge a w b G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forest (add_edge a w b G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. forest (add_edge a w b G)", "from assms(3)"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected G a b", "have \"\\<not> is_path_undir G a [(a, w, b)] b\""], ["proof (prove)\nusing this:\n  \\<not> nodes_connected G a b\n\ngoal (1 subgoal):\n 1. \\<not> is_path_undir G a [(a, w, b)] b", "by blast"], ["proof (state)\nthis:\n  \\<not> is_path_undir G a [(a, w, b)] b\n\ngoal (1 subgoal):\n 1. forest (add_edge a w b G)", "with assms(2)"], ["proof (chain)\npicking this:\n  b \\<in> V\n  \\<not> is_path_undir G a [(a, w, b)] b", "have awb: \"(a, w, b) \\<notin> E \\<and> (b, w, a) \\<notin> E\""], ["proof (prove)\nusing this:\n  b \\<in> V\n  \\<not> is_path_undir G a [(a, w, b)] b\n\ngoal (1 subgoal):\n 1. (a, w, b) \\<notin> E \\<and> (b, w, a) \\<notin> E", "by auto"], ["proof (state)\nthis:\n  (a, w, b) \\<notin> E \\<and> (b, w, a) \\<notin> E\n\ngoal (1 subgoal):\n 1. forest (add_edge a w b G)", "have \"\\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\"\n       if e: \"(v,w',v')\\<in> edges (add_edge a w b G)\" for v w' v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "proof (cases \"(v,w',v') = (a, w, b)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, w', v') = (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\n 2. (v, w', v') \\<noteq> (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "case True"], ["proof (state)\nthis:\n  (v, w', v') = (a, w, b)\n\ngoal (2 subgoals):\n 1. (v, w', v') = (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\n 2. (v, w', v') \\<noteq> (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "with assms awb delete_add_edge[of a G b w]"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  \\<not> nodes_connected G a b\n  (a, w, b) \\<notin> E \\<and> (b, w, a) \\<notin> E\n  \\<lbrakk>a \\<in> V; b \\<in> V; (a, w, b) \\<notin> E\\<rbrakk>\n  \\<Longrightarrow> delete_edge a w b (add_edge a w b G) = G\n  (v, w', v') = (a, w, b)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  \\<not> nodes_connected G a b\n  (a, w, b) \\<notin> E \\<and> (b, w, a) \\<notin> E\n  \\<lbrakk>a \\<in> V; b \\<in> V; (a, w, b) \\<notin> E\\<rbrakk>\n  \\<Longrightarrow> delete_edge a w b (add_edge a w b G) = G\n  (v, w', v') = (a, w, b)\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "by simp"], ["proof (state)\nthis:\n  \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\n\ngoal (1 subgoal):\n 1. (v, w', v') \\<noteq> (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, w', v') \\<noteq> (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "case False"], ["proof (state)\nthis:\n  (v, w', v') \\<noteq> (a, w, b)\n\ngoal (1 subgoal):\n 1. (v, w', v') \\<noteq> (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "with e"], ["proof (chain)\npicking this:\n  (v, w', v') \\<in> edges (add_edge a w b G)\n  (v, w', v') \\<noteq> (a, w, b)", "have e': \"(v,w',v')\\<in> edges G\""], ["proof (prove)\nusing this:\n  (v, w', v') \\<in> edges (add_edge a w b G)\n  (v, w', v') \\<noteq> (a, w, b)\n\ngoal (1 subgoal):\n 1. (v, w', v') \\<in> E", "by auto"], ["proof (state)\nthis:\n  (v, w', v') \\<in> E\n\ngoal (1 subgoal):\n 1. (v, w', v') \\<noteq> (a, w, b) \\<Longrightarrow>\n    \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge v w' v' (add_edge a w b G)) v\n     v' \\<Longrightarrow>\n    False", "assume asm: \"nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\""], ["proof (state)\nthis:\n  nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge v w' v' (add_edge a w b G)) v\n     v' \\<Longrightarrow>\n    False", "with swap_delete_add_edge[OF False, of G]\n          valid_graph.swap_edges[OF delete_edge_valid', of a w b v w' v' v v' w']\n          add_delete_edge[OF e'] cycle_free assms(1,2) e'"], ["proof (chain)\npicking this:\n  delete_edge v w' v' (add_edge a w b G) =\n  add_edge a w b (delete_edge v w' v' G)\n  \\<lbrakk>nodes_connected (add_edge a w b (delete_edge v w' v' G)) v v';\n   a \\<in> nodes (delete_edge v w' v' G);\n   b \\<in> nodes (delete_edge v w' v' G);\n   \\<not> nodes_connected (delete_edge v w' v' G) v v'\\<rbrakk>\n  \\<Longrightarrow> nodes_connected\n                     (add_edge v w' v' (delete_edge v w' v' G)) a b\n  add_edge v w' v' (delete_edge v w' v' G) = G\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  a \\<in> V\n  b \\<in> V\n  (v, w', v') \\<in> E\n  nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'", "have \"nodes_connected G a b\""], ["proof (prove)\nusing this:\n  delete_edge v w' v' (add_edge a w b G) =\n  add_edge a w b (delete_edge v w' v' G)\n  \\<lbrakk>nodes_connected (add_edge a w b (delete_edge v w' v' G)) v v';\n   a \\<in> nodes (delete_edge v w' v' G);\n   b \\<in> nodes (delete_edge v w' v' G);\n   \\<not> nodes_connected (delete_edge v w' v' G) v v'\\<rbrakk>\n  \\<Longrightarrow> nodes_connected\n                     (add_edge v w' v' (delete_edge v w' v' G)) a b\n  add_edge v w' v' (delete_edge v w' v' G) = G\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  a \\<in> V\n  b \\<in> V\n  (v, w', v') \\<in> E\n  nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\n\ngoal (1 subgoal):\n 1. nodes_connected G a b", "by force"], ["proof (state)\nthis:\n  nodes_connected G a b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge v w' v' (add_edge a w b G)) v\n     v' \\<Longrightarrow>\n    False", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  \\<not> nodes_connected G a b\n  nodes_connected G a b", "show False"], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  \\<not> nodes_connected G a b\n  nodes_connected G a b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> nodes_connected (delete_edge v w' v' (add_edge a w b G)) v v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?v, ?w', ?v') \\<in> edges (add_edge a w b G) \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?v ?w' ?v' (add_edge a w b G)) ?v ?v'\n\ngoal (1 subgoal):\n 1. forest (add_edge a w b G)", "with cycle_free add_edge_valid[OF valid_graph_axioms]"], ["proof (chain)\npicking this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  valid_graph (add_edge ?v ?e ?v' G)\n  (?v, ?w', ?v') \\<in> edges (add_edge a w b G) \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?v ?w' ?v' (add_edge a w b G)) ?v ?v'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  valid_graph (add_edge ?v ?e ?v' G)\n  (?v, ?w', ?v') \\<in> edges (add_edge a w b G) \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?v ?w' ?v' (add_edge a w b G)) ?v ?v'\n\ngoal (1 subgoal):\n 1. forest (add_edge a w b G)", "unfolding forest_def forest_axioms_def"], ["proof (prove)\nusing this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  valid_graph (add_edge ?v ?e ?v' G)\n  (?v, ?w', ?v') \\<in> edges (add_edge a w b G) \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?v ?w' ?v' (add_edge a w b G)) ?v ?v'\n\ngoal (1 subgoal):\n 1. valid_graph (add_edge a w b G) \\<and>\n    (\\<forall>(aa, wa, ba)\\<in>edges (add_edge a w b G).\n        \\<not> nodes_connected (delete_edge aa wa ba (add_edge a w b G)) aa\n                ba)", "by auto"], ["proof (state)\nthis:\n  forest (add_edge a w b G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma forest_subsets:\n    assumes \"valid_graph H\"\n    assumes \"edges H \\<subseteq> E\"\n    assumes \"nodes H \\<subseteq> V\"\n    shows \"forest H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forest H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. forest H", "have \"\\<not> nodes_connected (delete_edge a w b H) a b\"\n      if e: \"(a, w, b)\\<in>edges H\" for a w b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected (delete_edge a w b H) a b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) a b \\<Longrightarrow> False", "assume asm: \"nodes_connected (delete_edge a w b H) a b\""], ["proof (state)\nthis:\n  nodes_connected (delete_edge a w b H) a b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) a b \\<Longrightarrow> False", "from \\<open>edges H \\<subseteq> E\\<close>"], ["proof (chain)\npicking this:\n  edges H \\<subseteq> E", "have edges: \"edges (delete_edge a w b H) \\<subseteq> edges (delete_edge a w b G)\""], ["proof (prove)\nusing this:\n  edges H \\<subseteq> E\n\ngoal (1 subgoal):\n 1. edges (delete_edge a w b H) \\<subseteq> edges (delete_edge a w b G)", "by auto"], ["proof (state)\nthis:\n  edges (delete_edge a w b H) \\<subseteq> edges (delete_edge a w b G)\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) a b \\<Longrightarrow> False", "from \\<open>nodes H \\<subseteq> V\\<close>"], ["proof (chain)\npicking this:\n  nodes H \\<subseteq> V", "have nodes: \"nodes (delete_edge a w b H) \\<subseteq> nodes (delete_edge a w b G)\""], ["proof (prove)\nusing this:\n  nodes H \\<subseteq> V\n\ngoal (1 subgoal):\n 1. nodes (delete_edge a w b H) \\<subseteq> nodes (delete_edge a w b G)", "by auto"], ["proof (state)\nthis:\n  nodes (delete_edge a w b H) \\<subseteq> nodes (delete_edge a w b G)\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) a b \\<Longrightarrow> False", "from asm valid_graph.subset_was_path[OF delete_edge_valid' _ edges nodes]"], ["proof (chain)\npicking this:\n  nodes_connected (delete_edge a w b H) a b\n  is_path_undir (delete_edge a w b H) ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (delete_edge a w b G) ?x ?p ?y", "have \"nodes_connected (delete_edge a w b G) a b\""], ["proof (prove)\nusing this:\n  nodes_connected (delete_edge a w b H) a b\n  is_path_undir (delete_edge a w b H) ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (delete_edge a w b G) ?x ?p ?y\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b G) a b", "by auto"], ["proof (state)\nthis:\n  nodes_connected (delete_edge a w b G) a b\n\ngoal (1 subgoal):\n 1. nodes_connected (delete_edge a w b H) a b \\<Longrightarrow> False", "with cycle_free e \\<open>edges H \\<subseteq> E\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  (a, w, b) \\<in> edges H\n  edges H \\<subseteq> E\n  nodes_connected (delete_edge a w b G) a b", "show False"], ["proof (prove)\nusing this:\n  \\<forall>(a, w, b)\\<in>E. \\<not> nodes_connected (delete_edge a w b G) a b\n  (a, w, b) \\<in> edges H\n  edges H \\<subseteq> E\n  nodes_connected (delete_edge a w b G) a b\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?a, ?w, ?b) \\<in> edges H \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?a ?w ?b H) ?a ?b\n\ngoal (1 subgoal):\n 1. forest H", "with assms(1)"], ["proof (chain)\npicking this:\n  valid_graph H\n  (?a, ?w, ?b) \\<in> edges H \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?a ?w ?b H) ?a ?b", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_graph H\n  (?a, ?w, ?b) \\<in> edges H \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?a ?w ?b H) ?a ?b\n\ngoal (1 subgoal):\n 1. forest H", "unfolding forest_def forest_axioms_def"], ["proof (prove)\nusing this:\n  valid_graph H\n  (?a, ?w, ?b) \\<in> edges H \\<Longrightarrow>\n  \\<not> nodes_connected (delete_edge ?a ?w ?b H) ?a ?b\n\ngoal (1 subgoal):\n 1. valid_graph H \\<and>\n    (\\<forall>(a, w, b)\\<in>edges H.\n        \\<not> nodes_connected (delete_edge a w b H) a b)", "by auto"], ["proof (state)\nthis:\n  forest H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subgraph_forest:\n    assumes \"subgraph H G\"\n    shows \"forest H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forest H", "using assms forest_subsets valid_subgraph"], ["proof (prove)\nusing this:\n  subgraph H G\n  \\<lbrakk>valid_graph ?H; edges ?H \\<subseteq> E;\n   nodes ?H \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> forest ?H\n  subgraph ?H G \\<Longrightarrow> valid_graph ?H\n\ngoal (1 subgoal):\n 1. forest H", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n  \\<lbrakk>valid_graph ?H; edges ?H \\<subseteq> E;\n   nodes ?H \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> forest ?H\n  nodes ?H = V \\<and> edges ?H \\<subseteq> E \\<Longrightarrow>\n  valid_graph ?H\n\ngoal (1 subgoal):\n 1. forest H", "by simp"], ["", "lemma forest_delete_edge: \"forest (delete_edge a w c G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forest (delete_edge a w c G)", "using forest_subsets[OF delete_edge_valid']"], ["proof (prove)\nusing this:\n  \\<lbrakk>edges (delete_edge ?v1 ?e1 ?v'1 G) \\<subseteq> E;\n   nodes (delete_edge ?v1 ?e1 ?v'1 G) \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> forest (delete_edge ?v1 ?e1 ?v'1 G)\n\ngoal (1 subgoal):\n 1. forest (delete_edge a w c G)", "unfolding delete_edge_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>edges \\<lparr>nodes = V, edges = E - {(?v1, ?e1, ?v'1)}\\<rparr>\n           \\<subseteq> E;\n   nodes \\<lparr>nodes = V, edges = E - {(?v1, ?e1, ?v'1)}\\<rparr>\n   \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> forest\n                     \\<lparr>nodes = V,\n                        edges = E - {(?v1, ?e1, ?v'1)}\\<rparr>\n\ngoal (1 subgoal):\n 1. forest \\<lparr>nodes = V, edges = E - {(a, w, c)}\\<rparr>", "by auto"], ["", "lemma forest_delete_node: \"forest (delete_node n G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forest (delete_node n G)", "using forest_subsets[OF delete_node_valid[OF valid_graph_axioms]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>edges (delete_node ?v1 G) \\<subseteq> E;\n   nodes (delete_node ?v1 G) \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> forest (delete_node ?v1 G)\n\ngoal (1 subgoal):\n 1. forest (delete_node n G)", "unfolding delete_node_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>edges\n            \\<lparr>nodes = V - {?v1},\n               edges =\n                 E \\<inter> (- {?v1}) \\<times> UNIV \\<times> - {?v1}\\<rparr>\n           \\<subseteq> E;\n   nodes\n    \\<lparr>nodes = V - {?v1},\n       edges = E \\<inter> (- {?v1}) \\<times> UNIV \\<times> - {?v1}\\<rparr>\n   \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> forest\n                     \\<lparr>nodes = V - {?v1},\n                        edges =\n                          E \\<inter>\n                          (- {?v1}) \\<times> UNIV \\<times> - {?v1}\\<rparr>\n\ngoal (1 subgoal):\n 1. forest\n     \\<lparr>nodes = V - {n},\n        edges = E \\<inter> (- {n}) \\<times> UNIV \\<times> - {n}\\<rparr>", "by auto"], ["", "end"], ["", "context finite_graph\nbegin"], ["", "lemma finite_subgraphs: \"finite {T. subgraph T G}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {T. subgraph T G}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {T. subgraph T G}", "from finite_E"], ["proof (chain)\npicking this:\n  finite E", "have \"finite {E'. E' \\<subseteq> E}\""], ["proof (prove)\nusing this:\n  finite E\n\ngoal (1 subgoal):\n 1. finite {E'. E' \\<subseteq> E}", "by simp"], ["proof (state)\nthis:\n  finite {E'. E' \\<subseteq> E}\n\ngoal (1 subgoal):\n 1. finite {T. subgraph T G}", "then"], ["proof (chain)\npicking this:\n  finite {E'. E' \\<subseteq> E}", "have \"finite {\\<lparr>nodes = V, edges = E'\\<rparr>| E'. E' \\<subseteq> E}\""], ["proof (prove)\nusing this:\n  finite {E'. E' \\<subseteq> E}\n\ngoal (1 subgoal):\n 1. finite {\\<lparr>nodes = V, edges = E'\\<rparr> |E'. E' \\<subseteq> E}", "by simp"], ["proof (state)\nthis:\n  finite {\\<lparr>nodes = V, edges = E'\\<rparr> |E'. E' \\<subseteq> E}\n\ngoal (1 subgoal):\n 1. finite {T. subgraph T G}", "also"], ["proof (state)\nthis:\n  finite {\\<lparr>nodes = V, edges = E'\\<rparr> |E'. E' \\<subseteq> E}\n\ngoal (1 subgoal):\n 1. finite {T. subgraph T G}", "have \"{\\<lparr>nodes = V, edges = E'\\<rparr>| E'. E' \\<subseteq> E} = {T. subgraph T G}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lparr>nodes = V, edges = E'\\<rparr> |E'. E' \\<subseteq> E} =\n    {T. subgraph T G}", "unfolding subgraph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lparr>nodes = V, edges = E'\\<rparr> |E'. E' \\<subseteq> E} =\n    {T. nodes T = V \\<and> edges T \\<subseteq> E}", "by (metis (mono_tags, lifting) old.unit.exhaust select_convs(1) select_convs(2) surjective)"], ["proof (state)\nthis:\n  {\\<lparr>nodes = V, edges = E'\\<rparr> |E'. E' \\<subseteq> E} =\n  {T. subgraph T G}\n\ngoal (1 subgoal):\n 1. finite {T. subgraph T G}", "finally"], ["proof (chain)\npicking this:\n  finite {T. subgraph T G}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {T. subgraph T G}\n\ngoal (1 subgoal):\n 1. finite {T. subgraph T G}", "."], ["proof (state)\nthis:\n  finite {T. subgraph T G}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma minimum_spanning_forest_impl_tree:\n  assumes \"minimum_spanning_forest F G\"\n  assumes valid_G: \"valid_graph G\"\n  assumes \"connected_graph F\"\n  shows \"minimum_spanning_tree F G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum_spanning_tree F G", "using assms valid_graph.connected_impl_maximally_connected[OF valid_G]"], ["proof (prove)\nusing this:\n  minimum_spanning_forest F G\n  valid_graph G\n  connected_graph F\n  \\<lbrakk>connected_graph ?H; subgraph ?H G\\<rbrakk>\n  \\<Longrightarrow> maximally_connected ?H G\n\ngoal (1 subgoal):\n 1. minimum_spanning_tree F G", "unfolding minimum_spanning_forest_def minimum_spanning_tree_def\n    spanning_forest_def spanning_tree_def tree_def\n    optimal_forest_def optimal_tree_def"], ["proof (prove)\nusing this:\n  (forest F \\<and> maximally_connected F G \\<and> subgraph F G) \\<and>\n  (\\<forall>F'.\n      forest F' \\<and>\n      maximally_connected F' G \\<and> subgraph F' G \\<longrightarrow>\n      edge_weight F \\<le> edge_weight F')\n  valid_graph G\n  connected_graph F\n  \\<lbrakk>connected_graph ?H; subgraph ?H G\\<rbrakk>\n  \\<Longrightarrow> maximally_connected ?H G\n\ngoal (1 subgoal):\n 1. ((forest F \\<and> connected_graph F) \\<and> subgraph F G) \\<and>\n    (\\<forall>F'.\n        (forest F' \\<and> connected_graph F') \\<and>\n        subgraph F' G \\<longrightarrow>\n        edge_weight F \\<le> edge_weight F')", "by auto"], ["", "lemma minimum_spanning_forest_impl_tree2:\n  assumes \"minimum_spanning_forest F G\"\n  assumes connected_G: \"connected_graph G\"\n  shows \"minimum_spanning_tree F G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum_spanning_tree F G", "using assms connected_graph.maximally_connected_impl_connected[OF connected_G]\n    minimum_spanning_forest_impl_tree connected_graph.axioms(1)[OF connected_G]"], ["proof (prove)\nusing this:\n  minimum_spanning_forest F G\n  connected_graph G\n  \\<lbrakk>maximally_connected ?H G; subgraph ?H G\\<rbrakk>\n  \\<Longrightarrow> connected_graph ?H\n  \\<lbrakk>minimum_spanning_forest ?F ?G; valid_graph ?G;\n   connected_graph ?F\\<rbrakk>\n  \\<Longrightarrow> minimum_spanning_tree ?F ?G\n  valid_graph G\n\ngoal (1 subgoal):\n 1. minimum_spanning_tree F G", "unfolding minimum_spanning_forest_def spanning_forest_def"], ["proof (prove)\nusing this:\n  (forest F \\<and> maximally_connected F G \\<and> subgraph F G) \\<and>\n  optimal_forest F G\n  connected_graph G\n  \\<lbrakk>maximally_connected ?H G; subgraph ?H G\\<rbrakk>\n  \\<Longrightarrow> connected_graph ?H\n  \\<lbrakk>(forest ?F \\<and>\n            maximally_connected ?F ?G \\<and> subgraph ?F ?G) \\<and>\n           optimal_forest ?F ?G;\n   valid_graph ?G; connected_graph ?F\\<rbrakk>\n  \\<Longrightarrow> minimum_spanning_tree ?F ?G\n  valid_graph G\n\ngoal (1 subgoal):\n 1. minimum_spanning_tree F G", "by auto"], ["", "end"]]}