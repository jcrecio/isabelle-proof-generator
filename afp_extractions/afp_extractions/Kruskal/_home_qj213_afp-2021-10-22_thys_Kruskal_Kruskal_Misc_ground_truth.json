{"file_name": "/home/qj213/afp-2021-10-22/thys/Kruskal/Kruskal_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kruskal", "problem_names": ["lemma card2_get2: assumes \"card x = 2\"\n  obtains a b where  \"x = {a, b}\" \"a \\<noteq> b\"", "lemma equiv_sym: \"equiv V R \\<Longrightarrow> (x,y)\\<in>R \\<Longrightarrow> (y,x)\\<in>R\"", "lemma equiv_trans: \"equiv V R \\<Longrightarrow> (x,y)\\<in>R \\<Longrightarrow> (y,z)\\<in>R \\<Longrightarrow> (x,z)\\<in>R\"", "lemma equiv_trans_sym: \n  \"\\<lbrakk> equiv V R; (a,b)\\<in>R; (c,b)\\<in>R \\<rbrakk> \\<Longrightarrow> (a,c)\\<in>R\"\n  \"\\<lbrakk> equiv V R; (a,b)\\<in>R; (a,c)\\<in>R \\<rbrakk> \\<Longrightarrow> (b,c)\\<in>R\"", "lemma union_equiv: \n  \"equiv V R \\<Longrightarrow> equiv V (per_union R a b)\"", "lemma equiv_mono: \"E'\\<subseteq>E \\<Longrightarrow> equiv E R1 \\<Longrightarrow> equiv E' (R1 \\<inter> E'\\<times>E')\"", "lemma unify2EquivClasses_alt: \n  assumes \"R``{x} \\<noteq> R``{y}\" and inV: \"y\\<in>V\" \"x\\<in>V\" and \"R\\<subseteq>V\\<times>V\"    \n   and eq: \"equiv V R\" and [simp]: \"finite V\"\n  shows \"Suc (card (quotient V (per_union R x y))) = card (quotient V R)\"", "lemma fixes f::\"'c\\<Rightarrow>'d\"\n    and g ::\"'c\\<Rightarrow>'d\"\n    assumes \"finite A\" and k: \"\\<And>a b. a\\<in>A \\<Longrightarrow> b\\<in>A \\<Longrightarrow> f a = f b \\<Longrightarrow> g a = g b\"\n    shows  coarser: \"card (f ` A) \\<ge> card (g ` A)\"", "lemma max_node_impl[code]: \"max_node l = fold (\\<lambda>(u,_,w) x. max u (max w x)) l 0\"", "lemma edges_less_eq_linorder: \"is_linorder_rel edges_less_eq\"", "lemma sort_edges_correct: \"sorted_wrt edges_less_eq (quicksort_by_rel edges_less_eq [] l)\"", "lemma distinct_mset_eq:\"distinct a \\<Longrightarrow> mset a = mset b \\<Longrightarrow> distinct b\"", "lemma quicksort_by_rel_distinct: \"distinct l \\<Longrightarrow> distinct (quicksort_by_rel edges_less_eq [] l)\"", "lemma map_in_list_rel_conv: \n  shows \"(l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel \\<longleftrightarrow> ((\\<forall>x\\<in>set l. I x) \\<and> l'=map \\<alpha> l)\"", "lemma list_relD: \"(x, y) \\<in> \\<langle>br a I\\<rangle>list_rel \\<Longrightarrow> y = map a x\"", "lemma list_relD2: \"(x, y) \\<in> \\<langle>br a I\\<rangle>list_rel \\<Longrightarrow> y = map a x \\<and> (\\<forall>x\\<in>set x. I x)\"", "lemma list_set_rel_append: \"(x,s)\\<in>br a I \\<Longrightarrow> (xs,S)\\<in>\\<langle>br a I\\<rangle>list_set_rel \\<Longrightarrow> s\\<notin>S\n     \\<Longrightarrow> (xs@[x],insert s S)\\<in>\\<langle>br a I\\<rangle>list_set_rel\"", "lemma pure_fold: \"(\\<lambda>a c. \\<up> (c = a)) = pure Id\"", "lemma list_assn_emp: \"list_assn id_assn L L = emp\""], "translations": [["", "lemma card2_get2: assumes \"card x = 2\"\n  obtains a b where  \"x = {a, b}\" \"a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = {a, b}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = {a, b}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  card x = 2", "have [simp,intro!]: \"finite x\""], ["proof (prove)\nusing this:\n  card x = 2\n\ngoal (1 subgoal):\n 1. finite x", "apply(rule_tac ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>card x = 2; infinite x\\<rbrakk> \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  finite x\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = {a, b}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  card x = 2", "obtain a where ax: \"a \\<in> x\""], ["proof (prove)\nusing this:\n  card x = 2\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> x\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = {a, b}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  card x = 2\n  a \\<in> x", "have \"card (x - {a}) = 1\""], ["proof (prove)\nusing this:\n  card x = 2\n  a \\<in> x\n\ngoal (1 subgoal):\n 1. card (x - {a}) = 1", "by fastforce"], ["proof (state)\nthis:\n  card (x - {a}) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = {a, b}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  card (x - {a}) = 1", "obtain b where \"x - {a} = {b}\" \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  card (x - {a}) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>x - {a} = {b}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Diff_cancel Diff_idemp card_1_singletonE insert_not_empty)"], ["proof (state)\nthis:\n  x - {a} = {b}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = {a, b}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that ax"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = {?a, ?b}; ?a \\<noteq> ?b\\<rbrakk> \\<Longrightarrow> thesis\n  a \\<in> x\n  x - {a} = {b}\n  a \\<noteq> b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = {?a, ?b}; ?a \\<noteq> ?b\\<rbrakk> \\<Longrightarrow> thesis\n  a \\<in> x\n  x - {a} = {b}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Lemmas on equivalence relations\""], ["", "lemma equiv_sym: \"equiv V R \\<Longrightarrow> (x,y)\\<in>R \\<Longrightarrow> (y,x)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv V R; (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (y, x) \\<in> R", "by (metis equiv_def symD)"], ["", "lemma equiv_trans: \"equiv V R \\<Longrightarrow> (x,y)\\<in>R \\<Longrightarrow> (y,z)\\<in>R \\<Longrightarrow> (x,z)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv V R; (x, y) \\<in> R; (y, z) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (x, z) \\<in> R", "by (metis equiv_def transD)"], ["", "lemma equiv_trans_sym: \n  \"\\<lbrakk> equiv V R; (a,b)\\<in>R; (c,b)\\<in>R \\<rbrakk> \\<Longrightarrow> (a,c)\\<in>R\"\n  \"\\<lbrakk> equiv V R; (a,b)\\<in>R; (a,c)\\<in>R \\<rbrakk> \\<Longrightarrow> (b,c)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>equiv V R; (a, b) \\<in> R; (c, b) \\<in> R\\<rbrakk>\n     \\<Longrightarrow> (a, c) \\<in> R) &&&\n    (\\<lbrakk>equiv V R; (a, b) \\<in> R; (a, c) \\<in> R\\<rbrakk>\n     \\<Longrightarrow> (b, c) \\<in> R)", "apply (metis equiv_sym equiv_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma union_equiv: \n  \"equiv V R \\<Longrightarrow> equiv V (per_union R a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv V R \\<Longrightarrow> equiv V (per_union R a b)", "apply (rule equivI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. equiv V R \\<Longrightarrow> refl_on V (per_union R a b)\n 2. equiv V R \\<Longrightarrow> sym (per_union R a b)\n 3. equiv V R \\<Longrightarrow> trans (per_union R a b)", "unfolding per_union_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. equiv V R \\<Longrightarrow>\n    refl_on V\n     (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n      {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})\n 2. equiv V R \\<Longrightarrow>\n    sym (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n         {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})\n 3. equiv V R \\<Longrightarrow>\n    trans\n     (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n      {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv V R \\<Longrightarrow>\n    refl_on V\n     (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n      {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})", "unfolding equiv_def refl_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (R \\<subseteq> V \\<times> V \\<and>\n     (\\<forall>x\\<in>V. (x, x) \\<in> R)) \\<and>\n    sym R \\<and> trans R \\<Longrightarrow>\n    R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n    {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R}\n    \\<subseteq> V \\<times> V \\<and>\n    (\\<forall>x\\<in>V.\n        (x, x)\n        \\<in> R \\<union>\n              {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n              {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. equiv V R \\<Longrightarrow>\n    sym (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n         {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})\n 2. equiv V R \\<Longrightarrow>\n    trans\n     (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n      {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv V R \\<Longrightarrow>\n    sym (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n         {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})", "apply (rule symI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>equiv V R;\n        (aa, ba)\n        \\<in> R \\<union>\n              {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n              {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> (ba, aa)\n                         \\<in> R \\<union>\n                               {(x, y).\n                                (x, a) \\<in> R \\<and>\n                                (y, b) \\<in> R} \\<union>\n                               {(y, x).\n                                (x, a) \\<in> R \\<and> (y, b) \\<in> R}", "by (auto dest: equiv_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv V R \\<Longrightarrow>\n    trans\n     (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n      {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv V R \\<Longrightarrow>\n    trans\n     (R \\<union> {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n      {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R})", "apply (rule transI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>equiv V R;\n        (x, y)\n        \\<in> R \\<union>\n              {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n              {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R};\n        (y, z)\n        \\<in> R \\<union>\n              {(x, y). (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n              {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> (x, z)\n                         \\<in> R \\<union>\n                               {(x, y).\n                                (x, a) \\<in> R \\<and>\n                                (y, b) \\<in> R} \\<union>\n                               {(y, x).\n                                (x, a) \\<in> R \\<and> (y, b) \\<in> R}", "by (auto dest: equiv_trans equiv_trans_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma equiv_mono: \"E'\\<subseteq>E \\<Longrightarrow> equiv E R1 \\<Longrightarrow> equiv E' (R1 \\<inter> E'\\<times>E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> equiv E' (Restr R1 E')", "apply(rule equivI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> refl_on E' (Restr R1 E')\n 2. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> sym (Restr R1 E')\n 3. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> trans (Restr R1 E')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> refl_on E' (Restr R1 E')", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E;\n     refl_on E R1 \\<and> sym R1 \\<and> trans R1\\<rbrakk>\n    \\<Longrightarrow> refl_on E' (Restr R1 E')", "by (simp add: refl_on_def subset_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> sym (Restr R1 E')\n 2. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> trans (Restr R1 E')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> sym (Restr R1 E')", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E;\n     refl_on E R1 \\<and> sym R1 \\<and> trans R1\\<rbrakk>\n    \\<Longrightarrow> sym (Restr R1 E')", "by (metis mem_Sigma_iff symI sym_Int)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> trans (Restr R1 E')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E; equiv E R1\\<rbrakk>\n    \\<Longrightarrow> trans (Restr R1 E')", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E;\n     refl_on E R1 \\<and> sym R1 \\<and> trans R1\\<rbrakk>\n    \\<Longrightarrow> trans (Restr R1 E')", "using trans_Restr"], ["proof (prove)\nusing this:\n  trans ?r \\<Longrightarrow> trans (Restr ?r ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E;\n     refl_on E R1 \\<and> sym R1 \\<and> trans R1\\<rbrakk>\n    \\<Longrightarrow> trans (Restr R1 E')", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unify2EquivClasses_alt: \n  assumes \"R``{x} \\<noteq> R``{y}\" and inV: \"y\\<in>V\" \"x\\<in>V\" and \"R\\<subseteq>V\\<times>V\"    \n   and eq: \"equiv V R\" and [simp]: \"finite V\"\n  shows \"Suc (card (quotient V (per_union R x y))) = card (quotient V R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "from eq"], ["proof (chain)\npicking this:\n  equiv V R", "have Rtrancl: \"R\\<^sup>+ = R\""], ["proof (prove)\nusing this:\n  equiv V R\n\ngoal (1 subgoal):\n 1. R\\<^sup>+ = R", "by (auto elim: equivE)"], ["proof (state)\nthis:\n  R\\<^sup>+ = R\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "from \\<open>equiv V R\\<close>"], ["proof (chain)\npicking this:\n  equiv V R", "have sym: \"sym R\""], ["proof (prove)\nusing this:\n  equiv V R\n\ngoal (1 subgoal):\n 1. sym R", "unfolding equiv_def"], ["proof (prove)\nusing this:\n  refl_on V R \\<and> sym R \\<and> trans R\n\ngoal (1 subgoal):\n 1. sym R", "by auto"], ["proof (state)\nthis:\n  sym R\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "let ?R' = \"per_union R x y\"  \n\n  \\<comment> \\<open> the equivalence classes not contining x and y, stay unchanged when performing @{term per_union} \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<And>z. z \\<in> V \\<Longrightarrow> z \\<notin> R `` {x} \\<Longrightarrow> z \\<notin> R `` {y} \\<Longrightarrow> per_union R x y `` {z} = R `` {z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> V; z \\<notin> R `` {x}; z \\<notin> R `` {y}\\<rbrakk>\n       \\<Longrightarrow> per_union R x y `` {z} = R `` {z}", "using sym"], ["proof (prove)\nusing this:\n  sym R\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> V; z \\<notin> R `` {x}; z \\<notin> R `` {y}\\<rbrakk>\n       \\<Longrightarrow> per_union R x y `` {z} = R `` {z}", "by(auto simp: sym_def per_union_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?z \\<in> V; ?z \\<notin> R `` {x}; ?z \\<notin> R `` {y}\\<rbrakk>\n  \\<Longrightarrow> per_union R x y `` {?z} = R `` {?z}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?z \\<in> V; ?z \\<notin> R `` {x}; ?z \\<notin> R `` {y}\\<rbrakk>\n  \\<Longrightarrow> per_union R x y `` {?z} = R `` {?z}", "have K: \"(\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {?R'``{x}}) = (\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {R``{x}})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?z \\<in> V; ?z \\<notin> R `` {x}; ?z \\<notin> R `` {y}\\<rbrakk>\n  \\<Longrightarrow> per_union R x y `` {?z} = R `` {?z}\n\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V - R `` {x} - R `` {y}. {per_union R x y `` {xa}}) =\n    (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}. {per_union R x y `` {xa}}) =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have R_respect: \"(\\<lambda>x. {R `` {x}}) respects R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. {R `` {x}}) respects R", "unfolding congruent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(y, z)\\<in>R. {R `` {y}} = {R `` {z}}", "using eq equiv_class_eq_iff"], ["proof (prove)\nusing this:\n  equiv V R\n  equiv ?A ?r \\<Longrightarrow>\n  ((?x, ?y) \\<in> ?r) =\n  (?r `` {?x} = ?r `` {?y} \\<and> ?x \\<in> ?A \\<and> ?y \\<in> ?A)\n\ngoal (1 subgoal):\n 1. \\<forall>(y, z)\\<in>R. {R `` {y}} = {R `` {z}}", "by fastforce+"], ["proof (state)\nthis:\n  (\\<lambda>x. {R `` {x}}) respects R\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have R'_respect: \"(\\<lambda>xa. {?R' `` {xa}}) respects R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. {per_union R x y `` {xa}}) respects R", "unfolding congruent_def per_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(ya, z)\\<in>R.\n       {(R \\<union>\n         {(xa, ya). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R} \\<union>\n         {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}) ``\n        {ya}} =\n       {(R \\<union>\n         {(xa, ya). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R} \\<union>\n         {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}) ``\n        {z}}", "using eq equiv_class_eq_iff"], ["proof (prove)\nusing this:\n  equiv V R\n  equiv ?A ?r \\<Longrightarrow>\n  ((?x, ?y) \\<in> ?r) =\n  (?r `` {?x} = ?r `` {?y} \\<and> ?x \\<in> ?A \\<and> ?y \\<in> ?A)\n\ngoal (1 subgoal):\n 1. \\<forall>(ya, z)\\<in>R.\n       {(R \\<union>\n         {(xa, ya). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R} \\<union>\n         {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}) ``\n        {ya}} =\n       {(R \\<union>\n         {(xa, ya). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R} \\<union>\n         {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}) ``\n        {z}}", "by force+ \n\n  \\<comment> \\<open>some facts about the equivalence class of x, before and after the @{term per_union} operation\\<close>"], ["proof (state)\nthis:\n  (\\<lambda>xa. {per_union R x y `` {xa}}) respects R\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have xdrin: \"(R``{x}) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {x} \\<subseteq> V", "using assms(4)"], ["proof (prove)\nusing this:\n  R \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. R `` {x} \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  R `` {x} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have x1: \"(\\<Union>x \\<in> (R``{x}). {?R'``{x}}) = {?R'``{x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}}) =\n    {per_union R x y `` {x}}", "apply(rule UN_equiv_class)"], ["proof (prove)\ngoal (3 subgoals):\n 1. equiv ?A R\n 2. (\\<lambda>xa. {per_union R x y `` {xa}}) respects R\n 3. x \\<in> ?A", "by fact+"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}}) =\n  {per_union R x y `` {x}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have x2: \"(\\<Union>x \\<in> (R``{x}). {R``{x}}) = {R``{x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>R `` {x}. {R `` {x}}) = {R `` {x}}", "apply(rule UN_equiv_class)"], ["proof (prove)\ngoal (3 subgoals):\n 1. equiv ?A R\n 2. (\\<lambda>x. {R `` {x}}) respects R\n 3. x \\<in> ?A", "by fact+\n      \n  \\<comment> \\<open>some facts about the equivalence class of y, before and after the @{term per_union} operation\\<close>"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>R `` {x}. {R `` {x}}) = {R `` {x}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have ydrin: \"(R``{y}) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {y} \\<subseteq> V", "using assms(4)"], ["proof (prove)\nusing this:\n  R \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. R `` {y} \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  R `` {y} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have y1: \"(\\<Union>x \\<in> (R``{y}). {?R'``{x}}) = {?R'``{y}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) =\n    {per_union R x y `` {y}}", "apply(rule UN_equiv_class)"], ["proof (prove)\ngoal (3 subgoals):\n 1. equiv ?A R\n 2. (\\<lambda>xa. {per_union R x y `` {xa}}) respects R\n 3. y \\<in> ?A", "by fact+"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) =\n  {per_union R x y `` {y}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have y2: \"(\\<Union>x \\<in> (R``{y}). {R``{x}}) = {R``{y}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>R `` {y}. {R `` {x}}) = {R `` {y}}", "apply(rule UN_equiv_class)"], ["proof (prove)\ngoal (3 subgoals):\n 1. equiv ?A R\n 2. (\\<lambda>x. {R `` {x}}) respects R\n 3. y \\<in> ?A", "by fact+"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>R `` {y}. {R `` {x}}) = {R `` {y}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have z: \"(y,x)\\<in>?R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> per_union R x y", "unfolding per_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x)\n    \\<in> R \\<union>\n          {(xa, ya). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R} \\<union>\n          {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}", "using sym sym_def"], ["proof (prove)\nusing this:\n  sym R\n  sym ?r = (\\<forall>x y. (x, y) \\<in> ?r \\<longrightarrow> (y, x) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. (y, x)\n    \\<in> R \\<union>\n          {(xa, ya). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R} \\<union>\n          {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}", "using assms(2) assms(3) eq eq_equiv_class"], ["proof (prove)\nusing this:\n  sym R\n  sym ?r = (\\<forall>x y. (x, y) \\<in> ?r \\<longrightarrow> (y, x) \\<in> ?r)\n  y \\<in> V\n  x \\<in> V\n  equiv V R\n  \\<lbrakk>?r `` {?a} = ?r `` {?b}; equiv ?A ?r; ?b \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> ?r\n\ngoal (1 subgoal):\n 1. (y, x)\n    \\<in> R \\<union>\n          {(xa, ya). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R} \\<union>\n          {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}", "by fastforce"], ["proof (state)\nthis:\n  (y, x) \\<in> per_union R x y\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have bla: \"?R'``{y} = ?R'``{x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. per_union R x y `` {y} = per_union R x y `` {x}", "apply(rule equiv_class_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. equiv ?A (per_union R x y)\n 2. (y, x) \\<in> per_union R x y", "apply(rule union_equiv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. equiv ?A R\n 2. (y, x) \\<in> per_union R x y", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> per_union R x y", "by fact"], ["proof (state)\nthis:\n  per_union R x y `` {y} = per_union R x y `` {x}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "let ?Vm = \"(\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {R``{x}})\"  \n\n  \\<comment> \\<open>now consider the set of quotients wrt. the relation after the @{term per_union}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"quotient V ?R' = (\\<Union>x \\<in> V. {?R'``{x}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V // per_union R x y = (\\<Union>xa\\<in>V. {per_union R x y `` {xa}})", "unfolding quotient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V. {per_union R x y `` {xa}}) =\n    (\\<Union>xa\\<in>V. {per_union R x y `` {xa}})", "by auto"], ["proof (state)\nthis:\n  V // per_union R x y = (\\<Union>xa\\<in>V. {per_union R x y `` {xa}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also  \\<comment> \\<open>decompose it into the quotients for elements equivalent to x, y in R, and the rest\\<close>"], ["proof (state)\nthis:\n  V // per_union R x y = (\\<Union>xa\\<in>V. {per_union R x y `` {xa}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<dots> = (\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {?R'``{x}})\n             \\<union> (\\<Union>x \\<in> (R``{y}). {?R'``{x}}) \\<union> (\\<Union>x \\<in> (R``{x}). {?R'``{x}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V. {per_union R x y `` {xa}}) =\n    (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}})", "using xdrin ydrin"], ["proof (prove)\nusing this:\n  R `` {x} \\<subseteq> V\n  R `` {y} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V. {per_union R x y `` {xa}}) =\n    (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>V. {per_union R x y `` {xa}}) =\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also  \\<comment> \\<open>for the elements equivalent to x and y in R the quotient is \n            the quotient containing x and y respectively \\<close>"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>V. {per_union R x y `` {xa}}) =\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<dots> = (\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {?R'``{x}}) \\<union> {?R'``{y}} \\<union> {?R'``{x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}}) =\n    (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    {per_union R x y `` {y}} \\<union>\n    {per_union R x y `` {x}}", "using x1 y1"], ["proof (prove)\nusing this:\n  (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}}) =\n  {per_union R x y `` {x}}\n  (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) =\n  {per_union R x y `` {y}}\n\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n    (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}}) =\n    (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    {per_union R x y `` {y}} \\<union>\n    {per_union R x y `` {x}}", "by auto"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}}) =\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  {per_union R x y `` {y}} \\<union>\n  {per_union R x y `` {x}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also  \\<comment> \\<open>which is after uniting them, the same quotient \\<close>"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {y}. {per_union R x y `` {xa}}) \\<union>\n  (\\<Union>xa\\<in>R `` {x}. {per_union R x y `` {xa}}) =\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  {per_union R x y `` {y}} \\<union>\n  {per_union R x y `` {x}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<dots> = (\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {R``{x}}) \\<union> {?R'``{y}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    {per_union R x y `` {y}} \\<union>\n    {per_union R x y `` {x}} =\n    (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    {per_union R x y `` {y}}", "using K bla"], ["proof (prove)\nusing this:\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}. {per_union R x y `` {xa}}) =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n  per_union R x y `` {y} = per_union R x y `` {x}\n\ngoal (1 subgoal):\n 1. (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n        {per_union R x y `` {xa}}) \\<union>\n    {per_union R x y `` {y}} \\<union>\n    {per_union R x y `` {x}} =\n    (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    {per_union R x y `` {y}}", "by auto"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  {per_union R x y `` {y}} \\<union>\n  {per_union R x y `` {x}} =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  {per_union R x y `` {y}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also"], ["proof (state)\nthis:\n  (\\<Union>xa\\<in>V - R `` {x} - R `` {y}.\n      {per_union R x y `` {xa}}) \\<union>\n  {per_union R x y `` {y}} \\<union>\n  {per_union R x y `` {x}} =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  {per_union R x y `` {y}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<dots> = insert (?R'``{y}) ?Vm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    {per_union R x y `` {y}} =\n    insert (per_union R x y `` {y})\n     (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  {per_union R x y `` {y}} =\n  insert (per_union R x y `` {y})\n   (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "finally"], ["proof (chain)\npicking this:\n  V // per_union R x y =\n  insert (per_union R x y `` {y})\n   (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "have leftside: \"quotient V ?R' = insert (?R'``{y}) ?Vm\""], ["proof (prove)\nusing this:\n  V // per_union R x y =\n  insert (per_union R x y `` {y})\n   (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. V // per_union R x y =\n    insert (per_union R x y `` {y})\n     (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "."], ["proof (state)\nthis:\n  V // per_union R x y =\n  insert (per_union R x y `` {y})\n   (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have notin: \"?R'``{y} \\<notin> ?Vm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. per_union R x y `` {y}\n    \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "apply (auto simp: per_union_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> V; (y, xa) \\<notin> R; (x, xa) \\<notin> R;\n        (R \\<union>\n         {xa. (xa, x) \\<in> R} \\<times> {ya. (ya, y) \\<in> R} \\<union>\n         {(ya, xa). (xa, x) \\<in> R \\<and> (ya, y) \\<in> R}) ``\n        {y} =\n        R `` {xa}\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis (no_types, lifting) Image_singleton_iff UnI1 assms(2) eq equiv_class_self local.sym symE)"], ["proof (state)\nthis:\n  per_union R x y `` {y}\n  \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have o: \"card (quotient V ?R') = Suc (card ?Vm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (V // per_union R x y) =\n    Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))", "unfolding leftside"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (insert (per_union R x y `` {y})\n       (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})) =\n    Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))", "apply(rule card_insert_disjoint)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n 2. per_union R x y `` {y}\n    \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "using notin"], ["proof (prove)\nusing this:\n  per_union R x y `` {y}\n  \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (2 subgoals):\n 1. finite (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n 2. per_union R x y `` {y}\n    \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "by auto\n      \n  \\<comment> \\<open>now consider the set of quotients wrt. the relation before the @{term per_union}\\<close>"], ["proof (state)\nthis:\n  card (V // per_union R x y) =\n  Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"quotient V R = (\\<Union>x \\<in> V. {R``{x}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V // R = (\\<Union>x\\<in>V. {R `` {x}})", "unfolding quotient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>V. {R `` {x}}) = (\\<Union>x\\<in>V. {R `` {x}})", "by auto"], ["proof (state)\nthis:\n  V // R = (\\<Union>x\\<in>V. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also \\<comment> \\<open>decompose it into the quotients for elements equivalent to x, y in R, and the rest\\<close>"], ["proof (state)\nthis:\n  V // R = (\\<Union>x\\<in>V. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<dots> = (\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {R``{x}})\n           \\<union> (\\<Union>x \\<in> (R``{y}). {R``{x}}) \\<union> (\\<Union>x \\<in> (R``{x}). {R``{x}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>V. {R `` {x}}) =\n    (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {x}. {R `` {x}})", "using xdrin ydrin"], ["proof (prove)\nusing this:\n  R `` {x} \\<subseteq> V\n  R `` {y} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>V. {R `` {x}}) =\n    (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {x}. {R `` {x}})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>V. {R `` {x}}) =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {x}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also \\<comment> \\<open>for the elements equivalent to x and y in R the quotient is \n            the quotient containing x and y respectively \\<close>"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>V. {R `` {x}}) =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {x}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<dots> = (\\<Union>x \\<in> (V-(R``{x})-(R``{y})). {R``{x}}) \\<union> {R``{y}} \\<union> {R``{x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {x}. {R `` {x}}) =\n    (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    {R `` {y}} \\<union>\n    {R `` {x}}", "using x2 y2"], ["proof (prove)\nusing this:\n  (\\<Union>x\\<in>R `` {x}. {R `` {x}}) = {R `` {x}}\n  (\\<Union>x\\<in>R `` {y}. {R `` {x}}) = {R `` {y}}\n\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n    (\\<Union>x\\<in>R `` {x}. {R `` {x}}) =\n    (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    {R `` {y}} \\<union>\n    {R `` {x}}", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {x}. {R `` {x}}) =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  {R `` {y}} \\<union>\n  {R `` {x}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also \\<comment> \\<open> these are two distinct quotients  \\<close>"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {y}. {R `` {x}}) \\<union>\n  (\\<Union>x\\<in>R `` {x}. {R `` {x}}) =\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  {R `` {y}} \\<union>\n  {R `` {x}}\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"\\<dots> = insert (R``{y}) (insert (R``{x}) ?Vm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n    {R `` {y}} \\<union>\n    {R `` {x}} =\n    insert (R `` {y})\n     (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}) \\<union>\n  {R `` {y}} \\<union>\n  {R `` {x}} =\n  insert (R `` {y})\n   (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "finally"], ["proof (chain)\npicking this:\n  V // R =\n  insert (R `` {y})\n   (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))", "have ii: \"quotient V R = insert (R``{y}) (insert (R``{x}) ?Vm)\""], ["proof (prove)\nusing this:\n  V // R =\n  insert (R `` {y})\n   (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))\n\ngoal (1 subgoal):\n 1. V // R =\n    insert (R `` {y})\n     (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))", "."], ["proof (state)\nthis:\n  V // R =\n  insert (R `` {y})\n   (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"R``{x} \\<notin> ?Vm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {x} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "using eq equiv_class_self"], ["proof (prove)\nusing this:\n  equiv V R\n  \\<lbrakk>equiv ?A ?r; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> ?r `` {?a}\n\ngoal (1 subgoal):\n 1. R `` {x} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "by fastforce"], ["proof (state)\nthis:\n  R `` {x} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"R``{y} \\<notin> ?Vm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {y} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "using eq equiv_class_self"], ["proof (prove)\nusing this:\n  equiv V R\n  \\<lbrakk>equiv ?A ?r; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> ?r `` {?a}\n\ngoal (1 subgoal):\n 1. R `` {y} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "by fastforce"], ["proof (state)\nthis:\n  R `` {y} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "with assms(1)"], ["proof (chain)\npicking this:\n  R `` {x} \\<noteq> R `` {y}\n  R `` {y} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "have \"R``{y} \\<notin> (insert (R``{x}) ?Vm)\""], ["proof (prove)\nusing this:\n  R `` {x} \\<noteq> R `` {y}\n  R `` {y} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. R `` {y}\n    \\<notin> insert (R `` {x})\n              (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "by blast"], ["proof (state)\nthis:\n  R `` {y}\n  \\<notin> insert (R `` {x})\n            (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"card (quotient V R) = Suc (card (insert (R``{x}) ?Vm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (V // R) =\n    Suc (card\n          (insert (R `` {x})\n            (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))", "apply(simp only: ii)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (insert (R `` {y})\n       (insert (R `` {x})\n         (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))) =\n    Suc (card\n          (insert (R `` {x})\n            (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))", "apply(rule card_insert_disjoint)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))\n 2. R `` {y}\n    \\<notin> insert (R `` {x})\n              (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {y}\n    \\<notin> insert (R `` {x})\n              (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  card (V // R) =\n  Suc (card\n        (insert (R `` {x})\n          (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "also"], ["proof (state)\nthis:\n  card (V // R) =\n  Suc (card\n        (insert (R `` {x})\n          (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "have \"card (insert (R``{x}) ?Vm) = Suc (card ?Vm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (insert (R `` {x})\n       (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})) =\n    Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))", "apply(rule card_insert_disjoint)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})\n 2. R `` {x} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {x} \\<notin> (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  card\n   (insert (R `` {x}) (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})) =\n  Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "finally"], ["proof (chain)\npicking this:\n  card (V // R) =\n  Suc (Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))", "have a: \"card (quotient V R) = Suc (Suc (card ?Vm))\""], ["proof (prove)\nusing this:\n  card (V // R) =\n  Suc (Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))\n\ngoal (1 subgoal):\n 1. card (V // R) =\n    Suc (Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))", "by auto"], ["proof (state)\nthis:\n  card (V // R) =\n  Suc (Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "from a o"], ["proof (chain)\npicking this:\n  card (V // R) =\n  Suc (Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))\n  card (V // per_union R x y) =\n  Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (V // R) =\n  Suc (Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}})))\n  card (V // per_union R x y) =\n  Suc (card (\\<Union>x\\<in>V - R `` {x} - R `` {y}. {R `` {x}}))\n\ngoal (1 subgoal):\n 1. Suc (card (V // per_union R x y)) = card (V // R)", "by auto"], ["proof (state)\nthis:\n  Suc (card (V // per_union R x y)) = card (V // R)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"On the pigeon hole principle\""], ["", "lemma fixes f::\"'c\\<Rightarrow>'d\"\n    and g ::\"'c\\<Rightarrow>'d\"\n    assumes \"finite A\" and k: \"\\<And>a b. a\\<in>A \\<Longrightarrow> b\\<in>A \\<Longrightarrow> f a = f b \\<Longrightarrow> g a = g b\"\n    shows  coarser: \"card (f ` A) \\<ge> card (g ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (g ` A) \\<le> card (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<lbrakk>?a \\<in> A; ?b \\<in> A; f ?a = f ?b\\<rbrakk>\n  \\<Longrightarrow> g ?a = g ?b\n\ngoal (1 subgoal):\n 1. card (g ` A) \\<le> card (f ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "let ?h = \"\\<lambda>d. THE x. {x} = g ` {x\\<in>A. f x = d}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "term image"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "have z: \"\\<And>x. x\\<in>A \\<Longrightarrow> g ` {y\\<in>A. f y = f x} = {g x} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> g ` {y \\<in> A. f y = f x} = {g x}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       {y. \\<exists>x\\<in>{y \\<in> A. f y = f x}. y = g x} = {g x}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xb.\n       \\<lbrakk>x \\<in> A; xb \\<in> A; f xb = f x\\<rbrakk>\n       \\<Longrightarrow> g xb = g x", "using k"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> A; ?b \\<in> A; f ?a = f ?b\\<rbrakk>\n  \\<Longrightarrow> g ?a = g ?b\n\ngoal (1 subgoal):\n 1. \\<And>x xb.\n       \\<lbrakk>x \\<in> A; xb \\<in> A; f xb = f x\\<rbrakk>\n       \\<Longrightarrow> g xb = g x", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> g ` {y \\<in> A. f y = f ?x} = {g ?x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "have uz: \"\\<And>x. x\\<in>A \\<Longrightarrow> ?h (f x) = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (THE xa. {xa} = g ` {xa \\<in> A. f xa = f x}) = g x", "by (simp add: z)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow>\n  (THE x. {x} = g ` {x \\<in> A. f x = f ?x}) = g ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "have \"card (?h ` (f ` A)) \\<le> card (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A)\n    \\<le> card (f ` A)", "apply(rule card_image_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` A)", "apply(rule finite_imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "by fact"], ["proof (state)\nthis:\n  card ((\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A)\n  \\<le> card (f ` A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "moreover"], ["proof (state)\nthis:\n  card ((\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A)\n  \\<le> card (f ` A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "from uz"], ["proof (chain)\npicking this:\n  ?x \\<in> A \\<Longrightarrow>\n  (THE x. {x} = g ` {x \\<in> A. f x = f ?x}) = g ?x", "have \"?h ` (f ` A)  = g ` A\""], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow>\n  (THE x. {x} = g ` {x \\<in> A. f x = f ?x}) = g ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A = g ` A", "by force"], ["proof (state)\nthis:\n  (\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A = g ` A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A; f a = f b\\<rbrakk>\n        \\<Longrightarrow> g a = g b\\<rbrakk>\n    \\<Longrightarrow> card (g ` A) \\<le> card (f ` A)", "ultimately"], ["proof (chain)\npicking this:\n  card ((\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A)\n  \\<le> card (f ` A)\n  (\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A = g ` A", "show ?thesis"], ["proof (prove)\nusing this:\n  card ((\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A)\n  \\<le> card (f ` A)\n  (\\<lambda>d. THE x. {x} = g ` {x \\<in> A. f x = d}) ` f ` A = g ` A\n\ngoal (1 subgoal):\n 1. card (g ` A) \\<le> card (f ` A)", "by auto"], ["proof (state)\nthis:\n  card (g ` A) \\<le> card (f ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"On sorting and \\<open>max_node\\<close>\""], ["", "definition edges_less_eq :: \"('a \\<times> 'w::{linorder, ordered_comm_monoid_add} \\<times> 'a) \\<Rightarrow> ('a \\<times> 'w \\<times> 'a) \\<Rightarrow> bool\"\n  where \"edges_less_eq a b \\<equiv> fst(snd a) \\<le> fst(snd b)\""], ["", "definition \"sort_edges \\<equiv> quicksort_by_rel edges_less_eq []\""], ["", "definition \"max_node l \\<equiv> Max (insert 0 (fst`set l \\<union> (snd o snd)`set l))\""], ["", "lemma max_node_impl[code]: \"max_node l = fold (\\<lambda>(u,_,w) x. max u (max w x)) l 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_node l = fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max_node l = fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l (0::'a)", "have \"fold (\\<lambda>(u,_,w) x. max u (max w x)) l a = Max (insert a (fst`set l \\<union> (snd o snd)`set l))\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l a =\n    Max (insert a (fst ` set l \\<union> (snd \\<circ> snd) ` set l))", "apply (induction l arbitrary: a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       fold (\\<lambda>(u, uu_, w) x. max u (max w x)) [] a =\n       Max (insert a (fst ` set [] \\<union> (snd \\<circ> snd) ` set []))\n 2. \\<And>a l aa.\n       (\\<And>a.\n           fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l a =\n           Max (insert a\n                 (fst ` set l \\<union>\n                  (snd \\<circ> snd) ` set l))) \\<Longrightarrow>\n       fold (\\<lambda>(u, uu_, w) x. max u (max w x)) (a # l) aa =\n       Max (insert aa\n             (fst ` set (a # l) \\<union> (snd \\<circ> snd) ` set (a # l)))", "apply (auto simp:  )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa.\n       (\\<And>a.\n           fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l a =\n           Max (insert a\n                 (fst ` set l \\<union>\n                  (\\<lambda>x. snd (snd x)) ` set l))) \\<Longrightarrow>\n       Max (insert (max a (max b aa))\n             (fst ` set l \\<union> (\\<lambda>x. snd (snd x)) ` set l)) =\n       max aa\n        (max b\n          (Max (insert a\n                 (fst ` set l \\<union> (\\<lambda>x. snd (snd x)) ` set l))))", "subgoal for a b l aa"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l a =\n        Max (insert a\n              (fst ` set l \\<union>\n               (\\<lambda>x. snd (snd x)) ` set l))) \\<Longrightarrow>\n    Max (insert (max a (max b aa))\n          (fst ` set l \\<union> (\\<lambda>x. snd (snd x)) ` set l)) =\n    max aa\n     (max b\n       (Max (insert a\n              (fst ` set l \\<union> (\\<lambda>x. snd (snd x)) ` set l))))", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a.\n                fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l a =\n                Max (insert a\n                      (fst ` set l \\<union>\n                       (\\<lambda>x. snd (snd x)) ` set l));\n     l = []\\<rbrakk>\n    \\<Longrightarrow> Max (insert (max a (max b aa))\n                            (fst ` set l \\<union>\n                             (\\<lambda>x. snd (snd x)) ` set l)) =\n                      max aa\n                       (max b\n                         (Max (insert a\n                                (fst ` set l \\<union>\n                                 (\\<lambda>x. snd (snd x)) ` set l))))\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>a.\n                   fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l a =\n                   Max (insert a\n                         (fst ` set l \\<union>\n                          (\\<lambda>x. snd (snd x)) ` set l));\n        l = a # list\\<rbrakk>\n       \\<Longrightarrow> Max (insert (max a (max b aa))\n                               (fst ` set l \\<union>\n                                (\\<lambda>x. snd (snd x)) ` set l)) =\n                         max aa\n                          (max b\n                            (Max (insert a\n                                   (fst ` set l \\<union>\n                                    (\\<lambda>x. snd (snd x)) ` set l))))", "by (auto simp: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l ?a =\n  Max (insert ?a (fst ` set l \\<union> (snd \\<circ> snd) ` set l))\n\ngoal (1 subgoal):\n 1. max_node l = fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l ?a =\n  Max (insert ?a (fst ` set l \\<union> (snd \\<circ> snd) ` set l))\n\ngoal (1 subgoal):\n 1. max_node l = fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l (0::'a)", "unfolding max_node_def"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l ?a =\n  Max (insert ?a (fst ` set l \\<union> (snd \\<circ> snd) ` set l))\n\ngoal (1 subgoal):\n 1. Max (insert (0::'a) (fst ` set l \\<union> (snd \\<circ> snd) ` set l)) =\n    fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l (0::'a)", "by auto"], ["proof (state)\nthis:\n  max_node l = fold (\\<lambda>(u, uu_, w) x. max u (max w x)) l (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"is_linorder_rel R \\<equiv> (\\<forall>x y. R x y \\<or> R y x) \\<and> (\\<forall>x y z. R x y \\<longrightarrow> R y z \\<longrightarrow> R x z)\""], ["", "lemma edges_less_eq_linorder: \"is_linorder_rel edges_less_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_linorder_rel edges_less_eq", "unfolding edges_less_eq_def is_linorder_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        fst (snd x) \\<le> fst (snd y) \\<or>\n        fst (snd y) \\<le> fst (snd x)) \\<and>\n    (\\<forall>x y z.\n        fst (snd x) \\<le> fst (snd y) \\<longrightarrow>\n        fst (snd y) \\<le> fst (snd z) \\<longrightarrow>\n        fst (snd x) \\<le> fst (snd z))", "by (metis linear order_trans)"], ["", "lemma sort_edges_correct: \"sorted_wrt edges_less_eq (quicksort_by_rel edges_less_eq [] l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt edges_less_eq (quicksort_by_rel edges_less_eq [] l)", "by (metis (no_types, hide_lams) edges_less_eq_linorder is_linorder_rel_def sorted_wrt_quicksort_by_rel)"], ["", "lemma distinct_mset_eq:\"distinct a \\<Longrightarrow> mset a = mset b \\<Longrightarrow> distinct b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct a; mset a = mset b\\<rbrakk>\n    \\<Longrightarrow> distinct b", "by (metis card_distinct distinct_card set_mset_mset size_mset)"], ["", "lemma quicksort_by_rel_distinct: \"distinct l \\<Longrightarrow> distinct (quicksort_by_rel edges_less_eq [] l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l \\<Longrightarrow>\n    distinct (quicksort_by_rel edges_less_eq [] l)", "by (auto intro: distinct_mset_eq)"], ["", "subsection \"On @{term list_rel}\""], ["", "lemma map_in_list_rel_conv: \n  shows \"(l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel \\<longleftrightarrow> ((\\<forall>x\\<in>set l. I x) \\<and> l'=map \\<alpha> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n    ((\\<forall>x\\<in>set l. I x) \\<and> l' = map \\<alpha> l)", "proof (induction l arbitrary: l')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l'.\n       (([], l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n       (Ball (set []) I \\<and> l' = map \\<alpha> [])\n 2. \\<And>a l l'.\n       (\\<And>l'.\n           ((l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n           (Ball (set l) I \\<and> l' = map \\<alpha> l)) \\<Longrightarrow>\n       ((a # l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n       (Ball (set (a # l)) I \\<and> l' = map \\<alpha> (a # l))", "case (Cons a l l')"], ["proof (state)\nthis:\n  ((l, ?l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n  ((\\<forall>a\\<in>set l. I a) \\<and> ?l' = map \\<alpha> l)\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       (([], l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n       (Ball (set []) I \\<and> l' = map \\<alpha> [])\n 2. \\<And>a l l'.\n       (\\<And>l'.\n           ((l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n           (Ball (set l) I \\<and> l' = map \\<alpha> l)) \\<Longrightarrow>\n       ((a # l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n       (Ball (set (a # l)) I \\<and> l' = map \\<alpha> (a # l))", "then"], ["proof (chain)\npicking this:\n  ((l, ?l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n  ((\\<forall>a\\<in>set l. I a) \\<and> ?l' = map \\<alpha> l)", "show ?case"], ["proof (prove)\nusing this:\n  ((l, ?l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n  ((\\<forall>a\\<in>set l. I a) \\<and> ?l' = map \\<alpha> l)\n\ngoal (1 subgoal):\n 1. ((a # l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n    ((\\<forall>a\\<in>set (a # l). I a) \\<and> l' = map \\<alpha> (a # l))", "apply(cases l')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>l'.\n                ((l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n                ((\\<forall>a\\<in>set l. I a) \\<and> l' = map \\<alpha> l);\n     l' = []\\<rbrakk>\n    \\<Longrightarrow> ((a # l, l')\n                       \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n                      ((\\<forall>a\\<in>set (a # l). I a) \\<and>\n                       l' = map \\<alpha> (a # l))\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>l'.\n                   ((l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n                   ((\\<forall>a\\<in>set l. I a) \\<and> l' = map \\<alpha> l);\n        l' = aa # list\\<rbrakk>\n       \\<Longrightarrow> ((a # l, l')\n                          \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n                         ((\\<forall>a\\<in>set (a # l). I a) \\<and>\n                          l' = map \\<alpha> (a # l))", "by (auto simp add: in_br_conv)"], ["proof (state)\nthis:\n  ((a # l, l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n  ((\\<forall>a\\<in>set (a # l). I a) \\<and> l' = map \\<alpha> (a # l))\n\ngoal (1 subgoal):\n 1. \\<And>l'.\n       (([], l') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel) =\n       (Ball (set []) I \\<and> l' = map \\<alpha> [])", "qed simp"], ["", "lemma list_relD: \"(x, y) \\<in> \\<langle>br a I\\<rangle>list_rel \\<Longrightarrow> y = map a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> \\<langle>br a I\\<rangle>list_rel \\<Longrightarrow>\n    y = map a x", "by(auto simp: map_in_list_rel_conv)"], ["", "lemma list_relD2: \"(x, y) \\<in> \\<langle>br a I\\<rangle>list_rel \\<Longrightarrow> y = map a x \\<and> (\\<forall>x\\<in>set x. I x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> \\<langle>br a I\\<rangle>list_rel \\<Longrightarrow>\n    y = map a x \\<and> (\\<forall>x\\<in>set x. I x)", "by(auto simp: map_in_list_rel_conv)"], ["", "lemma list_set_rel_append: \"(x,s)\\<in>br a I \\<Longrightarrow> (xs,S)\\<in>\\<langle>br a I\\<rangle>list_set_rel \\<Longrightarrow> s\\<notin>S\n     \\<Longrightarrow> (xs@[x],insert s S)\\<in>\\<langle>br a I\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, s) \\<in> br a I;\n     (xs, S) \\<in> \\<langle>br a I\\<rangle>list_set_rel;\n     s \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> (xs @ [x], insert s S)\n                      \\<in> \\<langle>br a I\\<rangle>list_set_rel", "unfolding list_set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, s) \\<in> br a I;\n     (xs, S) \\<in> \\<langle>br a I\\<rangle>list_rel O br set distinct;\n     s \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> (xs @ [x], insert s S)\n                      \\<in> \\<langle>br a I\\<rangle>list_rel O\n                            br set distinct", "apply(intro relcompI[where b=\"map a (xs @ [x])\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(x, s) \\<in> br a I;\n     (xs, S) \\<in> \\<langle>br a I\\<rangle>list_rel O br set distinct;\n     s \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> (xs @ [x], map a (xs @ [x]))\n                      \\<in> \\<langle>br a I\\<rangle>list_rel\n 2. \\<lbrakk>(x, s) \\<in> br a I;\n     (xs, S) \\<in> \\<langle>br a I\\<rangle>list_rel O br set distinct;\n     s \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> (map a (xs @ [x]), insert s S) \\<in> br set distinct", "apply (auto simp: in_br_conv)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> (xs @ [x], map a xs @ [a x])\n                         \\<in> \\<langle>br a I\\<rangle>list_rel\n 2. \\<And>y xa.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        xa \\<notin> a ` set xs; xa \\<in> set y; S = set y;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> xa = a x\n 3. \\<And>y xb.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        a xb \\<notin> set y; xb \\<in> set xs; S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> a xb = a x\n 4. \\<And>y.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> distinct (map a xs)\n 5. \\<And>y xa.\n       \\<lbrakk>a xa \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a xa; I x;\n        a x = a xa; xa \\<in> set xs; S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> False", "apply parametricity"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> (xs, map a xs)\n                         \\<in> \\<langle>br a I\\<rangle>list_rel\n 2. \\<And>y.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, a x) \\<in> br a I\n 3. \\<And>y xa.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        xa \\<notin> a ` set xs; xa \\<in> set y; S = set y;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> xa = a x\n 4. \\<And>y xb.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        a xb \\<notin> set y; xb \\<in> set xs; S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> a xb = a x\n 5. \\<And>y.\n       \\<lbrakk>a x \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a x; I x;\n        S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> distinct (map a xs)\n 6. \\<And>y xa.\n       \\<lbrakk>a xa \\<notin> set y;\n        (xs, y) \\<in> \\<langle>br a I\\<rangle>list_rel; s = a xa; I x;\n        a x = a xa; xa \\<in> set xs; S = set y; distinct y\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto dest: list_relD simp add: in_br_conv)"], ["", "subsection \"Auxiliary lemmas for Sepref\""], ["", "lemma pure_fold: \"(\\<lambda>a c. \\<up> (c = a)) = pure Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a c. \\<up> (c = a)) = id_assn", "unfolding pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a c. \\<up> (c = a)) = (\\<lambda>a c. \\<up> ((c, a) \\<in> Id))", "by auto"], ["", "lemma list_assn_emp: \"list_assn id_assn L L = emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn id_assn L L = emp", "apply(induct L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_assn id_assn [] [] = emp\n 2. \\<And>a L.\n       list_assn id_assn L L = emp \\<Longrightarrow>\n       list_assn id_assn (a # L) (a # L) = emp", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       list_assn id_assn L L = emp \\<Longrightarrow>\n       list_assn id_assn (a # L) (a # L) = emp", "by (simp add: pure_def)"], ["", "end"]]}