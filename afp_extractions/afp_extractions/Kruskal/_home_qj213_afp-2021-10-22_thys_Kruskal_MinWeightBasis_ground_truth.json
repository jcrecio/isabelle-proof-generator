{"file_name": "/home/qj213/afp-2021-10-22/thys/Kruskal/MinWeightBasis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kruskal", "problem_names": ["lemma [simp]: \"set (in_sort_edge x L) = insert x (set L)\"", "lemma in_sort_edge: \"sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L\n         \\<Longrightarrow> sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) (in_sort_edge x L)\"", "lemma in_sort_edge_distinct: \"x \\<notin> set L \\<Longrightarrow> distinct L \\<Longrightarrow> distinct (in_sort_edge x L)\"", "lemma finite_sorted_edge_distinct:\n  assumes \"finite S\" \n  obtains L where \"distinct L\" \"sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L\" \"S = set L\"", "lemma sum_list_map_cons:\n  \"sum_list (map weight (y # ys)) = weight y + sum_list (map weight ys)\"", "lemma exists_greater:\n  assumes  len: \"length F = length F'\"\n      and sum: \"sum_list (map weight F) > sum_list (map weight F')\"\n    shows \"\\<exists>i<length F. weight (F ! i) > weight (F' ! i)\"", "lemma wsorted_nth_mono: assumes \"wsorted L\" \"i\\<le>j\" \"j<length L\"\n  shows \"weight (L!i) \\<le> weight (L!j)\"", "lemma limi_subset: \"limi T g \\<subseteq> T\"", "lemma limi_mono: \"A \\<subseteq> B \\<Longrightarrow> limi A g \\<subseteq> limi B g\"", "lemma no_smallest_element_skipped_empty[simp]: \"no_smallest_element_skipped carrier {}\"", "lemma no_smallest_element_skippedD:\n  assumes \"no_smallest_element_skipped E F\" \"e \\<in>carrier - E\"\n      \"weight e < g\" \"(indep (insert e (limi F g)))\"\n  shows \"e\\<in> limi F g\"", "lemma no_smallest_element_skipped_skip: \n  assumes createsCycle: \"\\<not> indep (insert e F)\"\n       and    I: \"no_smallest_element_skipped (E\\<union>{e}) F\"\n       and    sorted: \"(\\<forall>x\\<in>F.\\<forall>y\\<in>(E\\<union>{e}). weight x \\<le> weight y)\"\n     shows \"no_smallest_element_skipped E F\"", "lemma no_smallest_element_skipped_add:\n  assumes I: \"no_smallest_element_skipped (E\\<union>{e}) F\"\n  shows \"no_smallest_element_skipped E (insert e F)\"", "lemma greedy_approach_leads_to_minBasis: assumes indep: \"indep F\"\n  and inclmax: \"\\<forall>e\\<in>carrier - F. \\<not> indep (insert e F)\"\n  and \"no_smallest_element_skipped {} F\"\n  shows \"minBasis F\"", "lemma I_minWeightBasisD: \n  assumes \n   \"I_minWeightBasis (T,E)\"\n shows\"indep T\" \"\\<And>e. e\\<in>carrier-E-T \\<Longrightarrow> ~indep (insert e T)\"\n    \"E \\<subseteq> carrier\" \"\\<And>x y. x\\<in>T \\<Longrightarrow> y\\<in>E \\<Longrightarrow> weight x \\<le> weight y\"  \"T \\<subseteq> carrier\"\n    \"no_smallest_element_skipped E T\"", "lemma I_minWeightBasisI:\n  assumes \"indep T\" \"\\<And>e. e\\<in>carrier-E-T \\<Longrightarrow> ~indep (insert e T)\"\n    \"E \\<subseteq> carrier\" \"\\<And>x y. x\\<in>T \\<Longrightarrow> y\\<in>E \\<Longrightarrow> weight x \\<le> weight y\"  \"T \\<subseteq> carrier\"\n    \"no_smallest_element_skipped E T\"\n  shows \"I_minWeightBasis (T,E)\"", "lemma I_minWeightBasisG: \"I_minWeightBasis (T,E) \\<Longrightarrow> no_smallest_element_skipped E T\"", "lemma I_minWeightBasis_sorted: \"I_minWeightBasis (T,E) \\<Longrightarrow> (\\<forall>x\\<in>T.\\<forall>y\\<in>E. weight x \\<le> weight y)\"", "lemma I_minWeightBasis_empty: \"I_minWeightBasis ({}, carrier)\"", "lemma I_minWeightBasis_final: \"I_minWeightBasis (T, {}) \\<Longrightarrow> minBasis T\"", "lemma indep_aux:       \n  assumes \"e \\<in> E\" \"\\<forall>e\\<in>carrier - E - F. \\<not> indep (insert e F)\"        \n    and \"x\\<in>carrier - (E - {e}) - insert e F\"\n    shows  \"\\<not> indep (insert x (insert e F))\"", "lemma preservation_if: \"wsorted x \\<Longrightarrow>   set x = carrier \\<Longrightarrow>\n    x = l1 @ xa # l2 \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set (xa # l2))  \\<Longrightarrow> indep \\<sigma>\n   \\<Longrightarrow> xa \\<in> carrier \\<Longrightarrow> indep (insert xa \\<sigma>) \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\"", "lemma preservation_else: \"set x = carrier \\<Longrightarrow>\n    x = l1 @ xa # l2 \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set (xa # l2))\n     \\<Longrightarrow> indep \\<sigma>   \\<Longrightarrow> \\<not> indep (insert xa \\<sigma>) \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\"", "theorem minWeightBasis_refine: \"(minWeightBasis, SPEC minBasis)\\<in>\\<langle>Id\\<rangle>nres_rel\""], "translations": [["", "lemma [simp]: \"set (in_sort_edge x L) = insert x (set L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (in_sort_edge x L) = insert x (set L)", "by (induct L, auto)"], ["", "lemma in_sort_edge: \"sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L\n         \\<Longrightarrow> sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) (in_sort_edge x L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\n     L \\<Longrightarrow>\n    sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\n     (in_sort_edge x L)", "by (induct L, auto)"], ["", "lemma in_sort_edge_distinct: \"x \\<notin> set L \\<Longrightarrow> distinct L \\<Longrightarrow> distinct (in_sort_edge x L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set L; distinct L\\<rbrakk>\n    \\<Longrightarrow> distinct (in_sort_edge x L)", "by (induct L, auto)"], ["", "lemma finite_sorted_edge_distinct:\n  assumes \"finite S\" \n  obtains L where \"distinct L\" \"sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L\" \"S = set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>distinct L;\n         sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L;\n         S = set L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>distinct L;\n         sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L;\n         S = set L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>distinct L;\n         sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L;\n         S = set L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>L.  distinct L \\<and> sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and> S = set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L.\n       distinct L \\<and>\n       sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n       S = set L", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       distinct L \\<and>\n       sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n       S = set L", "apply(induct S)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>L.\n       distinct L \\<and>\n       sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n       {} = set L\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>L.\n           distinct L \\<and>\n           sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n           F = set L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L.\n                            distinct L \\<and>\n                            sorted_wrt\n                             (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\n                             L \\<and>\n                            insert x F = set L", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>L.\n           distinct L \\<and>\n           sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n           F = set L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L.\n                            distinct L \\<and>\n                            sorted_wrt\n                             (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\n                             L \\<and>\n                            insert x F = set L", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x L.\n       \\<lbrakk>x \\<notin> set L; distinct L;\n        sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>La.\n                            distinct La \\<and>\n                            sorted_wrt\n                             (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\n                             La \\<and>\n                            insert x (set L) = set La", "subgoal for x L"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set L; distinct L;\n     sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L\\<rbrakk>\n    \\<Longrightarrow> \\<exists>La.\n                         distinct La \\<and>\n                         sorted_wrt\n                          (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\n                          La \\<and>\n                         insert x (set L) = set La", "apply(rule exI[where x=\"in_sort_edge x L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set L; distinct L;\n     sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L\\<rbrakk>\n    \\<Longrightarrow> distinct (in_sort_edge x L) \\<and>\n                      sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\n                       (in_sort_edge x L) \\<and>\n                      insert x (set L) = set (in_sort_edge x L)", "by (auto simp: in_sort_edge in_sort_edge_distinct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>L.\n     distinct L \\<and>\n     sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n     S = set L\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>distinct L;\n         sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L;\n         S = set L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>L.\n     distinct L \\<and>\n     sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n     S = set L\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>distinct L;\n         sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L;\n         S = set L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct ?L;\n   sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) ?L;\n   S = set ?L\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>L.\n     distinct L \\<and>\n     sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n     S = set L", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?L;\n   sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) ?L;\n   S = set ?L\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>L.\n     distinct L \\<and>\n     sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2) L \\<and>\n     S = set L\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"wsorted == sorted_wrt (\\<lambda>e1 e2. weight e1 \\<le> weight e2)\""], ["", "lemma sum_list_map_cons:\n  \"sum_list (map weight (y # ys)) = weight y + sum_list (map weight ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map weight (y # ys)) = weight y + sum_list (map weight ys)", "by auto"], ["", "lemma exists_greater:\n  assumes  len: \"length F = length F'\"\n      and sum: \"sum_list (map weight F) > sum_list (map weight F')\"\n    shows \"\\<exists>i<length F. weight (F ! i) > weight (F' ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length F. weight (F' ! i) < weight (F ! i)", "using len sum"], ["proof (prove)\nusing this:\n  length F = length F'\n  sum_list (map weight F') < sum_list (map weight F)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length F. weight (F' ! i) < weight (F ! i)", "proof (induct rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (map weight []) < sum_list (map weight []) \\<Longrightarrow>\n    \\<exists>i<length []. weight ([] ! i) < weight ([] ! i)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map weight ys)\n        < sum_list (map weight xs) \\<Longrightarrow>\n        \\<exists>i<length xs. weight (ys ! i) < weight (xs ! i);\n        sum_list (map weight (y # ys))\n        < sum_list (map weight (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (x # xs).\n                            weight ((y # ys) ! i) < weight ((x # xs) ! i)", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  sum_list (map weight ys) < sum_list (map weight xs) \\<Longrightarrow>\n  \\<exists>i<length xs. weight (ys ! i) < weight (xs ! i)\n  sum_list (map weight (y # ys)) < sum_list (map weight (x # xs))\n\ngoal (2 subgoals):\n 1. sum_list (map weight []) < sum_list (map weight []) \\<Longrightarrow>\n    \\<exists>i<length []. weight ([] ! i) < weight ([] ! i)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map weight ys)\n        < sum_list (map weight xs) \\<Longrightarrow>\n        \\<exists>i<length xs. weight (ys ! i) < weight (xs ! i);\n        sum_list (map weight (y # ys))\n        < sum_list (map weight (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (x # xs).\n                            weight ((y # ys) ! i) < weight ((x # xs) ! i)", "from Cons(3)"], ["proof (chain)\npicking this:\n  sum_list (map weight (y # ys)) < sum_list (map weight (x # xs))", "have *: \"~ weight y < weight x \\<Longrightarrow> sum_list (map weight ys) < sum_list (map weight xs)\""], ["proof (prove)\nusing this:\n  sum_list (map weight (y # ys)) < sum_list (map weight (x # xs))\n\ngoal (1 subgoal):\n 1. \\<not> weight y < weight x \\<Longrightarrow>\n    sum_list (map weight ys) < sum_list (map weight xs)", "by (metis add_mono not_less sum_list_map_cons)"], ["proof (state)\nthis:\n  \\<not> weight y < weight x \\<Longrightarrow>\n  sum_list (map weight ys) < sum_list (map weight xs)\n\ngoal (2 subgoals):\n 1. sum_list (map weight []) < sum_list (map weight []) \\<Longrightarrow>\n    \\<exists>i<length []. weight ([] ! i) < weight ([] ! i)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map weight ys)\n        < sum_list (map weight xs) \\<Longrightarrow>\n        \\<exists>i<length xs. weight (ys ! i) < weight (xs ! i);\n        sum_list (map weight (y # ys))\n        < sum_list (map weight (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (x # xs).\n                            weight ((y # ys) ! i) < weight ((x # xs) ! i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length (x # xs).\n       weight ((y # ys) ! i) < weight ((x # xs) ! i)", "using Cons *"], ["proof (prove)\nusing this:\n  length xs = length ys\n  sum_list (map weight ys) < sum_list (map weight xs) \\<Longrightarrow>\n  \\<exists>i<length xs. weight (ys ! i) < weight (xs ! i)\n  sum_list (map weight (y # ys)) < sum_list (map weight (x # xs))\n  \\<not> weight y < weight x \\<Longrightarrow>\n  sum_list (map weight ys) < sum_list (map weight xs)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length (x # xs).\n       weight ((y # ys) ! i) < weight ((x # xs) ! i)", "by (cases \"weight y < weight x\", auto)"], ["proof (state)\nthis:\n  \\<exists>i<length (x # xs). weight ((y # ys) ! i) < weight ((x # xs) ! i)\n\ngoal (1 subgoal):\n 1. sum_list (map weight []) < sum_list (map weight []) \\<Longrightarrow>\n    \\<exists>i<length []. weight ([] ! i) < weight ([] ! i)", "qed simp"], ["", "lemma wsorted_nth_mono: assumes \"wsorted L\" \"i\\<le>j\" \"j<length L\"\n  shows \"weight (L!i) \\<le> weight (L!j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (L ! i) \\<le> weight (L ! j)", "using assms"], ["proof (prove)\nusing this:\n  wsorted L\n  i \\<le> j\n  j < length L\n\ngoal (1 subgoal):\n 1. weight (L ! i) \\<le> weight (L ! j)", "by (induct L arbitrary: i j rule: list.induct, auto simp: nth_Cons')"], ["", "subsubsection \\<open>Weight restricted set\\<close>"], ["", "text \\<open>limi T g is the set T restricted  \n     to elements only with weight\n    strictly smaller than g.\\<close>"], ["", "definition \"limi T g == {e. e\\<in>T \\<and> weight e < g}\""], ["", "lemma limi_subset: \"limi T g \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limi T g \\<subseteq> T", "by (auto simp: limi_def)"], ["", "lemma limi_mono: \"A \\<subseteq> B \\<Longrightarrow> limi A g \\<subseteq> limi B g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> limi A g \\<subseteq> limi B g", "by (auto simp: limi_def)"], ["", "subsubsection \\<open>The greedy idea\\<close>"], ["", "definition \"no_smallest_element_skipped E F\n   = (\\<forall>e\\<in>carrier - E. \\<forall>g>weight e. indep (insert e (limi F g)) \\<longrightarrow> (e \\<in> limi F g))\""], ["", "text  \\<open>let @{term F} be a set of elements\n  @{term \\<open>limi F g\\<close>} is @{term F} restricted to elements with weight smaller than @{term g}\n  let @{term E} be a set of elements we want to exclude.\n    \n  @{term \\<open>no_smallest_element_skipped E F\\<close>} expresses,\n     that going greedily over @{term \\<open>carrier-E\\<close>}, every element that did not\n     render the accumulated set dependent, was added to the set @{term F}.\\<close>"], ["", "lemma no_smallest_element_skipped_empty[simp]: \"no_smallest_element_skipped carrier {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_smallest_element_skipped carrier {}", "by(auto simp: no_smallest_element_skipped_def)"], ["", "lemma no_smallest_element_skippedD:\n  assumes \"no_smallest_element_skipped E F\" \"e \\<in>carrier - E\"\n      \"weight e < g\" \"(indep (insert e (limi F g)))\"\n  shows \"e\\<in> limi F g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> limi F g", "using assms"], ["proof (prove)\nusing this:\n  no_smallest_element_skipped E F\n  e \\<in> carrier - E\n  weight e < g\n  indep (insert e (limi F g))\n\ngoal (1 subgoal):\n 1. e \\<in> limi F g", "by(auto simp: no_smallest_element_skipped_def)"], ["", "lemma no_smallest_element_skipped_skip: \n  assumes createsCycle: \"\\<not> indep (insert e F)\"\n       and    I: \"no_smallest_element_skipped (E\\<union>{e}) F\"\n       and    sorted: \"(\\<forall>x\\<in>F.\\<forall>y\\<in>(E\\<union>{e}). weight x \\<le> weight y)\"\n     shows \"no_smallest_element_skipped E F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_smallest_element_skipped E F", "unfolding no_smallest_element_skipped_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>carrier - E.\n       \\<forall>g>weight e.\n          indep (insert e (limi F g)) \\<longrightarrow> e \\<in> limi F g", "proof (clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e g.\n       \\<lbrakk>e \\<in> carrier; e \\<notin> E; weight e < g;\n        indep (insert e (limi F g))\\<rbrakk>\n       \\<Longrightarrow> e \\<in> limi F g", "fix x g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e g.\n       \\<lbrakk>e \\<in> carrier; e \\<notin> E; weight e < g;\n        indep (insert e (limi F g))\\<rbrakk>\n       \\<Longrightarrow> e \\<in> limi F g", "assume x: \"x \\<in> carrier\"  \"x \\<notin> E\"  \"weight x < g\""], ["proof (state)\nthis:\n  x \\<in> carrier\n  x \\<notin> E\n  weight x < g\n\ngoal (1 subgoal):\n 1. \\<And>e g.\n       \\<lbrakk>e \\<in> carrier; e \\<notin> E; weight e < g;\n        indep (insert e (limi F g))\\<rbrakk>\n       \\<Longrightarrow> e \\<in> limi F g", "assume f: \"indep (insert x (limi F g))\""], ["proof (state)\nthis:\n  indep (insert x (limi F g))\n\ngoal (1 subgoal):\n 1. \\<And>e g.\n       \\<lbrakk>e \\<in> carrier; e \\<notin> E; weight e < g;\n        indep (insert e (limi F g))\\<rbrakk>\n       \\<Longrightarrow> e \\<in> limi F g", "show \"(x \\<in> limi F g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> limi F g", "proof (cases \"x=e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = e \\<Longrightarrow> x \\<in> limi F g\n 2. x \\<noteq> e \\<Longrightarrow> x \\<in> limi F g", "case True"], ["proof (state)\nthis:\n  x = e\n\ngoal (2 subgoals):\n 1. x = e \\<Longrightarrow> x \\<in> limi F g\n 2. x \\<noteq> e \\<Longrightarrow> x \\<in> limi F g", "from True"], ["proof (chain)\npicking this:\n  x = e", "have \"limi F g = F\""], ["proof (prove)\nusing this:\n  x = e\n\ngoal (1 subgoal):\n 1. limi F g = F", "unfolding limi_def"], ["proof (prove)\nusing this:\n  x = e\n\ngoal (1 subgoal):\n 1. {e \\<in> F. weight e < g} = F", "using \\<open>weight x < g\\<close> sorted"], ["proof (prove)\nusing this:\n  x = e\n  weight x < g\n  \\<forall>x\\<in>F. \\<forall>y\\<in>E \\<union> {e}. weight x \\<le> weight y\n\ngoal (1 subgoal):\n 1. {e \\<in> F. weight e < g} = F", "by fastforce"], ["proof (state)\nthis:\n  limi F g = F\n\ngoal (2 subgoals):\n 1. x = e \\<Longrightarrow> x \\<in> limi F g\n 2. x \\<noteq> e \\<Longrightarrow> x \\<in> limi F g", "with createsCycle f True"], ["proof (chain)\npicking this:\n  \\<not> indep (insert e F)\n  indep (insert x (limi F g))\n  x = e\n  limi F g = F", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> indep (insert e F)\n  indep (insert x (limi F g))\n  x = e\n  limi F g = F\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. x = e \\<Longrightarrow> x \\<in> limi F g\n 2. x \\<noteq> e \\<Longrightarrow> x \\<in> limi F g", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x \\<in> limi F g", "by simp"], ["proof (state)\nthis:\n  x \\<in> limi F g\n\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi F g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi F g", "case False"], ["proof (state)\nthis:\n  x \\<noteq> e\n\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi F g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> limi F g", "apply(rule I[THEN no_smallest_element_skippedD, OF _ \\<open>weight x < g\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> carrier - (E \\<union> {e})\n 2. indep (insert x (limi F g))", "using x f False"], ["proof (prove)\nusing this:\n  x \\<in> carrier\n  x \\<notin> E\n  weight x < g\n  indep (insert x (limi F g))\n  x \\<noteq> e\n\ngoal (2 subgoals):\n 1. x \\<in> carrier - (E \\<union> {e})\n 2. indep (insert x (limi F g))", "by auto"], ["proof (state)\nthis:\n  x \\<in> limi F g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> limi F g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_smallest_element_skipped_add:\n  assumes I: \"no_smallest_element_skipped (E\\<union>{e}) F\"\n  shows \"no_smallest_element_skipped E (insert e F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_smallest_element_skipped E (insert e F)", "unfolding no_smallest_element_skipped_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ea\\<in>carrier - E.\n       \\<forall>g>weight ea.\n          indep (insert ea (limi (insert e F) g)) \\<longrightarrow>\n          ea \\<in> limi (insert e F) g", "proof (clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ea g.\n       \\<lbrakk>ea \\<in> carrier; ea \\<notin> E; weight ea < g;\n        indep (insert ea (limi (insert e F) g))\\<rbrakk>\n       \\<Longrightarrow> ea \\<in> limi (insert e F) g", "fix x g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ea g.\n       \\<lbrakk>ea \\<in> carrier; ea \\<notin> E; weight ea < g;\n        indep (insert ea (limi (insert e F) g))\\<rbrakk>\n       \\<Longrightarrow> ea \\<in> limi (insert e F) g", "assume xc: \"x \\<in> carrier\""], ["proof (state)\nthis:\n  x \\<in> carrier\n\ngoal (1 subgoal):\n 1. \\<And>ea g.\n       \\<lbrakk>ea \\<in> carrier; ea \\<notin> E; weight ea < g;\n        indep (insert ea (limi (insert e F) g))\\<rbrakk>\n       \\<Longrightarrow> ea \\<in> limi (insert e F) g", "assume x: \"x \\<notin> E\""], ["proof (state)\nthis:\n  x \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<And>ea g.\n       \\<lbrakk>ea \\<in> carrier; ea \\<notin> E; weight ea < g;\n        indep (insert ea (limi (insert e F) g))\\<rbrakk>\n       \\<Longrightarrow> ea \\<in> limi (insert e F) g", "assume wx: \"weight x < g\""], ["proof (state)\nthis:\n  weight x < g\n\ngoal (1 subgoal):\n 1. \\<And>ea g.\n       \\<lbrakk>ea \\<in> carrier; ea \\<notin> E; weight ea < g;\n        indep (insert ea (limi (insert e F) g))\\<rbrakk>\n       \\<Longrightarrow> ea \\<in> limi (insert e F) g", "assume f: \"indep (insert x (limi (insert e F) g))\""], ["proof (state)\nthis:\n  indep (insert x (limi (insert e F) g))\n\ngoal (1 subgoal):\n 1. \\<And>ea g.\n       \\<lbrakk>ea \\<in> carrier; ea \\<notin> E; weight ea < g;\n        indep (insert ea (limi (insert e F) g))\\<rbrakk>\n       \\<Longrightarrow> ea \\<in> limi (insert e F) g", "show \"(x \\<in> limi (insert e F) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> limi (insert e F) g", "proof(cases \"x=e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = e \\<Longrightarrow> x \\<in> limi (insert e F) g\n 2. x \\<noteq> e \\<Longrightarrow> x \\<in> limi (insert e F) g", "case True"], ["proof (state)\nthis:\n  x = e\n\ngoal (2 subgoals):\n 1. x = e \\<Longrightarrow> x \\<in> limi (insert e F) g\n 2. x \\<noteq> e \\<Longrightarrow> x \\<in> limi (insert e F) g", "then"], ["proof (chain)\npicking this:\n  x = e", "show ?thesis"], ["proof (prove)\nusing this:\n  x = e\n\ngoal (1 subgoal):\n 1. x \\<in> limi (insert e F) g", "unfolding limi_def"], ["proof (prove)\nusing this:\n  x = e\n\ngoal (1 subgoal):\n 1. x \\<in> {ea \\<in> insert e F. weight ea < g}", "using wx"], ["proof (prove)\nusing this:\n  x = e\n  weight x < g\n\ngoal (1 subgoal):\n 1. x \\<in> {ea \\<in> insert e F. weight ea < g}", "by blast"], ["proof (state)\nthis:\n  x \\<in> limi (insert e F) g\n\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi (insert e F) g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi (insert e F) g", "case False"], ["proof (state)\nthis:\n  x \\<noteq> e\n\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi (insert e F) g", "have ind: \"indep (insert x (limi F g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indep (insert x (limi F g))", "apply(rule indep_subset[OF f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (limi F g) \\<subseteq> insert x (limi (insert e F) g)", "using limi_mono"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?B \\<Longrightarrow> limi ?A ?g \\<subseteq> limi ?B ?g\n\ngoal (1 subgoal):\n 1. insert x (limi F g) \\<subseteq> insert x (limi (insert e F) g)", "by blast"], ["proof (state)\nthis:\n  indep (insert x (limi F g))\n\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi (insert e F) g", "have \"indep (insert x (limi F g)) \\<Longrightarrow> x \\<in> limi F g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indep (insert x (limi F g)) \\<Longrightarrow> x \\<in> limi F g", "apply(rule I[THEN no_smallest_element_skippedD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. indep (insert x (limi F g)) \\<Longrightarrow>\n    x \\<in> carrier - (E \\<union> {e})\n 2. indep (insert x (limi F g)) \\<Longrightarrow> weight x < g\n 3. indep (insert x (limi F g)) \\<Longrightarrow>\n    indep (insert x (limi F g))", "using False xc wx x"], ["proof (prove)\nusing this:\n  x \\<noteq> e\n  x \\<in> carrier\n  weight x < g\n  x \\<notin> E\n\ngoal (3 subgoals):\n 1. indep (insert x (limi F g)) \\<Longrightarrow>\n    x \\<in> carrier - (E \\<union> {e})\n 2. indep (insert x (limi F g)) \\<Longrightarrow> weight x < g\n 3. indep (insert x (limi F g)) \\<Longrightarrow>\n    indep (insert x (limi F g))", "by auto"], ["proof (state)\nthis:\n  indep (insert x (limi F g)) \\<Longrightarrow> x \\<in> limi F g\n\ngoal (1 subgoal):\n 1. x \\<noteq> e \\<Longrightarrow> x \\<in> limi (insert e F) g", "with ind"], ["proof (chain)\npicking this:\n  indep (insert x (limi F g))\n  indep (insert x (limi F g)) \\<Longrightarrow> x \\<in> limi F g", "show ?thesis"], ["proof (prove)\nusing this:\n  indep (insert x (limi F g))\n  indep (insert x (limi F g)) \\<Longrightarrow> x \\<in> limi F g\n\ngoal (1 subgoal):\n 1. x \\<in> limi (insert e F) g", "using limi_mono"], ["proof (prove)\nusing this:\n  indep (insert x (limi F g))\n  indep (insert x (limi F g)) \\<Longrightarrow> x \\<in> limi F g\n  ?A \\<subseteq> ?B \\<Longrightarrow> limi ?A ?g \\<subseteq> limi ?B ?g\n\ngoal (1 subgoal):\n 1. x \\<in> limi (insert e F) g", "by blast"], ["proof (state)\nthis:\n  x \\<in> limi (insert e F) g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> limi (insert e F) g\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Minimum Weight Basis algorithm\\<close>"], ["", "definition \"obtain_sorted_carrier \\<equiv> SPEC (\\<lambda>L. wsorted L \\<and> set L = carrier)\""], ["", "abbreviation \"empty_basis \\<equiv> {}\""], ["", "text \\<open>To compute a minimum weight basis one obtains a list of the carrier set sorted ascendingly\n  by the weight function. Then one iterates over the list and adds an elements greedily to \n  the independent set if it does not render the set dependet.\\<close>"], ["", "definition minWeightBasis where \n  \"minWeightBasis \\<equiv> do {\n        l \\<leftarrow> obtain_sorted_carrier;\n        ASSERT (set l = carrier);\n        T \\<leftarrow> nfoldli l (\\<lambda>_. True) \n        (\\<lambda>e T. do { \n            ASSERT (indep T \\<and> e\\<in>carrier \\<and> T\\<subseteq>carrier);\n            if indep (insert e T) then\n              RETURN (insert e T)\n            else \n              RETURN T\n        }) empty_basis;\n        RETURN T\n      }\""], ["", "subsection \\<open>The heart of the argument\\<close>"], ["", "text \\<open>The algorithmic idea above is correct, as an independent set, which\n  is inclusion maximal and has not skipped any smaller element, is a minimum weight basis. \\<close>"], ["", "lemma greedy_approach_leads_to_minBasis: assumes indep: \"indep F\"\n  and inclmax: \"\\<forall>e\\<in>carrier - F. \\<not> indep (insert e F)\"\n  and \"no_smallest_element_skipped {} F\"\n  shows \"minBasis F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minBasis F", "proof (rule ccontr)\n  \\<comment> \\<open>from our assumptions we have that F is a basis\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from indep inclmax"], ["proof (chain)\npicking this:\n  indep F\n  \\<forall>e\\<in>carrier - F. \\<not> indep (insert e F)", "have bF: \"basis F\""], ["proof (prove)\nusing this:\n  indep F\n  \\<forall>e\\<in>carrier - F. \\<not> indep (insert e F)\n\ngoal (1 subgoal):\n 1. basis F", "using indep_not_basis"], ["proof (prove)\nusing this:\n  indep F\n  \\<forall>e\\<in>carrier - F. \\<not> indep (insert e F)\n  \\<lbrakk>indep ?X; \\<not> basis ?X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>carrier - ?X. indep (insert x ?X)\n\ngoal (1 subgoal):\n 1. basis F", "by blast\n  \\<comment> \\<open>towards a contradiction, assume F is not a minimum Basis\\<close>"], ["proof (state)\nthis:\n  basis F\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "assume notmin: \"\\<not> minBasis F\"    \n  \\<comment> \\<open>then we can get a smaller Basis B\\<close>"], ["proof (state)\nthis:\n  \\<not> minBasis F\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from bF notmin[unfolded minBasis_def]"], ["proof (chain)\npicking this:\n  basis F\n  \\<not> (basis F \\<and>\n          (\\<forall>B'.\n              basis B' \\<longrightarrow> sum weight F \\<le> sum weight B'))", "obtain B\n    where bB: \"basis B\" and sum: \"sum weight B < sum weight F\""], ["proof (prove)\nusing this:\n  basis F\n  \\<not> (basis F \\<and>\n          (\\<forall>B'.\n              basis B' \\<longrightarrow> sum weight F \\<le> sum weight B'))\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>basis B; sum weight B < sum weight F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force\n  \\<comment> \\<open>lets us obtain two sorted lists for the bases F and B\\<close>"], ["proof (state)\nthis:\n  basis B\n  sum weight B < sum weight F\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from bF basis_finite finite_sorted_edge_distinct"], ["proof (chain)\npicking this:\n  basis F\n  basis ?A \\<Longrightarrow> finite ?A\n  \\<lbrakk>finite ?S;\n   \\<And>L.\n      \\<lbrakk>distinct L; wsorted L; ?S = set L\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain FL where dF[simp]: \"distinct FL\" and wF[simp]: \"wsorted FL\" \n    and sF[simp]: \"F = set FL\""], ["proof (prove)\nusing this:\n  basis F\n  basis ?A \\<Longrightarrow> finite ?A\n  \\<lbrakk>finite ?S;\n   \\<And>L.\n      \\<lbrakk>distinct L; wsorted L; ?S = set L\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>FL.\n        \\<lbrakk>distinct FL; wsorted FL; F = set FL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct FL\n  wsorted FL\n  F = set FL\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from bB basis_finite finite_sorted_edge_distinct"], ["proof (chain)\npicking this:\n  basis B\n  basis ?A \\<Longrightarrow> finite ?A\n  \\<lbrakk>finite ?S;\n   \\<And>L.\n      \\<lbrakk>distinct L; wsorted L; ?S = set L\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain BL where dB[simp]: \"distinct BL\" and wB[simp]: \"wsorted BL\"\n    and sB[simp]: \"B = set BL\""], ["proof (prove)\nusing this:\n  basis B\n  basis ?A \\<Longrightarrow> finite ?A\n  \\<lbrakk>finite ?S;\n   \\<And>L.\n      \\<lbrakk>distinct L; wsorted L; ?S = set L\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>BL.\n        \\<lbrakk>distinct BL; wsorted BL; B = set BL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>as basis F has more total weight than basis B (and the basis have the same length) ...\\<close>"], ["proof (state)\nthis:\n  distinct BL\n  wsorted BL\n  B = set BL\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from sum"], ["proof (chain)\npicking this:\n  sum weight B < sum weight F", "have suml: \"sum_list (map weight BL) < sum_list (map weight FL)\""], ["proof (prove)\nusing this:\n  sum weight B < sum weight F\n\ngoal (1 subgoal):\n 1. sum_list (map weight BL) < sum_list (map weight FL)", "by(simp add: sum.distinct_set_conv_list[symmetric])"], ["proof (state)\nthis:\n  sum_list (map weight BL) < sum_list (map weight FL)\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from bB bF"], ["proof (chain)\npicking this:\n  basis B\n  basis F", "have \"card B = card F\""], ["proof (prove)\nusing this:\n  basis B\n  basis F\n\ngoal (1 subgoal):\n 1. card B = card F", "using basis_card"], ["proof (prove)\nusing this:\n  basis B\n  basis F\n  \\<lbrakk>basis ?B\\<^sub>1; basis ?B\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> card ?B\\<^sub>1 = card ?B\\<^sub>2\n\ngoal (1 subgoal):\n 1. card B = card F", "by blast"], ["proof (state)\nthis:\n  card B = card F\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  card B = card F", "have l: \"length FL = length BL\""], ["proof (prove)\nusing this:\n  card B = card F\n\ngoal (1 subgoal):\n 1. length FL = length BL", "by (simp add: distinct_card) \n  \\<comment> \\<open>... there exists an index i such that the ith element of the BL is strictly smaller \n      than the ith element of FL \\<close>"], ["proof (state)\nthis:\n  length FL = length BL\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from exists_greater[OF l suml]"], ["proof (chain)\npicking this:\n  \\<exists>i<length FL. weight (BL ! i) < weight (FL ! i)", "obtain i where i: \"i<length FL\"\n    and gr: \"weight (BL ! i) < weight (FL ! i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length FL. weight (BL ! i) < weight (FL ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length FL; weight (BL ! i) < weight (FL ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length FL\n  weight (BL ! i) < weight (FL ! i)\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "let ?FL_restricted = \"limi (set FL) (weight (FL ! i))\"\n\n  \\<comment> \\<open>now let us look at the two independent sets X and Y:\n        let X and Y be the set if we take the first i-1 elements of BL\n         and the first i elements of FL respectively. \n      We want to use the augment property of Matroids in order to show that we must have skipped\n      and optimal element, which then contradicts our assumption. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "let ?X = \"take i FL\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have X_size: \"card (set ?X) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (take i FL)) = i", "using i"], ["proof (prove)\nusing this:\n  i < length FL\n\ngoal (1 subgoal):\n 1. card (set (take i FL)) = i", "by (simp add: distinct_card)"], ["proof (state)\nthis:\n  card (set (take i FL)) = i\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have X_indep: \"indep (set ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indep (set (take i FL))", "using bF"], ["proof (prove)\nusing this:\n  basis F\n\ngoal (1 subgoal):\n 1. indep (set (take i FL))", "using indep_iff_subset_basis set_take_subset"], ["proof (prove)\nusing this:\n  basis F\n  indep ?X = (\\<exists>B. basis B \\<and> ?X \\<subseteq> B)\n  set (take ?n ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. indep (set (take i FL))", "by force"], ["proof (state)\nthis:\n  indep (set (take i FL))\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "let ?Y = \"take (Suc i) BL\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have Y_size: \"card (set ?Y) = Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (take (Suc i) BL)) = Suc i", "using i l"], ["proof (prove)\nusing this:\n  i < length FL\n  length FL = length BL\n\ngoal (1 subgoal):\n 1. card (set (take (Suc i) BL)) = Suc i", "by (simp add: distinct_card)"], ["proof (state)\nthis:\n  card (set (take (Suc i) BL)) = Suc i\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have Y_indep: \"indep (set ?Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indep (set (take (Suc i) BL))", "using bB"], ["proof (prove)\nusing this:\n  basis B\n\ngoal (1 subgoal):\n 1. indep (set (take (Suc i) BL))", "using indep_iff_subset_basis set_take_subset"], ["proof (prove)\nusing this:\n  basis B\n  indep ?X = (\\<exists>B. basis B \\<and> ?X \\<subseteq> B)\n  set (take ?n ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. indep (set (take (Suc i) BL))", "by force"], ["proof (state)\nthis:\n  indep (set (take (Suc i) BL))\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have \"card (set ?X) < card (set ?Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (take i FL)) < card (set (take (Suc i) BL))", "using X_size Y_size"], ["proof (prove)\nusing this:\n  card (set (take i FL)) = i\n  card (set (take (Suc i) BL)) = Suc i\n\ngoal (1 subgoal):\n 1. card (set (take i FL)) < card (set (take (Suc i) BL))", "by simp\n\n  \\<comment> \\<open>X and Y are independent and X is smaller than Y, thus we can augment X with some element x\\<close>"], ["proof (state)\nthis:\n  card (set (take i FL)) < card (set (take (Suc i) BL))\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "with Y_indep X_indep"], ["proof (chain)\npicking this:\n  indep (set (take (Suc i) BL))\n  indep (set (take i FL))\n  card (set (take i FL)) < card (set (take (Suc i) BL))", "obtain x where x: \"x\\<in>set (take (Suc i) BL) - set ?X\"\n    and indepX: \"indep (insert x (set ?X))\""], ["proof (prove)\nusing this:\n  indep (set (take (Suc i) BL))\n  indep (set (take i FL))\n  card (set (take i FL)) < card (set (take (Suc i) BL))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set (take (Suc i) BL) - set (take i FL);\n         indep (insert x (set (take i FL)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using augment"], ["proof (prove)\nusing this:\n  indep (set (take (Suc i) BL))\n  indep (set (take i FL))\n  card (set (take i FL)) < card (set (take (Suc i) BL))\n  \\<lbrakk>indep ?X; indep ?Y; card ?Y < card ?X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>?X - ?Y. indep (insert x ?Y)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set (take (Suc i) BL) - set (take i FL);\n         indep (insert x (set (take i FL)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto\n\n  \\<comment> \\<open>we know many things about x now, i.e. x weights strictly less than the ith element of FL ...\\<close>"], ["proof (state)\nthis:\n  x \\<in> set (take (Suc i) BL) - set (take i FL)\n  indep (insert x (set (take i FL)))\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have \"x\\<in>carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier", "using indepX indep_subset_carrier"], ["proof (prove)\nusing this:\n  indep (insert x (set (take i FL)))\n  indep ?X \\<Longrightarrow> ?X \\<subseteq> carrier\n\ngoal (1 subgoal):\n 1. x \\<in> carrier", "by blast"], ["proof (state)\nthis:\n  x \\<in> carrier\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set (take (Suc i) BL) - set (take i FL)", "have xs: \"x\\<in>set (take (Suc i) BL)\" and xnX: \"x \\<notin> set ?X\""], ["proof (prove)\nusing this:\n  x \\<in> set (take (Suc i) BL) - set (take i FL)\n\ngoal (1 subgoal):\n 1. x \\<in> set (take (Suc i) BL) &&& x \\<notin> set (take i FL)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (take (Suc i) BL)\n  x \\<notin> set (take i FL)\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from xs"], ["proof (chain)\npicking this:\n  x \\<in> set (take (Suc i) BL)", "obtain j where \"x=(take (Suc i) BL)!j\" and ij: \"j\\<le>i\""], ["proof (prove)\nusing this:\n  x \\<in> set (take (Suc i) BL)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x = take (Suc i) BL ! j; j \\<le> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis i in_set_conv_nth l length_take less_Suc_eq_le min_Suc_gt(2))"], ["proof (state)\nthis:\n  x = take (Suc i) BL ! j\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x = take (Suc i) BL ! j\n  j \\<le> i", "have x: \"x=BL!j\""], ["proof (prove)\nusing this:\n  x = take (Suc i) BL ! j\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. x = BL ! j", "by auto"], ["proof (state)\nthis:\n  x = BL ! j\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have il: \"i < length BL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length BL", "using i l"], ["proof (prove)\nusing this:\n  i < length FL\n  length FL = length BL\n\ngoal (1 subgoal):\n 1. i < length BL", "by simp"], ["proof (state)\nthis:\n  i < length BL\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have \"weight x \\<le> weight (BL ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight x \\<le> weight (BL ! i)", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (BL ! j) \\<le> weight (BL ! i)", "apply(rule wsorted_nth_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wsorted BL\n 2. j \\<le> i\n 3. i < length BL", "by fact+"], ["proof (state)\nthis:\n  weight x \\<le> weight (BL ! i)\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  weight x \\<le> weight (BL ! i)", "have k: \"weight x < weight (FL ! i)\""], ["proof (prove)\nusing this:\n  weight x \\<le> weight (BL ! i)\n\ngoal (1 subgoal):\n 1. weight x < weight (FL ! i)", "using gr"], ["proof (prove)\nusing this:\n  weight x \\<le> weight (BL ! i)\n  weight (BL ! i) < weight (FL ! i)\n\ngoal (1 subgoal):\n 1. weight x < weight (FL ! i)", "by auto\n\n  \\<comment> \\<open>... and that adding x to X gives us an independent set\\<close>"], ["proof (state)\nthis:\n  weight x < weight (FL ! i)\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have \"?FL_restricted \\<subseteq> set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limi (set FL) (weight (FL ! i)) \\<subseteq> set (take i FL)", "unfolding  limi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> set FL. weight e < weight (FL ! i)} \\<subseteq> set (take i FL)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set FL; weight x < weight (FL ! i)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (take i FL)", "by (metis (no_types, lifting) i in_set_conv_nth length_take\n              min_simps(2) not_less nth_take wF wsorted_nth_mono)"], ["proof (state)\nthis:\n  limi (set FL) (weight (FL ! i)) \\<subseteq> set (take i FL)\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "have z': \"insert x ?FL_restricted \\<subseteq> insert x (set ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (limi (set FL) (weight (FL ! i)))\n    \\<subseteq> insert x (set (take i FL))", "using xnX \\<open>?FL_restricted \\<subseteq> set (take i FL)\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> set (take i FL)\n  limi (set FL) (weight (FL ! i)) \\<subseteq> set (take i FL)\n\ngoal (1 subgoal):\n 1. insert x (limi (set FL) (weight (FL ! i)))\n    \\<subseteq> insert x (set (take i FL))", "by auto"], ["proof (state)\nthis:\n  insert x (limi (set FL) (weight (FL ! i)))\n  \\<subseteq> insert x (set (take i FL))\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from indep_subset[OF indepX z']"], ["proof (chain)\npicking this:\n  indep (insert x (limi (set FL) (weight (FL ! i))))", "have add_x_stay_indep: \"indep (insert x ?FL_restricted)\""], ["proof (prove)\nusing this:\n  indep (insert x (limi (set FL) (weight (FL ! i))))\n\ngoal (1 subgoal):\n 1. indep (insert x (limi (set FL) (weight (FL ! i))))", ".\n\n  \\<comment> \\<open>... finally this means that we must have taken the element during our greedy algorithm\\<close>"], ["proof (state)\nthis:\n  indep (insert x (limi (set FL) (weight (FL ! i))))\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "from \\<open>no_smallest_element_skipped {} F\\<close>\n      \\<open>x\\<in>carrier\\<close> \\<open>weight x < weight (FL ! i)\\<close> add_x_stay_indep"], ["proof (chain)\npicking this:\n  no_smallest_element_skipped {} F\n  x \\<in> carrier\n  weight x < weight (FL ! i)\n  indep (insert x (limi (set FL) (weight (FL ! i))))", "have \"x \\<in> ?FL_restricted\""], ["proof (prove)\nusing this:\n  no_smallest_element_skipped {} F\n  x \\<in> carrier\n  weight x < weight (FL ! i)\n  indep (insert x (limi (set FL) (weight (FL ! i))))\n\ngoal (1 subgoal):\n 1. x \\<in> limi (set FL) (weight (FL ! i))", "by (auto dest: no_smallest_element_skippedD)"], ["proof (state)\nthis:\n  x \\<in> limi (set FL) (weight (FL ! i))\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "with \\<open>?FL_restricted \\<subseteq> set ?X\\<close>"], ["proof (chain)\npicking this:\n  limi (set FL) (weight (FL ! i)) \\<subseteq> set (take i FL)\n  x \\<in> limi (set FL) (weight (FL ! i))", "have \"x \\<in> set ?X\""], ["proof (prove)\nusing this:\n  limi (set FL) (weight (FL ! i)) \\<subseteq> set (take i FL)\n  x \\<in> limi (set FL) (weight (FL ! i))\n\ngoal (1 subgoal):\n 1. x \\<in> set (take i FL)", "by auto\n\n  \\<comment> \\<open>... but we actually didn't. This finishes our proof by contradiction.\\<close>"], ["proof (state)\nthis:\n  x \\<in> set (take i FL)\n\ngoal (1 subgoal):\n 1. \\<not> minBasis F \\<Longrightarrow> False", "with xnX"], ["proof (chain)\npicking this:\n  x \\<notin> set (take i FL)\n  x \\<in> set (take i FL)", "show \"False\""], ["proof (prove)\nusing this:\n  x \\<notin> set (take i FL)\n  x \\<in> set (take i FL)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"The Invariant\""], ["", "text \\<open>The following predicate is invariant during the execution of the \n  minimum weight basis algorithm, and implies that its result is a minimum weight basis.\\<close>"], ["", "definition I_minWeightBasis where\n  \"I_minWeightBasis == \\<lambda>(T,E). indep T \n                \\<and> T \\<subseteq> carrier\n                 \\<and> E \\<subseteq> carrier  \n                 \\<and> (\\<forall>x\\<in>T.\\<forall>y\\<in>E. weight x \\<le> weight y)\n                \\<and> (\\<forall>e\\<in>carrier-E-T. ~indep (insert e T))\n                 \\<and> no_smallest_element_skipped E T\""], ["", "lemma I_minWeightBasisD: \n  assumes \n   \"I_minWeightBasis (T,E)\"\n shows\"indep T\" \"\\<And>e. e\\<in>carrier-E-T \\<Longrightarrow> ~indep (insert e T)\"\n    \"E \\<subseteq> carrier\" \"\\<And>x y. x\\<in>T \\<Longrightarrow> y\\<in>E \\<Longrightarrow> weight x \\<le> weight y\"  \"T \\<subseteq> carrier\"\n    \"no_smallest_element_skipped E T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (indep T &&&\n     (\\<And>e.\n         e \\<in> carrier - E - T \\<Longrightarrow>\n         \\<not> indep (insert e T)) &&&\n     E \\<subseteq> carrier) &&&\n    (\\<And>x y.\n        \\<lbrakk>x \\<in> T; y \\<in> E\\<rbrakk>\n        \\<Longrightarrow> weight x \\<le> weight y) &&&\n    T \\<subseteq> carrier &&& no_smallest_element_skipped E T", "using assms"], ["proof (prove)\nusing this:\n  I_minWeightBasis (T, E)\n\ngoal (1 subgoal):\n 1. (indep T &&&\n     (\\<And>e.\n         e \\<in> carrier - E - T \\<Longrightarrow>\n         \\<not> indep (insert e T)) &&&\n     E \\<subseteq> carrier) &&&\n    (\\<And>x y.\n        \\<lbrakk>x \\<in> T; y \\<in> E\\<rbrakk>\n        \\<Longrightarrow> weight x \\<le> weight y) &&&\n    T \\<subseteq> carrier &&& no_smallest_element_skipped E T", "by(auto simp: no_smallest_element_skipped_def I_minWeightBasis_def)"], ["", "lemma I_minWeightBasisI:\n  assumes \"indep T\" \"\\<And>e. e\\<in>carrier-E-T \\<Longrightarrow> ~indep (insert e T)\"\n    \"E \\<subseteq> carrier\" \"\\<And>x y. x\\<in>T \\<Longrightarrow> y\\<in>E \\<Longrightarrow> weight x \\<le> weight y\"  \"T \\<subseteq> carrier\"\n    \"no_smallest_element_skipped E T\"\n  shows \"I_minWeightBasis (T,E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_minWeightBasis (T, E)", "using assms"], ["proof (prove)\nusing this:\n  indep T\n  ?e \\<in> carrier - E - T \\<Longrightarrow> \\<not> indep (insert ?e T)\n  E \\<subseteq> carrier\n  \\<lbrakk>?x \\<in> T; ?y \\<in> E\\<rbrakk>\n  \\<Longrightarrow> weight ?x \\<le> weight ?y\n  T \\<subseteq> carrier\n  no_smallest_element_skipped E T\n\ngoal (1 subgoal):\n 1. I_minWeightBasis (T, E)", "by(auto simp: no_smallest_element_skipped_def I_minWeightBasis_def)"], ["", "lemma I_minWeightBasisG: \"I_minWeightBasis (T,E) \\<Longrightarrow> no_smallest_element_skipped E T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_minWeightBasis (T, E) \\<Longrightarrow>\n    no_smallest_element_skipped E T", "by(auto simp: I_minWeightBasis_def)"], ["", "lemma I_minWeightBasis_sorted: \"I_minWeightBasis (T,E) \\<Longrightarrow> (\\<forall>x\\<in>T.\\<forall>y\\<in>E. weight x \\<le> weight y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_minWeightBasis (T, E) \\<Longrightarrow>\n    \\<forall>x\\<in>T. \\<forall>y\\<in>E. weight x \\<le> weight y", "by(auto simp: I_minWeightBasis_def)"], ["", "subsection \\<open>Invariant proofs\\<close>"], ["", "lemma I_minWeightBasis_empty: \"I_minWeightBasis ({}, carrier)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_minWeightBasis ({}, carrier)", "by (auto simp: I_minWeightBasis_def)"], ["", "lemma I_minWeightBasis_final: \"I_minWeightBasis (T, {}) \\<Longrightarrow> minBasis T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_minWeightBasis (T, {}) \\<Longrightarrow> minBasis T", "by(auto simp: greedy_approach_leads_to_minBasis I_minWeightBasis_def)"], ["", "lemma indep_aux:       \n  assumes \"e \\<in> E\" \"\\<forall>e\\<in>carrier - E - F. \\<not> indep (insert e F)\"        \n    and \"x\\<in>carrier - (E - {e}) - insert e F\"\n    shows  \"\\<not> indep (insert x (insert e F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> indep (insert x (insert e F))", "using assms indep_iff_subset_basis"], ["proof (prove)\nusing this:\n  e \\<in> E\n  \\<forall>e\\<in>carrier - E - F. \\<not> indep (insert e F)\n  x \\<in> carrier - (E - {e}) - insert e F\n  indep ?X = (\\<exists>B. basis B \\<and> ?X \\<subseteq> B)\n\ngoal (1 subgoal):\n 1. \\<not> indep (insert x (insert e F))", "by auto"], ["", "lemma preservation_if: \"wsorted x \\<Longrightarrow>   set x = carrier \\<Longrightarrow>\n    x = l1 @ xa # l2 \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set (xa # l2))  \\<Longrightarrow> indep \\<sigma>\n   \\<Longrightarrow> xa \\<in> carrier \\<Longrightarrow> indep (insert xa \\<sigma>) \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)", "apply(rule I_minWeightBasisI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> indep (insert xa \\<sigma>)\n 2. \\<And>e.\n       \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        xa \\<in> carrier; indep (insert xa \\<sigma>);\n        e \\<in> carrier - set l2 - insert xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> indep (insert e (insert xa \\<sigma>))\n 3. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier\n 4. \\<And>xb y.\n       \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        xa \\<in> carrier; indep (insert xa \\<sigma>);\n        xb \\<in> insert xa \\<sigma>; y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 5. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> insert xa \\<sigma> \\<subseteq> carrier\n 6. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2)\n                       (insert xa \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> indep (insert xa \\<sigma>)", "by simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        xa \\<in> carrier; indep (insert xa \\<sigma>);\n        e \\<in> carrier - set l2 - insert xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> indep (insert e (insert xa \\<sigma>))\n 2. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier\n 3. \\<And>xb y.\n       \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        xa \\<in> carrier; indep (insert xa \\<sigma>);\n        xb \\<in> insert xa \\<sigma>; y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 4. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> insert xa \\<sigma> \\<subseteq> carrier\n 5. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2)\n                       (insert xa \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>);\n     e_ \\<in> carrier - set l2 - insert xa \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> indep (insert e_ (insert xa \\<sigma>))", "unfolding I_minWeightBasis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     case (\\<sigma>, set (xa # l2)) of\n     (T, E) \\<Rightarrow>\n       indep T \\<and>\n       T \\<subseteq> carrier \\<and>\n       E \\<subseteq> carrier \\<and>\n       (\\<forall>x\\<in>T. \\<forall>y\\<in>E. weight x \\<le> weight y) \\<and>\n       (\\<forall>e\\<in>carrier - E - T. \\<not> indep (insert e T)) \\<and>\n       no_smallest_element_skipped E T;\n     indep \\<sigma>; xa \\<in> carrier; indep (insert xa \\<sigma>);\n     e_ \\<in> carrier - set l2 - insert xa \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> indep (insert e_ (insert xa \\<sigma>))", "apply(rule indep_aux[where E=\"set (xa # l2)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     case (\\<sigma>, set (xa # l2)) of\n     (T, E) \\<Rightarrow>\n       indep T \\<and>\n       T \\<subseteq> carrier \\<and>\n       E \\<subseteq> carrier \\<and>\n       (\\<forall>x\\<in>T. \\<forall>y\\<in>E. weight x \\<le> weight y) \\<and>\n       (\\<forall>e\\<in>carrier - E - T. \\<not> indep (insert e T)) \\<and>\n       no_smallest_element_skipped E T;\n     indep \\<sigma>; xa \\<in> carrier; indep (insert xa \\<sigma>);\n     e_ \\<in> carrier - set l2 - insert xa \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> xa \\<in> set (xa # l2)\n 2. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     case (\\<sigma>, set (xa # l2)) of\n     (T, E) \\<Rightarrow>\n       indep T \\<and>\n       T \\<subseteq> carrier \\<and>\n       E \\<subseteq> carrier \\<and>\n       (\\<forall>x\\<in>T. \\<forall>y\\<in>E. weight x \\<le> weight y) \\<and>\n       (\\<forall>e\\<in>carrier - E - T. \\<not> indep (insert e T)) \\<and>\n       no_smallest_element_skipped E T;\n     indep \\<sigma>; xa \\<in> carrier; indep (insert xa \\<sigma>);\n     e_ \\<in> carrier - set l2 - insert xa \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e\\<in>carrier - set (xa # l2) - \\<sigma>.\n                         \\<not> indep (insert e \\<sigma>)\n 3. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     case (\\<sigma>, set (xa # l2)) of\n     (T, E) \\<Rightarrow>\n       indep T \\<and>\n       T \\<subseteq> carrier \\<and>\n       E \\<subseteq> carrier \\<and>\n       (\\<forall>x\\<in>T. \\<forall>y\\<in>E. weight x \\<le> weight y) \\<and>\n       (\\<forall>e\\<in>carrier - E - T. \\<not> indep (insert e T)) \\<and>\n       no_smallest_element_skipped E T;\n     indep \\<sigma>; xa \\<in> carrier; indep (insert xa \\<sigma>);\n     e_ \\<in> carrier - set l2 - insert xa \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> e_ \\<in> carrier - (set (xa # l2) - {xa}) -\n                               insert xa \\<sigma>", "by simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier\n 2. \\<And>xb y.\n       \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        xa \\<in> carrier; indep (insert xa \\<sigma>);\n        xb \\<in> insert xa \\<sigma>; y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 3. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> insert xa \\<sigma> \\<subseteq> carrier\n 4. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2)\n                       (insert xa \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xb y.\n       \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        xa \\<in> carrier; indep (insert xa \\<sigma>);\n        xb \\<in> insert xa \\<sigma>; y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 2. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> insert xa \\<sigma> \\<subseteq> carrier\n 3. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2)\n                       (insert xa \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>);\n     xb_ \\<in> insert xa \\<sigma>; y_ \\<in> set l2\\<rbrakk>\n    \\<Longrightarrow> weight xb_ \\<le> weight y_", "by (metis insert_iff list.set(2) I_minWeightBasis_sorted\n        sorted_wrt_append sorted_wrt.simps(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> insert xa \\<sigma> \\<subseteq> carrier\n 2. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2)\n                       (insert xa \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> insert xa \\<sigma> \\<subseteq> carrier", "by(auto simp: I_minWeightBasis_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2)\n                       (insert xa \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2)\n                       (insert xa \\<sigma>)", "apply (rule no_smallest_element_skipped_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x; set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     xa \\<in> carrier; indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2 \\<union> {xa})\n                       \\<sigma>", "by(auto intro!:  simp: I_minWeightBasis_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma preservation_else: \"set x = carrier \\<Longrightarrow>\n    x = l1 @ xa # l2 \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set (xa # l2))\n     \\<Longrightarrow> indep \\<sigma>   \\<Longrightarrow> \\<not> indep (insert xa \\<sigma>) \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)", "apply(rule I_minWeightBasisI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> indep \\<sigma>\n 2. \\<And>e.\n       \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        \\<not> indep (insert xa \\<sigma>);\n        e \\<in> carrier - set l2 - \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> indep (insert e \\<sigma>)\n 3. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier\n 4. \\<And>xb y.\n       \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        \\<not> indep (insert xa \\<sigma>); xb \\<in> \\<sigma>;\n        y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 5. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 6. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2) \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> indep \\<sigma>", "by simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        \\<not> indep (insert xa \\<sigma>);\n        e \\<in> carrier - set l2 - \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> indep (insert e \\<sigma>)\n 2. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier\n 3. \\<And>xb y.\n       \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        \\<not> indep (insert xa \\<sigma>); xb \\<in> \\<sigma>;\n        y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 4. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 5. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2) \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>);\n     e_ \\<in> carrier - set l2 - \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> indep (insert e_ \\<sigma>)", "by (auto simp: DiffD2 I_minWeightBasis_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier\n 2. \\<And>xb y.\n       \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        \\<not> indep (insert xa \\<sigma>); xb \\<in> \\<sigma>;\n        y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 3. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 4. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2) \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> set l2 \\<subseteq> carrier", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xb y.\n       \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n        I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n        \\<not> indep (insert xa \\<sigma>); xb \\<in> \\<sigma>;\n        y \\<in> set l2\\<rbrakk>\n       \\<Longrightarrow> weight xb \\<le> weight y\n 2. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 3. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2) \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>); xb_ \\<in> \\<sigma>;\n     y_ \\<in> set l2\\<rbrakk>\n    \\<Longrightarrow> weight xb_ \\<le> weight y_", "by(auto simp: I_minWeightBasis_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 2. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2) \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> \\<subseteq> carrier", "by(auto simp: I_minWeightBasis_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2) \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2) \\<sigma>", "apply (rule no_smallest_element_skipped_skip)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> indep (insert ?e \\<sigma>)\n 2. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> no_smallest_element_skipped (set l2 \\<union> {?e})\n                       \\<sigma>\n 3. \\<lbrakk>set x = carrier; x = l1 @ xa # l2;\n     I_minWeightBasis (\\<sigma>, set (xa # l2)); indep \\<sigma>;\n     \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<sigma>.\n                         \\<forall>y\\<in>set l2 \\<union> {?e}.\n                            weight x \\<le> weight y", "by(auto intro!:  simp: I_minWeightBasis_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>The refinement lemma\\<close>"], ["", "theorem minWeightBasis_refine: \"(minWeightBasis, SPEC minBasis)\\<in>\\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (minWeightBasis, SPEC minBasis) \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding minWeightBasis_def obtain_sorted_carrier_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>L. wsorted L \\<and> set L = carrier) \\<bind>\n     (\\<lambda>l.\n         ASSERT (set l = carrier) \\<bind>\n         (\\<lambda>_.\n             nfoldli l (\\<lambda>_. True)\n              (\\<lambda>e T.\n                  ASSERT\n                   (indep T \\<and>\n                    e \\<in> carrier \\<and> T \\<subseteq> carrier) \\<bind>\n                  (\\<lambda>_.\n                      if indep (insert e T) then RETURN (insert e T)\n                      else RETURN T))\n              {} \\<bind>\n             RETURN)),\n     SPEC minBasis)\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "apply(refine_vcg nfoldli_rule[where I=\"\\<lambda>l1 l2 s. I_minWeightBasis (s,set l2)\"])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       wsorted x \\<and> set x = carrier \\<Longrightarrow> set x = carrier\n 2. \\<And>x.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis ({}, set x)\n 3. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> indep \\<sigma>\n 4. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> carrier\n 5. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 6. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\n 7. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\n 8. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 9. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. wsorted x_ \\<and> set x_ = carrier \\<Longrightarrow> set x_ = carrier", "by auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis ({}, set x)\n 2. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> indep \\<sigma>\n 3. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> carrier\n 4. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 5. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\n 6. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\n 7. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 8. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier\\<rbrakk>\n    \\<Longrightarrow> I_minWeightBasis ({}, set x_)", "by (auto simp: I_minWeightBasis_empty)\n      \\<comment> \\<open>asserts\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> indep \\<sigma>\n 2. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> carrier\n 3. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 4. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\n 5. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\n 6. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 7. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True\\<rbrakk>\n    \\<Longrightarrow> indep \\<sigma>_", "by (auto simp: I_minWeightBasis_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> carrier\n 2. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 3. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\n 4. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\n 5. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 6. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True\\<rbrakk>\n    \\<Longrightarrow> xa_ \\<in> carrier", "by (auto simp: I_minWeightBasis_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2));\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<subseteq> carrier\n 2. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\n 3. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\n 4. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 5. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>_ \\<subseteq> carrier", "by (auto simp: I_minWeightBasis_def)   \n      \\<comment> \\<open>branches\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (insert xa \\<sigma>, set l2)\n 2. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\n 3. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 4. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> I_minWeightBasis (insert xa_ \\<sigma>_, set l2_)", "apply(rule preservation_if)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> wsorted ?x\n 2. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> set ?x = carrier\n 3. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> ?x = ?l1.0 @ xa_ # l2_\n 4. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> I_minWeightBasis (\\<sigma>_, set (xa_ # l2_))\n 5. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> indep \\<sigma>_\n 6. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> xa_ \\<in> carrier\n 7. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> indep (insert xa_ \\<sigma>_)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ xa # l2; I_minWeightBasis (\\<sigma>, set (xa # l2)); True;\n        indep \\<sigma> \\<and>\n        xa \\<in> carrier \\<and> \\<sigma> \\<subseteq> carrier;\n        \\<not> indep (insert xa \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> I_minWeightBasis (\\<sigma>, set l2)\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 3. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     \\<not> indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> I_minWeightBasis (\\<sigma>_, set l2_)", "apply(rule preservation_else)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     \\<not> indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> set ?x = carrier\n 2. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     \\<not> indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> ?x = ?l1.0 @ ?xa # l2_\n 3. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     \\<not> indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> I_minWeightBasis (\\<sigma>_, set (?xa # l2_))\n 4. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     \\<not> indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> indep \\<sigma>_\n 5. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ xa_ # l2_; I_minWeightBasis (\\<sigma>_, set (xa_ # l2_));\n     True;\n     indep \\<sigma>_ \\<and>\n     xa_ \\<in> carrier \\<and> \\<sigma>_ \\<subseteq> carrier;\n     \\<not> indep (insert xa_ \\<sigma>_)\\<rbrakk>\n    \\<Longrightarrow> \\<not> indep (insert ?xa \\<sigma>_)", "by auto  \n      \\<comment> \\<open>final\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        x = l1 @ l2; I_minWeightBasis (\\<sigma>, set l2);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     x_ = l1_ @ l2_; I_minWeightBasis (\\<sigma>_, set l2_);\n     \\<not> True\\<rbrakk>\n    \\<Longrightarrow> minBasis \\<sigma>_", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>wsorted x \\<and> set x = carrier; set x = carrier;\n        I_minWeightBasis (\\<sigma>, set []); True\\<rbrakk>\n       \\<Longrightarrow> minBasis \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wsorted x_ \\<and> set x_ = carrier; set x_ = carrier;\n     I_minWeightBasis (\\<sigma>_, set []); True\\<rbrakk>\n    \\<Longrightarrow> minBasis \\<sigma>_", "by (auto simp: I_minWeightBasis_final)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>locale minWeightBasis\\<close>"], ["", "end"]]}