{"file_name": "/home/qj213/afp-2021-10-22/thys/Kruskal/SeprefUF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kruskal", "problem_names": ["lemma per_init_of_nat_range: \"per_init {i. i<N} = per_init' N\"", "lemma per_init_per[simp, intro!]:\n    \"part_equiv (per_init D)\"", "lemma per_init_self: \"(a,b)\\<in>per_init D \\<Longrightarrow> a=b\"", "lemma per_union_impl: \"(i,j)\\<in>R \\<Longrightarrow> (i,j)\\<in>per_union R a b\"", "lemma per_union_related:\n    \"part_equiv R \\<Longrightarrow> a\\<in>Domain R \\<Longrightarrow> b\\<in>Domain  R \\<Longrightarrow> (a,b)\\<in>per_union R a b\"", "lemma part_equiv_refl':\n    \"part_equiv R \\<Longrightarrow> x\\<in>Domain R \\<Longrightarrow> (x,x)\\<in>R\"", "lemma per_supset_rel_dom: \"(p1, p2) \\<in> per_supset_rel \\<Longrightarrow> Domain p1 \\<supseteq> Domain p2\"", "lemma per_supset_compare:\n    \"(p1, p2) \\<in> per_supset_rel \\<Longrightarrow> x1\\<in>Domain p2 \\<Longrightarrow> x2\\<in>Domain p2 \\<Longrightarrow> per_compare p1 x1 x2 \\<longleftrightarrow> per_compare p2 x1 x2\"", "lemma per_supset_union: \"(p1, p2) \\<in> per_supset_rel \\<Longrightarrow> x1\\<in>Domain p2 \\<Longrightarrow> x2\\<in>Domain p2 \\<Longrightarrow>\n    (per_union p1 x1 x2, per_union p2 x1 x2) \\<in> per_supset_rel\"", "lemma per_init_Domain[simp]: \"Domain (per_init D) = D\"", "lemma per_init'_Domain[simp]: \"Domain (per_init' N) = {i. i<N}\"", "lemma per_init'_sepref_rule[sepref_fr_rules]: \"(uf_init,RETURN o per_init') \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_uf\"", "lemma per_compare_sepref_rule[sepref_fr_rules]: \"(uncurry2 uf_cmp, uncurry2 (RETURN ooo per_compare)) \\<in>\n    is_uf\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma per_union_sepref_rule[sepref_fr_rules]: \"(uncurry2 uf_union, uncurry2 (RETURN ooo per_union)) \\<in>\n    [\\<lambda>((R,i),j). i\\<in>Domain R \\<and> j\\<in>Domain R ]\\<^sub>a is_uf\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> is_uf\""], "translations": [["", "lemma per_init_of_nat_range: \"per_init {i. i<N} = per_init' N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. per_init {i. i < N} = per_init' N", "by (auto simp: per_init_def per_init'_def)"], ["", "lemma per_init_per[simp, intro!]:\n    \"part_equiv (per_init D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_equiv (per_init D)", "unfolding per_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. part_equiv {(i, i) |i. i \\<in> D}", "by (auto simp: part_equiv_def sym_def trans_def)"], ["", "lemma per_init_self: \"(a,b)\\<in>per_init D \\<Longrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> per_init D \\<Longrightarrow> a = b", "unfolding per_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> {(i, i) |i. i \\<in> D} \\<Longrightarrow> a = b", "by simp"], ["", "lemma per_union_impl: \"(i,j)\\<in>R \\<Longrightarrow> (i,j)\\<in>per_union R a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, j) \\<in> R \\<Longrightarrow> (i, j) \\<in> per_union R a b", "by (auto simp: per_union_def)"], ["", "lemma per_union_related:\n    \"part_equiv R \\<Longrightarrow> a\\<in>Domain R \\<Longrightarrow> b\\<in>Domain  R \\<Longrightarrow> (a,b)\\<in>per_union R a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>part_equiv R; a \\<in> Domain R; b \\<in> Domain R\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> per_union R a b", "unfolding per_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>part_equiv R; a \\<in> Domain R; b \\<in> Domain R\\<rbrakk>\n    \\<Longrightarrow> (a, b)\n                      \\<in> R \\<union>\n                            {(x, y).\n                             (x, a) \\<in> R \\<and> (y, b) \\<in> R} \\<union>\n                            {(y, x). (x, a) \\<in> R \\<and> (y, b) \\<in> R}", "by (auto simp: part_equiv_refl)"], ["", "lemma part_equiv_refl':\n    \"part_equiv R \\<Longrightarrow> x\\<in>Domain R \\<Longrightarrow> (x,x)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>part_equiv R; x \\<in> Domain R\\<rbrakk>\n    \\<Longrightarrow> (x, x) \\<in> R", "using part_equiv_refl[of R x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>part_equiv R; (x, ?y) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (x, x) \\<in> R\n  \\<lbrakk>part_equiv R; (x, ?y) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (?y, ?y) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>part_equiv R; x \\<in> Domain R\\<rbrakk>\n    \\<Longrightarrow> (x, x) \\<in> R", "by blast"], ["", "definition per_supset_rel :: \"('a per \\<times> 'a per) set\" where\n    \"per_supset_rel\n      \\<equiv> {(p1,p2). p1 \\<inter> Domain p2 \\<times> Domain p2 = p2 \\<and> p1 - (Domain p2 \\<times> Domain p2) \\<subseteq> Id}\""], ["", "lemma per_supset_rel_dom: \"(p1, p2) \\<in> per_supset_rel \\<Longrightarrow> Domain p1 \\<supseteq> Domain p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p1, p2) \\<in> per_supset_rel \\<Longrightarrow>\n    Domain p2 \\<subseteq> Domain p1", "by (auto simp: per_supset_rel_def)"], ["", "lemma per_supset_compare:\n    \"(p1, p2) \\<in> per_supset_rel \\<Longrightarrow> x1\\<in>Domain p2 \\<Longrightarrow> x2\\<in>Domain p2 \\<Longrightarrow> per_compare p1 x1 x2 \\<longleftrightarrow> per_compare p2 x1 x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p1, p2) \\<in> per_supset_rel; x1 \\<in> Domain p2;\n     x2 \\<in> Domain p2\\<rbrakk>\n    \\<Longrightarrow> per_compare p1 x1 x2 = per_compare p2 x1 x2", "by (auto simp: per_supset_rel_def)"], ["", "lemma per_supset_union: \"(p1, p2) \\<in> per_supset_rel \\<Longrightarrow> x1\\<in>Domain p2 \\<Longrightarrow> x2\\<in>Domain p2 \\<Longrightarrow>\n    (per_union p1 x1 x2, per_union p2 x1 x2) \\<in> per_supset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p1, p2) \\<in> per_supset_rel; x1 \\<in> Domain p2;\n     x2 \\<in> Domain p2\\<rbrakk>\n    \\<Longrightarrow> (per_union p1 x1 x2, per_union p2 x1 x2)\n                      \\<in> per_supset_rel", "apply (clarsimp simp: per_supset_rel_def per_union_def Domain_unfold )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya.\n       \\<lbrakk>(x1, y) \\<in> p2; (x2, ya) \\<in> p2;\n        Restr p1 {x. \\<exists>y. (x, y) \\<in> p2} = p2;\n        p1 -\n        {x. \\<exists>y. (x, y) \\<in> p2} \\<times>\n        {x. \\<exists>y. (x, y) \\<in> p2}\n        \\<subseteq> Id\\<rbrakk>\n       \\<Longrightarrow> Restr\n                          (p1 \\<union>\n                           {x. (x, x1) \\<in> p1} \\<times>\n                           {y. (y, x2) \\<in> p1} \\<union>\n                           {(y, x).\n                            (x, x1) \\<in> p1 \\<and> (y, x2) \\<in> p1})\n                          {x. \\<exists>y.\n                                 (x, y) \\<in> p2 \\<or>\n                                 (x, x1) \\<in> p2 \\<and>\n                                 (y, x2) \\<in> p2 \\<or>\n                                 (y, x1) \\<in> p2 \\<and> (x, x2) \\<in> p2} =\n                         p2 \\<union>\n                         {x. (x, x1) \\<in> p2} \\<times>\n                         {y. (y, x2) \\<in> p2} \\<union>\n                         {(y, x).\n                          (x, x1) \\<in> p2 \\<and> (y, x2) \\<in> p2} \\<and>\n                         p1 \\<union>\n                         {x. (x, x1) \\<in> p1} \\<times>\n                         {y. (y, x2) \\<in> p1} \\<union>\n                         {(y, x).\n                          (x, x1) \\<in> p1 \\<and> (y, x2) \\<in> p1} -\n                         {x. \\<exists>y.\n                                (x, y) \\<in> p2 \\<or>\n                                (x, x1) \\<in> p2 \\<and>\n                                (y, x2) \\<in> p2 \\<or>\n                                (y, x1) \\<in> p2 \\<and>\n                                (x, x2) \\<in> p2} \\<times>\n                         {x. \\<exists>y.\n                                (x, y) \\<in> p2 \\<or>\n                                (x, x1) \\<in> p2 \\<and>\n                                (y, x2) \\<in> p2 \\<or>\n                                (y, x1) \\<in> p2 \\<and> (x, x2) \\<in> p2}\n                         \\<subseteq> Id", "apply (intro subsetI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y ya.\n       \\<lbrakk>(x1, y) \\<in> p2; (x2, ya) \\<in> p2;\n        Restr p1 {x. \\<exists>y. (x, y) \\<in> p2} = p2;\n        p1 -\n        {x. \\<exists>y. (x, y) \\<in> p2} \\<times>\n        {x. \\<exists>y. (x, y) \\<in> p2}\n        \\<subseteq> Id\\<rbrakk>\n       \\<Longrightarrow> Restr\n                          (p1 \\<union>\n                           {x. (x, x1) \\<in> p1} \\<times>\n                           {y. (y, x2) \\<in> p1} \\<union>\n                           {(y, x).\n                            (x, x1) \\<in> p1 \\<and> (y, x2) \\<in> p1})\n                          {x. \\<exists>y.\n                                 (x, y) \\<in> p2 \\<or>\n                                 (x, x1) \\<in> p2 \\<and>\n                                 (y, x2) \\<in> p2 \\<or>\n                                 (y, x1) \\<in> p2 \\<and> (x, x2) \\<in> p2} =\n                         p2 \\<union>\n                         {x. (x, x1) \\<in> p2} \\<times>\n                         {y. (y, x2) \\<in> p2} \\<union>\n                         {(y, x). (x, x1) \\<in> p2 \\<and> (y, x2) \\<in> p2}\n 2. \\<And>y ya x.\n       \\<lbrakk>(x1, y) \\<in> p2; (x2, ya) \\<in> p2;\n        Restr p1 {x. \\<exists>y. (x, y) \\<in> p2} = p2;\n        p1 -\n        {x. \\<exists>y. (x, y) \\<in> p2} \\<times>\n        {x. \\<exists>y. (x, y) \\<in> p2}\n        \\<subseteq> Id;\n        x \\<in> p1 \\<union>\n                {x. (x, x1) \\<in> p1} \\<times>\n                {y. (y, x2) \\<in> p1} \\<union>\n                {(y, x). (x, x1) \\<in> p1 \\<and> (y, x2) \\<in> p1} -\n                {x. \\<exists>y.\n                       (x, y) \\<in> p2 \\<or>\n                       (x, x1) \\<in> p2 \\<and> (y, x2) \\<in> p2 \\<or>\n                       (y, x1) \\<in> p2 \\<and> (x, x2) \\<in> p2} \\<times>\n                {x. \\<exists>y.\n                       (x, y) \\<in> p2 \\<or>\n                       (x, x1) \\<in> p2 \\<and> (y, x2) \\<in> p2 \\<or>\n                       (y, x1) \\<in> p2 \\<and> (x, x2) \\<in> p2}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Id", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya x.\n       \\<lbrakk>(x1, y) \\<in> p2; (x2, ya) \\<in> p2;\n        Restr p1 {x. \\<exists>y. (x, y) \\<in> p2} = p2;\n        p1 -\n        {x. \\<exists>y. (x, y) \\<in> p2} \\<times>\n        {x. \\<exists>y. (x, y) \\<in> p2}\n        \\<subseteq> Id;\n        x \\<in> p1 \\<union>\n                {x. (x, x1) \\<in> p1} \\<times>\n                {y. (y, x2) \\<in> p1} \\<union>\n                {(y, x). (x, x1) \\<in> p1 \\<and> (y, x2) \\<in> p1} -\n                {x. \\<exists>y.\n                       (x, y) \\<in> p2 \\<or>\n                       (x, x1) \\<in> p2 \\<and> (y, x2) \\<in> p2 \\<or>\n                       (y, x1) \\<in> p2 \\<and> (x, x2) \\<in> p2} \\<times>\n                {x. \\<exists>y.\n                       (x, y) \\<in> p2 \\<or>\n                       (x, x1) \\<in> p2 \\<and> (y, x2) \\<in> p2 \\<or>\n                       (y, x1) \\<in> p2 \\<and> (x, x2) \\<in> p2}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Id", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_register per_init per_init' per_compare per_union"], ["", "lemma per_init_Domain[simp]: \"Domain (per_init D) = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (per_init D) = D", "by (auto simp: per_init_def)"], ["", "lemma per_init'_Domain[simp]: \"Domain (per_init' N) = {i. i<N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (per_init' N) = {i. i < N}", "by (auto simp: per_init'_def)"], ["", "lemma per_init'_sepref_rule[sepref_fr_rules]: \"(uf_init,RETURN o per_init') \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_uf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uf_init, RETURN \\<circ> per_init')\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_uf", "unfolding per_init'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uf_init, RETURN \\<circ> (\\<lambda>n. {(i, i) |i. i < n}))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_uf", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat);\n        nofail (RETURN {(i, i) |i. i < x})\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> nat_rel)> uf_init\n       xi <\\<lambda>r.\n              \\<up> ((xi, x) \\<in> nat_rel) *\n              (\\<exists>\\<^sub>Axa.\n                  is_uf xa r *\n                  \\<up>\n                   (RETURN xa \\<le> RETURN {(i, i) |i. i < x}))>\\<^sub>t", "by sep_auto"], ["", "lemma per_compare_sepref_rule[sepref_fr_rules]: \"(uncurry2 uf_cmp, uncurry2 (RETURN ooo per_compare)) \\<in>\n    is_uf\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 uf_cmp, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> per_compare))\n    \\<in> is_uf\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding per_compare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 uf_cmp,\n     uncurry2 (\\<lambda>x xa. RETURN \\<circ> (\\<lambda>b. (xa, b) \\<in> x)))\n    \\<in> is_uf\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE((nat \\<times> nat) set);\n        ba ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat);\n        nofail (RETURN ((ba, b) \\<in> a))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          is_uf a\n                           ai> uf_cmp ai bia\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * \\<up> ((bia, ba) \\<in> nat_rel) *\n is_uf a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> bool_rel) *\n     \\<up> (RETURN x \\<le> RETURN ((ba, b) \\<in> a)))>\\<^sub>t", "by sep_auto"], ["", "lemma per_union_sepref_rule[sepref_fr_rules]: \"(uncurry2 uf_union, uncurry2 (RETURN ooo per_union)) \\<in>\n    [\\<lambda>((R,i),j). i\\<in>Domain R \\<and> j\\<in>Domain R ]\\<^sub>a is_uf\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> is_uf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 uf_union, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> per_union))\n    \\<in> [\\<lambda>((R, i), j).\n              i \\<in> Domain R \\<and>\n              j \\<in> Domain\n                       R]\\<^sub>a is_uf\\<^sup>d *\\<^sub>a\n                                  nat_assn\\<^sup>k *\\<^sub>a\n                                  nat_assn\\<^sup>k \\<rightarrow> is_uf", "unfolding per_compare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 uf_union, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> per_union))\n    \\<in> [\\<lambda>((R, i), j).\n              i \\<in> Domain R \\<and>\n              j \\<in> Domain\n                       R]\\<^sub>a is_uf\\<^sup>d *\\<^sub>a\n                                  nat_assn\\<^sup>k *\\<^sub>a\n                                  nat_assn\\<^sup>k \\<rightarrow> is_uf", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>ba \\<in> Domain a; b \\<in> Domain a;\n        a ::\\<^sub>i TYPE((nat \\<times> nat) set); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat); nofail (RETURN (per_union a ba b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          is_uf a\n                           ai> uf_union ai bia\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * \\<up> ((bia, ba) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     is_uf x r * \\<up> (RETURN x \\<le> RETURN (per_union a ba b)))>\\<^sub>t", "by sep_auto"], ["", "definition \"abs_test \\<equiv> do {\n    let u = per_init' (5::nat);\n    let u = per_union u 1 2;\n    let u = per_union u 2 3;\n    RETURN (per_compare u 1 3)\n  }\""], ["", "sepref_definition abs_test_impl is \"uncurry0 abs_test\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 abs_test)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding abs_test_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let u = per_init' 5; u = per_union u 1 2; u = per_union u 2 3\n       in RETURN (per_compare u 1 3)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "end"]]}