{"file_name": "/home/qj213/afp-2021-10-22/thys/Kruskal/Graph_Definition_Aux.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kruskal", "problem_names": ["lemma  nodes_connected_sym: \"nodes_connected G a b = nodes_connected G b a\"", "lemma  Domain_nodes_connected: \"Domain {(x, y) |x y. nodes_connected G x y} = V\"", "lemma  Range_nodes_connected: \"Range {(x, y) |x y. nodes_connected G x y} = V\"", "lemma   nodes_connected_insert_per_union:\n  \"(nodes_connected (add_edge a w b H) x y) \\<longleftrightarrow> (x,y) \\<in> per_union {(x,y)| x y. nodes_connected H x y} a b\"\n  if  \"subgraph H G\" and PER: \"part_equiv {(x,y)| x y. nodes_connected H x y}\"\n    and V: \"a\\<in>V\" \"b\\<in>V\" for x y", "lemma  is_path_undir_append: \"is_path_undir G v p1 u \\<Longrightarrow> is_path_undir G u p2 w\n      \\<Longrightarrow> is_path_undir G v (p1@p2) w\"", "lemma \n  augment_edge:\n  assumes sg: \"subgraph G1 G\" \"subgraph G2 G\" and\n    p: \"(u, v) \\<in> {(a, b) |a b. nodes_connected G1 a b}\"\n  and notinE2:  \"(u, v) \\<notin> {(a, b) |a b. nodes_connected G2 a b}\"\n\nshows \"\\<exists>a b e. (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and> e \\<notin> edges G2 \\<and> e \\<in> edges G1 \\<and> (case e of (aa, w, ba) \\<Rightarrow> a=aa \\<and> b=ba \\<or> a=ba \\<and> b=aa)\"", "lemma  nodes_connected_refl: \"a\\<in>V \\<Longrightarrow> nodes_connected G a a\"", "lemma assumes sg: \"subgraph H G\"\n  shows connected_VV: \"{(x, y) |x y. nodes_connected H x y} \\<subseteq> V\\<times>V\"\n    and connected_refl: \"refl_on V {(x, y) |x y. nodes_connected H x y}\"\n    and connected_trans: \"trans {(x, y) |x y. nodes_connected H x y}\"\n    and connected_sym: \"sym {(x, y) |x y. nodes_connected H x y}\"\n    and connected_equiv: \"equiv V {(x, y) |x y. nodes_connected H x y}\"", "lemma  forest_maximally_connected_incl_max1:\n  assumes\n    \"forest H\"\n    \"subgraph H G\"                                                                \n  shows \"(\\<forall>(a,w,b)\\<in>edges G - edges H. \\<not> (forest (add_edge a w b H))) \\<Longrightarrow> maximally_connected H G\"", "lemma   forest_maximally_connected_incl_max2:\n  assumes\n    \"forest H\"\n    \"subgraph H G\"\n  shows \"maximally_connected H G \\<Longrightarrow> (\\<forall>(a,w,b)\\<in>E - edges H. \\<not> (forest (add_edge a w b H)))\"", "lemma  forest_maximally_connected_incl_max_conv:\n  assumes\n    \"forest H\"\n    \"subgraph H G\"\n  shows \"maximally_connected H G = (\\<forall>(a,w,b)\\<in>E - edges H. \\<not> (forest (add_edge a w b H)))\""], "translations": [["", "lemma  nodes_connected_sym: \"nodes_connected G a b = nodes_connected G b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G a b = nodes_connected G b a", "using is_path_undir_sym"], ["proof (prove)\nusing this:\n  is_path_undir G ?v ?p ?v' \\<Longrightarrow>\n  is_path_undir G ?v' (rev (map (\\<lambda>(u, w, u'). (u', w, u)) ?p)) ?v\n\ngoal (1 subgoal):\n 1. nodes_connected G a b = nodes_connected G b a", "by auto"], ["", "lemma  Domain_nodes_connected: \"Domain {(x, y) |x y. nodes_connected G x y} = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain {(x, y) |x y. nodes_connected G x y} = V", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> \\<exists>y. nodes_connected G x y", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V \\<Longrightarrow> \\<exists>y. nodes_connected G x y", "apply(rule exI[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V \\<Longrightarrow> nodes_connected G x x", "apply(rule exI[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V \\<Longrightarrow> is_path_undir G x [] x", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  Range_nodes_connected: \"Range {(x, y) |x y. nodes_connected G x y} = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range {(x, y) |x y. nodes_connected G x y} = V", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> \\<exists>xa. nodes_connected G xa x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V \\<Longrightarrow> \\<exists>xa. nodes_connected G xa x", "apply(rule exI[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V \\<Longrightarrow> nodes_connected G x x", "apply(rule exI[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V \\<Longrightarrow> is_path_undir G x [] x", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>adaptation of a proof by Julian Biendarra\\<close>"], ["", "lemma   nodes_connected_insert_per_union:\n  \"(nodes_connected (add_edge a w b H) x y) \\<longleftrightarrow> (x,y) \\<in> per_union {(x,y)| x y. nodes_connected H x y} a b\"\n  if  \"subgraph H G\" and PER: \"part_equiv {(x,y)| x y. nodes_connected H x y}\"\n    and V: \"a\\<in>V\" \"b\\<in>V\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "let ?uf = \"{(x,y)| x y. nodes_connected H x y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "from valid_subgraph[OF \\<open>subgraph H G\\<close>]"], ["proof (chain)\npicking this:\n  valid_graph H", "have valid_H: \"valid_graph H\""], ["proof (prove)\nusing this:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. valid_graph H", "."], ["proof (state)\nthis:\n  valid_graph H\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "from \\<open>subgraph H G\\<close>"], ["proof (chain)\npicking this:\n  subgraph H G", "have nodes_H: \"nodes H = V\""], ["proof (prove)\nusing this:\n  subgraph H G\n\ngoal (1 subgoal):\n 1. nodes H = V", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n\ngoal (1 subgoal):\n 1. nodes H = V", ".."], ["proof (state)\nthis:\n  nodes H = V\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "with \\<open>a\\<in>V\\<close> \\<open>b\\<in>V\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  nodes H = V", "have nodes_add_H: \"nodes (add_edge a w b H) = nodes H\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  nodes H = V\n\ngoal (1 subgoal):\n 1. nodes (add_edge a w b H) = nodes H", "by auto"], ["proof (state)\nthis:\n  nodes (add_edge a w b H) = nodes H\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "have \"Domain ?uf = nodes H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain {(x, y) |x y. nodes_connected H x y} = nodes H", "using valid_graph.Domain_nodes_connected[OF valid_H]"], ["proof (prove)\nusing this:\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n\ngoal (1 subgoal):\n 1. Domain {(x, y) |x y. nodes_connected H x y} = nodes H", "."], ["proof (state)\nthis:\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y =\n    ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nodes_connected (add_edge a w b H) x y \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "assume \"nodes_connected (add_edge a w b H) x y\""], ["proof (state)\nthis:\n  nodes_connected (add_edge a w b H) x y\n\ngoal (2 subgoals):\n 1. nodes_connected (add_edge a w b H) x y \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "then"], ["proof (chain)\npicking this:\n  nodes_connected (add_edge a w b H) x y", "obtain p where p: \"is_path_undir (add_edge a w b H) x p y\""], ["proof (prove)\nusing this:\n  nodes_connected (add_edge a w b H) x y\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir (add_edge a w b H) x p y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b H) x p y\n\ngoal (2 subgoals):\n 1. nodes_connected (add_edge a w b H) x y \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "from \\<open>a\\<in>V\\<close> \\<open>b\\<in>V\\<close> \\<open>Domain {(x,y)| x y. nodes_connected H x y} = nodes H\\<close> nodes_H"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  nodes H = V", "have [simp]: \"a\\<in>Domain (per_union ?uf a b)\" \"b\\<in>Domain (per_union ?uf a b)\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  nodes H = V\n\ngoal (1 subgoal):\n 1. a \\<in> Domain (per_union {(x, y) |x y. nodes_connected H x y} a b) &&&\n    b \\<in> Domain (per_union {(x, y) |x y. nodes_connected H x y} a b)", "by auto"], ["proof (state)\nthis:\n  a \\<in> Domain (per_union {(x, y) |x y. nodes_connected H x y} a b)\n  b \\<in> Domain (per_union {(x, y) |x y. nodes_connected H x y} a b)\n\ngoal (2 subgoals):\n 1. nodes_connected (add_edge a w b H) x y \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "from PER"], ["proof (chain)\npicking this:\n  part_equiv {(x, y) |x y. nodes_connected H x y}", "have PER': \"part_equiv (per_union ?uf a b)\""], ["proof (prove)\nusing this:\n  part_equiv {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. part_equiv (per_union {(x, y) |x y. nodes_connected H x y} a b)", "by (auto simp: union_part_equivp)"], ["proof (state)\nthis:\n  part_equiv (per_union {(x, y) |x y. nodes_connected H x y} a b)\n\ngoal (2 subgoals):\n 1. nodes_connected (add_edge a w b H) x y \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "show \"(x,y) \\<in> per_union ?uf a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "proof (cases \"(a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "case True"], ["proof (state)\nthis:\n  (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "from valid_graph.is_path_undir_split_distinct[OF add_edge_valid[OF valid_H] p True]"], ["proof (chain)\npicking this:\n  \\<exists>p' p'' u u'.\n     is_path_undir (add_edge a w b H) x p' u \\<and>\n     is_path_undir (add_edge a w b H) u' p'' y \\<and>\n     length p' < length p \\<and>\n     length p'' < length p \\<and>\n     (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n     (a, w, b) \\<notin> set p' \\<and>\n     (b, w, a) \\<notin> set p' \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "obtain p' p'' u u' where\n        \"is_path_undir (add_edge a w b H) x p' u \\<and>\n        is_path_undir (add_edge a w b H) u' p'' y\" and\n        u: \"u\\<in>{a,b} \\<and> u'\\<in>{a,b}\" and\n        \"(a, w, b) \\<notin> set p' \\<and> (b, w, a) \\<notin> set p' \\<and>\n        (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\""], ["proof (prove)\nusing this:\n  \\<exists>p' p'' u u'.\n     is_path_undir (add_edge a w b H) x p' u \\<and>\n     is_path_undir (add_edge a w b H) u' p'' y \\<and>\n     length p' < length p \\<and>\n     length p'' < length p \\<and>\n     (u \\<in> {a, b} \\<and> u' \\<in> {a, b}) \\<and>\n     (a, w, b) \\<notin> set p' \\<and>\n     (b, w, a) \\<notin> set p' \\<and>\n     (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. (\\<And>p' u u' p''.\n        \\<lbrakk>is_path_undir (add_edge a w b H) x p' u \\<and>\n                 is_path_undir (add_edge a w b H) u' p'' y;\n         u \\<in> {a, b} \\<and> u' \\<in> {a, b};\n         (a, w, b) \\<notin> set p' \\<and>\n         (b, w, a) \\<notin> set p' \\<and>\n         (a, w, b) \\<notin> set p'' \\<and>\n         (b, w, a) \\<notin> set p''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b H) x p' u \\<and>\n  is_path_undir (add_edge a w b H) u' p'' y\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "with \\<open>a\\<in>V\\<close> \\<open>b\\<in>V\\<close> \\<open>Domain ?uf = nodes H\\<close> \\<open>subgraph H G\\<close>\n        valid_graph.add_edge_was_path[OF valid_H]"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  subgraph H G\n  \\<lbrakk>is_path_undir (add_edge ?a ?b ?c H) ?x ?p ?y;\n   (?a, ?b, ?c) \\<notin> set ?p; (?c, ?b, ?a) \\<notin> set ?p;\n   ?a \\<in> nodes H; ?c \\<in> nodes H\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H ?x ?p ?y\n  is_path_undir (add_edge a w b H) x p' u \\<and>\n  is_path_undir (add_edge a w b H) u' p'' y\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''", "have \"is_path_undir H x p' u \\<and> is_path_undir H u' p'' y\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  subgraph H G\n  \\<lbrakk>is_path_undir (add_edge ?a ?b ?c H) ?x ?p ?y;\n   (?a, ?b, ?c) \\<notin> set ?p; (?c, ?b, ?a) \\<notin> set ?p;\n   ?a \\<in> nodes H; ?c \\<in> nodes H\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H ?x ?p ?y\n  is_path_undir (add_edge a w b H) x p' u \\<and>\n  is_path_undir (add_edge a w b H) u' p'' y\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. is_path_undir H x p' u \\<and> is_path_undir H u' p'' y", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  nodes H = V \\<and> edges H \\<subseteq> E\n  \\<lbrakk>is_path_undir (add_edge ?a ?b ?c H) ?x ?p ?y;\n   (?a, ?b, ?c) \\<notin> set ?p; (?c, ?b, ?a) \\<notin> set ?p;\n   ?a \\<in> nodes H; ?c \\<in> nodes H\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H ?x ?p ?y\n  is_path_undir (add_edge a w b H) x p' u \\<and>\n  is_path_undir (add_edge a w b H) u' p'' y\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  (a, w, b) \\<notin> set p' \\<and>\n  (b, w, a) \\<notin> set p' \\<and>\n  (a, w, b) \\<notin> set p'' \\<and> (b, w, a) \\<notin> set p''\n\ngoal (1 subgoal):\n 1. is_path_undir H x p' u \\<and> is_path_undir H u' p'' y", "by auto"], ["proof (state)\nthis:\n  is_path_undir H x p' u \\<and> is_path_undir H u' p'' y\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "with V  u nodes_H"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  nodes H = V\n  is_path_undir H x p' u \\<and> is_path_undir H u' p'' y", "have comps: \"(x,u) \\<in> ?uf \\<and> (u', y) \\<in> ?uf\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  nodes H = V\n  is_path_undir H x p' u \\<and> is_path_undir H u' p'' y\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n    (u', y) \\<in> {(x, y) |x y. nodes_connected H x y}", "by auto"], ["proof (state)\nthis:\n  (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (u', y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "from comps"], ["proof (chain)\npicking this:\n  (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (u', y) \\<in> {(x, y) |x y. nodes_connected H x y}", "have \"(x,u) \\<in> per_union ?uf a b\""], ["proof (prove)\nusing this:\n  (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (u', y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "apply(intro per_union_impl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n    (u', y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    (x, u) \\<in> {(x, y) |x y. nodes_connected H x y}", "by auto"], ["proof (state)\nthis:\n  (x, u) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "also"], ["proof (state)\nthis:\n  (x, u) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "from u \\<open>a\\<in>V\\<close> \\<open>b\\<in>V\\<close> \\<open>Domain ?uf = nodes H\\<close> nodes_H\n        part_equiv_refl'[OF PER' \\<open>a\\<in>Domain (per_union ?uf a b)\\<close>]\n        part_equiv_refl'[OF PER' \\<open>b\\<in>Domain (per_union ?uf a b)\\<close>] part_equiv_sym[OF PER']\n        per_union_related[OF PER]"], ["proof (chain)\npicking this:\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  a \\<in> V\n  b \\<in> V\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  nodes H = V\n  (a, a) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  (b, b) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  (?x, ?y)\n  \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b \\<Longrightarrow>\n  (?y, ?x) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  \\<lbrakk>?a \\<in> Domain {(x, y) |x y. nodes_connected H x y};\n   ?b \\<in> Domain {(x, y) |x y. nodes_connected H x y}\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b)\n                    \\<in> per_union {(x, y) |x y. nodes_connected H x y} ?a\n                           ?b", "have \"(u,u') \\<in> per_union ?uf a b\""], ["proof (prove)\nusing this:\n  u \\<in> {a, b} \\<and> u' \\<in> {a, b}\n  a \\<in> V\n  b \\<in> V\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  nodes H = V\n  (a, a) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  (b, b) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  (?x, ?y)\n  \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b \\<Longrightarrow>\n  (?y, ?x) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  \\<lbrakk>?a \\<in> Domain {(x, y) |x y. nodes_connected H x y};\n   ?b \\<in> Domain {(x, y) |x y. nodes_connected H x y}\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b)\n                    \\<in> per_union {(x, y) |x y. nodes_connected H x y} ?a\n                           ?b\n\ngoal (1 subgoal):\n 1. (u, u') \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "by auto"], ["proof (state)\nthis:\n  (u, u') \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "also (part_equiv_trans[OF PER'])"], ["proof (state)\nthis:\n  (u, u') \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "from comps"], ["proof (chain)\npicking this:\n  (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (u', y) \\<in> {(x, y) |x y. nodes_connected H x y}", "have \"(u',y) \\<in> per_union ?uf a b\""], ["proof (prove)\nusing this:\n  (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (u', y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. (u', y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "apply(intro per_union_impl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, u) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n    (u', y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    (u', y) \\<in> {(x, y) |x y. nodes_connected H x y}", "by auto"], ["proof (state)\nthis:\n  (u', y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (2 subgoals):\n 1. (a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n 2. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "finally (part_equiv_trans[OF PER'])"], ["proof (chain)\npicking this:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "by simp"], ["proof (state)\nthis:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "case False"], ["proof (state)\nthis:\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)\n\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "with \\<open>a\\<in>V\\<close> \\<open>b\\<in>V\\<close> nodes_H valid_graph.add_edge_was_path[OF valid_H p(1)]"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  nodes H = V\n  \\<lbrakk>(a, w, b) \\<notin> set p; (b, w, a) \\<notin> set p;\n   a \\<in> nodes H; b \\<in> nodes H\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H x p y\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)", "have \"is_path_undir H x p y\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  nodes H = V\n  \\<lbrakk>(a, w, b) \\<notin> set p; (b, w, a) \\<notin> set p;\n   a \\<in> nodes H; b \\<in> nodes H\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H x p y\n  \\<not> ((a, w, b) \\<in> set p \\<or> (b, w, a) \\<in> set p)\n\ngoal (1 subgoal):\n 1. is_path_undir H x p y", "by auto"], ["proof (state)\nthis:\n  is_path_undir H x p y\n\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "with     nodes_add_H"], ["proof (chain)\npicking this:\n  nodes (add_edge a w b H) = nodes H\n  is_path_undir H x p y", "have \"(x,y)\\<in>?uf\""], ["proof (prove)\nusing this:\n  nodes (add_edge a w b H) = nodes H\n  is_path_undir H x p y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> {(x, y) |x y. nodes_connected H x y}", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. \\<not> ((a, w, b) \\<in> set p \\<or>\n            (b, w, a) \\<in> set p) \\<Longrightarrow>\n    (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "from per_union_impl[OF this]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} ?a ?b", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} ?a ?b\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b", "."], ["proof (state)\nthis:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "assume asm: \"(x, y) \\<in> per_union ?uf a b\""], ["proof (state)\nthis:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> per_union {(x, y) |x y. nodes_connected H x y} a\n           b \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "show \"nodes_connected (add_edge a w b H) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y", "proof (cases \"(x, y) \\<in> ?uf\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y\n 2. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "case True"], ["proof (state)\nthis:\n  (x, y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y\n 2. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "with nodes_add_H"], ["proof (chain)\npicking this:\n  nodes (add_edge a w b H) = nodes H\n  (x, y) \\<in> {(x, y) |x y. nodes_connected H x y}", "have \"nodes_connected H x y\""], ["proof (prove)\nusing this:\n  nodes (add_edge a w b H) = nodes H\n  (x, y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. nodes_connected H x y", "by auto"], ["proof (state)\nthis:\n  nodes_connected H x y\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y\n 2. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "with valid_graph.add_edge_is_path[OF valid_H]"], ["proof (chain)\npicking this:\n  is_path_undir H ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (add_edge ?a ?b ?c H) ?x ?p ?y\n  nodes_connected H x y", "show ?thesis"], ["proof (prove)\nusing this:\n  is_path_undir H ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (add_edge ?a ?b ?c H) ?x ?p ?y\n  nodes_connected H x y\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y", "by blast"], ["proof (state)\nthis:\n  nodes_connected (add_edge a w b H) x y\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "case False"], ["proof (state)\nthis:\n  (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "with asm part_equiv_sym[OF PER]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  (?x, ?y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n  (?y, ?x) \\<in> {(x, y) |x y. nodes_connected H x y}\n  (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y}", "have \"(x,a) \\<in> ?uf \\<and> (b,y) \\<in> ?uf \\<or>\n              (x,b) \\<in> ?uf \\<and> (a,y) \\<in> ?uf\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b\n  (?x, ?y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n  (?y, ?x) \\<in> {(x, y) |x y. nodes_connected H x y}\n  (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. (x, a) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n    (b, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<or>\n    (x, b) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n    (a, y) \\<in> {(x, y) |x y. nodes_connected H x y}", "unfolding per_union_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(x, y) |x y. nodes_connected H x y} \\<union>\n        {(x, y).\n         (x, a) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n         (y, b) \\<in> {(x, y) |x y. nodes_connected H x y}} \\<union>\n        {(y, x).\n         (x, a) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n         (y, b) \\<in> {(x, y) |x y. nodes_connected H x y}}\n  (?x, ?y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n  (?y, ?x) \\<in> {(x, y) |x y. nodes_connected H x y}\n  (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. (x, a) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n    (b, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<or>\n    (x, b) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n    (a, y) \\<in> {(x, y) |x y. nodes_connected H x y}", "by auto"], ["proof (state)\nthis:\n  (x, a) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (b, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<or>\n  (x, b) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (a, y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "with  \\<open>a\\<in>V\\<close> \\<open>b\\<in>V\\<close> nodes_H nodes_add_H"], ["proof (chain)\npicking this:\n  a \\<in> V\n  b \\<in> V\n  nodes H = V\n  nodes (add_edge a w b H) = nodes H\n  (x, a) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (b, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<or>\n  (x, b) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (a, y) \\<in> {(x, y) |x y. nodes_connected H x y}", "obtain p q p' q'\n          where \"is_path_undir H x p a \\<and> is_path_undir H b q y \\<or>\n                 is_path_undir H x p' b \\<and> is_path_undir H a q' y\""], ["proof (prove)\nusing this:\n  a \\<in> V\n  b \\<in> V\n  nodes H = V\n  nodes (add_edge a w b H) = nodes H\n  (x, a) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (b, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<or>\n  (x, b) \\<in> {(x, y) |x y. nodes_connected H x y} \\<and>\n  (a, y) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. (\\<And>p q p' q'.\n        is_path_undir H x p a \\<and> is_path_undir H b q y \\<or>\n        is_path_undir H x p' b \\<and>\n        is_path_undir H a q' y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  is_path_undir H x p a \\<and> is_path_undir H b q y \\<or>\n  is_path_undir H x p' b \\<and> is_path_undir H a q' y\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "with valid_graph.add_edge_is_path[OF valid_H]"], ["proof (chain)\npicking this:\n  is_path_undir H ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (add_edge ?a ?b ?c H) ?x ?p ?y\n  is_path_undir H x p a \\<and> is_path_undir H b q y \\<or>\n  is_path_undir H x p' b \\<and> is_path_undir H a q' y", "have \"is_path_undir (add_edge a w b H) x p a \\<and>\n              is_path_undir (add_edge a w b H) b q y \\<or>\n              is_path_undir (add_edge a w b H) x p' b \\<and>\n              is_path_undir (add_edge a w b H) a q' y\""], ["proof (prove)\nusing this:\n  is_path_undir H ?x ?p ?y \\<Longrightarrow>\n  is_path_undir (add_edge ?a ?b ?c H) ?x ?p ?y\n  is_path_undir H x p a \\<and> is_path_undir H b q y \\<or>\n  is_path_undir H x p' b \\<and> is_path_undir H a q' y\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a w b H) x p a \\<and>\n    is_path_undir (add_edge a w b H) b q y \\<or>\n    is_path_undir (add_edge a w b H) x p' b \\<and>\n    is_path_undir (add_edge a w b H) a q' y", "by blast"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b H) x p a \\<and>\n  is_path_undir (add_edge a w b H) b q y \\<or>\n  is_path_undir (add_edge a w b H) x p' b \\<and>\n  is_path_undir (add_edge a w b H) a q' y\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "with valid_graph.is_path_undir_split'[OF add_edge_valid[OF valid_H]]"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v (?p1.0 @ (?u, ?w, ?u') # ?p2.0)\n   ?v' =\n  (is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v ?p1.0 ?u \\<and>\n   ((?u, ?w, ?u') \\<in> edges (add_edge ?v1 ?e1 ?v'1 H) \\<or>\n    (?u', ?w, ?u) \\<in> edges (add_edge ?v1 ?e1 ?v'1 H)) \\<and>\n   is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?u' ?p2.0 ?v')\n  is_path_undir (add_edge a w b H) x p a \\<and>\n  is_path_undir (add_edge a w b H) b q y \\<or>\n  is_path_undir (add_edge a w b H) x p' b \\<and>\n  is_path_undir (add_edge a w b H) a q' y", "have \"is_path_undir (add_edge a w b H) x (p @ (a, w, b) # q) y \\<or>\n              is_path_undir (add_edge a w b H) x (p' @ (b, w, a) # q') y\""], ["proof (prove)\nusing this:\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v (?p1.0 @ (?u, ?w, ?u') # ?p2.0)\n   ?v' =\n  (is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v ?p1.0 ?u \\<and>\n   ((?u, ?w, ?u') \\<in> edges (add_edge ?v1 ?e1 ?v'1 H) \\<or>\n    (?u', ?w, ?u) \\<in> edges (add_edge ?v1 ?e1 ?v'1 H)) \\<and>\n   is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?u' ?p2.0 ?v')\n  is_path_undir (add_edge a w b H) x p a \\<and>\n  is_path_undir (add_edge a w b H) b q y \\<or>\n  is_path_undir (add_edge a w b H) x p' b \\<and>\n  is_path_undir (add_edge a w b H) a q' y\n\ngoal (1 subgoal):\n 1. is_path_undir (add_edge a w b H) x (p @ (a, w, b) # q) y \\<or>\n    is_path_undir (add_edge a w b H) x (p' @ (b, w, a) # q') y", "by auto"], ["proof (state)\nthis:\n  is_path_undir (add_edge a w b H) x (p @ (a, w, b) # q) y \\<or>\n  is_path_undir (add_edge a w b H) x (p' @ (b, w, a) # q') y\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> {(x, y) |x y. nodes_connected H x y} \\<Longrightarrow>\n    nodes_connected (add_edge a w b H) x y", "with valid_graph.is_path_undir_sym[OF add_edge_valid[OF valid_H]]"], ["proof (chain)\npicking this:\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v ?p ?v' \\<Longrightarrow>\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v'\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) ?p)) ?v\n  is_path_undir (add_edge a w b H) x (p @ (a, w, b) # q) y \\<or>\n  is_path_undir (add_edge a w b H) x (p' @ (b, w, a) # q') y", "show ?thesis"], ["proof (prove)\nusing this:\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v ?p ?v' \\<Longrightarrow>\n  is_path_undir (add_edge ?v1 ?e1 ?v'1 H) ?v'\n   (rev (map (\\<lambda>(u, w, u'). (u', w, u)) ?p)) ?v\n  is_path_undir (add_edge a w b H) x (p @ (a, w, b) # q) y \\<or>\n  is_path_undir (add_edge a w b H) x (p' @ (b, w, a) # q') y\n\ngoal (1 subgoal):\n 1. nodes_connected (add_edge a w b H) x y", "by blast"], ["proof (state)\nthis:\n  nodes_connected (add_edge a w b H) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected (add_edge a w b H) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected (add_edge a w b H) x y =\n  ((x, y) \\<in> per_union {(x, y) |x y. nodes_connected H x y} a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  is_path_undir_append: \"is_path_undir G v p1 u \\<Longrightarrow> is_path_undir G u p2 w\n      \\<Longrightarrow> is_path_undir G v (p1@p2) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_path_undir G v p1 u; is_path_undir G u p2 w\\<rbrakk>\n    \\<Longrightarrow> is_path_undir G v (p1 @ p2) w", "using is_path_undir_split"], ["proof (prove)\nusing this:\n  is_path_undir G ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      is_path_undir G ?v ?p1.0 u \\<and> is_path_undir G u ?p2.0 ?v')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_path_undir G v p1 u; is_path_undir G u p2 w\\<rbrakk>\n    \\<Longrightarrow> is_path_undir G v (p1 @ p2) w", "by auto"], ["", "lemma \n  augment_edge:\n  assumes sg: \"subgraph G1 G\" \"subgraph G2 G\" and\n    p: \"(u, v) \\<in> {(a, b) |a b. nodes_connected G1 a b}\"\n  and notinE2:  \"(u, v) \\<notin> {(a, b) |a b. nodes_connected G2 a b}\"\n\nshows \"\\<exists>a b e. (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and> e \\<notin> edges G2 \\<and> e \\<in> edges G1 \\<and> (case e of (aa, w, ba) \\<Rightarrow> a=aa \\<and> b=ba \\<or> a=ba \\<and> b=aa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "from sg"], ["proof (chain)\npicking this:\n  subgraph G1 G\n  subgraph G2 G", "have [simp]: \"nodes G1 = nodes G\" \"nodes G2 = nodes G\""], ["proof (prove)\nusing this:\n  subgraph G1 G\n  subgraph G2 G\n\ngoal (1 subgoal):\n 1. nodes G1 = V &&& nodes G2 = V", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes G1 = V \\<and> edges G1 \\<subseteq> E\n  nodes G2 = V \\<and> edges G2 \\<subseteq> E\n\ngoal (1 subgoal):\n 1. nodes G1 = V &&& nodes G2 = V", "by auto"], ["proof (state)\nthis:\n  nodes G1 = V\n  nodes G2 = V\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "from p"], ["proof (chain)\npicking this:\n  (u, v) \\<in> {(a, b) |a b. nodes_connected G1 a b}", "obtain p where a: \"is_path_undir G1 u p v\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> {(a, b) |a b. nodes_connected G1 a b}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        is_path_undir G1 u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_path_undir G1 u p v\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "from notinE2"], ["proof (chain)\npicking this:\n  (u, v) \\<notin> {(a, b) |a b. nodes_connected G2 a b}", "have b: \"~(\\<exists>p. is_path_undir G2 u p v)\""], ["proof (prove)\nusing this:\n  (u, v) \\<notin> {(a, b) |a b. nodes_connected G2 a b}\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected G2 u v", "by auto"], ["proof (state)\nthis:\n  \\<not> nodes_connected G2 u v\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "from a b"], ["proof (chain)\npicking this:\n  is_path_undir G1 u p v\n  \\<not> nodes_connected G2 u v", "show ?thesis"], ["proof (prove)\nusing this:\n  is_path_undir G1 u p v\n  \\<not> nodes_connected G2 u v\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "proof (induct p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>is_path_undir G1 u [] v;\n        \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "case Nil"], ["proof (state)\nthis:\n  is_path_undir G1 u [] v\n  \\<not> nodes_connected G2 u v\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>is_path_undir G1 u [] v;\n        \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "then"], ["proof (chain)\npicking this:\n  is_path_undir G1 u [] v\n  \\<not> nodes_connected G2 u v", "have \"u=v\" \"u\\<in>nodes G1\""], ["proof (prove)\nusing this:\n  is_path_undir G1 u [] v\n  \\<not> nodes_connected G2 u v\n\ngoal (1 subgoal):\n 1. u = v &&& u \\<in> nodes G1", "by auto"], ["proof (state)\nthis:\n  u = v\n  u \\<in> nodes G1\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>is_path_undir G1 u [] v;\n        \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "then"], ["proof (chain)\npicking this:\n  u = v\n  u \\<in> nodes G1", "have \"is_path_undir G2 u [] v\""], ["proof (prove)\nusing this:\n  u = v\n  u \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. is_path_undir G2 u [] v", "by auto"], ["proof (state)\nthis:\n  is_path_undir G2 u [] v\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>is_path_undir G1 u [] v;\n        \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "have \"(u, v) \\<in> {(a, b) |a b. nodes_connected G2 a b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> {(a, b) |a b. nodes_connected G2 a b}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected G2 u v", "apply(rule exI[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path_undir G2 u [] v", "by fact"], ["proof (state)\nthis:\n  (u, v) \\<in> {(a, b) |a b. nodes_connected G2 a b}\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>is_path_undir G1 u [] v;\n        \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "with Nil(2)"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected G2 u v\n  (u, v) \\<in> {(a, b) |a b. nodes_connected G2 a b}", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected G2 u v\n  (u, v) \\<in> {(a, b) |a b. nodes_connected G2 a b}\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "by blast"], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "case (Cons a p)"], ["proof (state)\nthis:\n  \\<lbrakk>is_path_undir G1 ?u p v; \\<not> nodes_connected G2 ?u v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b e.\n                       (a, b)\n                       \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n                       e \\<notin> edges G2 \\<and>\n                       e \\<in> edges G1 \\<and>\n                       (case e of\n                        (aa, w, ba) \\<Rightarrow>\n                          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n  is_path_undir G1 u (a # p) v\n  \\<not> nodes_connected G2 u v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "from Cons(2)"], ["proof (chain)\npicking this:\n  is_path_undir G1 u (a # p) v", "obtain w x y u' where axy: \"a=(u,w,u')\" and 2: \"(x=u \\<and> y=u') \\<or> (x=u' \\<and> y=u)\" and e': \"is_path_undir G1 u' p v\"\n      and uwE1: \"(x,w,y) \\<in> edges G1\""], ["proof (prove)\nusing this:\n  is_path_undir G1 u (a # p) v\n\ngoal (1 subgoal):\n 1. (\\<And>w u' x y.\n        \\<lbrakk>a = (u, w, u');\n         x = u \\<and> y = u' \\<or> x = u' \\<and> y = u;\n         is_path_undir G1 u' p v; (x, w, y) \\<in> edges G1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>\\<And>w u' x y.\n                   \\<lbrakk>a = (u, w, u');\n                    x = u \\<and> y = u' \\<or> x = u' \\<and> y = u;\n                    is_path_undir G1 u' p v;\n                    (x, w, y) \\<in> edges G1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        is_path_undir G1 u (a # p) v; a = (aa, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a = (u, w, u')\n  x = u \\<and> y = u' \\<or> x = u' \\<and> y = u\n  is_path_undir G1 u' p v\n  (x, w, y) \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>is_path_undir G1 u p v;\n                    \\<not> nodes_connected G2 u v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b e.\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n  e \\<notin> edges G2 \\<and>\n  e \\<in> edges G1 \\<and>\n  (case e of\n   (aa, w, ba) \\<Rightarrow>\n     a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa);\n        is_path_undir G1 u (a # p) v; \\<not> nodes_connected G2 u v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b)\n                            \\<notin> {(a, b) |a b.\nnodes_connected G2 a b} \\<and>\n                            e \\<notin> edges G2 \\<and>\n                            e \\<in> edges G1 \\<and>\n                            (case e of\n                             (aa, w, ba) \\<Rightarrow>\n                               a = aa \\<and> b = ba \\<or>\n                               a = ba \\<and> b = aa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "proof (cases \"(x,w,y)\\<in>edges G2 \\<or> (y,w,x)\\<in>edges G2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, w, y) \\<in> edges G2 \\<or>\n    (y, w, x) \\<in> edges G2 \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n 2. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "case True"], ["proof (state)\nthis:\n  (x, w, y) \\<in> edges G2 \\<or> (y, w, x) \\<in> edges G2\n\ngoal (2 subgoals):\n 1. (x, w, y) \\<in> edges G2 \\<or>\n    (y, w, x) \\<in> edges G2 \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n 2. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "have e2': \"~(\\<exists>p. is_path_undir G2 u' p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected G2 u' v", "proof (rule ccontr, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u' p v \\<Longrightarrow> False", "fix p2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u' p v \\<Longrightarrow> False", "assume \"is_path_undir G2 u' p2 v\""], ["proof (state)\nthis:\n  is_path_undir G2 u' p2 v\n\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u' p v \\<Longrightarrow> False", "with True axy 2"], ["proof (chain)\npicking this:\n  (x, w, y) \\<in> edges G2 \\<or> (y, w, x) \\<in> edges G2\n  a = (u, w, u')\n  x = u \\<and> y = u' \\<or> x = u' \\<and> y = u\n  is_path_undir G2 u' p2 v", "have \"is_path_undir G2 u (a#p2) v\""], ["proof (prove)\nusing this:\n  (x, w, y) \\<in> edges G2 \\<or> (y, w, x) \\<in> edges G2\n  a = (u, w, u')\n  x = u \\<and> y = u' \\<or> x = u' \\<and> y = u\n  is_path_undir G2 u' p2 v\n\ngoal (1 subgoal):\n 1. is_path_undir G2 u (a # p2) v", "by auto"], ["proof (state)\nthis:\n  is_path_undir G2 u (a # p2) v\n\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u' p v \\<Longrightarrow> False", "with Cons(3)"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected G2 u v\n  is_path_undir G2 u (a # p2) v", "show False"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected G2 u v\n  is_path_undir G2 u (a # p2) v\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> nodes_connected G2 u' v\n\ngoal (2 subgoals):\n 1. (x, w, y) \\<in> edges G2 \\<or>\n    (y, w, x) \\<in> edges G2 \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n 2. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "from Cons(1)[OF e' e2']"], ["proof (chain)\npicking this:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "."], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "case False"], ["proof (state)\nthis:\n  \\<not> ((x, w, y) \\<in> edges G2 \\<or> (y, w, x) \\<in> edges G2)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "{"], ["proof (state)\nthis:\n  \\<not> ((x, w, y) \\<in> edges G2 \\<or> (y, w, x) \\<in> edges G2)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "assume e2': \"~(\\<exists>p. is_path_undir G2 u' p v)\""], ["proof (state)\nthis:\n  \\<not> nodes_connected G2 u' v\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "from Cons(1)[OF e' e2']"], ["proof (chain)\npicking this:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "."], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "}"], ["proof (state)\nthis:\n  \\<not> nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "moreover"], ["proof (state)\nthis:\n  \\<not> nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "{"], ["proof (state)\nthis:\n  \\<not> nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "assume e2': \"\\<exists>p. is_path_undir G2 u' p v\""], ["proof (state)\nthis:\n  nodes_connected G2 u' v\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "then"], ["proof (chain)\npicking this:\n  nodes_connected G2 u' v", "obtain p1 where p1: \"is_path_undir G2 u' p1 v\""], ["proof (prove)\nusing this:\n  nodes_connected G2 u' v\n\ngoal (1 subgoal):\n 1. (\\<And>p1.\n        is_path_undir G2 u' p1 v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path_undir G2 u' p1 v\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "from False axy"], ["proof (chain)\npicking this:\n  \\<not> ((x, w, y) \\<in> edges G2 \\<or> (y, w, x) \\<in> edges G2)\n  a = (u, w, u')", "have \"(x, w, y)\\<notin>edges G2\""], ["proof (prove)\nusing this:\n  \\<not> ((x, w, y) \\<in> edges G2 \\<or> (y, w, x) \\<in> edges G2)\n  a = (u, w, u')\n\ngoal (1 subgoal):\n 1. (x, w, y) \\<notin> edges G2", "by auto"], ["proof (state)\nthis:\n  (x, w, y) \\<notin> edges G2\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "moreover"], ["proof (state)\nthis:\n  (x, w, y) \\<notin> edges G2\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "have \"(u,u') \\<notin> {(a, b) |a b. nodes_connected G2 a b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b}", "proof(rule ccontr, auto simp add:  )"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u p u' \\<Longrightarrow> False", "fix p2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u p u' \\<Longrightarrow> False", "assume \"is_path_undir G2 u p2 u'\""], ["proof (state)\nthis:\n  is_path_undir G2 u p2 u'\n\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u p u' \\<Longrightarrow> False", "with p1"], ["proof (chain)\npicking this:\n  is_path_undir G2 u' p1 v\n  is_path_undir G2 u p2 u'", "have \"is_path_undir G2 u (p2@p1) v\""], ["proof (prove)\nusing this:\n  is_path_undir G2 u' p1 v\n  is_path_undir G2 u p2 u'\n\ngoal (1 subgoal):\n 1. is_path_undir G2 u (p2 @ p1) v", "using valid_graph.is_path_undir_append[OF valid_subgraph[OF assms(2)]]"], ["proof (prove)\nusing this:\n  is_path_undir G2 u' p1 v\n  is_path_undir G2 u p2 u'\n  \\<lbrakk>is_path_undir G2 ?v ?p1.0 ?u;\n   is_path_undir G2 ?u ?p2.0 ?w\\<rbrakk>\n  \\<Longrightarrow> is_path_undir G2 ?v (?p1.0 @ ?p2.0) ?w\n\ngoal (1 subgoal):\n 1. is_path_undir G2 u (p2 @ p1) v", "by auto"], ["proof (state)\nthis:\n  is_path_undir G2 u (p2 @ p1) v\n\ngoal (1 subgoal):\n 1. \\<And>p. is_path_undir G2 u p u' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_path_undir G2 u (p2 @ p1) v", "show \"False\""], ["proof (prove)\nusing this:\n  is_path_undir G2 u (p2 @ p1) v\n\ngoal (1 subgoal):\n 1. False", "using Cons(3)"], ["proof (prove)\nusing this:\n  is_path_undir G2 u (p2 @ p1) v\n  \\<not> nodes_connected G2 u v\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b}\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "moreover"], ["proof (state)\nthis:\n  (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b}\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "note uwE1"], ["proof (state)\nthis:\n  (x, w, y) \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "ultimately"], ["proof (chain)\npicking this:\n  (x, w, y) \\<notin> edges G2\n  (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b}\n  (x, w, y) \\<in> edges G1", "have ?thesis"], ["proof (prove)\nusing this:\n  (x, w, y) \\<notin> edges G2\n  (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b}\n  (x, w, y) \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, w, y) \\<notin> edges G2;\n     (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b};\n     (x, w, y) \\<in> edges G1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b e.\n                         (a, b)\n                         \\<notin> {(a, b) |a b.\n                                   nodes_connected G2 a b} \\<and>\n                         e \\<notin> edges G2 \\<and>\n                         e \\<in> edges G1 \\<and>\n                         (case e of\n                          (aa, w, ba) \\<Rightarrow>\n                            a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "apply(rule exI[where x=\"u\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, w, y) \\<notin> edges G2;\n     (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b};\n     (x, w, y) \\<in> edges G1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b e.\n                         (u, b)\n                         \\<notin> {(a, b) |a b.\n                                   nodes_connected G2 a b} \\<and>\n                         e \\<notin> edges G2 \\<and>\n                         e \\<in> edges G1 \\<and>\n                         (case e of\n                          (aa, w, ba) \\<Rightarrow>\n                            u = aa \\<and> b = ba \\<or> u = ba \\<and> b = aa)", "apply(rule exI[where x=\"u'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, w, y) \\<notin> edges G2;\n     (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b};\n     (x, w, y) \\<in> edges G1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         (u, u')\n                         \\<notin> {(a, b) |a b.\n                                   nodes_connected G2 a b} \\<and>\n                         e \\<notin> edges G2 \\<and>\n                         e \\<in> edges G1 \\<and>\n                         (case e of\n                          (aa, w, ba) \\<Rightarrow>\n                            u = aa \\<and> u' = ba \\<or>\n                            u = ba \\<and> u' = aa)", "apply(rule exI[where x=\"(x,w,y)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, w, y) \\<notin> edges G2;\n     (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b};\n     (x, w, y) \\<in> edges G1\\<rbrakk>\n    \\<Longrightarrow> (u, u')\n                      \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n                      (x, w, y) \\<notin> edges G2 \\<and>\n                      (x, w, y) \\<in> edges G1 \\<and>\n                      (case (x, w, y) of\n                       (aa, w, ba) \\<Rightarrow>\n                         u = aa \\<and> u' = ba \\<or> u = ba \\<and> u' = aa)", "using 2"], ["proof (prove)\nusing this:\n  x = u \\<and> y = u' \\<or> x = u' \\<and> y = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, w, y) \\<notin> edges G2;\n     (u, u') \\<notin> {(a, b) |a b. nodes_connected G2 a b};\n     (x, w, y) \\<in> edges G1\\<rbrakk>\n    \\<Longrightarrow> (u, u')\n                      \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n                      (x, w, y) \\<notin> edges G2 \\<and>\n                      (x, w, y) \\<in> edges G1 \\<and>\n                      (case (x, w, y) of\n                       (aa, w, ba) \\<Rightarrow>\n                         u = aa \\<and> u' = ba \\<or> u = ba \\<and> u' = aa)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "}"], ["proof (state)\nthis:\n  nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, w, y) \\<in> edges G2 \\<or>\n            (y, w, x) \\<in> edges G2) \\<Longrightarrow>\n    \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n  nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n  nodes_connected G2 u' v \\<Longrightarrow>\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n       e \\<notin> edges G2 \\<and>\n       e \\<in> edges G1 \\<and>\n       (case e of\n        (aa, w, ba) \\<Rightarrow>\n          a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected G2 a b} \\<and>\n     e \\<notin> edges G2 \\<and>\n     e \\<in> edges G1 \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  nodes_connected_refl: \"a\\<in>V \\<Longrightarrow> nodes_connected G a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> V \\<Longrightarrow> nodes_connected G a a", "apply(rule exI[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> V \\<Longrightarrow> is_path_undir G a [] a", "by auto"], ["", "lemma assumes sg: \"subgraph H G\"\n  shows connected_VV: \"{(x, y) |x y. nodes_connected H x y} \\<subseteq> V\\<times>V\"\n    and connected_refl: \"refl_on V {(x, y) |x y. nodes_connected H x y}\"\n    and connected_trans: \"trans {(x, y) |x y. nodes_connected H x y}\"\n    and connected_sym: \"sym {(x, y) |x y. nodes_connected H x y}\"\n    and connected_equiv: \"equiv V {(x, y) |x y. nodes_connected H x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V &&&\n     refl_on V {(x, y) |x y. nodes_connected H x y}) &&&\n    trans {(x, y) |x y. nodes_connected H x y} &&&\n    sym {(x, y) |x y. nodes_connected H x y} &&&\n    equiv V {(x, y) |x y. nodes_connected H x y}", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. {(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V\n 2. refl_on V {(x, y) |x y. nodes_connected H x y}\n 3. trans {(x, y) |x y. nodes_connected H x y}\n 4. sym {(x, y) |x y. nodes_connected H x y}\n 5. equiv V {(x, y) |x y. nodes_connected H x y}", "have *: \"\\<And>R S. Domain R \\<subseteq> S \\<Longrightarrow> Range R \\<subseteq> S \\<Longrightarrow> R \\<subseteq> S\\<times>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R S.\n       \\<lbrakk>Domain R \\<subseteq> S; Range R \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> R \\<subseteq> S \\<times> S", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>Domain ?R \\<subseteq> ?S; Range ?R \\<subseteq> ?S\\<rbrakk>\n  \\<Longrightarrow> ?R \\<subseteq> ?S \\<times> ?S\n\ngoal (5 subgoals):\n 1. {(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V\n 2. refl_on V {(x, y) |x y. nodes_connected H x y}\n 3. trans {(x, y) |x y. nodes_connected H x y}\n 4. sym {(x, y) |x y. nodes_connected H x y}\n 5. equiv V {(x, y) |x y. nodes_connected H x y}", "from sg"], ["proof (chain)\npicking this:\n  subgraph H G", "have [simp]: \"nodes H = V\""], ["proof (prove)\nusing this:\n  subgraph H G\n\ngoal (1 subgoal):\n 1. nodes H = V", "by (auto simp: subgraph_def)"], ["proof (state)\nthis:\n  nodes H = V\n\ngoal (5 subgoals):\n 1. {(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V\n 2. refl_on V {(x, y) |x y. nodes_connected H x y}\n 3. trans {(x, y) |x y. nodes_connected H x y}\n 4. sym {(x, y) |x y. nodes_connected H x y}\n 5. equiv V {(x, y) |x y. nodes_connected H x y}", "from sg valid_subgraph"], ["proof (chain)\npicking this:\n  subgraph H G\n  subgraph ?H G \\<Longrightarrow> valid_graph ?H", "have v: \"valid_graph H\""], ["proof (prove)\nusing this:\n  subgraph H G\n  subgraph ?H G \\<Longrightarrow> valid_graph ?H\n\ngoal (1 subgoal):\n 1. valid_graph H", "by auto"], ["proof (state)\nthis:\n  valid_graph H\n\ngoal (5 subgoals):\n 1. {(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V\n 2. refl_on V {(x, y) |x y. nodes_connected H x y}\n 3. trans {(x, y) |x y. nodes_connected H x y}\n 4. sym {(x, y) |x y. nodes_connected H x y}\n 5. equiv V {(x, y) |x y. nodes_connected H x y}", "from valid_graph.Domain_nodes_connected[OF this] valid_graph.Range_nodes_connected[OF this]"], ["proof (chain)\npicking this:\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  Range {(x, y) |x y. nodes_connected H x y} = nodes H", "show i: \"{(x, y) |x y. nodes_connected H x y} \\<subseteq> V\\<times>V\""], ["proof (prove)\nusing this:\n  Domain {(x, y) |x y. nodes_connected H x y} = nodes H\n  Range {(x, y) |x y. nodes_connected H x y} = nodes H\n\ngoal (1 subgoal):\n 1. {(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V", "apply(intro *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Domain {(x, y) |x y. nodes_connected H x y} = nodes H;\n     Range {(x, y) |x y. nodes_connected H x y} = nodes H\\<rbrakk>\n    \\<Longrightarrow> Domain {(x, y) |x y. nodes_connected H x y}\n                      \\<subseteq> V\n 2. \\<lbrakk>Domain {(x, y) |x y. nodes_connected H x y} = nodes H;\n     Range {(x, y) |x y. nodes_connected H x y} = nodes H\\<rbrakk>\n    \\<Longrightarrow> Range {(x, y) |x y. nodes_connected H x y}\n                      \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  {(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V\n\ngoal (4 subgoals):\n 1. refl_on V {(x, y) |x y. nodes_connected H x y}\n 2. trans {(x, y) |x y. nodes_connected H x y}\n 3. sym {(x, y) |x y. nodes_connected H x y}\n 4. equiv V {(x, y) |x y. nodes_connected H x y}", "have ii: \"\\<And>x. x \\<in> V \\<Longrightarrow> (x, x) \\<in> {(x, y) |x y. nodes_connected H x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       (x, x) \\<in> {(x, y) |x y. nodes_connected H x y}", "using valid_graph.nodes_connected_refl[OF v]"], ["proof (prove)\nusing this:\n  ?a \\<in> nodes H \\<Longrightarrow> nodes_connected H ?a ?a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       (x, x) \\<in> {(x, y) |x y. nodes_connected H x y}", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> V \\<Longrightarrow>\n  (?x1, ?x1) \\<in> {(x, y) |x y. nodes_connected H x y}\n\ngoal (4 subgoals):\n 1. refl_on V {(x, y) |x y. nodes_connected H x y}\n 2. trans {(x, y) |x y. nodes_connected H x y}\n 3. sym {(x, y) |x y. nodes_connected H x y}\n 4. equiv V {(x, y) |x y. nodes_connected H x y}", "show \"refl_on V {(x, y) |x y. nodes_connected H x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on V {(x, y) |x y. nodes_connected H x y}", "apply(rule refl_onI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(x, y) |x y. nodes_connected H x y} \\<subseteq> V \\<times> V\n 2. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       (x, x) \\<in> {(x, y) |x y. nodes_connected H x y}", "by fact+"], ["proof (state)\nthis:\n  refl_on V {(x, y) |x y. nodes_connected H x y}\n\ngoal (3 subgoals):\n 1. trans {(x, y) |x y. nodes_connected H x y}\n 2. sym {(x, y) |x y. nodes_connected H x y}\n 3. equiv V {(x, y) |x y. nodes_connected H x y}", "from valid_graph.is_path_undir_append[OF v]"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_path_undir H ?v ?p1.0 ?u; is_path_undir H ?u ?p2.0 ?w\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H ?v (?p1.0 @ ?p2.0) ?w", "show \"trans {(x, y) |x y. nodes_connected H x y}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_path_undir H ?v ?p1.0 ?u; is_path_undir H ?u ?p2.0 ?w\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H ?v (?p1.0 @ ?p2.0) ?w\n\ngoal (1 subgoal):\n 1. trans {(x, y) |x y. nodes_connected H x y}", "unfolding trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_path_undir H ?v ?p1.0 ?u; is_path_undir H ?u ?p2.0 ?w\\<rbrakk>\n  \\<Longrightarrow> is_path_undir H ?v (?p1.0 @ ?p2.0) ?w\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<longrightarrow>\n       (y, z) \\<in> {(x, y) |x y. nodes_connected H x y} \\<longrightarrow>\n       (x, z) \\<in> {(x, y) |x y. nodes_connected H x y}", "by fast"], ["proof (state)\nthis:\n  trans {(x, y) |x y. nodes_connected H x y}\n\ngoal (2 subgoals):\n 1. sym {(x, y) |x y. nodes_connected H x y}\n 2. equiv V {(x, y) |x y. nodes_connected H x y}", "from valid_graph.nodes_connected_sym[OF v]"], ["proof (chain)\npicking this:\n  nodes_connected H ?a ?b = nodes_connected H ?b ?a", "show \"sym {(x, y) |x y. nodes_connected H x y}\""], ["proof (prove)\nusing this:\n  nodes_connected H ?a ?b = nodes_connected H ?b ?a\n\ngoal (1 subgoal):\n 1. sym {(x, y) |x y. nodes_connected H x y}", "unfolding sym_def"], ["proof (prove)\nusing this:\n  nodes_connected H ?a ?b = nodes_connected H ?b ?a\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> {(x, y) |x y. nodes_connected H x y} \\<longrightarrow>\n       (y, x) \\<in> {(x, y) |x y. nodes_connected H x y}", "by fast"], ["proof (state)\nthis:\n  sym {(x, y) |x y. nodes_connected H x y}\n\ngoal (1 subgoal):\n 1. equiv V {(x, y) |x y. nodes_connected H x y}", "show \"equiv V {(x, y) |x y. nodes_connected H x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv V {(x, y) |x y. nodes_connected H x y}", "apply (rule equivI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. refl_on V {(x, y) |x y. nodes_connected H x y}\n 2. sym {(x, y) |x y. nodes_connected H x y}\n 3. trans {(x, y) |x y. nodes_connected H x y}", "by fact+"], ["proof (state)\nthis:\n  equiv V {(x, y) |x y. nodes_connected H x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  forest_maximally_connected_incl_max1:\n  assumes\n    \"forest H\"\n    \"subgraph H G\"                                                                \n  shows \"(\\<forall>(a,w,b)\\<in>edges G - edges H. \\<not> (forest (add_edge a w b H))) \\<Longrightarrow> maximally_connected H G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "from assms(2)"], ["proof (chain)\npicking this:\n  subgraph H G", "have V[simp]: \"nodes H = nodes G\""], ["proof (prove)\nusing this:\n  subgraph H G\n\ngoal (1 subgoal):\n 1. nodes H = V", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n\ngoal (1 subgoal):\n 1. nodes H = V", "by auto"], ["proof (state)\nthis:\n  nodes H = V\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "assume pff: \"(\\<forall>(a,w,b)\\<in>E - edges H. \\<not> (forest (add_edge a w b H)))\""], ["proof (state)\nthis:\n  \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "{"], ["proof (state)\nthis:\n  \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "assume uv: \"v\\<in>V\" \"u\\<in>V\""], ["proof (state)\nthis:\n  v \\<in> V\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "assume \"nodes_connected G u v\""], ["proof (state)\nthis:\n  nodes_connected G u v\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "then"], ["proof (chain)\npicking this:\n  nodes_connected G u v", "have i: \"(u, v) \\<in> {(a, b) |a b. nodes_connected G a b}\""], ["proof (prove)\nusing this:\n  nodes_connected G u v\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> {(a, b) |a b. nodes_connected G a b}", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> {(a, b) |a b. nodes_connected G a b}\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "have \"nodes_connected H u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_connected H u v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "assume \"\\<not>nodes_connected H u v\""], ["proof (state)\nthis:\n  \\<not> nodes_connected H u v\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected H u v", "have ii: \"(u, v) \\<notin> {(a, b) |a b. nodes_connected H a b}\""], ["proof (prove)\nusing this:\n  \\<not> nodes_connected H u v\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> {(a, b) |a b. nodes_connected H a b}", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<notin> {(a, b) |a b. nodes_connected H a b}\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "have \"subgraph G G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgraph G G", "by(auto simp: subgraph_def)"], ["proof (state)\nthis:\n  subgraph G G\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "from augment_edge[OF this assms(2) i ii]"], ["proof (chain)\npicking this:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected H a b} \\<and>\n     e \\<notin> edges H \\<and>\n     e \\<in> E \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)", "obtain e a b where\n         k: \"(a, b) \\<notin> {(a, b) |a b. nodes_connected H a b}\"\n        and nn: \"e \\<notin> edges H\" \"e \\<in> E\" and ee: \"(case e of (aa, w, ba) \\<Rightarrow> a=aa \\<and> b=ba \\<or> a=ba \\<and> b=aa) \""], ["proof (prove)\nusing this:\n  \\<exists>a b e.\n     (a, b) \\<notin> {(a, b) |a b. nodes_connected H a b} \\<and>\n     e \\<notin> edges H \\<and>\n     e \\<in> E \\<and>\n     (case e of\n      (aa, w, ba) \\<Rightarrow>\n        a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa)\n\ngoal (1 subgoal):\n 1. (\\<And>a b e.\n        \\<lbrakk>(a, b) \\<notin> {(a, b) |a b. nodes_connected H a b};\n         e \\<notin> edges H; e \\<in> E;\n         case e of\n         (aa, w, ba) \\<Rightarrow>\n           a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected H a b}\n  e \\<notin> edges H\n  e \\<in> E\n  case e of\n  (aa, w, ba) \\<Rightarrow> a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "obtain x w y where e: \"e=(x,w,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x w y. e = (x, w, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>x w y. e = (x, w, y) \\<Longrightarrow> thesis;\n        e = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  e = (x, w, y)\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "from e ee"], ["proof (chain)\npicking this:\n  e = (x, w, y)\n  case e of\n  (aa, w, ba) \\<Rightarrow> a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa", "have \"x=a \\<and> y=b \\<or> x=b \\<and> y=a\""], ["proof (prove)\nusing this:\n  e = (x, w, y)\n  case e of\n  (aa, w, ba) \\<Rightarrow> a = aa \\<and> b = ba \\<or> a = ba \\<and> b = aa\n\ngoal (1 subgoal):\n 1. x = a \\<and> y = b \\<or> x = b \\<and> y = a", "by auto"], ["proof (state)\nthis:\n  x = a \\<and> y = b \\<or> x = b \\<and> y = a\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "with k"], ["proof (chain)\npicking this:\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected H a b}\n  x = a \\<and> y = b \\<or> x = b \\<and> y = a", "have k': \"\\<not> nodes_connected H x y\""], ["proof (prove)\nusing this:\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected H a b}\n  x = a \\<and> y = b \\<or> x = b \\<and> y = a\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H x y", "using valid_graph.nodes_connected_sym[OF valid_subgraph[OF assms(2)]]"], ["proof (prove)\nusing this:\n  (a, b) \\<notin> {(a, b) |a b. nodes_connected H a b}\n  x = a \\<and> y = b \\<or> x = b \\<and> y = a\n  nodes_connected H ?a ?b = nodes_connected H ?b ?a\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H x y", "by auto"], ["proof (state)\nthis:\n  \\<not> nodes_connected H x y\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "have xy: \"x\\<in>V\" \"y\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V &&& y \\<in> V", "using e nn(2)"], ["proof (prove)\nusing this:\n  e = (x, w, y)\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. x \\<in> V &&& y \\<in> V", "by (auto dest: E_validD)"], ["proof (state)\nthis:\n  x \\<in> V\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> V\n  y \\<in> V", "have nxy: \"x\\<in>nodes H\"  \"y\\<in>nodes H\""], ["proof (prove)\nusing this:\n  x \\<in> V\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. x \\<in> nodes H &&& y \\<in> nodes H", "by auto"], ["proof (state)\nthis:\n  x \\<in> nodes H\n  y \\<in> nodes H\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "from forest.forest_add_edge[OF assms(1) nxy k' ]"], ["proof (chain)\npicking this:\n  forest (add_edge x ?w y H)", "have\n        \"forest (add_edge x w y H)\""], ["proof (prove)\nusing this:\n  forest (add_edge x ?w y H)\n\ngoal (1 subgoal):\n 1. forest (add_edge x w y H)", "."], ["proof (state)\nthis:\n  forest (add_edge x w y H)\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  forest (add_edge x w y H)\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "have \"(x,w,y)\\<in>E-edges H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, w, y) \\<in> E - edges H", "using nn e"], ["proof (prove)\nusing this:\n  e \\<notin> edges H\n  e \\<in> E\n  e = (x, w, y)\n\ngoal (1 subgoal):\n 1. (x, w, y) \\<in> E - edges H", "by auto"], ["proof (state)\nthis:\n  (x, w, y) \\<in> E - edges H\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H u v \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  forest (add_edge x w y H)\n  (x, w, y) \\<in> E - edges H", "show \"False\""], ["proof (prove)\nusing this:\n  forest (add_edge x w y H)\n  (x, w, y) \\<in> E - edges H\n\ngoal (1 subgoal):\n 1. False", "using pff"], ["proof (prove)\nusing this:\n  forest (add_edge x w y H)\n  (x, w, y) \\<in> E - edges H\n  \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes_connected H u v\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<in> V; ?u2 \\<in> V; nodes_connected G ?u2 ?v2\\<rbrakk>\n  \\<Longrightarrow> nodes_connected H ?u2 ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H.\n       \\<not> forest (add_edge a w b H) \\<Longrightarrow>\n    maximally_connected H G", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?v2 \\<in> V; ?u2 \\<in> V; nodes_connected G ?u2 ?v2\\<rbrakk>\n  \\<Longrightarrow> nodes_connected H ?u2 ?v2", "show \"maximally_connected H G\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?v2 \\<in> V; ?u2 \\<in> V; nodes_connected G ?u2 ?v2\\<rbrakk>\n  \\<Longrightarrow> nodes_connected H ?u2 ?v2\n\ngoal (1 subgoal):\n 1. maximally_connected H G", "unfolding maximally_connected_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v2 \\<in> V; ?u2 \\<in> V; nodes_connected G ?u2 ?v2\\<rbrakk>\n  \\<Longrightarrow> nodes_connected H ?u2 ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       \\<forall>v'\\<in>V.\n          nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'", "by auto"], ["proof (state)\nthis:\n  maximally_connected H G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma   forest_maximally_connected_incl_max2:\n  assumes\n    \"forest H\"\n    \"subgraph H G\"\n  shows \"maximally_connected H G \\<Longrightarrow> (\\<forall>(a,w,b)\\<in>E - edges H. \\<not> (forest (add_edge a w b H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximally_connected H G \\<Longrightarrow>\n    \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. maximally_connected H G \\<Longrightarrow>\n    \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)", "from assms(2)"], ["proof (chain)\npicking this:\n  subgraph H G", "have V[simp]: \"nodes H = nodes G\""], ["proof (prove)\nusing this:\n  subgraph H G\n\ngoal (1 subgoal):\n 1. nodes H = V", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  nodes H = V \\<and> edges H \\<subseteq> E\n\ngoal (1 subgoal):\n 1. nodes H = V", "by auto"], ["proof (state)\nthis:\n  nodes H = V\n\ngoal (1 subgoal):\n 1. maximally_connected H G \\<Longrightarrow>\n    \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)", "assume mc: \"maximally_connected H G\""], ["proof (state)\nthis:\n  maximally_connected H G\n\ngoal (1 subgoal):\n 1. maximally_connected H G \\<Longrightarrow>\n    \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)", "then"], ["proof (chain)\npicking this:\n  maximally_connected H G", "have k: \"\\<And>v v'. v\\<in>V \\<Longrightarrow>  v'\\<in>V \\<Longrightarrow> \n          nodes_connected G v v' \\<Longrightarrow> nodes_connected H v v'\""], ["proof (prove)\nusing this:\n  maximally_connected H G\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> V; v' \\<in> V; nodes_connected G v v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "unfolding maximally_connected_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     \\<forall>v'\\<in>V.\n        nodes_connected G v v' \\<longrightarrow> nodes_connected H v v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> V; v' \\<in> V; nodes_connected G v v'\\<rbrakk>\n       \\<Longrightarrow> nodes_connected H v v'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> V; ?v' \\<in> V; nodes_connected G ?v ?v'\\<rbrakk>\n  \\<Longrightarrow> nodes_connected H ?v ?v'\n\ngoal (1 subgoal):\n 1. maximally_connected H G \\<Longrightarrow>\n    \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)", "show \"(\\<forall>(a,w,b)\\<in>E - edges H. \\<not> (forest (add_edge a w b H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)", "proof (safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "fix x w y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "assume i: \"(x, w, y) \\<in> E\" and ni: \"(x, w, y) \\<notin> edges H\"\n      and f: \"forest (add_edge x w y H)\""], ["proof (state)\nthis:\n  (x, w, y) \\<in> E\n  (x, w, y) \\<notin> edges H\n  forest (add_edge x w y H)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  (x, w, y) \\<in> E", "have xy: \"x\\<in>V\" \"y\\<in>V\""], ["proof (prove)\nusing this:\n  (x, w, y) \\<in> E\n\ngoal (1 subgoal):\n 1. x \\<in> V &&& y \\<in> V", "by (auto dest: E_validD)"], ["proof (state)\nthis:\n  x \\<in> V\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "from f"], ["proof (chain)\npicking this:\n  forest (add_edge x w y H)", "have \"\\<forall>(a,wa,b)\\<in>insert (x, w, y) (edges H). \\<not> nodes_connected (delete_edge a wa b (add_edge x w y H)) a b\""], ["proof (prove)\nusing this:\n  forest (add_edge x w y H)\n\ngoal (1 subgoal):\n 1. \\<forall>(a, wa, b)\\<in>insert (x, w, y) (edges H).\n       \\<not> nodes_connected (delete_edge a wa b (add_edge x w y H)) a b", "unfolding forest_def forest_axioms_def"], ["proof (prove)\nusing this:\n  valid_graph (add_edge x w y H) \\<and>\n  (\\<forall>(a, wa, b)\\<in>edges (add_edge x w y H).\n      \\<not> nodes_connected (delete_edge a wa b (add_edge x w y H)) a b)\n\ngoal (1 subgoal):\n 1. \\<forall>(a, wa, b)\\<in>insert (x, w, y) (edges H).\n       \\<not> nodes_connected (delete_edge a wa b (add_edge x w y H)) a b", "by auto"], ["proof (state)\nthis:\n  \\<forall>(a, wa, b)\\<in>insert (x, w, y) (edges H).\n     \\<not> nodes_connected (delete_edge a wa b (add_edge x w y H)) a b\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>(a, wa, b)\\<in>insert (x, w, y) (edges H).\n     \\<not> nodes_connected (delete_edge a wa b (add_edge x w y H)) a b", "have \"\\<not> nodes_connected (delete_edge x w y (add_edge x w y H)) x y\""], ["proof (prove)\nusing this:\n  \\<forall>(a, wa, b)\\<in>insert (x, w, y) (edges H).\n     \\<not> nodes_connected (delete_edge a wa b (add_edge x w y H)) a b\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected (delete_edge x w y (add_edge x w y H)) x y", "by auto"], ["proof (state)\nthis:\n  \\<not> nodes_connected (delete_edge x w y (add_edge x w y H)) x y\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> nodes_connected (delete_edge x w y (add_edge x w y H)) x y\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"(delete_edge x w y (add_edge x w y H)) = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edge x w y (add_edge x w y H) = H", "using ni xy"], ["proof (prove)\nusing this:\n  (x, w, y) \\<notin> edges H\n  x \\<in> V\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. delete_edge x w y (add_edge x w y H) = H", "by(auto simp: add_edge_def delete_edge_def insert_absorb)"], ["proof (state)\nthis:\n  delete_edge x w y (add_edge x w y H) = H\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected (delete_edge x w y (add_edge x w y H)) x y\n  delete_edge x w y (add_edge x w y H) = H", "have \"\\<not> nodes_connected H x y\""], ["proof (prove)\nusing this:\n  \\<not> nodes_connected (delete_edge x w y (add_edge x w y H)) x y\n  delete_edge x w y (add_edge x w y H) = H\n\ngoal (1 subgoal):\n 1. \\<not> nodes_connected H x y", "by auto"], ["proof (state)\nthis:\n  \\<not> nodes_connected H x y\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> nodes_connected H x y\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  (x, w, y) \\<in> E", "have \"nodes_connected G x y\""], ["proof (prove)\nusing this:\n  (x, w, y) \\<in> E\n\ngoal (1 subgoal):\n 1. nodes_connected G x y", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, w, y) \\<in> E \\<Longrightarrow> nodes_connected G x y", "apply(rule exI[where x=\"[(x,w,y)]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, w, y) \\<in> E \\<Longrightarrow> is_path_undir G x [(x, w, y)] y", "by (auto dest: E_validD)"], ["proof (state)\nthis:\n  nodes_connected G x y\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(a, aa, b) \\<in> E; (a, aa, b) \\<notin> edges H;\n        forest (add_edge a aa b H)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> nodes_connected H x y\n  nodes_connected G x y", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> nodes_connected H x y\n  nodes_connected G x y\n\ngoal (1 subgoal):\n 1. False", "using k[OF xy]"], ["proof (prove)\nusing this:\n  \\<not> nodes_connected H x y\n  nodes_connected G x y\n  nodes_connected G x y \\<Longrightarrow> nodes_connected H x y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  forest_maximally_connected_incl_max_conv:\n  assumes\n    \"forest H\"\n    \"subgraph H G\"\n  shows \"maximally_connected H G = (\\<forall>(a,w,b)\\<in>E - edges H. \\<not> (forest (add_edge a w b H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximally_connected H G =\n    (\\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H))", "using assms forest_maximally_connected_incl_max2 forest_maximally_connected_incl_max1"], ["proof (prove)\nusing this:\n  forest H\n  subgraph H G\n  \\<lbrakk>forest ?H; subgraph ?H G; maximally_connected ?H G\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(a, w, b)\\<in>E - edges ?H.\n                       \\<not> forest (add_edge a w b ?H)\n  \\<lbrakk>forest ?H; subgraph ?H G;\n   \\<forall>(a, w, b)\\<in>E - edges ?H.\n      \\<not> forest (add_edge a w b ?H)\\<rbrakk>\n  \\<Longrightarrow> maximally_connected ?H G\n\ngoal (1 subgoal):\n 1. maximally_connected H G =\n    (\\<forall>(a, w, b)\\<in>E - edges H. \\<not> forest (add_edge a w b H))", "by blast"], ["", "end"], ["", "end"]]}