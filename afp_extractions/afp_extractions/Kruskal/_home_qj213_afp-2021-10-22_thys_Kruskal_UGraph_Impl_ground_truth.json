{"file_name": "/home/qj213/afp-2021-10-22/thys/Kruskal/UGraph_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kruskal", "problem_names": ["lemma max_node_is_Max_V: \" E = \\<alpha> ` set la \\<Longrightarrow>  max_node la = Max (insert 0 V)\"", "lemma spanningForest_eq_basis: \"spanningForest = s.basis\"", "lemma minSpanningForest_eq_minbasis: \"minSpanningForest = s.minBasis\"", "lemma kruskal_correct': \n  \"<emp> kruskal getEdges_impl (\\<lambda>(u,w,v). return (u,v)) ()\n    <\\<lambda>r. \\<up> (distinct r \\<and> set r \\<subseteq> csuper_E \\<and> s.MSF (set (map \\<alpha> r)))>\\<^sub>t\"", "lemma kruskal_correct:\n  \"<emp> kruskal getEdges_impl (\\<lambda>(u,w,v). return (u,v)) ()\n    <\\<lambda>r. \\<up> (distinct r \\<and> set r \\<subseteq> csuper_E \\<and> minSpanningForest (set (map \\<alpha> r)))>\\<^sub>t\"", "lemma not_distinct_map: \"a\\<in>set l \\<Longrightarrow> b\\<in>set l \\<Longrightarrow> a\\<noteq>b \\<Longrightarrow> \\<alpha> a = \\<alpha> b \\<Longrightarrow> \\<not> distinct (map \\<alpha> l)\"", "lemma ii: \"(a, aa, b) \\<in> set L \\<Longrightarrow> uGraph_from_list_\\<alpha>_weight L (Upair a b) = aa\"", "lemmas kruskal_correct = kruskal_correct", "lemma uGraph_from_list_invar_conv: \"uGraph_from_list_invar L = fromlist L\"", "lemma uGraph_from_list_invar_subset: \n  \"uGraph_from_list_invar L \\<Longrightarrow> set L'\\<subseteq> set L \\<Longrightarrow> distinct L' \\<Longrightarrow> uGraph_from_list_invar L'\"", "lemma  uGraph_from_list_\\<alpha>_inj_on: \"uGraph_from_list_invar E \\<Longrightarrow> inj_on \\<alpha> (set E)\"", "lemma sum_easier: \"uGraph_from_list_invar L \n    \\<Longrightarrow> set E \\<subseteq> set L\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L) (uGraph_from_list_\\<alpha>_edges E) = sum (\\<lambda>(u,w,v). w) (set E)\"", "lemma corr: \"uGraph_from_list_invar L \\<Longrightarrow>\n  <emp> kruskal_algo L\n     <\\<lambda>F. \\<up> (uGraph_from_list_invar F \\<and> set F \\<subseteq> set L \\<and>               \n       uGraph.minSpanningForest (uGraph_from_list_\\<alpha>_edges L)\n         (uGraph_from_list_\\<alpha>_weight L) (uGraph_from_list_\\<alpha>_edges F))>\\<^sub>t\"", "lemma \"uGraph_from_list_invar L \\<Longrightarrow>\n  <emp> kruskal_algo L\n     <\\<lambda>F. \\<up> (uGraph_from_list_invar F \\<and> set F \\<subseteq> set L \\<and>\n       uGraph.spanningForest (uGraph_from_list_\\<alpha>_edges L) (uGraph_from_list_\\<alpha>_edges F)\n      \\<and> (\\<forall>F'. uGraph.spanningForest (uGraph_from_list_\\<alpha>_edges L) (uGraph_from_list_\\<alpha>_edges F')\n          \\<longrightarrow> set F' \\<subseteq> set L \\<longrightarrow>  sum (\\<lambda>(u,w,v). w) (set F) \\<le> sum (\\<lambda>(u,w,v). w) (set F')))>\\<^sub>t\"", "lemma \"<emp> kruskal_checked L <\\<lambda>\n    Some F \\<Rightarrow> \\<up> (uGraph_from_list_invar L \\<and> set F \\<subseteq> set L\n       \\<and> uGraph.minSpanningForest (uGraph_from_list_\\<alpha>_edges L) (uGraph_from_list_\\<alpha>_weight L)\n           (uGraph_from_list_\\<alpha>_edges F))\n  | None \\<Rightarrow> \\<up> (\\<not> uGraph_from_list_invar L)>\\<^sub>t\""], "translations": [["", "lemma max_node_is_Max_V: \" E = \\<alpha> ` set la \\<Longrightarrow>  max_node la = Max (insert 0 V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E = \\<alpha> ` set la \\<Longrightarrow> max_node la = Max (insert 0 V)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E = \\<alpha> ` set la \\<Longrightarrow> max_node la = Max (insert 0 V)", "assume E: \"E = \\<alpha> ` set la\""], ["proof (state)\nthis:\n  E = \\<alpha> ` set la\n\ngoal (1 subgoal):\n 1. E = \\<alpha> ` set la \\<Longrightarrow> max_node la = Max (insert 0 V)", "have *: \"fst ` set la \\<union> (snd \\<circ> snd) ` set la = (\\<Union>x\\<in>set la. case x of (x1, x1a, x2a) \\<Rightarrow> {x1, x2a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set la \\<union> (snd \\<circ> snd) ` set la =\n    (\\<Union>x\\<in>set la. case x of (x1, x1a, x2a) \\<Rightarrow> {x1, x2a})", "by auto force"], ["proof (state)\nthis:\n  fst ` set la \\<union> (snd \\<circ> snd) ` set la =\n  (\\<Union>x\\<in>set la. case x of (x1, x1a, x2a) \\<Rightarrow> {x1, x2a})\n\ngoal (1 subgoal):\n 1. E = \\<alpha> ` set la \\<Longrightarrow> max_node la = Max (insert 0 V)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_node la = Max (insert 0 V)", "unfolding E"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_node la = Max (insert 0 (\\<Union> (set_uprod ` \\<alpha> ` set la)))", "using *"], ["proof (prove)\nusing this:\n  fst ` set la \\<union> (snd \\<circ> snd) ` set la =\n  (\\<Union>x\\<in>set la. case x of (x1, x1a, x2a) \\<Rightarrow> {x1, x2a})\n\ngoal (1 subgoal):\n 1. max_node la = Max (insert 0 (\\<Union> (set_uprod ` \\<alpha> ` set la)))", "by (auto simp add: \\<alpha>_def  max_node_def prod.case_distrib)"], ["proof (state)\nthis:\n  max_node la = Max (insert 0 V)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale s: Kruskal_Impl E \"\\<Union>(set_uprod ` E)\" set_uprod \"\\<lambda>u v e. Upair u v = e\"\n  \"subforest\" \"uconnectedV\"  w \\<alpha> \"PR_CONST (\\<lambda>(u,w,v). RETURN (u,v))\"\n  \"PR_CONST (getEdges_SPEC csuper_E)\"\n getEdges_impl \"csuper_E\" \" (\\<lambda>(u,w,v). return (u,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Kruskal_Impl E V set_uprod (\\<lambda>u v. (=) (Upair u v)) subforest\n     (\\<lambda>E'. Restr (uconnected E') V) w \\<alpha>\n     (PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n     (PR_CONST (getEdges_SPEC csuper_E)) getEdges_impl csuper_E\n     (\\<lambda>(u, w, v). return (u, v))", "unfolding subforest_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Kruskal_Impl E V set_uprod (\\<lambda>u v. (=) (Upair u v))\n     (\\<lambda>F. forest F \\<and> F \\<subseteq> E)\n     (\\<lambda>E'. Restr (uconnected E') V) w \\<alpha>\n     (PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n     (PR_CONST (getEdges_SPEC csuper_E)) getEdges_impl csuper_E\n     (\\<lambda>(u, w, v). return (u, v))", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (23 subgoals):\n 1. finite E\n 2. \\<And>E'.\n       forest E' \\<and> E' \\<subseteq> E \\<Longrightarrow> E' \\<subseteq> E\n 3. forest {} \\<and> {} \\<subseteq> E\n 4. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 5. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 6. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 7. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 8. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 9. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 10. \\<And>x y F e.\n        \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n         Upair x y = e\\<rbrakk>\n        \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                          per_union (Restr (uconnected F) V) x y\nA total of 23 subgoals...", "show \"finite E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E", "by simp"], ["proof (state)\nthis:\n  finite E\n\ngoal (22 subgoals):\n 1. \\<And>E'.\n       forest E' \\<and> E' \\<subseteq> E \\<Longrightarrow> E' \\<subseteq> E\n 2. forest {} \\<and> {} \\<subseteq> E\n 3. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 4. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 5. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 6. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 7. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 8. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 9. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 10. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>E'.\n       forest E' \\<and> E' \\<subseteq> E \\<Longrightarrow> E' \\<subseteq> E\n 2. forest {} \\<and> {} \\<subseteq> E\n 3. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 4. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 5. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 6. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 7. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 8. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 9. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 10. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\nA total of 22 subgoals...", "fix E'"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>E'.\n       forest E' \\<and> E' \\<subseteq> E \\<Longrightarrow> E' \\<subseteq> E\n 2. forest {} \\<and> {} \\<subseteq> E\n 3. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 4. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 5. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 6. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 7. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 8. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 9. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 10. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\nA total of 22 subgoals...", "assume \"forest E' \\<and> E' \\<subseteq> E\""], ["proof (state)\nthis:\n  forest E' \\<and> E' \\<subseteq> E\n\ngoal (22 subgoals):\n 1. \\<And>E'.\n       forest E' \\<and> E' \\<subseteq> E \\<Longrightarrow> E' \\<subseteq> E\n 2. forest {} \\<and> {} \\<subseteq> E\n 3. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 4. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 5. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 6. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 7. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 8. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 9. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 10. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\nA total of 22 subgoals...", "then"], ["proof (chain)\npicking this:\n  forest E' \\<and> E' \\<subseteq> E", "show \"E' \\<subseteq> E\""], ["proof (prove)\nusing this:\n  forest E' \\<and> E' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  E' \\<subseteq> E\n\ngoal (21 subgoals):\n 1. forest {} \\<and> {} \\<subseteq> E\n 2. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 3. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 4. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 5. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 6. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 7. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 8. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 9. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 10. \\<And>a b e.\n        Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. forest {} \\<and> {} \\<subseteq> E\n 2. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 3. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 4. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 5. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 6. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 7. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 8. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 9. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 10. \\<And>a b e.\n        Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\nA total of 21 subgoals...", "show \"forest {} \\<and> {} \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forest {} \\<and> {} \\<subseteq> E", "apply (auto simp: decycle_def forest_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>2 < length p; epath {} u p u; distinct p\\<rbrakk>\n       \\<Longrightarrow> False", "using epath.elims(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>epath ?x ?xa ?xb ?xc;\n   \\<And>E u v.\n      \\<lbrakk>?x = E; ?xa = u; ?xb = []; ?xc = v; u = v\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>E u x xs v.\n      \\<lbrakk>?x = E; ?xa = u; ?xb = x # xs; ?xc = v;\n       (\\<exists>w.\n           u \\<noteq> w \\<and> Upair u w = x \\<and> epath E w xs v) \\<and>\n       x \\<in> E\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>u p.\n       \\<lbrakk>2 < length p; epath {} u p u; distinct p\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  forest {} \\<and> {} \\<subseteq> E\n\ngoal (20 subgoals):\n 1. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 2. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 3. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 4. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 5. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 6. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 7. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 8. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 9. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 10. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 2. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 3. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 4. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 5. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 6. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 7. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 8. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 9. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 10. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\nA total of 20 subgoals...", "fix X Y"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 2. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 3. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 4. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 5. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 6. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 7. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 8. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 9. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 10. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\nA total of 20 subgoals...", "assume \"forest X \\<and> X \\<subseteq> E\" \"Y \\<subseteq> X\""], ["proof (state)\nthis:\n  forest X \\<and> X \\<subseteq> E\n  Y \\<subseteq> X\n\ngoal (20 subgoals):\n 1. \\<And>X Y.\n       \\<lbrakk>forest X \\<and> X \\<subseteq> E; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> forest Y \\<and> Y \\<subseteq> E\n 2. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 3. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 4. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 5. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 6. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 7. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 8. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 9. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 10. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  forest X \\<and> X \\<subseteq> E\n  Y \\<subseteq> X", "show \"forest Y \\<and> Y \\<subseteq> E\""], ["proof (prove)\nusing this:\n  forest X \\<and> X \\<subseteq> E\n  Y \\<subseteq> X\n\ngoal (1 subgoal):\n 1. forest Y \\<and> Y \\<subseteq> E", "using forest_mono"], ["proof (prove)\nusing this:\n  forest X \\<and> X \\<subseteq> E\n  Y \\<subseteq> X\n  \\<lbrakk>?Y \\<subseteq> ?X; forest ?X\\<rbrakk> \\<Longrightarrow> forest ?Y\n\ngoal (1 subgoal):\n 1. forest Y \\<and> Y \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  forest Y \\<and> Y \\<subseteq> E\n\ngoal (19 subgoals):\n 1. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 2. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 3. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 5. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 6. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 7. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 8. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 9. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 10. \\<And>a F e.\n        \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n        \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                  insert e F \\<subseteq> E)\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 2. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 3. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 5. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 6. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 7. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 8. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 9. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 10. \\<And>a F e.\n        \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n        \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                  insert e F \\<subseteq> E)\nA total of 19 subgoals...", "case (5 u v)"], ["proof (state)\nthis:\n  \n\ngoal (19 subgoals):\n 1. \\<And>u v.\n       ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n 2. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 3. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 5. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 6. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 7. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 8. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 9. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 10. \\<And>a F e.\n        \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n        \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                  insert e F \\<subseteq> E)\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)", "unfolding uconnected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u, v) \\<in> Restr {(u, v). \\<exists>p. epath {} u p v} V) =\n    (u = v \\<and> v \\<in> V)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x xa.\n       \\<lbrakk>epath {} u p v; x \\<in> E; u \\<in> set_uprod x; xa \\<in> E;\n        v \\<in> set_uprod xa\\<rbrakk>\n       \\<Longrightarrow> u = v", "using epath.elims(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>epath ?x ?xa ?xb ?xc;\n   \\<And>E u v.\n      \\<lbrakk>?x = E; ?xa = u; ?xb = []; ?xc = v; u = v\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>E u x xs v.\n      \\<lbrakk>?x = E; ?xa = u; ?xb = x # xs; ?xc = v;\n       (\\<exists>w.\n           u \\<noteq> w \\<and> Upair u w = x \\<and> epath E w xs v) \\<and>\n       x \\<in> E\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>p x xa.\n       \\<lbrakk>epath {} u p v; x \\<in> E; u \\<in> set_uprod x; xa \\<in> E;\n        v \\<in> set_uprod xa\\<rbrakk>\n       \\<Longrightarrow> u = v", "by force"], ["proof (state)\nthis:\n  ((u, v) \\<in> Restr (uconnected {}) V) = (u = v \\<and> v \\<in> V)\n\ngoal (18 subgoals):\n 1. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 2. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 5. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 6. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 7. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 8. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 9. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 10. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 2. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 5. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 6. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 7. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 8. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 9. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 10. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\nA total of 18 subgoals...", "case (6 E1 E2 u v)"], ["proof (state)\nthis:\n  E1 \\<subseteq> E\n  E2 \\<subseteq> E\n  (u, v) \\<in> Restr (uconnected E1) V\n  (u, v) \\<notin> Restr (uconnected E2) V\n\ngoal (18 subgoals):\n 1. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 2. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 5. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 6. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 7. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 8. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 9. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 10. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  E1 \\<subseteq> E\n  E2 \\<subseteq> E\n  (u, v) \\<in> Restr (uconnected E1) V\n  (u, v) \\<notin> Restr (uconnected E2) V", "have \"(u, v) \\<in> (uconnected E1)\" and uv: \"u \\<in> V\" \"v \\<in> V\""], ["proof (prove)\nusing this:\n  E1 \\<subseteq> E\n  E2 \\<subseteq> E\n  (u, v) \\<in> Restr (uconnected E1) V\n  (u, v) \\<notin> Restr (uconnected E2) V\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> uconnected E1 &&& u \\<in> V &&& v \\<in> V", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> uconnected E1\n  u \\<in> V\n  v \\<in> V\n\ngoal (18 subgoals):\n 1. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 2. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 5. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 6. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 7. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 8. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 9. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 10. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> uconnected E1\n  u \\<in> V\n  v \\<in> V", "obtain p where 1: \"epath E1 u p v\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> uconnected E1\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>p. epath E1 u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding uconnected_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> {(u, v). \\<exists>p. epath E1 u p v}\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>p. epath E1 u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  epath E1 u p v\n\ngoal (18 subgoals):\n 1. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 2. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 5. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 6. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 7. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 8. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 9. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 10. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\nA total of 18 subgoals...", "from 6 uv"], ["proof (chain)\npicking this:\n  E1 \\<subseteq> E\n  E2 \\<subseteq> E\n  (u, v) \\<in> Restr (uconnected E1) V\n  (u, v) \\<notin> Restr (uconnected E2) V\n  u \\<in> V\n  v \\<in> V", "have 2: \"\\<not>(\\<exists>p.  epath E2 u p v)\""], ["proof (prove)\nusing this:\n  E1 \\<subseteq> E\n  E2 \\<subseteq> E\n  (u, v) \\<in> Restr (uconnected E1) V\n  (u, v) \\<notin> Restr (uconnected E2) V\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<nexists>p. epath E2 u p v", "unfolding uconnected_def"], ["proof (prove)\nusing this:\n  E1 \\<subseteq> E\n  E2 \\<subseteq> E\n  (u, v) \\<in> Restr {(u, v). \\<exists>p. epath E1 u p v} V\n  (u, v) \\<notin> Restr {(u, v). \\<exists>p. epath E2 u p v} V\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<nexists>p. epath E2 u p v", "by auto"], ["proof (state)\nthis:\n  \\<nexists>p. epath E2 u p v\n\ngoal (18 subgoals):\n 1. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 2. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 5. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 6. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 7. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 8. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 9. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 10. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\nA total of 18 subgoals...", "from 1 2"], ["proof (chain)\npicking this:\n  epath E1 u p v\n  \\<nexists>p. epath E2 u p v", "have \"\\<exists>a b. (a, b) \\<notin> uconnected E2\n           \\<and> Upair a b \\<notin> E2 \\<and> Upair a b \\<in> E1\""], ["proof (prove)\nusing this:\n  epath E1 u p v\n  \\<nexists>p. epath E2 u p v\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       (a, b) \\<notin> uconnected E2 \\<and>\n       Upair a b \\<notin> E2 \\<and> Upair a b \\<in> E1", "by(rule findaugmenting_edge)"], ["proof (state)\nthis:\n  \\<exists>a b.\n     (a, b) \\<notin> uconnected E2 \\<and>\n     Upair a b \\<notin> E2 \\<and> Upair a b \\<in> E1\n\ngoal (18 subgoals):\n 1. \\<And>E1 E2 u v.\n       \\<lbrakk>E1 \\<subseteq> E; E2 \\<subseteq> E;\n        (u, v) \\<in> Restr (uconnected E1) V;\n        (u, v) \\<notin> Restr (uconnected E2) V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b e.\n                            (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n                            e \\<notin> E2 \\<and>\n                            e \\<in> E1 \\<and> Upair a b = e\n 2. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 4. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 5. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 6. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 7. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 8. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 9. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 10. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     (a, b) \\<notin> uconnected E2 \\<and>\n     Upair a b \\<notin> E2 \\<and> Upair a b \\<in> E1", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     (a, b) \\<notin> uconnected E2 \\<and>\n     Upair a b \\<notin> E2 \\<and> Upair a b \\<in> E1\n\ngoal (1 subgoal):\n 1. \\<exists>a b e.\n       (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n       e \\<notin> E2 \\<and> e \\<in> E1 \\<and> Upair a b = e", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b e.\n     (a, b) \\<notin> Restr (uconnected E2) V \\<and>\n     e \\<notin> E2 \\<and> e \\<in> E1 \\<and> Upair a b = e\n\ngoal (17 subgoals):\n 1. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 4. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 5. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 6. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 7. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 8. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 9. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 10. V \\<subseteq> V\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 4. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 5. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 6. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 7. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 8. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 9. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 10. V \\<subseteq> V\nA total of 17 subgoals...", "case (7 F e u v)"], ["proof (state)\nthis:\n  forest F \\<and> F \\<subseteq> E\n  e \\<in> E - F\n  Upair u v = e\n\ngoal (17 subgoals):\n 1. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 4. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 5. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 6. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 7. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 8. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 9. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 10. V \\<subseteq> V\nA total of 17 subgoals...", "note f = \\<open>forest F \\<and> F \\<subseteq> E\\<close>"], ["proof (state)\nthis:\n  forest F \\<and> F \\<subseteq> E\n\ngoal (17 subgoals):\n 1. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 4. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 5. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 6. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 7. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 8. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 9. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 10. V \\<subseteq> V\nA total of 17 subgoals...", "note notin = \\<open>e \\<in> E - F\\<close> \\<open>Upair u v = e\\<close>"], ["proof (state)\nthis:\n  e \\<in> E - F\n  Upair u v = e\n\ngoal (17 subgoals):\n 1. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 4. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 5. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 6. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 7. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 8. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 9. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 10. V \\<subseteq> V\nA total of 17 subgoals...", "from notin ecard2"], ["proof (chain)\npicking this:\n  e \\<in> E - F\n  Upair u v = e\n  ?e \\<in> E \\<Longrightarrow> proper_uprod ?e", "have unv: \"u\\<noteq>v\""], ["proof (prove)\nusing this:\n  e \\<in> E - F\n  Upair u v = e\n  ?e \\<in> E \\<Longrightarrow> proper_uprod ?e\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by fastforce"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (17 subgoals):\n 1. \\<And>F e u v.\n       \\<lbrakk>forest F \\<and> F \\<subseteq> E; e \\<in> E - F;\n        Upair u v = e\\<rbrakk>\n       \\<Longrightarrow> (forest (insert e F) \\<and>\n                          insert e F \\<subseteq> E) =\n                         ((u, v) \\<notin> Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 3. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 4. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 5. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 6. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 7. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 8. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 9. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 10. V \\<subseteq> V\nA total of 17 subgoals...", "show \"(forest (insert e F) \\<and> insert e F \\<subseteq> E) = ((u, v) \\<notin> uconnectedV F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (forest (insert e F) \\<and> insert e F \\<subseteq> E) =\n    ((u, v) \\<notin> Restr (uconnected F) V)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. forest (insert e F) \\<and> insert e F \\<subseteq> E \\<Longrightarrow>\n    (u, v) \\<notin> Restr (uconnected F) V\n 2. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "assume a: \"forest (insert e F) \\<and> insert e F \\<subseteq> E \""], ["proof (state)\nthis:\n  forest (insert e F) \\<and> insert e F \\<subseteq> E\n\ngoal (2 subgoals):\n 1. forest (insert e F) \\<and> insert e F \\<subseteq> E \\<Longrightarrow>\n    (u, v) \\<notin> Restr (uconnected F) V\n 2. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "have \"(u, v) \\<notin> uconnected F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> uconnected F", "apply(rule insert_stays_forest_means_not_connected)"], ["proof (prove)\ngoal (3 subgoals):\n 1. forest (insert (Upair u v) F)\n 2. Upair u v \\<notin> F\n 3. u \\<noteq> v", "using notin a unv"], ["proof (prove)\nusing this:\n  e \\<in> E - F\n  Upair u v = e\n  forest (insert e F) \\<and> insert e F \\<subseteq> E\n  u \\<noteq> v\n\ngoal (3 subgoals):\n 1. forest (insert (Upair u v) F)\n 2. Upair u v \\<notin> F\n 3. u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<notin> uconnected F\n\ngoal (2 subgoals):\n 1. forest (insert e F) \\<and> insert e F \\<subseteq> E \\<Longrightarrow>\n    (u, v) \\<notin> Restr (uconnected F) V\n 2. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<notin> uconnected F", "show \"((u, v) \\<notin> Restr (uconnected F) V)\""], ["proof (prove)\nusing this:\n  (u, v) \\<notin> uconnected F\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> Restr (uconnected F) V", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<notin> Restr (uconnected F) V\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "assume a: \"(u, v) \\<notin> Restr (uconnected F) V\""], ["proof (state)\nthis:\n  (u, v) \\<notin> Restr (uconnected F) V\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "have \"forest (insert (Upair u v) F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forest (insert (Upair u v) F)", "apply(rule augment_forest_overedges[where E=E])"], ["proof (prove)\ngoal (5 subgoals):\n 1. F \\<subseteq> E\n 2. forest F\n 3. Upair u v \\<in> E\n 4. (u, v) \\<notin> uconnected F\n 5. u \\<noteq> v", "using notin f a unv"], ["proof (prove)\nusing this:\n  e \\<in> E - F\n  Upair u v = e\n  forest F \\<and> F \\<subseteq> E\n  (u, v) \\<notin> Restr (uconnected F) V\n  u \\<noteq> v\n\ngoal (5 subgoals):\n 1. F \\<subseteq> E\n 2. forest F\n 3. Upair u v \\<in> E\n 4. (u, v) \\<notin> uconnected F\n 5. u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  forest (insert (Upair u v) F)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "moreover"], ["proof (state)\nthis:\n  forest (insert (Upair u v) F)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "have \"insert e F \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert e F \\<subseteq> E", "using notin f"], ["proof (prove)\nusing this:\n  e \\<in> E - F\n  Upair u v = e\n  forest F \\<and> F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. insert e F \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  insert e F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> Restr (uconnected F) V \\<Longrightarrow>\n    forest (insert e F) \\<and> insert e F \\<subseteq> E", "ultimately"], ["proof (chain)\npicking this:\n  forest (insert (Upair u v) F)\n  insert e F \\<subseteq> E", "show \"forest (insert e F) \\<and> insert e F \\<subseteq> E\""], ["proof (prove)\nusing this:\n  forest (insert (Upair u v) F)\n  insert e F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. forest (insert e F) \\<and> insert e F \\<subseteq> E", "using notin"], ["proof (prove)\nusing this:\n  forest (insert (Upair u v) F)\n  insert e F \\<subseteq> E\n  e \\<in> E - F\n  Upair u v = e\n\ngoal (1 subgoal):\n 1. forest (insert e F) \\<and> insert e F \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  forest (insert e F) \\<and> insert e F \\<subseteq> E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (forest (insert e F) \\<and> insert e F \\<subseteq> E) =\n  ((u, v) \\<notin> Restr (uconnected F) V)\n\ngoal (16 subgoals):\n 1. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 3. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 4. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 5. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 6. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 7. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 8. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 9. V \\<subseteq> V\n 10. finite V\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 3. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 4. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 5. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 6. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 7. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 8. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 9. V \\<subseteq> V\n 10. finite V\nA total of 16 subgoals...", "fix F"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 3. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 4. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 5. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 6. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 7. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 8. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 9. V \\<subseteq> V\n 10. finite V\nA total of 16 subgoals...", "assume \"F\\<subseteq>E\""], ["proof (state)\nthis:\n  F \\<subseteq> E\n\ngoal (16 subgoals):\n 1. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow> equiv V (Restr (uconnected F) V)\n 2. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 3. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 4. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 5. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 6. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 7. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 8. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 9. V \\<subseteq> V\n 10. finite V\nA total of 16 subgoals...", "show \"equiv V (uconnectedV F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv V (Restr (uconnected F) V)", "by(rule equiv_vert_uconnected)"], ["proof (state)\nthis:\n  equiv V (Restr (uconnected F) V)\n\ngoal (15 subgoals):\n 1. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 2. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 3. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 4. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 5. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 6. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 7. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 8. V \\<subseteq> V\n 9. finite V\n 10. \\<And>a b e T.\n        \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n        \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 2. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 3. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 4. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 5. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 6. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 7. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 8. V \\<subseteq> V\n 9. finite V\n 10. \\<And>a b e T.\n        \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n        \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\nA total of 15 subgoals...", "case (9 F)"], ["proof (state)\nthis:\n  F \\<subseteq> E\n\ngoal (15 subgoals):\n 1. \\<And>F.\n       F \\<subseteq> E \\<Longrightarrow>\n       Restr (uconnected F) V \\<subseteq> V \\<times> V\n 2. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 3. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 4. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 5. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 6. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 7. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 8. V \\<subseteq> V\n 9. finite V\n 10. \\<And>a b e T.\n        \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n        \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  F \\<subseteq> E", "show ?case"], ["proof (prove)\nusing this:\n  F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. Restr (uconnected F) V \\<subseteq> V \\<times> V", "by auto"], ["proof (state)\nthis:\n  Restr (uconnected F) V \\<subseteq> V \\<times> V\n\ngoal (14 subgoals):\n 1. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 2. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 3. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 4. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 5. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 6. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 7. V \\<subseteq> V\n 8. finite V\n 9. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 10. \\<And>xi x.\n        \\<alpha> xi = x \\<Longrightarrow>\n        PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n        \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 2. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 3. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 4. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 5. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 6. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 7. V \\<subseteq> V\n 8. finite V\n 9. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 10. \\<And>xi x.\n        \\<alpha> xi = x \\<Longrightarrow>\n        PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n        \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\nA total of 14 subgoals...", "case (10 x y F)"], ["proof (state)\nthis:\n  x \\<in> V\n  y \\<in> V\n  F \\<subseteq> E\n  e_ \\<in> E\n  Upair x y = e_\n\ngoal (14 subgoals):\n 1. \\<And>x y F e.\n       \\<lbrakk>x \\<in> V; y \\<in> V; F \\<subseteq> E; e \\<in> E;\n        Upair x y = e\\<rbrakk>\n       \\<Longrightarrow> Restr (uconnected (insert e F)) V =\n                         per_union (Restr (uconnected F) V) x y\n 2. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 3. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 4. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 5. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 6. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 7. V \\<subseteq> V\n 8. finite V\n 9. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 10. \\<And>xi x.\n        \\<alpha> xi = x \\<Longrightarrow>\n        PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n        \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  x \\<in> V\n  y \\<in> V\n  F \\<subseteq> E\n  e_ \\<in> E\n  Upair x y = e_", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> V\n  y \\<in> V\n  F \\<subseteq> E\n  e_ \\<in> E\n  Upair x y = e_\n\ngoal (1 subgoal):\n 1. Restr (uconnected (insert e_ F)) V =\n    per_union (Restr (uconnected F) V) x y", "using insert_uconnectedV_per'"], ["proof (prove)\nusing this:\n  x \\<in> V\n  y \\<in> V\n  F \\<subseteq> E\n  e_ \\<in> E\n  Upair x y = e_\n  \\<lbrakk>?x \\<in> V; ?y \\<in> V; ?F \\<subseteq> E\\<rbrakk>\n  \\<Longrightarrow> Restr (uconnected (insert (Upair ?x ?y) ?F)) V =\n                    per_union (Restr (uconnected ?F) V) ?x ?y\n\ngoal (1 subgoal):\n 1. Restr (uconnected (insert e_ F)) V =\n    per_union (Restr (uconnected F) V) x y", "by metis"], ["proof (state)\nthis:\n  Restr (uconnected (insert e_ F)) V =\n  per_union (Restr (uconnected F) V) x y\n\ngoal (13 subgoals):\n 1. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 2. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 3. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 4. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 5. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 6. V \\<subseteq> V\n 7. finite V\n 8. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 9. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 10. PR_CONST (getEdges_SPEC csuper_E)\n     \\<le> SPEC\n            (\\<lambda>L.\n                \\<alpha> ` set L = E \\<and>\n                (\\<forall>(a, wv, b)\\<in>set L.\n                    w (\\<alpha> (a, wv, b)) = wv) \\<and>\n                set L \\<subseteq> csuper_E)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 2. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 3. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 4. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 5. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 6. V \\<subseteq> V\n 7. finite V\n 8. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 9. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 10. PR_CONST (getEdges_SPEC csuper_E)\n     \\<le> SPEC\n            (\\<lambda>L.\n                \\<alpha> ` set L = E \\<and>\n                (\\<forall>(a, wv, b)\\<in>set L.\n                    w (\\<alpha> (a, wv, b)) = wv) \\<and>\n                set L \\<subseteq> csuper_E)\nA total of 13 subgoals...", "case (11 x)"], ["proof (state)\nthis:\n  x \\<in> E\n\ngoal (13 subgoals):\n 1. \\<And>x. x \\<in> E \\<Longrightarrow> \\<exists>a b. Upair a b = x\n 2. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 3. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 4. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 5. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 6. V \\<subseteq> V\n 7. finite V\n 8. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 9. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 10. PR_CONST (getEdges_SPEC csuper_E)\n     \\<le> SPEC\n            (\\<lambda>L.\n                \\<alpha> ` set L = E \\<and>\n                (\\<forall>(a, wv, b)\\<in>set L.\n                    w (\\<alpha> (a, wv, b)) = wv) \\<and>\n                set L \\<subseteq> csuper_E)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  x \\<in> E", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> E\n\ngoal (1 subgoal):\n 1. \\<exists>a b. Upair a b = x", "apply(cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> E; x = Upair a b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. Upair a b = x", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b. Upair a b = x\n\ngoal (12 subgoals):\n 1. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 2. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 3. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 4. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 5. V \\<subseteq> V\n 6. finite V\n 7. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 8. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 9. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 10. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n     \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n              (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 2. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 3. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 4. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 5. V \\<subseteq> V\n 6. finite V\n 7. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 8. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 9. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 10. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n     \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n              (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\nA total of 12 subgoals...", "case (12 u v e)"], ["proof (state)\nthis:\n  Upair u v = e\n\ngoal (12 subgoals):\n 1. \\<And>a b e.\n       Upair a b = e \\<Longrightarrow> {a, b} \\<subseteq> set_uprod e\n 2. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 3. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 4. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 5. V \\<subseteq> V\n 6. finite V\n 7. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 8. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 9. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 10. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n     \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n              (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  Upair u v = e", "show ?case"], ["proof (prove)\nusing this:\n  Upair u v = e\n\ngoal (1 subgoal):\n 1. {u, v} \\<subseteq> set_uprod e", "by auto"], ["proof (state)\nthis:\n  {u, v} \\<subseteq> set_uprod e\n\ngoal (11 subgoals):\n 1. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 2. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 3. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 4. V \\<subseteq> V\n 5. finite V\n 6. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 7. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 8. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 9. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 10. \\<And>la.\n        E = \\<alpha> ` set la \\<Longrightarrow>\n        max_node la = Max (insert 0 V)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 2. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 3. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 4. V \\<subseteq> V\n 5. finite V\n 6. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 7. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 8. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 9. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 10. \\<And>la.\n        E = \\<alpha> ` set la \\<Longrightarrow>\n        max_node la = Max (insert 0 V)\nA total of 11 subgoals...", "case (13 u v e)"], ["proof (state)\nthis:\n  \n\ngoal (11 subgoals):\n 1. \\<And>a b e. (Upair a b = e) = (Upair b a = e)\n 2. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 3. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 4. V \\<subseteq> V\n 5. finite V\n 6. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 7. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 8. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 9. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 10. \\<And>la.\n        E = \\<alpha> ` set la \\<Longrightarrow>\n        max_node la = Max (insert 0 V)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Upair u v = e) = (Upair v u = e)", "by auto"], ["proof (state)\nthis:\n  (Upair u v = e) = (Upair v u = e)\n\ngoal (10 subgoals):\n 1. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 2. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 3. V \\<subseteq> V\n 4. finite V\n 5. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 6. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 7. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 8. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 9. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 10. (\\<lambda>(u, w, v). return (u, v),\n      PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n     \\<in> (nat_assn \\<times>\\<^sub>a\n            int_assn \\<times>\\<^sub>a\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n              nat_assn", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 2. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 3. V \\<subseteq> V\n 4. finite V\n 5. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 6. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 7. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 8. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 9. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 10. (\\<lambda>(u, w, v). return (u, v),\n      PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n     \\<in> (nat_assn \\<times>\\<^sub>a\n            int_assn \\<times>\\<^sub>a\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n              nat_assn", "case (14 a F e)"], ["proof (state)\nthis:\n  e \\<in> E\n  Upair a a = e\n\ngoal (10 subgoals):\n 1. \\<And>a F e.\n       \\<lbrakk>e \\<in> E; Upair a a = e\\<rbrakk>\n       \\<Longrightarrow> \\<not> (forest (insert e F) \\<and>\n                                 insert e F \\<subseteq> E)\n 2. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 3. V \\<subseteq> V\n 4. finite V\n 5. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 6. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 7. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 8. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 9. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 10. (\\<lambda>(u, w, v). return (u, v),\n      PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n     \\<in> (nat_assn \\<times>\\<^sub>a\n            int_assn \\<times>\\<^sub>a\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n              nat_assn", "then"], ["proof (chain)\npicking this:\n  e \\<in> E\n  Upair a a = e", "show ?case"], ["proof (prove)\nusing this:\n  e \\<in> E\n  Upair a a = e\n\ngoal (1 subgoal):\n 1. \\<not> (forest (insert e F) \\<and> insert e F \\<subseteq> E)", "using ecard2"], ["proof (prove)\nusing this:\n  e \\<in> E\n  Upair a a = e\n  ?e \\<in> E \\<Longrightarrow> proper_uprod ?e\n\ngoal (1 subgoal):\n 1. \\<not> (forest (insert e F) \\<and> insert e F \\<subseteq> E)", "by force"], ["proof (state)\nthis:\n  \\<not> (forest (insert e F) \\<and> insert e F \\<subseteq> E)\n\ngoal (9 subgoals):\n 1. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 2. V \\<subseteq> V\n 3. finite V\n 4. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 5. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 6. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 7. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 8. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 9. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 2. V \\<subseteq> V\n 3. finite V\n 4. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 5. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 6. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 7. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 8. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 9. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case (15 v)"], ["proof (state)\nthis:\n  v \\<in> E\n\ngoal (9 subgoals):\n 1. \\<And>e. e \\<in> E \\<Longrightarrow> finite (set_uprod e)\n 2. V \\<subseteq> V\n 3. finite V\n 4. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 5. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 6. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 7. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 8. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 9. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "then"], ["proof (chain)\npicking this:\n  v \\<in> E", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> E\n\ngoal (1 subgoal):\n 1. finite (set_uprod v)", "using ecard2"], ["proof (prove)\nusing this:\n  v \\<in> E\n  ?e \\<in> E \\<Longrightarrow> proper_uprod ?e\n\ngoal (1 subgoal):\n 1. finite (set_uprod v)", "by auto"], ["proof (state)\nthis:\n  finite (set_uprod v)\n\ngoal (8 subgoals):\n 1. V \\<subseteq> V\n 2. finite V\n 3. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 4. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 5. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 6. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 7. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 8. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. V \\<subseteq> V\n 2. finite V\n 3. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 4. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 5. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 6. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 7. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 8. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case 16"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. V \\<subseteq> V\n 2. finite V\n 3. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 4. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 5. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 6. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 7. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 8. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "show \"V \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  V \\<subseteq> V\n\ngoal (7 subgoals):\n 1. finite V\n 2. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 3. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 4. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 5. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 6. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 7. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. finite V\n 2. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 3. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 4. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 5. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 6. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 7. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case 17"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. finite V\n 2. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 3. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 4. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 5. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 6. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 7. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "show \"finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "by simp"], ["proof (state)\nthis:\n  finite V\n\ngoal (6 subgoals):\n 1. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 2. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 3. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 4. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 5. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 6. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 2. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 3. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 4. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 5. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 6. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case (18 a b e T)"], ["proof (state)\nthis:\n  Upair a b = e\n  T \\<subseteq> E\n  e \\<in> T\n\ngoal (6 subgoals):\n 1. \\<And>a b e T.\n       \\<lbrakk>Upair a b = e; T \\<subseteq> E; e \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> Restr (uconnected T) V\n 2. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 3. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 4. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 5. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 6. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "then"], ["proof (chain)\npicking this:\n  Upair a b = e\n  T \\<subseteq> E\n  e \\<in> T", "show ?case"], ["proof (prove)\nusing this:\n  Upair a b = e\n  T \\<subseteq> E\n  e \\<in> T\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> Restr (uconnected T) V", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> uconnected T\n 2. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>E. a \\<in> set_uprod x\n 3. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>E. b \\<in> set_uprod x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> uconnected T", "unfolding uconnected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> {(u, v). \\<exists>p. epath T u p v}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p. epath T a p b", "apply(rule exI[where x=\"[e]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> epath T a [e] b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "using ecard2"], ["proof (prove)\nusing this:\n  ?e \\<in> E \\<Longrightarrow> proper_uprod ?e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "by force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>E. a \\<in> set_uprod x\n 2. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>E. b \\<in> set_uprod x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>E. a \\<in> set_uprod x", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>E. b \\<in> set_uprod x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<subseteq> E; Upair a b \\<in> T; e = Upair a b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>E. b \\<in> set_uprod x", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (a, b) \\<in> Restr (uconnected T) V\n\ngoal (5 subgoals):\n 1. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 2. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 3. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 4. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 5. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 2. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 3. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 4. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 5. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case (19 xi x)"], ["proof (state)\nthis:\n  \\<alpha> xi = x\n\ngoal (5 subgoals):\n 1. \\<And>xi x.\n       \\<alpha> xi = x \\<Longrightarrow>\n       PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n       \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n 2. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 3. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 4. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 5. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "then"], ["proof (chain)\npicking this:\n  \\<alpha> xi = x", "show ?case"], ["proof (prove)\nusing this:\n  \\<alpha> xi = x\n\ngoal (1 subgoal):\n 1. PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n    \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))", "by (auto split: prod.splits simp: \\<alpha>_def)"], ["proof (state)\nthis:\n  PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) xi\n  \\<le> \\<Down> Id (SPEC (\\<lambda>(a, b). Upair a b = x))\n\ngoal (4 subgoals):\n 1. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 2. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 3. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 4. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 2. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 3. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 4. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case 20"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)\n 2. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 3. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 4. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (getEdges_SPEC csuper_E)\n    \\<le> SPEC\n           (\\<lambda>L.\n               \\<alpha> ` set L = E \\<and>\n               (\\<forall>(a, wv, b)\\<in>set L.\n                   w (\\<alpha> (a, wv, b)) = wv) \\<and>\n               set L \\<subseteq> csuper_E)", "by auto"], ["proof (state)\nthis:\n  PR_CONST (getEdges_SPEC csuper_E)\n  \\<le> SPEC\n         (\\<lambda>L.\n             \\<alpha> ` set L = E \\<and>\n             (\\<forall>(a, wv, b)\\<in>set L.\n                 w (\\<alpha> (a, wv, b)) = wv) \\<and>\n             set L \\<subseteq> csuper_E)\n\ngoal (3 subgoals):\n 1. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 2. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 3. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 2. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 3. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case 21"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n 2. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 3. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "using getEdges_impl"], ["proof (prove)\nusing this:\n  (uncurry0 getEdges_impl, uncurry0 (getEdges_SPEC csuper_E))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n           (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n\ngoal (1 subgoal):\n 1. (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "by simp"], ["proof (state)\nthis:\n  (uncurry0 getEdges_impl, uncurry0 (PR_CONST (getEdges_SPEC csuper_E)))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n           (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n\ngoal (2 subgoals):\n 1. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 2. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 2. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case (22 l)"], ["proof (state)\nthis:\n  E = \\<alpha> ` set l\n\ngoal (2 subgoals):\n 1. \\<And>la.\n       E = \\<alpha> ` set la \\<Longrightarrow>\n       max_node la = Max (insert 0 V)\n 2. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "from max_node_is_Max_V[OF 22]"], ["proof (chain)\npicking this:\n  max_node l = Max (insert 0 V)", "show \"max_node l = Max (insert 0 V)\""], ["proof (prove)\nusing this:\n  max_node l = Max (insert 0 V)\n\ngoal (1 subgoal):\n 1. max_node l = Max (insert 0 V)", "."], ["proof (state)\nthis:\n  max_node l = Max (insert 0 V)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "case (23)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(u, w, v). return (u, v),\n     PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           int_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n             nat_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat \\<times> int \\<times> nat);\n        nofail (PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)) x)\\<rbrakk>\n       \\<Longrightarrow> <((\\<lambda>a c.\n                               \\<up>\n                                ((c, a) \\<in> nat_rel)) \\<times>\\<^sub>a\n                           (\\<lambda>a c.\n                               \\<up>\n                                ((c, a) \\<in> int_rel)) \\<times>\\<^sub>a\n                           (\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)))\n                           x xi> case xi of\n                                 (u, w, v) \\<Rightarrow>\n                                   return\n                                    (u, v) <\\<lambda>r.\n         ((\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)) \\<times>\\<^sub>a\n          (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)) \\<times>\\<^sub>a\n          (\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)))\n          x xi *\n         (\\<exists>\\<^sub>Axa.\n             ((\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)) \\<times>\\<^sub>a\n              (\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)))\n              xa r *\n             \\<up>\n              (RETURN xa\n               \\<le> PR_CONST (\\<lambda>(u, w, v). RETURN (u, v))\n                      x))>\\<^sub>t", "by sep_auto"], ["proof (state)\nthis:\n  (\\<lambda>(u, w, v). return (u, v),\n   PR_CONST (\\<lambda>(u, w, v). RETURN (u, v)))\n  \\<in> (nat_assn \\<times>\\<^sub>a\n         int_assn \\<times>\\<^sub>a\n         nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n           nat_assn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spanningForest_eq_basis: \"spanningForest = s.basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spanningForest = s.SpanningForest", "unfolding spanningForest_def  s.basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>X.\n        subforest X \\<and>\n        (\\<forall>x\\<in>E - X. \\<not> subforest (insert x X))) =\n    (\\<lambda>X.\n        subforest X \\<and>\n        (\\<forall>x\\<in>E - X. \\<not> subforest (insert x X)))", "by auto"], ["", "lemma minSpanningForest_eq_minbasis: \"minSpanningForest = s.minBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minSpanningForest = s.MSF", "unfolding minSpanningForest_def  s.MSF_def spanningForest_eq_basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>F.\n        s.SpanningForest F \\<and>\n        (\\<forall>F'.\n            s.SpanningForest F' \\<longrightarrow> sum w F \\<le> sum w F')) =\n    (\\<lambda>B.\n        s.SpanningForest B \\<and>\n        (\\<forall>B'.\n            s.SpanningForest B' \\<longrightarrow> sum w B \\<le> sum w B'))", "by auto"], ["", "lemma kruskal_correct': \n  \"<emp> kruskal getEdges_impl (\\<lambda>(u,w,v). return (u,v)) ()\n    <\\<lambda>r. \\<up> (distinct r \\<and> set r \\<subseteq> csuper_E \\<and> s.MSF (set (map \\<alpha> r)))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> kruskal getEdges_impl (\\<lambda>(u, w, v). return (u, v))\n           () <\\<lambda>r.\n                  \\<up>\n                   (distinct r \\<and>\n                    set r \\<subseteq> csuper_E \\<and>\n                    s.MSF (set (map \\<alpha> r)))>\\<^sub>t", "using s.kruskal_correct_forest"], ["proof (prove)\nusing this:\n  <emp> kruskal getEdges_impl (\\<lambda>(u, w, v). return (u, v))\n         () <\\<lambda>r.\n                \\<up>\n                 (distinct r \\<and>\n                  set r \\<subseteq> csuper_E \\<and>\n                  s.MSF (set (map \\<alpha> r)))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <emp> kruskal getEdges_impl (\\<lambda>(u, w, v). return (u, v))\n           () <\\<lambda>r.\n                  \\<up>\n                   (distinct r \\<and>\n                    set r \\<subseteq> csuper_E \\<and>\n                    s.MSF (set (map \\<alpha> r)))>\\<^sub>t", "by auto"], ["", "lemma kruskal_correct:\n  \"<emp> kruskal getEdges_impl (\\<lambda>(u,w,v). return (u,v)) ()\n    <\\<lambda>r. \\<up> (distinct r \\<and> set r \\<subseteq> csuper_E \\<and> minSpanningForest (set (map \\<alpha> r)))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> kruskal getEdges_impl (\\<lambda>(u, w, v). return (u, v))\n           () <\\<lambda>r.\n                  \\<up>\n                   (distinct r \\<and>\n                    set r \\<subseteq> csuper_E \\<and>\n                    minSpanningForest (set (map \\<alpha> r)))>\\<^sub>t", "using s.kruskal_correct_forest minSpanningForest_eq_minbasis"], ["proof (prove)\nusing this:\n  <emp> kruskal getEdges_impl (\\<lambda>(u, w, v). return (u, v))\n         () <\\<lambda>r.\n                \\<up>\n                 (distinct r \\<and>\n                  set r \\<subseteq> csuper_E \\<and>\n                  s.MSF (set (map \\<alpha> r)))>\\<^sub>t\n  minSpanningForest = s.MSF\n\ngoal (1 subgoal):\n 1. <emp> kruskal getEdges_impl (\\<lambda>(u, w, v). return (u, v))\n           () <\\<lambda>r.\n                  \\<up>\n                   (distinct r \\<and>\n                    set r \\<subseteq> csuper_E \\<and>\n                    minSpanningForest (set (map \\<alpha> r)))>\\<^sub>t", "by auto"], ["", "end"], ["", "subsection \"Kruskal on UGraph from list of concrete edges\""], ["", "definition \"uGraph_from_list_\\<alpha>_weight L e = (THE w. \\<exists>a' b'. Upair a' b' = e \\<and> (a', w, b') \\<in> set L)\""], ["", "abbreviation \"uGraph_from_list_\\<alpha>_edges L \\<equiv> \\<alpha> ` set L\""], ["", "locale fromlist = fixes\n  L :: \"(nat \\<times> int \\<times> nat) list\"\nassumes dist: \"distinct (map \\<alpha> L)\" and no_selfloop: \"\\<forall>u w v. (u,w,v)\\<in>set L \\<longrightarrow> u\\<noteq>v\"\nbegin"], ["", "lemma not_distinct_map: \"a\\<in>set l \\<Longrightarrow> b\\<in>set l \\<Longrightarrow> a\\<noteq>b \\<Longrightarrow> \\<alpha> a = \\<alpha> b \\<Longrightarrow> \\<not> distinct (map \\<alpha> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set l; b \\<in> set l; a \\<noteq> b;\n     \\<alpha> a = \\<alpha> b\\<rbrakk>\n    \\<Longrightarrow> \\<not> distinct (map \\<alpha> l)", "by (meson distinct_map_eq)"], ["", "lemma ii: \"(a, aa, b) \\<in> set L \\<Longrightarrow> uGraph_from_list_\\<alpha>_weight L (Upair a b) = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, aa, b) \\<in> set L \\<Longrightarrow>\n    uGraph_from_list_\\<alpha>_weight L (Upair a b) = aa", "unfolding uGraph_from_list_\\<alpha>_weight_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, aa, b) \\<in> set L \\<Longrightarrow>\n    (THE w.\n        \\<exists>a' b'.\n           Upair a' b' = Upair a b \\<and> (a', w, b') \\<in> set L) =\n    aa", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. (a, aa, b) \\<in> set L \\<Longrightarrow>\n    \\<exists>a' b'. Upair a' b' = Upair a b \\<and> (a', aa, b') \\<in> set L\n 2. \\<And>w.\n       \\<lbrakk>(a, aa, b) \\<in> set L;\n        \\<exists>a' b'.\n           Upair a' b' = Upair a b \\<and> (a', w, b') \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> w = aa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, aa, b) \\<in> set L \\<Longrightarrow>\n    \\<exists>a' b'. Upair a' b' = Upair a b \\<and> (a', aa, b') \\<in> set L", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>(a, aa, b) \\<in> set L;\n        \\<exists>a' b'.\n           Upair a' b' = Upair a b \\<and> (a', w, b') \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> w = aa", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w a' b'.\n       \\<lbrakk>(a, aa, b) \\<in> set L; Upair a' b' = Upair a b;\n        (a', w, b') \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> w = aa", "subgoal for w a' b'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; Upair a' b' = Upair a b;\n     (a', w, b') \\<in> set L\\<rbrakk>\n    \\<Longrightarrow> w = aa", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (a, w, b) \\<in> set L; b' = b;\n     a' = a\\<rbrakk>\n    \\<Longrightarrow> w = aa\n 2. \\<lbrakk>(a, aa, b) \\<in> set L; (b, w, a) \\<in> set L; b' = a;\n     a' = b\\<rbrakk>\n    \\<Longrightarrow> w = aa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (a, w, b) \\<in> set L; b' = b;\n     a' = a\\<rbrakk>\n    \\<Longrightarrow> w = aa", "using distinct_map_eq[OF dist, of \"(a, aa, b)\" \"(a, w, b)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<alpha> (a, aa, b) = \\<alpha> (a, w, b); (a, aa, b) \\<in> set L;\n   (a, w, b) \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> (a, aa, b) = (a, w, b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (a, w, b) \\<in> set L; b' = b;\n     a' = a\\<rbrakk>\n    \\<Longrightarrow> w = aa", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(case (a, aa, b) of (u, w, xa) \\<Rightarrow> Upair u xa) =\n           (case (a, w, b) of (u, w, xa) \\<Rightarrow> Upair u xa);\n   (a, aa, b) \\<in> set L; (a, w, b) \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> (a, aa, b) = (a, w, b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (a, w, b) \\<in> set L; b' = b;\n     a' = a\\<rbrakk>\n    \\<Longrightarrow> w = aa", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (b, w, a) \\<in> set L; b' = a;\n     a' = b\\<rbrakk>\n    \\<Longrightarrow> w = aa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (b, w, a) \\<in> set L; b' = a;\n     a' = b\\<rbrakk>\n    \\<Longrightarrow> w = aa", "using distinct_map_eq[OF dist, of \"(a, aa, b)\" \"(a', w, b')\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<alpha> (a, aa, b) = \\<alpha> (a', w, b');\n   (a, aa, b) \\<in> set L; (a', w, b') \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> (a, aa, b) = (a', w, b')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (b, w, a) \\<in> set L; b' = a;\n     a' = b\\<rbrakk>\n    \\<Longrightarrow> w = aa", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(case (a, aa, b) of (u, w, xa) \\<Rightarrow> Upair u xa) =\n           (case (a', w, b') of (u, w, xa) \\<Rightarrow> Upair u xa);\n   (a, aa, b) \\<in> set L; (a', w, b') \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> (a, aa, b) = (a', w, b')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa, b) \\<in> set L; (b, w, a) \\<in> set L; b' = a;\n     a' = b\\<rbrakk>\n    \\<Longrightarrow> w = aa", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale uGraph_impl \"\\<alpha> ` set L\" \"uGraph_from_list_\\<alpha>_weight L\" \"return L\" \"set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uGraph_impl (uGraph_from_list_\\<alpha>_edges L)\n     (uGraph_from_list_\\<alpha>_weight L) (return L) (set L)", "proof (unfold_locales)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       e \\<in> uGraph_from_list_\\<alpha>_edges L \\<Longrightarrow>\n       proper_uprod e\n 2. finite (uGraph_from_list_\\<alpha>_edges L)\n 3. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "fix e"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       e \\<in> uGraph_from_list_\\<alpha>_edges L \\<Longrightarrow>\n       proper_uprod e\n 2. finite (uGraph_from_list_\\<alpha>_edges L)\n 3. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "assume *: \"e \\<in> \\<alpha> ` set L\""], ["proof (state)\nthis:\n  e \\<in> uGraph_from_list_\\<alpha>_edges L\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       e \\<in> uGraph_from_list_\\<alpha>_edges L \\<Longrightarrow>\n       proper_uprod e\n 2. finite (uGraph_from_list_\\<alpha>_edges L)\n 3. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "from *"], ["proof (chain)\npicking this:\n  e \\<in> uGraph_from_list_\\<alpha>_edges L", "obtain u w v where \"(u,w,v) \\<in> set L\" \"e = \\<alpha> (u, w, v)\""], ["proof (prove)\nusing this:\n  e \\<in> uGraph_from_list_\\<alpha>_edges L\n\ngoal (1 subgoal):\n 1. (\\<And>u w v.\n        \\<lbrakk>(u, w, v) \\<in> set L; e = \\<alpha> (u, w, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (u, w, v) \\<in> set L\n  e = \\<alpha> (u, w, v)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       e \\<in> uGraph_from_list_\\<alpha>_edges L \\<Longrightarrow>\n       proper_uprod e\n 2. finite (uGraph_from_list_\\<alpha>_edges L)\n 3. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "then"], ["proof (chain)\npicking this:\n  (u, w, v) \\<in> set L\n  e = \\<alpha> (u, w, v)", "show \"proper_uprod e\""], ["proof (prove)\nusing this:\n  (u, w, v) \\<in> set L\n  e = \\<alpha> (u, w, v)\n\ngoal (1 subgoal):\n 1. proper_uprod e", "using no_selfloop"], ["proof (prove)\nusing this:\n  (u, w, v) \\<in> set L\n  e = \\<alpha> (u, w, v)\n  \\<forall>u w v. (u, w, v) \\<in> set L \\<longrightarrow> u \\<noteq> v\n\ngoal (1 subgoal):\n 1. proper_uprod e", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  (u, w, v) \\<in> set L\n  e = (case (u, w, v) of (u, w, xa) \\<Rightarrow> Upair u xa)\n  \\<forall>u w v. (u, w, v) \\<in> set L \\<longrightarrow> u \\<noteq> v\n\ngoal (1 subgoal):\n 1. proper_uprod e", "by auto"], ["proof (state)\nthis:\n  proper_uprod e\n\ngoal (2 subgoals):\n 1. finite (uGraph_from_list_\\<alpha>_edges L)\n 2. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (uGraph_from_list_\\<alpha>_edges L)\n 2. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "show \"finite (\\<alpha> ` set L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uGraph_from_list_\\<alpha>_edges L)", "by auto"], ["proof (state)\nthis:\n  finite (uGraph_from_list_\\<alpha>_edges L)\n\ngoal (1 subgoal):\n 1. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(a, wv, b)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (a, wv, b)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "show \"(uncurry0 (return L),uncurry0((SPEC\n          (\\<lambda>La. distinct (map \\<alpha> La) \\<and> \\<alpha> ` set La = \\<alpha> ` set L \n      \\<and> (\\<forall>(aa, wv, ba)\\<in>set La. uGraph_from_list_\\<alpha>_weight L (\\<alpha> (aa, wv, ba)) = wv)\n      \\<and> set La \\<subseteq> set L))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return L),\n     uncurry0\n      (SPEC\n        (\\<lambda>La.\n            distinct (map \\<alpha> La) \\<and>\n            uGraph_from_list_\\<alpha>_edges La =\n            uGraph_from_list_\\<alpha>_edges L \\<and>\n            (\\<forall>(aa, wv, ba)\\<in>set La.\n                uGraph_from_list_\\<alpha>_weight L (\\<alpha> (aa, wv, ba)) =\n                wv) \\<and>\n            set La \\<subseteq> set L)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        nofail\n         (SPEC\n           (\\<lambda>La.\n               distinct (map \\<alpha> La) \\<and>\n               uGraph_from_list_\\<alpha>_edges La =\n               uGraph_from_list_\\<alpha>_edges L \\<and>\n               (\\<forall>(aa, wv, ba)\\<in>set La.\n                   uGraph_from_list_\\<alpha>_weight L\n                    (\\<alpha> (aa, wv, ba)) =\n                   wv) \\<and>\n               set La \\<subseteq> set L))\\<rbrakk>\n       \\<Longrightarrow> <emp> return\n                                L <\\<lambda>r.\nemp *\n(\\<exists>\\<^sub>Ax.\n    list_assn\n     ((\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)))\n     x r *\n    \\<up>\n     (RETURN x\n      \\<le> SPEC\n             (\\<lambda>La.\n                 distinct (map \\<alpha> La) \\<and>\n                 uGraph_from_list_\\<alpha>_edges La =\n                 uGraph_from_list_\\<alpha>_edges L \\<and>\n                 (\\<forall>(aa, wv, ba)\\<in>set La.\n                     uGraph_from_list_\\<alpha>_weight L\n                      (\\<alpha> (aa, wv, ba)) =\n                     wv) \\<and>\n                 set La \\<subseteq> set L)))>\\<^sub>t", "using dist"], ["proof (prove)\nusing this:\n  distinct (map \\<alpha> L)\n\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        nofail\n         (SPEC\n           (\\<lambda>La.\n               distinct (map \\<alpha> La) \\<and>\n               uGraph_from_list_\\<alpha>_edges La =\n               uGraph_from_list_\\<alpha>_edges L \\<and>\n               (\\<forall>(aa, wv, ba)\\<in>set La.\n                   uGraph_from_list_\\<alpha>_weight L\n                    (\\<alpha> (aa, wv, ba)) =\n                   wv) \\<and>\n               set La \\<subseteq> set L))\\<rbrakk>\n       \\<Longrightarrow> <emp> return\n                                L <\\<lambda>r.\nemp *\n(\\<exists>\\<^sub>Ax.\n    list_assn\n     ((\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)))\n     x r *\n    \\<up>\n     (RETURN x\n      \\<le> SPEC\n             (\\<lambda>La.\n                 distinct (map \\<alpha> La) \\<and>\n                 uGraph_from_list_\\<alpha>_edges La =\n                 uGraph_from_list_\\<alpha>_edges L \\<and>\n                 (\\<forall>(aa, wv, ba)\\<in>set La.\n                     uGraph_from_list_\\<alpha>_weight L\n                      (\\<alpha> (aa, wv, ba)) =\n                     wv) \\<and>\n                 set La \\<subseteq> set L)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b ab ba.\n       \\<lbrakk>distinct (map \\<alpha> L); (a, aa, b) \\<in> set L;\n        (ab, ba) \\<Turnstile> emp\\<rbrakk>\n       \\<Longrightarrow> uGraph_from_list_\\<alpha>_weight L\n                          (\\<alpha> (a, aa, b)) =\n                         aa\n 2. \\<lbrakk>distinct (map \\<alpha> L);\n     \\<exists>h. h \\<Turnstile> emp\\<rbrakk>\n    \\<Longrightarrow> set L \\<subseteq> set L\n 3. distinct (map \\<alpha> L) \\<Longrightarrow>\n    emp \\<Longrightarrow>\\<^sub>A\n    list_assn\n     ((\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)))\n     L L *\n    true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map \\<alpha> L); (a_, aa_, b_) \\<in> set L;\n     (ab_, ba_) \\<Turnstile> emp\\<rbrakk>\n    \\<Longrightarrow> uGraph_from_list_\\<alpha>_weight L\n                       (\\<alpha> (a_, aa_, b_)) =\n                      aa_", "using ii"], ["proof (prove)\nusing this:\n  (?a, ?aa, ?b) \\<in> set L \\<Longrightarrow>\n  uGraph_from_list_\\<alpha>_weight L (Upair ?a ?b) = ?aa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map \\<alpha> L); (a_, aa_, b_) \\<in> set L;\n     (ab_, ba_) \\<Turnstile> emp\\<rbrakk>\n    \\<Longrightarrow> uGraph_from_list_\\<alpha>_weight L\n                       (\\<alpha> (a_, aa_, b_)) =\n                      aa_", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  (?a, ?aa, ?b) \\<in> set L \\<Longrightarrow>\n  uGraph_from_list_\\<alpha>_weight L (Upair ?a ?b) = ?aa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map (\\<lambda>(u, w, y). Upair u y) L);\n     (a_, aa_, b_) \\<in> set L; (ab_, ba_) \\<Turnstile> emp\\<rbrakk>\n    \\<Longrightarrow> uGraph_from_list_\\<alpha>_weight L\n                       (case (a_, aa_, b_) of\n                        (u, w, xa) \\<Rightarrow> Upair u xa) =\n                      aa_", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map \\<alpha> L);\n     \\<exists>h. h \\<Turnstile> emp\\<rbrakk>\n    \\<Longrightarrow> set L \\<subseteq> set L\n 2. distinct (map \\<alpha> L) \\<Longrightarrow>\n    emp \\<Longrightarrow>\\<^sub>A\n    list_assn\n     ((\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)))\n     L L *\n    true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map \\<alpha> L);\n     \\<exists>h. h \\<Turnstile> emp\\<rbrakk>\n    \\<Longrightarrow> set L \\<subseteq> set L", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map \\<alpha> L) \\<Longrightarrow>\n    emp \\<Longrightarrow>\\<^sub>A\n    list_assn\n     ((\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)))\n     L L *\n    true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map \\<alpha> L) \\<Longrightarrow>\n    emp \\<Longrightarrow>\\<^sub>A\n    list_assn\n     ((\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)) \\<times>\\<^sub>a\n      (\\<lambda>a c. \\<up> (c = a)))\n     L L *\n    true", "by (auto simp: pure_fold list_assn_emp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (uncurry0 (return L),\n   uncurry0\n    (SPEC\n      (\\<lambda>La.\n          distinct (map \\<alpha> La) \\<and>\n          uGraph_from_list_\\<alpha>_edges La =\n          uGraph_from_list_\\<alpha>_edges L \\<and>\n          (\\<forall>(aa, wv, ba)\\<in>set La.\n              uGraph_from_list_\\<alpha>_weight L (\\<alpha> (aa, wv, ba)) =\n              wv) \\<and>\n          set La \\<subseteq> set L)))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n           (nat_assn \\<times>\\<^sub>a int_assn \\<times>\\<^sub>a nat_assn)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas kruskal_correct = kruskal_correct"], ["", "definition (in -) \"kruskal_algo L = kruskal (return L) (\\<lambda>(u,w,v). return (u,v)) ()\""], ["", "end"], ["", "subsection \\<open>Outside the locale\\<close>"], ["", "definition uGraph_from_list_invar :: \"(nat\\<times>int\\<times>nat) list \\<Rightarrow> bool\" where\n  \"uGraph_from_list_invar L = (distinct (map \\<alpha> L) \\<and> (\\<forall>p\\<in>set L. case p of (u,w,v) \\<Rightarrow>u\\<noteq>v))\""], ["", "lemma uGraph_from_list_invar_conv: \"uGraph_from_list_invar L = fromlist L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L = fromlist L", "by(auto simp add: uGraph_from_list_invar_def fromlist_def)"], ["", "lemma uGraph_from_list_invar_subset: \n  \"uGraph_from_list_invar L \\<Longrightarrow> set L'\\<subseteq> set L \\<Longrightarrow> distinct L' \\<Longrightarrow> uGraph_from_list_invar L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uGraph_from_list_invar L; set L' \\<subseteq> set L;\n     distinct L'\\<rbrakk>\n    \\<Longrightarrow> uGraph_from_list_invar L'", "unfolding uGraph_from_list_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map \\<alpha> L) \\<and>\n             (\\<forall>(u, w, v)\\<in>set L. u \\<noteq> v);\n     set L' \\<subseteq> set L; distinct L'\\<rbrakk>\n    \\<Longrightarrow> distinct (map \\<alpha> L') \\<and>\n                      (\\<forall>(u, w, v)\\<in>set L'. u \\<noteq> v)", "by (auto simp: distinct_map inj_on_subset)"], ["", "lemma  uGraph_from_list_\\<alpha>_inj_on: \"uGraph_from_list_invar E \\<Longrightarrow> inj_on \\<alpha> (set E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar E \\<Longrightarrow> inj_on \\<alpha> (set E)", "by(auto simp: distinct_map uGraph_from_list_invar_def  )"], ["", "lemma sum_easier: \"uGraph_from_list_invar L \n    \\<Longrightarrow> set E \\<subseteq> set L\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L) (uGraph_from_list_\\<alpha>_edges E) = sum (\\<lambda>(u,w,v). w) (set E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uGraph_from_list_invar L; set E \\<subseteq> set L\\<rbrakk>\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L)\n                       (uGraph_from_list_\\<alpha>_edges E) =\n                      (\\<Sum>(u, w, v)\\<in>set E. w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>uGraph_from_list_invar L; set E \\<subseteq> set L\\<rbrakk>\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L)\n                       (uGraph_from_list_\\<alpha>_edges E) =\n                      (\\<Sum>(u, w, v)\\<in>set E. w)", "assume a: \"uGraph_from_list_invar L\""], ["proof (state)\nthis:\n  uGraph_from_list_invar L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uGraph_from_list_invar L; set E \\<subseteq> set L\\<rbrakk>\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L)\n                       (uGraph_from_list_\\<alpha>_edges E) =\n                      (\\<Sum>(u, w, v)\\<in>set E. w)", "assume b: \"set E \\<subseteq> set L\""], ["proof (state)\nthis:\n  set E \\<subseteq> set L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uGraph_from_list_invar L; set E \\<subseteq> set L\\<rbrakk>\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L)\n                       (uGraph_from_list_\\<alpha>_edges E) =\n                      (\\<Sum>(u, w, v)\\<in>set E. w)", "have *: \"\\<And>e. e\\<in>set E \\<Longrightarrow>\n   ((\\<lambda>e. THE w. \\<exists>a' b'. Upair a' b' = e \\<and> (a', w, b') \\<in> set L) \\<circ> \\<alpha>) e\n       = (case e of (u, w, v) \\<Rightarrow> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set E \\<Longrightarrow>\n       ((\\<lambda>e.\n            THE w.\n               \\<exists>a' b'.\n                  Upair a' b' = e \\<and> (a', w, b') \\<in> set L) \\<circ>\n        \\<alpha>)\n        e =\n       (case e of (u, w, v) \\<Rightarrow> w)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set E \\<Longrightarrow>\n       (THE w.\n           \\<exists>a' b'.\n              Upair a' b' = \\<alpha> e \\<and> (a', w, b') \\<in> set L) =\n       (case e of (u, w, v) \\<Rightarrow> w)", "apply(rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       e \\<in> set E \\<Longrightarrow>\n       \\<exists>a' b'.\n          Upair a' b' = \\<alpha> e \\<and>\n          (a', case e of (u, w, v) \\<Rightarrow> w, b') \\<in> set L\n 2. \\<And>e w.\n       \\<lbrakk>e \\<in> set E;\n        \\<exists>a' b'.\n           Upair a' b' = \\<alpha> e \\<and> (a', w, b') \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> w = (case e of (u, w, v) \\<Rightarrow> w)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_ \\<in> set E \\<Longrightarrow>\n    \\<exists>a' b'.\n       Upair a' b' = \\<alpha> e_ \\<and>\n       (a', case e_ of (u, w, v) \\<Rightarrow> w, b') \\<in> set L", "using b"], ["proof (prove)\nusing this:\n  set E \\<subseteq> set L\n\ngoal (1 subgoal):\n 1. e_ \\<in> set E \\<Longrightarrow>\n    \\<exists>a' b'.\n       Upair a' b' = \\<alpha> e_ \\<and>\n       (a', case e_ of (u, w, v) \\<Rightarrow> w, b') \\<in> set L", "by(auto simp: \\<alpha>_def split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e w.\n       \\<lbrakk>e \\<in> set E;\n        \\<exists>a' b'.\n           Upair a' b' = \\<alpha> e \\<and> (a', w, b') \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> w = (case e of (u, w, v) \\<Rightarrow> w)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e_ \\<in> set E;\n     \\<exists>a' b'.\n        Upair a' b' = \\<alpha> e_ \\<and> (a', w_, b') \\<in> set L\\<rbrakk>\n    \\<Longrightarrow> w_ = (case e_ of (u, w, v) \\<Rightarrow> w)", "using a b"], ["proof (prove)\nusing this:\n  uGraph_from_list_invar L\n  set E \\<subseteq> set L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e_ \\<in> set E;\n     \\<exists>a' b'.\n        Upair a' b' = \\<alpha> e_ \\<and> (a', w_, b') \\<in> set L\\<rbrakk>\n    \\<Longrightarrow> w_ = (case e_ of (u, w, v) \\<Rightarrow> w)", "apply(auto simp: uGraph_from_list_invar_def distinct_map split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' b' x1 a b.\n       \\<lbrakk>set E \\<subseteq> set L; (x1, a, b) \\<in> set E; distinct L;\n        inj_on \\<alpha> (set L);\n        \\<forall>x\\<in>set L. \\<forall>x1 a. x \\<noteq> (x1, a, x1);\n        Upair a' b' = \\<alpha> (x1, a, b); (a', w_, b') \\<in> set L;\n        e_ = (x1, a, b)\\<rbrakk>\n       \\<Longrightarrow> w_ = a", "using \\<alpha>_def"], ["proof (prove)\nusing this:\n  \\<alpha> = (\\<lambda>(u, w, v). Upair u v)\n\ngoal (1 subgoal):\n 1. \\<And>a' b' x1 a b.\n       \\<lbrakk>set E \\<subseteq> set L; (x1, a, b) \\<in> set E; distinct L;\n        inj_on \\<alpha> (set L);\n        \\<forall>x\\<in>set L. \\<forall>x1 a. x \\<noteq> (x1, a, x1);\n        Upair a' b' = \\<alpha> (x1, a, b); (a', w_, b') \\<in> set L;\n        e_ = (x1, a, b)\\<rbrakk>\n       \\<Longrightarrow> w_ = a", "by (smt \\<alpha>_def inj_onD old.prod.case prod.inject set_mp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?e \\<in> set E \\<Longrightarrow>\n  ((\\<lambda>e.\n       THE w.\n          \\<exists>a' b'.\n             Upair a' b' = e \\<and> (a', w, b') \\<in> set L) \\<circ>\n   \\<alpha>)\n   ?e =\n  (case ?e of (u, w, v) \\<Rightarrow> w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uGraph_from_list_invar L; set E \\<subseteq> set L\\<rbrakk>\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L)\n                       (uGraph_from_list_\\<alpha>_edges E) =\n                      (\\<Sum>(u, w, v)\\<in>set E. w)", "have inj_on_E: \"inj_on \\<alpha> (set E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<alpha> (set E)", "apply(rule inj_on_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on \\<alpha> ?A\n 2. set E \\<subseteq> ?A", "apply(rule uGraph_from_list_\\<alpha>_inj_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. uGraph_from_list_invar ?E3\n 2. set E \\<subseteq> set ?E3", "by fact+"], ["proof (state)\nthis:\n  inj_on \\<alpha> (set E)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uGraph_from_list_invar L; set E \\<subseteq> set L\\<rbrakk>\n    \\<Longrightarrow> sum (uGraph_from_list_\\<alpha>_weight L)\n                       (uGraph_from_list_\\<alpha>_edges E) =\n                      (\\<Sum>(u, w, v)\\<in>set E. w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (uGraph_from_list_\\<alpha>_weight L)\n     (uGraph_from_list_\\<alpha>_edges E) =\n    (\\<Sum>(u, w, v)\\<in>set E. w)", "unfolding uGraph_from_list_\\<alpha>_weight_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>uGraph_from_list_\\<alpha>_edges E.\n       THE w.\n          \\<exists>a' b'. Upair a' b' = e \\<and> (a', w, b') \\<in> set L) =\n    (\\<Sum>(u, w, v)\\<in>set E. w)", "apply(subst sum.reindex[OF inj_on_E] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>e.\n             THE w.\n                \\<exists>a' b'.\n                   Upair a' b' = e \\<and> (a', w, b') \\<in> set L) \\<circ>\n         \\<alpha>)\n     (set E) =\n    (\\<Sum>(u, w, v)\\<in>set E. w)", "using *"], ["proof (prove)\nusing this:\n  ?e \\<in> set E \\<Longrightarrow>\n  ((\\<lambda>e.\n       THE w.\n          \\<exists>a' b'.\n             Upair a' b' = e \\<and> (a', w, b') \\<in> set L) \\<circ>\n   \\<alpha>)\n   ?e =\n  (case ?e of (u, w, v) \\<Rightarrow> w)\n\ngoal (1 subgoal):\n 1. sum ((\\<lambda>e.\n             THE w.\n                \\<exists>a' b'.\n                   Upair a' b' = e \\<and> (a', w, b') \\<in> set L) \\<circ>\n         \\<alpha>)\n     (set E) =\n    (\\<Sum>(u, w, v)\\<in>set E. w)", "by auto"], ["proof (state)\nthis:\n  sum (uGraph_from_list_\\<alpha>_weight L)\n   (uGraph_from_list_\\<alpha>_edges E) =\n  (\\<Sum>(u, w, v)\\<in>set E. w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma corr: \"uGraph_from_list_invar L \\<Longrightarrow>\n  <emp> kruskal_algo L\n     <\\<lambda>F. \\<up> (uGraph_from_list_invar F \\<and> set F \\<subseteq> set L \\<and>               \n       uGraph.minSpanningForest (uGraph_from_list_\\<alpha>_edges L)\n         (uGraph_from_list_\\<alpha>_weight L) (uGraph_from_list_\\<alpha>_edges F))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal_algo\n           L <\\<lambda>r.\n                 \\<up>\n                  (uGraph_from_list_invar r \\<and>\n                   set r \\<subseteq> set L \\<and>\n                   uGraph.minSpanningForest\n                    (uGraph_from_list_\\<alpha>_edges L)\n                    (uGraph_from_list_\\<alpha>_weight L)\n                    (uGraph_from_list_\\<alpha>_edges r))>\\<^sub>t", "apply(sep_auto heap: fromlist.kruskal_correct\n          simp: uGraph_from_list_invar_conv kruskal_algo_def  )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>fromlist L; in_range (a, b); distinct x;\n        set x \\<subseteq> set L;\n        uGraph.minSpanningForest (uGraph_from_list_\\<alpha>_edges L)\n         (uGraph_from_list_\\<alpha>_weight L)\n         (uGraph_from_list_\\<alpha>_edges x)\\<rbrakk>\n       \\<Longrightarrow> fromlist x", "using uGraph_from_list_invar_subset uGraph_from_list_invar_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>uGraph_from_list_invar ?L; set ?L' \\<subseteq> set ?L;\n   distinct ?L'\\<rbrakk>\n  \\<Longrightarrow> uGraph_from_list_invar ?L'\n  uGraph_from_list_invar ?L = fromlist ?L\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>fromlist L; in_range (a, b); distinct x;\n        set x \\<subseteq> set L;\n        uGraph.minSpanningForest (uGraph_from_list_\\<alpha>_edges L)\n         (uGraph_from_list_\\<alpha>_weight L)\n         (uGraph_from_list_\\<alpha>_edges x)\\<rbrakk>\n       \\<Longrightarrow> fromlist x", "by simp"], ["", "lemma \"uGraph_from_list_invar L \\<Longrightarrow>\n  <emp> kruskal_algo L\n     <\\<lambda>F. \\<up> (uGraph_from_list_invar F \\<and> set F \\<subseteq> set L \\<and>\n       uGraph.spanningForest (uGraph_from_list_\\<alpha>_edges L) (uGraph_from_list_\\<alpha>_edges F)\n      \\<and> (\\<forall>F'. uGraph.spanningForest (uGraph_from_list_\\<alpha>_edges L) (uGraph_from_list_\\<alpha>_edges F')\n          \\<longrightarrow> set F' \\<subseteq> set L \\<longrightarrow>  sum (\\<lambda>(u,w,v). w) (set F) \\<le> sum (\\<lambda>(u,w,v). w) (set F')))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal_algo\n           L <\\<lambda>r.\n                 \\<up>\n                  (uGraph_from_list_invar r \\<and>\n                   set r \\<subseteq> set L \\<and>\n                   uGraph.spanningForest (uGraph_from_list_\\<alpha>_edges L)\n                    (uGraph_from_list_\\<alpha>_edges r) \\<and>\n                   (\\<forall>F'.\n                       uGraph.spanningForest\n                        (uGraph_from_list_\\<alpha>_edges L)\n                        (uGraph_from_list_\\<alpha>_edges\n                          F') \\<longrightarrow>\n                       set F' \\<subseteq> set L \\<longrightarrow>\n                       (\\<Sum>(u, w, v)\\<in>set r. w)\n                       \\<le> (\\<Sum>(u, w, v)\\<in>set F'. w)))>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal_algo\n           L <\\<lambda>r.\n                 \\<up>\n                  (uGraph_from_list_invar r \\<and>\n                   set r \\<subseteq> set L \\<and>\n                   uGraph.spanningForest (uGraph_from_list_\\<alpha>_edges L)\n                    (uGraph_from_list_\\<alpha>_edges r) \\<and>\n                   (\\<forall>F'.\n                       uGraph.spanningForest\n                        (uGraph_from_list_\\<alpha>_edges L)\n                        (uGraph_from_list_\\<alpha>_edges\n                          F') \\<longrightarrow>\n                       set F' \\<subseteq> set L \\<longrightarrow>\n                       (\\<Sum>(u, w, v)\\<in>set r. w)\n                       \\<le> (\\<Sum>(u, w, v)\\<in>set F'. w)))>\\<^sub>t", "assume a: \"uGraph_from_list_invar L\""], ["proof (state)\nthis:\n  uGraph_from_list_invar L\n\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal_algo\n           L <\\<lambda>r.\n                 \\<up>\n                  (uGraph_from_list_invar r \\<and>\n                   set r \\<subseteq> set L \\<and>\n                   uGraph.spanningForest (uGraph_from_list_\\<alpha>_edges L)\n                    (uGraph_from_list_\\<alpha>_edges r) \\<and>\n                   (\\<forall>F'.\n                       uGraph.spanningForest\n                        (uGraph_from_list_\\<alpha>_edges L)\n                        (uGraph_from_list_\\<alpha>_edges\n                          F') \\<longrightarrow>\n                       set F' \\<subseteq> set L \\<longrightarrow>\n                       (\\<Sum>(u, w, v)\\<in>set r. w)\n                       \\<le> (\\<Sum>(u, w, v)\\<in>set F'. w)))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  uGraph_from_list_invar L", "interpret fromlist L"], ["proof (prove)\nusing this:\n  uGraph_from_list_invar L\n\ngoal (1 subgoal):\n 1. fromlist L", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. uGraph_from_list_invar L \\<Longrightarrow> distinct (map \\<alpha> L)\n 2. uGraph_from_list_invar L \\<Longrightarrow>\n    \\<forall>u w v. (u, w, v) \\<in> set L \\<longrightarrow> u \\<noteq> v", "by (auto simp: uGraph_from_list_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal_algo\n           L <\\<lambda>r.\n                 \\<up>\n                  (uGraph_from_list_invar r \\<and>\n                   set r \\<subseteq> set L \\<and>\n                   spanningForest (uGraph_from_list_\\<alpha>_edges r) \\<and>\n                   (\\<forall>F'.\n                       spanningForest\n                        (uGraph_from_list_\\<alpha>_edges\n                          F') \\<longrightarrow>\n                       set F' \\<subseteq> set L \\<longrightarrow>\n                       (\\<Sum>(u, w, v)\\<in>set r. w)\n                       \\<le> (\\<Sum>(u, w, v)\\<in>set F'. w)))>\\<^sub>t", "from a"], ["proof (chain)\npicking this:\n  uGraph_from_list_invar L", "show ?thesis"], ["proof (prove)\nusing this:\n  uGraph_from_list_invar L\n\ngoal (1 subgoal):\n 1. <emp> kruskal_algo\n           L <\\<lambda>r.\n                 \\<up>\n                  (uGraph_from_list_invar r \\<and>\n                   set r \\<subseteq> set L \\<and>\n                   spanningForest (uGraph_from_list_\\<alpha>_edges r) \\<and>\n                   (\\<forall>F'.\n                       spanningForest\n                        (uGraph_from_list_\\<alpha>_edges\n                          F') \\<longrightarrow>\n                       set F' \\<subseteq> set L \\<longrightarrow>\n                       (\\<Sum>(u, w, v)\\<in>set r. w)\n                       \\<le> (\\<Sum>(u, w, v)\\<in>set F'. w)))>\\<^sub>t", "by(sep_auto heap: corr simp: minSpanningForest_def sum_easier)"], ["proof (state)\nthis:\n  <emp> kruskal_algo\n         L <\\<lambda>r.\n               \\<up>\n                (uGraph_from_list_invar r \\<and>\n                 set r \\<subseteq> set L \\<and>\n                 spanningForest (uGraph_from_list_\\<alpha>_edges r) \\<and>\n                 (\\<forall>F'.\n                     spanningForest\n                      (uGraph_from_list_\\<alpha>_edges F') \\<longrightarrow>\n                     set F' \\<subseteq> set L \\<longrightarrow>\n                     (\\<Sum>(u, w, v)\\<in>set r. w)\n                     \\<le> (\\<Sum>(u, w, v)\\<in>set F'. w)))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Kruskal with input check\\<close>"], ["", "definition \"kruskal' L = kruskal (return L)  (\\<lambda>(u,w,v). return (u,v)) ()\""], ["", "definition \"kruskal_checked L = (if uGraph_from_list_invar L\n                             then do { F \\<leftarrow> kruskal' L; return (Some F) }\n                             else return None)\""], ["", "lemma \"<emp> kruskal_checked L <\\<lambda>\n    Some F \\<Rightarrow> \\<up> (uGraph_from_list_invar L \\<and> set F \\<subseteq> set L\n       \\<and> uGraph.minSpanningForest (uGraph_from_list_\\<alpha>_edges L) (uGraph_from_list_\\<alpha>_weight L)\n           (uGraph_from_list_\\<alpha>_edges F))\n  | None \\<Rightarrow> \\<up> (\\<not> uGraph_from_list_invar L)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> kruskal_checked\n           L <\\<lambda>r.\n                 case r of\n                 None \\<Rightarrow> \\<up> (\\<not> uGraph_from_list_invar L)\n                 | Some F \\<Rightarrow>\n                     \\<up>\n                      (uGraph_from_list_invar L \\<and>\n                       set F \\<subseteq> set L \\<and>\n                       uGraph.minSpanningForest\n                        (uGraph_from_list_\\<alpha>_edges L)\n                        (uGraph_from_list_\\<alpha>_weight L)\n                        (uGraph_from_list_\\<alpha>_edges F))>\\<^sub>t", "unfolding kruskal_checked_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> if uGraph_from_list_invar L\n          then kruskal' L \\<bind> (\\<lambda>F. return (Some F))\n          else return\n                None <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               uGraph.minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges L)\n                                (uGraph_from_list_\\<alpha>_weight L)\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "apply(cases \"uGraph_from_list_invar L\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> if uGraph_from_list_invar L\n          then kruskal' L \\<bind> (\\<lambda>F. return (Some F))\n          else return\n                None <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               uGraph.minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges L)\n                                (uGraph_from_list_\\<alpha>_weight L)\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t\n 2. \\<not> uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> if uGraph_from_list_invar L\n          then kruskal' L \\<bind> (\\<lambda>F. return (Some F))\n          else return\n                None <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               uGraph.minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges L)\n                                (uGraph_from_list_\\<alpha>_weight L)\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal' L \\<bind>\n          (\\<lambda>F.\n              return\n               (Some\n                 F)) <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               uGraph.minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges L)\n                                (uGraph_from_list_\\<alpha>_weight L)\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t\n 2. \\<not> uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> return\n           None <\\<lambda>r.\n                    case r of\n                    None \\<Rightarrow>\n                      \\<up> (\\<not> uGraph_from_list_invar L)\n                    | Some F \\<Rightarrow>\n                        \\<up>\n                         (uGraph_from_list_invar L \\<and>\n                          set F \\<subseteq> set L \\<and>\n                          uGraph.minSpanningForest\n                           (uGraph_from_list_\\<alpha>_edges L)\n                           (uGraph_from_list_\\<alpha>_weight L)\n                           (uGraph_from_list_\\<alpha>_edges F))>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal' L \\<bind>\n          (\\<lambda>F.\n              return\n               (Some\n                 F)) <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               uGraph.minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges L)\n                                (uGraph_from_list_\\<alpha>_weight L)\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal' L \\<bind>\n          (\\<lambda>F.\n              return\n               (Some\n                 F)) <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               uGraph.minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges L)\n                                (uGraph_from_list_\\<alpha>_weight L)\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "assume [simp]: \"uGraph_from_list_invar L\""], ["proof (state)\nthis:\n  uGraph_from_list_invar L\n\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal' L \\<bind>\n          (\\<lambda>F.\n              return\n               (Some\n                 F)) <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               uGraph.minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges L)\n                                (uGraph_from_list_\\<alpha>_weight L)\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  uGraph_from_list_invar L", "interpret fromlist L"], ["proof (prove)\nusing this:\n  uGraph_from_list_invar L\n\ngoal (1 subgoal):\n 1. fromlist L", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. uGraph_from_list_invar L \\<Longrightarrow> distinct (map \\<alpha> L)\n 2. uGraph_from_list_invar L \\<Longrightarrow>\n    \\<forall>u w v. (u, w, v) \\<in> set L \\<longrightarrow> u \\<noteq> v", "by(auto simp: uGraph_from_list_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> kruskal' L \\<bind>\n          (\\<lambda>F.\n              return\n               (Some\n                 F)) <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> kruskal' L \\<bind>\n          (\\<lambda>F.\n              return\n               (Some\n                 F)) <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "unfolding kruskal'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> kruskal (return L) (\\<lambda>(u, w, v). return (u, v)) () \\<bind>\n          (\\<lambda>F.\n              return\n               (Some\n                 F)) <\\<lambda>r.\n                         case r of\n                         None \\<Rightarrow>\n                           \\<up> (\\<not> uGraph_from_list_invar L)\n                         | Some F \\<Rightarrow>\n                             \\<up>\n                              (uGraph_from_list_invar L \\<and>\n                               set F \\<subseteq> set L \\<and>\n                               minSpanningForest\n                                (uGraph_from_list_\\<alpha>_edges\n                                  F))>\\<^sub>t", "by (sep_auto heap: kruskal_correct)"], ["proof (state)\nthis:\n  <emp> kruskal' L \\<bind>\n        (\\<lambda>F.\n            return\n             (Some\n               F)) <\\<lambda>r.\n                       case r of\n                       None \\<Rightarrow>\n                         \\<up> (\\<not> uGraph_from_list_invar L)\n                       | Some F \\<Rightarrow>\n                           \\<up>\n                            (uGraph_from_list_invar L \\<and>\n                             set F \\<subseteq> set L \\<and>\n                             minSpanningForest\n                              (uGraph_from_list_\\<alpha>_edges F))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> return\n           None <\\<lambda>r.\n                    case r of\n                    None \\<Rightarrow>\n                      \\<up> (\\<not> uGraph_from_list_invar L)\n                    | Some F \\<Rightarrow>\n                        \\<up>\n                         (uGraph_from_list_invar L \\<and>\n                          set F \\<subseteq> set L \\<and>\n                          uGraph.minSpanningForest\n                           (uGraph_from_list_\\<alpha>_edges L)\n                           (uGraph_from_list_\\<alpha>_weight L)\n                           (uGraph_from_list_\\<alpha>_edges F))>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> uGraph_from_list_invar L \\<Longrightarrow>\n    <emp> return\n           None <\\<lambda>r.\n                    case r of\n                    None \\<Rightarrow>\n                      \\<up> (\\<not> uGraph_from_list_invar L)\n                    | Some F \\<Rightarrow>\n                        \\<up>\n                         (uGraph_from_list_invar L \\<and>\n                          set F \\<subseteq> set L \\<and>\n                          uGraph.minSpanningForest\n                           (uGraph_from_list_\\<alpha>_edges L)\n                           (uGraph_from_list_\\<alpha>_weight L)\n                           (uGraph_from_list_\\<alpha>_edges F))>\\<^sub>t", "by sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Code export\\<close>"], ["", "export_code uGraph_from_list_invar checking SML_imp"], ["", "export_code kruskal_checked checking SML_imp"], ["", "ML_val \\<open>\n  val export_nat = @{code integer_of_nat}\n  val import_nat = @{code nat_of_integer}\n  val export_int = @{code integer_of_int}\n  val import_int = @{code int_of_integer}\n  val import_list = map (fn (a,b,c) => (import_nat a, (import_int b, import_nat c)))\n  val export_list = map (fn (a,(b,c)) => (export_nat a, export_int b, export_nat c))\n  val export_Some_list = (fn SOME l => SOME (export_list l) | NONE => NONE)\n\n  fun kruskal l = @{code kruskal} (fn () => import_list l) (fn (a,(_,c)) => fn () => (a,c)) () ()\n                     |> export_list \n  fun kruskal_checked l = @{code kruskal_checked} (import_list l) ()  |> export_Some_list\n\n\n  val result = kruskal [(1,~9,2),(2,~3,3),(3,~4,1)]\n  val result4 = kruskal [(1,~100,4), (3,64,5), (1,13,2), (3,20,2), (2,5,5), (4,80,3), (4,40,5)]\n\n  val result' = kruskal_checked [(1,~9,2),(2,~3,3),(3,~4,1)]\n  val result1' = kruskal_checked [(1,~9,2),(2,~3,3),(3,~4,1),(1,5,3)]\n  val result2' = kruskal_checked [(1,~9,2),(2,~3,3),(3,~4,1),(3,~4,1)]\n  val result3' = kruskal_checked [(1,~9,2),(2,~3,3),(3,~4,1),(1,~4,1)]\n  val result4' = kruskal_checked [(1,~100,4), (3,64,5), (1,13,2), (3,20,2),\n                                   (2,5,5), (4,80,3), (4,40,5)]\n\\<close>"], ["", "end"]]}