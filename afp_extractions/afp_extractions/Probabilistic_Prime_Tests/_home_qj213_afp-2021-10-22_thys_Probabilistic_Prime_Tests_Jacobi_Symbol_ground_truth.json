{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests/Jacobi_Symbol.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests", "problem_names": ["lemma Jacobi_0_right [simp]: \"Jacobi a 0 = 0\"", "lemma Jacobi_mult_left [simp]: \"Jacobi (a * b) n = Jacobi a n * Jacobi b n\"", "lemma Jacobi_mult_right [simp]: \"Jacobi a (n * m) = Jacobi a n * Jacobi a m\"", "lemma prime_p_Jacobi_eq_Legendre[intro!]: \"prime p \\<Longrightarrow> Jacobi a p = Legendre a p\"", "lemma Jacobi_mod [simp]: \"Jacobi (a mod m) n = Jacobi a n\" if \"n dvd m\"", "lemma Jacobi_mod_cong: \"[a = b] (mod n) \\<Longrightarrow> Jacobi a n = Jacobi b n\"", "lemma Jacobi_1_eq_1 [simp]: \"p \\<noteq> 0 \\<Longrightarrow> Jacobi 1 p = 1\"", "lemma Jacobi_eq_0_not_coprime:\n  assumes \"n \\<noteq> 0\" \"\\<not>coprime a n\"\n  shows   \"Jacobi a n = 0\"", "lemma Jacobi_p_eq_2'[simp]: \"n > 0 \\<Longrightarrow> Jacobi a (2^n) = a mod 2\"", "lemma Jacobi_prod_mset[simp]: \"n \\<noteq> 0 \\<Longrightarrow> Jacobi (prod_mset M) n = (\\<Prod>q\\<in>#M. Jacobi q n)\"", "lemma non_trivial_coprime_neq:\n  \"1 < a \\<Longrightarrow> 1 < b \\<Longrightarrow> coprime a b \\<Longrightarrow> a \\<noteq> b\" for a b :: int", "lemma odd_odd_even: \n  fixes a b :: int \n  assumes \"odd a\" \"odd b\"\n  shows \"even ((a*b-1) div 2) = even ((a-1) div 2 + (b-1) div 2)\"", "lemma prime_nonprime_wlog [case_names primes nonprime sym]:\n  assumes \"\\<And>p q. prime p \\<Longrightarrow> prime q \\<Longrightarrow> P p q\"\n  assumes \"\\<And>p q. \\<not>prime p \\<Longrightarrow> P p q\"\n  assumes \"\\<And>p q. P p q \\<Longrightarrow> P q p\"\n  shows   \"P p q\"", "lemma Quadratic_Reciprocity_Jacobi:\n  fixes p q :: int\n  assumes \"coprime p q\"\n      and \"2 < p\" \"2 < q\"\n      and \"odd p\" \"odd q\"\n    shows \"Jacobi p q * Jacobi q p =\n           (- 1) ^ (nat ((p - 1) div 2 * ((q - 1) div 2)))\"", "lemma Jacobi_values: \"Jacobi p q \\<in> {1, -1, 0}\"", "lemma Quadratic_Reciprocity_Jacobi':\n  fixes p q :: int\n  assumes \"coprime p q\"\n      and \"2 < p\" \"2 < q\"\n      and \"odd p\" \"odd q\"\n    shows \"Jacobi q p = (if p mod 4 = 3 \\<and> q mod 4 = 3 then -1 else 1) * Jacobi p q\"", "lemma dvd_odd_square: \"8 dvd a\\<^sup>2 - 1\" if \"odd a\" for a :: int", "lemma odd_odd_even': \n  fixes a b :: int \n  assumes \"odd a\" \"odd b\"\n  shows \"even (((a * b)\\<^sup>2 - 1) div 8) \\<longleftrightarrow> even (((a\\<^sup>2 - 1) div 8) + ((b\\<^sup>2 - 1) div 8))\"", "lemma odd_odd_even_nat': \n  fixes a b :: nat \n  assumes \"odd a\" \"odd b\"\n  shows \"even (((a * b)\\<^sup>2 - 1) div 8) \\<longleftrightarrow> even (((a\\<^sup>2 - 1) div 8) + ((b\\<^sup>2 - 1) div 8))\"", "lemma supplement2_Jacobi: \"odd p \\<Longrightarrow> p > 1 \\<Longrightarrow> Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\"", "lemma mod_nat_wlog [consumes 1, case_names modulo]:\n  fixes P :: \"nat \\<Rightarrow> bool\"\n  assumes \"b > 0\"\n  assumes \"\\<And>k. k \\<in> {0..<b} \\<Longrightarrow> n mod b = k \\<Longrightarrow> P n\"\n  shows   \"P n\"", "lemma mod_int_wlog [consumes 1, case_names modulo]:\n  fixes P :: \"int \\<Rightarrow> bool\"\n  assumes \"b > 0\"\n  assumes \"\\<And>k. 0 \\<le> k \\<Longrightarrow> k < b \\<Longrightarrow> n mod b = k \\<Longrightarrow> P n\"\n  shows   \"P n\"", "lemma supplement2_Jacobi':\n  assumes \"odd p\" and \"p > 1\"\n  shows \"Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else -1)\"", "theorem supplement1_Jacobi:\n  \"odd p \\<Longrightarrow> 1 < p \\<Longrightarrow> Jacobi (-1) p = (-1) ^ (nat ((p - 1) div 2))\"", "theorem supplement1_Jacobi':\n  \"odd n \\<Longrightarrow> 1 < n \\<Longrightarrow> Jacobi (-1) n = (if n mod 4 = 1 then 1 else -1)\"", "lemma Jacobi_0_eq_0: \"\\<not>is_unit n \\<Longrightarrow> Jacobi 0 n = 0\"", "lemma is_unit_Jacobi_aux: \"is_unit x \\<Longrightarrow> Jacobi a x = 1\"", "lemma is_unit_Jacobi[simp]: \"Jacobi a 1 = 1\" \"Jacobi a (-1) = 1\"", "lemma Jacobi_neg_right [simp]:\n  \"Jacobi a (-n) = Jacobi a n\"", "lemma Jacobi_neg_left:\n  assumes \"odd n\" \"1 < n\" \n  shows   \"Jacobi (-a) n = (if n mod 4 = 1 then 1 else -1) * Jacobi a n\"", "lemmas [simp del] = jacobi_code.simps", "lemma Jacobi_code [code]: \"Jacobi a n = jacobi_code a n\"", "lemma Jacobi_eq_0_imp_not_coprime:\n  assumes \"p \\<noteq> 0\" \"p \\<noteq> 1\"\n  shows   \"Jacobi n p = 0 \\<Longrightarrow> \\<not>coprime n p\"", "lemma Jacobi_eq_0_iff_not_coprime:\n  assumes \"p \\<noteq> 0\" \"p \\<noteq> 1\"\n  shows \"Jacobi n p = 0 \\<longleftrightarrow> \\<not>coprime n p\""], "translations": [["", "lemma Jacobi_0_right [simp]: \"Jacobi a 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a 0 = 0", "by (simp add: Jacobi_def)"], ["", "lemma Jacobi_mult_left [simp]: \"Jacobi (a * b) n = Jacobi a n * Jacobi b n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (a * b) n = Jacobi a n * Jacobi b n", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> Jacobi (a * b) n = Jacobi a n * Jacobi b n\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    Jacobi (a * b) n = Jacobi a n * Jacobi b n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> Jacobi (a * b) n = Jacobi a n * Jacobi b n\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    Jacobi (a * b) n = Jacobi a n * Jacobi b n", "have *: \"{# Legendre (a * b) p          . p \\<in># prime_factorization n #} =\n           {# Legendre a p * Legendre b p . p \\<in># prime_factorization n #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (Legendre (a * b)) (prime_factorization n) =\n    {#Legendre a p * Legendre b p. p \\<in># prime_factorization n#}", "by (meson Legendre_mult in_prime_factors_imp_prime image_mset_cong)"], ["proof (state)\nthis:\n  image_mset (Legendre (a * b)) (prime_factorization n) =\n  {#Legendre a p * Legendre b p. p \\<in># prime_factorization n#}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> Jacobi (a * b) n = Jacobi a n * Jacobi b n\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    Jacobi (a * b) n = Jacobi a n * Jacobi b n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (a * b) n = Jacobi a n * Jacobi b n", "using False"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Jacobi (a * b) n = Jacobi a n * Jacobi b n", "unfolding Jacobi_def * prod_mset.distrib"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if n = 0 then 0\n     else \\<Prod>\\<^sub>#\n           (image_mset (Legendre a) (prime_factorization n)) *\n          \\<Prod>\\<^sub>#\n           (image_mset (Legendre b) (prime_factorization n))) =\n    (if n = 0 then 0\n     else \\<Prod>\\<^sub>#\n           (image_mset (Legendre a) (prime_factorization n))) *\n    (if n = 0 then 0\n     else \\<Prod>\\<^sub># (image_mset (Legendre b) (prime_factorization n)))", "by auto"], ["proof (state)\nthis:\n  Jacobi (a * b) n = Jacobi a n * Jacobi b n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> Jacobi (a * b) n = Jacobi a n * Jacobi b n", "qed auto"], ["", "lemma Jacobi_mult_right [simp]: \"Jacobi a (n * m) = Jacobi a n * Jacobi a m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a (n * m) = Jacobi a n * Jacobi a m", "by (cases \"m = 0\"; cases \"n = 0\")\n     (auto simp: Jacobi_def prime_factorization_mult)"], ["", "lemma prime_p_Jacobi_eq_Legendre[intro!]: \"prime p \\<Longrightarrow> Jacobi a p = Legendre a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow> Jacobi a p = Legendre a p", "unfolding Jacobi_def prime_factorization_prime"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow>\n    (if p = 0 then 0 else \\<Prod>\\<^sub># (image_mset (Legendre a) {#p#})) =\n    Legendre a p", "by simp"], ["", "lemma Jacobi_mod [simp]: \"Jacobi (a mod m) n = Jacobi a n\" if \"n dvd m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (a mod m) n = Jacobi a n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Jacobi (a mod m) n = Jacobi a n", "have *: \"{# Legendre (a mod m) p . p \\<in># prime_factorization n #} =\n           {# Legendre a p . p \\<in># prime_factorization n #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (Legendre (a mod m)) (prime_factorization n) =\n    image_mset (Legendre a) (prime_factorization n)", "using that"], ["proof (prove)\nusing this:\n  n dvd m\n\ngoal (1 subgoal):\n 1. image_mset (Legendre (a mod m)) (prime_factorization n) =\n    image_mset (Legendre a) (prime_factorization n)", "by (intro image_mset_cong, subst Legendre_mod)\n       (auto intro: dvd_trans[OF in_prime_factors_imp_dvd])"], ["proof (state)\nthis:\n  image_mset (Legendre (a mod m)) (prime_factorization n) =\n  image_mset (Legendre a) (prime_factorization n)\n\ngoal (1 subgoal):\n 1. Jacobi (a mod m) n = Jacobi a n", "thus ?thesis"], ["proof (prove)\nusing this:\n  image_mset (Legendre (a mod m)) (prime_factorization n) =\n  image_mset (Legendre a) (prime_factorization n)\n\ngoal (1 subgoal):\n 1. Jacobi (a mod m) n = Jacobi a n", "by (simp add: Jacobi_def)"], ["proof (state)\nthis:\n  Jacobi (a mod m) n = Jacobi a n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Jacobi_mod_cong: \"[a = b] (mod n) \\<Longrightarrow> Jacobi a n = Jacobi b n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod n) \\<Longrightarrow> Jacobi a n = Jacobi b n", "by (metis Jacobi_mod cong_def dvd_refl)"], ["", "lemma Jacobi_1_eq_1 [simp]: \"p \\<noteq> 0 \\<Longrightarrow> Jacobi 1 p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> Jacobi 1 p = 1", "by (simp add: Jacobi_def in_prime_factors_imp_prime cong: image_mset_cong)"], ["", "lemma Jacobi_eq_0_not_coprime:\n  assumes \"n \\<noteq> 0\" \"\\<not>coprime a n\"\n  shows   \"Jacobi a n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a n = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Jacobi a n = 0", "from assms"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  \\<not> coprime a n", "have \"\\<exists>p. p dvd gcd a n \\<and> prime p\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  \\<not> coprime a n\n\ngoal (1 subgoal):\n 1. \\<exists>p. p dvd gcd a n \\<and> prime p", "by (intro prime_divisor_exists) auto"], ["proof (state)\nthis:\n  \\<exists>p. p dvd gcd a n \\<and> prime p\n\ngoal (1 subgoal):\n 1. Jacobi a n = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. p dvd gcd a n \\<and> prime p", "obtain p where p: \"p dvd a\" \"p dvd n\" \"prime p\""], ["proof (prove)\nusing this:\n  \\<exists>p. p dvd gcd a n \\<and> prime p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p dvd a; p dvd n; prime p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p dvd a\n  p dvd n\n  prime p\n\ngoal (1 subgoal):\n 1. Jacobi a n = 0", "hence \"Legendre a p = 0\""], ["proof (prove)\nusing this:\n  p dvd a\n  p dvd n\n  prime p\n\ngoal (1 subgoal):\n 1. Legendre a p = 0", "using assms"], ["proof (prove)\nusing this:\n  p dvd a\n  p dvd n\n  prime p\n  n \\<noteq> 0\n  \\<not> coprime a n\n\ngoal (1 subgoal):\n 1. Legendre a p = 0", "by (auto simp: prime_int_iff)"], ["proof (state)\nthis:\n  Legendre a p = 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Legendre a p = 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = 0", "using p assms"], ["proof (prove)\nusing this:\n  Legendre a p = 0\n  p dvd a\n  p dvd n\n  prime p\n  n \\<noteq> 0\n  \\<not> coprime a n\n\ngoal (1 subgoal):\n 1. Jacobi a n = 0", "unfolding Jacobi_def"], ["proof (prove)\nusing this:\n  Legendre a p = 0\n  p dvd a\n  p dvd n\n  prime p\n  n \\<noteq> 0\n  \\<not> coprime a n\n\ngoal (1 subgoal):\n 1. (if n = 0 then 0\n     else \\<Prod>\\<^sub>#\n           (image_mset (Legendre a) (prime_factorization n))) =\n    0", "by (auto simp: image_iff prime_factors_dvd)"], ["proof (state)\nthis:\n  Jacobi a n = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Jacobi_p_eq_2'[simp]: \"n > 0 \\<Longrightarrow> Jacobi a (2^n) = a mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> Jacobi a (2 ^ n) = a mod 2", "by (auto simp add: Jacobi_def prime_factorization_prime_power)"], ["", "lemma Jacobi_prod_mset[simp]: \"n \\<noteq> 0 \\<Longrightarrow> Jacobi (prod_mset M) n = (\\<Prod>q\\<in>#M. Jacobi q n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    Jacobi (\\<Prod>\\<^sub># M) n = (\\<Prod>q\\<in>#M. Jacobi q n)", "by (induction M) simp_all"], ["", "lemma non_trivial_coprime_neq:\n  \"1 < a \\<Longrightarrow> 1 < b \\<Longrightarrow> coprime a b \\<Longrightarrow> a \\<noteq> b\" for a b :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < a; 1 < b; coprime a b\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "by auto"], ["", "lemma odd_odd_even: \n  fixes a b :: int \n  assumes \"odd a\" \"odd b\"\n  shows \"even ((a*b-1) div 2) = even ((a-1) div 2 + (b-1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even ((a * b - 1) div 2) = even ((a - 1) div 2 + (b - 1) div 2)", "using assms"], ["proof (prove)\nusing this:\n  odd a\n  odd b\n\ngoal (1 subgoal):\n 1. even ((a * b - 1) div 2) = even ((a - 1) div 2 + (b - 1) div 2)", "by (auto elim!: oddE simp: algebra_simps)"], ["", "lemma prime_nonprime_wlog [case_names primes nonprime sym]:\n  assumes \"\\<And>p q. prime p \\<Longrightarrow> prime q \\<Longrightarrow> P p q\"\n  assumes \"\\<And>p q. \\<not>prime p \\<Longrightarrow> P p q\"\n  assumes \"\\<And>p q. P p q \\<Longrightarrow> P q p\"\n  shows   \"P p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p q", "by (cases \"prime p\"; cases \"prime q\") (auto intro: assms)"], ["", "lemma Quadratic_Reciprocity_Jacobi:\n  fixes p q :: int\n  assumes \"coprime p q\"\n      and \"2 < p\" \"2 < q\"\n      and \"odd p\" \"odd q\"\n    shows \"Jacobi p q * Jacobi q p =\n           (- 1) ^ (nat ((p - 1) div 2 * ((q - 1) div 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "using assms"], ["proof (prove)\nusing this:\n  coprime p q\n  2 < p\n  2 < q\n  odd p\n  odd q\n\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "proof (induction \"nat p\" \"nat q\" arbitrary: p q \n         rule: measure_induct_rule[where f = \"\\<lambda>(a, b). a + b\", split_format(complete), simplified])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<And>pa qa.\n                   \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa;\n                    2 < pa; 2 < qa; odd pa; odd qa\\<rbrakk>\n                   \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                                     (- 1) ^\n                                     nat\n((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "case (1 p q)"], ["proof (state)\nthis:\n  \\<lbrakk>nat ?p + nat ?q < nat p + nat q; coprime ?p ?q; 2 < ?p; 2 < ?q;\n   odd ?p; odd ?q\\<rbrakk>\n  \\<Longrightarrow> Jacobi ?p ?q * Jacobi ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  coprime p q\n  2 < p\n  2 < q\n  odd p\n  odd q\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<And>pa qa.\n                   \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa;\n                    2 < pa; 2 < qa; odd pa; odd qa\\<rbrakk>\n                   \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                                     (- 1) ^\n                                     nat\n((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>nat ?p + nat ?q < nat p + nat q; coprime ?p ?q; 2 < ?p; 2 < ?q;\n   odd ?p; odd ?q\\<rbrakk>\n  \\<Longrightarrow> Jacobi ?p ?q * Jacobi ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  coprime p q\n  2 < p\n  2 < q\n  odd p\n  odd q\n\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "proof (induction p q rule: prime_nonprime_wlog)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>prime p; prime q;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 2. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 3. \\<And>p q.\n       \\<lbrakk>\\<lbrakk>\\<And>pa qa.\n                            \\<lbrakk>nat pa + nat qa < nat p + nat q;\n                             coprime pa qa; 2 < pa; 2 < qa; odd pa;\n                             odd qa\\<rbrakk>\n                            \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n        (- 1) ^ nat ((pa - 1) div 2 * ((qa - 1) div 2));\n                 coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n                \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                                  (- 1) ^\n                                  nat ((p - 1) div 2 * ((q - 1) div 2));\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat q + nat p; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime q p; 2 < q; 2 < p; odd q; odd p\\<rbrakk>\n       \\<Longrightarrow> Jacobi q p * Jacobi p q =\n                         (- 1) ^ nat ((q - 1) div 2 * ((p - 1) div 2))", "case (sym p q)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>p q.\n              \\<lbrakk>nat p + nat q < nat p + nat q; coprime p q; 2 < p;\n               2 < q; odd p; odd q\\<rbrakk>\n              \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                                (- 1) ^\n                                nat ((p - 1) div 2 * ((q - 1) div 2));\n   coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n  \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                    (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n  \\<lbrakk>nat ?p + nat ?q < nat q + nat p; coprime ?p ?q; 2 < ?p; 2 < ?q;\n   odd ?p; odd ?q\\<rbrakk>\n  \\<Longrightarrow> Jacobi ?p ?q * Jacobi ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  coprime q p\n  2 < q\n  2 < p\n  odd q\n  odd p\n\ngoal (3 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>prime p; prime q;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 2. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 3. \\<And>p q.\n       \\<lbrakk>\\<lbrakk>\\<And>pa qa.\n                            \\<lbrakk>nat pa + nat qa < nat p + nat q;\n                             coprime pa qa; 2 < pa; 2 < qa; odd pa;\n                             odd qa\\<rbrakk>\n                            \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n        (- 1) ^ nat ((pa - 1) div 2 * ((qa - 1) div 2));\n                 coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n                \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                                  (- 1) ^\n                                  nat ((p - 1) div 2 * ((q - 1) div 2));\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat q + nat p; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime q p; 2 < q; 2 < p; odd q; odd p\\<rbrakk>\n       \\<Longrightarrow> Jacobi q p * Jacobi p q =\n                         (- 1) ^ nat ((q - 1) div 2 * ((p - 1) div 2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>p q.\n              \\<lbrakk>nat p + nat q < nat p + nat q; coprime p q; 2 < p;\n               2 < q; odd p; odd q\\<rbrakk>\n              \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                                (- 1) ^\n                                nat ((p - 1) div 2 * ((q - 1) div 2));\n   coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n  \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                    (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n  \\<lbrakk>nat ?p + nat ?q < nat q + nat p; coprime ?p ?q; 2 < ?p; 2 < ?q;\n   odd ?p; odd ?q\\<rbrakk>\n  \\<Longrightarrow> Jacobi ?p ?q * Jacobi ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  coprime q p\n  2 < q\n  2 < p\n  odd q\n  odd p\n\ngoal (1 subgoal):\n 1. Jacobi q p * Jacobi p q = (- 1) ^ nat ((q - 1) div 2 * ((p - 1) div 2))", "by (simp only: add_ac coprime_commute mult_ac) blast"], ["proof (state)\nthis:\n  Jacobi q p * Jacobi p q = (- 1) ^ nat ((q - 1) div 2 * ((p - 1) div 2))\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>prime p; prime q;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 2. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>prime p; prime q;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 2. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "case (primes p q)"], ["proof (state)\nthis:\n  prime p\n  prime q\n  \\<lbrakk>nat ?p + nat ?q < nat p + nat q; coprime ?p ?q; 2 < ?p; 2 < ?q;\n   odd ?p; odd ?q\\<rbrakk>\n  \\<Longrightarrow> Jacobi ?p ?q * Jacobi ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  coprime p q\n  2 < p\n  2 < q\n  odd p\n  odd q\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>prime p; prime q;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 2. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "from \\<open>prime p\\<close> \\<open>prime q\\<close>"], ["proof (chain)\npicking this:\n  prime p\n  prime q", "have \"prime (nat p)\" \"prime (nat q)\" \"p \\<noteq> q\""], ["proof (prove)\nusing this:\n  prime p\n  prime q\n\ngoal (1 subgoal):\n 1. prime (nat p) &&& prime (nat q) &&& p \\<noteq> q", "using prime_int_nat_transfer primes(4) non_trivial_coprime_neq prime_gt_1_int"], ["proof (prove)\nusing this:\n  prime p\n  prime q\n  prime ?k = (0 \\<le> ?k \\<and> prime (nat ?k))\n  coprime p q\n  \\<lbrakk>1 < ?a; 1 < ?b; coprime ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?a \\<noteq> ?b\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. prime (nat p) &&& prime (nat q) &&& p \\<noteq> q", "by blast+"], ["proof (state)\nthis:\n  prime (nat p)\n  prime (nat q)\n  p \\<noteq> q\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>prime p; prime q;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n 2. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "with Quadratic_Reciprocity_int and prime_p_Jacobi_eq_Legendre"], ["proof (chain)\npicking this:\n  \\<lbrakk>prime (nat ?p); 2 < ?p; prime (nat ?q); 2 < ?q;\n   ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> Legendre ?p ?q * Legendre ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  prime ?p \\<Longrightarrow> Jacobi ?a ?p = Legendre ?a ?p\n  prime (nat p)\n  prime (nat q)\n  p \\<noteq> q", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime (nat ?p); 2 < ?p; prime (nat ?q); 2 < ?q;\n   ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> Legendre ?p ?q * Legendre ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  prime ?p \\<Longrightarrow> Jacobi ?a ?p = Legendre ?a ?p\n  prime (nat p)\n  prime (nat q)\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "using \\<open>prime p\\<close> \\<open>prime q\\<close> primes(5-)"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime (nat ?p); 2 < ?p; prime (nat ?q); 2 < ?q;\n   ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> Legendre ?p ?q * Legendre ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  prime ?p \\<Longrightarrow> Jacobi ?a ?p = Legendre ?a ?p\n  prime (nat p)\n  prime (nat q)\n  p \\<noteq> q\n  prime p\n  prime q\n  2 < p\n  2 < q\n  odd p\n  odd q\n\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "by presburger"], ["proof (state)\nthis:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "case (nonprime p q)"], ["proof (state)\nthis:\n  \\<not> prime p\n  \\<lbrakk>nat ?p + nat ?q < nat p + nat q; coprime ?p ?q; 2 < ?p; 2 < ?q;\n   odd ?p; odd ?q\\<rbrakk>\n  \\<Longrightarrow> Jacobi ?p ?q * Jacobi ?q ?p =\n                    (- 1) ^ nat ((?p - 1) div 2 * ((?q - 1) div 2))\n  coprime p q\n  2 < p\n  2 < q\n  odd p\n  odd q\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "from \\<open>\\<not>prime p\\<close>"], ["proof (chain)\npicking this:\n  \\<not> prime p", "obtain a b where *: \"p = a * b\" \"1 < b\" \"1 < a\""], ["proof (prove)\nusing this:\n  \\<not> prime p\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = a * b; 1 < b; 1 < a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>2 < p\\<close> prime_divisor_exists_strong[of p]"], ["proof (prove)\nusing this:\n  \\<not> prime p\n  2 < p\n  \\<lbrakk>1 < p; \\<not> prime p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n k.\n                       p = n * k \\<and>\n                       1 < n \\<and> n < p \\<and> 1 < k \\<and> k < p\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = a * b; 1 < b; 1 < a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = a * b\n  1 < b\n  1 < a\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "hence odd_ab: \"odd a\" \"odd b\""], ["proof (prove)\nusing this:\n  p = a * b\n  1 < b\n  1 < a\n\ngoal (1 subgoal):\n 1. odd a &&& odd b", "using \\<open>odd p\\<close>"], ["proof (prove)\nusing this:\n  p = a * b\n  1 < b\n  1 < a\n  odd p\n\ngoal (1 subgoal):\n 1. odd a &&& odd b", "by simp_all"], ["proof (state)\nthis:\n  odd a\n  odd b\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "moreover"], ["proof (state)\nthis:\n  odd a\n  odd b\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "have \"2 < b\" and \"2 < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < b &&& 2 < a", "using odd_ab and *"], ["proof (prove)\nusing this:\n  odd a\n  odd b\n  p = a * b\n  1 < b\n  1 < a\n\ngoal (1 subgoal):\n 1. 2 < b &&& 2 < a", "by presburger+"], ["proof (state)\nthis:\n  2 < b\n  2 < a\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "moreover"], ["proof (state)\nthis:\n  2 < b\n  2 < a\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "have \"coprime a q\" and \"coprime b q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime a q &&& coprime b q", "using \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  coprime p q\n\ngoal (1 subgoal):\n 1. coprime a q &&& coprime b q", "unfolding *"], ["proof (prove)\nusing this:\n  coprime (a * b) q\n\ngoal (1 subgoal):\n 1. coprime a q &&& coprime b q", "by simp_all"], ["proof (state)\nthis:\n  coprime a q\n  coprime b q\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "ultimately"], ["proof (chain)\npicking this:\n  odd a\n  odd b\n  2 < b\n  2 < a\n  coprime a q\n  coprime b q", "have IH: \"Jacobi a q * Jacobi q a = (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2))\"\n                        \"Jacobi b q * Jacobi q b = (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))\""], ["proof (prove)\nusing this:\n  odd a\n  odd b\n  2 < b\n  2 < a\n  coprime a q\n  coprime b q\n\ngoal (1 subgoal):\n 1. Jacobi a q * Jacobi q a =\n    (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) &&&\n    Jacobi b q * Jacobi q b = (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))", "by (auto simp: * nonprime)"], ["proof (state)\nthis:\n  Jacobi a q * Jacobi q a = (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2))\n  Jacobi b q * Jacobi q b = (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "have pos: \"0 < q\" \"0 < p\" \"0 < a\" \"0 < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < q &&& 0 < p) &&& 0 < a &&& 0 < b", "using * \\<open>2 < q\\<close>"], ["proof (prove)\nusing this:\n  p = a * b\n  1 < b\n  1 < a\n  2 < q\n\ngoal (1 subgoal):\n 1. (0 < q &&& 0 < p) &&& 0 < a &&& 0 < b", "by simp_all"], ["proof (state)\nthis:\n  0 < q\n  0 < p\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "have \"Jacobi p q * Jacobi q p = (Jacobi a q * Jacobi q a) * (Jacobi b q * Jacobi q b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p =\n    Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b)", "using *"], ["proof (prove)\nusing this:\n  p = a * b\n  1 < b\n  1 < a\n\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p =\n    Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b)", "by simp"], ["proof (state)\nthis:\n  Jacobi p q * Jacobi q p =\n  Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "also"], ["proof (state)\nthis:\n  Jacobi p q * Jacobi q p =\n  Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "have \"... = (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) *\n                     (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b) =\n    (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) *\n    (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))", "using IH"], ["proof (prove)\nusing this:\n  Jacobi a q * Jacobi q a = (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2))\n  Jacobi b q * Jacobi q b = (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b) =\n    (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) *\n    (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))", "by presburger"], ["proof (state)\nthis:\n  Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b) =\n  (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) *\n  (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "also"], ["proof (state)\nthis:\n  Jacobi a q * Jacobi q a * (Jacobi b q * Jacobi q b) =\n  (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) *\n  (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "from odd_odd_even[OF odd_ab]"], ["proof (chain)\npicking this:\n  even ((a * b - 1) div 2) = even ((a - 1) div 2 + (b - 1) div 2)", "have \"... = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\""], ["proof (prove)\nusing this:\n  even ((a * b - 1) div 2) = even ((a - 1) div 2 + (b - 1) div 2)\n\ngoal (1 subgoal):\n 1. (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) *\n    (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2)) =\n    (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "unfolding * minus_one_power_iff"], ["proof (prove)\nusing this:\n  even ((a * b - 1) div 2) = even ((a - 1) div 2 + (b - 1) div 2)\n\ngoal (1 subgoal):\n 1. (if even (nat ((a - 1) div 2 * ((q - 1) div 2))) then 1 else - 1) *\n    (if even (nat ((b - 1) div 2 * ((q - 1) div 2))) then 1 else - 1) =\n    (if even (nat ((a * b - 1) div 2 * ((q - 1) div 2))) then 1 else - 1)", "using \\<open>2 < q\\<close> *"], ["proof (prove)\nusing this:\n  even ((a * b - 1) div 2) = even ((a - 1) div 2 + (b - 1) div 2)\n  2 < q\n  p = a * b\n  1 < b\n  1 < a\n\ngoal (1 subgoal):\n 1. (if even (nat ((a - 1) div 2 * ((q - 1) div 2))) then 1 else - 1) *\n    (if even (nat ((b - 1) div 2 * ((q - 1) div 2))) then 1 else - 1) =\n    (if even (nat ((a * b - 1) div 2 * ((q - 1) div 2))) then 1 else - 1)", "by (auto simp add: even_nat_iff pos_imp_zdiv_nonneg_iff)"], ["proof (state)\nthis:\n  (- 1) ^ nat ((a - 1) div 2 * ((q - 1) div 2)) *\n  (- 1) ^ nat ((b - 1) div 2 * ((q - 1) div 2)) =\n  (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<not> prime p;\n        \\<And>pa qa.\n           \\<lbrakk>nat pa + nat qa < nat p + nat q; coprime pa qa; 2 < pa;\n            2 < qa; odd pa; odd qa\\<rbrakk>\n           \\<Longrightarrow> Jacobi pa qa * Jacobi qa pa =\n                             (- 1) ^\n                             nat ((pa - 1) div 2 * ((qa - 1) div 2));\n        coprime p q; 2 < p; 2 < q; odd p; odd q\\<rbrakk>\n       \\<Longrightarrow> Jacobi p q * Jacobi q p =\n                         (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "finally"], ["proof (chain)\npicking this:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "show ?case"], ["proof (prove)\nusing this:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "."], ["proof (state)\nthis:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Jacobi_values: \"Jacobi p q \\<in> {1, -1, 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi p q \\<in> {1, - 1, 0}", "proof (cases \"q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}\n 2. q \\<noteq> 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}", "case False"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}\n 2. q \\<noteq> 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}", "hence \"\\<bar>Legendre p x\\<bar> = 1\" if \"x \\<in># prime_factorization q\" \"Jacobi p q \\<noteq> 0\" for x"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>Legendre p x\\<bar> = 1", "using that prod_mset_zero_iff Legendre_values[of p x]"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  x \\<in># prime_factorization q\n  Jacobi p q \\<noteq> 0\n  (\\<Prod>\\<^sub># ?A = (0::?'a)) = ((0::?'a) \\<in># ?A)\n  Legendre p x \\<in> {1, - 1, 0}\n\ngoal (1 subgoal):\n 1. \\<bar>Legendre p x\\<bar> = 1", "unfolding Jacobi_def is_unit_prod_mset_iff set_image_mset"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  x \\<in># prime_factorization q\n  (if q = 0 then 0\n   else \\<Prod>\\<^sub>#\n         (image_mset (Legendre p) (prime_factorization q))) \\<noteq>\n  0\n  (\\<Prod>\\<^sub># ?A = (0::?'a)) = ((0::?'a) \\<in># ?A)\n  Legendre p x \\<in> {1, - 1, 0}\n\ngoal (1 subgoal):\n 1. \\<bar>Legendre p x\\<bar> = 1", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in># prime_factorization q; Jacobi p q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<bar>Legendre p ?x\\<bar> = 1\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}\n 2. q \\<noteq> 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in># prime_factorization q; Jacobi p q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<bar>Legendre p ?x\\<bar> = 1", "have \"is_unit (prod_mset (image_mset (Legendre p) (prime_factorization q)))\"\n    if \"Jacobi p q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in># prime_factorization q; Jacobi p q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<bar>Legendre p ?x\\<bar> = 1\n\ngoal (1 subgoal):\n 1. is_unit\n     (\\<Prod>\\<^sub># (image_mset (Legendre p) (prime_factorization q)))", "using that False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in># prime_factorization q; Jacobi p q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<bar>Legendre p ?x\\<bar> = 1\n  Jacobi p q \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit\n     (\\<Prod>\\<^sub># (image_mset (Legendre p) (prime_factorization q)))", "unfolding Jacobi_def is_unit_prod_mset_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in># prime_factorization q;\n   (if q = 0 then 0\n    else \\<Prod>\\<^sub>#\n          (image_mset (Legendre p) (prime_factorization q))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<bar>Legendre p ?x\\<bar> = 1\n  (if q = 0 then 0\n   else \\<Prod>\\<^sub>#\n         (image_mset (Legendre p) (prime_factorization q))) \\<noteq>\n  0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#image_mset (Legendre p) (prime_factorization q).\n       is_unit x", "by auto"], ["proof (state)\nthis:\n  Jacobi p q \\<noteq> 0 \\<Longrightarrow>\n  is_unit\n   (\\<Prod>\\<^sub># (image_mset (Legendre p) (prime_factorization q)))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}\n 2. q \\<noteq> 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  Jacobi p q \\<noteq> 0 \\<Longrightarrow>\n  is_unit\n   (\\<Prod>\\<^sub># (image_mset (Legendre p) (prime_factorization q)))\n\ngoal (1 subgoal):\n 1. Jacobi p q \\<in> {1, - 1, 0}", "by (auto simp: Jacobi_def)"], ["proof (state)\nthis:\n  Jacobi p q \\<in> {1, - 1, 0}\n\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow> Jacobi p q \\<in> {1, - 1, 0}", "qed auto"], ["", "lemma Quadratic_Reciprocity_Jacobi':\n  fixes p q :: int\n  assumes \"coprime p q\"\n      and \"2 < p\" \"2 < q\"\n      and \"odd p\" \"odd q\"\n    shows \"Jacobi q p = (if p mod 4 = 3 \\<and> q mod 4 = 3 then -1 else 1) * Jacobi p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "have aux: \"a \\<in> {1, -1, 0} \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> a*b = c \\<Longrightarrow> b = c * a\" for b c a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> {1, - 1, 0}; c \\<noteq> 0; a * b = c\\<rbrakk>\n    \\<Longrightarrow> b = c * a", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {1, - 1, 0}; ?c \\<noteq> 0; ?a * ?b = ?c\\<rbrakk>\n  \\<Longrightarrow> ?b = ?c * ?a\n\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "from Quadratic_Reciprocity_Jacobi[OF assms]"], ["proof (chain)\npicking this:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))", "have \"Jacobi q p = (-1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) * Jacobi p q\""], ["proof (prove)\nusing this:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n\ngoal (1 subgoal):\n 1. Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) * Jacobi p q", "using Jacobi_values"], ["proof (prove)\nusing this:\n  Jacobi p q * Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2))\n  Jacobi ?p ?q \\<in> {1, - 1, 0}\n\ngoal (1 subgoal):\n 1. Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) * Jacobi p q", "by (fastforce intro!: aux)"], ["proof (state)\nthis:\n  Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) * Jacobi p q\n\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "also"], ["proof (state)\nthis:\n  Jacobi q p = (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) * Jacobi p q\n\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "have \"(-1 :: int) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) = (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) =\n    (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1)", "unfolding minus_one_power_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (nat ((p - 1) div 2 * ((q - 1) div 2))) then 1 else - 1) =\n    (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1)", "using \\<open>2 < p\\<close> \\<open>2 < q\\<close>"], ["proof (prove)\nusing this:\n  2 < p\n  2 < q\n\ngoal (1 subgoal):\n 1. (if even (nat ((p - 1) div 2 * ((q - 1) div 2))) then 1 else - 1) =\n    (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1)", "by (auto simp: even_nat_iff)"], ["proof (state)\nthis:\n  (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) =\n  (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "also"], ["proof (state)\nthis:\n  (- 1) ^ nat ((p - 1) div 2 * ((q - 1) div 2)) =\n  (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "have \"... = (if p mod 4 = 3 \\<and> q mod 4 = 3 then -1 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1) =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1)", "using \\<open>odd p\\<close> \\<open>odd q\\<close>"], ["proof (prove)\nusing this:\n  odd p\n  odd q\n\ngoal (1 subgoal):\n 1. (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1) =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1)", "by presburger"], ["proof (state)\nthis:\n  (if even ((p - 1) div 2) \\<or> even ((q - 1) div 2) then 1 else - 1) =\n  (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1)\n\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "finally"], ["proof (chain)\npicking this:\n  Jacobi q p =\n  (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "show ?thesis"], ["proof (prove)\nusing this:\n  Jacobi q p =\n  (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q\n\ngoal (1 subgoal):\n 1. Jacobi q p =\n    (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q", "."], ["proof (state)\nthis:\n  Jacobi q p =\n  (if p mod 4 = 3 \\<and> q mod 4 = 3 then - 1 else 1) * Jacobi p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_odd_square: \"8 dvd a\\<^sup>2 - 1\" if \"odd a\" for a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 dvd a\\<^sup>2 - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 8 dvd a\\<^sup>2 - 1", "obtain x where \"a = 2*x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. a = 2 * x + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>odd a\\<close>"], ["proof (prove)\nusing this:\n  odd a\n\ngoal (1 subgoal):\n 1. (\\<And>x. a = 2 * x + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: oddE)"], ["proof (state)\nthis:\n  a = 2 * x + 1\n\ngoal (1 subgoal):\n 1. 8 dvd a\\<^sup>2 - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = 2 * x + 1\n\ngoal (1 subgoal):\n 1. 8 dvd a\\<^sup>2 - 1", "by(cases \"odd x\") \n      (auto elim: oddE simp: power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  8 dvd a\\<^sup>2 - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_odd_even': \n  fixes a b :: int \n  assumes \"odd a\" \"odd b\"\n  shows \"even (((a * b)\\<^sup>2 - 1) div 8) \\<longleftrightarrow> even (((a\\<^sup>2 - 1) div 8) + ((b\\<^sup>2 - 1) div 8))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "obtain x where [simp]: \"a = 2*x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. a = 2 * x + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>odd a\\<close>"], ["proof (prove)\nusing this:\n  odd a\n\ngoal (1 subgoal):\n 1. (\\<And>x. a = 2 * x + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: oddE)"], ["proof (state)\nthis:\n  a = 2 * x + 1\n\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "obtain y where [simp]: \"b = 2*y + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. b = 2 * y + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>odd b\\<close>"], ["proof (prove)\nusing this:\n  odd b\n\ngoal (1 subgoal):\n 1. (\\<And>y. b = 2 * y + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: oddE)"], ["proof (state)\nthis:\n  b = 2 * y + 1\n\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "by (cases \"even x\"; cases \"even y\"; elim oddE evenE)\n       (auto simp: power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  even (((a * b)\\<^sup>2 - 1) div 8) =\n  even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_odd_even_nat': \n  fixes a b :: nat \n  assumes \"odd a\" \"odd b\"\n  shows \"even (((a * b)\\<^sup>2 - 1) div 8) \\<longleftrightarrow> even (((a\\<^sup>2 - 1) div 8) + ((b\\<^sup>2 - 1) div 8))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "obtain x where [simp]: \"a = 2*x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. a = 2 * x + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>odd a\\<close>"], ["proof (prove)\nusing this:\n  odd a\n\ngoal (1 subgoal):\n 1. (\\<And>x. a = 2 * x + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: oddE)"], ["proof (state)\nthis:\n  a = 2 * x + 1\n\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "obtain y where [simp]: \"b = 2*y + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. b = 2 * y + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>odd b\\<close>"], ["proof (prove)\nusing this:\n  odd b\n\ngoal (1 subgoal):\n 1. (\\<And>y. b = 2 * y + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: oddE)"], ["proof (state)\nthis:\n  b = 2 * y + 1\n\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (((a * b)\\<^sup>2 - 1) div 8) =\n    even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)", "by (cases \"even x\"; cases \"even y\"; elim oddE evenE)\n       (auto simp: power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  even (((a * b)\\<^sup>2 - 1) div 8) =\n  even ((a\\<^sup>2 - 1) div 8 + (b\\<^sup>2 - 1) div 8)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supplement2_Jacobi: \"odd p \\<Longrightarrow> p > 1 \\<Longrightarrow> Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd p; 1 < p\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "proof (induction p rule: prime_divisors_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi 2 x =\n                          (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 (p * x) =\n                         (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "case (factor p x)"], ["proof (state)\nthis:\n  prime p\n  \\<lbrakk>odd x; 1 < x\\<rbrakk>\n  \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n  odd (p * x)\n  1 < p * x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi 2 x =\n                          (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 (p * x) =\n                         (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "then"], ["proof (chain)\npicking this:\n  prime p\n  \\<lbrakk>odd x; 1 < x\\<rbrakk>\n  \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n  odd (p * x)\n  1 < p * x", "have \"odd x\""], ["proof (prove)\nusing this:\n  prime p\n  \\<lbrakk>odd x; 1 < x\\<rbrakk>\n  \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n  odd (p * x)\n  1 < p * x\n\ngoal (1 subgoal):\n 1. odd x", "by force"], ["proof (state)\nthis:\n  odd x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi 2 x =\n                          (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 (p * x) =\n                         (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "have \"2 < p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < p", "using \\<open>odd (p * x)\\<close> prime_gt_1_int[OF \\<open>prime p\\<close>]"], ["proof (prove)\nusing this:\n  odd (p * x)\n  1 < p\n\ngoal (1 subgoal):\n 1. 2 < p", "by (cases \"p = 2\") auto"], ["proof (state)\nthis:\n  2 < p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi 2 x =\n                          (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 (p * x) =\n                         (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "have \"odd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd p", "using prime_odd_int[OF \\<open>prime p\\<close> \\<open>2 < p\\<close>]"], ["proof (prove)\nusing this:\n  odd p\n\ngoal (1 subgoal):\n 1. odd p", "."], ["proof (state)\nthis:\n  odd p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi 2 x =\n                          (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 (p * x) =\n                         (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "have \"0 < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x", "using \\<open>1 < (p * x)\\<close> prime_gt_0_int[OF \\<open>prime p\\<close>]\n    and less_trans less_numeral_extra(1) zero_less_mult_pos"], ["proof (prove)\nusing this:\n  1 < p * x\n  0 < p\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  (0::?'a) < (1::?'a)\n  \\<lbrakk>(0::?'a) < ?a * ?b; (0::?'a) < ?a\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?b\n\ngoal (1 subgoal):\n 1. 0 < x", "by blast"], ["proof (state)\nthis:\n  0 < x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi 2 x =\n                          (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 (p * x) =\n                         (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "have base_case : \"Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "using \\<open>2 < p\\<close> \\<open>prime p\\<close> supplement2_Legendre and prime_p_Jacobi_eq_Legendre"], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n  \\<lbrakk>2 < ?p; prime ?p\\<rbrakk>\n  \\<Longrightarrow> Legendre 2 ?p = (- 1) ^ (((nat ?p)\\<^sup>2 - 1) div 8)\n  prime ?p \\<Longrightarrow> Jacobi ?a ?p = Legendre ?a ?p\n\ngoal (1 subgoal):\n 1. Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "by presburger"], ["proof (state)\nthis:\n  Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi 2 x =\n                          (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 (p * x) =\n                         (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "proof (cases \"x = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "case True"], ["proof (state)\nthis:\n  x = 1\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 1\n\ngoal (1 subgoal):\n 1. Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "using base_case"], ["proof (prove)\nusing this:\n  x = 1\n  Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "by force"], ["proof (state)\nthis:\n  Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "have \"Jacobi 2 (p * x) = Jacobi 2 p * Jacobi 2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi 2 (p * x) = Jacobi 2 p * Jacobi 2 x", "using \\<open>2 < p\\<close> \\<open>0 < x\\<close>"], ["proof (prove)\nusing this:\n  2 < p\n  0 < x\n\ngoal (1 subgoal):\n 1. Jacobi 2 (p * x) = Jacobi 2 p * Jacobi 2 x", "by simp"], ["proof (state)\nthis:\n  Jacobi 2 (p * x) = Jacobi 2 p * Jacobi 2 x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  Jacobi 2 (p * x) = Jacobi 2 p * Jacobi 2 x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "have \"Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)", "using \\<open>odd x\\<close> \\<open>0 < x\\<close> \\<open>x \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  odd x\n  0 < x\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)", "by (intro factor.IH) auto"], ["proof (state)\nthis:\n  Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "note base_case"], ["proof (state)\nthis:\n  Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  Jacobi 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "have \"(-1) ^ (((nat p)\\<^sup>2 - 1) div 8) * (-1) ^ (((nat x)\\<^sup>2 - 1) div 8)\n             = (-1 :: int) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8) *\n    (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8) =\n    (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "unfolding minus_one_power_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (((nat p)\\<^sup>2 - 1) div 8) then 1 else - 1) *\n    (if even (((nat x)\\<^sup>2 - 1) div 8) then 1 else - 1) =\n    (if even (((nat (p * x))\\<^sup>2 - 1) div 8) then 1 else - 1)", "using \\<open>2 < p\\<close> \\<open>0 < x\\<close> \\<open>odd x\\<close> \\<open>odd p\\<close> and odd_odd_even_nat'"], ["proof (prove)\nusing this:\n  2 < p\n  0 < x\n  odd x\n  odd p\n  \\<lbrakk>odd ?a; odd ?b\\<rbrakk>\n  \\<Longrightarrow> even (((?a * ?b)\\<^sup>2 - 1) div 8) =\n                    even ((?a\\<^sup>2 - 1) div 8 + (?b\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. (if even (((nat p)\\<^sup>2 - 1) div 8) then 1 else - 1) *\n    (if even (((nat x)\\<^sup>2 - 1) div 8) then 1 else - 1) =\n    (if even (((nat (p * x))\\<^sup>2 - 1) div 8) then 1 else - 1)", "using [[linarith_split_limit = 0]]"], ["proof (prove)\nusing this:\n  2 < p\n  0 < x\n  odd x\n  odd p\n  \\<lbrakk>odd ?a; odd ?b\\<rbrakk>\n  \\<Longrightarrow> even (((?a * ?b)\\<^sup>2 - 1) div 8) =\n                    even ((?a\\<^sup>2 - 1) div 8 + (?b\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. (if even (((nat p)\\<^sup>2 - 1) div 8) then 1 else - 1) *\n    (if even (((nat x)\\<^sup>2 - 1) div 8) then 1 else - 1) =\n    (if even (((nat (p * x))\\<^sup>2 - 1) div 8) then 1 else - 1)", "by (force simp add: nat_mult_distrib even_nat_iff)"], ["proof (state)\nthis:\n  (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8) *\n  (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8) =\n  (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "finally"], ["proof (chain)\npicking this:\n  Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "show ?thesis"], ["proof (prove)\nusing this:\n  Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)", "."], ["proof (state)\nthis:\n  Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi 2 (p * x) = (- 1) ^ (((nat (p * x))\\<^sup>2 - 1) div 8)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi 2 0 = (- 1) ^ (((nat 0)\\<^sup>2 - 1) div 8)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi 2 x = (- 1) ^ (((nat x)\\<^sup>2 - 1) div 8)", "qed simp_all"], ["", "lemma mod_nat_wlog [consumes 1, case_names modulo]:\n  fixes P :: \"nat \\<Rightarrow> bool\"\n  assumes \"b > 0\"\n  assumes \"\\<And>k. k \\<in> {0..<b} \\<Longrightarrow> n mod b = k \\<Longrightarrow> P n\"\n  shows   \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "using assms and mod_less_divisor"], ["proof (prove)\nusing this:\n  0 < b\n  \\<lbrakk>?k \\<in> {0..<b}; n mod b = ?k\\<rbrakk> \\<Longrightarrow> P n\n  0 < ?n \\<Longrightarrow> ?m mod ?n < ?n\n\ngoal (1 subgoal):\n 1. P n", "by fastforce"], ["", "lemma mod_int_wlog [consumes 1, case_names modulo]:\n  fixes P :: \"int \\<Rightarrow> bool\"\n  assumes \"b > 0\"\n  assumes \"\\<And>k. 0 \\<le> k \\<Longrightarrow> k < b \\<Longrightarrow> n mod b = k \\<Longrightarrow> P n\"\n  shows   \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "using assms and pos_mod_conj"], ["proof (prove)\nusing this:\n  0 < b\n  \\<lbrakk>0 \\<le> ?k; ?k < b; n mod b = ?k\\<rbrakk> \\<Longrightarrow> P n\n  0 < ?b \\<Longrightarrow> 0 \\<le> ?a mod ?b \\<and> ?a mod ?b < ?b\n\ngoal (1 subgoal):\n 1. P n", "by blast"], ["", "lemma supplement2_Jacobi':\n  assumes \"odd p\" and \"p > 1\"\n  shows \"Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "have \"0 < (4 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 4", "by simp"], ["proof (state)\nthis:\n  0 < 4\n\ngoal (1 subgoal):\n 1. Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "then"], ["proof (chain)\npicking this:\n  0 < 4", "have *: \"even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\" if \"odd p\" for p :: nat"], ["proof (prove)\nusing this:\n  0 < 4\n\ngoal (1 subgoal):\n 1. even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "proof(induction p rule: mod_nat_wlog)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<in> {0..<4}; p mod 4 = k\\<rbrakk>\n       \\<Longrightarrow> even ((p\\<^sup>2 - 1) div 8) =\n                         (p mod 8 = 1 \\<or> p mod 8 = 7)", "case (modulo k)"], ["proof (state)\nthis:\n  k \\<in> {0..<4}\n  p mod 4 = k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<in> {0..<4}; p mod 4 = k\\<rbrakk>\n       \\<Longrightarrow> even ((p\\<^sup>2 - 1) div 8) =\n                         (p mod 8 = 1 \\<or> p mod 8 = 7)", "then"], ["proof (chain)\npicking this:\n  k \\<in> {0..<4}\n  p mod 4 = k", "consider \"p mod 4 = 1\" | \"p mod 4 = 3\""], ["proof (prove)\nusing this:\n  k \\<in> {0..<4}\n  p mod 4 = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p mod 4 = 1 \\<Longrightarrow> thesis;\n     p mod 4 = 3 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>odd p\\<close>"], ["proof (prove)\nusing this:\n  k \\<in> {0..<4}\n  p mod 4 = k\n  odd p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p mod 4 = 1 \\<Longrightarrow> thesis;\n     p mod 4 = 3 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis dvd_0_right even_even_mod_4_iff even_numeral mod_exhaust_less_4)"], ["proof (state)\nthis:\n  \\<lbrakk>p mod 4 = 1 \\<Longrightarrow> ?thesis;\n   p mod 4 = 3 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<in> {0..<4}; p mod 4 = k\\<rbrakk>\n       \\<Longrightarrow> even ((p\\<^sup>2 - 1) div 8) =\n                         (p mod 8 = 1 \\<or> p mod 8 = 7)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p mod 4 = 1 \\<Longrightarrow> ?thesis;\n   p mod 4 = 3 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>p mod 4 = 1 \\<Longrightarrow> ?thesis;\n   p mod 4 = 3 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\n 2. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "case 1"], ["proof (state)\nthis:\n  p mod 4 = 1\n\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\n 2. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "then"], ["proof (chain)\npicking this:\n  p mod 4 = 1", "obtain l where l: \"p = 4 * l + 1\""], ["proof (prove)\nusing this:\n  p mod 4 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>l. p = 4 * l + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mod_natE"], ["proof (prove)\nusing this:\n  p mod 4 = 1\n  ?a mod ?n = ?b \\<Longrightarrow> \\<exists>l. ?a = ?n * l + ?b\n\ngoal (1 subgoal):\n 1. (\\<And>l. p = 4 * l + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = 4 * l + 1\n\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\n 2. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "have \"even l = ((4 * l + 1) mod 8 = 1 \\<or> (4 * l + 1) mod 8 = 7)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even l = ((4 * l + 1) mod 8 = 1 \\<or> (4 * l + 1) mod 8 = 7)", "by presburger"], ["proof (state)\nthis:\n  even l = ((4 * l + 1) mod 8 = 1 \\<or> (4 * l + 1) mod 8 = 7)\n\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\n 2. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "thus ?thesis"], ["proof (prove)\nusing this:\n  even l = ((4 * l + 1) mod 8 = 1 \\<or> (4 * l + 1) mod 8 = 7)\n\ngoal (1 subgoal):\n 1. even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "by (simp add: l power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\n\ngoal (1 subgoal):\n 1. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "case 2"], ["proof (state)\nthis:\n  p mod 4 = 3\n\ngoal (1 subgoal):\n 1. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "then"], ["proof (chain)\npicking this:\n  p mod 4 = 3", "obtain l where l: \"p = 4 * l + 3\""], ["proof (prove)\nusing this:\n  p mod 4 = 3\n\ngoal (1 subgoal):\n 1. (\\<And>l. p = 4 * l + 3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mod_natE"], ["proof (prove)\nusing this:\n  p mod 4 = 3\n  ?a mod ?n = ?b \\<Longrightarrow> \\<exists>l. ?a = ?n * l + ?b\n\ngoal (1 subgoal):\n 1. (\\<And>l. p = 4 * l + 3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = 4 * l + 3\n\ngoal (1 subgoal):\n 1. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "have \"odd l = ((3 + l * 4) mod 8 = Suc 0 \\<or> (3 + l * 4) mod 8 = 7)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd l = ((3 + l * 4) mod 8 = Suc 0 \\<or> (3 + l * 4) mod 8 = 7)", "by presburger"], ["proof (state)\nthis:\n  odd l = ((3 + l * 4) mod 8 = Suc 0 \\<or> (3 + l * 4) mod 8 = 7)\n\ngoal (1 subgoal):\n 1. p mod 4 = 3 \\<Longrightarrow>\n    even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd l = ((3 + l * 4) mod 8 = Suc 0 \\<or> (3 + l * 4) mod 8 = 7)\n\ngoal (1 subgoal):\n 1. even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)", "by (simp add: l power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even ((p\\<^sup>2 - 1) div 8) = (p mod 8 = 1 \\<or> p mod 8 = 7)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd ?p \\<Longrightarrow>\n  even ((?p\\<^sup>2 - 1) div 8) = (?p mod 8 = 1 \\<or> ?p mod 8 = 7)\n\ngoal (1 subgoal):\n 1. Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "have [simp]: \"nat p mod 8 = nat (p mod 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat p mod 8 = nat (p mod 8)", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. nat p mod 8 = nat (p mod 8)", "using nat_mod_distrib[of p 8]"], ["proof (prove)\nusing this:\n  1 < p\n  \\<lbrakk>0 \\<le> p; 0 \\<le> 8\\<rbrakk>\n  \\<Longrightarrow> nat (p mod 8) = nat p mod nat 8\n\ngoal (1 subgoal):\n 1. nat p mod 8 = nat (p mod 8)", "by simp"], ["proof (state)\nthis:\n  nat p mod 8 = nat (p mod 8)\n\ngoal (1 subgoal):\n 1. Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "from assms"], ["proof (chain)\npicking this:\n  odd p\n  1 < p", "have \"odd (nat p)\""], ["proof (prove)\nusing this:\n  odd p\n  1 < p\n\ngoal (1 subgoal):\n 1. odd (nat p)", "by (simp add: even_nat_iff)"], ["proof (state)\nthis:\n  odd (nat p)\n\ngoal (1 subgoal):\n 1. Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "unfolding supplement2_Jacobi[OF assms]\n              minus_one_power_iff *[OF \\<open>odd (nat p)\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if nat p mod 8 = 1 \\<or> nat p mod 8 = 7 then 1 else - 1) =\n    (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "by (simp add: nat_eq_iff)"], ["proof (state)\nthis:\n  Jacobi 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem supplement1_Jacobi:\n  \"odd p \\<Longrightarrow> 1 < p \\<Longrightarrow> Jacobi (-1) p = (-1) ^ (nat ((p - 1) div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd p; 1 < p\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)", "proof (induction p rule: prime_divisors_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "case (factor p x)"], ["proof (state)\nthis:\n  prime p\n  \\<lbrakk>odd x; 1 < x\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n  odd (p * x)\n  1 < p * x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "then"], ["proof (chain)\npicking this:\n  prime p\n  \\<lbrakk>odd x; 1 < x\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n  odd (p * x)\n  1 < p * x", "have \"odd x\""], ["proof (prove)\nusing this:\n  prime p\n  \\<lbrakk>odd x; 1 < x\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n  odd (p * x)\n  1 < p * x\n\ngoal (1 subgoal):\n 1. odd x", "by force"], ["proof (state)\nthis:\n  odd x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "have \"2 < p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < p", "using \\<open>odd (p * x)\\<close> prime_gt_1_int[OF \\<open>prime p\\<close>]"], ["proof (prove)\nusing this:\n  odd (p * x)\n  1 < p\n\ngoal (1 subgoal):\n 1. 2 < p", "by (cases \"p = 2\") auto"], ["proof (state)\nthis:\n  2 < p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "have \"prime (nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (nat p)", "using \\<open>prime p\\<close> prime_int_nat_transfer"], ["proof (prove)\nusing this:\n  prime p\n  prime ?k = (0 \\<le> ?k \\<and> prime (nat ?k))\n\ngoal (1 subgoal):\n 1. prime (nat p)", "by blast"], ["proof (state)\nthis:\n  prime (nat p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "have \"Jacobi (-1) p = Legendre (-1) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (- 1) p = Legendre (- 1) p", "using prime_p_Jacobi_eq_Legendre[OF \\<open>prime p\\<close>]"], ["proof (prove)\nusing this:\n  Jacobi ?a p = Legendre ?a p\n\ngoal (1 subgoal):\n 1. Jacobi (- 1) p = Legendre (- 1) p", "."], ["proof (state)\nthis:\n  Jacobi (- 1) p = Legendre (- 1) p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "also"], ["proof (state)\nthis:\n  Jacobi (- 1) p = Legendre (- 1) p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "have \"... = (-1) ^ ((nat p - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre (- 1) p = (- 1) ^ ((nat p - 1) div 2)", "using \\<open>prime p\\<close> \\<open>2 < p\\<close> and supplement1_Legendre[of \"nat p\"]"], ["proof (prove)\nusing this:\n  prime p\n  2 < p\n  \\<lbrakk>prime (nat p); 2 < nat p\\<rbrakk>\n  \\<Longrightarrow> Legendre (- 1) (int (nat p)) =\n                    (- 1) ^ ((nat p - 1) div 2)\n\ngoal (1 subgoal):\n 1. Legendre (- 1) p = (- 1) ^ ((nat p - 1) div 2)", "by (metis int_nat_eq nat_mono_iff nat_numeral_as_int prime_gt_0_int prime_int_nat_transfer)"], ["proof (state)\nthis:\n  Legendre (- 1) p = (- 1) ^ ((nat p - 1) div 2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "also"], ["proof (state)\nthis:\n  Legendre (- 1) p = (- 1) ^ ((nat p - 1) div 2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "have \"((nat p - 1) div 2) = nat ((p - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat p - 1) div 2 = nat ((p - 1) div 2)", "by force"], ["proof (state)\nthis:\n  (nat p - 1) div 2 = nat ((p - 1) div 2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "finally"], ["proof (chain)\npicking this:\n  Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)", "have base_case: \"Jacobi (-1) p = (-1) ^ nat ((p - 1) div 2)\""], ["proof (prove)\nusing this:\n  Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)\n\ngoal (1 subgoal):\n 1. Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)", "."], ["proof (state)\nthis:\n  Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n 3. \\<And>p x.\n       \\<lbrakk>prime p;\n        \\<lbrakk>odd x; 1 < x\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2);\n        odd (p * x); 1 < p * x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) (p * x) =\n                         (- 1) ^ nat ((p * x - 1) div 2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "proof (cases \"x = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "case True"], ["proof (state)\nthis:\n  x = 1\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "then"], ["proof (chain)\npicking this:\n  x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 1\n\ngoal (1 subgoal):\n 1. Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "using base_case"], ["proof (prove)\nusing this:\n  x = 1\n  Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)\n\ngoal (1 subgoal):\n 1. Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "by simp"], ["proof (state)\nthis:\n  Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "have \"0 < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x", "using \\<open>1 < (p * x)\\<close> prime_gt_0_int[OF \\<open>prime p\\<close>]"], ["proof (prove)\nusing this:\n  1 < p * x\n  0 < p\n\ngoal (1 subgoal):\n 1. 0 < x", "by (meson int_one_le_iff_zero_less not_less not_less_iff_gr_or_eq zero_less_mult_iff)"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "have \"odd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd p", "using \\<open>prime p\\<close> \\<open>2 < p\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  2 < p\n\ngoal (1 subgoal):\n 1. odd p", "by (simp add: prime_odd_int)"], ["proof (state)\nthis:\n  odd p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "have \"Jacobi (-1) (p * x) = Jacobi (-1) p * Jacobi (-1) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (- 1) (p * x) = Jacobi (- 1) p * Jacobi (- 1) x", "using \\<open>2 < p\\<close> \\<open>0 < x\\<close>"], ["proof (prove)\nusing this:\n  2 < p\n  0 < x\n\ngoal (1 subgoal):\n 1. Jacobi (- 1) (p * x) = Jacobi (- 1) p * Jacobi (- 1) x", "by simp"], ["proof (state)\nthis:\n  Jacobi (- 1) (p * x) = Jacobi (- 1) p * Jacobi (- 1) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "also"], ["proof (state)\nthis:\n  Jacobi (- 1) (p * x) = Jacobi (- 1) p * Jacobi (- 1) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "note base_case"], ["proof (state)\nthis:\n  Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "also"], ["proof (state)\nthis:\n  Jacobi (- 1) p = (- 1) ^ nat ((p - 1) div 2)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "have \"Jacobi (-1) x = (-1) ^ nat ((x - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)", "using \\<open>0 < x\\<close> False \\<open>odd x\\<close> factor.IH"], ["proof (prove)\nusing this:\n  0 < x\n  x \\<noteq> 1\n  odd x\n  \\<lbrakk>odd x; 1 < x\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n\ngoal (1 subgoal):\n 1. Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)", "by fastforce"], ["proof (state)\nthis:\n  Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "also"], ["proof (state)\nthis:\n  Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "have \"(- 1) ^ nat ((p - 1) div 2) * (- 1) ^ nat ((x - 1) div 2) =\n               (- 1 :: int) ^ nat ((p*x - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ nat ((p - 1) div 2) * (- 1) ^ nat ((x - 1) div 2) =\n    (- 1) ^ nat ((p * x - 1) div 2)", "unfolding minus_one_power_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (nat ((p - 1) div 2)) then 1 else - 1) *\n    (if even (nat ((x - 1) div 2)) then 1 else - 1) =\n    (if even (nat ((p * x - 1) div 2)) then 1 else - 1)", "using \\<open>2 < p\\<close> \\<open>0 < x\\<close> and \\<open>odd x\\<close> \\<open>odd p\\<close>"], ["proof (prove)\nusing this:\n  2 < p\n  0 < x\n  odd x\n  odd p\n\ngoal (1 subgoal):\n 1. (if even (nat ((p - 1) div 2)) then 1 else - 1) *\n    (if even (nat ((x - 1) div 2)) then 1 else - 1) =\n    (if even (nat ((p * x - 1) div 2)) then 1 else - 1)", "by (fastforce elim!: oddE simp: even_nat_iff algebra_simps)"], ["proof (state)\nthis:\n  (- 1) ^ nat ((p - 1) div 2) * (- 1) ^ nat ((x - 1) div 2) =\n  (- 1) ^ nat ((p * x - 1) div 2)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "finally"], ["proof (chain)\npicking this:\n  Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)\n\ngoal (1 subgoal):\n 1. Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)", "."], ["proof (state)\nthis:\n  Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi (- 1) (p * x) = (- 1) ^ nat ((p * x - 1) div 2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>odd 0; 1 < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) 0 = (- 1) ^ nat ((0 - 1) div 2)\n 2. \\<And>x.\n       \\<lbrakk>is_unit x; odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> Jacobi (- 1) x = (- 1) ^ nat ((x - 1) div 2)", "qed simp_all"], ["", "theorem supplement1_Jacobi':\n  \"odd n \\<Longrightarrow> 1 < n \\<Longrightarrow> Jacobi (-1) n = (if n mod 4 = 1 then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> Jacobi (- 1) n = (if n mod 4 = 1 then 1 else - 1)", "by (simp add: even_nat_iff minus_one_power_iff supplement1_Jacobi)\n     presburger?"], ["", "lemma Jacobi_0_eq_0: \"\\<not>is_unit n \\<Longrightarrow> Jacobi 0 n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit n \\<Longrightarrow> Jacobi 0 n = 0", "by (cases \"prime_factorization n = {#}\")\n     (auto simp: Jacobi_def prime_factorization_empty_iff image_iff intro: Nat.gr0I)"], ["", "lemma is_unit_Jacobi_aux: \"is_unit x \\<Longrightarrow> Jacobi a x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit x \\<Longrightarrow> Jacobi a x = 1", "unfolding Jacobi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit x \\<Longrightarrow>\n    (if x = 0 then 0\n     else \\<Prod>\\<^sub>#\n           (image_mset (Legendre a) (prime_factorization x))) =\n    1", "using prime_factorization_empty_iff[of x]"], ["proof (prove)\nusing this:\n  (prime_factorization x = {#}) = (x = 0 \\<or> is_unit x)\n\ngoal (1 subgoal):\n 1. is_unit x \\<Longrightarrow>\n    (if x = 0 then 0\n     else \\<Prod>\\<^sub>#\n           (image_mset (Legendre a) (prime_factorization x))) =\n    1", "by auto"], ["", "lemma is_unit_Jacobi[simp]: \"Jacobi a 1 = 1\" \"Jacobi a (-1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a 1 = 1 &&& Jacobi a (- 1) = 1", "using is_unit_Jacobi_aux"], ["proof (prove)\nusing this:\n  is_unit ?x \\<Longrightarrow> Jacobi ?a ?x = 1\n\ngoal (1 subgoal):\n 1. Jacobi a 1 = 1 &&& Jacobi a (- 1) = 1", "by simp_all"], ["", "lemma Jacobi_neg_right [simp]:\n  \"Jacobi a (-n) = Jacobi a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a (- n) = Jacobi a n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Jacobi a (- n) = Jacobi a n", "have * : \"-n = (-1) * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - n = - 1 * n", "by simp"], ["proof (state)\nthis:\n  - n = - 1 * n\n\ngoal (1 subgoal):\n 1. Jacobi a (- n) = Jacobi a n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a (- n) = Jacobi a n", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a (- 1 * n) = Jacobi a n", "by (subst Jacobi_mult_right) auto"], ["proof (state)\nthis:\n  Jacobi a (- n) = Jacobi a n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Jacobi_neg_left:\n  assumes \"odd n\" \"1 < n\" \n  shows   \"Jacobi (-a) n = (if n mod 4 = 1 then 1 else -1) * Jacobi a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (- a) n = (if n mod 4 = 1 then 1 else - 1) * Jacobi a n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Jacobi (- a) n = (if n mod 4 = 1 then 1 else - 1) * Jacobi a n", "have * : \"-a = (-1) * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a = - 1 * a", "by simp"], ["proof (state)\nthis:\n  - a = - 1 * a\n\ngoal (1 subgoal):\n 1. Jacobi (- a) n = (if n mod 4 = 1 then 1 else - 1) * Jacobi a n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (- a) n = (if n mod 4 = 1 then 1 else - 1) * Jacobi a n", "unfolding * Jacobi_mult_left supplement1_Jacobi'[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n mod 4 = 1 then 1 else - 1) * Jacobi a n =\n    (if n mod 4 = 1 then 1 else - 1) * Jacobi a n", ".."], ["proof (state)\nthis:\n  Jacobi (- a) n = (if n mod 4 = 1 then 1 else - 1) * Jacobi a n\n\ngoal:\nNo subgoals!", "qed"], ["", "function jacobi_code :: \"int \\<Rightarrow> int \\<Rightarrow> int\" where\n\"jacobi_code a n = ( \n        if n = 0 then 0\n   else if n = 1 then 1\n   else if a = 1 then 1\n   else if n < 0 then jacobi_code a (-n)\n   else if even n then if even a then 0 else jacobi_code a (n div 2)\n   else if a < 0 then (if n mod 4 = 1 then 1 else -1) * jacobi_code (-a) n\n   else if a = 0 then 0\n   else if a \\<ge> n then jacobi_code (a mod n) n\n   else if even a      then (if n mod 8 \\<in> {1, 7} then 1 else -1) * jacobi_code (a div 2) n\n   else if coprime a n then (if n mod 4 = 3 \\<and> a mod 4 = 3 then -1 else 1) * jacobi_code n a\n   else 0)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>a n. x = (a, n) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>a n aa na.\n       (a, n) = (aa, na) \\<Longrightarrow>\n       (if n = 0 then 0\n        else if n = 1 then 1\n             else if a = 1 then 1\n                  else if n < 0 then jacobi_code_sumC (a, - n)\n                       else if even n\n                            then if even a then 0\n                                 else jacobi_code_sumC (a, n div 2)\n                            else if a < 0\n                                 then (if n mod 4 = 1 then 1 else - 1) *\njacobi_code_sumC (- a, n)\n                                 else if a = 0 then 0\nelse if n \\<le> a then jacobi_code_sumC (a mod n, n)\n     else if even a\n          then (if n mod 8 \\<in> {1, 7} then 1 else - 1) *\n               jacobi_code_sumC (a div 2, n)\n          else if coprime a n\n               then (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) *\n                    jacobi_code_sumC (n, a)\n               else 0) =\n       (if na = 0 then 0\n        else if na = 1 then 1\n             else if aa = 1 then 1\n                  else if na < 0 then jacobi_code_sumC (aa, - na)\n                       else if even na\n                            then if even aa then 0\n                                 else jacobi_code_sumC (aa, na div 2)\n                            else if aa < 0\n                                 then (if na mod 4 = 1 then 1 else - 1) *\njacobi_code_sumC (- aa, na)\n                                 else if aa = 0 then 0\nelse if na \\<le> aa then jacobi_code_sumC (aa mod na, na)\n     else if even aa\n          then (if na mod 8 \\<in> {1, 7} then 1 else - 1) *\n               jacobi_code_sumC (aa div 2, na)\n          else if coprime aa na\n               then (if na mod 4 = 3 \\<and> aa mod 4 = 3 then - 1 else 1) *\n                    jacobi_code_sumC (na, aa)\n               else 0)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All jacobi_code_dom", "proof (relation \"measure (\\<lambda>(a, n). nat(abs(a) + abs(n)*2) + \n                   (if n < 0 then 1 else 0) + (if a < 0 then 1 else 0))\", goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. wf (measure\n         (\\<lambda>(a, n).\n             nat (\\<bar>a\\<bar> + \\<bar>n\\<bar> * 2) +\n             (if n < 0 then 1 else 0) +\n             (if a < 0 then 1 else 0)))\n 2. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n       \\<Longrightarrow> ((a, - n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 3. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        even n; odd a\\<rbrakk>\n       \\<Longrightarrow> ((a, n div 2), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 4. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; a < 0\\<rbrakk>\n       \\<Longrightarrow> ((- a, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 5. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n       \\<Longrightarrow> ((a mod n, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 6. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n       \\<Longrightarrow> ((a div 2, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 7. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n        coprime a n\\<rbrakk>\n       \\<Longrightarrow> ((n, a), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))", "case (5 a n)"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  n \\<le> a\n\ngoal (7 subgoals):\n 1. wf (measure\n         (\\<lambda>(a, n).\n             nat (\\<bar>a\\<bar> + \\<bar>n\\<bar> * 2) +\n             (if n < 0 then 1 else 0) +\n             (if a < 0 then 1 else 0)))\n 2. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n       \\<Longrightarrow> ((a, - n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 3. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        even n; odd a\\<rbrakk>\n       \\<Longrightarrow> ((a, n div 2), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 4. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; a < 0\\<rbrakk>\n       \\<Longrightarrow> ((- a, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 5. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n       \\<Longrightarrow> ((a mod n, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 6. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n       \\<Longrightarrow> ((a div 2, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 7. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n        coprime a n\\<rbrakk>\n       \\<Longrightarrow> ((n, a), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))", "thus ?case"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  n \\<le> a\n\ngoal (1 subgoal):\n 1. ((a mod n, n), a, n)\n    \\<in> measure\n           (\\<lambda>(a, n).\n               nat (\\<bar>a\\<bar> + \\<bar>n\\<bar> * 2) +\n               (if n < 0 then 1 else 0) +\n               (if a < 0 then 1 else 0))", "by (fastforce intro!: less_le_trans[OF pos_mod_bound])"], ["proof (state)\nthis:\n  ((a mod n, n), a, n)\n  \\<in> measure\n         (\\<lambda>(a, n).\n             nat (\\<bar>a\\<bar> + \\<bar>n\\<bar> * 2) +\n             (if n < 0 then 1 else 0) +\n             (if a < 0 then 1 else 0))\n\ngoal (6 subgoals):\n 1. wf (measure\n         (\\<lambda>(a, n).\n             nat (\\<bar>a\\<bar> + \\<bar>n\\<bar> * 2) +\n             (if n < 0 then 1 else 0) +\n             (if a < 0 then 1 else 0)))\n 2. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n       \\<Longrightarrow> ((a, - n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 3. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        even n; odd a\\<rbrakk>\n       \\<Longrightarrow> ((a, n div 2), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 4. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; a < 0\\<rbrakk>\n       \\<Longrightarrow> ((- a, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 5. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n       \\<Longrightarrow> ((a div 2, n), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))\n 6. \\<And>a n.\n       \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n        odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n        coprime a n\\<rbrakk>\n       \\<Longrightarrow> ((n, a), a, n)\n                         \\<in> measure\n                                (\\<lambda>(a, n).\n                                    nat (\\<bar>a\\<bar> +\n   \\<bar>n\\<bar> * 2) +\n                                    (if n < 0 then 1 else 0) +\n                                    (if a < 0 then 1 else 0))", "qed auto"], ["", "lemmas [simp del] = jacobi_code.simps"], ["", "lemma Jacobi_code [code]: \"Jacobi a n = jacobi_code a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (induction a n rule: jacobi_code.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n                 n < 0\\<rbrakk>\n                \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         even n; odd a\\<rbrakk>\n        \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; a < 0\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n        \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a;\n         even a\\<rbrakk>\n        \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n         coprime a n\\<rbrakk>\n        \\<Longrightarrow> Jacobi n a = jacobi_code n a\\<rbrakk>\n       \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case (1 a n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; even n;\n   odd a\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   a < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a; coprime a n\\<rbrakk>\n  \\<Longrightarrow> Jacobi n a = jacobi_code n a\n\ngoal (1 subgoal):\n 1. \\<And>a n.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n                 n < 0\\<rbrakk>\n                \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         even n; odd a\\<rbrakk>\n        \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; a < 0\\<rbrakk>\n        \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n        \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a;\n         even a\\<rbrakk>\n        \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n        \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n         odd n; \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n         coprime a n\\<rbrakk>\n        \\<Longrightarrow> Jacobi n a = jacobi_code n a\\<rbrakk>\n       \\<Longrightarrow> Jacobi a n = jacobi_code a n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. n \\<noteq> 0 \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 2: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. n \\<noteq> 0 \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0; n = 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 3: False"], ["proof (state)\nthis:\n  n \\<noteq> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0; n = 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"a = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 1; a = 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>n \\<noteq> 1; a \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 4: False"], ["proof (state)\nthis:\n  a \\<noteq> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 1; a = 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>n \\<noteq> 1; a \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"n < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 1; n < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>a \\<noteq> 1; \\<not> n < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case True"], ["proof (state)\nthis:\n  n < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 1; n < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>a \\<noteq> 1; \\<not> n < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  n < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n < 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "using 2 3 4 1(1)"], ["proof (prove)\nusing this:\n  n < 0\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n)\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "by (subst jacobi_code.simps) simp"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 1; \\<not> n < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 1; \\<not> n < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 5: False"], ["proof (state)\nthis:\n  \\<not> n < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 1; \\<not> n < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  \\<not> n < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n < 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"even n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < 0; even n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n < 0; odd n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case True"], ["proof (state)\nthis:\n  even n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < 0; even n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n < 0; odd n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  even n", "show ?thesis"], ["proof (prove)\nusing this:\n  even n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "using 2 3 4 5 1(2)"], ["proof (prove)\nusing this:\n  even n\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; even n;\n   odd a\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2)\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "by (elim evenE, subst jacobi_code.simps) (auto simp: prime_p_Jacobi_eq_Legendre)"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 0; odd n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 0; odd n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 6: False"], ["proof (state)\nthis:\n  odd n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 0; odd n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  odd n", "show ?thesis"], ["proof (prove)\nusing this:\n  odd n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"a < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>odd n; a < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>odd n; \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case True"], ["proof (state)\nthis:\n  a < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>odd n; a < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>odd n; \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  a < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "using 2 3 4 5 6"], ["proof (prove)\nusing this:\n  a < 0\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "by(subst jacobi_code.simps, subst 1(3)[symmetric]) (simp_all add: Jacobi_neg_left)"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd n; \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd n; \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 7: False"], ["proof (state)\nthis:\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd n; \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  \\<not> a < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> a < 0; a = 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> a < 0; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> a < 0; a = 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> a < 0; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have *: \"\\<not> is_unit n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit n", "using 3 5"], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n  \\<not> n < 0\n\ngoal (1 subgoal):\n 1. \\<not> is_unit n", "by simp"], ["proof (state)\nthis:\n  \\<not> is_unit n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> a < 0; a = 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> a < 0; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  \\<not> is_unit n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_unit n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "using Jacobi_0_eq_0[OF *] 2 3 4 5 7 True"], ["proof (prove)\nusing this:\n  \\<not> is_unit n\n  Jacobi 0 n = 0\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  \\<not> a < 0\n  a = 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "by (subst jacobi_code.simps) simp"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> a < 0; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> a < 0; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 8: False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> a < 0; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"a \\<ge> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>a \\<noteq> 0; \\<not> n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case True"], ["proof (state)\nthis:\n  n \\<le> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>a \\<noteq> 0; \\<not> n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  n \\<le> a", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> a\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "using 2 3 4 5 6 7 8 1(4)"], ["proof (prove)\nusing this:\n  n \\<le> a\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "by (subst jacobi_code.simps) simp"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; \\<not> n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; \\<not> n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 9: False"], ["proof (state)\nthis:\n  \\<not> n \\<le> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; \\<not> n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> a\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"even a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case True"], ["proof (state)\nthis:\n  even a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "hence \"a = 2 * (a div 2)\""], ["proof (prove)\nusing this:\n  even a\n\ngoal (1 subgoal):\n 1. a = 2 * (a div 2)", "by simp"], ["proof (state)\nthis:\n  a = 2 * (a div 2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "also"], ["proof (state)\nthis:\n  a = 2 * (a div 2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"Jacobi \\<dots> n = Jacobi 2 n * Jacobi (a div 2) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (2 * (a div 2)) n = Jacobi 2 n * Jacobi (a div 2) n", "by simp"], ["proof (state)\nthis:\n  Jacobi (2 * (a div 2)) n = Jacobi 2 n * Jacobi (a div 2) n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "also"], ["proof (state)\nthis:\n  Jacobi (2 * (a div 2)) n = Jacobi 2 n * Jacobi (a div 2) n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"Jacobi (a div 2) n = jacobi_code (a div 2) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi (a div 2) n = jacobi_code (a div 2) n", "using 2 3 4 5 6 7 8 9 True"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n  even a\n\ngoal (1 subgoal):\n 1. Jacobi (a div 2) n = jacobi_code (a div 2) n", "by (intro 1(5))"], ["proof (state)\nthis:\n  Jacobi (a div 2) n = jacobi_code (a div 2) n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "also"], ["proof (state)\nthis:\n  Jacobi (a div 2) n = jacobi_code (a div 2) n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"Jacobi 2 n = (if n mod 8 \\<in> {1, 7} then 1 else - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi 2 n = (if n mod 8 \\<in> {1, 7} then 1 else - 1)", "using 2 3 5 supplement2_Jacobi'[OF 6]"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  \\<not> n < 0\n  1 < n \\<Longrightarrow>\n  Jacobi 2 n = (if n mod 8 = 1 \\<or> n mod 8 = 7 then 1 else - 1)\n\ngoal (1 subgoal):\n 1. Jacobi 2 n = (if n mod 8 \\<in> {1, 7} then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  Jacobi 2 n = (if n mod 8 \\<in> {1, 7} then 1 else - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "also"], ["proof (state)\nthis:\n  Jacobi 2 n = (if n mod 8 \\<in> {1, 7} then 1 else - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"\\<dots> * jacobi_code (a div 2) n = jacobi_code a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n mod 8 \\<in> {1, 7} then 1 else - 1) * jacobi_code (a div 2) n =\n    jacobi_code a n", "using 2 3 4 5 6 7 8 9 True"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n  even a\n\ngoal (1 subgoal):\n 1. (if n mod 8 \\<in> {1, 7} then 1 else - 1) * jacobi_code (a div 2) n =\n    jacobi_code a n", "by (subst (2) jacobi_code.simps) (simp only: if_False if_True HOL.simp_thms)"], ["proof (state)\nthis:\n  (if n mod 8 \\<in> {1, 7} then 1 else - 1) * jacobi_code (a div 2) n =\n  jacobi_code a n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n \\<le> a; even a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "finally"], ["proof (chain)\npicking this:\n  Jacobi a n = jacobi_code a n", "show ?thesis"], ["proof (prove)\nusing this:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "."], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case 10: False"], ["proof (state)\nthis:\n  odd a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "note foo = 1 2 3"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; even n;\n   odd a\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   a < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a; coprime a n\\<rbrakk>\n  \\<Longrightarrow> Jacobi n a = jacobi_code n a\n  n \\<noteq> 0\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n \\<le> a; odd a\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; even n;\n   odd a\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   a < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a; coprime a n\\<rbrakk>\n  \\<Longrightarrow> Jacobi n a = jacobi_code n a\n  n \\<noteq> 0\n  n \\<noteq> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; even n;\n   odd a\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   a < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a; coprime a n\\<rbrakk>\n  \\<Longrightarrow> Jacobi n a = jacobi_code n a\n  n \\<noteq> 0\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "proof (cases \"coprime a n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case True"], ["proof (state)\nthis:\n  coprime a n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "note this_case = 2 3 4 5 6 7 8 9 10 True"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n  odd a\n  coprime a n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"2 < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < a", "using 10 4 7"], ["proof (prove)\nusing this:\n  odd a\n  a \\<noteq> 1\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. 2 < a", "by presburger"], ["proof (state)\nthis:\n  2 < a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "moreover"], ["proof (state)\nthis:\n  2 < a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"2 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < n", "using 3 5 6"], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n  \\<not> n < 0\n  odd n\n\ngoal (1 subgoal):\n 1. 2 < n", "by presburger"], ["proof (state)\nthis:\n  2 < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "ultimately"], ["proof (chain)\npicking this:\n  2 < a\n  2 < n", "have \"jacobi_code a n = (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1)\n                                                        * jacobi_code n a\""], ["proof (prove)\nusing this:\n  2 < a\n  2 < n\n\ngoal (1 subgoal):\n 1. jacobi_code a n =\n    (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) * jacobi_code n a", "using this_case"], ["proof (prove)\nusing this:\n  2 < a\n  2 < n\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n  odd a\n  coprime a n\n\ngoal (1 subgoal):\n 1. jacobi_code a n =\n    (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) * jacobi_code n a", "by (subst jacobi_code.simps) simp"], ["proof (state)\nthis:\n  jacobi_code a n =\n  (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) * jacobi_code n a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "also"], ["proof (state)\nthis:\n  jacobi_code a n =\n  (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) * jacobi_code n a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"jacobi_code n a = Jacobi n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jacobi_code n a = Jacobi n a", "using this_case"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n  odd a\n  coprime a n\n\ngoal (1 subgoal):\n 1. jacobi_code n a = Jacobi n a", "by (intro 1(6) [symmetric]) auto"], ["proof (state)\nthis:\n  jacobi_code n a = Jacobi n a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "also"], ["proof (state)\nthis:\n  jacobi_code n a = Jacobi n a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have \"(if n mod 4 = 3 \\<and> a mod 4 = 3 then -1 else 1) * \\<dots> = Jacobi a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) * Jacobi n a =\n    Jacobi a n", "using this_case and \\<open>2 < a\\<close>"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n  odd a\n  coprime a n\n  2 < a\n\ngoal (1 subgoal):\n 1. (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) * Jacobi n a =\n    Jacobi a n", "by (intro Quadratic_Reciprocity_Jacobi' [symmetric])\n                             (auto simp: coprime_commute)"], ["proof (state)\nthis:\n  (if n mod 4 = 3 \\<and> a mod 4 = 3 then - 1 else 1) * Jacobi n a =\n  Jacobi a n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n\n 2. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "finally"], ["proof (chain)\npicking this:\n  jacobi_code a n = Jacobi a n", "show ?thesis"], ["proof (prove)\nusing this:\n  jacobi_code a n = Jacobi a n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", ".."], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "case False"], ["proof (state)\nthis:\n  \\<not> coprime a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "have *: \"0 < a\" \"0 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a &&& 0 < n", "using 5 7 8 9"], ["proof (prove)\nusing this:\n  \\<not> n < 0\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n\ngoal (1 subgoal):\n 1. 0 < a &&& 0 < n", "by linarith+"], ["proof (state)\nthis:\n  0 < a\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1;\n              n < 0\\<rbrakk>\n             \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0;\n      even n; odd a\\<rbrakk>\n     \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2);\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      a < 0\\<rbrakk>\n     \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n     \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n;\n     \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n      \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a;\n      coprime a n\\<rbrakk>\n     \\<Longrightarrow> Jacobi n a = jacobi_code n a;\n     n \\<noteq> 0; n \\<noteq> 1; \\<not> coprime a n\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "using 1 2 3 4 5 6 7 8 9 10 False *"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; n < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (- n) = jacobi_code a (- n)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; even n;\n   odd a\\<rbrakk>\n  \\<Longrightarrow> Jacobi a (n div 2) = jacobi_code a (n div 2)\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   a < 0\\<rbrakk>\n  \\<Longrightarrow> Jacobi (- a) n = jacobi_code (- a) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; n \\<le> a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a mod n) n = jacobi_code (a mod n) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; even a\\<rbrakk>\n  \\<Longrightarrow> Jacobi (a div 2) n = jacobi_code (a div 2) n\n  \\<lbrakk>n \\<noteq> 0; n \\<noteq> 1; a \\<noteq> 1; \\<not> n < 0; odd n;\n   \\<not> a < 0; a \\<noteq> 0; \\<not> n \\<le> a; odd a; coprime a n\\<rbrakk>\n  \\<Longrightarrow> Jacobi n a = jacobi_code n a\n  n \\<noteq> 0\n  n \\<noteq> 1\n  a \\<noteq> 1\n  \\<not> n < 0\n  odd n\n  \\<not> a < 0\n  a \\<noteq> 0\n  \\<not> n \\<le> a\n  odd a\n  \\<not> coprime a n\n  0 < a\n  0 < n\n\ngoal (1 subgoal):\n 1. Jacobi a n = jacobi_code a n", "by (subst jacobi_code.simps) (auto simp: Jacobi_eq_0_not_coprime)"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 1; a = 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "qed (subst jacobi_code.simps, simp)"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; n = 1\\<rbrakk>\n    \\<Longrightarrow> Jacobi a n = jacobi_code a n", "qed (subst jacobi_code.simps, simp)"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> Jacobi a n = jacobi_code a n", "qed (subst jacobi_code.simps, simp)"], ["proof (state)\nthis:\n  Jacobi a n = jacobi_code a n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Jacobi_eq_0_imp_not_coprime:\n  assumes \"p \\<noteq> 0\" \"p \\<noteq> 1\"\n  shows   \"Jacobi n p = 0 \\<Longrightarrow> \\<not>coprime n p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Jacobi n p = 0 \\<Longrightarrow> \\<not> coprime n p", "using assms Jacobi_mod_cong coprime_iff_invertible_int"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p \\<noteq> 1\n  [?a = ?b] (mod ?n) \\<Longrightarrow> Jacobi ?a ?n = Jacobi ?b ?n\n  coprime ?a ?m = (\\<exists>x. [?a * x = 1] (mod ?m))\n\ngoal (1 subgoal):\n 1. Jacobi n p = 0 \\<Longrightarrow> \\<not> coprime n p", "by force"], ["", "lemma Jacobi_eq_0_iff_not_coprime:\n  assumes \"p \\<noteq> 0\" \"p \\<noteq> 1\"\n  shows \"Jacobi n p = 0 \\<longleftrightarrow> \\<not>coprime n p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Jacobi n p = 0) = (\\<not> coprime n p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Jacobi n p = 0) = (\\<not> coprime n p)", "from assms and Jacobi_eq_0_imp_not_coprime"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p \\<noteq> 1\n  \\<lbrakk>?p \\<noteq> 0; ?p \\<noteq> 1; Jacobi ?n ?p = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> coprime ?n ?p", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p \\<noteq> 1\n  \\<lbrakk>?p \\<noteq> 0; ?p \\<noteq> 1; Jacobi ?n ?p = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> coprime ?n ?p\n\ngoal (1 subgoal):\n 1. (Jacobi n p = 0) = (\\<not> coprime n p)", "using Jacobi_eq_0_not_coprime"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p \\<noteq> 1\n  \\<lbrakk>?p \\<noteq> 0; ?p \\<noteq> 1; Jacobi ?n ?p = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> coprime ?n ?p\n  \\<lbrakk>?n \\<noteq> 0; \\<not> coprime ?a ?n\\<rbrakk>\n  \\<Longrightarrow> Jacobi ?a ?n = 0\n\ngoal (1 subgoal):\n 1. (Jacobi n p = 0) = (\\<not> coprime n p)", "by auto"], ["proof (state)\nthis:\n  (Jacobi n p = 0) = (\\<not> coprime n p)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}