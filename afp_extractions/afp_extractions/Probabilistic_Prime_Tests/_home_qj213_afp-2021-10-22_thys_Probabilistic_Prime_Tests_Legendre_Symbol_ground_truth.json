{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests/Legendre_Symbol.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests", "problem_names": ["lemma basic_cong[simp]: \n  fixes p :: int\n  assumes \"2 < p\"\n  shows   \"[-1 \\<noteq>  1] (mod p)\"\n          \"[ 1 \\<noteq> -1] (mod p)\"\n          \"[ 0 \\<noteq>  1] (mod p)\"\n          \"[ 1 \\<noteq>  0] (mod p)\"\n          \"[ 0 \\<noteq> -1] (mod p)\"\n          \"[-1 \\<noteq>  0] (mod p)\"", "lemma [simp]: \"0 < n \\<Longrightarrow> (a mod 2) ^ n = a mod 2\" for n :: nat and a :: int", "lemma Legendre_in_cong_eq: \n  fixes p :: int\n  assumes \"p > 2\" and \"b \\<in> {-1,0,1}\"\n  shows   \"[Legendre a m = b] (mod p) \\<longleftrightarrow> Legendre a m = b\"", "lemma Legendre_p_eq_2[simp]: \"Legendre a 2 = a mod 2\"", "lemma Legendre_p_eq_1[simp]: \"Legendre a 1 = 0\"", "lemma euler_criterion_int:\n  assumes \"prime p\" and \"2 < p\" \n  shows \"[Legendre a p = a^((nat p-1) div 2)] (mod p)\"", "lemma QuadRes_neg[simp]: \"QuadRes (-p) a = QuadRes p a\"", "lemma Legendre_neg[simp]: \"Legendre a (-p) = Legendre a p\"", "lemma Legendre_mult[simp]:\n  assumes \"prime p\"\n  shows \"Legendre (a*b) p = Legendre a p * Legendre b p\"", "lemma QuadRes_mod[simp]: \"p dvd n \\<Longrightarrow> QuadRes p (a mod n) = QuadRes p a\"", "lemma Legendre_mod[simp]: \"p dvd n \\<Longrightarrow> Legendre (a mod n) p = Legendre a p\"", "lemma two_cong_0_iff: \"[2 = 0] (mod p) \\<longleftrightarrow> p = 1 \\<or> p = 2\" for p :: nat", "lemma two_cong_0_iff_nat: \"[2 = 0] (mod int p) \\<longleftrightarrow> p = 1 \\<or> p = 2\"", "lemma two_cong_0_iff_int: \"p > 0 \\<Longrightarrow> [2 = 0] (mod p) \\<longleftrightarrow> p = 1 \\<or> p = 2\" for p :: int", "lemma QuadRes_2_2 [simp, intro]: \"QuadRes 2 2\"", "lemma Suc_mod_eq[simp]: \"[Suc a = Suc b] (mod 2) = [a = b] (mod 2)\"", "lemma div_cancel_aux: \"c dvd a \\<Longrightarrow> (d + a * b) div c = (d div c) + a div c * b\" for a b c :: nat", "lemma cong_aux_eq_1: \"odd p \\<Longrightarrow> [(p - 1) div 2 - p div 4 = (p^2 - 1) div 8] (mod 2)\" for p :: nat", "lemma cong_2_pow[intro]: \"(-1 :: int)^a = (-1)^b\" if \"[a = b] (mod 2)\" for a b :: nat", "lemma card_Int: \"card (A \\<inter> B) = card A - card (A - B)\" if \"finite A\"", "theorem supplement2_Legendre:\n  fixes p :: int\n  assumes \"p > 2\" \"prime p\"\n  shows \"Legendre 2 p = (-1) ^ (((nat p)^2 - 1) div 8)\"", "theorem supplement1_Legendre:\n  \"prime p \\<Longrightarrow> 2 < p \\<Longrightarrow> Legendre (-1) p = (-1)^((p-1) div 2)\"", "lemma QuadRes_1_right [intro, simp]: \"QuadRes p 1\"", "lemma Legendre_1_left [simp]: \"prime p \\<Longrightarrow> Legendre 1 p = 1\"", "lemma cong_eq_0_not_coprime: \"prime p \\<Longrightarrow> [a = 0] (mod p) \\<Longrightarrow> \\<not>coprime a p\" for a p :: int", "lemma not_coprime_cong_eq_0: \"prime p \\<Longrightarrow> \\<not>coprime a p \\<Longrightarrow> [a = 0] (mod p)\" for a p :: int", "lemma prime_cong_eq_0_iff: \"prime p \\<Longrightarrow> [a = 0] (mod p) \\<longleftrightarrow> \\<not>coprime a p\" for a p :: int", "lemma Legendre_eq_0_iff [simp]: \"prime p \\<Longrightarrow> Legendre a p = 0 \\<longleftrightarrow> \\<not>coprime a p\"", "lemma Legendre_prod_mset [simp]: \"prime p \\<Longrightarrow> Legendre (prod_mset M) p = (\\<Prod>q\\<in>#M. Legendre q p)\"", "lemma Legendre_0_eq_0[simp]: \"Legendre 0 p = 0\"", "lemma Legendre_values: \"Legendre p q \\<in> {1, - 1, 0}\""], "translations": [["", "lemma basic_cong[simp]: \n  fixes p :: int\n  assumes \"2 < p\"\n  shows   \"[-1 \\<noteq>  1] (mod p)\"\n          \"[ 1 \\<noteq> -1] (mod p)\"\n          \"[ 0 \\<noteq>  1] (mod p)\"\n          \"[ 1 \\<noteq>  0] (mod p)\"\n          \"[ 0 \\<noteq> -1] (mod p)\"\n          \"[-1 \\<noteq>  0] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([- 1 \\<noteq> 1] (mod p) &&&\n     [1 \\<noteq> - 1] (mod p) &&& [0 \\<noteq> 1] (mod p)) &&&\n    [1 \\<noteq> 0] (mod p) &&&\n    [0 \\<noteq> - 1] (mod p) &&& [- 1 \\<noteq> 0] (mod p)", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. ([- 1 \\<noteq> 1] (mod p) &&&\n     [1 \\<noteq> - 1] (mod p) &&& [0 \\<noteq> 1] (mod p)) &&&\n    [1 \\<noteq> 0] (mod p) &&&\n    [0 \\<noteq> - 1] (mod p) &&& [- 1 \\<noteq> 0] (mod p)", "by (simp_all add: cong_iff_dvd_diff zdvd_not_zless)"], ["", "lemma [simp]: \"0 < n \\<Longrightarrow> (a mod 2) ^ n = a mod 2\" for n :: nat and a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> (a mod 2) ^ n = a mod 2", "by (metis not_mod_2_eq_0_eq_1 power_one zero_power)"], ["", "lemma Legendre_in_cong_eq: \n  fixes p :: int\n  assumes \"p > 2\" and \"b \\<in> {-1,0,1}\"\n  shows   \"[Legendre a m = b] (mod p) \\<longleftrightarrow> Legendre a m = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Legendre a m = b] (mod p) = (Legendre a m = b)", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n  b \\<in> {- 1, 0, 1}\n\ngoal (1 subgoal):\n 1. [Legendre a m = b] (mod p) = (Legendre a m = b)", "unfolding Legendre_def"], ["proof (prove)\nusing this:\n  2 < p\n  b \\<in> {- 1, 0, 1}\n\ngoal (1 subgoal):\n 1. [if [a = 0] (mod m) then 0\n     else if QuadRes m a then 1 else - 1 = b] (mod p) =\n    ((if [a = 0] (mod m) then 0 else if QuadRes m a then 1 else - 1) = b)", "by auto"], ["", "lemma Legendre_p_eq_2[simp]: \"Legendre a 2 = a mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre a 2 = a mod 2", "by (clarsimp simp: Legendre_def QuadRes_def cong_iff_dvd_diff) presburger"], ["", "lemma Legendre_p_eq_1[simp]: \"Legendre a 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre a 1 = 0", "by (simp add: Legendre_def)"], ["", "lemma euler_criterion_int:\n  assumes \"prime p\" and \"2 < p\" \n  shows \"[Legendre a p = a^((nat p-1) div 2)] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Legendre a p = a ^ ((nat p - 1) div 2)] (mod p)", "using euler_criterion assms prime_int_nat_transfer"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?p; 2 < ?p\\<rbrakk>\n  \\<Longrightarrow> [Legendre ?a\n                      (int ?p) = ?a ^ ((?p - 1) div 2)] (mod int ?p)\n  prime p\n  2 < p\n  prime ?k = (0 \\<le> ?k \\<and> prime (nat ?k))\n\ngoal (1 subgoal):\n 1. [Legendre a p = a ^ ((nat p - 1) div 2)] (mod p)", "by (metis int_nat_eq nat_numeral prime_gt_0_int zless_nat_conj)"], ["", "lemma QuadRes_neg[simp]: \"QuadRes (-p) a = QuadRes p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QuadRes (- p) a = QuadRes p a", "unfolding QuadRes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y. [y\\<^sup>2 = a] (mod - p)) =\n    (\\<exists>y. [y\\<^sup>2 = a] (mod p))", "by auto"], ["", "lemma Legendre_neg[simp]: \"Legendre a (-p) = Legendre a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre a (- p) = Legendre a p", "unfolding Legendre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [a = 0] (mod - p) then 0 else if QuadRes (- p) a then 1 else - 1) =\n    (if [a = 0] (mod p) then 0 else if QuadRes p a then 1 else - 1)", "by auto"], ["", "lemma Legendre_mult[simp]:\n  assumes \"prime p\"\n  shows \"Legendre (a*b) p = Legendre a p * Legendre b p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre (a * b) p = Legendre a p * Legendre b p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Legendre (a * b) p = Legendre a p * Legendre b p", "consider \"p = 2\" | \"p > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = 2 \\<Longrightarrow> thesis;\n     2 < p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms order_le_less prime_ge_2_int"], ["proof (prove)\nusing this:\n  prime p\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  prime ?p \\<Longrightarrow> 2 \\<le> ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = 2 \\<Longrightarrow> thesis;\n     2 < p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>p = 2 \\<Longrightarrow> ?thesis;\n   2 < p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Legendre (a * b) p = Legendre a p * Legendre b p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>p = 2 \\<Longrightarrow> ?thesis;\n   2 < p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Legendre (a * b) p = Legendre a p * Legendre b p", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p\n 2. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "case 1"], ["proof (state)\nthis:\n  p = 2\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p\n 2. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "then"], ["proof (chain)\npicking this:\n  p = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 2\n\ngoal (1 subgoal):\n 1. Legendre (a * b) p = Legendre a p * Legendre b p", "by (metis Legendre_p_eq_2 mod_mult_eq mod_self mult_cancel_right2\n                mult_eq_0_iff not_mod_2_eq_1_eq_0 one_mod_two_eq_one)"], ["proof (state)\nthis:\n  Legendre (a * b) p = Legendre a p * Legendre b p\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "case 2"], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "hence \"[Legendre (a*b) p = (a*b)^((nat p-1) div 2)] (mod p)\""], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. [Legendre (a * b) p = (a * b) ^ ((nat p - 1) div 2)] (mod p)", "using euler_criterion_int assms"], ["proof (prove)\nusing this:\n  2 < p\n  \\<lbrakk>prime ?p; 2 < ?p\\<rbrakk>\n  \\<Longrightarrow> [Legendre ?a ?p = ?a ^ ((nat ?p - 1) div 2)] (mod ?p)\n  prime p\n\ngoal (1 subgoal):\n 1. [Legendre (a * b) p = (a * b) ^ ((nat p - 1) div 2)] (mod p)", "by blast"], ["proof (state)\nthis:\n  [Legendre (a * b) p = (a * b) ^ ((nat p - 1) div 2)] (mod p)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "also"], ["proof (state)\nthis:\n  [Legendre (a * b) p = (a * b) ^ ((nat p - 1) div 2)] (mod p)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "have \"[(a*b)^((nat p-1) div 2) = a^((nat p-1) div 2) * b^((nat p-1) div 2)] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a * b) ^\n     ((nat p - 1) div\n      2) = a ^ ((nat p - 1) div 2) * b ^ ((nat p - 1) div 2)] (mod p)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  [(a * b) ^\n   ((nat p - 1) div\n    2) = a ^ ((nat p - 1) div 2) * b ^ ((nat p - 1) div 2)] (mod p)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "also"], ["proof (state)\nthis:\n  [(a * b) ^\n   ((nat p - 1) div\n    2) = a ^ ((nat p - 1) div 2) * b ^ ((nat p - 1) div 2)] (mod p)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "have \"[a^((nat p-1) div 2) * b^((nat p-1) div 2) = Legendre a p * Legendre b p] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a ^ ((nat p - 1) div 2) *\n     b ^ ((nat p - 1) div 2) = Legendre a p * Legendre b p] (mod p)", "using cong_sym[OF euler_criterion_int] assms 2 cong_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?a; 2 < ?a\\<rbrakk>\n  \\<Longrightarrow> [?a1 ^ ((nat ?a - 1) div 2) = Legendre ?a1 ?a] (mod ?a)\n  prime p\n  2 < p\n  \\<lbrakk>[?b = ?c] (mod ?a); [?d = ?e] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b * ?d = ?c * ?e] (mod ?a)\n\ngoal (1 subgoal):\n 1. [a ^ ((nat p - 1) div 2) *\n     b ^ ((nat p - 1) div 2) = Legendre a p * Legendre b p] (mod p)", "by blast"], ["proof (state)\nthis:\n  [a ^ ((nat p - 1) div 2) *\n   b ^ ((nat p - 1) div 2) = Legendre a p * Legendre b p] (mod p)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow> Legendre (a * b) p = Legendre a p * Legendre b p", "finally"], ["proof (chain)\npicking this:\n  [Legendre (a * b) p = Legendre a p * Legendre b p] (mod p)", "show ?thesis"], ["proof (prove)\nusing this:\n  [Legendre (a * b) p = Legendre a p * Legendre b p] (mod p)\n\ngoal (1 subgoal):\n 1. Legendre (a * b) p = Legendre a p * Legendre b p", "using Legendre_in_cong_eq[OF 2]"], ["proof (prove)\nusing this:\n  [Legendre (a * b) p = Legendre a p * Legendre b p] (mod p)\n  ?b \\<in> {- 1, 0, 1} \\<Longrightarrow>\n  [Legendre ?a ?m = ?b] (mod p) = (Legendre ?a ?m = ?b)\n\ngoal (1 subgoal):\n 1. Legendre (a * b) p = Legendre a p * Legendre b p", "by (simp add: Legendre_def)"], ["proof (state)\nthis:\n  Legendre (a * b) p = Legendre a p * Legendre b p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Legendre (a * b) p = Legendre a p * Legendre b p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma QuadRes_mod[simp]: \"p dvd n \\<Longrightarrow> QuadRes p (a mod n) = QuadRes p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd n \\<Longrightarrow> QuadRes p (a mod n) = QuadRes p a", "by (simp add: mod_mod_cancel QuadRes_def cong_def)"], ["", "lemma Legendre_mod[simp]: \"p dvd n \\<Longrightarrow> Legendre (a mod n) p = Legendre a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd n \\<Longrightarrow> Legendre (a mod n) p = Legendre a p", "by (simp add: mod_mod_cancel Legendre_def cong_def)"], ["", "lemma two_cong_0_iff: \"[2 = 0] (mod p) \\<longleftrightarrow> p = 1 \\<or> p = 2\" for p :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 = 0] (mod p) = (p = 1 \\<or> p = 2)", "unfolding cong_altdef_nat[of 0 2 p, simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p dvd 2) = (p = 1 \\<or> p = 2)", "using dvd_refl prime_nat_iff two_is_prime_nat"], ["proof (prove)\nusing this:\n  ?a dvd ?a\n  prime ?n =\n  (1 < ?n \\<and>\n   (\\<forall>m. m dvd ?n \\<longrightarrow> m = 1 \\<or> m = ?n))\n  prime 2\n\ngoal (1 subgoal):\n 1. (p dvd 2) = (p = 1 \\<or> p = 2)", "by blast"], ["", "lemma two_cong_0_iff_nat: \"[2 = 0] (mod int p) \\<longleftrightarrow> p = 1 \\<or> p = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 = 0] (mod int p) = (p = 1 \\<or> p = 2)", "unfolding cong_iff_dvd_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int p dvd 2 - 0) = (p = 1 \\<or> p = 2)", "using two_is_prime_nat prime_nat_iff int_dvd_int_iff[of p 2]"], ["proof (prove)\nusing this:\n  prime 2\n  prime ?n =\n  (1 < ?n \\<and>\n   (\\<forall>m. m dvd ?n \\<longrightarrow> m = 1 \\<or> m = ?n))\n  (int p dvd int 2) = (p dvd 2)\n\ngoal (1 subgoal):\n 1. (int p dvd 2 - 0) = (p = 1 \\<or> p = 2)", "by auto"], ["", "lemma two_cong_0_iff_int: \"p > 0 \\<Longrightarrow> [2 = 0] (mod p) \\<longleftrightarrow> p = 1 \\<or> p = 2\" for p :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p \\<Longrightarrow> [2 = 0] (mod p) = (p = 1 \\<or> p = 2)", "by (metis of_nat_numeral pos_int_cases semiring_char_0_class.of_nat_eq_1_iff two_cong_0_iff_nat)"], ["", "lemma QuadRes_2_2 [simp, intro]: \"QuadRes 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QuadRes 2 2", "unfolding QuadRes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. [y\\<^sup>2 = 2] (mod 2)", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. y\\<^sup>2 mod 2 = 2 mod 2", "by presburger"], ["", "lemma Suc_mod_eq[simp]: \"[Suc a = Suc b] (mod 2) = [a = b] (mod 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Suc a = Suc b] (mod 2) = [a = b] (mod 2)", "using Suc_eq_plus1_left cong_add_lcancel_nat"], ["proof (prove)\nusing this:\n  Suc ?n = 1 + ?n\n  [?a + ?x = ?a + ?y] (mod ?n) = [?x = ?y] (mod ?n)\n\ngoal (1 subgoal):\n 1. [Suc a = Suc b] (mod 2) = [a = b] (mod 2)", "by presburger"], ["", "lemma div_cancel_aux: \"c dvd a \\<Longrightarrow> (d + a * b) div c = (d div c) + a div c * b\" for a b c :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. c dvd a \\<Longrightarrow> (d + a * b) div c = d div c + a div c * b", "by (metis div_plus_div_distrib_dvd_right dvd_div_mult dvd_trans dvd_triv_left)"], ["", "corollary div_cancel_Suc: \"c dvd a \\<Longrightarrow> 1 < c \\<Longrightarrow> Suc (a * b) div c = a div c * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd a; 1 < c\\<rbrakk>\n    \\<Longrightarrow> Suc (a * b) div c = a div c * b", "using div_cancel_aux[where d = 1]"], ["proof (prove)\nusing this:\n  ?c dvd ?a \\<Longrightarrow>\n  (1 + ?a * ?b) div ?c = 1 div ?c + ?a div ?c * ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd a; 1 < c\\<rbrakk>\n    \\<Longrightarrow> Suc (a * b) div c = a div c * b", "by fastforce"], ["", "lemma cong_aux_eq_1: \"odd p \\<Longrightarrow> [(p - 1) div 2 - p div 4 = (p^2 - 1) div 8] (mod 2)\" for p :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. odd p \\<Longrightarrow>\n    [(p - 1) div 2 - p div 4 = (p\\<^sup>2 - 1) div 8] (mod 2)", "proof (induction p rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   odd m \\<longrightarrow>\n                   [(m - 1) div 2 -\n                    m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2);\n        odd n\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) div 2 -\n                          n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "case (1 n)"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     odd m \\<longrightarrow>\n     [(m - 1) div 2 - m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2)\n  odd n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   odd m \\<longrightarrow>\n                   [(m - 1) div 2 -\n                    m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2);\n        odd n\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) div 2 -\n                          n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "consider \"n = 1\" | \"n > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 1 \\<Longrightarrow> thesis;\n     1 < n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using odd_pos[OF \\<open>odd n\\<close>]"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 1 \\<Longrightarrow> thesis;\n     1 < n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>n = 1 \\<Longrightarrow> ?thesis;\n   1 < n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   odd m \\<longrightarrow>\n                   [(m - 1) div 2 -\n                    m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2);\n        odd n\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) div 2 -\n                          n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = 1 \\<Longrightarrow> ?thesis;\n   1 < n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = 1 \\<Longrightarrow> ?thesis;\n   1 < n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "assume \"n > 1\""], ["proof (state)\nthis:\n  1 < n\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "then"], ["proof (chain)\npicking this:\n  1 < n", "obtain m where m: \"m = n - 2\" and m': \"odd m\" \"m < n\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m = n - 2; odd m; m < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>odd n\\<close>"], ["proof (prove)\nusing this:\n  1 < n\n  odd n\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m = n - 2; odd m; m < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  m = n - 2\n  odd m\n  m < n\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "then"], ["proof (chain)\npicking this:\n  m = n - 2\n  odd m\n  m < n", "obtain b where b: \"m = 2 * b + 1\""], ["proof (prove)\nusing this:\n  m = n - 2\n  odd m\n  m < n\n\ngoal (1 subgoal):\n 1. (\\<And>b. m = 2 * b + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using oddE"], ["proof (prove)\nusing this:\n  m = n - 2\n  odd m\n  m < n\n  \\<lbrakk>odd ?a;\n   \\<And>b. ?a = (2::?'a) * b + (1::?'a) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>b. m = 2 * b + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = 2 * b + 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "have IH: \"[(m - 1) div 2 - m div 4 = (m^2 - 1) div 8] (mod 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(m - 1) div 2 - m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2)", "using \"1.IH\" m'"], ["proof (prove)\nusing this:\n  \\<forall>m<n.\n     odd m \\<longrightarrow>\n     [(m - 1) div 2 - m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2)\n  odd m\n  m < n\n\ngoal (1 subgoal):\n 1. [(m - 1) div 2 - m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2)", "by simp"], ["proof (state)\nthis:\n  [(m - 1) div 2 - m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "have [simp]: \"n = 2 * b + 1 + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 2 * b + 1 + 2", "using m \\<open>n > 1\\<close> b"], ["proof (prove)\nusing this:\n  m = n - 2\n  1 < n\n  m = 2 * b + 1\n\ngoal (1 subgoal):\n 1. n = 2 * b + 1 + 2", "by auto"], ["proof (state)\nthis:\n  n = 2 * b + 1 + 2\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "have *: \"(n\\<^sup>2 - 1) div 8 = ((n - 2)\\<^sup>2 - 1) div 8 + (n - 1) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n\\<^sup>2 - 1) div 8 = ((n - 2)\\<^sup>2 - 1) div 8 + (n - 1) div 2", "unfolding  power2_sum power2_eq_square"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n * n - 1) div 8 = ((n - 2) * (n - 2) - 1) div 8 + (n - 1) div 2", "by simp"], ["proof (state)\nthis:\n  (n\\<^sup>2 - 1) div 8 = ((n - 2)\\<^sup>2 - 1) div 8 + (n - 1) div 2\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "have \"[(n - 1) div 2 - n div 4 = (n - 2 - 1) div 2 - (n - 2) div 4 + (n - 1) div 2] (mod 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(n - 1) div 2 -\n     n div 4 = (n - 2 - 1) div 2 - (n - 2) div 4 + (n - 1) div 2] (mod 2)", "by (rule cong_sym, cases \"even b\") (auto simp: cong_altdef_nat div_cancel_Suc elim: oddE)"], ["proof (state)\nthis:\n  [(n - 1) div 2 -\n   n div 4 = (n - 2 - 1) div 2 - (n - 2) div 4 + (n - 1) div 2] (mod 2)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "also"], ["proof (state)\nthis:\n  [(n - 1) div 2 -\n   n div 4 = (n - 2 - 1) div 2 - (n - 2) div 4 + (n - 1) div 2] (mod 2)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "have \"[(n - 2 - 1) div 2 - (n - 2) div 4 + (n - 1) div 2 = (n\\<^sup>2 - 1) div 8] (mod 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(n - 2 - 1) div 2 - (n - 2) div 4 +\n     (n - 1) div 2 = (n\\<^sup>2 - 1) div 8] (mod 2)", "using IH cong_add_rcancel_nat"], ["proof (prove)\nusing this:\n  [(m - 1) div 2 - m div 4 = (m\\<^sup>2 - 1) div 8] (mod 2)\n  [?x + ?a = ?y + ?a] (mod ?n) = [?x = ?y] (mod ?n)\n\ngoal (1 subgoal):\n 1. [(n - 2 - 1) div 2 - (n - 2) div 4 +\n     (n - 1) div 2 = (n\\<^sup>2 - 1) div 8] (mod 2)", "unfolding * m"], ["proof (prove)\nusing this:\n  [(n - 2 - 1) div 2 - (n - 2) div 4 = ((n - 2)\\<^sup>2 - 1) div 8] (mod 2)\n  [?x + ?a = ?y + ?a] (mod ?n) = [?x = ?y] (mod ?n)\n\ngoal (1 subgoal):\n 1. [(n - 2 - 1) div 2 - (n - 2) div 4 +\n     (n - 1) div 2 = ((n - 2)\\<^sup>2 - 1) div 8 + (n - 1) div 2] (mod 2)", "by presburger"], ["proof (state)\nthis:\n  [(n - 2 - 1) div 2 - (n - 2) div 4 +\n   (n - 1) div 2 = (n\\<^sup>2 - 1) div 8] (mod 2)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n 2. 1 < n \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "finally"], ["proof (chain)\npicking this:\n  [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n\ngoal (1 subgoal):\n 1. [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "."], ["proof (state)\nthis:\n  [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)", "qed simp"], ["proof (state)\nthis:\n  [(n - 1) div 2 - n div 4 = (n\\<^sup>2 - 1) div 8] (mod 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cong_2_pow[intro]: \"(-1 :: int)^a = (-1)^b\" if \"[a = b] (mod 2)\" for a b :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ a = (- 1) ^ b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (- 1) ^ a = (- 1) ^ b", "have \"even a = even b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even a = even b", "by (simp add: cong_dvd_iff that)"], ["proof (state)\nthis:\n  even a = even b\n\ngoal (1 subgoal):\n 1. (- 1) ^ a = (- 1) ^ b", "then"], ["proof (chain)\npicking this:\n  even a = even b", "show ?thesis"], ["proof (prove)\nusing this:\n  even a = even b\n\ngoal (1 subgoal):\n 1. (- 1) ^ a = (- 1) ^ b", "by auto"], ["proof (state)\nthis:\n  (- 1) ^ a = (- 1) ^ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_Int: \"card (A \\<inter> B) = card A - card (A - B)\" if \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A \\<inter> B) = card A - card (A - B)", "by (metis Diff_Diff_Int Diff_subset card_Diff_subset finite_Diff that)"], ["", "text \\<open>Proofs are inspired by \\cite{Quadratic_Reciprocity}.\\<close>"], ["", "theorem supplement2_Legendre:\n  fixes p :: int\n  assumes \"p > 2\" \"prime p\"\n  shows \"Legendre 2 p = (-1) ^ (((nat p)^2 - 1) div 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "interpret GAUSS \"nat p\" 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. GAUSS (nat p) 2", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n\ngoal (1 subgoal):\n 1. GAUSS (nat p) 2", "unfolding GAUSS_def prime_int_nat_transfer"], ["proof (prove)\nusing this:\n  2 < p\n  0 \\<le> p \\<and> prime (nat p)\n\ngoal (1 subgoal):\n 1. (prime (nat p) \\<and> 2 < nat p) \\<and>\n    [2 \\<noteq> 0] (mod int (nat p)) \\<and> 0 < 2", "by (simp add: two_cong_0_iff_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"card E = card ((\\<lambda>x. x * 2 mod p) `\n          {0<..(p - 1) div 2} \\<inter> {(p - 1) div 2<..})\" (is \"_ = card ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card E =\n    card\n     ((\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} \\<inter>\n      {(p - 1) div 2<..})", "unfolding E_def C_def B_def A_def image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>x. x * 2 mod int (nat p)) `\n      {0<..(int (nat p) - 1) div 2} \\<inter>\n      {(int (nat p) - 1) div 2<..}) =\n    card\n     ((\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} \\<inter>\n      {(p - 1) div 2<..})", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>x. x * 2 mod int (nat p)) `\n      {0<..(int (nat p) - 1) div 2} \\<inter>\n      {(int (nat p) - 1) div 2<..}) =\n    card\n     ((\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} \\<inter>\n      {(p - 1) div 2<..})", "by simp"], ["proof (state)\nthis:\n  card E =\n  card\n   ((\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} \\<inter>\n    {(p - 1) div 2<..})\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  card E =\n  card\n   ((\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} \\<inter>\n    {(p - 1) div 2<..})\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"(\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} = ((*) 2) ` {0<..(p - 1) div 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} =\n    (*) 2 ` {0<..(p - 1) div 2}", "by (intro image_cong) auto"], ["proof (state)\nthis:\n  (\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} =\n  (*) 2 ` {0<..(p - 1) div 2}\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. x * 2 mod p) ` {0<..(p - 1) div 2} =\n  (*) 2 ` {0<..(p - 1) div 2}\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"card (\\<dots> \\<inter> {(p - 1) div 2<..}) =\n               nat ((p - 1) div 2) - card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((*) 2 ` {0<..(p - 1) div 2} \\<inter> {(p - 1) div 2<..}) =\n    nat ((p - 1) div 2) -\n    card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..})", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n\ngoal (1 subgoal):\n 1. card ((*) 2 ` {0<..(p - 1) div 2} \\<inter> {(p - 1) div 2<..}) =\n    nat ((p - 1) div 2) -\n    card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..})", "by (subst card_Int) (auto simp: card_image inj_onI)"], ["proof (state)\nthis:\n  card ((*) 2 ` {0<..(p - 1) div 2} \\<inter> {(p - 1) div 2<..}) =\n  nat ((p - 1) div 2) -\n  card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..})\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  card ((*) 2 ` {0<..(p - 1) div 2} \\<inter> {(p - 1) div 2<..}) =\n  nat ((p - 1) div 2) -\n  card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..})\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"card (((*) 2) ` {0<..(p - 1) div 2} - {(p - 1) div 2<..}) = card {0 <.. (p div 4)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..}) =\n    card {0<..p div 4}", "by (rule sym, intro bij_betw_same_card[of \"(*) 2\"] bij_betw_imageI inj_onI)\n       (insert assms prime_odd_int[of p], auto simp: image_def elim!: oddE)"], ["proof (state)\nthis:\n  card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..}) =\n  card {0<..p div 4}\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  card ((*) 2 ` {0<..(p - 1) div 2} - {(p - 1) div 2<..}) =\n  card {0<..p div 4}\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"\\<dots> = nat p div 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0<..p div 4} = nat p div 4", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n\ngoal (1 subgoal):\n 1. card {0<..p div 4} = nat p div 4", "by simp"], ["proof (state)\nthis:\n  card {0<..p div 4} = nat p div 4\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  card {0<..p div 4} = nat p div 4\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"nat ((p - 1) div 2) - nat p div 4 =  nat ((p - 1) div 2 - p div 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat ((p - 1) div 2) - nat p div 4 = nat ((p - 1) div 2 - p div 4)", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n\ngoal (1 subgoal):\n 1. nat ((p - 1) div 2) - nat p div 4 = nat ((p - 1) div 2 - p div 4)", "by (simp add: nat_diff_distrib nat_div_distrib)"], ["proof (state)\nthis:\n  nat ((p - 1) div 2) - nat p div 4 = nat ((p - 1) div 2 - p div 4)\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "finally"], ["proof (chain)\npicking this:\n  card E = nat ((p - 1) div 2 - p div 4)", "have \"card E = \\<dots>\""], ["proof (prove)\nusing this:\n  card E = nat ((p - 1) div 2 - p div 4)\n\ngoal (1 subgoal):\n 1. card E = nat ((p - 1) div 2 - p div 4)", "."], ["proof (state)\nthis:\n  card E = nat ((p - 1) div 2 - p div 4)\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "then"], ["proof (chain)\npicking this:\n  card E = nat ((p - 1) div 2 - p div 4)", "have \"Legendre 2 p = (-1) ^ nat ((p - 1) div 2 - p div 4)\""], ["proof (prove)\nusing this:\n  card E = nat ((p - 1) div 2 - p div 4)\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ nat ((p - 1) div 2 - p div 4)", "using gauss_lemma assms"], ["proof (prove)\nusing this:\n  card E = nat ((p - 1) div 2 - p div 4)\n  Legendre 2 (int (nat p)) = (- 1) ^ card E\n  2 < p\n  prime p\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ nat ((p - 1) div 2 - p div 4)", "by simp"], ["proof (state)\nthis:\n  Legendre 2 p = (- 1) ^ nat ((p - 1) div 2 - p div 4)\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  Legendre 2 p = (- 1) ^ nat ((p - 1) div 2 - p div 4)\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"nat ((p - 1) div 2 - p div 4) = (nat p - 1) div 2 - nat p div 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat ((p - 1) div 2 - p div 4) = (nat p - 1) div 2 - nat p div 4", "using assms"], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n\ngoal (1 subgoal):\n 1. nat ((p - 1) div 2 - p div 4) = (nat p - 1) div 2 - nat p div 4", "by (simp add: nat_div_distrib nat_diff_distrib)"], ["proof (state)\nthis:\n  nat ((p - 1) div 2 - p div 4) = (nat p - 1) div 2 - nat p div 4\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "also"], ["proof (state)\nthis:\n  nat ((p - 1) div 2 - p div 4) = (nat p - 1) div 2 - nat p div 4\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "have \"(-1) ^ \\<dots> = ((-1) ^ (((nat p)^2 - 1) div 8) :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ ((nat p - 1) div 2 - nat p div 4) =\n    (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "using cong_aux_eq_1[of \"nat p\"] odd_p"], ["proof (prove)\nusing this:\n  odd (nat p) \\<Longrightarrow>\n  [(nat p - 1) div 2 - nat p div 4 = ((nat p)\\<^sup>2 - 1) div 8] (mod 2)\n  odd (nat p)\n\ngoal (1 subgoal):\n 1. (- 1) ^ ((nat p - 1) div 2 - nat p div 4) =\n    (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "by blast"], ["proof (state)\nthis:\n  (- 1) ^ ((nat p - 1) div 2 - nat p div 4) =\n  (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "finally"], ["proof (chain)\npicking this:\n  Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "show ?thesis"], ["proof (prove)\nusing this:\n  Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)", "."], ["proof (state)\nthis:\n  Legendre 2 p = (- 1) ^ (((nat p)\\<^sup>2 - 1) div 8)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem supplement1_Legendre:\n  \"prime p \\<Longrightarrow> 2 < p \\<Longrightarrow> Legendre (-1) p = (-1)^((p-1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; 2 < p\\<rbrakk>\n    \\<Longrightarrow> Legendre (- 1) (int p) = (- 1) ^ ((p - 1) div 2)", "using euler_criterion[of p \"-1\"] Legendre_in_cong_eq[symmetric, of p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; 2 < p\\<rbrakk>\n  \\<Longrightarrow> [Legendre (- 1)\n                      (int p) = (- 1) ^ ((p - 1) div 2)] (mod int p)\n  \\<lbrakk>2 < int p; ?b \\<in> {- 1, 0, 1}\\<rbrakk>\n  \\<Longrightarrow> (Legendre ?a ?m = ?b) =\n                    [Legendre ?a ?m = ?b] (mod int p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; 2 < p\\<rbrakk>\n    \\<Longrightarrow> Legendre (- 1) (int p) = (- 1) ^ ((p - 1) div 2)", "by (simp add: minus_one_power_iff)"], ["", "lemma QuadRes_1_right [intro, simp]: \"QuadRes p 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QuadRes p 1", "by (metis QuadRes_def cong_def power_one)"], ["", "lemma Legendre_1_left [simp]: \"prime p \\<Longrightarrow> Legendre 1 p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow> Legendre 1 p = 1", "by (auto simp add: Legendre_def cong_iff_dvd_diff not_prime_unit)"], ["", "lemma cong_eq_0_not_coprime: \"prime p \\<Longrightarrow> [a = 0] (mod p) \\<Longrightarrow> \\<not>coprime a p\" for a p :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; [a = 0] (mod p)\\<rbrakk>\n    \\<Longrightarrow> \\<not> coprime a p", "unfolding cong_iff_dvd_diff prime_int_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < p \\<and>\n             (\\<forall>m.\n                 0 \\<le> m \\<and> m dvd p \\<longrightarrow>\n                 m = 1 \\<or> m = p);\n     p dvd a - 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> coprime a p", "by auto"], ["", "lemma not_coprime_cong_eq_0: \"prime p \\<Longrightarrow> \\<not>coprime a p \\<Longrightarrow> [a = 0] (mod p)\" for a p :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; \\<not> coprime a p\\<rbrakk>\n    \\<Longrightarrow> [a = 0] (mod p)", "unfolding cong_iff_dvd_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; \\<not> coprime a p\\<rbrakk>\n    \\<Longrightarrow> p dvd a - 0", "using prime_imp_coprime[of p a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; \\<not> p dvd a\\<rbrakk> \\<Longrightarrow> coprime p a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; \\<not> coprime a p\\<rbrakk>\n    \\<Longrightarrow> p dvd a - 0", "by (auto simp: coprime_commute)"], ["", "lemma prime_cong_eq_0_iff: \"prime p \\<Longrightarrow> [a = 0] (mod p) \\<longleftrightarrow> \\<not>coprime a p\" for a p :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow> [a = 0] (mod p) = (\\<not> coprime a p)", "using not_coprime_cong_eq_0[of p a] cong_eq_0_not_coprime[of p a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; \\<not> coprime a p\\<rbrakk>\n  \\<Longrightarrow> [a = 0] (mod p)\n  \\<lbrakk>prime p; [a = 0] (mod p)\\<rbrakk>\n  \\<Longrightarrow> \\<not> coprime a p\n\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow> [a = 0] (mod p) = (\\<not> coprime a p)", "by auto"], ["", "lemma Legendre_eq_0_iff [simp]: \"prime p \\<Longrightarrow> Legendre a p = 0 \\<longleftrightarrow> \\<not>coprime a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow> (Legendre a p = 0) = (\\<not> coprime a p)", "unfolding Legendre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow>\n    ((if [a = 0] (mod p) then 0 else if QuadRes p a then 1 else - 1) = 0) =\n    (\\<not> coprime a p)", "by (auto simp: prime_cong_eq_0_iff)"], ["", "lemma Legendre_prod_mset [simp]: \"prime p \\<Longrightarrow> Legendre (prod_mset M) p = (\\<Prod>q\\<in>#M. Legendre q p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow>\n    Legendre (\\<Prod>\\<^sub># M) p = (\\<Prod>q\\<in>#M. Legendre q p)", "by (induction M) simp_all"], ["", "lemma Legendre_0_eq_0[simp]: \"Legendre 0 p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre 0 p = 0", "unfolding Legendre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [0 = 0] (mod p) then 0 else if QuadRes p 0 then 1 else - 1) = 0", "by auto"], ["", "lemma Legendre_values: \"Legendre p q \\<in> {1, - 1, 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre p q \\<in> {1, - 1, 0}", "unfolding Legendre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [p = 0] (mod q) then 0 else if QuadRes q p then 1 else - 1)\n    \\<in> {1, - 1, 0}", "by auto"], ["", "end"]]}