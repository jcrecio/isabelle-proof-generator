{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests/Residues_Nat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests", "problem_names": ["lemma carrier_eq [simp]: \"carrier G = totatives n\"\n  and mult_eq [simp]:    \"(x \\<otimes>\\<^bsub>G\\<^esub> y) = (x * y) mod n\"\n  and one_eq [simp]:     \"\\<one>\\<^bsub>G\\<^esub> = 1\"", "lemma mult_eq': \"(\\<otimes>\\<^bsub>G\\<^esub>) = (\\<lambda>x y. (x * y) mod n)\"", "lemma nat_pow_eq [simp]: \"x [^]\\<^bsub>G\\<^esub> (k :: nat) = (x ^ k) mod n\"", "lemma nat_pow_eq': \"([^]\\<^bsub>G\\<^esub>) = (\\<lambda>x k. (x ^ k) mod n)\"", "lemma order_eq: \"order G = totient n\"", "lemma order_less: \"\\<not>prime n \\<Longrightarrow> order G < n - 1\"", "lemma ord_residue_mult_group:\n  assumes \"a \\<in> totatives n\"\n  shows   \"local.ord a = Pocklington.ord n a\"", "lemma carrier_eq [simp]: \"carrier R = {0..<n}\"\n  and mult_eq [simp]: \"x \\<otimes>\\<^bsub>R\\<^esub> y = (x * y) mod n\"\n  and add_eq [simp]: \"x \\<oplus>\\<^bsub>R\\<^esub> y = (x + y) mod n\"\n  and one_eq [simp]: \"\\<one>\\<^bsub>R\\<^esub> = 1\"\n  and zero_eq [simp]: \"\\<zero>\\<^bsub>R\\<^esub> = 0\"", "lemma mult_eq': \"(\\<otimes>\\<^bsub>R\\<^esub>) = (\\<lambda>x y. (x * y) mod n)\"\n  and add_eq': \"(\\<oplus>\\<^bsub>R\\<^esub>) = (\\<lambda>x y. (x + y) mod n)\"", "lemma Units_eq: \"Units R = totatives n\"", "lemma nat_pow_eq [simp]: \"x [^]\\<^bsub>R\\<^esub> (k :: nat) = (x ^ k) mod n\"", "lemma nat_pow_eq': \"([^]\\<^bsub>R\\<^esub>) = (\\<lambda>x k. (x ^ k) mod n)\"", "lemma carrier_eq' [simp]: \"totatives p = {0<..<p}\"", "lemma order_eq: \"order (units_of R) = p - 1\"", "lemma order_eq' [simp]: \"totient p = p - 1\"", "lemma residues_prime_cyclic: \"\\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\"", "lemma residues_prime_cyclic': \"\\<exists>x\\<in>{0<..<p}. units.ord x = p - 1\"", "lemma minus_one_cong_solve_weak:\n  fixes n x :: nat\n  assumes \"1 < n\" \"x \\<in> totatives n\" \"y \\<in> totatives n\"\n    and  \"[x = n - 1] (mod n)\" \"[x * y = 1] (mod n)\"\n  shows \"y = n - 1\"", "lemma coprime_imp_mod_not_zero:\n  fixes n x :: nat\n  assumes \"1 < n\" \"coprime x n\"\n  shows \"0 < x mod n\"", "lemma minus_one_cong_solve:\n  fixes n x :: nat\n  assumes \"1 < n\"\n    and eq: \"[x = n - 1] (mod n)\" \"[x * y = 1] (mod n)\"\n    and coprime: \"coprime x n\" \"coprime y n\"\n  shows \"[y = n - 1](mod n)\""], "translations": [["", "lemma carrier_eq [simp]: \"carrier G = totatives n\"\n  and mult_eq [simp]:    \"(x \\<otimes>\\<^bsub>G\\<^esub> y) = (x * y) mod n\"\n  and one_eq [simp]:     \"\\<one>\\<^bsub>G\\<^esub> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier G = totatives n &&&\n    x \\<otimes>\\<^bsub>G\\<^esub> y = x * y mod n &&&\n    \\<one>\\<^bsub>G\\<^esub> = 1", "by (auto simp: G_def Residues_Mult_def totatives_def)"], ["", "lemma mult_eq': \"(\\<otimes>\\<^bsub>G\\<^esub>) = (\\<lambda>x y. (x * y) mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<otimes>\\<^bsub>G\\<^esub>) = (\\<lambda>x y. x * y mod n)", "by (intro ext; simp)+"], ["", "sublocale group G"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group G", "proof(rule groupI, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub> y \\<in> carrier G\n 2. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> carrier G\n  y \\<in> carrier G\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub> y \\<in> carrier G\n 2. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "from 1"], ["proof (chain)\npicking this:\n  x \\<in> carrier G\n  y \\<in> carrier G", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n  y \\<in> carrier G\n\ngoal (1 subgoal):\n 1. x \\<otimes>\\<^bsub>G\\<^esub> y \\<in> carrier G", "using n_gt_1"], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n  y \\<in> carrier G\n  1 < n\n\ngoal (1 subgoal):\n 1. x \\<otimes>\\<^bsub>G\\<^esub> y \\<in> carrier G", "by (auto intro!: Nat.gr0I simp: coprime_commute coprime_dvd_mult_left_iff\n                                    coprime_absorb_left nat_dvd_not_less totatives_def)"], ["proof (state)\nthis:\n  x \\<otimes>\\<^bsub>G\\<^esub> y \\<in> carrier G\n\ngoal (4 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "case (5 x)"], ["proof (state)\nthis:\n  x \\<in> carrier G\n\ngoal (4 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "hence \"(\\<exists>y. y \\<ge> 0 \\<and> y < n \\<and> [x * y = Suc 0] (mod n))\""], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<ge>0. y < n \\<and> [x * y = Suc 0] (mod n)", "using coprime_iff_invertible'_nat[of n x] n_gt_1"], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n  0 < n \\<Longrightarrow>\n  coprime x n = (\\<exists>xa\\<ge>0. xa < n \\<and> [x * xa = Suc 0] (mod n))\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<ge>0. y < n \\<and> [x * y = Suc 0] (mod n)", "by (auto simp: totatives_def)"], ["proof (state)\nthis:\n  \\<exists>y\\<ge>0. y < n \\<and> [x * y = Suc 0] (mod n)\n\ngoal (4 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "then"], ["proof (chain)\npicking this:\n  \\<exists>y\\<ge>0. y < n \\<and> [x * y = Suc 0] (mod n)", "obtain y where y: \"y \\<ge> 0\" \"y < n\" \"[x * y = Suc 0] (mod n)\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<ge>0. y < n \\<and> [x * y = Suc 0] (mod n)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>0 \\<le> y; y < n; [x * y = Suc 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> y\n  y < n\n  [x * y = Suc 0] (mod n)\n\ngoal (4 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "from \\<open>[x * y = Suc 0] (mod n)\\<close>"], ["proof (chain)\npicking this:\n  [x * y = Suc 0] (mod n)", "have \"gcd (x * y) n = 1\""], ["proof (prove)\nusing this:\n  [x * y = Suc 0] (mod n)\n\ngoal (1 subgoal):\n 1. gcd (x * y) n = 1", "by (simp add: cong_gcd_eq)"], ["proof (state)\nthis:\n  gcd (x * y) n = 1\n\ngoal (4 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "hence \"coprime y n\""], ["proof (prove)\nusing this:\n  gcd (x * y) n = 1\n\ngoal (1 subgoal):\n 1. coprime y n", "by fastforce"], ["proof (state)\nthis:\n  coprime y n\n\ngoal (4 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x\n 4. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<exists>y\\<in>carrier G.\n          y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "with y n_gt_1"], ["proof (chain)\npicking this:\n  0 \\<le> y\n  y < n\n  [x * y = Suc 0] (mod n)\n  1 < n\n  coprime y n", "show \"\\<exists>y\\<in>carrier G. y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n  y < n\n  [x * y = Suc 0] (mod n)\n  1 < n\n  coprime y n\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>carrier G.\n       y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>", "by (intro bexI[of _ y]) (auto simp: totatives_def cong_def mult_ac intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>carrier G.\n     y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<one>\\<^bsub>G\\<^esub> \\<in> carrier G\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n        z \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>G\\<^esub>\n                         y \\<otimes>\\<^bsub>G\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>G\\<^esub>\n                         (y \\<otimes>\\<^bsub>G\\<^esub> z)\n 3. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       \\<one>\\<^bsub>G\\<^esub> \\<otimes>\\<^bsub>G\\<^esub> x = x", "qed (use n_gt_1 in \\<open>auto simp: mod_simps algebra_simps totatives_less\\<close>)"], ["", "sublocale comm_group"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group G", "by unfold_locales (auto simp: mult_ac)"], ["", "lemma nat_pow_eq [simp]: \"x [^]\\<^bsub>G\\<^esub> (k :: nat) = (x ^ k) mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>G\\<^esub> k = x ^ k mod n", "using n_gt_1"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>G\\<^esub> k = x ^ k mod n", "by (induction k) (simp_all add: mod_mult_left_eq mod_mult_right_eq mult_ac)"], ["", "lemma nat_pow_eq': \"([^]\\<^bsub>G\\<^esub>) = (\\<lambda>x k. (x ^ k) mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([^]\\<^bsub>G\\<^esub>) = (\\<lambda>x k. x ^ k mod n)", "by (intro ext) simp"], ["", "lemma order_eq: \"order G = totient n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order G = totient n", "by (simp add: order_def totient_def)"], ["", "lemma order_less: \"\\<not>prime n \\<Longrightarrow> order G < n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> prime n \\<Longrightarrow> order G < n - 1", "using totient_less_not_prime[of n] n_gt_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n  \\<Longrightarrow> totient n < n - 1\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<not> prime n \\<Longrightarrow> order G < n - 1", "by (auto simp: order_eq)"], ["", "lemma ord_residue_mult_group:\n  assumes \"a \\<in> totatives n\"\n  shows   \"local.ord a = Pocklington.ord n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ord a = Pocklington.ord n a", "proof (rule dvd_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. local.ord a dvd Pocklington.ord n a\n 2. Pocklington.ord n a dvd local.ord a", "have \"[a ^ local.ord a = 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a ^ local.ord a = 1] (mod n)", "using pow_ord_eq_1[of a] assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier G \\<Longrightarrow>\n  a [^]\\<^bsub>G\\<^esub> local.ord a = \\<one>\\<^bsub>G\\<^esub>\n  a \\<in> totatives n\n\ngoal (1 subgoal):\n 1. [a ^ local.ord a = 1] (mod n)", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  [a ^ local.ord a = 1] (mod n)\n\ngoal (2 subgoals):\n 1. local.ord a dvd Pocklington.ord n a\n 2. Pocklington.ord n a dvd local.ord a", "thus \"Pocklington.ord n a dvd local.ord a\""], ["proof (prove)\nusing this:\n  [a ^ local.ord a = 1] (mod n)\n\ngoal (1 subgoal):\n 1. Pocklington.ord n a dvd local.ord a", "by (subst (asm) ord_divides)"], ["proof (state)\nthis:\n  Pocklington.ord n a dvd local.ord a\n\ngoal (1 subgoal):\n 1. local.ord a dvd Pocklington.ord n a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ord a dvd Pocklington.ord n a", "show \"local.ord a dvd Pocklington.ord n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ord a dvd Pocklington.ord n a", "using assms Pocklington.ord[of a n] n_gt_1 pow_eq_id"], ["proof (prove)\nusing this:\n  a \\<in> totatives n\n  [a ^ Pocklington.ord n a = 1] (mod n)\n  1 < n\n  ?x \\<in> carrier G \\<Longrightarrow>\n  (?x [^]\\<^bsub>G\\<^esub> ?n = \\<one>\\<^bsub>G\\<^esub>) =\n  (local.ord ?x dvd ?n)\n\ngoal (1 subgoal):\n 1. local.ord a dvd Pocklington.ord n a", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  local.ord a dvd Pocklington.ord n a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The ring of residues modulo \\<open>n\\<close>\\<close>"], ["", "definition Residues_nat :: \"nat \\<Rightarrow> nat ring\" where\n  \"Residues_nat m = \\<lparr>carrier = {0..<m}, monoid.mult = \\<lambda>x y. (x * y) mod m, one = 1,\n                     ring.zero = 0, add = \\<lambda>x y. (x + y) mod m\\<rparr>\""], ["", "locale residues_nat =\n  fixes n :: nat and R\n  assumes n_gt_1: \"n > 1\"\n  defines \"R \\<equiv> Residues_nat n\"\nbegin"], ["", "lemma carrier_eq [simp]: \"carrier R = {0..<n}\"\n  and mult_eq [simp]: \"x \\<otimes>\\<^bsub>R\\<^esub> y = (x * y) mod n\"\n  and add_eq [simp]: \"x \\<oplus>\\<^bsub>R\\<^esub> y = (x + y) mod n\"\n  and one_eq [simp]: \"\\<one>\\<^bsub>R\\<^esub> = 1\"\n  and zero_eq [simp]: \"\\<zero>\\<^bsub>R\\<^esub> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (carrier R = {0..<n} &&&\n     x \\<otimes>\\<^bsub>R\\<^esub> y = x * y mod n) &&&\n    x \\<oplus>\\<^bsub>R\\<^esub> y = (x + y) mod n &&&\n    \\<one>\\<^bsub>R\\<^esub> = 1 &&& \\<zero>\\<^bsub>R\\<^esub> = 0", "by (simp_all add: Residues_nat_def R_def)"], ["", "lemma mult_eq': \"(\\<otimes>\\<^bsub>R\\<^esub>) = (\\<lambda>x y. (x * y) mod n)\"\n  and add_eq': \"(\\<oplus>\\<^bsub>R\\<^esub>) = (\\<lambda>x y. (x + y) mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<otimes>\\<^bsub>R\\<^esub>) = (\\<lambda>x y. x * y mod n) &&&\n    (\\<oplus>\\<^bsub>R\\<^esub>) = (\\<lambda>x y. (x + y) mod n)", "by (intro ext; simp)+"], ["", "sublocale abelian_group R"], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_group R", "proof(rule abelian_groupI, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y \\<in> carrier R\n 2. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 6. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> carrier R\n  y \\<in> carrier R\n\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y \\<in> carrier R\n 2. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 6. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "then"], ["proof (chain)\npicking this:\n  x \\<in> carrier R\n  y \\<in> carrier R", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> carrier R\n  y \\<in> carrier R\n\ngoal (1 subgoal):\n 1. x \\<oplus>\\<^bsub>R\\<^esub> y \\<in> carrier R", "using n_gt_1"], ["proof (prove)\nusing this:\n  x \\<in> carrier R\n  y \\<in> carrier R\n  1 < n\n\ngoal (1 subgoal):\n 1. x \\<oplus>\\<^bsub>R\\<^esub> y \\<in> carrier R", "by (auto simp: mod_simps algebra_simps simp flip: less_Suc_eq_le)"], ["proof (state)\nthis:\n  x \\<oplus>\\<^bsub>R\\<^esub> y \\<in> carrier R\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "case (6 x)"], ["proof (state)\nthis:\n  x \\<in> carrier R\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "{"], ["proof (state)\nthis:\n  x \\<in> carrier R\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "assume \"x < n\" \"1 < n\""], ["proof (state)\nthis:\n  x < n\n  1 < n\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "hence \"n - x \\<in> {0..<n}\" \"((n - x) + x) mod n = 0\" if \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x < n\n  1 < n\n\ngoal (1 subgoal):\n 1. n - x \\<in> {0..<n} &&& (n - x + x) mod n = 0", "using that"], ["proof (prove)\nusing this:\n  x < n\n  1 < n\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n - x \\<in> {0..<n} &&& (n - x + x) mod n = 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0 \\<Longrightarrow> n - x \\<in> {0..<n}\n  x \\<noteq> 0 \\<Longrightarrow> (n - x + x) mod n = 0\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> 0 \\<Longrightarrow> n - x \\<in> {0..<n}\n  x \\<noteq> 0 \\<Longrightarrow> (n - x + x) mod n = 0\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "have \"0 \\<in> {0..<n}\" \"(0 + x) mod n = 0\" if \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<n} &&& (0 + x) mod n = 0", "using that n_gt_1"], ["proof (prove)\nusing this:\n  x = 0\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<n} &&& (0 + x) mod n = 0", "by auto"], ["proof (state)\nthis:\n  x = 0 \\<Longrightarrow> 0 \\<in> {0..<n}\n  x = 0 \\<Longrightarrow> (0 + x) mod n = 0\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> 0 \\<Longrightarrow> n - x \\<in> {0..<n}\n  x \\<noteq> 0 \\<Longrightarrow> (n - x + x) mod n = 0\n  x = 0 \\<Longrightarrow> 0 \\<in> {0..<n}\n  x = 0 \\<Longrightarrow> (0 + x) mod n = 0", "have \"\\<exists>y\\<in>{0..<n}. (y + x) mod n = 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0 \\<Longrightarrow> n - x \\<in> {0..<n}\n  x \\<noteq> 0 \\<Longrightarrow> (n - x + x) mod n = 0\n  x = 0 \\<Longrightarrow> 0 \\<in> {0..<n}\n  x = 0 \\<Longrightarrow> (0 + x) mod n = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>{0..<n}. (y + x) mod n = 0", "by meson"], ["proof (state)\nthis:\n  \\<exists>y\\<in>{0..<n}. (y + x) mod n = 0\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x < n; 1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>{0..<n}. (y + x) mod n = 0\n\ngoal (5 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x\n 5. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<exists>y\\<in>carrier R.\n          y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "with 6"], ["proof (chain)\npicking this:\n  x \\<in> carrier R\n  \\<lbrakk>x < n; 1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>{0..<n}. (y + x) mod n = 0", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> carrier R\n  \\<lbrakk>x < n; 1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>{0..<n}. (y + x) mod n = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>carrier R.\n       y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "using n_gt_1"], ["proof (prove)\nusing this:\n  x \\<in> carrier R\n  \\<lbrakk>x < n; 1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>{0..<n}. (y + x) mod n = 0\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>carrier R.\n       y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>carrier R.\n     y \\<oplus>\\<^bsub>R\\<^esub> x = \\<zero>\\<^bsub>R\\<^esub>\n\ngoal (4 subgoals):\n 1. \\<zero>\\<^bsub>R\\<^esub> \\<in> carrier R\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R;\n        z \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub>\n                         y \\<oplus>\\<^bsub>R\\<^esub>\n                         z =\n                         x \\<oplus>\\<^bsub>R\\<^esub>\n                         (y \\<oplus>\\<^bsub>R\\<^esub> z)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier R; y \\<in> carrier R\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus>\\<^bsub>R\\<^esub> y =\n                         y \\<oplus>\\<^bsub>R\\<^esub> x\n 4. \\<And>x.\n       x \\<in> carrier R \\<Longrightarrow>\n       \\<zero>\\<^bsub>R\\<^esub> \\<oplus>\\<^bsub>R\\<^esub> x = x", "qed (use n_gt_1 in \\<open>auto simp add: mod_simps algebra_simps\\<close>)"], ["", "sublocale comm_monoid R"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.comm_monoid R", "using n_gt_1"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. Group.comm_monoid R", "by unfold_locales (auto simp: mult_ac mod_simps)"], ["", "sublocale cring R"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring R", "by unfold_locales (auto simp: mod_simps algebra_simps)"], ["", "lemma Units_eq: \"Units R = totatives n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Units R = totatives n", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Units R \\<Longrightarrow> x \\<in> totatives n\n 2. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Units R \\<Longrightarrow> x \\<in> totatives n\n 2. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "assume x: \"x \\<in> Units R\""], ["proof (state)\nthis:\n  x \\<in> Units R\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Units R \\<Longrightarrow> x \\<in> totatives n\n 2. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "then"], ["proof (chain)\npicking this:\n  x \\<in> Units R", "obtain y where y: \"[x * y = 1] (mod n)\""], ["proof (prove)\nusing this:\n  x \\<in> Units R\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        [x * y = 1] (mod n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using n_gt_1"], ["proof (prove)\nusing this:\n  x \\<in> Units R\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        [x * y = 1] (mod n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Units_def cong_def)"], ["proof (state)\nthis:\n  [x * y = 1] (mod n)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Units R \\<Longrightarrow> x \\<in> totatives n\n 2. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "hence \"coprime x n\""], ["proof (prove)\nusing this:\n  [x * y = 1] (mod n)\n\ngoal (1 subgoal):\n 1. coprime x n", "using cong_imp_coprime cong_sym coprime_1_left coprime_mult_left_iff"], ["proof (prove)\nusing this:\n  [x * y = 1] (mod n)\n  \\<lbrakk>[?a = ?b] (mod ?m); coprime ?a ?m\\<rbrakk>\n  \\<Longrightarrow> coprime ?b ?m\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  coprime (1::?'a) ?a\n  coprime (?a * ?b) ?c = (coprime ?a ?c \\<and> coprime ?b ?c)\n\ngoal (1 subgoal):\n 1. coprime x n", "by metis"], ["proof (state)\nthis:\n  coprime x n\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Units R \\<Longrightarrow> x \\<in> totatives n\n 2. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "with x"], ["proof (chain)\npicking this:\n  x \\<in> Units R\n  coprime x n", "show \"x \\<in> totatives n\""], ["proof (prove)\nusing this:\n  x \\<in> Units R\n  coprime x n\n\ngoal (1 subgoal):\n 1. x \\<in> totatives n", "by (auto simp: totatives_def Units_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  x \\<in> totatives n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "assume x: \"x \\<in> totatives n\""], ["proof (state)\nthis:\n  x \\<in> totatives n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "then"], ["proof (chain)\npicking this:\n  x \\<in> totatives n", "obtain y where \"y < n\" \"[x * y = 1] (mod n)\""], ["proof (prove)\nusing this:\n  x \\<in> totatives n\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y < n; [x * y = 1] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using coprime_iff_invertible'_nat[of n x]"], ["proof (prove)\nusing this:\n  x \\<in> totatives n\n  0 < n \\<Longrightarrow>\n  coprime x n = (\\<exists>xa\\<ge>0. xa < n \\<and> [x * xa = Suc 0] (mod n))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y < n; [x * y = 1] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: totatives_def)"], ["proof (state)\nthis:\n  y < n\n  [x * y = 1] (mod n)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> totatives n \\<Longrightarrow> x \\<in> Units R", "with x"], ["proof (chain)\npicking this:\n  x \\<in> totatives n\n  y < n\n  [x * y = 1] (mod n)", "show \"x \\<in> Units R\""], ["proof (prove)\nusing this:\n  x \\<in> totatives n\n  y < n\n  [x * y = 1] (mod n)\n\ngoal (1 subgoal):\n 1. x \\<in> Units R", "using n_gt_1"], ["proof (prove)\nusing this:\n  x \\<in> totatives n\n  y < n\n  [x * y = 1] (mod n)\n  1 < n\n\ngoal (1 subgoal):\n 1. x \\<in> Units R", "by (auto simp: Units_def mult_ac cong_def totatives_less)"], ["proof (state)\nthis:\n  x \\<in> Units R\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale units: residues_mult_nat n \"units_of R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residues_mult_nat n &&& units_of R \\<equiv> Residues_Mult n", "proof unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < n\n 2. units_of R \\<equiv> Residues_Mult n", "show \"units_of R \\<equiv> Residues_Mult n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. units_of R \\<equiv> Residues_Mult n", "by (auto simp: units_of_def Units_eq Residues_Mult_def totatives_def Suc_le_eq mult_eq')"], ["proof (state)\nthis:\n  units_of R \\<equiv> Residues_Mult n\n\ngoal (1 subgoal):\n 1. 1 < n", "qed (use n_gt_1 in auto)"], ["", "lemma nat_pow_eq [simp]: \"x [^]\\<^bsub>R\\<^esub> (k :: nat) = (x ^ k) mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>R\\<^esub> k = x ^ k mod n", "using n_gt_1"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>R\\<^esub> k = x ^ k mod n", "by (induction k) (auto simp: mod_simps mult_ac)"], ["", "lemma nat_pow_eq': \"([^]\\<^bsub>R\\<^esub>) = (\\<lambda>x k. (x ^ k) mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([^]\\<^bsub>R\\<^esub>) = (\\<lambda>x k. x ^ k mod n)", "by (intro ext) simp"], ["", "end"], ["", "subsection \\<open>The ring of residues modulo a prime\\<close>"], ["", "locale residues_nat_prime =\n  fixes p :: nat and R\n  assumes prime_p: \"prime p\"\n  defines \"R \\<equiv> Residues_nat p\"\nbegin"], ["", "sublocale residues_nat p R"], ["proof (prove)\ngoal (1 subgoal):\n 1. residues_nat p &&& R \\<equiv> Residues_nat p", "using prime_gt_1_nat[OF prime_p]"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. residues_nat p &&& R \\<equiv> Residues_nat p", "by unfold_locales (auto simp: R_def)"], ["", "lemma carrier_eq' [simp]: \"totatives p = {0<..<p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totatives p = {0<..<p}", "using prime_p"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. totatives p = {0<..<p}", "by (auto simp: totatives_prime)"], ["", "lemma order_eq: \"order (units_of R) = p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (units_of R) = p - 1", "using prime_p"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. order (units_of R) = p - 1", "by (simp add: units.order_eq totient_prime)"], ["", "lemma order_eq' [simp]: \"totient p = p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient p = p - 1", "using prime_p"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. totient p = p - 1", "by (auto simp: totient_prime)"], ["", "sublocale field R"], ["proof (prove)\ngoal (1 subgoal):\n 1. field R", "proof (rule cring_fieldI)"], ["proof (state)\ngoal (1 subgoal):\n 1. Units R = carrier R - {\\<zero>\\<^bsub>R\\<^esub>}", "show \"Units R = carrier R - {\\<zero>\\<^bsub>R\\<^esub>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Units R = carrier R - {\\<zero>\\<^bsub>R\\<^esub>}", "by (subst Units_eq) (use prime_p in \\<open>auto simp: totatives_prime\\<close>)"], ["proof (state)\nthis:\n  Units R = carrier R - {\\<zero>\\<^bsub>R\\<^esub>}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma residues_prime_cyclic: \"\\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}", "from n_gt_1"], ["proof (chain)\npicking this:\n  1 < p", "have \"{0..<p} - {0} = {0<..<p}\""], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. {0..<p} - {0} = {0<..<p}", "by auto"], ["proof (state)\nthis:\n  {0..<p} - {0} = {0<..<p}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {0..<p} - {0} = {0<..<p}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}", "using finite_field_mult_group_has_gen"], ["proof (prove)\nusing this:\n  {0..<p} - {0} = {0<..<p}\n  finite (carrier R) \\<Longrightarrow>\n  \\<exists>a\\<in>carrier (Multiplicative_Group.mult_of R).\n     carrier (Multiplicative_Group.mult_of R) =\n     {a [^]\\<^bsub>R\\<^esub> i |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}", "by simp"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma residues_prime_cyclic': \"\\<exists>x\\<in>{0<..<p}. units.ord x = p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. units.ord x = p - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. units.ord x = p - 1", "from residues_prime_cyclic"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}", "obtain x\n    where x: \"x \\<in> {0<..<p}\" \"{0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{0<..<p}. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {0<..<p};\n         {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  x \\<in> {0<..<p}\n  {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. units.ord x = p - 1", "have \"units.ord x = p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. units.ord x = p - 1", "proof (intro antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. units.ord x \\<le> p - 1\n 2. p - 1 \\<le> units.ord x", "show \"units.ord x \\<le> p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. units.ord x \\<le> p - 1", "using units.ord_dvd_group_order[of x] x(1)"], ["proof (prove)\nusing this:\n  x \\<in> carrier (units_of R) \\<Longrightarrow>\n  units.ord x dvd order (units_of R)\n  x \\<in> {0<..<p}\n\ngoal (1 subgoal):\n 1. units.ord x \\<le> p - 1", "by (auto simp: units.order_eq intro!: dvd_imp_le)"], ["proof (state)\nthis:\n  units.ord x \\<le> p - 1\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "(* TODO FIXME: a bit ugly; could be simplified if we had a theory of finite cyclic rings *)"], ["proof (state)\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "have \"p - 1 = card {0<..<p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - 1 = card {0<..<p}", "by simp"], ["proof (state)\nthis:\n  p - 1 = card {0<..<p}\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "also"], ["proof (state)\nthis:\n  p - 1 = card {0<..<p}\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "have \"{0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}", "by fact"], ["proof (state)\nthis:\n  {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "also"], ["proof (state)\nthis:\n  {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "have \"card \\<dots> \\<le> card ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {y. \\<exists>i. y = x ^ i mod p}\n    \\<le> card ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})", "proof (intro card_mono; safe?)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "fix j :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "have \"j = units.ord x * (j div units.ord x) + (j mod units.ord x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = units.ord x * (j div units.ord x) + j mod units.ord x", "by simp"], ["proof (state)\nthis:\n  j = units.ord x * (j div units.ord x) + j mod units.ord x\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "also"], ["proof (state)\nthis:\n  j = units.ord x * (j div units.ord x) + j mod units.ord x\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "have \"x [^]\\<^bsub>units_of R\\<^esub> \\<dots> = x [^]\\<^bsub>units_of R\\<^esub> (units.ord x * (j div units.ord x))\n                   \\<otimes>\\<^bsub>units_of R\\<^esub> x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>units_of R\\<^esub>\n    (units.ord x * (j div units.ord x) + j mod units.ord x) =\n    x [^]\\<^bsub>units_of R\\<^esub>\n    (units.ord x * (j div units.ord x)) \\<otimes>\\<^bsub>units_of R\\<^esub>\n    x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<p}\n  {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>units_of R\\<^esub>\n    (units.ord x * (j div units.ord x) + j mod units.ord x) =\n    x [^]\\<^bsub>units_of R\\<^esub>\n    (units.ord x * (j div units.ord x)) \\<otimes>\\<^bsub>units_of R\\<^esub>\n    x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)", "by (subst units.nat_pow_mult) auto"], ["proof (state)\nthis:\n  x [^]\\<^bsub>units_of R\\<^esub>\n  (units.ord x * (j div units.ord x) + j mod units.ord x) =\n  x [^]\\<^bsub>units_of R\\<^esub>\n  (units.ord x * (j div units.ord x)) \\<otimes>\\<^bsub>units_of R\\<^esub>\n  x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "also"], ["proof (state)\nthis:\n  x [^]\\<^bsub>units_of R\\<^esub>\n  (units.ord x * (j div units.ord x) + j mod units.ord x) =\n  x [^]\\<^bsub>units_of R\\<^esub>\n  (units.ord x * (j div units.ord x)) \\<otimes>\\<^bsub>units_of R\\<^esub>\n  x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "have \"x [^]\\<^bsub>units_of R\\<^esub> (units.ord x * (j div units.ord x)) =\n                   (x [^]\\<^bsub>units_of R\\<^esub> units.ord x) [^]\\<^bsub>units_of R\\<^esub> (j div units.ord x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>units_of R\\<^esub> (units.ord x * (j div units.ord x)) =\n    (x [^]\\<^bsub>units_of R\\<^esub>\n     units.ord x) [^]\\<^bsub>units_of R\\<^esub>\n    (j div units.ord x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<p}\n  {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>units_of R\\<^esub> (units.ord x * (j div units.ord x)) =\n    (x [^]\\<^bsub>units_of R\\<^esub>\n     units.ord x) [^]\\<^bsub>units_of R\\<^esub>\n    (j div units.ord x)", "by (subst units.nat_pow_pow) auto"], ["proof (state)\nthis:\n  x [^]\\<^bsub>units_of R\\<^esub> (units.ord x * (j div units.ord x)) =\n  (x [^]\\<^bsub>units_of R\\<^esub>\n   units.ord x) [^]\\<^bsub>units_of R\\<^esub>\n  (j div units.ord x)\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "also"], ["proof (state)\nthis:\n  x [^]\\<^bsub>units_of R\\<^esub> (units.ord x * (j div units.ord x)) =\n  (x [^]\\<^bsub>units_of R\\<^esub>\n   units.ord x) [^]\\<^bsub>units_of R\\<^esub>\n  (j div units.ord x)\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "have \"x [^]\\<^bsub>units_of R\\<^esub> units.ord x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>units_of R\\<^esub> units.ord x = 1", "using x(1)"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<p}\n\ngoal (1 subgoal):\n 1. x [^]\\<^bsub>units_of R\\<^esub> units.ord x = 1", "by (subst units.pow_ord_eq_1) auto"], ["proof (state)\nthis:\n  x [^]\\<^bsub>units_of R\\<^esub> units.ord x = 1\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "finally"], ["proof (chain)\npicking this:\n  x [^]\\<^bsub>units_of R\\<^esub> j =\n  1 [^]\\<^bsub>units_of R\\<^esub>\n  (j div units.ord x) \\<otimes>\\<^bsub>units_of R\\<^esub>\n  x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)", "have \"x ^ j mod p = x ^ (j mod units.ord x) mod p\""], ["proof (prove)\nusing this:\n  x [^]\\<^bsub>units_of R\\<^esub> j =\n  1 [^]\\<^bsub>units_of R\\<^esub>\n  (j div units.ord x) \\<otimes>\\<^bsub>units_of R\\<^esub>\n  x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)\n\ngoal (1 subgoal):\n 1. x ^ j mod p = x ^ (j mod units.ord x) mod p", "using n_gt_1"], ["proof (prove)\nusing this:\n  x [^]\\<^bsub>units_of R\\<^esub> j =\n  1 [^]\\<^bsub>units_of R\\<^esub>\n  (j div units.ord x) \\<otimes>\\<^bsub>units_of R\\<^esub>\n  x [^]\\<^bsub>units_of R\\<^esub> (j mod units.ord x)\n  1 < p\n\ngoal (1 subgoal):\n 1. x ^ j mod p = x ^ (j mod units.ord x) mod p", "by simp"], ["proof (state)\nthis:\n  x ^ j mod p = x ^ (j mod units.ord x) mod p\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n 2. \\<And>xa i.\n       x ^ i mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "thus \"x ^ j mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}\""], ["proof (prove)\nusing this:\n  x ^ j mod p = x ^ (j mod units.ord x) mod p\n\ngoal (1 subgoal):\n 1. x ^ j mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "using units.ord_ge_1[of x] x(1)"], ["proof (prove)\nusing this:\n  x ^ j mod p = x ^ (j mod units.ord x) mod p\n  \\<lbrakk>finite (carrier (units_of R));\n   x \\<in> carrier (units_of R)\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> units.ord x\n  x \\<in> {0<..<p}\n\ngoal (1 subgoal):\n 1. x ^ j mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}", "by force"], ["proof (state)\nthis:\n  x ^ j mod p \\<in> (\\<lambda>i. x ^ i mod p) ` {..<units.ord x}\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})", "qed auto"], ["proof (state)\nthis:\n  card {y. \\<exists>i. y = x ^ i mod p}\n  \\<le> card ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "also"], ["proof (state)\nthis:\n  card {y. \\<exists>i. y = x ^ i mod p}\n  \\<le> card ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "have \"\\<dots> \\<le> card {..<units.ord x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n    \\<le> card {..<units.ord x}", "by (intro card_image_le) auto"], ["proof (state)\nthis:\n  card ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n  \\<le> card {..<units.ord x}\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "also"], ["proof (state)\nthis:\n  card ((\\<lambda>i. x ^ i mod p) ` {..<units.ord x})\n  \\<le> card {..<units.ord x}\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "have \"\\<dots> = units.ord x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {..<units.ord x} = units.ord x", "by simp"], ["proof (state)\nthis:\n  card {..<units.ord x} = units.ord x\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "finally"], ["proof (chain)\npicking this:\n  p - 1 \\<le> units.ord x", "show \"p - 1 \\<le> units.ord x\""], ["proof (prove)\nusing this:\n  p - 1 \\<le> units.ord x\n\ngoal (1 subgoal):\n 1. p - 1 \\<le> units.ord x", "."], ["proof (state)\nthis:\n  p - 1 \\<le> units.ord x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  units.ord x = p - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. units.ord x = p - 1", "with x"], ["proof (chain)\npicking this:\n  x \\<in> {0<..<p}\n  {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n  units.ord x = p - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<p}\n  {0<..<p} = {y. \\<exists>i. y = x ^ i mod p}\n  units.ord x = p - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0<..<p}. units.ord x = p - 1", "by metis"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{0<..<p}. units.ord x = p - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>\\<open>-1\\<close> in residue rings\\<close>"], ["", "lemma minus_one_cong_solve_weak:\n  fixes n x :: nat\n  assumes \"1 < n\" \"x \\<in> totatives n\" \"y \\<in> totatives n\"\n    and  \"[x = n - 1] (mod n)\" \"[x * y = 1] (mod n)\"\n  shows \"y = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = n - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y = n - 1", "define G where \"G = Residues_Mult n\""], ["proof (state)\nthis:\n  G = Residues_Mult n\n\ngoal (1 subgoal):\n 1. y = n - 1", "interpret residues_mult_nat n G"], ["proof (prove)\ngoal (1 subgoal):\n 1. residues_mult_nat n &&& G \\<equiv> Residues_Mult n", "by unfold_locales (use \\<open>n > 1\\<close> in \\<open>simp_all add: G_def\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. y = n - 1", "have \"[x * (n - 1) = x * n - x] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * (n - 1) = x * n - x] (mod n)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  [x * (n - 1) = x * n - x] (mod n)\n\ngoal (1 subgoal):\n 1. y = n - 1", "also"], ["proof (state)\nthis:\n  [x * (n - 1) = x * n - x] (mod n)\n\ngoal (1 subgoal):\n 1. y = n - 1", "have \"[x * n - x = (n - 1) * n - (n - 1)] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * n - x = (n - 1) * n - (n - 1)] (mod n)", "using assms"], ["proof (prove)\nusing this:\n  1 < n\n  x \\<in> totatives n\n  y \\<in> totatives n\n  [x = n - 1] (mod n)\n  [x * y = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [x * n - x = (n - 1) * n - (n - 1)] (mod n)", "by (intro cong_diff_nat cong_mult) auto"], ["proof (state)\nthis:\n  [x * n - x = (n - 1) * n - (n - 1)] (mod n)\n\ngoal (1 subgoal):\n 1. y = n - 1", "also"], ["proof (state)\nthis:\n  [x * n - x = (n - 1) * n - (n - 1)] (mod n)\n\ngoal (1 subgoal):\n 1. y = n - 1", "have \"(n - 1) * n - (n - 1) = (n - 1) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n - 1) * n - (n - 1) = (n - 1)\\<^sup>2", "by (simp add: power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  (n - 1) * n - (n - 1) = (n - 1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. y = n - 1", "also"], ["proof (state)\nthis:\n  (n - 1) * n - (n - 1) = (n - 1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. y = n - 1", "have \"[(n - 1)\\<^sup>2 = 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(n - 1)\\<^sup>2 = 1] (mod n)", "using assms"], ["proof (prove)\nusing this:\n  1 < n\n  x \\<in> totatives n\n  y \\<in> totatives n\n  [x = n - 1] (mod n)\n  [x * y = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [(n - 1)\\<^sup>2 = 1] (mod n)", "by (intro square_minus_one_cong_one) auto"], ["proof (state)\nthis:\n  [(n - 1)\\<^sup>2 = 1] (mod n)\n\ngoal (1 subgoal):\n 1. y = n - 1", "finally"], ["proof (chain)\npicking this:\n  [x * (n - 1) = 1] (mod n)", "have \"x * (n - 1) mod n = 1\""], ["proof (prove)\nusing this:\n  [x * (n - 1) = 1] (mod n)\n\ngoal (1 subgoal):\n 1. x * (n - 1) mod n = 1", "using \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  [x * (n - 1) = 1] (mod n)\n  1 < n\n\ngoal (1 subgoal):\n 1. x * (n - 1) mod n = 1", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  x * (n - 1) mod n = 1\n\ngoal (1 subgoal):\n 1. y = n - 1", "hence \"y = n - 1\""], ["proof (prove)\nusing this:\n  x * (n - 1) mod n = 1\n\ngoal (1 subgoal):\n 1. y = n - 1", "using inv_unique'[of x \"n - 1\"] inv_unique'[of x y] minus_one_in_totatives[of n] assms(1-3,5)"], ["proof (prove)\nusing this:\n  x * (n - 1) mod n = 1\n  \\<lbrakk>x \\<in> carrier G; n - 1 \\<in> carrier G;\n   x \\<otimes>\\<^bsub>G\\<^esub> (n - 1) = \\<one>\\<^bsub>G\\<^esub>;\n   (n - 1) \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> n - 1 = inv\\<^bsub>G\\<^esub> x\n  \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G;\n   x \\<otimes>\\<^bsub>G\\<^esub> y = \\<one>\\<^bsub>G\\<^esub>;\n   y \\<otimes>\\<^bsub>G\\<^esub> x = \\<one>\\<^bsub>G\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> y = inv\\<^bsub>G\\<^esub> x\n  2 \\<le> n \\<Longrightarrow> n - 1 \\<in> totatives n\n  1 < n\n  x \\<in> totatives n\n  y \\<in> totatives n\n  [x * y = 1] (mod n)\n\ngoal (1 subgoal):\n 1. y = n - 1", "by (simp_all add: mult_ac cong_def)"], ["proof (state)\nthis:\n  y = n - 1\n\ngoal (1 subgoal):\n 1. y = n - 1", "then"], ["proof (chain)\npicking this:\n  y = n - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  y = n - 1\n\ngoal (1 subgoal):\n 1. y = n - 1", "by simp"], ["proof (state)\nthis:\n  y = n - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_imp_mod_not_zero:\n  fixes n x :: nat\n  assumes \"1 < n\" \"coprime x n\"\n  shows \"0 < x mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x mod n", "using assms coprime_0_left_iff nat_dvd_not_less"], ["proof (prove)\nusing this:\n  1 < n\n  coprime x n\n  coprime (0::?'a) ?a = is_unit ?a\n  \\<lbrakk>0 < ?m; ?m < ?n\\<rbrakk> \\<Longrightarrow> \\<not> ?n dvd ?m\n\ngoal (1 subgoal):\n 1. 0 < x mod n", "by fastforce"], ["", "lemma minus_one_cong_solve:\n  fixes n x :: nat\n  assumes \"1 < n\"\n    and eq: \"[x = n - 1] (mod n)\" \"[x * y = 1] (mod n)\"\n    and coprime: \"coprime x n\" \"coprime y n\"\n  shows \"[y = n - 1](mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "have \"0 < x mod n\" \"0 < y mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x mod n &&& 0 < y mod n", "using coprime coprime_imp_mod_not_zero \\<open>1 < n\\<close>"], ["proof (prove)\nusing this:\n  coprime x n\n  coprime y n\n  \\<lbrakk>1 < ?n; coprime ?x ?n\\<rbrakk> \\<Longrightarrow> 0 < ?x mod ?n\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 < x mod n &&& 0 < y mod n", "by blast+"], ["proof (state)\nthis:\n  0 < x mod n\n  0 < y mod n\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "moreover"], ["proof (state)\nthis:\n  0 < x mod n\n  0 < y mod n\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "have \"x mod n < n\" \"y mod n < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod n < n &&& y mod n < n", "using \\<open>1 < n\\<close>"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. x mod n < n &&& y mod n < n", "by auto"], ["proof (state)\nthis:\n  x mod n < n\n  y mod n < n\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "moreover"], ["proof (state)\nthis:\n  x mod n < n\n  y mod n < n\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "have \"[x mod n = n - 1] (mod n)\" \"[x mod n * (y mod n) = 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x mod n = n - 1] (mod n) &&& [x mod n * (y mod n) = 1] (mod n)", "using eq"], ["proof (prove)\nusing this:\n  [x = n - 1] (mod n)\n  [x * y = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [x mod n = n - 1] (mod n) &&& [x mod n * (y mod n) = 1] (mod n)", "by auto"], ["proof (state)\nthis:\n  [x mod n = n - 1] (mod n)\n  [x mod n * (y mod n) = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "moreover"], ["proof (state)\nthis:\n  [x mod n = n - 1] (mod n)\n  [x mod n * (y mod n) = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "have \"coprime (x mod n) n\" \"coprime (y mod n) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (x mod n) n &&& coprime (y mod n) n", "using coprime coprime_mod_left_iff \\<open>1 < n\\<close>"], ["proof (prove)\nusing this:\n  coprime x n\n  coprime y n\n  ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  coprime (?a mod ?b) ?b = coprime ?a ?b\n  1 < n\n\ngoal (1 subgoal):\n 1. coprime (x mod n) n &&& coprime (y mod n) n", "by auto"], ["proof (state)\nthis:\n  coprime (x mod n) n\n  coprime (y mod n) n\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "ultimately"], ["proof (chain)\npicking this:\n  0 < x mod n\n  0 < y mod n\n  x mod n < n\n  y mod n < n\n  [x mod n = n - 1] (mod n)\n  [x mod n * (y mod n) = 1] (mod n)\n  coprime (x mod n) n\n  coprime (y mod n) n", "have \"[y mod n = n - 1] (mod n)\""], ["proof (prove)\nusing this:\n  0 < x mod n\n  0 < y mod n\n  x mod n < n\n  y mod n < n\n  [x mod n = n - 1] (mod n)\n  [x mod n * (y mod n) = 1] (mod n)\n  coprime (x mod n) n\n  coprime (y mod n) n\n\ngoal (1 subgoal):\n 1. [y mod n = n - 1] (mod n)", "using minus_one_cong_solve_weak[OF \\<open>1 < n\\<close>, of \"x mod n\" \"y mod n\"]"], ["proof (prove)\nusing this:\n  0 < x mod n\n  0 < y mod n\n  x mod n < n\n  y mod n < n\n  [x mod n = n - 1] (mod n)\n  [x mod n * (y mod n) = 1] (mod n)\n  coprime (x mod n) n\n  coprime (y mod n) n\n  \\<lbrakk>x mod n \\<in> totatives n; y mod n \\<in> totatives n;\n   [x mod n = n - 1] (mod n); [x mod n * (y mod n) = 1] (mod n)\\<rbrakk>\n  \\<Longrightarrow> y mod n = n - 1\n\ngoal (1 subgoal):\n 1. [y mod n = n - 1] (mod n)", "by (auto simp: totatives_def)"], ["proof (state)\nthis:\n  [y mod n = n - 1] (mod n)\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "then"], ["proof (chain)\npicking this:\n  [y mod n = n - 1] (mod n)", "show ?thesis"], ["proof (prove)\nusing this:\n  [y mod n = n - 1] (mod n)\n\ngoal (1 subgoal):\n 1. [y = n - 1] (mod n)", "by simp"], ["proof (state)\nthis:\n  [y = n - 1] (mod n)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary square_minus_one_cong_one':\n  fixes n x :: nat\n  assumes \"1 < n\"\n  shows \"[(n - 1) * (n - 1) = 1](mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(n - 1) * (n - 1) = 1] (mod n)", "using square_minus_one_cong_one[OF assms, of \"n - 1\"] assms"], ["proof (prove)\nusing this:\n  [n - 1 = n - 1] (mod n) \\<Longrightarrow> [(n - 1)\\<^sup>2 = 1] (mod n)\n  1 < n\n\ngoal (1 subgoal):\n 1. [(n - 1) * (n - 1) = 1] (mod n)", "by (fastforce simp: power2_eq_square)"], ["", "end"]]}