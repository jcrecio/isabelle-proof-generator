{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Prime_Tests", "problem_names": ["lemma sum_of_bool_eq_card:\n  assumes \"finite S\"\n  shows \"(\\<Sum>a \\<in> S. of_bool (P a)) = real (card {a \\<in> S . P a })\"", "lemma mod_natE:\n  fixes a n b :: nat\n  assumes \"a mod n = b\"\n  shows \"\\<exists> l. a = n * l + b\"", "lemma (in group) r_coset_is_image: \"H #> a = (\\<lambda> x. x \\<otimes> a) ` H\"", "lemma (in group) FactGroup_order:\n  assumes \"subgroup H G\" \"finite H\"\n  shows \"order G = order (G Mod H) * card H\"", "lemma group_hom_imp_group_hom_image:\n  assumes \"group_hom G G h\"\n  shows \"group_hom G (G\\<lparr>carrier := h  ` carrier G\\<rparr>) h\"", "theorem homomorphism_thm:\n  assumes \"group_hom G G h\"\n  shows \"G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h \\<cong> G \\<lparr>carrier := h ` carrier G\\<rparr>\"", "lemma is_iso_imp_same_card:\n  assumes \"H \\<cong> G \"\n  shows \"order H = order G\"", "lemma (in group_hom) kernel_subset: \"kernel G H h \\<subseteq> carrier G\"", "lemma (in group) proper_subgroup_imp_bound_on_card:\n  assumes \"H \\<subset> carrier G\" \"subgroup H G\" \"finite (carrier G)\"\n  shows \"card H \\<le> order G div 2\"", "lemma cong_exp_trans[trans]: \n  \"[a ^ b = c] (mod n) \\<Longrightarrow> [a = d] (mod n) \\<Longrightarrow> [d ^ b = c] (mod n)\"\n  \"[c = a ^ b] (mod n) \\<Longrightarrow> [a = d] (mod n) \\<Longrightarrow> [c = d ^ b] (mod n)\"", "lemma cong_exp_mod[simp]: \n  \"[(a mod n) ^ b = c] (mod n) \\<longleftrightarrow> [a ^ b = c] (mod n)\"\n  \"[c = (a mod n) ^ b] (mod n) \\<longleftrightarrow> [c = a ^ b] (mod n)\"", "lemma cong_mult_mod[simp]:\n  \"[(a mod n) * b = c] (mod n) \\<longleftrightarrow> [a * b = c] (mod n)\"\n  \"[a * (b mod n) = c] (mod n) \\<longleftrightarrow> [a * b = c] (mod n)\"", "lemma cong_add_mod[simp]:\n  \"[(a mod n) + b = c] (mod n) \\<longleftrightarrow> [a + b = c] (mod n)\"\n  \"[a + (b mod n) = c] (mod n) \\<longleftrightarrow> [a + b = c] (mod n)\"\n  \"[\\<Sum>i\\<in>A. f i mod n = c] (mod n) \\<longleftrightarrow> [\\<Sum>i\\<in>A. f i = c] (mod n)\"", "lemma cong_add_trans[trans]:\n  \"[a = b + x] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = b + y] (mod n)\"\n  \"[a = x + b] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = y + b] (mod n)\"\n  \"[b + x = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [b + y = a] (mod n)\"\n  \"[x + b = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [y + b = a] (mod n)\"", "lemma cong_mult_trans[trans]:\n  \"[a = b * x] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = b * y] (mod n)\"\n  \"[a = x * b] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = y * b] (mod n)\"\n  \"[b * x = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [b * y = a] (mod n)\"\n  \"[x * b = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [y * b = a] (mod n)\"", "lemma cong_diff_trans[trans]:\n  \"[a = b - x] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = b - y] (mod n)\" \n  \"[a = x - b] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = y - b] (mod n)\" \n  \"[b - x = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [b - y = a] (mod n)\"\n  \"[x - b = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [y - b = a] (mod n)\"\n  for a :: \"'a :: {unique_euclidean_semiring, euclidean_ring_cancel}\"", "lemma eq_imp_eq_mod_int: \"a = b \\<Longrightarrow> [a = b] (mod m)\" for a b :: int", "lemma eq_imp_eq_mod_nat: \"a = b \\<Longrightarrow> [a = b] (mod m)\" for a b :: nat", "lemma cong_pow_I: \"a = b \\<Longrightarrow> [x^a = x^b](mod n)\"", "lemma gre1I: \"(n = 0 \\<Longrightarrow> False) \\<Longrightarrow> (1 :: nat) \\<le> n\"", "lemma gre1I_nat: \"(n = 0 \\<Longrightarrow> False) \\<Longrightarrow> (Suc 0 :: nat) \\<le> n\"", "lemma totient_less_not_prime:\n  assumes \"\\<not> prime n\" \"1 < n\"\n  shows \"totient n < n - 1\"", "lemma power2_diff_nat: \"x \\<ge> y \\<Longrightarrow> (x - y)\\<^sup>2 = x\\<^sup>2 + y\\<^sup>2 - 2 * x * y\" for x y :: nat", "lemma square_inequality: \"1 < n \\<Longrightarrow> (n + n) \\<le> (n * n)\" for n :: nat", "lemma square_one_cong_one:\n  assumes \"[x = 1](mod n)\"\n  shows \"[x^2 = 1](mod n)\"", "lemma cong_square_alt_int:\n  \"prime p \\<Longrightarrow> [a * a = 1] (mod p) \\<Longrightarrow> [a = 1] (mod p) \\<or> [a = p - 1] (mod p)\"\n  for a p :: \"'a :: {normalization_semidom, linordered_idom, unique_euclidean_ring}\"", "lemma cong_square_alt:\n  \"prime p \\<Longrightarrow> [a * a = 1] (mod p) \\<Longrightarrow> [a = 1] (mod p) \\<or> [a = p - 1] (mod p)\"\n  for a p :: nat", "lemma square_minus_one_cong_one:\n  fixes n x :: nat\n  assumes \"1 < n\" \"[x = n - 1](mod n)\"\n  shows \"[x^2 = 1](mod n)\"", "lemma odd_prime_gt_2_int:\n \"2 < p\" if \"odd p\" \"prime p\" for p :: int", "lemma odd_prime_gt_2_nat:\n \"2 < p\" if \"odd p\" \"prime p\" for p :: nat", "lemma gt_one_imp_gt_one_power_if_coprime:\n  \"1 \\<le> x \\<Longrightarrow> 1 < n \\<Longrightarrow> coprime x n \\<Longrightarrow> 1 \\<le> x ^ (n - 1) mod n\"", "lemma residue_one_dvd: \"a mod n = 1 \\<Longrightarrow> n dvd a - 1\" for a n :: nat", "lemma coprimeI_power_mod:\n  fixes x r n :: nat\n  assumes \"x ^ r mod n = 1\" \"r \\<noteq> 0\" \"n \\<noteq> 0\"\n  shows \"coprime x n\"", "lemma prime_dvd_choose:\n  assumes \"0 < k\" \"k < p\" \"prime p\" \n  shows \"p dvd (p choose k)\"", "lemma cong_eq_0_I: \"(\\<forall>i\\<in>A. [f i mod n = 0] (mod n)) \\<Longrightarrow> [\\<Sum>i\\<in>A. f i = 0] (mod n)\"", "lemma power_mult_cong:\n  assumes \"[x^n = a](mod m)\" \"[y^n = b](mod m)\"\n  shows \"[(x*y)^n = a*b](mod m)\"", "lemma\n  fixes n :: nat\n  assumes \"n > 1\"\n  shows odd_pow_cong: \"odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\"\n  and even_pow_cong: \"even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\"", "lemma cong_mult_uneq':\n  fixes a :: \"'a::{unique_euclidean_ring, ring_gcd}\"\n  assumes \"coprime d a\"\n  shows \"[b \\<noteq> c] (mod a) \\<Longrightarrow> [d = e] (mod a) \\<Longrightarrow> [b * d \\<noteq> c * e] (mod a)\"", "lemma p_coprime_right_nat: \"prime p \\<Longrightarrow> coprime a p = (\\<not> p dvd a)\" for p a :: nat", "lemma squarefree_mult_imp_coprime:\n  assumes \"squarefree (a * b :: 'a :: semiring_gcd)\"\n  shows   \"coprime a b\"", "lemma prime_divisor_exists_strong:\n  fixes m :: int\n  assumes \"m > 1\" \"\\<not>prime m\"\n  shows   \"\\<exists>n k. m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\"", "lemma prime_divisor_exists_strong_nat:\n  fixes m :: nat\n  assumes \"1 < m\" \"\\<not>prime m\"\n  shows   \"\\<exists>p k. m = p * k \\<and> 1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p\"", "lemma prime_factorization_eqI:\n  assumes \"\\<And>p. p \\<in># P \\<Longrightarrow> prime p\" \"prod_mset P = n\"\n  shows   \"prime_factorization n = P\"", "lemma prime_factorization_prime_elem:\n  assumes \"prime_elem p\"\n  shows   \"prime_factorization p = {#normalize p#}\"", "lemma size_prime_factorization_eq_Suc_0_iff [simp]:\n  fixes n :: \"'a :: factorial_semiring_multiplicative\"\n  shows \"size (prime_factorization n) = Suc 0 \\<longleftrightarrow> prime_elem n\"", "lemma squarefree_prime_elem [simp, intro]:\n  fixes p :: \"'a :: algebraic_semidom\"\n  assumes \"prime_elem p\"\n  shows   \"squarefree p\"", "lemma squarefree_prime [simp, intro]: \"prime p \\<Longrightarrow> squarefree p\"", "lemma not_squarefree_primepow:\n  assumes \"primepow n\"\n  shows   \"squarefree n \\<longleftrightarrow> prime n\"", "lemma prime_factorization_normalize [simp]:\n  \"prime_factorization (normalize n) = prime_factorization n\"", "lemma one_prime_factor_iff_primepow:\n  fixes n :: \"'a :: factorial_semiring_multiplicative\"\n  shows \"card (prime_factors n) = Suc 0 \\<longleftrightarrow> primepow (normalize n)\"", "lemma squarefree_imp_prod_prime_factors_eq:\n  fixes x :: \"'a :: factorial_semiring_multiplicative\"\n  assumes \"squarefree x\"\n  shows   \"\\<Prod>(prime_factors x) = normalize x\""], "translations": [["", "lemma sum_of_bool_eq_card:\n  assumes \"finite S\"\n  shows \"(\\<Sum>a \\<in> S. of_bool (P a)) = real (card {a \\<in> S . P a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>S. of_bool (P a)) = real (card {a \\<in> S. P a})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>S. of_bool (P a)) = real (card {a \\<in> S. P a})", "have \"(\\<Sum>a \\<in> S. of_bool (P a) :: real) = (\\<Sum>a \\<in> {x\\<in>S. P x}. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>S. of_bool (P a)) = (\\<Sum>a\\<in>{x \\<in> S. P x}. 1)", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>S. of_bool (P a)) = (\\<Sum>a\\<in>{x \\<in> S. P x}. 1)", "by (intro sum.mono_neutral_cong_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>S. of_bool (P a)) = (\\<Sum>a\\<in>{x \\<in> S. P x}. 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>S. of_bool (P a)) = real (card {a \\<in> S. P a})", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>S. of_bool (P a)) = (\\<Sum>a\\<in>{x \\<in> S. P x}. 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>S. of_bool (P a)) = real (card {a \\<in> S. P a})", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>S. of_bool (P a)) = real (card {a \\<in> S. P a})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_natE:\n  fixes a n b :: nat\n  assumes \"a mod n = b\"\n  shows \"\\<exists> l. a = n * l + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. a = n * l + b", "using assms mod_mult_div_eq[of a n]"], ["proof (prove)\nusing this:\n  a mod n = b\n  a mod n + n * (a div n) = a\n\ngoal (1 subgoal):\n 1. \\<exists>l. a = n * l + b", "by (metis add.commute)"], ["", "lemma (in group) r_coset_is_image: \"H #> a = (\\<lambda> x. x \\<otimes> a) ` H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H #> a = (\\<lambda>x. x \\<otimes> a) ` H", "unfolding r_coset_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {y. \\<exists>x\\<in>H. y = {x \\<otimes> a}} =\n    {y. \\<exists>x\\<in>H. y = x \\<otimes> a}", "by blast"], ["", "lemma (in group) FactGroup_order:\n  assumes \"subgroup H G\" \"finite H\"\n  shows \"order G = order (G Mod H) * card H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order G = order (G Mod H) * card H", "using lagrange assms"], ["proof (prove)\nusing this:\n  subgroup ?H G \\<Longrightarrow> card (rcosets ?H) * card ?H = order G\n  subgroup H G\n  finite H\n\ngoal (1 subgoal):\n 1. order G = order (G Mod H) * card H", "unfolding FactGroup_def order_def"], ["proof (prove)\nusing this:\n  subgroup ?H G \\<Longrightarrow>\n  card (rcosets ?H) * card ?H = card (carrier G)\n  subgroup H G\n  finite H\n\ngoal (1 subgoal):\n 1. card (carrier G) =\n    card\n     (carrier\n       \\<lparr>carrier = rcosets H, monoid.mult = (<#>), one = H\\<rparr>) *\n    card H", "by simp"], ["", "corollary (in group) FactGroup_order_div:\n  assumes \"subgroup H G\" \"finite H\"\n  shows \"order (G Mod H) = order G div card H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (G Mod H) = order G div card H", "using assms FactGroup_order subgroupE(2)[OF \\<open>subgroup H G\\<close>]"], ["proof (prove)\nusing this:\n  subgroup H G\n  finite H\n  \\<lbrakk>subgroup ?H G; finite ?H\\<rbrakk>\n  \\<Longrightarrow> order G = order (G Mod ?H) * card ?H\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. order (G Mod H) = order G div card H", "by (auto simp: order_def)"], ["", "lemma group_hom_imp_group_hom_image:\n  assumes \"group_hom G G h\"\n  shows \"group_hom G (G\\<lparr>carrier := h  ` carrier G\\<rparr>) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_hom G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h", "using group_hom.axioms[OF assms] group_hom.img_is_subgroup[OF assms] group.subgroup_imp_group"], ["proof (prove)\nusing this:\n  Group.group G\n  Group.group G\n  group_hom_axioms G G h\n  subgroup (h ` carrier G) G\n  \\<lbrakk>Group.group ?G; subgroup ?H ?G\\<rbrakk>\n  \\<Longrightarrow> Group.group (?G\\<lparr>carrier := ?H\\<rparr>)\n\ngoal (1 subgoal):\n 1. group_hom G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h", "by(auto intro!: group_hom.intro simp: group_hom_axioms_def hom_def)"], ["", "theorem homomorphism_thm:\n  assumes \"group_hom G G h\"\n  shows \"G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h \\<cong> G \\<lparr>carrier := h ` carrier G\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h \\<cong> G\n    \\<lparr>carrier := h ` carrier G\\<rparr>", "by (intro group_hom.FactGroup_iso group_hom_imp_group_hom_image assms) simp"], ["", "lemma is_iso_imp_same_card:\n  assumes \"H \\<cong> G \"\n  shows \"order H = order G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order H = order G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order H = order G", "from assms"], ["proof (chain)\npicking this:\n  H \\<cong> G", "obtain h where \"bij_betw h (carrier H) (carrier G)\""], ["proof (prove)\nusing this:\n  H \\<cong> G\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        bij_betw h (carrier H) (carrier G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_iso_def iso_def"], ["proof (prove)\nusing this:\n  {h \\<in> hom H G. bij_betw h (carrier H) (carrier G)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        bij_betw h (carrier H) (carrier G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij_betw h (carrier H) (carrier G)\n\ngoal (1 subgoal):\n 1. order H = order G", "then"], ["proof (chain)\npicking this:\n  bij_betw h (carrier H) (carrier G)", "show ?thesis"], ["proof (prove)\nusing this:\n  bij_betw h (carrier H) (carrier G)\n\ngoal (1 subgoal):\n 1. order H = order G", "unfolding order_def"], ["proof (prove)\nusing this:\n  bij_betw h (carrier H) (carrier G)\n\ngoal (1 subgoal):\n 1. card (carrier H) = card (carrier G)", "by (rule bij_betw_same_card)"], ["proof (state)\nthis:\n  order H = order G\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary homomorphism_thm_order:\n  assumes \"group_hom G G h\" \n  shows \"order (G\\<lparr>carrier := h ` carrier G\\<rparr>) * card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) = order G \""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "have \"order (G\\<lparr>carrier := h ` carrier G\\<rparr>) = order (G Mod (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n    order (G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h)", "using is_iso_imp_same_card[OF homomorphism_thm] \\<open>group_hom G G h\\<close>"], ["proof (prove)\nusing this:\n  group_hom ?G1 ?G1 ?h1 \\<Longrightarrow>\n  order\n   (?G1 Mod\n    kernel ?G1 (?G1\\<lparr>carrier := ?h1 ` carrier ?G1\\<rparr>) ?h1) =\n  order (?G1\\<lparr>carrier := ?h1 ` carrier ?G1\\<rparr>)\n  group_hom G G h\n\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n    order (G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h)", "by fastforce"], ["proof (state)\nthis:\n  order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n  order (G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h)\n\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "moreover"], ["proof (state)\nthis:\n  order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n  order (G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h)\n\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "have \"group G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group G", "using \\<open>group_hom G G h\\<close> group_hom.axioms"], ["proof (prove)\nusing this:\n  group_hom G G h\n  group_hom ?G ?H ?h \\<Longrightarrow> Group.group ?G\n  group_hom ?G ?H ?h \\<Longrightarrow> Group.group ?H\n  group_hom ?G ?H ?h \\<Longrightarrow> group_hom_axioms ?G ?H ?h\n\ngoal (1 subgoal):\n 1. Group.group G", "by blast"], ["proof (state)\nthis:\n  Group.group G\n\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "ultimately"], ["proof (chain)\npicking this:\n  order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n  order (G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h)\n  Group.group G", "show ?thesis"], ["proof (prove)\nusing this:\n  order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n  order (G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h)\n  Group.group G\n\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "using \\<open>group_hom G G h\\<close> and group_hom_imp_group_hom_image[OF \\<open>group_hom G G h\\<close>]"], ["proof (prove)\nusing this:\n  order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n  order (G Mod kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h)\n  Group.group G\n  group_hom G G h\n  group_hom G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h\n\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "unfolding FactGroup_def"], ["proof (prove)\nusing this:\n  order (G\\<lparr>carrier := h ` carrier G\\<rparr>) =\n  order\n   \\<lparr>carrier =\n             rcosets\\<^bsub>G\\<^esub> kernel G\n (G\\<lparr>carrier := h ` carrier G\\<rparr>) h,\n      monoid.mult = (<#>\\<^bsub>G\\<^esub>),\n      one = kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h\\<rparr>\n  Group.group G\n  group_hom G G h\n  group_hom G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h\n\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n    card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n    order G", "by (simp add: group.lagrange group_hom.subgroup_kernel order_def)"], ["proof (state)\nthis:\n  order (G\\<lparr>carrier := h ` carrier G\\<rparr>) *\n  card (kernel G (G\\<lparr>carrier := h ` carrier G\\<rparr>) h) =\n  order G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in group_hom) kernel_subset: \"kernel G H h \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel G H h \\<subseteq> carrier G", "using subgroup_kernel G.subgroupE(1)"], ["proof (prove)\nusing this:\n  subgroup (kernel G H h) G\n  subgroup ?H G \\<Longrightarrow> ?H \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. kernel G H h \\<subseteq> carrier G", "by blast"], ["", "lemma (in group) proper_subgroup_imp_bound_on_card:\n  assumes \"H \\<subset> carrier G\" \"subgroup H G\" \"finite (carrier G)\"\n  shows \"card H \\<le> order G div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "from \\<open>finite (carrier G)\\<close>"], ["proof (chain)\npicking this:\n  finite (carrier G)", "have \"finite (rcosets H)\""], ["proof (prove)\nusing this:\n  finite (carrier G)\n\ngoal (1 subgoal):\n 1. finite (rcosets H)", "by (simp add: RCOSETS_def)"], ["proof (state)\nthis:\n  finite (rcosets H)\n\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "note subgroup.subgroup_in_rcosets[OF \\<open>subgroup H G\\<close> is_group]"], ["proof (state)\nthis:\n  H \\<in> rcosets H\n\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "then"], ["proof (chain)\npicking this:\n  H \\<in> rcosets H", "obtain J where \"J \\<noteq> H\" \"J \\<in> rcosets H\""], ["proof (prove)\nusing this:\n  H \\<in> rcosets H\n\ngoal (1 subgoal):\n 1. (\\<And>J.\n        \\<lbrakk>J \\<noteq> H; J \\<in> rcosets H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rcosets_part_G[OF \\<open>subgroup H G\\<close>] and \\<open>H \\<subset> carrier G\\<close>"], ["proof (prove)\nusing this:\n  H \\<in> rcosets H\n  \\<Union> (rcosets H) = carrier G\n  H \\<subset> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>J.\n        \\<lbrakk>J \\<noteq> H; J \\<in> rcosets H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Sup_le_iff inf.absorb_iff2 inf.idem inf.strict_order_iff)"], ["proof (state)\nthis:\n  J \\<noteq> H\n  J \\<in> rcosets H\n\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "then"], ["proof (chain)\npicking this:\n  J \\<noteq> H\n  J \\<in> rcosets H", "have \"2 \\<le> card (rcosets H)\""], ["proof (prove)\nusing this:\n  J \\<noteq> H\n  J \\<in> rcosets H\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (rcosets H)", "using \\<open>H \\<in> rcosets H\\<close> card_mono[OF \\<open>finite (rcosets H)\\<close>, of \"{H, J}\"]"], ["proof (prove)\nusing this:\n  J \\<noteq> H\n  J \\<in> rcosets H\n  H \\<in> rcosets H\n  {H, J} \\<subseteq> rcosets H \\<Longrightarrow>\n  card {H, J} \\<le> card (rcosets H)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (rcosets H)", "by simp"], ["proof (state)\nthis:\n  2 \\<le> card (rcosets H)\n\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "then"], ["proof (chain)\npicking this:\n  2 \\<le> card (rcosets H)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> card (rcosets H)\n\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "using mult_le_mono[of 2 \"card (rcosets H)\" \"card H\" \"card H\"]"], ["proof (prove)\nusing this:\n  2 \\<le> card (rcosets H)\n  \\<lbrakk>2 \\<le> card (rcosets H); card H \\<le> card H\\<rbrakk>\n  \\<Longrightarrow> 2 * card H \\<le> card (rcosets H) * card H\n\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "unfolding lagrange[OF \\<open>subgroup H G\\<close>]"], ["proof (prove)\nusing this:\n  2 \\<le> card (rcosets H)\n  \\<lbrakk>2 \\<le> card (rcosets H); card H \\<le> card H\\<rbrakk>\n  \\<Longrightarrow> 2 * card H \\<le> order G\n\ngoal (1 subgoal):\n 1. card H \\<le> order G div 2", "by force"], ["proof (state)\nthis:\n  card H \\<le> order G div 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cong_exp_trans[trans]: \n  \"[a ^ b = c] (mod n) \\<Longrightarrow> [a = d] (mod n) \\<Longrightarrow> [d ^ b = c] (mod n)\"\n  \"[c = a ^ b] (mod n) \\<Longrightarrow> [a = d] (mod n) \\<Longrightarrow> [c = d ^ b] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>[a ^ b = c] (mod n); [a = d] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [d ^ b = c] (mod n)) &&&\n    (\\<lbrakk>[c = a ^ b] (mod n); [a = d] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [c = d ^ b] (mod n))", "using cong_pow cong_sym cong_trans"], ["proof (prove)\nusing this:\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b ^ ?n = ?c ^ ?n] (mod ?a)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  \\<lbrakk>[?b = ?c] (mod ?a); [?c = ?d] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b = ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>[a ^ b = c] (mod n); [a = d] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [d ^ b = c] (mod n)) &&&\n    (\\<lbrakk>[c = a ^ b] (mod n); [a = d] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [c = d ^ b] (mod n))", "by blast+"], ["", "lemma cong_exp_mod[simp]: \n  \"[(a mod n) ^ b = c] (mod n) \\<longleftrightarrow> [a ^ b = c] (mod n)\"\n  \"[c = (a mod n) ^ b] (mod n) \\<longleftrightarrow> [c = a ^ b] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a mod n) ^ b = c] (mod n) = [a ^ b = c] (mod n) &&&\n    [c = (a mod n) ^ b] (mod n) = [c = a ^ b] (mod n)", "by (auto simp add: cong_def mod_simps)"], ["", "lemma cong_mult_mod[simp]:\n  \"[(a mod n) * b = c] (mod n) \\<longleftrightarrow> [a * b = c] (mod n)\"\n  \"[a * (b mod n) = c] (mod n) \\<longleftrightarrow> [a * b = c] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a mod n * b = c] (mod n) = [a * b = c] (mod n) &&&\n    [a * (b mod n) = c] (mod n) = [a * b = c] (mod n)", "by (auto simp add: cong_def mod_simps)"], ["", "lemma cong_add_mod[simp]:\n  \"[(a mod n) + b = c] (mod n) \\<longleftrightarrow> [a + b = c] (mod n)\"\n  \"[a + (b mod n) = c] (mod n) \\<longleftrightarrow> [a + b = c] (mod n)\"\n  \"[\\<Sum>i\\<in>A. f i mod n = c] (mod n) \\<longleftrightarrow> [\\<Sum>i\\<in>A. f i = c] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a mod n + b = c] (mod n) = [a + b = c] (mod n) &&&\n    [a + b mod n = c] (mod n) = [a + b = c] (mod n) &&&\n    [\\<Sum>i\\<in>A. f i mod n = c] (mod n) = [sum f A = c] (mod n)", "by (auto simp add: cong_def mod_simps)"], ["", "lemma cong_add_trans[trans]:\n  \"[a = b + x] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = b + y] (mod n)\"\n  \"[a = x + b] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = y + b] (mod n)\"\n  \"[b + x = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [b + y = a] (mod n)\"\n  \"[x + b = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [y + b = a] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>[a = b + x] (mod n); [x = y] (mod n)\\<rbrakk>\n      \\<Longrightarrow> [a = b + y] (mod n)) &&&\n     (\\<lbrakk>[a = x + b] (mod n); [x = y] (mod n)\\<rbrakk>\n      \\<Longrightarrow> [a = y + b] (mod n))) &&&\n    (\\<lbrakk>[b + x = a] (mod n); [x = y] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [b + y = a] (mod n)) &&&\n    (\\<lbrakk>[x + b = a] (mod n); [x = y] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [y + b = a] (mod n))", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>a mod n = (b + x) mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = (b + y) mod n) &&&\n     (\\<lbrakk>a mod n = (x + b) mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = (y + b) mod n)) &&&\n    (\\<lbrakk>(b + x) mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> (b + y) mod n = a mod n) &&&\n    (\\<lbrakk>(x + b) mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> (y + b) mod n = a mod n)", "using mod_simps(1, 2)"], ["proof (prove)\nusing this:\n  (?a mod ?c + ?b) mod ?c = (?a + ?b) mod ?c\n  (?a + ?b mod ?c) mod ?c = (?a + ?b) mod ?c\n\ngoal (1 subgoal):\n 1. ((\\<lbrakk>a mod n = (b + x) mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = (b + y) mod n) &&&\n     (\\<lbrakk>a mod n = (x + b) mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = (y + b) mod n)) &&&\n    (\\<lbrakk>(b + x) mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> (b + y) mod n = a mod n) &&&\n    (\\<lbrakk>(x + b) mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> (y + b) mod n = a mod n)", "by metis+"], ["", "lemma cong_mult_trans[trans]:\n  \"[a = b * x] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = b * y] (mod n)\"\n  \"[a = x * b] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = y * b] (mod n)\"\n  \"[b * x = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [b * y = a] (mod n)\"\n  \"[x * b = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [y * b = a] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>[a = b * x] (mod n); [x = y] (mod n)\\<rbrakk>\n      \\<Longrightarrow> [a = b * y] (mod n)) &&&\n     (\\<lbrakk>[a = x * b] (mod n); [x = y] (mod n)\\<rbrakk>\n      \\<Longrightarrow> [a = y * b] (mod n))) &&&\n    (\\<lbrakk>[b * x = a] (mod n); [x = y] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [b * y = a] (mod n)) &&&\n    (\\<lbrakk>[x * b = a] (mod n); [x = y] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [y * b = a] (mod n))", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>a mod n = b * x mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = b * y mod n) &&&\n     (\\<lbrakk>a mod n = x * b mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = y * b mod n)) &&&\n    (\\<lbrakk>b * x mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> b * y mod n = a mod n) &&&\n    (\\<lbrakk>x * b mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> y * b mod n = a mod n)", "using mod_simps(4, 5)"], ["proof (prove)\nusing this:\n  ?a mod ?c * ?b mod ?c = ?a * ?b mod ?c\n  ?a * (?b mod ?c) mod ?c = ?a * ?b mod ?c\n\ngoal (1 subgoal):\n 1. ((\\<lbrakk>a mod n = b * x mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = b * y mod n) &&&\n     (\\<lbrakk>a mod n = x * b mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = y * b mod n)) &&&\n    (\\<lbrakk>b * x mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> b * y mod n = a mod n) &&&\n    (\\<lbrakk>x * b mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> y * b mod n = a mod n)", "by metis+"], ["", "lemma cong_diff_trans[trans]:\n  \"[a = b - x] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = b - y] (mod n)\" \n  \"[a = x - b] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [a = y - b] (mod n)\" \n  \"[b - x = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [b - y = a] (mod n)\"\n  \"[x - b = a] (mod n) \\<Longrightarrow> [x = y] (mod n) \\<Longrightarrow> [y - b = a] (mod n)\"\n  for a :: \"'a :: {unique_euclidean_semiring, euclidean_ring_cancel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>[a = b - x] (mod n); [x = y] (mod n)\\<rbrakk>\n      \\<Longrightarrow> [a = b - y] (mod n)) &&&\n     (\\<lbrakk>[a = x - b] (mod n); [x = y] (mod n)\\<rbrakk>\n      \\<Longrightarrow> [a = y - b] (mod n))) &&&\n    (\\<lbrakk>[b - x = a] (mod n); [x = y] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [b - y = a] (mod n)) &&&\n    (\\<lbrakk>[x - b = a] (mod n); [x = y] (mod n)\\<rbrakk>\n     \\<Longrightarrow> [y - b = a] (mod n))", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>a mod n = (b - x) mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = (b - y) mod n) &&&\n     (\\<lbrakk>a mod n = (x - b) mod n; x mod n = y mod n\\<rbrakk>\n      \\<Longrightarrow> a mod n = (y - b) mod n)) &&&\n    (\\<lbrakk>(b - x) mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> (b - y) mod n = a mod n) &&&\n    (\\<lbrakk>(x - b) mod n = a mod n; x mod n = y mod n\\<rbrakk>\n     \\<Longrightarrow> (y - b) mod n = a mod n)", "by (metis mod_diff_eq)+"], ["", "lemma eq_imp_eq_mod_int: \"a = b \\<Longrightarrow> [a = b] (mod m)\" for a b :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> [a = b] (mod m)", "by simp"], ["", "lemma eq_imp_eq_mod_nat: \"a = b \\<Longrightarrow> [a = b] (mod m)\" for a b :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> [a = b] (mod m)", "by simp"], ["", "lemma cong_pow_I: \"a = b \\<Longrightarrow> [x^a = x^b](mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> [x ^ a = x ^ b] (mod n)", "by simp"], ["", "lemma gre1I: \"(n = 0 \\<Longrightarrow> False) \\<Longrightarrow> (1 :: nat) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = 0 \\<Longrightarrow> False) \\<Longrightarrow> 1 \\<le> n", "by presburger"], ["", "lemma gre1I_nat: \"(n = 0 \\<Longrightarrow> False) \\<Longrightarrow> (Suc 0 :: nat) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = 0 \\<Longrightarrow> False) \\<Longrightarrow> Suc 0 \\<le> n", "by presburger"], ["", "lemma totient_less_not_prime:\n  assumes \"\\<not> prime n\" \"1 < n\"\n  shows \"totient n < n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n < n - 1", "using totient_imp_prime totient_less assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>totient ?p = ?p - 1; 0 < ?p\\<rbrakk> \\<Longrightarrow> prime ?p\n  1 < ?n \\<Longrightarrow> totient ?n < ?n\n  \\<not> prime n\n  1 < n\n\ngoal (1 subgoal):\n 1. totient n < n - 1", "by (metis One_nat_def Suc_pred le_less_trans less_SucE zero_le_one)"], ["", "lemma power2_diff_nat: \"x \\<ge> y \\<Longrightarrow> (x - y)\\<^sup>2 = x\\<^sup>2 + y\\<^sup>2 - 2 * x * y\" for x y :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow>\n    (x - y)\\<^sup>2 = x\\<^sup>2 + y\\<^sup>2 - 2 * x * y", "by (simp add: algebra_simps power2_eq_square mult_2_right)\n     (meson Nat.diff_diff_right le_add2 le_trans mult_le_mono order_refl)"], ["", "lemma square_inequality: \"1 < n \\<Longrightarrow> (n + n) \\<le> (n * n)\" for n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n + n \\<le> n * n", "by (metis Suc_eq_plus1_left Suc_leI mult_le_mono1 semiring_normalization_rules(4))"], ["", "lemma square_one_cong_one:\n  assumes \"[x = 1](mod n)\"\n  shows \"[x^2 = 1](mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1::'a] (mod n)", "using assms cong_pow"], ["proof (prove)\nusing this:\n  [x = 1::'a] (mod n)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b ^ ?n = ?c ^ ?n] (mod ?a)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1::'a] (mod n)", "by fastforce"], ["", "lemma cong_square_alt_int:\n  \"prime p \\<Longrightarrow> [a * a = 1] (mod p) \\<Longrightarrow> [a = 1] (mod p) \\<or> [a = p - 1] (mod p)\"\n  for a p :: \"'a :: {normalization_semidom, linordered_idom, unique_euclidean_ring}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; [a * a = 1::'a] (mod p)\\<rbrakk>\n    \\<Longrightarrow> [a = 1::'a] (mod p) \\<or> [a = p - (1::'a)] (mod p)", "using dvd_add_triv_right_iff[of p \"a - (p - 1)\"]"], ["proof (prove)\nusing this:\n  (p dvd a - (p - (1::'a)) + p) = (p dvd a - (p - (1::'a)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; [a * a = 1::'a] (mod p)\\<rbrakk>\n    \\<Longrightarrow> [a = 1::'a] (mod p) \\<or> [a = p - (1::'a)] (mod p)", "by (auto simp add: cong_iff_dvd_diff square_diff_one_factored dest!: prime_dvd_multD)"], ["", "lemma cong_square_alt:\n  \"prime p \\<Longrightarrow> [a * a = 1] (mod p) \\<Longrightarrow> [a = 1] (mod p) \\<or> [a = p - 1] (mod p)\"\n  for a p :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; [a * a = 1] (mod p)\\<rbrakk>\n    \\<Longrightarrow> [a = 1] (mod p) \\<or> [a = p - 1] (mod p)", "using cong_square_alt_int[of \"int p\" \"int a\"] prime_nat_int_transfer[of p] prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime (int p); [int a * int a = 1] (mod int p)\\<rbrakk>\n  \\<Longrightarrow> [int a = 1] (mod int p) \\<or>\n                    [int a = int p - 1] (mod int p)\n  prime (int p) = prime p\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; [a * a = 1] (mod p)\\<rbrakk>\n    \\<Longrightarrow> [a = 1] (mod p) \\<or> [a = p - 1] (mod p)", "by (simp flip: cong_int_iff add: of_nat_diff)"], ["", "lemma square_minus_one_cong_one:\n  fixes n x :: nat\n  assumes \"1 < n\" \"[x = n - 1](mod n)\"\n  shows \"[x^2 = 1](mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "have \"[x^2 = (n - 1) * (n - 1)] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = (n - 1) * (n - 1)] (mod n)", "using cong_mult[OF assms(2) assms(2)]"], ["proof (prove)\nusing this:\n  [x * x = (n - 1) * (n - 1)] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = (n - 1) * (n - 1)] (mod n)", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  [x\\<^sup>2 = (n - 1) * (n - 1)] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "also"], ["proof (state)\nthis:\n  [x\\<^sup>2 = (n - 1) * (n - 1)] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "have \"[(n - 1) * (n - 1) = Suc (n * n) - (n + n)] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(n - 1) * (n - 1) = Suc (n * n) - (n + n)] (mod n)", "using power2_diff_nat[of 1 n] \\<open>1 < n\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> n \\<Longrightarrow>\n  (n - 1)\\<^sup>2 = n\\<^sup>2 + 1\\<^sup>2 - 2 * n * 1\n  1 < n\n\ngoal (1 subgoal):\n 1. [(n - 1) * (n - 1) = Suc (n * n) - (n + n)] (mod n)", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  [(n - 1) * (n - 1) = Suc (n * n) - (n + n)] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "also"], ["proof (state)\nthis:\n  [(n - 1) * (n - 1) = Suc (n * n) - (n + n)] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "have \"[Suc (n * n) - (n + n) = Suc (n * n)] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "have \"n * n + 0 * n = n * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * n + 0 * n = n * n", "by linarith"], ["proof (state)\nthis:\n  n * n + 0 * n = n * n\n\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "moreover"], ["proof (state)\nthis:\n  n * n + 0 * n = n * n\n\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "have \"n * n - (n + n) + (n + n) = n * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * n - (n + n) + (n + n) = n * n", "using square_inequality[OF \\<open>1 < n\\<close>] le_add_diff_inverse2"], ["proof (prove)\nusing this:\n  n + n \\<le> n * n\n  ?b \\<le> ?a \\<Longrightarrow> ?a - ?b + ?b = ?a\n\ngoal (1 subgoal):\n 1. n * n - (n + n) + (n + n) = n * n", "by blast"], ["proof (state)\nthis:\n  n * n - (n + n) + (n + n) = n * n\n\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "moreover"], ["proof (state)\nthis:\n  n * n - (n + n) + (n + n) = n * n\n\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "have \"(Suc 0 + 1) * n = n + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc 0 + 1) * n = n + n", "by simp"], ["proof (state)\nthis:\n  (Suc 0 + 1) * n = n + n\n\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "ultimately"], ["proof (chain)\npicking this:\n  n * n + 0 * n = n * n\n  n * n - (n + n) + (n + n) = n * n\n  (Suc 0 + 1) * n = n + n", "show ?thesis"], ["proof (prove)\nusing this:\n  n * n + 0 * n = n * n\n  n * n - (n + n) + (n + n) = n * n\n  (Suc 0 + 1) * n = n + n\n\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "using square_inequality[OF \\<open>1 < n\\<close>]"], ["proof (prove)\nusing this:\n  n * n + 0 * n = n * n\n  n * n - (n + n) + (n + n) = n * n\n  (Suc 0 + 1) * n = n + n\n  n + n \\<le> n * n\n\ngoal (1 subgoal):\n 1. [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)", "by (metis (no_types) Suc_diff_le add_Suc cong_iff_lin_nat)"], ["proof (state)\nthis:\n  [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "also"], ["proof (state)\nthis:\n  [Suc (n * n) - (n + n) = Suc (n * n)] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "have \"[Suc (n * n) = 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Suc (n * n) = 1] (mod n)", "using cong_to_1'_nat"], ["proof (prove)\nusing this:\n  [?a = 1] (mod ?n) =\n  (?a = 0 \\<and> ?n = 1 \\<or> (\\<exists>m. ?a = 1 + m * ?n))\n\ngoal (1 subgoal):\n 1. [Suc (n * n) = 1] (mod n)", "by auto"], ["proof (state)\nthis:\n  [Suc (n * n) = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "finally"], ["proof (chain)\npicking this:\n  [x\\<^sup>2 = 1] (mod n)", "show ?thesis"], ["proof (prove)\nusing this:\n  [x\\<^sup>2 = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod n)", "."], ["proof (state)\nthis:\n  [x\\<^sup>2 = 1] (mod n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_prime_gt_2_int:\n \"2 < p\" if \"odd p\" \"prime p\" for p :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < p", "using prime_ge_2_int[OF \\<open>prime p\\<close>] \\<open>odd p\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> p\n  odd p\n\ngoal (1 subgoal):\n 1. 2 < p", "by (cases \"p = 2\") auto"], ["", "lemma odd_prime_gt_2_nat:\n \"2 < p\" if \"odd p\" \"prime p\" for p :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < p", "using prime_ge_2_nat[OF \\<open>prime p\\<close>] \\<open>odd p\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> p\n  odd p\n\ngoal (1 subgoal):\n 1. 2 < p", "by (cases \"p = 2\") auto"], ["", "lemma gt_one_imp_gt_one_power_if_coprime:\n  \"1 \\<le> x \\<Longrightarrow> 1 < n \\<Longrightarrow> coprime x n \\<Longrightarrow> 1 \\<le> x ^ (n - 1) mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> x; 1 < n; coprime x n\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> x ^ (n - 1) mod n", "by (rule gre1I) (auto simp: coprime_commute dest: coprime_absorb_left)"], ["", "lemma residue_one_dvd: \"a mod n = 1 \\<Longrightarrow> n dvd a - 1\" for a n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod n = 1 \\<Longrightarrow> n dvd a - 1", "by (fastforce intro!: cong_to_1_nat simp: cong_def)"], ["", "lemma coprimeI_power_mod:\n  fixes x r n :: nat\n  assumes \"x ^ r mod n = 1\" \"r \\<noteq> 0\" \"n \\<noteq> 0\"\n  shows \"coprime x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime x n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime x n", "have \"coprime (x ^ r mod n) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (x ^ r mod n) n", "using coprime_1_right \\<open>x ^ r mod n = 1\\<close>"], ["proof (prove)\nusing this:\n  coprime ?a (1::?'a)\n  x ^ r mod n = 1\n\ngoal (1 subgoal):\n 1. coprime (x ^ r mod n) n", "by (simp add: coprime_commute)"], ["proof (state)\nthis:\n  coprime (x ^ r mod n) n\n\ngoal (1 subgoal):\n 1. coprime x n", "thus ?thesis"], ["proof (prove)\nusing this:\n  coprime (x ^ r mod n) n\n\ngoal (1 subgoal):\n 1. coprime x n", "using \\<open>r \\<noteq> 0\\<close> \\<open>n \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  coprime (x ^ r mod n) n\n  r \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime x n", "by simp"], ["proof (state)\nthis:\n  coprime x n\n\ngoal:\nNo subgoals!", "qed"], ["", "(* MOVE - EXTRA *)"], ["", "lemma prime_dvd_choose:\n  assumes \"0 < k\" \"k < p\" \"prime p\" \n  shows \"p dvd (p choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd p choose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd p choose k", "have \"k \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> p", "using \\<open>k < p\\<close>"], ["proof (prove)\nusing this:\n  k < p\n\ngoal (1 subgoal):\n 1. k \\<le> p", "by auto"], ["proof (state)\nthis:\n  k \\<le> p\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "have \"p dvd fact p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd fact p", "using \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. p dvd fact p", "by (simp add: prime_dvd_fact_iff)"], ["proof (state)\nthis:\n  p dvd fact p\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "moreover"], ["proof (state)\nthis:\n  p dvd fact p\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "have \"\\<not> p dvd fact k * fact (p - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd fact k * fact (p - k)", "unfolding prime_dvd_mult_iff[OF \\<open>prime p\\<close>] prime_dvd_fact_iff[OF \\<open>prime p\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (p \\<le> k \\<or> p \\<le> p - k)", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  k < p\n  prime p\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<le> k \\<or> p \\<le> p - k)", "by simp"], ["proof (state)\nthis:\n  \\<not> p dvd fact k * fact (p - k)\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "ultimately"], ["proof (chain)\npicking this:\n  p dvd fact p\n  \\<not> p dvd fact k * fact (p - k)", "show ?thesis"], ["proof (prove)\nusing this:\n  p dvd fact p\n  \\<not> p dvd fact k * fact (p - k)\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "unfolding binomial_fact_lemma[OF \\<open>k \\<le> p\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  p dvd fact k * fact (p - k) * (p choose k)\n  \\<not> p dvd fact k * fact (p - k)\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "using assms prime_dvd_multD"], ["proof (prove)\nusing this:\n  p dvd fact k * fact (p - k) * (p choose k)\n  \\<not> p dvd fact k * fact (p - k)\n  0 < k\n  k < p\n  prime p\n  \\<lbrakk>prime ?p; ?p dvd ?a * ?b\\<rbrakk>\n  \\<Longrightarrow> ?p dvd ?a \\<or> ?p dvd ?b\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "by blast"], ["proof (state)\nthis:\n  p dvd p choose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cong_eq_0_I: \"(\\<forall>i\\<in>A. [f i mod n = 0] (mod n)) \\<Longrightarrow> [\\<Sum>i\\<in>A. f i = 0] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A. [f i mod n = 0::'b] (mod n) \\<Longrightarrow>\n    [sum f A = 0::'b] (mod n)", "using cong_sum"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> ?A \\<Longrightarrow> [?f x = ?g x] (mod ?a)) \\<Longrightarrow>\n  [sum ?f ?A = sum ?g ?A] (mod ?a)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A. [f i mod n = 0::'b] (mod n) \\<Longrightarrow>\n    [sum f A = 0::'b] (mod n)", "by fastforce"], ["", "lemma power_mult_cong:\n  assumes \"[x^n = a](mod m)\" \"[y^n = b](mod m)\"\n  shows \"[(x*y)^n = a*b](mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x * y) ^ n = a * b] (mod m)", "using assms cong_mult[of \"x^n\" a m \"y^n\" b] power_mult_distrib"], ["proof (prove)\nusing this:\n  [x ^ n = a] (mod m)\n  [y ^ n = b] (mod m)\n  \\<lbrakk>[x ^ n = a] (mod m); [y ^ n = b] (mod m)\\<rbrakk>\n  \\<Longrightarrow> [x ^ n * y ^ n = a * b] (mod m)\n  (?a * ?b) ^ ?n = ?a ^ ?n * ?b ^ ?n\n\ngoal (1 subgoal):\n 1. [(x * y) ^ n = a * b] (mod m)", "by metis"], ["", "lemma\n  fixes n :: nat\n  assumes \"n > 1\"\n  shows odd_pow_cong: \"odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\"\n  and even_pow_cong: \"even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)) &&&\n    (even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n))", "proof (induction m)"], ["proof (state)\ngoal (4 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        odd (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = n - 1] (mod n)\n 4. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "case (Suc m)"], ["proof (state)\nthis:\n  odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\n  even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\n\ngoal (4 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        odd (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = n - 1] (mod n)\n 4. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "case 1"], ["proof (state)\nthis:\n  odd (Suc m)\n\ngoal (4 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        odd (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = n - 1] (mod n)\n 4. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "with Suc"], ["proof (chain)\npicking this:\n  odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\n  even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\n  odd (Suc m)", "have IH: \"[(n - 1) ^ m = 1] (mod n)\""], ["proof (prove)\nusing this:\n  odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\n  even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\n  odd (Suc m)\n\ngoal (1 subgoal):\n 1. [(n - 1) ^ m = 1] (mod n)", "by auto"], ["proof (state)\nthis:\n  [(n - 1) ^ m = 1] (mod n)\n\ngoal (4 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        odd (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = n - 1] (mod n)\n 4. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(n - 1) ^ Suc m = n - 1] (mod n)", "using \\<open>1 < n\\<close> cong_mult[OF cong_refl IH]"], ["proof (prove)\nusing this:\n  1 < n\n  [?b * (n - 1) ^ m = ?b * 1] (mod n)\n\ngoal (1 subgoal):\n 1. [(n - 1) ^ Suc m = n - 1] (mod n)", "by simp"], ["proof (state)\nthis:\n  [(n - 1) ^ Suc m = n - 1] (mod n)\n\ngoal (3 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "case (Suc m)"], ["proof (state)\nthis:\n  odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\n  even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\n\ngoal (3 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "case 2"], ["proof (state)\nthis:\n  even (Suc m)\n\ngoal (3 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "with Suc"], ["proof (chain)\npicking this:\n  odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\n  even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\n  even (Suc m)", "have IH: \"[(n - 1) ^ m = n - 1] (mod n)\""], ["proof (prove)\nusing this:\n  odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n)\n  even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n)\n  even (Suc m)\n\ngoal (1 subgoal):\n 1. [(n - 1) ^ m = n - 1] (mod n)", "by auto"], ["proof (state)\nthis:\n  [(n - 1) ^ m = n - 1] (mod n)\n\ngoal (3 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)\n 3. \\<And>m.\n       \\<lbrakk>odd m \\<Longrightarrow> [(n - 1) ^ m = n - 1] (mod n);\n        even m \\<Longrightarrow> [(n - 1) ^ m = 1] (mod n);\n        even (Suc m)\\<rbrakk>\n       \\<Longrightarrow> [(n - 1) ^ Suc m = 1] (mod n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(n - 1) ^ Suc m = 1] (mod n)", "using cong_mult[OF cong_refl IH, of \"(n - 1)\"] and square_minus_one_cong_one[OF \\<open>1 < n\\<close>, of \"n - 1\"]"], ["proof (prove)\nusing this:\n  [(n - 1) * (n - 1) ^ m = (n - 1) * (n - 1)] (mod n)\n  [n - 1 = n - 1] (mod n) \\<Longrightarrow> [(n - 1)\\<^sup>2 = 1] (mod n)\n\ngoal (1 subgoal):\n 1. [(n - 1) ^ Suc m = 1] (mod n)", "by (auto simp: power2_eq_square intro: cong_trans)"], ["proof (state)\nthis:\n  [(n - 1) ^ Suc m = 1] (mod n)\n\ngoal (2 subgoals):\n 1. odd 0 \\<Longrightarrow> [(n - 1) ^ 0 = n - 1] (mod n)\n 2. even 0 \\<Longrightarrow> [(n - 1) ^ 0 = 1] (mod n)", "qed simp_all"], ["", "lemma cong_mult_uneq':\n  fixes a :: \"'a::{unique_euclidean_ring, ring_gcd}\"\n  assumes \"coprime d a\"\n  shows \"[b \\<noteq> c] (mod a) \\<Longrightarrow> [d = e] (mod a) \\<Longrightarrow> [b * d \\<noteq> c * e] (mod a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[b \\<noteq> c] (mod a); [d = e] (mod a)\\<rbrakk>\n    \\<Longrightarrow> [b * d \\<noteq> c * e] (mod a)", "using cong_mult_rcancel[OF assms]"], ["proof (prove)\nusing this:\n  [?a * d = ?b * d] (mod a) = [?a = ?b] (mod a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[b \\<noteq> c] (mod a); [d = e] (mod a)\\<rbrakk>\n    \\<Longrightarrow> [b * d \\<noteq> c * e] (mod a)", "using cong_trans[of \"b*d\" \"c*e\" a \"c*d\"]"], ["proof (prove)\nusing this:\n  [?a * d = ?b * d] (mod a) = [?a = ?b] (mod a)\n  \\<lbrakk>[b * d = c * e] (mod a); [c * e = c * d] (mod a)\\<rbrakk>\n  \\<Longrightarrow> [b * d = c * d] (mod a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[b \\<noteq> c] (mod a); [d = e] (mod a)\\<rbrakk>\n    \\<Longrightarrow> [b * d \\<noteq> c * e] (mod a)", "using cong_scalar_left cong_sym"], ["proof (prove)\nusing this:\n  [?a * d = ?b * d] (mod a) = [?a = ?b] (mod a)\n  \\<lbrakk>[b * d = c * e] (mod a); [c * e = c * d] (mod a)\\<rbrakk>\n  \\<Longrightarrow> [b * d = c * d] (mod a)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?d * ?b = ?d * ?c] (mod ?a)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[b \\<noteq> c] (mod a); [d = e] (mod a)\\<rbrakk>\n    \\<Longrightarrow> [b * d \\<noteq> c * e] (mod a)", "by blast"], ["", "lemma p_coprime_right_nat: \"prime p \\<Longrightarrow> coprime a p = (\\<not> p dvd a)\" for p a :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow> coprime a p = (\\<not> p dvd a)", "by (meson coprime_absorb_left coprime_commute not_prime_unit prime_imp_coprime_nat)"], ["", "lemma squarefree_mult_imp_coprime:\n  assumes \"squarefree (a * b :: 'a :: semiring_gcd)\"\n  shows   \"coprime a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime a b", "proof (rule coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "assume \"l dvd a\" \"l dvd b\""], ["proof (state)\nthis:\n  l dvd a\n  l dvd b\n\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "then"], ["proof (chain)\npicking this:\n  l dvd a\n  l dvd b", "obtain a' b' where \"a = l * a'\" \"b = l * b'\""], ["proof (prove)\nusing this:\n  l dvd a\n  l dvd b\n\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>a = l * a'; b = l * b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: dvdE)"], ["proof (state)\nthis:\n  a = l * a'\n  b = l * b'\n\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "with assms"], ["proof (chain)\npicking this:\n  squarefree (a * b)\n  a = l * a'\n  b = l * b'", "have \"squarefree (l\\<^sup>2 * (a' * b'))\""], ["proof (prove)\nusing this:\n  squarefree (a * b)\n  a = l * a'\n  b = l * b'\n\ngoal (1 subgoal):\n 1. squarefree (l\\<^sup>2 * (a' * b'))", "by (simp add: power2_eq_square mult_ac)"], ["proof (state)\nthis:\n  squarefree (l\\<^sup>2 * (a' * b'))\n\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "thus \"l dvd 1\""], ["proof (prove)\nusing this:\n  squarefree (l\\<^sup>2 * (a' * b'))\n\ngoal (1 subgoal):\n 1. is_unit l", "by (rule squarefreeD) auto"], ["proof (state)\nthis:\n  is_unit l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_divisor_exists_strong:\n  fixes m :: int\n  assumes \"m > 1\" \"\\<not>prime m\"\n  shows   \"\\<exists>n k. m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from assms"], ["proof (chain)\npicking this:\n  1 < m\n  \\<not> prime m", "obtain n k where nk: \"n * k > 1\" \"n \\<ge> 0\" \"m = n * k\" \"n \\<noteq> 1\" \"n \\<noteq> 0\" \"k \\<noteq> 1\""], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. (\\<And>n k.\n        \\<lbrakk>1 < n * k; 0 \\<le> n; m = n * k; n \\<noteq> 1;\n         n \\<noteq> 0; k \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. (\\<And>n k.\n        \\<lbrakk>1 < n * k; 0 \\<le> n; m = n * k; n \\<noteq> 1;\n         n \\<noteq> 0; k \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding prime_int_iff dvd_def"], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> (1 < m \\<and>\n          (\\<forall>ma.\n              0 \\<le> ma \\<and> (\\<exists>k. m = ma * k) \\<longrightarrow>\n              ma = 1 \\<or> ma = m))\n  1 < m\n  \\<not> (1 < m \\<and>\n          (\\<forall>ma.\n              0 \\<le> ma \\<and> (\\<exists>k. m = ma * k) \\<longrightarrow>\n              ma = 1 \\<or> ma = m))\n\ngoal (1 subgoal):\n 1. (\\<And>n k.\n        \\<lbrakk>1 < n * k; 0 \\<le> n; m = n * k; n \\<noteq> 1;\n         n \\<noteq> 0; k \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from nk"], ["proof (chain)\npicking this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1", "have \"n > 1\""], ["proof (prove)\nusing this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < n", "by linarith"], ["proof (state)\nthis:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from nk assms"], ["proof (chain)\npicking this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n  1 < m\n  \\<not> prime m", "have \"n * k > 0\""], ["proof (prove)\nusing this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. 0 < n * k", "by simp"], ["proof (state)\nthis:\n  0 < n * k\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "with \\<open>n \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  0 < n * k", "have \"k > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n  0 < n * k\n\ngoal (1 subgoal):\n 1. 0 < k", "using zero_less_mult_pos"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  0 < n * k\n  \\<lbrakk>(0::?'a) < ?a * ?b; (0::?'a) < ?a\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?b\n\ngoal (1 subgoal):\n 1. 0 < k", "by force"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "with \\<open>k \\<noteq> 1\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> 1\n  0 < k", "have \"k > 1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  0 < k\n\ngoal (1 subgoal):\n 1. 1 < k", "by linarith"], ["proof (state)\nthis:\n  1 < k\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from nk"], ["proof (chain)\npicking this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1", "have \"n > 1\""], ["proof (prove)\nusing this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < n", "by linarith"], ["proof (state)\nthis:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from \\<open>k > 1\\<close> nk"], ["proof (chain)\npicking this:\n  1 < k\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1", "have \"n < m\" \"k < m\""], ["proof (prove)\nusing this:\n  1 < k\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n < m &&& k < m", "by simp_all"], ["proof (state)\nthis:\n  n < m\n  k < m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "with nk \\<open>k > 1\\<close> \\<open>n > 1\\<close>"], ["proof (chain)\npicking this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n  1 < k\n  1 < n\n  n < m\n  k < m", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < n * k\n  0 \\<le> n\n  m = n * k\n  n \\<noteq> 1\n  n \\<noteq> 0\n  k \\<noteq> 1\n  1 < k\n  1 < n\n  n < m\n  k < m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "by blast"], ["proof (state)\nthis:\n  \\<exists>n k.\n     m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_divisor_exists_strong_nat:\n  fixes m :: nat\n  assumes \"1 < m\" \"\\<not>prime m\"\n  shows   \"\\<exists>p k. m = p * k \\<and> 1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "obtain p where p_def: \"prime p\" \"p dvd m\" \"p \\<noteq> m\" \"1 < p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd m; p \\<noteq> m; 1 < p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms prime_prime_factor and prime_gt_1_nat"], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n  prime ?n =\n  (?n \\<noteq> 1 \\<and>\n   (\\<forall>p. prime p \\<and> p dvd ?n \\<longrightarrow> p = ?n))\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd m; p \\<noteq> m; 1 < p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prime p\n  p dvd m\n  p \\<noteq> m\n  1 < p\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "moreover"], ["proof (state)\nthis:\n  prime p\n  p dvd m\n  p \\<noteq> m\n  1 < p\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "define k where \"k = m div p\""], ["proof (state)\nthis:\n  k = m div p\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "with \\<open>p dvd m\\<close>"], ["proof (chain)\npicking this:\n  p dvd m\n  k = m div p", "have \"m = p * k\""], ["proof (prove)\nusing this:\n  p dvd m\n  k = m div p\n\ngoal (1 subgoal):\n 1. m = p * k", "by simp"], ["proof (state)\nthis:\n  m = p * k\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "moreover"], ["proof (state)\nthis:\n  m = p * k\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "have \"p < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p < m", "using \\<open>p \\<noteq> m\\<close> dvd_imp_le[OF \\<open>p dvd m\\<close>] and \\<open>m > 1\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> m\n  0 < m \\<Longrightarrow> p \\<le> m\n  1 < m\n\ngoal (1 subgoal):\n 1. p < m", "by simp"], ["proof (state)\nthis:\n  p < m\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "moreover"], ["proof (state)\nthis:\n  p < m\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "have \"1 < k\" \"k < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < k &&& k < m", "using \\<open>1 < m\\<close> \\<open>1 < p\\<close> and \\<open>p \\<noteq> m\\<close>"], ["proof (prove)\nusing this:\n  1 < m\n  1 < p\n  p \\<noteq> m\n\ngoal (1 subgoal):\n 1. 1 < k &&& k < m", "unfolding \\<open>m = p * k\\<close>"], ["proof (prove)\nusing this:\n  1 < p * k\n  1 < p\n  p \\<noteq> p * k\n\ngoal (1 subgoal):\n 1. 1 < k &&& k < p * k", "by (force intro: Suc_lessI Nat.gr0I)+"], ["proof (state)\nthis:\n  1 < k\n  k < m\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "ultimately"], ["proof (chain)\npicking this:\n  prime p\n  p dvd m\n  p \\<noteq> m\n  1 < p\n  m = p * k\n  p < m\n  1 < k\n  k < m", "show ?thesis"], ["proof (prove)\nusing this:\n  prime p\n  p dvd m\n  p \\<noteq> m\n  1 < p\n  m = p * k\n  p < m\n  1 < k\n  k < m\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "using \\<open>1 < m\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  p dvd m\n  p \\<noteq> m\n  1 < p\n  m = p * k\n  p < m\n  1 < k\n  k < m\n  1 < m\n\ngoal (1 subgoal):\n 1. \\<exists>p k.\n       m = p * k \\<and>\n       1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p", "by blast"], ["proof (state)\nthis:\n  \\<exists>p k.\n     m = p * k \\<and>\n     1 < p \\<and> p < m \\<and> 1 < k \\<and> k < m \\<and> prime p\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO Remove *)"], ["", "lemma prime_factorization_eqI:\n  assumes \"\\<And>p. p \\<in># P \\<Longrightarrow> prime p\" \"prod_mset P = n\"\n  shows   \"prime_factorization n = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization n = P", "using prime_factorization_prod_mset_primes[of P] assms"], ["proof (prove)\nusing this:\n  (\\<And>p. p \\<in># P \\<Longrightarrow> prime p) \\<Longrightarrow>\n  prime_factorization (\\<Prod>\\<^sub># P) = P\n  ?p \\<in># P \\<Longrightarrow> prime ?p\n  \\<Prod>\\<^sub># P = n\n\ngoal (1 subgoal):\n 1. prime_factorization n = P", "by simp"], ["", "lemma prime_factorization_prime_elem:\n  assumes \"prime_elem p\"\n  shows   \"prime_factorization p = {#normalize p#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization p = {#normalize p#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_factorization p = {#normalize p#}", "have \"prime_factorization p = prime_factorization (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization p = prime_factorization (normalize p)", "by (metis normalize_idem prime_factorization_cong)"], ["proof (state)\nthis:\n  prime_factorization p = prime_factorization (normalize p)\n\ngoal (1 subgoal):\n 1. prime_factorization p = {#normalize p#}", "also"], ["proof (state)\nthis:\n  prime_factorization p = prime_factorization (normalize p)\n\ngoal (1 subgoal):\n 1. prime_factorization p = {#normalize p#}", "have \"\\<dots> = {#normalize p#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization (normalize p) = {#normalize p#}", "by (rule prime_factorization_prime) (use assms in auto)"], ["proof (state)\nthis:\n  prime_factorization (normalize p) = {#normalize p#}\n\ngoal (1 subgoal):\n 1. prime_factorization p = {#normalize p#}", "finally"], ["proof (chain)\npicking this:\n  prime_factorization p = {#normalize p#}", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factorization p = {#normalize p#}\n\ngoal (1 subgoal):\n 1. prime_factorization p = {#normalize p#}", "."], ["proof (state)\nthis:\n  prime_factorization p = {#normalize p#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_prime_factorization_eq_Suc_0_iff [simp]:\n  fixes n :: \"'a :: factorial_semiring_multiplicative\"\n  shows \"size (prime_factorization n) = Suc 0 \\<longleftrightarrow> prime_elem n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (size (prime_factorization n) = Suc 0) = prime_elem n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "assume size: \"size (prime_factorization n) = Suc 0\""], ["proof (state)\nthis:\n  size (prime_factorization n) = Suc 0\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "hence [simp]: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  size (prime_factorization n) = Suc 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "from size"], ["proof (chain)\npicking this:\n  size (prime_factorization n) = Suc 0", "obtain p where *: \"prime_factorization n = {#p#}\""], ["proof (prove)\nusing this:\n  size (prime_factorization n) = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        prime_factorization n = {#p#} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: size_mset_SucE)"], ["proof (state)\nthis:\n  prime_factorization n = {#p#}\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "hence p: \"p \\<in> prime_factors n\""], ["proof (prove)\nusing this:\n  prime_factorization n = {#p#}\n\ngoal (1 subgoal):\n 1. p \\<in># prime_factorization n", "by auto"], ["proof (state)\nthis:\n  p \\<in># prime_factorization n\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "have \"prime_elem (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem (normalize p)", "using p"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. prime_elem (normalize p)", "by (auto simp: in_prime_factors_iff)"], ["proof (state)\nthis:\n  prime_elem (normalize p)\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "also"], ["proof (state)\nthis:\n  prime_elem (normalize p)\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "have \"p = prod_mset (prime_factorization n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = \\<Prod>\\<^sub># (prime_factorization n)", "using *"], ["proof (prove)\nusing this:\n  prime_factorization n = {#p#}\n\ngoal (1 subgoal):\n 1. p = \\<Prod>\\<^sub># (prime_factorization n)", "by simp"], ["proof (state)\nthis:\n  p = \\<Prod>\\<^sub># (prime_factorization n)\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "also"], ["proof (state)\nthis:\n  p = \\<Prod>\\<^sub># (prime_factorization n)\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "have \"normalize \\<dots> = normalize n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (\\<Prod>\\<^sub># (prime_factorization n)) = normalize n", "by (rule prod_mset_prime_factorization_weak) auto"], ["proof (state)\nthis:\n  normalize (\\<Prod>\\<^sub># (prime_factorization n)) = normalize n\n\ngoal (2 subgoals):\n 1. size (prime_factorization n) = Suc 0 \\<Longrightarrow> prime_elem n\n 2. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "finally"], ["proof (chain)\npicking this:\n  prime_elem (normalize n)", "show \"prime_elem n\""], ["proof (prove)\nusing this:\n  prime_elem (normalize n)\n\ngoal (1 subgoal):\n 1. prime_elem n", "by simp"], ["proof (state)\nthis:\n  prime_elem n\n\ngoal (1 subgoal):\n 1. prime_elem n \\<Longrightarrow> size (prime_factorization n) = Suc 0", "qed (auto simp: prime_factorization_prime_elem)"], ["", "(* END TODO *)\n\n(* TODO Move *)"], ["", "lemma squarefree_prime_elem [simp, intro]:\n  fixes p :: \"'a :: algebraic_semidom\"\n  assumes \"prime_elem p\"\n  shows   \"squarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree p", "proof (rule squarefreeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "assume \"x\\<^sup>2 dvd p\""], ["proof (state)\nthis:\n  x\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "show \"is_unit x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_unit x \\<Longrightarrow> False", "assume \"\\<not>is_unit x\""], ["proof (state)\nthis:\n  \\<not> is_unit x\n\ngoal (1 subgoal):\n 1. \\<not> is_unit x \\<Longrightarrow> False", "hence \"\\<not>is_unit (x\\<^sup>2)\""], ["proof (prove)\nusing this:\n  \\<not> is_unit x\n\ngoal (1 subgoal):\n 1. \\<not> is_unit (x\\<^sup>2)", "by (simp add: is_unit_power_iff)"], ["proof (state)\nthis:\n  \\<not> is_unit (x\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> is_unit x \\<Longrightarrow> False", "from assms and this and \\<open>x\\<^sup>2 dvd p\\<close>"], ["proof (chain)\npicking this:\n  prime_elem p\n  \\<not> is_unit (x\\<^sup>2)\n  x\\<^sup>2 dvd p", "have \"prime_elem (x\\<^sup>2)\""], ["proof (prove)\nusing this:\n  prime_elem p\n  \\<not> is_unit (x\\<^sup>2)\n  x\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. prime_elem (x\\<^sup>2)", "by (rule prime_elem_mono)"], ["proof (state)\nthis:\n  prime_elem (x\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> is_unit x \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  prime_elem (x\\<^sup>2)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: prime_elem_power_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squarefree_prime [simp, intro]: \"prime p \\<Longrightarrow> squarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<Longrightarrow> squarefree p", "by auto"], ["", "lemma not_squarefree_primepow:\n  assumes \"primepow n\"\n  shows   \"squarefree n \\<longleftrightarrow> prime n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree n = prime n", "using assms"], ["proof (prove)\nusing this:\n  primepow n\n\ngoal (1 subgoal):\n 1. squarefree n = prime n", "by (auto simp: primepow_def squarefree_power_iff prime_power_iff)"], ["", "lemma prime_factorization_normalize [simp]:\n  \"prime_factorization (normalize n) = prime_factorization n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization (normalize n) = prime_factorization n", "by (rule prime_factorization_cong) auto"], ["", "lemma one_prime_factor_iff_primepow:\n  fixes n :: \"'a :: factorial_semiring_multiplicative\"\n  shows \"card (prime_factors n) = Suc 0 \\<longleftrightarrow> primepow (normalize n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card (prime_factors n) = Suc 0) = primepow (normalize n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)\n 2. primepow (normalize n) \\<Longrightarrow> card (prime_factors n) = Suc 0", "assume \"primepow (normalize n)\""], ["proof (state)\nthis:\n  primepow (normalize n)\n\ngoal (2 subgoals):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)\n 2. primepow (normalize n) \\<Longrightarrow> card (prime_factors n) = Suc 0", "then"], ["proof (chain)\npicking this:\n  primepow (normalize n)", "obtain p k where pk: \"prime p\" \"normalize n = p ^ k\" \"k > 0\""], ["proof (prove)\nusing this:\n  primepow (normalize n)\n\ngoal (1 subgoal):\n 1. (\\<And>p k.\n        \\<lbrakk>prime p; normalize n = p ^ k; 0 < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: primepow_def)"], ["proof (state)\nthis:\n  prime p\n  normalize n = p ^ k\n  0 < k\n\ngoal (2 subgoals):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)\n 2. primepow (normalize n) \\<Longrightarrow> card (prime_factors n) = Suc 0", "hence \"card (prime_factors (normalize n)) = Suc 0\""], ["proof (prove)\nusing this:\n  prime p\n  normalize n = p ^ k\n  0 < k\n\ngoal (1 subgoal):\n 1. card (prime_factors (normalize n)) = Suc 0", "by (subst pk) (simp add: prime_factors_power prime_factorization_prime)"], ["proof (state)\nthis:\n  card (prime_factors (normalize n)) = Suc 0\n\ngoal (2 subgoals):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)\n 2. primepow (normalize n) \\<Longrightarrow> card (prime_factors n) = Suc 0", "thus \"card (prime_factors n) = Suc 0\""], ["proof (prove)\nusing this:\n  card (prime_factors (normalize n)) = Suc 0\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0", "by simp"], ["proof (state)\nthis:\n  card (prime_factors n) = Suc 0\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "assume *: \"card (prime_factors n) = Suc 0\""], ["proof (state)\nthis:\n  card (prime_factors n) = Suc 0\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "from *"], ["proof (chain)\npicking this:\n  card (prime_factors n) = Suc 0", "have \"(\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = normalize n\""], ["proof (prove)\nusing this:\n  card (prime_factors n) = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = normalize n", "by (intro prod_prime_factors) auto"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = normalize n\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "also"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = normalize n\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "from *"], ["proof (chain)\npicking this:\n  card (prime_factors n) = Suc 0", "have \"card (prime_factors n) = 1\""], ["proof (prove)\nusing this:\n  card (prime_factors n) = Suc 0\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = 1", "by simp"], ["proof (state)\nthis:\n  card (prime_factors n) = 1\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "then"], ["proof (chain)\npicking this:\n  card (prime_factors n) = 1", "obtain p where p: \"prime_factors n = {p}\""], ["proof (prove)\nusing this:\n  card (prime_factors n) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        prime_factors n = {p} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim card_1_singletonE)"], ["proof (state)\nthis:\n  prime_factors n = {p}\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>p\\<in>{p}. p ^ multiplicity p n) = normalize n", "have \"normalize n = p ^ multiplicity p n\""], ["proof (prove)\nusing this:\n  (\\<Prod>p\\<in>{p}. p ^ multiplicity p n) = normalize n\n\ngoal (1 subgoal):\n 1. normalize n = p ^ multiplicity p n", "by simp"], ["proof (state)\nthis:\n  normalize n = p ^ multiplicity p n\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "moreover"], ["proof (state)\nthis:\n  normalize n = p ^ multiplicity p n\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "from p"], ["proof (chain)\npicking this:\n  prime_factors n = {p}", "have \"prime p\" \"multiplicity p n > 0\""], ["proof (prove)\nusing this:\n  prime_factors n = {p}\n\ngoal (1 subgoal):\n 1. prime p &&& 0 < multiplicity p n", "by (auto simp: prime_factors_multiplicity)"], ["proof (state)\nthis:\n  prime p\n  0 < multiplicity p n\n\ngoal (1 subgoal):\n 1. card (prime_factors n) = Suc 0 \\<Longrightarrow> primepow (normalize n)", "ultimately"], ["proof (chain)\npicking this:\n  normalize n = p ^ multiplicity p n\n  prime p\n  0 < multiplicity p n", "show \"primepow (normalize n)\""], ["proof (prove)\nusing this:\n  normalize n = p ^ multiplicity p n\n  prime p\n  0 < multiplicity p n\n\ngoal (1 subgoal):\n 1. primepow (normalize n)", "unfolding primepow_def"], ["proof (prove)\nusing this:\n  normalize n = p ^ multiplicity p n\n  prime p\n  0 < multiplicity p n\n\ngoal (1 subgoal):\n 1. \\<exists>p k. prime p \\<and> 0 < k \\<and> normalize n = p ^ k", "by blast"], ["proof (state)\nthis:\n  primepow (normalize n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squarefree_imp_prod_prime_factors_eq:\n  fixes x :: \"'a :: factorial_semiring_multiplicative\"\n  assumes \"squarefree x\"\n  shows   \"\\<Prod>(prime_factors x) = normalize x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors x) = normalize x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors x) = normalize x", "from assms"], ["proof (chain)\npicking this:\n  squarefree x", "have [simp]: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  squarefree x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors x) = normalize x", "have \"(\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) = normalize x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) = normalize x", "by (intro prod_prime_factors) auto"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) = normalize x\n\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors x) = normalize x", "also"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) = normalize x\n\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors x) = normalize x", "have \"(\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) = (\\<Prod>p\\<in>prime_factors x. p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) =\n    \\<Prod>(prime_factors x)", "using assms"], ["proof (prove)\nusing this:\n  squarefree x\n\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) =\n    \\<Prod>(prime_factors x)", "by (intro prod.cong refl) (auto simp: squarefree_factorial_semiring')"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors x. p ^ multiplicity p x) =\n  \\<Prod>(prime_factors x)\n\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors x) = normalize x", "finally"], ["proof (chain)\npicking this:\n  \\<Prod>(prime_factors x) = normalize x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Prod>(prime_factors x) = normalize x\n\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors x) = normalize x", "by simp"], ["proof (state)\nthis:\n  \\<Prod>(prime_factors x) = normalize x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* END TODO *)"], ["", "end"]]}