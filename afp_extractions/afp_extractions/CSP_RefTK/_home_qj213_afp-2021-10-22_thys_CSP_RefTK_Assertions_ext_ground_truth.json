{"file_name": "/home/qj213/afp-2021-10-22/thys/CSP_RefTK/Assertions_ext.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CSP_RefTK", "problem_names": ["lemma DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold : \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A = ((\\<sqinter> z \\<in> A \\<rightarrow> DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<sqinter> SKIP)\"", "lemma le_F_T: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T Q\"", "lemma FD_F: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F Q\"", "lemma FD_D: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D Q\"", "lemma DT_D: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D Q\"", "lemma DT_T: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T Q\"", "lemma F_D_FD:\"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q\"", "lemma D_T_DT:\"P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\"", "lemma bot_FD[simp]: \"\\<bottom> \\<sqsubseteq>\\<^sub>F\\<^sub>D Q\"", "lemma STOP_leDT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T STOP\"", "lemma idem_F[simp]: \"P \\<sqsubseteq>\\<^sub>F P\"", "lemma idem_D[simp]: \"P \\<sqsubseteq>\\<^sub>D P\"", "lemma idem_T[simp]: \"P \\<sqsubseteq>\\<^sub>T P\"", "lemma idem_FD[simp]: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D P\"", "lemma idem_DT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T P\"", "lemma trans_F: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>F S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F S\"", "lemma trans_D: \"P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>D S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D S\"", "lemma trans_T: \"P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>T S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T S\"", "lemma trans_FD: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>F\\<^sub>D S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F\\<^sub>D S\"", "lemma trans_DT: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>D\\<^sub>T S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D\\<^sub>T S\"", "lemma le_F_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>F v x)\"", "lemma le_T_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>T v x)\"", "lemma le_D_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>D v x)\"", "lemma le_DT_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>D\\<^sub>T v x)\"", "lemmas le_FD_adm = le_adm[simplified failure_divergence_refine_def[symmetric]]", "lemma mono_det_D[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>D P'; S \\<sqsubseteq>\\<^sub>D S'\\<rbrakk> \\<Longrightarrow> (P \\<box> S) \\<sqsubseteq>\\<^sub>D (P' \\<box> S')\"", "lemma mono_det_T[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>T S'\\<rbrakk> \\<Longrightarrow> (P \\<box> S) \\<sqsubseteq>\\<^sub>T (P' \\<box> S')\"", "lemmas mono_det_FD[simp]= mono_det_FD[simplified failure_divergence_refine_def[symmetric]]\n\n\\<comment>\\<open>Deterministic choice monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>F\\<close>\\<close>", "lemma mono_ndet_F[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>F P'; S \\<sqsubseteq>\\<^sub>F S'\\<rbrakk> \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>F (P' \\<sqinter> S')\"", "lemma mono_ndet_D[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>D P'; S \\<sqsubseteq>\\<^sub>D S'\\<rbrakk> \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D (P' \\<sqinter> S')\"", "lemma mono_ndet_T[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>T S'\\<rbrakk> \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>T (P' \\<sqinter> S')\"", "lemmas mono_ndet_FD[simp]= \n                 mono_ndet_FD[simplified failure_divergence_refine_def[symmetric]]", "lemma mono_ndet_F_left[simp]: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>F Q\"", "lemma mono_ndet_D_left[simp]: \"P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D Q\"", "lemma mono_ndet_T_left[simp]: \"P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>T Q\"", "lemmas \nmono_ndet_FD_left[simp] = \n             mono_ndet_FD_left[simplified failure_divergence_refine_def[symmetric]] and\nmono_ndet_FD_right[simp] = \n             mono_ndet_FD_right[simplified failure_divergence_refine_def[symmetric]]", "lemma mono_ndet_det_FD[simp]: \"(P \\<sqinter> S) \\<sqsubseteq>\\<^sub>F\\<^sub>D (P \\<box> S)\"", "lemma mono_seq_F_right[simp]: \"S \\<sqsubseteq>\\<^sub>F S' \\<Longrightarrow> (P `;` S) \\<sqsubseteq>\\<^sub>F (P `;` S')\"", "lemma mono_seq_D_right[simp]: \"S \\<sqsubseteq>\\<^sub>D S' \\<Longrightarrow> (P `;` S) \\<sqsubseteq>\\<^sub>D (P `;` S')\"", "lemma  mono_seq_T_right[simp]: \"S \\<sqsubseteq>\\<^sub>T S' \\<Longrightarrow> (P `;` S)  \\<sqsubseteq>\\<^sub>T (P `;` S')\"", "lemma mono_seq_DT_left[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T P' \\<Longrightarrow> (P `;` S)  \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' `;` S)\"", "lemmas mono_seq_FD[simp]= mono_seq_FD[simplified failure_divergence_refine_def[symmetric]]", "lemma mono_mprefix_F_process[simp]: \"\\<forall>x. P x \\<sqsubseteq>\\<^sub>F Q x \\<Longrightarrow> Mprefix A P \\<sqsubseteq>\\<^sub>F Mprefix A Q\"", "lemma mono_mprefix_D_process[simp]: \"\\<forall>x. P x \\<sqsubseteq>\\<^sub>D Q x \\<Longrightarrow> Mprefix A P \\<sqsubseteq>\\<^sub>D Mprefix A Q\"", "lemma mono_mprefix_T_process[simp]: \"\\<forall>x. P x \\<sqsubseteq>\\<^sub>T Q x \\<Longrightarrow> Mprefix A P \\<sqsubseteq>\\<^sub>T Mprefix A Q\"", "lemmas \nmono_mprefix_FD_process[simp] = \n                mono_mprefix_FD[simplified failure_divergence_refine_def[symmetric]]", "lemma mono_mprefix_DT_set[simp]: \"A \\<subseteq> B \\<Longrightarrow> Mprefix B P \\<sqsubseteq>\\<^sub>D\\<^sub>T Mprefix A P\"", "lemma mono_hide_F[simp]: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> P \\\\ A \\<sqsubseteq>\\<^sub>F Q \\\\ A\"", "lemma mono_hide_T[simp]: \"P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> P \\\\ A \\<sqsubseteq>\\<^sub>T Q \\\\ A\"", "lemma mono_hide_DT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> P \\\\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\\\ A\"", "lemmas mono_hide_FD[simp] = \n                 mono_hide_FD[simplified failure_divergence_refine_def[symmetric]]\n\n\\<comment>\\<open>Obviously, Hide monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>D\\<close>\\<close>", "lemma mono_sync_DT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T P' \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>D\\<^sub>T Q' \\<Longrightarrow> (P \\<lbrakk> A \\<rbrakk> Q) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' \\<lbrakk> A \\<rbrakk> Q')\"", "lemmas mono_sync_FD[simp] = \n                 mono_sync_FD[simplified failure_divergence_refine_def[symmetric]]\n\n\\<comment>\\<open>synchronization monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>F\\<close>, \\<open>\\<sqsubseteq>\\<^sub>D\\<close> and \\<open>\\<sqsubseteq>\\<^sub>T\\<close>\\<close>", "lemma mono_mndet_F_process[simp]: \"\\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>F Q x \\<Longrightarrow> mndet A P \\<sqsubseteq>\\<^sub>F mndet A Q\"", "lemma mono_mndet_D_process[simp]: \"\\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>D Q x \\<Longrightarrow> mndet A P \\<sqsubseteq>\\<^sub>D mndet A Q\"", "lemma mono_mndet_T_process[simp]: \"\\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>T Q x \\<Longrightarrow> mndet A P \\<sqsubseteq>\\<^sub>T mndet A Q\"", "lemmas \nmono_mndet_FD_process[simp] = \n              mono_mndet_FD[simplified failure_divergence_refine_def[symmetric]]", "lemmas \nmono_mndet_FD_set[simp] = \n              mndet_FD_subset[simplified failure_divergence_refine_def[symmetric]]", "lemmas \nMprefix_refines_Mndet_FD[simp] = \n                          Mprefix_refines_Mndet[simplified failure_divergence_refine_def[symmetric]]", "lemma RUN_unfold : \"RUN A = (\\<box> z \\<in> A \\<rightarrow> RUN A)\"", "lemma CHAOS_unfold : \"CHAOS A = (STOP \\<sqinter> (\\<box> z \\<in> A \\<rightarrow> CHAOS A))\"", "lemma CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<equiv> SKIP \\<sqinter> STOP \\<sqinter> (\\<box> x \\<in> A \\<rightarrow> CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\"", "lemma events_DF: \"events_of (DF A) = A\"", "lemma events_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"events_of (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = A\"", "lemma events_RUN: \"events_of (RUN A) = A\"", "lemma events_CHAOS: \"events_of (CHAOS A) = A\"", "lemma events_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"events_of (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = A\"", "lemma events_div: \"D(P) \\<noteq> {} \\<Longrightarrow>  events_of (P) = UNIV\"", "lemma DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_subset_FD: \"A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P B \\<sqsubseteq>\\<^sub>F\\<^sub>D DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\"", "lemma RUN_subset_DT: \"A \\<subseteq> B \\<Longrightarrow> RUN B \\<sqsubseteq>\\<^sub>D\\<^sub>T RUN A\"", "lemma CHAOS_subset_FD: \"A \\<subseteq> B \\<Longrightarrow> CHAOS B \\<sqsubseteq>\\<^sub>F\\<^sub>D CHAOS A\"", "lemma CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_subset_FD: \"A \\<subseteq> B \\<Longrightarrow> CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P B \\<sqsubseteq>\\<^sub>F\\<^sub>D CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\"", "lemma CHAOS_has_all_tickFree_failures: \n      \"tickFree a \\<Longrightarrow> {x. ev x \\<in> set a} \\<subseteq> A \\<Longrightarrow> (a,b) \\<in> F (CHAOS A)\"", "lemma CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_failures: \n  assumes as:\"(events_of P) \\<subseteq> A\" \n  shows \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F P\"", "lemma DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF_refine_F: \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>F DF A\"", "lemma DF_RUN_refine_F: \"DF A  \\<sqsubseteq>\\<^sub>F RUN A\"", "lemma CHAOS_DF_refine_F: \"CHAOS A  \\<sqsubseteq>\\<^sub>F DF A\"", "lemma div_free_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"D(DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}\"", "lemma div_free_DF: \"D(DF A) = {}\"", "lemma div_free_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}\"", "lemma div_free_CHAOS: \"D(CHAOS A) = {}\"", "lemma div_free_RUN: \"D(RUN A) = {}\"", "lemma traces_CHAOS_sub: \"T(CHAOS A) \\<subseteq> {s. set s \\<subseteq> ev ` A}\"", "lemma traces_RUN_sub: \"{s. set s \\<subseteq> ev ` A} \\<subseteq> T(RUN A)\"", "lemma traces_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_sub: \"T(CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<subseteq> {s. front_tickFree s \\<and> set s \\<subseteq> (ev ` A \\<union> {tick})}\"", "lemma traces_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_sub: \n                      \"{s. front_tickFree s \\<and> set s \\<subseteq> (ev ` A \\<union> {tick})} \\<subseteq> T(DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A::'a process)\""], "translations": [["", "lemma DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold : \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A = ((\\<sqinter> z \\<in> A \\<rightarrow> DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<sqinter> SKIP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A =\n    ((\\<sqinter>z\\<in>A \\<rightarrow> \n         DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n     SKIP)", "by(simp add: DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def, rule trans, rule fix_eq, simp)"], ["", "section \\<open>All refinements definitions\\<close>"], ["", "thm failure_divergence_refine_def[simplified le_ref_def] trace_refine_def failure_refine_def"], ["", "definition divergence_refine :: \"'a process \\<Rightarrow> 'a process \\<Rightarrow> bool\" (infix \"\\<sqsubseteq>\\<^sub>D\" 60)\n  where \"P \\<sqsubseteq>\\<^sub>D Q \\<equiv> D Q \\<subseteq> D P\""], ["", "definition trace_divergence_refine :: \"'a process \\<Rightarrow> 'a process \\<Rightarrow> bool\" (infix \"\\<sqsubseteq>\\<^sub>D\\<^sub>T\" 60)\n  where \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<equiv> P \\<sqsubseteq>\\<^sub>T Q \\<and> P \\<sqsubseteq>\\<^sub>D Q\""], ["", "section \\<open>Relations between refinements\\<close>"], ["", "lemma le_F_T: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T Q", "by (simp add: F_subset_imp_T_subset failure_refine_def trace_refine_def)"], ["", "lemma FD_F: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow>\n    P \\<sqsubseteq>\\<^sub>F Q", "by (simp add: failure_divergence_refine_def failure_refine_def le_ref_def)"], ["", "lemma FD_D: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow>\n    P \\<sqsubseteq>\\<^sub>D Q", "by (simp add: divergence_refine_def failure_divergence_refine_def le_ref_def)"], ["", "lemma DT_D: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n    P \\<sqsubseteq>\\<^sub>D Q", "by (simp add: trace_divergence_refine_def)"], ["", "lemma DT_T: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n    P \\<sqsubseteq>\\<^sub>T Q", "by (simp add: trace_divergence_refine_def)"], ["", "lemma F_D_FD:\"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>F Q; P \\<sqsubseteq>\\<^sub>D Q\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q", "by (simp add: divergence_refine_def failure_divergence_refine_def failure_refine_def le_ref_def)"], ["", "lemma D_T_DT:\"P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D Q; P \\<sqsubseteq>\\<^sub>T Q\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q", "by (simp add: trace_divergence_refine_def)"], ["", "section \\<open>Some obvious refinements\\<close>"], ["", "lemma bot_FD[simp]: \"\\<bottom> \\<sqsubseteq>\\<^sub>F\\<^sub>D Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<sqsubseteq>\\<^sub>F\\<^sub>D Q", "by (simp add: failure_divergence_refine_def)"], ["", "corollary bot_F[simp]: \"\\<bottom> \\<sqsubseteq>\\<^sub>F Q\"\n      and bot_D[simp]: \"\\<bottom> \\<sqsubseteq>\\<^sub>D Q\"\n      and bot_T[simp]: \"\\<bottom> \\<sqsubseteq>\\<^sub>T Q\"\n      and bot_DT[simp]: \"\\<bottom> \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bottom> \\<sqsubseteq>\\<^sub>F Q &&&\n     \\<bottom> \\<sqsubseteq>\\<^sub>D Q) &&&\n    \\<bottom> \\<sqsubseteq>\\<^sub>T Q &&&\n    \\<bottom> \\<sqsubseteq>\\<^sub>D\\<^sub>T Q", "by (simp_all add: FD_F FD_D le_F_T D_T_DT)"], ["", "lemma STOP_leDT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T STOP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T STOP", "by (simp add: D_STOP D_T_DT Nil_elem_T T_STOP divergence_refine_def trace_refine_def)\n\n\\<comment>\\<open>For refinement proofs, we need admissibility and monotony starting with idempotency and \n  transitivity\\<close>"], ["", "section \\<open>Idempotency\\<close>"], ["", "lemma idem_F[simp]: \"P \\<sqsubseteq>\\<^sub>F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>F P", "by (simp add: failure_refine_def)"], ["", "lemma idem_D[simp]: \"P \\<sqsubseteq>\\<^sub>D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D P", "by (simp add: divergence_refine_def)"], ["", "lemma idem_T[simp]: \"P \\<sqsubseteq>\\<^sub>T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>T P", "by (simp add: trace_refine_def)"], ["", "lemma idem_FD[simp]: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>F\\<^sub>D P", "by (simp add: failure_divergence_refine_def)"], ["", "lemma idem_DT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T P", "by (simp add: trace_divergence_refine_def)"], ["", "section \\<open>Transitivity\\<close>"], ["", "lemma trans_F: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>F S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>F Q; Q \\<sqsubseteq>\\<^sub>F S\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F S", "by (meson failure_refine_def order_trans)"], ["", "lemma trans_D: \"P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>D S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D Q; Q \\<sqsubseteq>\\<^sub>D S\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D S", "by (meson divergence_refine_def order_trans)"], ["", "lemma trans_T: \"P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>T S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>T Q; Q \\<sqsubseteq>\\<^sub>T S\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>T S", "by (meson trace_refine_def order_trans)"], ["", "lemma trans_FD: \"P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>F\\<^sub>D S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F\\<^sub>D S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>F\\<^sub>D Q;\n     Q \\<sqsubseteq>\\<^sub>F\\<^sub>D S\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>F\\<^sub>D S", "by (meson failure_divergence_refine_def order_trans)"], ["", "lemma trans_DT: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>D\\<^sub>T S \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D\\<^sub>T S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q;\n     Q \\<sqsubseteq>\\<^sub>D\\<^sub>T S\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq>\\<^sub>D\\<^sub>T S", "by (meson trace_divergence_refine_def order_trans trans_D trans_T)"], ["", "section \\<open>Admissibility\\<close>"], ["", "lemma le_F_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>F v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont u; monofun v\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x. u x \\<sqsubseteq>\\<^sub>F v x)", "proof(auto simp add:cont2contlubE adm_def failure_refine_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "fix Y a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "assume 1:\"cont u\" \n     and 2:\"monofun v\" \n     and 3:\"chain Y\" \n     and 4:\"\\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i))\" \n     and 5:\" (a, b) \\<in> F (v (\\<Squnion>x. Y x))\""], ["proof (state)\nthis:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i))\n  (a, b) \\<in> F (v (\\<Squnion>x. Y x))\n\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "hence \"v (Y i)  \\<sqsubseteq> v (\\<Squnion>i. Y i)\" for i"], ["proof (prove)\nusing this:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i))\n  (a, b) \\<in> F (v (\\<Squnion>x. Y x))\n\ngoal (1 subgoal):\n 1. v (Y i) \\<sqsubseteq> v (\\<Squnion>i. Y i)", "by (simp add: is_ub_thelub monofunE)"], ["proof (state)\nthis:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "hence \"F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y i))\" for i"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y i))", "using 4 le_approx_lemma_F"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n  \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i))\n  ?P \\<sqsubseteq> ?Q \\<Longrightarrow> F ?Q \\<subseteq> F ?P\n\ngoal (1 subgoal):\n 1. F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y i))", "by blast"], ["proof (state)\nthis:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))\n\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "then"], ["proof (chain)\npicking this:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))", "show \"(a, b) \\<in> F (\\<Squnion>i. u (Y i))\""], ["proof (prove)\nusing this:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "using F_LUB[OF ch2ch_cont[OF 1 3]] limproc_is_thelub[OF ch2ch_cont[OF 1 3]] 5"], ["proof (prove)\nusing this:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))\n  F (lim_proc (range (\\<lambda>i. u (Y i)))) =\n  \\<Inter> (F ` range (\\<lambda>i. u (Y i)))\n  (\\<Squnion>i. u (Y i)) = lim_proc (range (\\<lambda>i. u (Y i)))\n  (a, b) \\<in> F (v (\\<Squnion>x. Y x))\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "by force"], ["proof (state)\nthis:\n  (a, b) \\<in> F (\\<Squnion>i. u (Y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_T_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>T v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont u; monofun v\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x. u x \\<sqsubseteq>\\<^sub>T v x)", "proof(auto simp add:cont2contlubE adm_def trace_refine_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i));\n        x \\<in> T (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (\\<Squnion>i. u (Y i))", "fix Y x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i));\n        x \\<in> T (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (\\<Squnion>i. u (Y i))", "assume 1:\"cont u\" \n     and 2:\"monofun v\" \n     and 3:\"chain Y\" \n     and 4:\"\\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i))\" \n     and 5:\" x \\<in> T (v (\\<Squnion>i. Y i))\""], ["proof (state)\nthis:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i))\n  x \\<in> T (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i));\n        x \\<in> T (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (\\<Squnion>i. u (Y i))", "hence \"v (Y i)  \\<sqsubseteq> v (\\<Squnion>i. Y i)\" for i"], ["proof (prove)\nusing this:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i))\n  x \\<in> T (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. v (Y i) \\<sqsubseteq> v (\\<Squnion>i. Y i)", "by (simp add: is_ub_thelub monofunE)"], ["proof (state)\nthis:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i));\n        x \\<in> T (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (\\<Squnion>i. u (Y i))", "hence \"T (v (\\<Squnion>i. Y i)) \\<subseteq> T (u (Y i))\" for i"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. T (v (\\<Squnion>i. Y i)) \\<subseteq> T (u (Y i))", "using 4 le_approx_lemma_T"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n  \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i))\n  ?P \\<sqsubseteq> ?Q \\<Longrightarrow> T ?Q \\<subseteq> T ?P\n\ngoal (1 subgoal):\n 1. T (v (\\<Squnion>i. Y i)) \\<subseteq> T (u (Y i))", "by blast"], ["proof (state)\nthis:\n  T (v (\\<Squnion>i. Y i)) \\<subseteq> T (u (Y ?i))\n\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. T (v (Y i)) \\<subseteq> T (u (Y i));\n        x \\<in> T (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (\\<Squnion>i. u (Y i))", "then"], ["proof (chain)\npicking this:\n  T (v (\\<Squnion>i. Y i)) \\<subseteq> T (u (Y ?i))", "show \"x \\<in> T (\\<Squnion>i. u (Y i))\""], ["proof (prove)\nusing this:\n  T (v (\\<Squnion>i. Y i)) \\<subseteq> T (u (Y ?i))\n\ngoal (1 subgoal):\n 1. x \\<in> T (\\<Squnion>i. u (Y i))", "using T_LUB[OF ch2ch_cont[OF 1 3]] limproc_is_thelub[OF ch2ch_cont[OF 1 3]] 5"], ["proof (prove)\nusing this:\n  T (v (\\<Squnion>i. Y i)) \\<subseteq> T (u (Y ?i))\n  T (lim_proc (range (\\<lambda>i. u (Y i)))) =\n  \\<Inter> (T ` range (\\<lambda>i. u (Y i)))\n  (\\<Squnion>i. u (Y i)) = lim_proc (range (\\<lambda>i. u (Y i)))\n  x \\<in> T (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. x \\<in> T (\\<Squnion>i. u (Y i))", "by force"], ["proof (state)\nthis:\n  x \\<in> T (\\<Squnion>i. u (Y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_D_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>D v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont u; monofun v\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x. u x \\<sqsubseteq>\\<^sub>D v x)", "proof(auto simp add:cont2contlubE adm_def divergence_refine_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))", "fix Y x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))", "assume 1:\"cont u\" \n     and 2:\"monofun v\" \n     and 3:\"chain Y\" \n     and 4:\"\\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i))\" \n     and 5:\" x \\<in> D (v (\\<Squnion>i. Y i))\""], ["proof (state)\nthis:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i))\n  x \\<in> D (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))", "hence \"v (Y i)  \\<sqsubseteq> v (\\<Squnion>i. Y i)\" for i"], ["proof (prove)\nusing this:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i))\n  x \\<in> D (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. v (Y i) \\<sqsubseteq> v (\\<Squnion>i. Y i)", "by (simp add: is_ub_thelub monofunE)"], ["proof (state)\nthis:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))", "hence \"D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y i))\" for i"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y i))", "using 4 le_approx1"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n  \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i))\n  ?P \\<sqsubseteq> ?Q \\<Longrightarrow> D ?Q \\<subseteq> D ?P\n\ngoal (1 subgoal):\n 1. D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y i))", "by blast"], ["proof (state)\nthis:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))\n\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i. D (v (Y i)) \\<subseteq> D (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))", "then"], ["proof (chain)\npicking this:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))", "show \"x \\<in> D (\\<Squnion>i. u (Y i))\""], ["proof (prove)\nusing this:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))\n\ngoal (1 subgoal):\n 1. x \\<in> D (\\<Squnion>i. u (Y i))", "using D_LUB[OF ch2ch_cont[OF 1 3]] limproc_is_thelub[OF ch2ch_cont[OF 1 3]] 5"], ["proof (prove)\nusing this:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))\n  D (lim_proc (range (\\<lambda>i. u (Y i)))) =\n  \\<Inter> (D ` range (\\<lambda>i. u (Y i)))\n  (\\<Squnion>i. u (Y i)) = lim_proc (range (\\<lambda>i. u (Y i)))\n  x \\<in> D (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. x \\<in> D (\\<Squnion>i. u (Y i))", "by force"], ["proof (state)\nthis:\n  x \\<in> D (\\<Squnion>i. u (Y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_DT_adm: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<sqsubseteq>\\<^sub>D\\<^sub>T v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont u; monofun v\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x.\n                              u x \\<sqsubseteq>\\<^sub>D\\<^sub>T v x)", "using adm_conj[OF le_T_adm[of u v] le_D_adm[of u v]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>cont u; monofun v; cont u; monofun v\\<rbrakk>\n  \\<Longrightarrow> adm (\\<lambda>x.\n                            u x \\<sqsubseteq>\\<^sub>T v x \\<and>\n                            u x \\<sqsubseteq>\\<^sub>D v x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cont u; monofun v\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x.\n                              u x \\<sqsubseteq>\\<^sub>D\\<^sub>T v x)", "by (simp add:trace_divergence_refine_def)"], ["", "lemmas le_FD_adm = le_adm[simplified failure_divergence_refine_def[symmetric]]"], ["", "section \\<open>Monotonicity\\<close>"], ["", "lemma mono_det_D[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>D P'; S \\<sqsubseteq>\\<^sub>D S'\\<rbrakk> \\<Longrightarrow> (P \\<box> S) \\<sqsubseteq>\\<^sub>D (P' \\<box> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D P'; S \\<sqsubseteq>\\<^sub>D S'\\<rbrakk>\n    \\<Longrightarrow> (P [+] S) \\<sqsubseteq>\\<^sub>D (P' [+] S')", "by (metis D_det Un_mono divergence_refine_def)"], ["", "lemma mono_det_T[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>T S'\\<rbrakk> \\<Longrightarrow> (P \\<box> S) \\<sqsubseteq>\\<^sub>T (P' \\<box> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>T S'\\<rbrakk>\n    \\<Longrightarrow> (P [+] S) \\<sqsubseteq>\\<^sub>T (P' [+] S')", "by (metis T_det Un_mono trace_refine_def)"], ["", "corollary mono_det_DT[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>D\\<^sub>T S'\\<rbrakk> \\<Longrightarrow> (P \\<box> S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' \\<box> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T P';\n     S \\<sqsubseteq>\\<^sub>D\\<^sub>T S'\\<rbrakk>\n    \\<Longrightarrow> (P [+] S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' [+] S')", "by (simp_all add: trace_divergence_refine_def)"], ["", "lemmas mono_det_FD[simp]= mono_det_FD[simplified failure_divergence_refine_def[symmetric]]\n\n\\<comment>\\<open>Deterministic choice monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>F\\<close>\\<close>"], ["", "lemma mono_ndet_F[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>F P'; S \\<sqsubseteq>\\<^sub>F S'\\<rbrakk> \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>F (P' \\<sqinter> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>F P'; S \\<sqsubseteq>\\<^sub>F S'\\<rbrakk>\n    \\<Longrightarrow> (P |-| S) \\<sqsubseteq>\\<^sub>F (P' |-| S')", "by (metis F_ndet Un_mono failure_refine_def)"], ["", "lemma mono_ndet_D[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>D P'; S \\<sqsubseteq>\\<^sub>D S'\\<rbrakk> \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D (P' \\<sqinter> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D P'; S \\<sqsubseteq>\\<^sub>D S'\\<rbrakk>\n    \\<Longrightarrow> (P |-| S) \\<sqsubseteq>\\<^sub>D (P' |-| S')", "by (metis D_ndet Un_mono divergence_refine_def)"], ["", "lemma mono_ndet_T[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>T S'\\<rbrakk> \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>T (P' \\<sqinter> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>T S'\\<rbrakk>\n    \\<Longrightarrow> (P |-| S) \\<sqsubseteq>\\<^sub>T (P' |-| S')", "by (metis T_ndet Un_mono trace_refine_def)"], ["", "corollary mono_ndet_DT[simp]: \"\\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T P'; S \\<sqsubseteq>\\<^sub>D\\<^sub>T S'\\<rbrakk> \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' \\<sqinter> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T P';\n     S \\<sqsubseteq>\\<^sub>D\\<^sub>T S'\\<rbrakk>\n    \\<Longrightarrow> (P |-| S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' |-| S')", "by (auto simp add: trace_divergence_refine_def)"], ["", "lemmas mono_ndet_FD[simp]= \n                 mono_ndet_FD[simplified failure_divergence_refine_def[symmetric]]"], ["", "lemma mono_ndet_F_left[simp]: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>F Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow>\n    (P |-| S) \\<sqsubseteq>\\<^sub>F Q", "by (simp add: F_ndet failure_refine_def order_trans)"], ["", "lemma mono_ndet_D_left[simp]: \"P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow>\n    (P |-| S) \\<sqsubseteq>\\<^sub>D Q", "by (simp add: D_ndet divergence_refine_def order_trans)"], ["", "lemma mono_ndet_T_left[simp]: \"P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow>\n    (P |-| S) \\<sqsubseteq>\\<^sub>T Q", "by (simp add: T_ndet trace_refine_def order_trans)"], ["", "corollary mono_ndet_DT_left[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> (P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\"\n     and mono_ndet_F_right[simp]: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> (S \\<sqinter> P) \\<sqsubseteq>\\<^sub>F Q\"\n     and mono_ndet_D_right[simp]: \"P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow> (S \\<sqinter> P) \\<sqsubseteq>\\<^sub>D Q\"\n     and mono_ndet_T_right[simp]: \"P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> (S \\<sqinter> P) \\<sqsubseteq>\\<^sub>T Q\"\n     and mono_ndet_DT_right[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> (S \\<sqinter> P) \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n      (P |-| S) \\<sqsubseteq>\\<^sub>D\\<^sub>T Q) &&&\n     (P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow>\n      (S |-| P) \\<sqsubseteq>\\<^sub>F Q)) &&&\n    (P \\<sqsubseteq>\\<^sub>D Q \\<Longrightarrow>\n     (S |-| P) \\<sqsubseteq>\\<^sub>D Q) &&&\n    (P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow>\n     (S |-| P) \\<sqsubseteq>\\<^sub>T Q) &&&\n    (P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n     (S |-| P) \\<sqsubseteq>\\<^sub>D\\<^sub>T Q)", "by (simp_all add: trace_divergence_refine_def Ndet_commute)"], ["", "lemmas \nmono_ndet_FD_left[simp] = \n             mono_ndet_FD_left[simplified failure_divergence_refine_def[symmetric]] and\nmono_ndet_FD_right[simp] = \n             mono_ndet_FD_right[simplified failure_divergence_refine_def[symmetric]]"], ["", "lemma mono_ndet_det_FD[simp]: \"(P \\<sqinter> S) \\<sqsubseteq>\\<^sub>F\\<^sub>D (P \\<box> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P |-| S) \\<sqsubseteq>\\<^sub>F\\<^sub>D (P [+] S)", "by (metis det_id failure_divergence_refine_def mono_det_FD mono_ndet_FD_left \n            mono_ndet_FD_right order_refl)"], ["", "corollary mono_ndet_det_F[simp]: \"(P \\<sqinter> S) \\<sqsubseteq>\\<^sub>F (P \\<box> S)\"\n      and mono_ndet_det_D[simp]: \"(P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D (P \\<box> S)\"\n      and mono_ndet_det_T[simp]: \"(P \\<sqinter> S) \\<sqsubseteq>\\<^sub>T (P \\<box> S)\"\n      and mono_ndet_det_DT[simp]: \"(P \\<sqinter> S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P \\<box> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P |-| S) \\<sqsubseteq>\\<^sub>F (P [+] S) &&&\n     (P |-| S) \\<sqsubseteq>\\<^sub>D (P [+] S)) &&&\n    (P |-| S) \\<sqsubseteq>\\<^sub>T (P [+] S) &&&\n    (P |-| S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P [+] S)", "by (simp_all add: FD_F FD_D le_F_T D_T_DT)"], ["", "lemma mono_seq_F_right[simp]: \"S \\<sqsubseteq>\\<^sub>F S' \\<Longrightarrow> (P `;` S) \\<sqsubseteq>\\<^sub>F (P `;` S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<sqsubseteq>\\<^sub>F S' \\<Longrightarrow>\n    (P `;` S) \\<sqsubseteq>\\<^sub>F (P `;` S')", "apply (auto simp: failure_refine_def F_seq append_single_T_imp_tickFree)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t1 t2.\n       \\<lbrakk>F S' \\<subseteq> F S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> (t2a, b) \\<notin> F S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> (t1 @ t2, insert tick b) \\<in> F P\n 2. \\<And>b t1 t2.\n       \\<lbrakk>F S' \\<subseteq> F S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> (t2a, b) \\<notin> F S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> tickFree t2", "using NF_ND"], ["proof (prove)\nusing this:\n  (?s, ?X) \\<notin> F ?P \\<Longrightarrow> ?s \\<notin> D ?P\n\ngoal (2 subgoals):\n 1. \\<And>b t1 t2.\n       \\<lbrakk>F S' \\<subseteq> F S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> (t2a, b) \\<notin> F S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> (t1 @ t2, insert tick b) \\<in> F P\n 2. \\<And>b t1 t2.\n       \\<lbrakk>F S' \\<subseteq> F S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> (t2a, b) \\<notin> F S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> tickFree t2", "by fastforce+"], ["", "lemma mono_seq_D_right[simp]: \"S \\<sqsubseteq>\\<^sub>D S' \\<Longrightarrow> (P `;` S) \\<sqsubseteq>\\<^sub>D (P `;` S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<sqsubseteq>\\<^sub>D S' \\<Longrightarrow>\n    (P `;` S) \\<sqsubseteq>\\<^sub>D (P `;` S')", "by (auto simp: divergence_refine_def D_seq)"], ["", "lemma  mono_seq_T_right[simp]: \"S \\<sqsubseteq>\\<^sub>T S' \\<Longrightarrow> (P `;` S)  \\<sqsubseteq>\\<^sub>T (P `;` S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<sqsubseteq>\\<^sub>T S' \\<Longrightarrow>\n    (P `;` S) \\<sqsubseteq>\\<^sub>T (P `;` S')", "apply (auto simp: trace_refine_def T_seq append_single_T_imp_tickFree)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t1 @ t2, insert tick X) \\<in> F P\n 2. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> tickFree t2\n 3. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t1 @ t2, insert tick X) \\<in> F P\n 4. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> tickFree t2", "using D_T"], ["proof (prove)\nusing this:\n  ?s \\<in> D ?P \\<Longrightarrow> ?s \\<in> T ?P\n\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t1 @ t2, insert tick X) \\<in> F P\n 2. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> tickFree t2\n 3. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t1 @ t2, insert tick X) \\<in> F P\n 4. \\<And>t1 t2.\n       \\<lbrakk>T S' \\<subseteq> T S;\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> D S);\n        \\<forall>t1a.\n           tickFree t1a \\<longrightarrow>\n           t1a \\<in> D P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow>\n               \\<not> front_tickFree t2a);\n        \\<forall>t1a.\n           t1a @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2a.\n               t1 @ t2 = t1a @ t2a \\<longrightarrow> t2a \\<notin> T S);\n        t1 @ [tick] \\<in> T P; t2 \\<in> D S'\\<rbrakk>\n       \\<Longrightarrow> tickFree t2", "by fastforce+"], ["", "corollary mono_seq_DT_right[simp]: \"S \\<sqsubseteq>\\<^sub>D\\<^sub>T S' \\<Longrightarrow> (P `;` S)  \\<sqsubseteq>\\<^sub>D\\<^sub>T (P `;` S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<sqsubseteq>\\<^sub>D\\<^sub>T S' \\<Longrightarrow>\n    (P `;` S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P `;` S')", "by (simp add: trace_divergence_refine_def)"], ["", "lemma mono_seq_DT_left[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T P' \\<Longrightarrow> (P `;` S)  \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' `;` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T P' \\<Longrightarrow>\n    (P `;` S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' `;` S)", "apply (auto simp: trace_divergence_refine_def divergence_refine_def trace_refine_def D_seq T_seq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>T P' \\<subseteq> T P; D P' \\<subseteq> D P;\n        \\<forall>t1.\n           t1 @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2. x = t1 @ t2 \\<longrightarrow> t2 \\<notin> D S);\n        \\<forall>t1.\n           tickFree t1 \\<longrightarrow>\n           t1 \\<in> D P \\<longrightarrow>\n           (\\<forall>t2.\n               x = t1 @ t2 \\<longrightarrow> \\<not> front_tickFree t2);\n        \\<forall>t1.\n           t1 @ [tick] \\<in> T P \\<longrightarrow>\n           (\\<forall>t2. x = t1 @ t2 \\<longrightarrow> t2 \\<notin> T S);\n        tickFree x; (x, insert tick X) \\<in> F P'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (x, insert tick X) \\<in> F P", "by (metis (no_types, lifting) Nil_elem_T Process.F_T T_F append.right_neutral \n            is_processT5_S3 subset_eq) \n\n\\<comment>\\<open>left sequence monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>F\\<close>, \\<open>\\<sqsubseteq>\\<^sub>D\\<close> and \\<open>\\<sqsubseteq>\\<^sub>T\\<close>\\<close>"], ["", "corollary mono_seq_DT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T P' \\<Longrightarrow> S \\<sqsubseteq>\\<^sub>D\\<^sub>T S' \\<Longrightarrow> (P `;` S)  \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' `;` S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T P';\n     S \\<sqsubseteq>\\<^sub>D\\<^sub>T S'\\<rbrakk>\n    \\<Longrightarrow> (P `;` S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' `;` S')", "using mono_seq_DT_left mono_seq_DT_right trans_DT"], ["proof (prove)\nusing this:\n  ?P \\<sqsubseteq>\\<^sub>D\\<^sub>T ?P' \\<Longrightarrow>\n  (?P `;` ?S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (?P' `;` ?S)\n  ?S \\<sqsubseteq>\\<^sub>D\\<^sub>T ?S' \\<Longrightarrow>\n  (?P `;` ?S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (?P `;` ?S')\n  \\<lbrakk>?P \\<sqsubseteq>\\<^sub>D\\<^sub>T ?Q;\n   ?Q \\<sqsubseteq>\\<^sub>D\\<^sub>T ?S\\<rbrakk>\n  \\<Longrightarrow> ?P \\<sqsubseteq>\\<^sub>D\\<^sub>T ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T P';\n     S \\<sqsubseteq>\\<^sub>D\\<^sub>T S'\\<rbrakk>\n    \\<Longrightarrow> (P `;` S) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' `;` S')", "by blast"], ["", "lemmas mono_seq_FD[simp]= mono_seq_FD[simplified failure_divergence_refine_def[symmetric]]"], ["", "lemma mono_mprefix_F_process[simp]: \"\\<forall>x. P x \\<sqsubseteq>\\<^sub>F Q x \\<Longrightarrow> Mprefix A P \\<sqsubseteq>\\<^sub>F Mprefix A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. P x \\<sqsubseteq>\\<^sub>F Q x \\<Longrightarrow>\n    Mprefix A P \\<sqsubseteq>\\<^sub>F Mprefix A Q", "by (auto simp: failure_refine_def F_Mprefix)"], ["", "lemma mono_mprefix_D_process[simp]: \"\\<forall>x. P x \\<sqsubseteq>\\<^sub>D Q x \\<Longrightarrow> Mprefix A P \\<sqsubseteq>\\<^sub>D Mprefix A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. P x \\<sqsubseteq>\\<^sub>D Q x \\<Longrightarrow>\n    Mprefix A P \\<sqsubseteq>\\<^sub>D Mprefix A Q", "by (auto simp: divergence_refine_def D_Mprefix)"], ["", "lemma mono_mprefix_T_process[simp]: \"\\<forall>x. P x \\<sqsubseteq>\\<^sub>T Q x \\<Longrightarrow> Mprefix A P \\<sqsubseteq>\\<^sub>T Mprefix A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. P x \\<sqsubseteq>\\<^sub>T Q x \\<Longrightarrow>\n    Mprefix A P \\<sqsubseteq>\\<^sub>T Mprefix A Q", "by (auto simp: trace_refine_def T_Mprefix)"], ["", "corollary mono_mprefix_DT_process[simp]: \"\\<forall>x. P x \\<sqsubseteq>\\<^sub>D\\<^sub>T Q x \\<Longrightarrow> Mprefix A P \\<sqsubseteq>\\<^sub>D\\<^sub>T Mprefix A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. P x \\<sqsubseteq>\\<^sub>D\\<^sub>T Q x \\<Longrightarrow>\n    Mprefix A P \\<sqsubseteq>\\<^sub>D\\<^sub>T Mprefix A Q", "by (simp add: trace_divergence_refine_def)"], ["", "lemmas \nmono_mprefix_FD_process[simp] = \n                mono_mprefix_FD[simplified failure_divergence_refine_def[symmetric]]"], ["", "lemma mono_mprefix_DT_set[simp]: \"A \\<subseteq> B \\<Longrightarrow> Mprefix B P \\<sqsubseteq>\\<^sub>D\\<^sub>T Mprefix A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    Mprefix B P \\<sqsubseteq>\\<^sub>D\\<^sub>T Mprefix A P", "by (auto simp add:T_Mprefix D_Mprefix trace_divergence_refine_def \n                    trace_refine_def divergence_refine_def)"], ["", "corollary mono_mprefix_D_set[simp]: \"A \\<subseteq> B \\<Longrightarrow> Mprefix B P \\<sqsubseteq>\\<^sub>D Mprefix A P\"\n      and mono_mprefix_T_set[simp]: \"A \\<subseteq> B \\<Longrightarrow> Mprefix B P \\<sqsubseteq>\\<^sub>T Mprefix A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<subseteq> B \\<Longrightarrow>\n     Mprefix B P \\<sqsubseteq>\\<^sub>D Mprefix A P) &&&\n    (A \\<subseteq> B \\<Longrightarrow>\n     Mprefix B P \\<sqsubseteq>\\<^sub>T Mprefix A P)", "by (simp_all add: DT_D DT_T)\n\n\\<comment>\\<open>Mprefix set monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>F\\<close> and \\<open>\\<sqsubseteq>\\<^sub>F\\<^sub>D\\<close> where it holds for deterministic choice\\<close>"], ["", "lemma mono_hide_F[simp]: \"P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow> P \\\\ A \\<sqsubseteq>\\<^sub>F Q \\\\ A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>F Q \\<Longrightarrow>\n    P \\ A \\<sqsubseteq>\\<^sub>F Q \\ A", "apply(cases \"A={}\", simp_all add: hide_set_empty failure_refine_def F_hiding, intro conjI, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F Q \\<subseteq> F P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {(s, X).\n                       \\<exists>t u.\n                          front_tickFree u \\<and>\n                          tickFree t \\<and>\n                          s = trace_hide t (ev ` A) @ u \\<and>\n                          (t \\<in> D Q \\<or>\n                           (\\<exists>f.\n                               strict_mono f \\<and>\n                               (\\<forall>i. f i \\<in> T Q) \\<and>\n                               (\\<forall>i.\n                                   trace_hide (f i) (ev ` A) =\n                                   trace_hide (f 0) (ev ` A)) \\<and>\n                               t \\<in> range f))}\n                      \\<subseteq> {(s, X).\n                                   \\<exists>t.\ns = trace_hide t (ev ` A) \\<and> (t, X \\<union> ev ` A) \\<in> F P} \\<union>\n                                  {(s, X).\n                                   \\<exists>t u.\nfront_tickFree u \\<and>\ntickFree t \\<and>\ns = trace_hide t (ev ` A) @ u \\<and>\n(t \\<in> D P \\<or>\n (\\<exists>f.\n     strict_mono f \\<and>\n     (\\<forall>i. f i \\<in> T P) \\<and>\n     (\\<forall>i.\n         trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n     t \\<in> range f))}", "proof(subst (2) Un_commute, rule subsetI, rule UnCI, auto, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 b t u)"], ["proof (state)\nthis:\n  F Q \\<subseteq> F P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  x_ \\<in> A\n  t \\<in> D Q\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  F Q \\<subseteq> F P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  x_ \\<in> A\n  t \\<in> D Q", "obtain a where a:\"a \\<in> A\""], ["proof (prove)\nusing this:\n  F Q \\<subseteq> F P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  x_ \\<in> A\n  t \\<in> D Q\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "define f where A:\"f = rec_nat t (\\<lambda>i t. t @ [ev a])\""], ["proof (state)\nthis:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "hence AA:\"f (Suc i) = (f i) @ [ev a]\" for i"], ["proof (prove)\nusing this:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])\n\ngoal (1 subgoal):\n 1. f (Suc i) = f i @ [ev a]", "by simp"], ["proof (state)\nthis:\n  f (Suc ?i) = f ?i @ [ev a]\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "hence B:\"strict_mono f\""], ["proof (prove)\nusing this:\n  f (Suc ?i) = f ?i @ [ev a]\n\ngoal (1 subgoal):\n 1. strict_mono f", "by (simp add:strict_mono_def lift_Suc_mono_less_iff)"], ["proof (state)\nthis:\n  strict_mono f\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "from A"], ["proof (chain)\npicking this:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])", "have C:\"t \\<in> range f\""], ["proof (prove)\nusing this:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])\n\ngoal (1 subgoal):\n 1. t \\<in> range f", "by (metis (mono_tags, lifting) old.nat.simps(6) range_eqI)"], ["proof (state)\nthis:\n  t \\<in> range f\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  t \\<in> range f\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"f i \\<in> D Q \\<and> tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = (trace_hide t (ev ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<in> D Q \\<and>\n    tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)", "proof(induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. f 0 \\<in> D Q \\<and>\n    tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)\n 2. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. f 0 \\<in> D Q \\<and>\n    tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)\n 2. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 \\<in> D Q \\<and>\n    tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)", "by (simp add: 1(4) 1(7) A)"], ["proof (state)\nthis:\n  f 0 \\<in> D Q \\<and>\n  tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "case (Suc i)"], ["proof (state)\nthis:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "then"], ["proof (chain)\npicking this:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)", "show ?case"], ["proof (prove)\nusing this:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> D Q \\<and>\n    tickFree (f (Suc i)) \\<and>\n    trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "apply (simp add:AA a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<in> D Q \\<and>\n    tickFree (f i) \\<and>\n    trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n    f i @ [ev a] \\<in> D Q", "using is_processT7[rule_format, of \"f i\" Q \"[ev a]\"] front_tickFree_single"], ["proof (prove)\nusing this:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> front_tickFree [ev a] \\<Longrightarrow>\n  f i @ [ev a] \\<in> D Q\n  front_tickFree [?a]\n\ngoal (1 subgoal):\n 1. f i \\<in> D Q \\<and>\n    tickFree (f i) \\<and>\n    trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n    f i @ [ev a] \\<in> D Q", "by blast"], ["proof (state)\nthis:\n  f (Suc i) \\<in> D Q \\<and>\n  tickFree (f (Suc i)) \\<and>\n  trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  f ?i2 \\<in> D Q \\<and>\n  tickFree (f ?i2) \\<and>\n  trace_hide (f ?i2) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "with B C"], ["proof (chain)\npicking this:\n  strict_mono f\n  t \\<in> range f\n  f ?i2 \\<in> D Q \\<and>\n  tickFree (f ?i2) \\<and>\n  trace_hide (f ?i2) (ev ` A) = trace_hide t (ev ` A)", "have \"isInfHiddenRun f P A \\<and> t \\<in> range f\""], ["proof (prove)\nusing this:\n  strict_mono f\n  t \\<in> range f\n  f ?i2 \\<in> D Q \\<and>\n  tickFree (f ?i2) \\<and>\n  trace_hide (f ?i2) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. isInfHiddenRun f P A \\<and> t \\<in> range f", "by (metis 1(1) D_T F_subset_imp_T_subset subsetD)"], ["proof (state)\nthis:\n  isInfHiddenRun f P A \\<and> t \\<in> range f\n\ngoal (2 subgoals):\n 1. \\<And>b t u x.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        x \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "with 1"], ["proof (chain)\npicking this:\n  F Q \\<subseteq> F P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  x_ \\<in> A\n  t \\<in> D Q\n  isInfHiddenRun f P A \\<and> t \\<in> range f", "show ?case"], ["proof (prove)\nusing this:\n  F Q \\<subseteq> F P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  x_ \\<in> A\n  t \\<in> D Q\n  isInfHiddenRun f P A \\<and> t \\<in> range f\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "case (2 b u f x)"], ["proof (state)\nthis:\n  F Q \\<subseteq> F P\n  \\<forall>t.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) \\<longrightarrow>\n     (t, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree (x xa_)\n  \\<forall>t ua.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) @ ua \\<longrightarrow>\n     tickFree t \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     t \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         t \\<notin> range f)\n  f \\<in> A\n  strict_mono x\n  \\<forall>i. x i \\<in> T Q\n  \\<forall>i. trace_hide (x i) (ev ` A) = trace_hide (x 0) (ev ` A)\n\ngoal (1 subgoal):\n 1. \\<And>b u x f xa.\n       \\<lbrakk>F Q \\<subseteq> F P;\n        \\<forall>t.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, b \\<union> ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xa);\n        \\<forall>t ua.\n           trace_hide (f xa) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        x \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  F Q \\<subseteq> F P\n  \\<forall>t.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) \\<longrightarrow>\n     (t, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree (x xa_)\n  \\<forall>t ua.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) @ ua \\<longrightarrow>\n     tickFree t \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     t \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         t \\<notin> range f)\n  f \\<in> A\n  strict_mono x\n  \\<forall>i. x i \\<in> T Q\n  \\<forall>i. trace_hide (x i) (ev ` A) = trace_hide (x 0) (ev ` A)", "show ?case"], ["proof (prove)\nusing this:\n  F Q \\<subseteq> F P\n  \\<forall>t.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) \\<longrightarrow>\n     (t, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree (x xa_)\n  \\<forall>t ua.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) @ ua \\<longrightarrow>\n     tickFree t \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     t \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         t \\<notin> range f)\n  f \\<in> A\n  strict_mono x\n  \\<forall>i. x i \\<in> T Q\n  \\<forall>i. trace_hide (x i) (ev ` A) = trace_hide (x 0) (ev ` A)\n\ngoal (1 subgoal):\n 1. False", "using F_subset_imp_T_subset"], ["proof (prove)\nusing this:\n  F Q \\<subseteq> F P\n  \\<forall>t.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) \\<longrightarrow>\n     (t, b \\<union> ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree (x xa_)\n  \\<forall>t ua.\n     trace_hide (x xa_) (ev ` A) @ u =\n     trace_hide t (ev ` A) @ ua \\<longrightarrow>\n     tickFree t \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     t \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         t \\<notin> range f)\n  f \\<in> A\n  strict_mono x\n  \\<forall>i. x i \\<in> T Q\n  \\<forall>i. trace_hide (x i) (ev ` A) = trace_hide (x 0) (ev ` A)\n  F ?P \\<subseteq> F ?Q \\<Longrightarrow> T ?P \\<subseteq> T ?Q\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_hide_T[simp]: \"P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow> P \\\\ A \\<sqsubseteq>\\<^sub>T Q \\\\ A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>T Q \\<Longrightarrow>\n    P \\ A \\<sqsubseteq>\\<^sub>T Q \\ A", "apply(cases \"A={}\", simp add: hide_set_empty, simp add:trace_refine_def T_hiding, intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F Q}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}\n 2. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {s. \\<exists>t u.\n                             front_tickFree u \\<and>\n                             tickFree t \\<and>\n                             s = trace_hide t (ev ` A) @ u \\<and>\n                             (t \\<in> D Q \\<or>\n                              (\\<exists>f.\n                                  strict_mono f \\<and>\n                                  (\\<forall>i. f i \\<in> T Q) \\<and>\n                                  (\\<forall>i.\ntrace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n                                  t \\<in> range f))}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}", "proof(goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F Q}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}\n 2. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {s. \\<exists>t u.\n                             front_tickFree u \\<and>\n                             tickFree t \\<and>\n                             s = trace_hide t (ev ` A) @ u \\<and>\n                             (t \\<in> D Q \\<or>\n                              (\\<exists>f.\n                                  strict_mono f \\<and>\n                                  (\\<forall>i. f i \\<in> T Q) \\<and>\n                                  (\\<forall>i.\ntrace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n                                  t \\<in> range f))}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}", "case 1"], ["proof (state)\nthis:\n  T Q \\<subseteq> T P\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F Q}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}\n 2. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {s. \\<exists>t u.\n                             front_tickFree u \\<and>\n                             tickFree t \\<and>\n                             s = trace_hide t (ev ` A) @ u \\<and>\n                             (t \\<in> D Q \\<or>\n                              (\\<exists>f.\n                                  strict_mono f \\<and>\n                                  (\\<forall>i. f i \\<in> T Q) \\<and>\n                                  (\\<forall>i.\ntrace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n                                  t \\<in> range f))}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}", "then"], ["proof (chain)\npicking this:\n  T Q \\<subseteq> T P\n  A \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  T Q \\<subseteq> T P\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F Q}\n    \\<subseteq> {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F P} \\<union>\n                {s. \\<exists>t u.\n                       front_tickFree u \\<and>\n                       tickFree t \\<and>\n                       s = trace_hide t (ev ` A) @ u \\<and>\n                       (t \\<in> D P \\<or>\n                        (\\<exists>f.\n                            strict_mono f \\<and>\n                            (\\<forall>i. f i \\<in> T P) \\<and>\n                            (\\<forall>i.\n                                trace_hide (f i) (ev ` A) =\n                                trace_hide (f 0) (ev ` A)) \\<and>\n                            t \\<in> range f))}", "proof(subst Un_commute, rule_tac subsetI, rule_tac UnCI, auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t xa.\n       \\<lbrakk>\\<forall>ta.\n                   trace_hide t (ev ` A) =\n                   trace_hide ta (ev ` A) \\<longrightarrow>\n                   (ta, ev ` A) \\<notin> F P;\n        T Q \\<subseteq> T P; (t, ev ` A) \\<in> F Q;\n        \\<forall>ta u.\n           trace_hide t (ev ` A) =\n           trace_hide ta (ev ` A) @ u \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree u \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "case 11:(1 t a)"], ["proof (state)\nthis:\n  \\<forall>ta.\n     trace_hide t (ev ` A) = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, ev ` A) \\<notin> F P\n  T Q \\<subseteq> T P\n  (t, ev ` A) \\<in> F Q\n  \\<forall>ta u.\n     trace_hide t (ev ` A) = trace_hide ta (ev ` A) @ u \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree u \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>t xa.\n       \\<lbrakk>\\<forall>ta.\n                   trace_hide t (ev ` A) =\n                   trace_hide ta (ev ` A) \\<longrightarrow>\n                   (ta, ev ` A) \\<notin> F P;\n        T Q \\<subseteq> T P; (t, ev ` A) \\<in> F Q;\n        \\<forall>ta u.\n           trace_hide t (ev ` A) =\n           trace_hide ta (ev ` A) @ u \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree u \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "hence tt:\"t \\<in> T P\""], ["proof (prove)\nusing this:\n  \\<forall>ta.\n     trace_hide t (ev ` A) = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, ev ` A) \\<notin> F P\n  T Q \\<subseteq> T P\n  (t, ev ` A) \\<in> F Q\n  \\<forall>ta u.\n     trace_hide t (ev ` A) = trace_hide ta (ev ` A) @ u \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree u \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. t \\<in> T P", "by (meson Process.F_T subset_eq)"], ["proof (state)\nthis:\n  t \\<in> T P\n\ngoal (1 subgoal):\n 1. \\<And>t xa.\n       \\<lbrakk>\\<forall>ta.\n                   trace_hide t (ev ` A) =\n                   trace_hide ta (ev ` A) \\<longrightarrow>\n                   (ta, ev ` A) \\<notin> F P;\n        T Q \\<subseteq> T P; (t, ev ` A) \\<in> F Q;\n        \\<forall>ta u.\n           trace_hide t (ev ` A) =\n           trace_hide ta (ev ` A) @ u \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree u \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "with 11(1) inf_hidden[of A t P]"], ["proof (chain)\npicking this:\n  \\<forall>ta.\n     trace_hide t (ev ` A) = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, ev ` A) \\<notin> F P\n  \\<lbrakk>\\<forall>ta.\n              trace_hide ta (ev ` A) =\n              trace_hide t (ev ` A) \\<longrightarrow>\n              (ta, ev ` A) \\<notin> F P;\n   t \\<in> T P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f. isInfHiddenRun f P A \\<and> t \\<in> range f\n  t \\<in> T P", "obtain f where \"isInfHiddenRun f P A \\<and> t \\<in> range f\""], ["proof (prove)\nusing this:\n  \\<forall>ta.\n     trace_hide t (ev ` A) = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, ev ` A) \\<notin> F P\n  \\<lbrakk>\\<forall>ta.\n              trace_hide ta (ev ` A) =\n              trace_hide t (ev ` A) \\<longrightarrow>\n              (ta, ev ` A) \\<notin> F P;\n   t \\<in> T P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f. isInfHiddenRun f P A \\<and> t \\<in> range f\n  t \\<in> T P\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        isInfHiddenRun f P A \\<and> t \\<in> range f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isInfHiddenRun f P A \\<and> t \\<in> range f\n\ngoal (1 subgoal):\n 1. \\<And>t xa.\n       \\<lbrakk>\\<forall>ta.\n                   trace_hide t (ev ` A) =\n                   trace_hide ta (ev ` A) \\<longrightarrow>\n                   (ta, ev ` A) \\<notin> F P;\n        T Q \\<subseteq> T P; (t, ev ` A) \\<in> F Q;\n        \\<forall>ta u.\n           trace_hide t (ev ` A) =\n           trace_hide ta (ev ` A) @ u \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree u \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "with 11(4)[rule_format, of t \"[]\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>trace_hide t (ev ` A) = trace_hide t (ev ` A) @ []; tickFree t;\n   front_tickFree []\\<rbrakk>\n  \\<Longrightarrow> t \\<notin> D P \\<and>\n                    (\\<forall>f.\n                        strict_mono f \\<longrightarrow>\n                        (\\<exists>i. f i \\<notin> T P) \\<or>\n                        (\\<exists>i.\n                            trace_hide (f i) (ev ` A) \\<noteq>\n                            trace_hide (f 0) (ev ` A)) \\<or>\n                        t \\<notin> range f)\n  isInfHiddenRun f P A \\<and> t \\<in> range f", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace_hide t (ev ` A) = trace_hide t (ev ` A) @ []; tickFree t;\n   front_tickFree []\\<rbrakk>\n  \\<Longrightarrow> t \\<notin> D P \\<and>\n                    (\\<forall>f.\n                        strict_mono f \\<longrightarrow>\n                        (\\<exists>i. f i \\<notin> T P) \\<or>\n                        (\\<exists>i.\n                            trace_hide (f i) (ev ` A) \\<noteq>\n                            trace_hide (f 0) (ev ` A)) \\<or>\n                        t \\<notin> range f)\n  isInfHiddenRun f P A \\<and> t \\<in> range f\n\ngoal (1 subgoal):\n 1. False", "by (metis 11(1) tt append_Nil2 front_tickFree_Nil is_processT2_TR \n                nonTickFree_n_frontTickFree tick_T_F)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F Q}\n  \\<subseteq> {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F P} \\<union>\n              {s. \\<exists>t u.\n                     front_tickFree u \\<and>\n                     tickFree t \\<and>\n                     s = trace_hide t (ev ` A) @ u \\<and>\n                     (t \\<in> D P \\<or>\n                      (\\<exists>f.\n                          strict_mono f \\<and>\n                          (\\<forall>i. f i \\<in> T P) \\<and>\n                          (\\<forall>i.\n                              trace_hide (f i) (ev ` A) =\n                              trace_hide (f 0) (ev ` A)) \\<and>\n                          t \\<in> range f))}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {s. \\<exists>t u.\n                             front_tickFree u \\<and>\n                             tickFree t \\<and>\n                             s = trace_hide t (ev ` A) @ u \\<and>\n                             (t \\<in> D Q \\<or>\n                              (\\<exists>f.\n                                  strict_mono f \\<and>\n                                  (\\<forall>i. f i \\<in> T Q) \\<and>\n                                  (\\<forall>i.\ntrace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n                                  t \\<in> range f))}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {s. \\<exists>t u.\n                             front_tickFree u \\<and>\n                             tickFree t \\<and>\n                             s = trace_hide t (ev ` A) @ u \\<and>\n                             (t \\<in> D Q \\<or>\n                              (\\<exists>f.\n                                  strict_mono f \\<and>\n                                  (\\<forall>i. f i \\<in> T Q) \\<and>\n                                  (\\<forall>i.\ntrace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n                                  t \\<in> range f))}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}", "case 2"], ["proof (state)\nthis:\n  T Q \\<subseteq> T P\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T Q \\<subseteq> T P; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {s. \\<exists>t u.\n                             front_tickFree u \\<and>\n                             tickFree t \\<and>\n                             s = trace_hide t (ev ` A) @ u \\<and>\n                             (t \\<in> D Q \\<or>\n                              (\\<exists>f.\n                                  strict_mono f \\<and>\n                                  (\\<forall>i. f i \\<in> T Q) \\<and>\n                                  (\\<forall>i.\ntrace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n                                  t \\<in> range f))}\n                      \\<subseteq> {trace_hide t (ev ` A) |t.\n                                   (t, ev ` A) \\<in> F P} \\<union>\n                                  {s. \\<exists>t u.\n   front_tickFree u \\<and>\n   tickFree t \\<and>\n   s = trace_hide t (ev ` A) @ u \\<and>\n   (t \\<in> D P \\<or>\n    (\\<exists>f.\n        strict_mono f \\<and>\n        (\\<forall>i. f i \\<in> T P) \\<and>\n        (\\<forall>i.\n            trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)) \\<and>\n        t \\<in> range f))}", "then"], ["proof (chain)\npicking this:\n  T Q \\<subseteq> T P\n  A \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  T Q \\<subseteq> T P\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {s. \\<exists>t u.\n           front_tickFree u \\<and>\n           tickFree t \\<and>\n           s = trace_hide t (ev ` A) @ u \\<and>\n           (t \\<in> D Q \\<or>\n            (\\<exists>f.\n                strict_mono f \\<and>\n                (\\<forall>i. f i \\<in> T Q) \\<and>\n                (\\<forall>i.\n                    trace_hide (f i) (ev ` A) =\n                    trace_hide (f 0) (ev ` A)) \\<and>\n                t \\<in> range f))}\n    \\<subseteq> {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F P} \\<union>\n                {s. \\<exists>t u.\n                       front_tickFree u \\<and>\n                       tickFree t \\<and>\n                       s = trace_hide t (ev ` A) @ u \\<and>\n                       (t \\<in> D P \\<or>\n                        (\\<exists>f.\n                            strict_mono f \\<and>\n                            (\\<forall>i. f i \\<in> T P) \\<and>\n                            (\\<forall>i.\n                                trace_hide (f i) (ev ` A) =\n                                trace_hide (f 0) (ev ` A)) \\<and>\n                            t \\<in> range f))}", "proof(subst Un_commute, auto, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "case 21:(1 t u a)"], ["proof (state)\nthis:\n  T Q \\<subseteq> T P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  a \\<in> A\n  t \\<in> D Q\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "define f where A:\"f = rec_nat t (\\<lambda>i t. t @ [ev a])\""], ["proof (state)\nthis:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "hence AA:\"f (Suc i) = (f i) @ [ev a]\" for i"], ["proof (prove)\nusing this:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])\n\ngoal (1 subgoal):\n 1. f (Suc i) = f i @ [ev a]", "by simp"], ["proof (state)\nthis:\n  f (Suc ?i) = f ?i @ [ev a]\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "hence B:\"strict_mono f\""], ["proof (prove)\nusing this:\n  f (Suc ?i) = f ?i @ [ev a]\n\ngoal (1 subgoal):\n 1. strict_mono f", "by (simp add:strict_mono_def lift_Suc_mono_less_iff)"], ["proof (state)\nthis:\n  strict_mono f\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "from A"], ["proof (chain)\npicking this:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])", "have C:\"t \\<in> range f\""], ["proof (prove)\nusing this:\n  f = rec_nat t (\\<lambda>i t. t @ [ev a])\n\ngoal (1 subgoal):\n 1. t \\<in> range f", "by (metis (mono_tags, lifting) old.nat.simps(6) range_eqI)"], ["proof (state)\nthis:\n  t \\<in> range f\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  t \\<in> range f\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"f i \\<in> D Q \\<and> tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = (trace_hide t (ev ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<in> D Q \\<and>\n    tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)", "proof(induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. f 0 \\<in> D Q \\<and>\n    tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)\n 2. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. f 0 \\<in> D Q \\<and>\n    tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)\n 2. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 \\<in> D Q \\<and>\n    tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)", "by (simp add: 21(4) 21(7) A)"], ["proof (state)\nthis:\n  f 0 \\<in> D Q \\<and>\n  tickFree (f 0) \\<and> trace_hide (f 0) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "case (Suc i)"], ["proof (state)\nthis:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       f i \\<in> D Q \\<and>\n       tickFree (f i) \\<and>\n       trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n       f (Suc i) \\<in> D Q \\<and>\n       tickFree (f (Suc i)) \\<and>\n       trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "then"], ["proof (chain)\npicking this:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)", "show ?case"], ["proof (prove)\nusing this:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> D Q \\<and>\n    tickFree (f (Suc i)) \\<and>\n    trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)", "apply (simp add:AA 21(6))"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<in> D Q \\<and>\n    tickFree (f i) \\<and>\n    trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n    f i @ [ev a] \\<in> D Q", "using is_processT7[rule_format, of \"f i\" Q \"[ev a]\"] front_tickFree_single"], ["proof (prove)\nusing this:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> front_tickFree [ev a] \\<Longrightarrow>\n  f i @ [ev a] \\<in> D Q\n  front_tickFree [?a]\n\ngoal (1 subgoal):\n 1. f i \\<in> D Q \\<and>\n    tickFree (f i) \\<and>\n    trace_hide (f i) (ev ` A) = trace_hide t (ev ` A) \\<Longrightarrow>\n    f i @ [ev a] \\<in> D Q", "by blast"], ["proof (state)\nthis:\n  f (Suc i) \\<in> D Q \\<and>\n  tickFree (f (Suc i)) \\<and>\n  trace_hide (f (Suc i)) (ev ` A) = trace_hide t (ev ` A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i \\<in> D Q \\<and>\n  tickFree (f i) \\<and> trace_hide (f i) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  f ?i2 \\<in> D Q \\<and>\n  tickFree (f ?i2) \\<and>\n  trace_hide (f ?i2) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "with B C"], ["proof (chain)\npicking this:\n  strict_mono f\n  t \\<in> range f\n  f ?i2 \\<in> D Q \\<and>\n  tickFree (f ?i2) \\<and>\n  trace_hide (f ?i2) (ev ` A) = trace_hide t (ev ` A)", "have \"isInfHiddenRun f P A \\<and> t \\<in> range f\""], ["proof (prove)\nusing this:\n  strict_mono f\n  t \\<in> range f\n  f ?i2 \\<in> D Q \\<and>\n  tickFree (f ?i2) \\<and>\n  trace_hide (f ?i2) (ev ` A) = trace_hide t (ev ` A)\n\ngoal (1 subgoal):\n 1. isInfHiddenRun f P A \\<and> t \\<in> range f", "by (metis 21(1) D_T subsetD)"], ["proof (state)\nthis:\n  isInfHiddenRun f P A \\<and> t \\<in> range f\n\ngoal (2 subgoals):\n 1. \\<And>t u xa.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>ta.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) \\<longrightarrow>\n           (ta, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree t;\n        \\<forall>ta ua.\n           trace_hide t (ev ` A) @ u =\n           trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n           tickFree ta \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           ta \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               ta \\<notin> range f);\n        xa \\<in> A; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "with 21"], ["proof (chain)\npicking this:\n  T Q \\<subseteq> T P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  a \\<in> A\n  t \\<in> D Q\n  isInfHiddenRun f P A \\<and> t \\<in> range f", "show ?case"], ["proof (prove)\nusing this:\n  T Q \\<subseteq> T P\n  \\<forall>ta.\n     trace_hide t (ev ` A) @ u = trace_hide ta (ev ` A) \\<longrightarrow>\n     (ta, ev ` A) \\<notin> F P\n  front_tickFree u\n  tickFree t\n  \\<forall>ta ua.\n     trace_hide t (ev ` A) @ u =\n     trace_hide ta (ev ` A) @ ua \\<longrightarrow>\n     tickFree ta \\<longrightarrow>\n     front_tickFree ua \\<longrightarrow>\n     ta \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         ta \\<notin> range f)\n  a \\<in> A\n  t \\<in> D Q\n  isInfHiddenRun f P A \\<and> t \\<in> range f\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "case 22:(2 b u f x)"], ["proof (state)\nthis:\n  T Q \\<subseteq> T P\n  \\<forall>t.\n     trace_hide (f x) (ev ` A) @ b = trace_hide t (ev ` A) \\<longrightarrow>\n     (t, ev ` A) \\<notin> F P\n  front_tickFree b\n  tickFree (f x)\n  \\<forall>t u.\n     trace_hide (f x) (ev ` A) @ b =\n     trace_hide t (ev ` A) @ u \\<longrightarrow>\n     tickFree t \\<longrightarrow>\n     front_tickFree u \\<longrightarrow>\n     t \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         t \\<notin> range f)\n  u \\<in> A\n  strict_mono f\n  \\<forall>i. f i \\<in> T Q\n  \\<forall>i. trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\n\ngoal (1 subgoal):\n 1. \\<And>u xa f xb.\n       \\<lbrakk>T Q \\<subseteq> T P;\n        \\<forall>t.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) \\<longrightarrow>\n           (t, ev ` A) \\<notin> F P;\n        front_tickFree u; tickFree (f xb);\n        \\<forall>t ua.\n           trace_hide (f xb) (ev ` A) @ u =\n           trace_hide t (ev ` A) @ ua \\<longrightarrow>\n           tickFree t \\<longrightarrow>\n           front_tickFree ua \\<longrightarrow>\n           t \\<notin> D P \\<and>\n           (\\<forall>f.\n               strict_mono f \\<longrightarrow>\n               (\\<exists>i. f i \\<notin> T P) \\<or>\n               (\\<exists>i.\n                   trace_hide (f i) (ev ` A) \\<noteq>\n                   trace_hide (f 0) (ev ` A)) \\<or>\n               t \\<notin> range f);\n        xa \\<in> A; strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  T Q \\<subseteq> T P\n  \\<forall>t.\n     trace_hide (f x) (ev ` A) @ b = trace_hide t (ev ` A) \\<longrightarrow>\n     (t, ev ` A) \\<notin> F P\n  front_tickFree b\n  tickFree (f x)\n  \\<forall>t u.\n     trace_hide (f x) (ev ` A) @ b =\n     trace_hide t (ev ` A) @ u \\<longrightarrow>\n     tickFree t \\<longrightarrow>\n     front_tickFree u \\<longrightarrow>\n     t \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         t \\<notin> range f)\n  u \\<in> A\n  strict_mono f\n  \\<forall>i. f i \\<in> T Q\n  \\<forall>i. trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)", "show ?case"], ["proof (prove)\nusing this:\n  T Q \\<subseteq> T P\n  \\<forall>t.\n     trace_hide (f x) (ev ` A) @ b = trace_hide t (ev ` A) \\<longrightarrow>\n     (t, ev ` A) \\<notin> F P\n  front_tickFree b\n  tickFree (f x)\n  \\<forall>t u.\n     trace_hide (f x) (ev ` A) @ b =\n     trace_hide t (ev ` A) @ u \\<longrightarrow>\n     tickFree t \\<longrightarrow>\n     front_tickFree u \\<longrightarrow>\n     t \\<notin> D P \\<and>\n     (\\<forall>f.\n         strict_mono f \\<longrightarrow>\n         (\\<exists>i. f i \\<notin> T P) \\<or>\n         (\\<exists>i.\n             trace_hide (f i) (ev ` A) \\<noteq>\n             trace_hide (f 0) (ev ` A)) \\<or>\n         t \\<notin> range f)\n  u \\<in> A\n  strict_mono f\n  \\<forall>i. f i \\<in> T Q\n  \\<forall>i. trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {s. \\<exists>t u.\n         front_tickFree u \\<and>\n         tickFree t \\<and>\n         s = trace_hide t (ev ` A) @ u \\<and>\n         (t \\<in> D Q \\<or>\n          (\\<exists>f.\n              strict_mono f \\<and>\n              (\\<forall>i. f i \\<in> T Q) \\<and>\n              (\\<forall>i.\n                  trace_hide (f i) (ev ` A) =\n                  trace_hide (f 0) (ev ` A)) \\<and>\n              t \\<in> range f))}\n  \\<subseteq> {trace_hide t (ev ` A) |t. (t, ev ` A) \\<in> F P} \\<union>\n              {s. \\<exists>t u.\n                     front_tickFree u \\<and>\n                     tickFree t \\<and>\n                     s = trace_hide t (ev ` A) @ u \\<and>\n                     (t \\<in> D P \\<or>\n                      (\\<exists>f.\n                          strict_mono f \\<and>\n                          (\\<forall>i. f i \\<in> T P) \\<and>\n                          (\\<forall>i.\n                              trace_hide (f i) (ev ` A) =\n                              trace_hide (f 0) (ev ` A)) \\<and>\n                          t \\<in> range f))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_hide_DT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow> P \\\\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\\\ A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n    P \\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\ A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n    P \\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\ A", "assume as:\"P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\""], ["proof (state)\nthis:\n  P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\n\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n    P \\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\ A", "then"], ["proof (chain)\npicking this:\n  P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q", "have \"P \\\\ A \\<sqsubseteq>\\<^sub>D Q \\\\ A\""], ["proof (prove)\nusing this:\n  P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q\n\ngoal (1 subgoal):\n 1. P \\ A \\<sqsubseteq>\\<^sub>D Q \\ A", "apply(auto simp:trace_divergence_refine_def divergence_refine_def \n                    trace_refine_def D_hiding T_hiding)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>T Q \\<subseteq> T P; D Q \\<subseteq> D P; front_tickFree u;\n        tickFree t; t \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta ua.\n                            front_tickFree ua \\<and>\n                            tickFree ta \\<and>\n                            trace_hide t (ev ` A) @ u =\n                            trace_hide ta (ev ` A) @ ua \\<and>\n                            (ta \\<in> D P \\<or>\n                             (\\<exists>f.\n                                 strict_mono f \\<and>\n                                 (\\<forall>i. f i \\<in> T P) \\<and>\n                                 (\\<forall>i.\n                                     trace_hide (f i) (ev ` A) =\n                                     trace_hide (f 0) (ev ` A)) \\<and>\n                                 ta \\<in> range f))\n 2. \\<And>u f xa.\n       \\<lbrakk>T Q \\<subseteq> T P; D Q \\<subseteq> D P; front_tickFree u;\n        tickFree (f xa); strict_mono f; \\<forall>i. f i \\<in> T Q;\n        \\<forall>i.\n           trace_hide (f i) (ev ` A) = trace_hide (f 0) (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ua.\n                            front_tickFree ua \\<and>\n                            tickFree t \\<and>\n                            trace_hide (f xa) (ev ` A) @ u =\n                            trace_hide t (ev ` A) @ ua \\<and>\n                            (t \\<in> D P \\<or>\n                             (\\<exists>f.\n                                 strict_mono f \\<and>\n                                 (\\<forall>i. f i \\<in> T P) \\<and>\n                                 (\\<forall>i.\n                                     trace_hide (f i) (ev ` A) =\n                                     trace_hide (f 0) (ev ` A)) \\<and>\n                                 t \\<in> range f))", "by blast+"], ["proof (state)\nthis:\n  P \\ A \\<sqsubseteq>\\<^sub>D Q \\ A\n\ngoal (1 subgoal):\n 1. P \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\<Longrightarrow>\n    P \\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\ A", "with DT_T[THEN mono_hide_T, OF as]"], ["proof (chain)\npicking this:\n  P \\ ?A \\<sqsubseteq>\\<^sub>T Q \\ ?A\n  P \\ A \\<sqsubseteq>\\<^sub>D Q \\ A", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\ ?A \\<sqsubseteq>\\<^sub>T Q \\ ?A\n  P \\ A \\<sqsubseteq>\\<^sub>D Q \\ A\n\ngoal (1 subgoal):\n 1. P \\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\ A", "by (simp add: trace_divergence_refine_def)"], ["proof (state)\nthis:\n  P \\ A \\<sqsubseteq>\\<^sub>D\\<^sub>T Q \\ A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas mono_hide_FD[simp] = \n                 mono_hide_FD[simplified failure_divergence_refine_def[symmetric]]\n\n\\<comment>\\<open>Obviously, Hide monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>D\\<close>\\<close>"], ["", "lemma mono_sync_DT[simp]: \"P \\<sqsubseteq>\\<^sub>D\\<^sub>T P' \\<Longrightarrow> Q \\<sqsubseteq>\\<^sub>D\\<^sub>T Q' \\<Longrightarrow> (P \\<lbrakk> A \\<rbrakk> Q) \\<sqsubseteq>\\<^sub>D\\<^sub>T (P' \\<lbrakk> A \\<rbrakk> Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq>\\<^sub>D\\<^sub>T P';\n     Q \\<sqsubseteq>\\<^sub>D\\<^sub>T Q'\\<rbrakk>\n    \\<Longrightarrow> (P \\<lbrakk>A\\<rbrakk>\n                          Q) \\<sqsubseteq>\\<^sub>D\\<^sub>T\n                      (P' \\<lbrakk>A\\<rbrakk> Q')", "by (simp add:trace_divergence_refine_def divergence_refine_def trace_refine_def T_sync D_sync) \n     blast"], ["", "lemmas mono_sync_FD[simp] = \n                 mono_sync_FD[simplified failure_divergence_refine_def[symmetric]]\n\n\\<comment>\\<open>synchronization monotony doesn't hold for \\<open>\\<sqsubseteq>\\<^sub>F\\<close>, \\<open>\\<sqsubseteq>\\<^sub>D\\<close> and \\<open>\\<sqsubseteq>\\<^sub>T\\<close>\\<close>"], ["", "lemma mono_mndet_F_process[simp]: \"\\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>F Q x \\<Longrightarrow> mndet A P \\<sqsubseteq>\\<^sub>F mndet A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>F Q x \\<Longrightarrow>\n    mndet A P \\<sqsubseteq>\\<^sub>F mndet A Q", "by (cases \"A = {}\", auto simp: failure_refine_def F_mndet write0_def F_Mprefix)"], ["", "lemma mono_mndet_D_process[simp]: \"\\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>D Q x \\<Longrightarrow> mndet A P \\<sqsubseteq>\\<^sub>D mndet A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>D Q x \\<Longrightarrow>\n    mndet A P \\<sqsubseteq>\\<^sub>D mndet A Q", "by (cases \"A = {}\", auto simp: divergence_refine_def D_mndet write0_def D_Mprefix)"], ["", "lemma mono_mndet_T_process[simp]: \"\\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>T Q x \\<Longrightarrow> mndet A P \\<sqsubseteq>\\<^sub>T mndet A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>T Q x \\<Longrightarrow>\n    mndet A P \\<sqsubseteq>\\<^sub>T mndet A Q", "by (cases \"A = {}\", auto simp: trace_refine_def T_mndet write0_def T_Mprefix)"], ["", "corollary mono_mndet_DT_process[simp]: \"\\<forall>x\\<in>A. P x \\<sqsubseteq>\\<^sub>D\\<^sub>T Q x \\<Longrightarrow> mndet A P \\<sqsubseteq>\\<^sub>D\\<^sub>T mndet A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       P x \\<sqsubseteq>\\<^sub>D\\<^sub>T Q x \\<Longrightarrow>\n    mndet A P \\<sqsubseteq>\\<^sub>D\\<^sub>T mndet A Q", "by (simp add: trace_divergence_refine_def)"], ["", "lemmas \nmono_mndet_FD_process[simp] = \n              mono_mndet_FD[simplified failure_divergence_refine_def[symmetric]]"], ["", "lemmas \nmono_mndet_FD_set[simp] = \n              mndet_FD_subset[simplified failure_divergence_refine_def[symmetric]]"], ["", "corollary mono_mndet_F_set[simp]: \"A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>F mndet A P\"\n      and mono_mndet_D_set[simp]: \"A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>D mndet A P\"\n      and mono_mndet_T_set[simp]: \"A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>T mndet A P\"\n      and mono_mndet_DT_set[simp]: \"A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>D\\<^sub>T mndet A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>A \\<noteq> {}; A \\<subseteq> B\\<rbrakk>\n      \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>F mndet A P) &&&\n     (\\<lbrakk>A \\<noteq> {}; A \\<subseteq> B\\<rbrakk>\n      \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>D mndet A P)) &&&\n    (\\<lbrakk>A \\<noteq> {}; A \\<subseteq> B\\<rbrakk>\n     \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>T mndet A P) &&&\n    (\\<lbrakk>A \\<noteq> {}; A \\<subseteq> B\\<rbrakk>\n     \\<Longrightarrow> mndet B P \\<sqsubseteq>\\<^sub>D\\<^sub>T mndet A P)", "by (simp_all add: FD_F FD_D le_F_T D_T_DT)"], ["", "lemmas \nMprefix_refines_Mndet_FD[simp] = \n                          Mprefix_refines_Mndet[simplified failure_divergence_refine_def[symmetric]]"], ["", "corollary Mprefix_refines_Mndet_F[simp]: \"mndet A P \\<sqsubseteq>\\<^sub>F Mprefix A P\"\n      and Mprefix_refines_Mndet_D[simp]: \"mndet A P \\<sqsubseteq>\\<^sub>D Mprefix A P\"\n      and Mprefix_refines_Mndet_T[simp]: \"mndet A P \\<sqsubseteq>\\<^sub>T Mprefix A P\"\n      and Mprefix_refines_Mndet_DT[simp]: \"mndet A P \\<sqsubseteq>\\<^sub>D\\<^sub>T Mprefix A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mndet A P \\<sqsubseteq>\\<^sub>F Mprefix A P &&&\n     mndet A P \\<sqsubseteq>\\<^sub>D Mprefix A P) &&&\n    mndet A P \\<sqsubseteq>\\<^sub>T Mprefix A P &&&\n    mndet A P \\<sqsubseteq>\\<^sub>D\\<^sub>T Mprefix A P", "by (simp_all add: FD_F FD_D le_F_T D_T_DT)"], ["", "section \\<open>Reference processes and their unfolding rules\\<close>"], ["", "thm DF_def DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def RUN_def CHAOS_def"], ["", "definition CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P :: \"'a set \\<Rightarrow> 'a process\" \n  where   \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<equiv> \\<mu> X. (SKIP \\<sqinter> STOP \\<sqinter> (\\<box> x \\<in> A \\<rightarrow> X))\""], ["", "thm DF_unfold DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold"], ["", "lemma RUN_unfold : \"RUN A = (\\<box> z \\<in> A \\<rightarrow> RUN A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RUN A = Mprefix A (\\<lambda>z. RUN A)", "by(simp add: RUN_def, rule trans, rule fix_eq, simp)"], ["", "lemma CHAOS_unfold : \"CHAOS A = (STOP \\<sqinter> (\\<box> z \\<in> A \\<rightarrow> CHAOS A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS A = (STOP |-| Mprefix A (\\<lambda>z. CHAOS A))", "by(simp add: CHAOS_def, rule trans, rule fix_eq, simp)"], ["", "lemma CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<equiv> SKIP \\<sqinter> STOP \\<sqinter> (\\<box> x \\<in> A \\<rightarrow> CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<equiv>\n    SKIP |-| STOP |-|\n    Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "unfolding CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> x. SKIP |-| STOP |-| Mprefix A (\\<lambda>xa. x) \\<equiv>\n    SKIP |-| STOP |-|\n    Mprefix A\n     (\\<lambda>x. \\<mu> x. SKIP |-| STOP |-| Mprefix A (\\<lambda>xa. x))", "using fix_eq[of \"\\<Lambda> X. (SKIP \\<sqinter> STOP \\<sqinter> (\\<box> x \\<in> A \\<rightarrow> X))\"]"], ["proof (prove)\nusing this:\n  (\\<mu> X. SKIP |-| STOP |-| Mprefix A (\\<lambda>x. X)) =\n  (\\<Lambda> X. SKIP |-| STOP |-| Mprefix A (\\<lambda>x. X))\\<cdot>\n  (\\<mu> X. SKIP |-| STOP |-| Mprefix A (\\<lambda>x. X))\n\ngoal (1 subgoal):\n 1. \\<mu> x. SKIP |-| STOP |-| Mprefix A (\\<lambda>xa. x) \\<equiv>\n    SKIP |-| STOP |-|\n    Mprefix A\n     (\\<lambda>x. \\<mu> x. SKIP |-| STOP |-| Mprefix A (\\<lambda>xa. x))", "by simp"], ["", "section \\<open>Process events and reference processes events\\<close>"], ["", "definition events_of where \"events_of P \\<equiv> (\\<Union>t\\<in>T P. {a. ev a \\<in> set t})\""], ["", "lemma events_DF: \"events_of (DF A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. events_of (DF A) = A", "proof(auto simp add:events_of_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa", "fix x t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa", "show \"t \\<in> T (DF A) \\<Longrightarrow> ev x \\<in> set t \\<Longrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (DF A); ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> T (DF A)\n  ev x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (DF A); ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  [] \\<in> T (DF A)\n  ev x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> T (DF A)\n  ev x \\<in> set []\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by simp"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF A)\n  ev x \\<in> set (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "from Cons(2)"], ["proof (chain)\npicking this:\n  a # t \\<in> T (DF A)", "have \"a # t \\<in> T (\\<sqinter>z\\<in>A \\<rightarrow>  DF A)\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (DF A)\n\ngoal (1 subgoal):\n 1. a # t \\<in> T (\\<sqinter>z\\<in>A \\<rightarrow>  DF A)", "using DF_unfold"], ["proof (prove)\nusing this:\n  a # t \\<in> T (DF A)\n  DF ?A = (\\<sqinter>z\\<in>?A \\<rightarrow>  DF ?A)\n\ngoal (1 subgoal):\n 1. a # t \\<in> T (\\<sqinter>z\\<in>A \\<rightarrow>  DF A)", "by metis"], ["proof (state)\nthis:\n  a # t \\<in> T (\\<sqinter>z\\<in>A \\<rightarrow>  DF A)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  a # t \\<in> T (\\<sqinter>z\\<in>A \\<rightarrow>  DF A)", "obtain aa where \"a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (DF A)\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (\\<sqinter>z\\<in>A \\<rightarrow>  DF A)\n\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        a = ev aa \\<and>\n        aa \\<in> A \\<and> t \\<in> T (DF A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"A={}\", auto simp add:T_mndet write0_def T_Mprefix T_STOP)"], ["proof (state)\nthis:\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (DF A)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (DF A)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (DF A)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (DF A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa", "show \"x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa", "apply(subst DF_unfold, cases \"A={}\", auto simp add:T_mndet write0_def T_Mprefix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> A;\n        \\<forall>y\\<in>A.\n           \\<forall>xa.\n              xa \\<noteq> [] \\<and>\n              (hd xa = ev y \\<longrightarrow>\n               xa = [] \\<or> tl xa \\<notin> T (DF A)) \\<or>\n              ev x \\<notin> set xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Nil_elem_T list.sel(1) list.sel(3) list.set_intros(1))"], ["proof (state)\nthis:\n  x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (DF A). ev x \\<in> set xa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma events_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"events_of (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. events_of (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = A", "proof(auto simp add:events_of_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "fix x t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "show \"t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<Longrightarrow> ev x \\<in> set t \\<Longrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     ev x \\<in> set t\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  [] \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set []\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by simp"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "from Cons(2)"], ["proof (chain)\npicking this:\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "have \"a # t \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow>  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<sqinter> SKIP)\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. a # t\n    \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \n                 DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n             SKIP)", "using DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold"], ["proof (prove)\nusing this:\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A =\n  ((\\<sqinter>z\\<in>?A \\<rightarrow> \n       DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A) |-|\n   SKIP)\n\ngoal (1 subgoal):\n 1. a # t\n    \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \n                 DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n             SKIP)", "by metis"], ["proof (state)\nthis:\n  a # t\n  \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \n               DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n           SKIP)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a # t\n  \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \n               DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n           SKIP)", "obtain aa where \"a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a # t\n  \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \n               DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n           SKIP)\n\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        a = ev aa \\<and>\n        aa \\<in> A \\<and>\n        t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"A={}\", auto simp add:T_mndet write0_def T_Mprefix T_STOP T_SKIP T_ndet)"], ["proof (state)\nthis:\n  a = ev aa \\<and>\n  aa \\<in> A \\<and> t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and>\n  aa \\<in> A \\<and> t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and>\n  aa \\<in> A \\<and> t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "show \"x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A). ev x \\<in> set xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n       ev x \\<in> set xa", "apply(subst DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold, cases \"A={}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> A; A = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>T\n ((\\<sqinter>z\\<in>A \\<rightarrow> \n      DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n  SKIP).\n                         ev x \\<in> set xa\n 2. \\<lbrakk>x \\<in> A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>T\n ((\\<sqinter>z\\<in>A \\<rightarrow> \n      DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n  SKIP).\n                         ev x \\<in> set xa", "apply(auto simp add:T_mndet write0_def T_Mprefix T_SKIP T_ndet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> A;\n        \\<forall>y\\<in>A.\n           \\<forall>xa.\n              xa \\<noteq> [] \\<and>\n              (hd xa = ev y \\<longrightarrow>\n               xa = [] \\<or>\n               tl xa\n               \\<notin> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)) \\<or>\n              ev x \\<notin> set xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Nil_elem_T list.sel(1) list.sel(3) list.set_intros(1))"], ["proof (state)\nthis:\n  x \\<in> A \\<Longrightarrow>\n  \\<exists>xa\\<in>T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n     ev x \\<in> set xa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma events_RUN: \"events_of (RUN A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. events_of (RUN A) = A", "proof(auto simp add:events_of_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa", "fix x t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa", "show \"t \\<in> T (RUN A) \\<Longrightarrow> ev x \\<in> set t \\<Longrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (RUN A); ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (RUN A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> T (RUN A)\n  ev x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (RUN A); ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (RUN A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  [] \\<in> T (RUN A)\n  ev x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> T (RUN A)\n  ev x \\<in> set []\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by simp"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (RUN A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (RUN A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (RUN A)\n  ev x \\<in> set (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (RUN A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "from Cons(2)"], ["proof (chain)\npicking this:\n  a # t \\<in> T (RUN A)", "have \"a # t \\<in> T (\\<box>z\\<in>A \\<rightarrow>  RUN A)\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (RUN A)\n\ngoal (1 subgoal):\n 1. a # t \\<in> T (Mprefix A (\\<lambda>z. RUN A))", "using RUN_unfold"], ["proof (prove)\nusing this:\n  a # t \\<in> T (RUN A)\n  RUN ?A = Mprefix ?A (\\<lambda>z. RUN ?A)\n\ngoal (1 subgoal):\n 1. a # t \\<in> T (Mprefix A (\\<lambda>z. RUN A))", "by metis"], ["proof (state)\nthis:\n  a # t \\<in> T (Mprefix A (\\<lambda>z. RUN A))\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (RUN A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  a # t \\<in> T (Mprefix A (\\<lambda>z. RUN A))", "obtain aa where \"a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (RUN A)\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (Mprefix A (\\<lambda>z. RUN A))\n\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        a = ev aa \\<and>\n        aa \\<in> A \\<and> t \\<in> T (RUN A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:T_Mprefix)"], ["proof (state)\nthis:\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (RUN A)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (RUN A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (RUN A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (RUN A)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (RUN A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (RUN A)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (RUN A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa", "show \"x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa", "apply(subst RUN_unfold, simp add: T_Mprefix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    \\<exists>xa.\n       (xa = [] \\<or>\n        (\\<exists>a.\n            a \\<in> A \\<and>\n            xa \\<noteq> [] \\<and>\n            hd xa = ev a \\<and> tl xa \\<in> T (RUN A))) \\<and>\n       ev x \\<in> set xa", "by (metis Nil_elem_T list.sel(1) list.sel(3) list.set_intros(1))"], ["proof (state)\nthis:\n  x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (RUN A). ev x \\<in> set xa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma events_CHAOS: \"events_of (CHAOS A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. events_of (CHAOS A) = A", "proof(auto simp add:events_of_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa", "fix x t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa", "show \"t \\<in> T (CHAOS A) \\<Longrightarrow> ev x \\<in> set t \\<Longrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (CHAOS A); ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> T (CHAOS A)\n  ev x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (CHAOS A); ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  [] \\<in> T (CHAOS A)\n  ev x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> T (CHAOS A)\n  ev x \\<in> set []\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by simp"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS A)\n  ev x \\<in> set (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "from Cons(2)"], ["proof (chain)\npicking this:\n  a # t \\<in> T (CHAOS A)", "have \"a # t \\<in> T (STOP \\<sqinter> (\\<box> z \\<in> A \\<rightarrow> CHAOS A))\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (CHAOS A)\n\ngoal (1 subgoal):\n 1. a # t \\<in> T (STOP |-| Mprefix A (\\<lambda>z. CHAOS A))", "using CHAOS_unfold"], ["proof (prove)\nusing this:\n  a # t \\<in> T (CHAOS A)\n  CHAOS ?A = (STOP |-| Mprefix ?A (\\<lambda>z. CHAOS ?A))\n\ngoal (1 subgoal):\n 1. a # t \\<in> T (STOP |-| Mprefix A (\\<lambda>z. CHAOS A))", "by metis"], ["proof (state)\nthis:\n  a # t \\<in> T (STOP |-| Mprefix A (\\<lambda>z. CHAOS A))\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  a # t \\<in> T (STOP |-| Mprefix A (\\<lambda>z. CHAOS A))", "obtain aa where \"a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (CHAOS A)\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (STOP |-| Mprefix A (\\<lambda>z. CHAOS A))\n\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        a = ev aa \\<and>\n        aa \\<in> A \\<and> t \\<in> T (CHAOS A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:T_ndet T_Mprefix T_STOP)"], ["proof (state)\nthis:\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (CHAOS A)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS A); ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (CHAOS A)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (CHAOS A)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (CHAOS A); ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa", "show \"x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa", "apply(subst CHAOS_unfold, simp add:T_ndet T_Mprefix T_STOP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    \\<exists>xa.\n       (xa = [] \\<or>\n        (\\<exists>a.\n            a \\<in> A \\<and>\n            xa \\<noteq> [] \\<and>\n            hd xa = ev a \\<and> tl xa \\<in> T (CHAOS A))) \\<and>\n       ev x \\<in> set xa", "by (metis Nil_elem_T list.sel(1) list.sel(3) list.set_intros(1))"], ["proof (state)\nthis:\n  x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (CHAOS A). ev x \\<in> set xa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma events_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"events_of (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. events_of (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = A", "proof(auto simp add:events_of_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "fix x t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set t\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "show \"t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<Longrightarrow> ev x \\<in> set t \\<Longrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     ev x \\<in> set t\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     ev x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  [] \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set []\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by simp"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "from Cons(2)"], ["proof (chain)\npicking this:\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "have \"a # t \\<in> T (SKIP \\<sqinter> STOP \\<sqinter> (\\<box> z \\<in> A \\<rightarrow> CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\""], ["proof (prove)\nusing this:\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. a # t\n    \\<in> T (SKIP |-| STOP |-|\n             Mprefix A\n              (\\<lambda>z. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "using CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold"], ["proof (prove)\nusing this:\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A \\<equiv>\n  SKIP |-| STOP |-|\n  Mprefix ?A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A)\n\ngoal (1 subgoal):\n 1. a # t\n    \\<in> T (SKIP |-| STOP |-|\n             Mprefix A\n              (\\<lambda>z. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "by metis"], ["proof (state)\nthis:\n  a # t\n  \\<in> T (SKIP |-| STOP |-|\n           Mprefix A (\\<lambda>z. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a # t\n  \\<in> T (SKIP |-| STOP |-|\n           Mprefix A (\\<lambda>z. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "obtain aa where \"a = ev aa \\<and> aa \\<in> A \\<and> t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a # t\n  \\<in> T (SKIP |-| STOP |-|\n           Mprefix A (\\<lambda>z. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\n\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        a = ev aa \\<and>\n        aa \\<in> A \\<and>\n        t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                    A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:T_ndet T_Mprefix T_STOP T_SKIP)"], ["proof (state)\nthis:\n  a = ev aa \\<and>\n  aa \\<in> A \\<and> t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 ev x \\<in> set t\\<rbrakk>\n                \\<Longrightarrow> x \\<in> A;\n        a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        ev x \\<in> set (a # t)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and>\n  aa \\<in> A \\<and> t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n  a # t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  ev x \\<in> set (a # t)\n  a = ev aa \\<and>\n  aa \\<in> A \\<and> t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n   ev x \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n          ev x \\<in> set xa", "show \"x \\<in> A \\<Longrightarrow> \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A). ev x \\<in> set xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n       ev x \\<in> set xa", "apply(subst CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold, simp add:T_ndet T_Mprefix T_STOP T_SKIP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    \\<exists>xa.\n       (xa = [] \\<or>\n        (\\<exists>a.\n            a \\<in> A \\<and>\n            xa \\<noteq> [] \\<and>\n            hd xa = ev a \\<and>\n            tl xa \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))) \\<and>\n       ev x \\<in> set xa", "by (metis Nil_elem_T list.sel(1) list.sel(3) list.set_intros(1))"], ["proof (state)\nthis:\n  x \\<in> A \\<Longrightarrow>\n  \\<exists>xa\\<in>T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A).\n     ev x \\<in> set xa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma events_div: \"D(P) \\<noteq> {} \\<Longrightarrow>  events_of (P) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D P \\<noteq> {} \\<Longrightarrow> events_of P = UNIV", "proof(auto simp add:events_of_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x \\<in> D P \\<Longrightarrow> \\<exists>x\\<in>T P. ev xa \\<in> set x", "fix x xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x \\<in> D P \\<Longrightarrow> \\<exists>x\\<in>T P. ev xa \\<in> set x", "assume 1: \"x \\<in> D P\""], ["proof (state)\nthis:\n  x \\<in> D P\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x \\<in> D P \\<Longrightarrow> \\<exists>x\\<in>T P. ev xa \\<in> set x", "show \"\\<exists>x\\<in>T P. ev xa \\<in> set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>T P. ev xa \\<in> set x", "proof(cases \"tickFree x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tickFree x \\<Longrightarrow> \\<exists>x\\<in>T P. ev xa \\<in> set x\n 2. \\<not> tickFree x \\<Longrightarrow>\n    \\<exists>x\\<in>T P. ev xa \\<in> set x", "case True"], ["proof (state)\nthis:\n  tickFree x\n\ngoal (2 subgoals):\n 1. tickFree x \\<Longrightarrow> \\<exists>x\\<in>T P. ev xa \\<in> set x\n 2. \\<not> tickFree x \\<Longrightarrow>\n    \\<exists>x\\<in>T P. ev xa \\<in> set x", "hence \"x@[ev xa] \\<in> T P\""], ["proof (prove)\nusing this:\n  tickFree x\n\ngoal (1 subgoal):\n 1. x @ [ev xa] \\<in> T P", "using 1 NT_ND front_tickFree_single is_processT7"], ["proof (prove)\nusing this:\n  tickFree x\n  x \\<in> D P\n  ?c \\<notin> T ?P \\<Longrightarrow> ?c \\<notin> D ?P\n  front_tickFree [?a]\n  \\<forall>s t.\n     s \\<in> D ?P \\<and>\n     tickFree s \\<and> front_tickFree t \\<longrightarrow>\n     s @ t \\<in> D ?P\n\ngoal (1 subgoal):\n 1. x @ [ev xa] \\<in> T P", "by blast"], ["proof (state)\nthis:\n  x @ [ev xa] \\<in> T P\n\ngoal (2 subgoals):\n 1. tickFree x \\<Longrightarrow> \\<exists>x\\<in>T P. ev xa \\<in> set x\n 2. \\<not> tickFree x \\<Longrightarrow>\n    \\<exists>x\\<in>T P. ev xa \\<in> set x", "then"], ["proof (chain)\npicking this:\n  x @ [ev xa] \\<in> T P", "show ?thesis"], ["proof (prove)\nusing this:\n  x @ [ev xa] \\<in> T P\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>T P. ev xa \\<in> set x", "by force"], ["proof (state)\nthis:\n  \\<exists>x\\<in>T P. ev xa \\<in> set x\n\ngoal (1 subgoal):\n 1. \\<not> tickFree x \\<Longrightarrow>\n    \\<exists>x\\<in>T P. ev xa \\<in> set x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tickFree x \\<Longrightarrow>\n    \\<exists>x\\<in>T P. ev xa \\<in> set x", "case False"], ["proof (state)\nthis:\n  \\<not> tickFree x\n\ngoal (1 subgoal):\n 1. \\<not> tickFree x \\<Longrightarrow>\n    \\<exists>x\\<in>T P. ev xa \\<in> set x", "hence \"(butlast x)@[ev xa] \\<in> T P\""], ["proof (prove)\nusing this:\n  \\<not> tickFree x\n\ngoal (1 subgoal):\n 1. butlast x @ [ev xa] \\<in> T P", "by (metis \"1\" D_T D_imp_front_tickFree append_single_T_imp_tickFree butlast_snoc \n                front_tickFree_single nonTickFree_n_frontTickFree process_charn)"], ["proof (state)\nthis:\n  butlast x @ [ev xa] \\<in> T P\n\ngoal (1 subgoal):\n 1. \\<not> tickFree x \\<Longrightarrow>\n    \\<exists>x\\<in>T P. ev xa \\<in> set x", "then"], ["proof (chain)\npicking this:\n  butlast x @ [ev xa] \\<in> T P", "show ?thesis"], ["proof (prove)\nusing this:\n  butlast x @ [ev xa] \\<in> T P\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>T P. ev xa \\<in> set x", "by force"], ["proof (state)\nthis:\n  \\<exists>x\\<in>T P. ev xa \\<in> set x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>T P. ev xa \\<in> set x\n\ngoal:\nNo subgoals!", "qed"], ["", "thm DF_subset"], ["", "lemma DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_subset_FD: \"A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P B \\<sqsubseteq>\\<^sub>F\\<^sub>D DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                       B \\<sqsubseteq>\\<^sub>F\\<^sub>D\n                      DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "apply(subst DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def, rule fix_ind, rule le_FD_adm, simp_all add:monofunI, subst DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; A \\<subseteq> B;\n        x \\<sqsubseteq>\\<^sub>F\\<^sub>D\n        DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\\<rbrakk>\n       \\<Longrightarrow> ((\\<sqinter>xa\\<in>B \\<rightarrow>  x) |-|\n                          SKIP) \\<sqsubseteq>\\<^sub>F\\<^sub>D\n                         ((\\<sqinter>z\\<in>A \\<rightarrow> \n                              DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n                          SKIP)", "by (rule mono_ndet_FD, simp_all) (meson mono_mndet_FD_process mono_mndet_FD_set trans_FD)"], ["", "lemma RUN_subset_DT: \"A \\<subseteq> B \\<Longrightarrow> RUN B \\<sqsubseteq>\\<^sub>D\\<^sub>T RUN A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    RUN B \\<sqsubseteq>\\<^sub>D\\<^sub>T RUN A", "apply(subst RUN_def, rule fix_ind, rule le_DT_adm, simp_all add:monofunI, subst RUN_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<subseteq> B;\n        x \\<sqsubseteq>\\<^sub>D\\<^sub>T RUN A\\<rbrakk>\n       \\<Longrightarrow> Mprefix B\n                          (\\<lambda>xa. x) \\<sqsubseteq>\\<^sub>D\\<^sub>T\n                         Mprefix A (\\<lambda>z. RUN A)", "by (meson mono_mprefix_DT_process mono_mprefix_DT_set trans_DT)"], ["", "lemma CHAOS_subset_FD: \"A \\<subseteq> B \\<Longrightarrow> CHAOS B \\<sqsubseteq>\\<^sub>F\\<^sub>D CHAOS A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    CHAOS B \\<sqsubseteq>\\<^sub>F\\<^sub>D CHAOS A", "apply(subst CHAOS_def, rule fix_ind, rule le_FD_adm, simp_all add:monofunI, subst CHAOS_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<subseteq> B;\n        x \\<sqsubseteq>\\<^sub>F\\<^sub>D CHAOS A\\<rbrakk>\n       \\<Longrightarrow> (STOP |-|\n                          Mprefix B\n                           (\\<lambda>xa. x)) \\<sqsubseteq>\\<^sub>F\\<^sub>D\n                         (STOP |-| Mprefix A (\\<lambda>z. CHAOS A))", "by (auto simp add: failure_divergence_refine_def le_ref_def \n                     D_Mprefix D_ndet F_STOP F_Mprefix F_ndet)"], ["", "lemma CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_subset_FD: \"A \\<subseteq> B \\<Longrightarrow> CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P B \\<sqsubseteq>\\<^sub>F\\<^sub>D CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P B \\<sqsubseteq>\\<^sub>F\\<^sub>D\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "apply(subst CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def, rule fix_ind, rule le_FD_adm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. A \\<subseteq> B \\<Longrightarrow> cont (\\<lambda>x. x)\n 2. A \\<subseteq> B \\<Longrightarrow>\n    monofun (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n 3. A \\<subseteq> B \\<Longrightarrow>\n    \\<bottom> \\<sqsubseteq>\\<^sub>F\\<^sub>D\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\n 4. \\<And>x.\n       \\<lbrakk>A \\<subseteq> B;\n        x \\<sqsubseteq>\\<^sub>F\\<^sub>D\n        CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             SKIP |-| STOP |-|\n                             Mprefix B (\\<lambda>xa. x))\\<cdot>\n                         x \\<sqsubseteq>\\<^sub>F\\<^sub>D\n                         CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "apply(simp_all add:monofunI, subst CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<subseteq> B;\n        x \\<sqsubseteq>\\<^sub>F\\<^sub>D\n        CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\\<rbrakk>\n       \\<Longrightarrow> (SKIP |-| STOP |-|\n                          Mprefix B\n                           (\\<lambda>xa. x)) \\<sqsubseteq>\\<^sub>F\\<^sub>D\n                         (SKIP |-| STOP |-|\n                          Mprefix A\n                           (\\<lambda>x.\n                               CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "by (auto simp add: failure_divergence_refine_def le_ref_def \n                     D_Mprefix D_ndet F_STOP F_Mprefix F_ndet)"], ["", "section \\<open>Relations between refinements on reference processes\\<close>"], ["", "lemma CHAOS_has_all_tickFree_failures: \n      \"tickFree a \\<Longrightarrow> {x. ev x \\<in> set a} \\<subseteq> A \\<Longrightarrow> (a,b) \\<in> F (CHAOS A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tickFree a; {x. ev x \\<in> set a} \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> F (CHAOS A)", "proof(induct a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>tickFree []; {x. ev x \\<in> set []} \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> ([], b) \\<in> F (CHAOS A)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>tickFree a2;\n                 {x. ev x \\<in> set a2} \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> (a2, b) \\<in> F (CHAOS A);\n        tickFree (a1 # a2);\n        {x. ev x \\<in> set (a1 # a2)} \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b) \\<in> F (CHAOS A)", "case Nil"], ["proof (state)\nthis:\n  tickFree []\n  {x. ev x \\<in> set []} \\<subseteq> A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tickFree []; {x. ev x \\<in> set []} \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> ([], b) \\<in> F (CHAOS A)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>tickFree a2;\n                 {x. ev x \\<in> set a2} \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> (a2, b) \\<in> F (CHAOS A);\n        tickFree (a1 # a2);\n        {x. ev x \\<in> set (a1 # a2)} \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b) \\<in> F (CHAOS A)", "then"], ["proof (chain)\npicking this:\n  tickFree []\n  {x. ev x \\<in> set []} \\<subseteq> A", "show ?case"], ["proof (prove)\nusing this:\n  tickFree []\n  {x. ev x \\<in> set []} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. ([], b) \\<in> F (CHAOS A)", "by (subst CHAOS_unfold, simp add:F_ndet F_STOP)"], ["proof (state)\nthis:\n  ([], b) \\<in> F (CHAOS A)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>tickFree a2;\n                 {x. ev x \\<in> set a2} \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> (a2, b) \\<in> F (CHAOS A);\n        tickFree (a1 # a2);\n        {x. ev x \\<in> set (a1 # a2)} \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b) \\<in> F (CHAOS A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>tickFree a2;\n                 {x. ev x \\<in> set a2} \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> (a2, b) \\<in> F (CHAOS A);\n        tickFree (a1 # a2);\n        {x. ev x \\<in> set (a1 # a2)} \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b) \\<in> F (CHAOS A)", "case (Cons a0 al)"], ["proof (state)\nthis:\n  \\<lbrakk>tickFree al; {x. ev x \\<in> set al} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> (al, b) \\<in> F (CHAOS A)\n  tickFree (a0 # al)\n  {x. ev x \\<in> set (a0 # al)} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>tickFree a2;\n                 {x. ev x \\<in> set a2} \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> (a2, b) \\<in> F (CHAOS A);\n        tickFree (a1 # a2);\n        {x. ev x \\<in> set (a1 # a2)} \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b) \\<in> F (CHAOS A)", "hence \"tickFree al\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tickFree al; {x. ev x \\<in> set al} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> (al, b) \\<in> F (CHAOS A)\n  tickFree (a0 # al)\n  {x. ev x \\<in> set (a0 # al)} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. tickFree al", "by (metis append.left_neutral append_Cons front_tickFree_charn front_tickFree_mono)"], ["proof (state)\nthis:\n  tickFree al\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>tickFree a2;\n                 {x. ev x \\<in> set a2} \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> (a2, b) \\<in> F (CHAOS A);\n        tickFree (a1 # a2);\n        {x. ev x \\<in> set (a1 # a2)} \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b) \\<in> F (CHAOS A)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>tickFree al; {x. ev x \\<in> set al} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> (al, b) \\<in> F (CHAOS A)\n  tickFree (a0 # al)\n  {x. ev x \\<in> set (a0 # al)} \\<subseteq> A\n  tickFree al", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>tickFree al; {x. ev x \\<in> set al} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> (al, b) \\<in> F (CHAOS A)\n  tickFree (a0 # al)\n  {x. ev x \\<in> set (a0 # al)} \\<subseteq> A\n  tickFree al\n\ngoal (1 subgoal):\n 1. (a0 # al, b) \\<in> F (CHAOS A)", "apply (subst CHAOS_unfold, simp add:F_ndet F_STOP F_Mprefix events_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a0 \\<noteq> tick;\n     {x. ev x = a0 \\<or> ev x \\<in> set al} \\<subseteq> A;\n     {x. ev x \\<in> set al} \\<subseteq> A \\<Longrightarrow>\n     (al, b) \\<in> F (CHAOS A);\n     tickFree al\\<rbrakk>\n    \\<Longrightarrow> a0 \\<in> ev ` A \\<and>\n                      (\\<exists>a. ev a = a0) \\<and>\n                      (al, b) \\<in> F (CHAOS A)", "using event_set"], ["proof (prove)\nusing this:\n  ?e \\<in> insert tick (range ev)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a0 \\<noteq> tick;\n     {x. ev x = a0 \\<or> ev x \\<in> set al} \\<subseteq> A;\n     {x. ev x \\<in> set al} \\<subseteq> A \\<Longrightarrow>\n     (al, b) \\<in> F (CHAOS A);\n     tickFree al\\<rbrakk>\n    \\<Longrightarrow> a0 \\<in> ev ` A \\<and>\n                      (\\<exists>a. ev a = a0) \\<and>\n                      (al, b) \\<in> F (CHAOS A)", "by blast"], ["proof (state)\nthis:\n  (a0 # al, b) \\<in> F (CHAOS A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_failures: \n  assumes as:\"(events_of P) \\<subseteq> A\" \n  shows \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F P", "have \"front_tickFree a \\<Longrightarrow> set a \\<subseteq> (\\<Union>t\\<in>T P. set t) \\<Longrightarrow> (a,b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>front_tickFree a;\n     set a \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n    \\<Longrightarrow> (a, b)\n                      \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "proof(induct a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>front_tickFree [];\n     set [] \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n    \\<Longrightarrow> ([], b)\n                      \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>front_tickFree a2;\n                 set a2 \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n                \\<Longrightarrow> (a2, b)\n                                  \\<in> F\n   (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a1 # a2);\n        set (a1 # a2) \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b)\n                         \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "case Nil"], ["proof (state)\nthis:\n  front_tickFree []\n  set [] \\<subseteq> \\<Union> (set ` T P)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>front_tickFree [];\n     set [] \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n    \\<Longrightarrow> ([], b)\n                      \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>front_tickFree a2;\n                 set a2 \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n                \\<Longrightarrow> (a2, b)\n                                  \\<in> F\n   (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a1 # a2);\n        set (a1 # a2) \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b)\n                         \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "then"], ["proof (chain)\npicking this:\n  front_tickFree []\n  set [] \\<subseteq> \\<Union> (set ` T P)", "show ?case"], ["proof (prove)\nusing this:\n  front_tickFree []\n  set [] \\<subseteq> \\<Union> (set ` T P)\n\ngoal (1 subgoal):\n 1. ([], b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "by (subst CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold, simp add:F_ndet F_STOP)"], ["proof (state)\nthis:\n  ([], b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>front_tickFree a2;\n                 set a2 \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n                \\<Longrightarrow> (a2, b)\n                                  \\<in> F\n   (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a1 # a2);\n        set (a1 # a2) \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b)\n                         \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>front_tickFree a2;\n                 set a2 \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n                \\<Longrightarrow> (a2, b)\n                                  \\<in> F\n   (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a1 # a2);\n        set (a1 # a2) \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b)\n                         \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "case (Cons a0 al)"], ["proof (state)\nthis:\n  \\<lbrakk>front_tickFree al;\n   set al \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n  \\<Longrightarrow> (al, b)\n                    \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  front_tickFree (a0 # al)\n  set (a0 # al) \\<subseteq> \\<Union> (set ` T P)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>front_tickFree a2;\n                 set a2 \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n                \\<Longrightarrow> (a2, b)\n                                  \\<in> F\n   (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a1 # a2);\n        set (a1 # a2) \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b)\n                         \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "hence \"front_tickFree al\""], ["proof (prove)\nusing this:\n  \\<lbrakk>front_tickFree al;\n   set al \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n  \\<Longrightarrow> (al, b)\n                    \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  front_tickFree (a0 # al)\n  set (a0 # al) \\<subseteq> \\<Union> (set ` T P)\n\ngoal (1 subgoal):\n 1. front_tickFree al", "by (metis append.left_neutral append_Cons front_tickFree_charn front_tickFree_mono)"], ["proof (state)\nthis:\n  front_tickFree al\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>front_tickFree a2;\n                 set a2 \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n                \\<Longrightarrow> (a2, b)\n                                  \\<in> F\n   (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a1 # a2);\n        set (a1 # a2) \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n       \\<Longrightarrow> (a1 # a2, b)\n                         \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>front_tickFree al;\n   set al \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n  \\<Longrightarrow> (al, b)\n                    \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  front_tickFree (a0 # al)\n  set (a0 # al) \\<subseteq> \\<Union> (set ` T P)\n  front_tickFree al", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>front_tickFree al;\n   set al \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n  \\<Longrightarrow> (al, b)\n                    \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  front_tickFree (a0 # al)\n  set (a0 # al) \\<subseteq> \\<Union> (set ` T P)\n  front_tickFree al\n\ngoal (1 subgoal):\n 1. (a0 # al, b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "apply (subst CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold, simp add:F_ndet F_STOP F_SKIP F_Mprefix events_of_def as)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>x\\<in>T P. a0 \\<in> set x) \\<and>\n             set al \\<subseteq> \\<Union> (set ` T P);\n     (al, b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     front_tickFree (a0 # al); front_tickFree al\\<rbrakk>\n    \\<Longrightarrow> a0 = tick \\<and> al = [] \\<or>\n                      a0 \\<in> ev ` A \\<and> (\\<exists>a. ev a = a0)", "apply(cases \"a0=tick\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>x\\<in>T P. a0 \\<in> set x) \\<and>\n             set al \\<subseteq> \\<Union> (set ` T P);\n     (al, b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     front_tickFree (a0 # al); front_tickFree al; a0 = tick\\<rbrakk>\n    \\<Longrightarrow> a0 = tick \\<and> al = [] \\<or>\n                      a0 \\<in> ev ` A \\<and> (\\<exists>a. ev a = a0)\n 2. \\<lbrakk>(\\<exists>x\\<in>T P. a0 \\<in> set x) \\<and>\n             set al \\<subseteq> \\<Union> (set ` T P);\n     (al, b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     front_tickFree (a0 # al); front_tickFree al; a0 \\<noteq> tick\\<rbrakk>\n    \\<Longrightarrow> a0 = tick \\<and> al = [] \\<or>\n                      a0 \\<in> ev ` A \\<and> (\\<exists>a. ev a = a0)", "apply (metis append.simps(2) front_tickFree_charn \n                    front_tickFree_mono list.distinct(1) tickFree_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>x\\<in>T P. a0 \\<in> set x) \\<and>\n             set al \\<subseteq> \\<Union> (set ` T P);\n     (al, b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     front_tickFree (a0 # al); front_tickFree al; a0 \\<noteq> tick\\<rbrakk>\n    \\<Longrightarrow> a0 = tick \\<and> al = [] \\<or>\n                      a0 \\<in> ev ` A \\<and> (\\<exists>a. ev a = a0)", "using event_set image_iff as[simplified events_of_def]"], ["proof (prove)\nusing this:\n  ?e \\<in> insert tick (range ev)\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  (\\<Union>t\\<in>T P. {a. ev a \\<in> set t}) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>x\\<in>T P. a0 \\<in> set x) \\<and>\n             set al \\<subseteq> \\<Union> (set ` T P);\n     (al, b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n     front_tickFree (a0 # al); front_tickFree al; a0 \\<noteq> tick\\<rbrakk>\n    \\<Longrightarrow> a0 = tick \\<and> al = [] \\<or>\n                      a0 \\<in> ev ` A \\<and> (\\<exists>a. ev a = a0)", "by fastforce"], ["proof (state)\nthis:\n  (a0 # al, b) \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>front_tickFree ?a;\n   set ?a \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b)\n                    \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F P", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>front_tickFree ?a;\n   set ?a \\<subseteq> \\<Union> (set ` T P)\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b)\n                    \\<in> F (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F P", "by (simp add: F_T SUP_upper failure_refine_def process_charn subrelI)"], ["proof (state)\nthis:\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F P\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_failures_ev: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P (events_of P) \\<sqsubseteq>\\<^sub>F P\" \n      and CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_failures_Un: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV \\<sqsubseteq>\\<^sub>F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n     (events_of P) \\<sqsubseteq>\\<^sub>F\n    P &&&\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV \\<sqsubseteq>\\<^sub>F P", "by (simp_all add: CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_failures)"], ["", "lemma DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF_refine_F: \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>F DF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F DF A", "by (simp add:DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def, rule fix_ind, simp_all add:le_F_adm monofunI, subst DF_unfold, simp)"], ["", "lemma DF_RUN_refine_F: \"DF A  \\<sqsubseteq>\\<^sub>F RUN A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DF A \\<sqsubseteq>\\<^sub>F RUN A", "apply (simp add:DF_def, rule fix_ind, simp_all add:le_F_adm monofunI, subst RUN_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq>\\<^sub>F RUN A \\<Longrightarrow>\n       (\\<sqinter>xa\\<in>A \\<rightarrow>  x) \\<sqsubseteq>\\<^sub>F\n       Mprefix A (\\<lambda>z. RUN A)", "by (meson Mprefix_refines_Mndet_F mono_mndet_F_process trans_F)"], ["", "lemma CHAOS_DF_refine_F: \"CHAOS A  \\<sqsubseteq>\\<^sub>F DF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS A \\<sqsubseteq>\\<^sub>F DF A", "apply (simp add:CHAOS_def DF_def, rule parallel_fix_ind, simp_all add: monofunI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. adm (\\<lambda>x. fst x \\<sqsubseteq>\\<^sub>F snd x)\n 2. \\<And>x y.\n       x \\<sqsubseteq>\\<^sub>F y \\<Longrightarrow>\n       (STOP |-| Mprefix A (\\<lambda>xa. x)) \\<sqsubseteq>\\<^sub>F\n       (\\<sqinter>x\\<in>A \\<rightarrow>  y)", "apply (rule le_F_adm, simp_all add: monofun_snd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq>\\<^sub>F y \\<Longrightarrow>\n       (STOP |-| Mprefix A (\\<lambda>xa. x)) \\<sqsubseteq>\\<^sub>F\n       (\\<sqinter>x\\<in>A \\<rightarrow>  y)", "by (cases \"A={}\", auto simp add:adm_def failure_refine_def F_mndet \n                                  F_Mprefix write0_def F_ndet F_STOP)"], ["", "corollary CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_CHAOS_refine_F: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>F CHAOS A\"\n      and CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_refine_F: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>F DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\n    CHAOS A &&&\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\n    DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "by (simp_all add: CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_failures events_CHAOS events_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P \n                    trans_F[OF CHAOS_DF_refine_F DF_RUN_refine_F])"], ["", "lemma div_free_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"D(DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}", "proof(simp add:DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def fix_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "define Y where \"Y \\<equiv> \\<lambda>i. iterate i\\<cdot>(\\<Lambda> x. (\\<sqinter>xa\\<in>A \\<rightarrow>  x) \\<sqinter> SKIP)\\<cdot>\\<bottom>\""], ["proof (state)\nthis:\n  Y \\<equiv>\n  \\<lambda>i.\n     iterate i\\<cdot>\n     (\\<Lambda> x. (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n     \\<bottom>\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "hence a:\"chain Y\""], ["proof (prove)\nusing this:\n  Y \\<equiv>\n  \\<lambda>i.\n     iterate i\\<cdot>\n     (\\<Lambda> x. (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n     \\<bottom>\n\ngoal (1 subgoal):\n 1. chain Y", "by simp"], ["proof (state)\nthis:\n  chain Y\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "have \"D (Y (Suc i)) = {d. d \\<noteq> [] \\<and> hd d  \\<in> (ev ` A) \\<and> tl d \\<in> D(Y i)}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. D (Y (Suc i)) =\n    {d. d \\<noteq> [] \\<and> hd d \\<in> ev ` A \\<and> tl d \\<in> D (Y i)}", "by (cases \"A={}\", auto simp add:Y_def D_STOP D_SKIP D_mndet write0_def D_Mprefix D_ndet)"], ["proof (state)\nthis:\n  D (Y (Suc ?i)) =\n  {d. d \\<noteq> [] \\<and> hd d \\<in> ev ` A \\<and> tl d \\<in> D (Y ?i)}\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "hence b:\"d \\<in> D(Y i) \\<Longrightarrow> length d \\<ge> i\" for d i"], ["proof (prove)\nusing this:\n  D (Y (Suc ?i)) =\n  {d. d \\<noteq> [] \\<and> hd d \\<in> ev ` A \\<and> tl d \\<in> D (Y ?i)}\n\ngoal (1 subgoal):\n 1. d \\<in> D (Y i) \\<Longrightarrow> i \\<le> length d", "by (induct i arbitrary:d, simp_all add: Nitpick.size_list_simp(2))"], ["proof (state)\nthis:\n  ?d \\<in> D (Y ?i) \\<Longrightarrow> ?i \\<le> length ?d\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "{"], ["proof (state)\nthis:\n  ?d \\<in> D (Y ?i) \\<Longrightarrow> ?i \\<le> length ?d\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "assume c:\"\\<forall> i. x \\<in> D (Y i)\""], ["proof (state)\nthis:\n  \\<forall>i. x \\<in> D (Y i)\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "from b"], ["proof (chain)\npicking this:\n  ?d \\<in> D (Y ?i) \\<Longrightarrow> ?i \\<le> length ?d", "have \"x \\<notin> D (Y (Suc (length x)))\""], ["proof (prove)\nusing this:\n  ?d \\<in> D (Y ?i) \\<Longrightarrow> ?i \\<le> length ?d\n\ngoal (1 subgoal):\n 1. x \\<notin> D (Y (Suc (length x)))", "using Suc_n_not_le_n"], ["proof (prove)\nusing this:\n  ?d \\<in> D (Y ?i) \\<Longrightarrow> ?i \\<le> length ?d\n  \\<not> Suc ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. x \\<notin> D (Y (Suc (length x)))", "by blast"], ["proof (state)\nthis:\n  x \\<notin> D (Y (Suc (length x)))\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "with c"], ["proof (chain)\npicking this:\n  \\<forall>i. x \\<in> D (Y i)\n  x \\<notin> D (Y (Suc (length x)))", "have False"], ["proof (prove)\nusing this:\n  \\<forall>i. x \\<in> D (Y i)\n  x \\<notin> D (Y (Suc (length x)))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "}"], ["proof (state)\nthis:\n  \\<forall>i. ?x2 \\<in> D (Y i) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i.\n          iterate i\\<cdot>\n          (\\<Lambda> x.\n              (\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP)\\<cdot>\n          \\<bottom>) =\n    {}", "with a"], ["proof (chain)\npicking this:\n  chain Y\n  \\<forall>i. ?x2 \\<in> D (Y i) \\<Longrightarrow> False", "show \"D (\\<Squnion>i. Y i) = {}\""], ["proof (prove)\nusing this:\n  chain Y\n  \\<forall>i. ?x2 \\<in> D (Y i) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i. Y i) = {}", "using D_LUB[OF a] limproc_is_thelub[OF a]"], ["proof (prove)\nusing this:\n  chain Y\n  \\<forall>i. ?x2 \\<in> D (Y i) \\<Longrightarrow> False\n  D (lim_proc (range Y)) = \\<Inter> (D ` range Y)\n  Lub Y = lim_proc (range Y)\n\ngoal (1 subgoal):\n 1. D (\\<Squnion>i. Y i) = {}", "by auto"], ["proof (state)\nthis:\n  D (\\<Squnion>i. Y i) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_free_DF: \"D(DF A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (DF A) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D (DF A) = {}", "have \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>D DF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D DF A", "by (simp add:DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def, rule fix_ind, simp_all add:le_D_adm monofunI, subst DF_unfold, simp)"], ["proof (state)\nthis:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D DF A\n\ngoal (1 subgoal):\n 1. D (DF A) = {}", "then"], ["proof (chain)\npicking this:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D DF A", "show ?thesis"], ["proof (prove)\nusing this:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D DF A\n\ngoal (1 subgoal):\n 1. D (DF A) = {}", "using divergence_refine_def div_free_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P"], ["proof (prove)\nusing this:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D DF A\n  ?P \\<sqsubseteq>\\<^sub>D ?Q \\<equiv> D ?Q \\<subseteq> D ?P\n  D (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A) = {}\n\ngoal (1 subgoal):\n 1. D (DF A) = {}", "by blast"], ["proof (state)\nthis:\n  D (DF A) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_free_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P: \"D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}", "have \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>D CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "proof (simp add:DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def, rule fix_ind, simp_all add:le_D_adm monofunI, subst CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq>\\<^sub>D\n       CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<Longrightarrow>\n       ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-|\n        SKIP) \\<sqsubseteq>\\<^sub>D\n       (SKIP |-| STOP |-|\n        Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq>\\<^sub>D\n       CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<Longrightarrow>\n       ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-|\n        SKIP) \\<sqsubseteq>\\<^sub>D\n       (SKIP |-| STOP |-|\n        Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "assume 1:\"x \\<sqsubseteq>\\<^sub>D CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\""], ["proof (state)\nthis:\n  x \\<sqsubseteq>\\<^sub>D CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq>\\<^sub>D\n       CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<Longrightarrow>\n       ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-|\n        SKIP) \\<sqsubseteq>\\<^sub>D\n       (SKIP |-| STOP |-|\n        Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "have a:\"((\\<sqinter>xa\\<in>A \\<rightarrow>  x) \\<sqinter> SKIP) = (SKIP \\<sqinter> SKIP \\<sqinter> (\\<sqinter>xa\\<in>A \\<rightarrow>  x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP) =\n    (SKIP |-| SKIP |-| (\\<sqinter>xa\\<in>A \\<rightarrow>  x))", "by (simp add: Ndet_commute ndet_id)"], ["proof (state)\nthis:\n  ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP) =\n  (SKIP |-| SKIP |-| (\\<sqinter>xa\\<in>A \\<rightarrow>  x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq>\\<^sub>D\n       CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<Longrightarrow>\n       ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-|\n        SKIP) \\<sqsubseteq>\\<^sub>D\n       (SKIP |-| STOP |-|\n        Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "from 1"], ["proof (chain)\npicking this:\n  x \\<sqsubseteq>\\<^sub>D CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "have b:\"(SKIP \\<sqinter> SKIP \\<sqinter> (\\<sqinter>xa\\<in>A \\<rightarrow>  x)) \\<sqsubseteq>\\<^sub>D (SKIP \\<sqinter> STOP \\<sqinter> (\\<box>xa\\<in>A \\<rightarrow> CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq>\\<^sub>D CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\n\ngoal (1 subgoal):\n 1. (SKIP |-| SKIP |-|\n     (\\<sqinter>xa\\<in>A \\<rightarrow>  x)) \\<sqsubseteq>\\<^sub>D\n    (SKIP |-| STOP |-|\n     Mprefix A (\\<lambda>xa. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "by (meson DT_D Mprefix_refines_Mndet_D STOP_leDT idem_D \n                mono_mprefix_D_process mono_ndet_D trans_D)"], ["proof (state)\nthis:\n  (SKIP |-| SKIP |-|\n   (\\<sqinter>xa\\<in>A \\<rightarrow>  x)) \\<sqsubseteq>\\<^sub>D\n  (SKIP |-| STOP |-|\n   Mprefix A (\\<lambda>xa. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq>\\<^sub>D\n       CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<Longrightarrow>\n       ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-|\n        SKIP) \\<sqsubseteq>\\<^sub>D\n       (SKIP |-| STOP |-|\n        Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "from a b"], ["proof (chain)\npicking this:\n  ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP) =\n  (SKIP |-| SKIP |-| (\\<sqinter>xa\\<in>A \\<rightarrow>  x))\n  (SKIP |-| SKIP |-|\n   (\\<sqinter>xa\\<in>A \\<rightarrow>  x)) \\<sqsubseteq>\\<^sub>D\n  (SKIP |-| STOP |-|\n   Mprefix A (\\<lambda>xa. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "show \"((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP) \\<sqsubseteq>\\<^sub>D (SKIP |-| STOP |-| Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\""], ["proof (prove)\nusing this:\n  ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP) =\n  (SKIP |-| SKIP |-| (\\<sqinter>xa\\<in>A \\<rightarrow>  x))\n  (SKIP |-| SKIP |-|\n   (\\<sqinter>xa\\<in>A \\<rightarrow>  x)) \\<sqsubseteq>\\<^sub>D\n  (SKIP |-| STOP |-|\n   Mprefix A (\\<lambda>xa. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\n\ngoal (1 subgoal):\n 1. ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP) \\<sqsubseteq>\\<^sub>D\n    (SKIP |-| STOP |-|\n     Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))", "by simp"], ["proof (state)\nthis:\n  ((\\<sqinter>xa\\<in>A \\<rightarrow>  x) |-| SKIP) \\<sqsubseteq>\\<^sub>D\n  (SKIP |-| STOP |-|\n   Mprefix A (\\<lambda>x. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\n\ngoal (1 subgoal):\n 1. D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}", "then"], ["proof (chain)\npicking this:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "show ?thesis"], ["proof (prove)\nusing this:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\n\ngoal (1 subgoal):\n 1. D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}", "using divergence_refine_def div_free_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P"], ["proof (prove)\nusing this:\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\n  ?P \\<sqsubseteq>\\<^sub>D ?Q \\<equiv> D ?Q \\<subseteq> D ?P\n  D (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A) = {}\n\ngoal (1 subgoal):\n 1. D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}", "by blast"], ["proof (state)\nthis:\n  D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_free_CHAOS: \"D(CHAOS A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (CHAOS A) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D (CHAOS A) = {}", "have \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>D CHAOS A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D CHAOS A", "apply (simp add:CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_def, rule fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. a \\<sqsubseteq>\\<^sub>D CHAOS A)\n 2. \\<bottom> \\<sqsubseteq>\\<^sub>D CHAOS A\n 3. \\<And>x.\n       x \\<sqsubseteq>\\<^sub>D CHAOS A \\<Longrightarrow>\n       (\\<Lambda> x. SKIP |-| STOP |-| Mprefix A (\\<lambda>xa. x))\\<cdot>\n       x \\<sqsubseteq>\\<^sub>D\n       CHAOS A", "by (simp_all add:le_D_adm monofunI, subst CHAOS_unfold, simp)"], ["proof (state)\nthis:\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D CHAOS A\n\ngoal (1 subgoal):\n 1. D (CHAOS A) = {}", "then"], ["proof (chain)\npicking this:\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D CHAOS A", "show ?thesis"], ["proof (prove)\nusing this:\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D CHAOS A\n\ngoal (1 subgoal):\n 1. D (CHAOS A) = {}", "using divergence_refine_def div_free_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P"], ["proof (prove)\nusing this:\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D CHAOS A\n  ?P \\<sqsubseteq>\\<^sub>D ?Q \\<equiv> D ?Q \\<subseteq> D ?P\n  D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A) = {}\n\ngoal (1 subgoal):\n 1. D (CHAOS A) = {}", "by blast"], ["proof (state)\nthis:\n  D (CHAOS A) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_free_RUN: \"D(RUN A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (RUN A) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D (RUN A) = {}", "have \"CHAOS A  \\<sqsubseteq>\\<^sub>D RUN A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS A \\<sqsubseteq>\\<^sub>D RUN A", "by (simp add:CHAOS_def, rule fix_ind, simp_all add:le_D_adm monofunI, subst RUN_unfold, simp)"], ["proof (state)\nthis:\n  CHAOS A \\<sqsubseteq>\\<^sub>D RUN A\n\ngoal (1 subgoal):\n 1. D (RUN A) = {}", "then"], ["proof (chain)\npicking this:\n  CHAOS A \\<sqsubseteq>\\<^sub>D RUN A", "show ?thesis"], ["proof (prove)\nusing this:\n  CHAOS A \\<sqsubseteq>\\<^sub>D RUN A\n\ngoal (1 subgoal):\n 1. D (RUN A) = {}", "using divergence_refine_def div_free_CHAOS"], ["proof (prove)\nusing this:\n  CHAOS A \\<sqsubseteq>\\<^sub>D RUN A\n  ?P \\<sqsubseteq>\\<^sub>D ?Q \\<equiv> D ?Q \\<subseteq> D ?P\n  D (CHAOS ?A) = {}\n\ngoal (1 subgoal):\n 1. D (RUN A) = {}", "by blast"], ["proof (state)\nthis:\n  D (RUN A) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF_refine_FD: \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>F\\<^sub>D DF A\"\n      and DF_RUN_refine_FD: \"DF A  \\<sqsubseteq>\\<^sub>F\\<^sub>D RUN A\"\n      and CHAOS_DF_refine_FD: \"CHAOS A  \\<sqsubseteq>\\<^sub>F\\<^sub>D DF A\"\n      and CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_CHAOS_refine_FD: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>F\\<^sub>D CHAOS A\"\n      and CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_refine_FD: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A  \\<sqsubseteq>\\<^sub>F\\<^sub>D DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n     DF A &&&\n     DF A \\<sqsubseteq>\\<^sub>F\\<^sub>D RUN A) &&&\n    CHAOS A \\<sqsubseteq>\\<^sub>F\\<^sub>D DF A &&&\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n    CHAOS A &&&\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n    DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "using div_free_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P[of A] div_free_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P[of A] div_free_DF[of A] div_free_RUN[of A] \n        div_free_CHAOS[of A] \n        F_D_FD[OF DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF_refine_F, of A] F_D_FD[OF DF_RUN_refine_F, of A] \n        F_D_FD[OF CHAOS_DF_refine_F, of A] F_D_FD[OF CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_CHAOS_refine_F, of A] \n        F_D_FD[OF CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_refine_F, of A]"], ["proof (prove)\nusing this:\n  D (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}\n  D (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {}\n  D (DF A) = {}\n  D (RUN A) = {}\n  D (CHAOS A) = {}\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n  DF A \\<Longrightarrow>\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D DF A\n  DF A \\<sqsubseteq>\\<^sub>D RUN A \\<Longrightarrow>\n  DF A \\<sqsubseteq>\\<^sub>F\\<^sub>D RUN A\n  CHAOS A \\<sqsubseteq>\\<^sub>D DF A \\<Longrightarrow>\n  CHAOS A \\<sqsubseteq>\\<^sub>F\\<^sub>D DF A\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n  CHAOS A \\<Longrightarrow>\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n  CHAOS A\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>D\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<Longrightarrow>\n  CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A\n\ngoal (1 subgoal):\n 1. (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n     DF A &&&\n     DF A \\<sqsubseteq>\\<^sub>F\\<^sub>D RUN A) &&&\n    CHAOS A \\<sqsubseteq>\\<^sub>F\\<^sub>D DF A &&&\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n    CHAOS A &&&\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A \\<sqsubseteq>\\<^sub>F\\<^sub>D\n    DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A", "by (auto simp add:divergence_refine_def)"], ["", "lemma traces_CHAOS_sub: \"T(CHAOS A) \\<subseteq> {s. set s \\<subseteq> ev ` A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (CHAOS A) \\<subseteq> {s. set s \\<subseteq> ev ` A}", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> T (CHAOS A); xa \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ev ` A", "fix s sa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> T (CHAOS A); xa \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ev ` A", "assume \"s \\<in> T (CHAOS A)\" and \"sa \\<in> set s\""], ["proof (state)\nthis:\n  s \\<in> T (CHAOS A)\n  sa \\<in> set s\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> T (CHAOS A); xa \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ev ` A", "then"], ["proof (chain)\npicking this:\n  s \\<in> T (CHAOS A)\n  sa \\<in> set s", "show \"sa \\<in> ev ` A\""], ["proof (prove)\nusing this:\n  s \\<in> T (CHAOS A)\n  sa \\<in> set s\n\ngoal (1 subgoal):\n 1. sa \\<in> ev ` A", "apply (induct s, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s.\n       \\<lbrakk>\\<lbrakk>s \\<in> T (CHAOS A); sa \\<in> set s\\<rbrakk>\n                \\<Longrightarrow> sa \\<in> ev ` A;\n        a # s \\<in> T (CHAOS A); sa \\<in> set (a # s)\\<rbrakk>\n       \\<Longrightarrow> sa \\<in> ev ` A", "by (subst (asm) (2) CHAOS_unfold, cases \"A={}\", auto simp add:T_ndet T_STOP T_Mprefix)"], ["proof (state)\nthis:\n  sa \\<in> ev ` A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma traces_RUN_sub: \"{s. set s \\<subseteq> ev ` A} \\<subseteq> T(RUN A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. set s \\<subseteq> ev ` A} \\<subseteq> T (RUN A)", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. set x \\<subseteq> ev ` A \\<Longrightarrow> x \\<in> T (RUN A)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. set x \\<subseteq> ev ` A \\<Longrightarrow> x \\<in> T (RUN A)", "assume \"set s \\<subseteq> ev ` A\""], ["proof (state)\nthis:\n  set s \\<subseteq> ev ` A\n\ngoal (1 subgoal):\n 1. \\<And>x. set x \\<subseteq> ev ` A \\<Longrightarrow> x \\<in> T (RUN A)", "then"], ["proof (chain)\npicking this:\n  set s \\<subseteq> ev ` A", "show \"s \\<in> T (RUN A)\""], ["proof (prove)\nusing this:\n  set s \\<subseteq> ev ` A\n\ngoal (1 subgoal):\n 1. s \\<in> T (RUN A)", "by (induct s, simp add: Nil_elem_T) (subst RUN_unfold, auto simp add:T_Mprefix)"], ["proof (state)\nthis:\n  s \\<in> T (RUN A)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary RUN_all_tickfree_traces1: \"T(RUN A) = {s. set s \\<subseteq> ev ` A}\" \n      and DF_all_tickfree_traces1: \"T(DF A) = {s. set s \\<subseteq> ev ` A}\" \n      and CHAOS_all_tickfree_traces1: \"T(CHAOS A) = {s. set s \\<subseteq> ev ` A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (RUN A) = {s. set s \\<subseteq> ev ` A} &&&\n    T (DF A) = {s. set s \\<subseteq> ev ` A} &&&\n    T (CHAOS A) = {s. set s \\<subseteq> ev ` A}", "using DF_RUN_refine_F[THEN le_F_T, simplified trace_refine_def]\n        CHAOS_DF_refine_F[THEN le_F_T,simplified trace_refine_def] \n        traces_CHAOS_sub traces_RUN_sub"], ["proof (prove)\nusing this:\n  T (RUN ?A1) \\<subseteq> T (DF ?A1)\n  T (DF ?A1) \\<subseteq> T (CHAOS ?A1)\n  T (CHAOS ?A) \\<subseteq> {s. set s \\<subseteq> ev ` ?A}\n  {s. set s \\<subseteq> ev ` ?A} \\<subseteq> T (RUN ?A)\n\ngoal (1 subgoal):\n 1. T (RUN A) = {s. set s \\<subseteq> ev ` A} &&&\n    T (DF A) = {s. set s \\<subseteq> ev ` A} &&&\n    T (CHAOS A) = {s. set s \\<subseteq> ev ` A}", "by blast+"], ["", "corollary RUN_all_tickfree_traces2: \"tickFree s \\<Longrightarrow> s \\<in> T(RUN UNIV)\" \n      and DF_all_tickfree_traces2: \"tickFree s \\<Longrightarrow> s \\<in> T(DF UNIV)\" \n      and CHAOS_all_tickfree_trace2: \"tickFree s \\<Longrightarrow> s \\<in> T(CHAOS UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tickFree s \\<Longrightarrow> s \\<in> T (RUN UNIV)) &&&\n    (tickFree s \\<Longrightarrow> s \\<in> T (DF UNIV)) &&&\n    (tickFree s \\<Longrightarrow> s \\<in> T (CHAOS UNIV))", "apply(simp_all add:tickFree_def RUN_all_tickfree_traces1 \n                       DF_all_tickfree_traces1 CHAOS_all_tickfree_traces1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. tick \\<notin> set s \\<Longrightarrow> set s \\<subseteq> range ev\n 2. tick \\<notin> set s \\<Longrightarrow> set s \\<subseteq> range ev\n 3. tick \\<notin> set s \\<Longrightarrow> set s \\<subseteq> range ev", "by (metis event_set insertE subsetI)+"], ["", "lemma traces_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_sub: \"T(CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) \\<subseteq> {s. front_tickFree s \\<and> set s \\<subseteq> (ev ` A \\<union> {tick})}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n    \\<subseteq> {s. front_tickFree s \\<and>\n                    set s \\<subseteq> ev ` A \\<union> {tick}}", "proof(auto simp add:is_processT2_TR)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        xa \\<in> set x; xa \\<notin> ev ` A\\<rbrakk>\n       \\<Longrightarrow> xa = tick", "fix s sa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        xa \\<in> set x; xa \\<notin> ev ` A\\<rbrakk>\n       \\<Longrightarrow> xa = tick", "assume \"s \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\" and \"sa \\<in> set s\" and \"sa \\<notin> ev ` A\""], ["proof (state)\nthis:\n  s \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  sa \\<in> set s\n  sa \\<notin> ev ` A\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        xa \\<in> set x; xa \\<notin> ev ` A\\<rbrakk>\n       \\<Longrightarrow> xa = tick", "then"], ["proof (chain)\npicking this:\n  s \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  sa \\<in> set s\n  sa \\<notin> ev ` A", "show \"sa = tick\""], ["proof (prove)\nusing this:\n  s \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n  sa \\<in> set s\n  sa \\<notin> ev ` A\n\ngoal (1 subgoal):\n 1. sa = tick", "apply (induct s, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s.\n       \\<lbrakk>\\<lbrakk>s \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P\n                                     A);\n                 sa \\<in> set s; sa \\<notin> ev ` A\\<rbrakk>\n                \\<Longrightarrow> sa = tick;\n        a # s \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        sa \\<in> set (a # s); sa \\<notin> ev ` A\\<rbrakk>\n       \\<Longrightarrow> sa = tick", "by (subst (asm) (2) CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold, cases \"A={}\", auto simp add:T_ndet T_STOP T_SKIP T_Mprefix)"], ["proof (state)\nthis:\n  sa = tick\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma traces_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_sub: \n                      \"{s. front_tickFree s \\<and> set s \\<subseteq> (ev ` A \\<union> {tick})} \\<subseteq> T(DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A::'a process)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. front_tickFree s \\<and> set s \\<subseteq> ev ` A \\<union> {tick}}\n    \\<subseteq> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>front_tickFree x;\n        set x \\<subseteq> insert tick (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>front_tickFree x;\n        set x \\<subseteq> insert tick (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "assume a:\"front_tickFree s\" and b:\"set s \\<subseteq> insert tick (ev ` A)\""], ["proof (state)\nthis:\n  front_tickFree s\n  set s \\<subseteq> insert tick (ev ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>front_tickFree x;\n        set x \\<subseteq> insert tick (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "have c:\"front_tickFree ((tick::'a event) # s) \\<Longrightarrow> s = []\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree (tick # s) \\<Longrightarrow> s = []", "by (metis butlast.simps(2) butlast_snoc front_tickFree_charn list.distinct(1) tickFree_Cons)"], ["proof (state)\nthis:\n  front_tickFree (tick # ?s) \\<Longrightarrow> ?s = []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>front_tickFree x;\n        set x \\<subseteq> insert tick (ev ` A)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "with a b"], ["proof (chain)\npicking this:\n  front_tickFree s\n  set s \\<subseteq> insert tick (ev ` A)\n  front_tickFree (tick # ?s) \\<Longrightarrow> ?s = []", "show \"s \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\""], ["proof (prove)\nusing this:\n  front_tickFree s\n  set s \\<subseteq> insert tick (ev ` A)\n  front_tickFree (tick # ?s) \\<Longrightarrow> ?s = []\n\ngoal (1 subgoal):\n 1. s \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)", "apply (induct s, simp add: Nil_elem_T, subst DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold, cases \"A={}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a sa.\n       \\<lbrakk>\\<lbrakk>front_tickFree sa;\n                 set sa \\<subseteq> insert tick (ev ` A);\n                 \\<And>s.\n                    front_tickFree (tick # s) \\<Longrightarrow>\n                    s = []\\<rbrakk>\n                \\<Longrightarrow> sa \\<in> T\n      (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a # sa);\n        set (a # sa) \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        A = {}\\<rbrakk>\n       \\<Longrightarrow> a # sa\n                         \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \nDF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n                                  SKIP)\n 2. \\<And>a sa.\n       \\<lbrakk>\\<lbrakk>front_tickFree sa;\n                 set sa \\<subseteq> insert tick (ev ` A);\n                 \\<And>s.\n                    front_tickFree (tick # s) \\<Longrightarrow>\n                    s = []\\<rbrakk>\n                \\<Longrightarrow> sa \\<in> T\n      (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a # sa);\n        set (a # sa) \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> a # sa\n                         \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \nDF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n                                  SKIP)", "apply (subst DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_unfold, cases \"A={}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a sa.\n       \\<lbrakk>\\<lbrakk>front_tickFree sa;\n                 set sa \\<subseteq> insert tick (ev ` A);\n                 \\<And>s.\n                    front_tickFree (tick # s) \\<Longrightarrow>\n                    s = []\\<rbrakk>\n                \\<Longrightarrow> sa \\<in> T\n      (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a # sa);\n        set (a # sa) \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = []; A = {};\n        A = {}\\<rbrakk>\n       \\<Longrightarrow> a # sa\n                         \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \n(\\<sqinter>z\\<in>A \\<rightarrow>  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\nSKIP) |-|\n                                  SKIP)\n 2. \\<And>a sa.\n       \\<lbrakk>\\<lbrakk>front_tickFree sa;\n                 set sa \\<subseteq> insert tick (ev ` A);\n                 \\<And>s.\n                    front_tickFree (tick # s) \\<Longrightarrow>\n                    s = []\\<rbrakk>\n                \\<Longrightarrow> sa \\<in> T\n      (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a # sa);\n        set (a # sa) \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = []; A = {};\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> a # sa\n                         \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \n(\\<sqinter>z\\<in>A \\<rightarrow>  DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\nSKIP) |-|\n                                  SKIP)\n 3. \\<And>a sa.\n       \\<lbrakk>\\<lbrakk>front_tickFree sa;\n                 set sa \\<subseteq> insert tick (ev ` A);\n                 \\<And>s.\n                    front_tickFree (tick # s) \\<Longrightarrow>\n                    s = []\\<rbrakk>\n                \\<Longrightarrow> sa \\<in> T\n      (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A);\n        front_tickFree (a # sa);\n        set (a # sa) \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        front_tickFree s; set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> a # sa\n                         \\<in> T ((\\<sqinter>z\\<in>A \\<rightarrow> \nDF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) |-|\n                                  SKIP)", "apply(auto simp add:T_Mprefix T_mndet write0_def T_SKIP T_ndet T_STOP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa x xa.\n       \\<lbrakk>front_tickFree sa \\<Longrightarrow> False;\n        front_tickFree (ev xa # sa); front_tickFree s;\n        set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        set sa \\<subseteq> insert tick (ev ` A); x \\<in> A; xa \\<in> A;\n        sa \\<notin> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>sa x xa.\n       \\<lbrakk>front_tickFree sa \\<Longrightarrow> False;\n        front_tickFree (ev xa # sa); front_tickFree s;\n        set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        set sa \\<subseteq> insert tick (ev ` A); x \\<in> A; xa \\<in> A;\n        sa \\<notin> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\\<rbrakk>\n       \\<Longrightarrow> sa = []", "apply (metis append_Cons append_Nil front_tickFree_charn front_tickFree_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa x xa.\n       \\<lbrakk>front_tickFree sa \\<Longrightarrow> False;\n        front_tickFree (ev xa # sa); front_tickFree s;\n        set s \\<subseteq> insert tick (ev ` A);\n        \\<And>s. front_tickFree (tick # s) \\<Longrightarrow> s = [];\n        set sa \\<subseteq> insert tick (ev ` A); x \\<in> A; xa \\<in> A;\n        sa \\<notin> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\\<rbrakk>\n       \\<Longrightarrow> sa = []", "by (metis append_Cons append_Nil front_tickFree_mono)"], ["proof (state)\nthis:\n  s \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces1: \n                              \"T(DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {s. front_tickFree s \\<and> set s \\<subseteq> (ev ` A \\<union> {tick})}\" \n      and CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces1: \n                              \"T(CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) = {s. front_tickFree s \\<and> set s \\<subseteq> (ev ` A \\<union> {tick})}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) =\n    {s. front_tickFree s \\<and>\n        set s \\<subseteq> ev ` A \\<union> {tick}} &&&\n    T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) =\n    {s. front_tickFree s \\<and> set s \\<subseteq> ev ` A \\<union> {tick}}", "using CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_refine_F[THEN le_F_T, simplified trace_refine_def]\n        traces_CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_sub traces_DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_sub"], ["proof (prove)\nusing this:\n  T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A1)\n  \\<subseteq> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A1)\n  T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A)\n  \\<subseteq> {s. front_tickFree s \\<and>\n                  set s \\<subseteq> ev ` ?A \\<union> {tick}}\n  {s. front_tickFree s \\<and> set s \\<subseteq> ev ` ?A \\<union> {tick}}\n  \\<subseteq> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P ?A)\n\ngoal (1 subgoal):\n 1. T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) =\n    {s. front_tickFree s \\<and>\n        set s \\<subseteq> ev ` A \\<union> {tick}} &&&\n    T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P A) =\n    {s. front_tickFree s \\<and> set s \\<subseteq> ev ` A \\<union> {tick}}", "by blast+"], ["", "corollary DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces2: \"front_tickFree s \\<Longrightarrow> s \\<in> T(DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV)\" \n      and CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces2: \"front_tickFree s \\<Longrightarrow> s \\<in> T(CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (front_tickFree s \\<Longrightarrow>\n     s \\<in> T (DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV)) &&&\n    (front_tickFree s \\<Longrightarrow>\n     s \\<in> T (CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV))", "apply(simp_all add:tickFree_def DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces1 \n                      CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. front_tickFree s \\<Longrightarrow>\n    set s \\<subseteq> insert tick (range ev)\n 2. front_tickFree s \\<Longrightarrow>\n    set s \\<subseteq> insert tick (range ev)", "by (metis event_set subsetI)+"], ["", "corollary DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_traces: \"DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV \\<sqsubseteq>\\<^sub>T P\"\n      and CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_has_all_traces: \"CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV \\<sqsubseteq>\\<^sub>T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV \\<sqsubseteq>\\<^sub>T P &&&\n    CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV \\<sqsubseteq>\\<^sub>T P", "apply (simp add:trace_refine_def DF\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces2 is_processT2_TR subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P UNIV \\<sqsubseteq>\\<^sub>T P", "by (simp add:trace_refine_def CHAOS\\<^sub>S\\<^sub>K\\<^sub>I\\<^sub>P_all_front_tickfree_traces2 is_processT2_TR subsetI)"], ["", "end"]]}