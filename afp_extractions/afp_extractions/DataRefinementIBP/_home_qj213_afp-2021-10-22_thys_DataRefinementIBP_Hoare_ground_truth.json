{"file_name": "/home/qj213/afp-2021-10-22/thys/DataRefinementIBP/Hoare.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DataRefinementIBP", "problem_names": ["theorem hoare_sequential:\n  \"mono S \\<Longrightarrow> (\\<Turnstile> p {| S o T |} r) = ( (\\<exists> q. \\<Turnstile> p {| S |} q \\<and> \\<Turnstile> q {| T |} r))\"", "theorem hoare_choice:\n  \"\\<Turnstile> p {| S \\<sqinter> T |} q = (\\<Turnstile> p {| S |} q \\<and> \\<Turnstile> p {| T |} q)\"", "theorem hoare_assume:\n  \"(\\<Turnstile> P {| [.R.] |} Q) = (P \\<sqinter> R \\<le> Q)\"", "theorem hoare_mono:\n  \"mono S \\<Longrightarrow> Q \\<le> R \\<Longrightarrow> \\<Turnstile> P {| S |} Q \\<Longrightarrow> \\<Turnstile> P {| S |} R\"", "theorem hoare_pre:\n  \"R \\<le> P \\<Longrightarrow> \\<Turnstile> P {| S |} Q \\<Longrightarrow> \\<Turnstile> R {| S |} Q\"", "theorem hoare_Sup:\n  \"(\\<forall> p \\<in> P . \\<Turnstile> p {| S |} q) = \\<Turnstile> Sup P {| S |} q\"", "lemma hoare_magic [simp]: \"\\<Turnstile> P {| \\<top> |} Q\"", "lemma hoare_demonic: \"\\<Turnstile> P {| [:R:] |} Q = (\\<forall> s . s \\<in> P \\<longrightarrow>  R s \\<subseteq> Q)\"", "lemma hoare_not_guard:\n  \"mono (S :: (_::order_bot) \\<Rightarrow> _) \\<Longrightarrow> \\<Turnstile> p {| S |} q = \\<Turnstile> (p \\<squnion> (- grd S)) {| S |} q\"", "theorem lfp_wf_induction:\n  \"mono f \\<Longrightarrow> (\\<forall> w . (p w) \\<le> f (Sup_less p w)) \\<Longrightarrow> Sup (range p) \\<le> lfp f\"", "lemma post_mono [simp]: \"mono (post_fun p :: (_::{order_bot,order_top}))\"", "lemma post_top [simp]: \"post_fun p p = \\<top>\"", "lemma post_refin [simp]: \"mono S \\<Longrightarrow> ((S p)::'a::bounded_lattice) \\<sqinter> (post_fun p) x \\<le> S x\"", "theorem hoare_refinement_post:\n  \"mono f \\<Longrightarrow>  (\\<Turnstile> x {| f |} y) = ({.x.} o (post_fun y) \\<le> f)\"", "lemma assert_Sup: \"{.\\<Squnion> (X::'a::complete_distrib_lattice set).} = \\<Squnion> (assert ` X)\"", "lemma assert_Sup_range: \"{.\\<Squnion> (range (p::'W \\<Rightarrow> 'a::complete_distrib_lattice)).} = \\<Squnion> (range (assert o p))\"", "lemma Sup_range_comp: \"(\\<Squnion> range p) o S = \\<Squnion> (range (\\<lambda> w . ((p w) o S)))\"", "lemma Sup_less_comp: \"(Sup_less P) w o S = Sup_less (\\<lambda> w . ((P w) o S)) w\"", "lemma Sup_less_assert: \"Sup_less (\\<lambda>w. {. (p w)::'a::complete_distrib_lattice .}) w = {.Sup_less p w.}\"", "theorem hoare_fixpoint:\n  \"mono_mono F \\<Longrightarrow>\n   (!! w f . mono f \\<and> \\<Turnstile> Sup_less p w {| f |} y \\<Longrightarrow> \\<Turnstile> p w {| F f |} y) \\<Longrightarrow> \\<Turnstile> (Sup (range p)) {| lfp F |} y\"", "theorem \"(\\<forall> t . \\<Turnstile> ({s . t \\<in> R s}) {|S|} q) \\<Longrightarrow> \\<Turnstile> ({:R:} p) {| S |} q\""], "translations": [["", "theorem hoare_sequential:\n  \"mono S \\<Longrightarrow> (\\<Turnstile> p {| S o T |} r) = ( (\\<exists> q. \\<Turnstile> p {| S |} q \\<and> \\<Turnstile> q {| T |} r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono S \\<Longrightarrow>\n    \\<Turnstile> p{| S \\<circ> T |}r =\n    (\\<exists>q. \\<Turnstile> p{| S |}q \\<and> \\<Turnstile> q{| T |}r)", "by (metis (no_types) Hoare_def monoD o_def order_refl order_trans)"], ["", "theorem hoare_choice:\n  \"\\<Turnstile> p {| S \\<sqinter> T |} q = (\\<Turnstile> p {| S |} q \\<and> \\<Turnstile> p {| T |} q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> p{| S \\<sqinter> T |}q =\n    (\\<Turnstile> p{| S |}q \\<and> \\<Turnstile> p{| T |}q)", "by (simp_all add: Hoare_def inf_fun_def)"], ["", "theorem hoare_assume:\n  \"(\\<Turnstile> P {| [.R.] |} Q) = (P \\<sqinter> R \\<le> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> P{| [. R .] |}Q = (P \\<sqinter> R \\<sqsubseteq> Q)", "apply (simp add: Hoare_def assume_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<sqsubseteq> - R \\<squnion> Q) = (P \\<sqinter> R \\<sqsubseteq> Q)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. P \\<sqsubseteq> - R \\<squnion> Q \\<Longrightarrow>\n    P \\<sqinter> R \\<sqsubseteq> Q\n 2. P \\<sqinter> R \\<sqsubseteq> Q \\<Longrightarrow>\n    P \\<sqsubseteq> - R \\<squnion> Q", "apply (case_tac \"(inf P R) \\<le> (inf (sup (- R) Q) R)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P \\<sqsubseteq> - R \\<squnion> Q;\n     P \\<sqinter> R \\<sqsubseteq> (- R \\<squnion> Q) \\<sqinter> R\\<rbrakk>\n    \\<Longrightarrow> P \\<sqinter> R \\<sqsubseteq> Q\n 2. \\<lbrakk>P \\<sqsubseteq> - R \\<squnion> Q;\n     \\<not> P \\<sqinter> R \\<sqsubseteq>\n            (- R \\<squnion> Q) \\<sqinter> R\\<rbrakk>\n    \\<Longrightarrow> P \\<sqinter> R \\<sqsubseteq> Q\n 3. P \\<sqinter> R \\<sqsubseteq> Q \\<Longrightarrow>\n    P \\<sqsubseteq> - R \\<squnion> Q", "apply (simp add: inf_sup_distrib2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<sqsubseteq> - R \\<squnion> Q;\n     \\<not> P \\<sqinter> R \\<sqsubseteq>\n            (- R \\<squnion> Q) \\<sqinter> R\\<rbrakk>\n    \\<Longrightarrow> P \\<sqinter> R \\<sqsubseteq> Q\n 2. P \\<sqinter> R \\<sqsubseteq> Q \\<Longrightarrow>\n    P \\<sqsubseteq> - R \\<squnion> Q", "apply (simp add: le_infI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqinter> R \\<sqsubseteq> Q \\<Longrightarrow>\n    P \\<sqsubseteq> - R \\<squnion> Q", "apply (case_tac \"(sup (-R) (inf P R)) \\<le> sup (- R) Q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<sqinter> R \\<sqsubseteq> Q;\n     - R \\<squnion> P \\<sqinter> R \\<sqsubseteq> - R \\<squnion> Q\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> - R \\<squnion> Q\n 2. \\<lbrakk>P \\<sqinter> R \\<sqsubseteq> Q;\n     \\<not> - R \\<squnion> P \\<sqinter> R \\<sqsubseteq>\n            - R \\<squnion> Q\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> - R \\<squnion> Q", "apply (simp add: sup_inf_distrib1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqinter> R \\<sqsubseteq> Q;\n     \\<not> - R \\<squnion> P \\<sqinter> R \\<sqsubseteq>\n            - R \\<squnion> Q\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> - R \\<squnion> Q", "by (simp add: le_supI2)"], ["", "theorem hoare_mono:\n  \"mono S \\<Longrightarrow> Q \\<le> R \\<Longrightarrow> \\<Turnstile> P {| S |} Q \\<Longrightarrow> \\<Turnstile> P {| S |} R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; Q \\<sqsubseteq> R; \\<Turnstile> P{| S |}Q\\<rbrakk>\n    \\<Longrightarrow> \\<Turnstile> P{| S |}R", "apply (simp add: mono_def Hoare_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y.\n                x \\<sqsubseteq> y \\<longrightarrow> S x \\<sqsubseteq> S y;\n     Q \\<sqsubseteq> R; P \\<sqsubseteq> S Q\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> S R", "apply (rule_tac y = \"S Q\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x y.\n                x \\<sqsubseteq> y \\<longrightarrow> S x \\<sqsubseteq> S y;\n     Q \\<sqsubseteq> R; P \\<sqsubseteq> S Q\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> S Q\n 2. \\<lbrakk>\\<forall>x y.\n                x \\<sqsubseteq> y \\<longrightarrow> S x \\<sqsubseteq> S y;\n     Q \\<sqsubseteq> R; P \\<sqsubseteq> S Q\\<rbrakk>\n    \\<Longrightarrow> S Q \\<sqsubseteq> S R", "by auto"], ["", "theorem hoare_pre:\n  \"R \\<le> P \\<Longrightarrow> \\<Turnstile> P {| S |} Q \\<Longrightarrow> \\<Turnstile> R {| S |} Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<sqsubseteq> P; \\<Turnstile> P{| S |}Q\\<rbrakk>\n    \\<Longrightarrow> \\<Turnstile> R{| S |}Q", "by (simp add: Hoare_def)"], ["", "theorem hoare_Sup:\n  \"(\\<forall> p \\<in> P . \\<Turnstile> p {| S |} q) = \\<Turnstile> Sup P {| S |} q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>P. \\<Turnstile> p{| S |}q) =\n    \\<Turnstile> \\<Squnion>P{| S |}q", "apply (simp add: Hoare_def, safe, simp add: Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<Squnion>P \\<sqsubseteq> S q; p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> p \\<sqsubseteq> S q", "apply (rule_tac y = \"\\<Squnion>P\" in order_trans, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<Squnion>P \\<sqsubseteq> S q; p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> p \\<sqsubseteq> \\<Squnion>P", "by (simp add: Sup_upper)"], ["", "lemma hoare_magic [simp]: \"\\<Turnstile> P {| \\<top> |} Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> P{| \\<top> |}Q", "by (simp add: Hoare_def top_fun_def)"], ["", "lemma hoare_demonic: \"\\<Turnstile> P {| [:R:] |} Q = (\\<forall> s . s \\<in> P \\<longrightarrow>  R s \\<subseteq> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> P{| [: R :] |}Q =\n    (\\<forall>s. s \\<in> P \\<longrightarrow> R s \\<subseteq> Q)", "apply (unfold Hoare_def demonic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<subseteq> {s. R s \\<subseteq> Q}) =\n    (\\<forall>s. s \\<in> P \\<longrightarrow> R s \\<subseteq> Q)", "by auto"], ["", "lemma hoare_not_guard:\n  \"mono (S :: (_::order_bot) \\<Rightarrow> _) \\<Longrightarrow> \\<Turnstile> p {| S |} q = \\<Turnstile> (p \\<squnion> (- grd S)) {| S |} q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono S \\<Longrightarrow>\n    \\<Turnstile> p{| S |}q = \\<Turnstile> p \\<squnion> - grd S{| S |}q", "apply (simp add: Hoare_def grd_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; p \\<sqsubseteq> S q\\<rbrakk>\n    \\<Longrightarrow> S \\<bottom> \\<sqsubseteq> S q", "apply (drule monoD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<sqsubseteq> S q \\<Longrightarrow> ?x3 \\<sqsubseteq> ?y3\n 2. \\<lbrakk>p \\<sqsubseteq> S q; S ?x3 \\<sqsubseteq> S ?y3\\<rbrakk>\n    \\<Longrightarrow> S \\<bottom> \\<sqsubseteq> S q", "by auto"], ["", "subsection \\<open>Hoare rule for recursive statements\\<close>"], ["", "text \\<open>\nA statement $S$ is refined by another statement $S'$ if $\\models p \\{| S' |\\} q$ \nis true for all $p$ and $q$ such that  $\\models p \\{| S |\\} q$ is true. This\nis equivalent to $S \\le S'$. \n\nNext theorem can be used to prove refinement of a recursive program. A recursive\nprogram is modeled as the least fixpoint of a monotonic mapping from predicate\ntransformers to predicate transformers.\n\\<close>"], ["", "theorem lfp_wf_induction:\n  \"mono f \\<Longrightarrow> (\\<forall> w . (p w) \\<le> f (Sup_less p w)) \\<Longrightarrow> Sup (range p) \\<le> lfp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; \\<forall>w. p w \\<sqsubseteq> f (Sup_less p w)\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion>range p \\<sqsubseteq> lfp f", "apply (rule fp_wf_induction, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; \\<forall>w. p w \\<sqsubseteq> f (Sup_less p w)\\<rbrakk>\n    \\<Longrightarrow> f (lfp f) = lfp f", "by (drule lfp_unfold, simp)"], ["", "definition\n  \"post_fun (p::'a::order) q = (if p \\<le> q then \\<top> else \\<bottom>)\""], ["", "lemma post_mono [simp]: \"mono (post_fun p :: (_::{order_bot,order_top}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (post_fun p)", "apply (simp add: post_fun_def  mono_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>p \\<sqsubseteq> x; \\<not> p \\<sqsubseteq> y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> \\<top> \\<sqsubseteq> \\<bottom>", "apply (subgoal_tac \"p \\<le> y\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>p \\<sqsubseteq> x; \\<not> p \\<sqsubseteq> y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> p \\<sqsubseteq> y", "by (rule_tac y = x in order_trans, simp_all)"], ["", "lemma post_top [simp]: \"post_fun p p = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post_fun p p = \\<top>", "by (simp add: post_fun_def)"], ["", "lemma post_refin [simp]: \"mono S \\<Longrightarrow> ((S p)::'a::bounded_lattice) \\<sqinter> (post_fun p) x \\<le> S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono S \\<Longrightarrow> S p \\<sqinter> post_fun p x \\<sqsubseteq> S x", "apply (simp add: le_fun_def post_fun_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; p \\<sqsubseteq> x\\<rbrakk>\n    \\<Longrightarrow> S p \\<sqsubseteq> S x", "by (rule_tac f = S in monoD, simp_all)"], ["", "text \\<open>\nNext theorem shows the equivalence between the validity of Hoare\ntriples and refinement statements. This theorem together with the\ntheorem for refinement of recursive programs will be used to prove\na Hoare rule for recursive programs.\n\\<close>"], ["", "theorem hoare_refinement_post:\n  \"mono f \\<Longrightarrow>  (\\<Turnstile> x {| f |} y) = ({.x.} o (post_fun y) \\<le> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    \\<Turnstile> x{| f |}y = ({. x .} \\<circ> post_fun y \\<sqsubseteq> f)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono f; \\<Turnstile> x{| f |}y\\<rbrakk>\n    \\<Longrightarrow> {. x .} \\<circ> post_fun y \\<sqsubseteq> f\n 2. \\<lbrakk>mono f; {. x .} \\<circ> post_fun y \\<sqsubseteq> f\\<rbrakk>\n    \\<Longrightarrow> \\<Turnstile> x{| f |}y", "apply (simp_all add: Hoare_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono f; x \\<sqsubseteq> f y\\<rbrakk>\n    \\<Longrightarrow> {. x .} \\<circ> post_fun y \\<sqsubseteq> f\n 2. \\<lbrakk>mono f; {. x .} \\<circ> post_fun y \\<sqsubseteq> f\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> f y", "apply (simp_all add: le_fun_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono f; x \\<sqsubseteq> f y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         {. x .} (post_fun y xa) \\<sqsubseteq> f xa\n 2. \\<lbrakk>mono f;\n     \\<forall>xa. {. x .} (post_fun y xa) \\<sqsubseteq> f xa\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> f y", "apply (simp add: assert_def, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>mono f; x \\<sqsubseteq> f y\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> post_fun y xa \\<sqsubseteq> f xa\n 2. \\<lbrakk>mono f;\n     \\<forall>xa. {. x .} (post_fun y xa) \\<sqsubseteq> f xa\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> f y", "apply (rule_tac y = \"f y \\<sqinter> post_fun y xa\" in order_trans, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>mono f; x \\<sqsubseteq> f y\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> post_fun y xa \\<sqsubseteq> f y\n 2. \\<lbrakk>mono f;\n     \\<forall>xa. {. x .} (post_fun y xa) \\<sqsubseteq> f xa\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> f y", "apply (rule_tac y = \"x\" in order_trans, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f;\n     \\<forall>xa. {. x .} (post_fun y xa) \\<sqsubseteq> f xa\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> f y", "apply (simp add: assert_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f;\n     \\<forall>xa. x \\<sqinter> post_fun y xa \\<sqsubseteq> f xa\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> f y", "by (drule_tac x = \"y\" in spec, simp)"], ["", "text \\<open>\nNext theorem gives a Hoare rule for recursive programs. If we can prove correct the unfolding \nof the recursive definition applid to a program $f$, $\\models p\\ w\\ \\{| F\\  f |\\}\\  y$, assumming\nthat $f$ is correct when starting from $p\\  v$, $v<w$, $\\models SUP-L\\  p\\  w\\  \\{| f |\\}\\  y$, then\nthe recursive program is correct $\\models SUP\\ p\\ \\{| lfp\\  F |\\}\\  y$\n\\<close>"], ["", "lemma assert_Sup: \"{.\\<Squnion> (X::'a::complete_distrib_lattice set).} = \\<Squnion> (assert ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. \\<Squnion>X .} = \\<Squnion>(assert ` X)", "by (simp add: fun_eq_iff assert_def Sup_inf image_comp)"], ["", "lemma assert_Sup_range: \"{.\\<Squnion> (range (p::'W \\<Rightarrow> 'a::complete_distrib_lattice)).} = \\<Squnion> (range (assert o p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. \\<Squnion>range p .} = \\<Squnion>range (assert \\<circ> p)", "by (simp add: fun_eq_iff assert_def SUP_inf image_comp)"], ["", "lemma Sup_range_comp: \"(\\<Squnion> range p) o S = \\<Squnion> (range (\\<lambda> w . ((p w) o S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>range p \\<circ> S = (SUP w. p w \\<circ> S)", "by (simp add: fun_eq_iff image_comp)"], ["", "lemma Sup_less_comp: \"(Sup_less P) w o S = Sup_less (\\<lambda> w . ((P w) o S)) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_less P w \\<circ> S = Sup_less (\\<lambda>w. P w \\<circ> S) w", "apply (simp add: Sup_less_def fun_eq_iff, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (SUP f\\<in>{y. \\<exists>v<w. \\<forall>x. y x = P v x}. f (S x)) =\n       (SUP f\\<in>{y. \\<exists>v<w. \\<forall>x. y x = P v (S x)}. f x)", "apply (subgoal_tac \"((\\<lambda>f. f (S x)) ` {y. \\<exists>v<w. \\<forall>x. y x = P v x}) = ((\\<lambda>f. f x) ` {y. \\<exists>v<w. \\<forall>x. y x = P v (S x)})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<lambda>f. f (S x)) ` {y. \\<exists>v<w. \\<forall>x. y x = P v x} =\n       (\\<lambda>f. f x) `\n       {y. \\<exists>v<w. \\<forall>x. y x = P v (S x)} \\<Longrightarrow>\n       (SUP f\\<in>{y. \\<exists>v<w. \\<forall>x. y x = P v x}. f (S x)) =\n       (SUP f\\<in>{y. \\<exists>v<w. \\<forall>x. y x = P v (S x)}. f x)\n 2. \\<And>x.\n       (\\<lambda>f. f (S x)) ` {y. \\<exists>v<w. \\<forall>x. y x = P v x} =\n       (\\<lambda>f. f x) ` {y. \\<exists>v<w. \\<forall>x. y x = P v (S x)}", "apply (auto cong del: SUP_cong_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Sup_less_assert: \"Sup_less (\\<lambda>w. {. (p w)::'a::complete_distrib_lattice .}) w = {.Sup_less p w.}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_less (\\<lambda>w. {. p w .}) w = {. Sup_less p w .}", "apply (simp add: Sup_less_def assert_Sup image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{y. \\<exists>v<w. y = {. p v .}} =\n    \\<Squnion>{y. \\<exists>x. (\\<exists>v<w. x = p v) \\<and> y = {. x .}}", "apply (subgoal_tac \"{y. \\<exists>v<w. y = {. p v .}} = {y. \\<exists>x. (\\<exists>v<w. x = p v) \\<and> y = {. x .}}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. {y. \\<exists>v<w. y = {. p v .}} =\n    {y. \\<exists>x.\n           (\\<exists>v<w. x = p v) \\<and> y = {. x .}} \\<Longrightarrow>\n    \\<Squnion>{y. \\<exists>v<w. y = {. p v .}} =\n    \\<Squnion>{y. \\<exists>x. (\\<exists>v<w. x = p v) \\<and> y = {. x .}}\n 2. {y. \\<exists>v<w. y = {. p v .}} =\n    {y. \\<exists>x. (\\<exists>v<w. x = p v) \\<and> y = {. x .}}", "apply (auto simp add: image_def cong del: SUP_cong_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare mono_comp[simp]"], ["", "theorem hoare_fixpoint:\n  \"mono_mono F \\<Longrightarrow>\n   (!! w f . mono f \\<and> \\<Turnstile> Sup_less p w {| f |} y \\<Longrightarrow> \\<Turnstile> p w {| F f |} y) \\<Longrightarrow> \\<Turnstile> (Sup (range p)) {| lfp F |} y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono_mono F;\n     \\<And>w f.\n        mono f \\<and> \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n        \\<Turnstile> p w{| F f |}y\\<rbrakk>\n    \\<Longrightarrow> \\<Turnstile> \\<Squnion>range p{| lfp F |}y", "apply (simp add: mono_mono_def hoare_refinement_post assert_Sup_range Sup_range_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono F \\<and>\n             (\\<forall>f. mono f \\<longrightarrow> mono (F f));\n     \\<And>w f.\n        mono f \\<and> \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n        {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f\\<rbrakk>\n    \\<Longrightarrow> (SUP x. {. p x .} \\<circ> post_fun y) \\<sqsubseteq>\n                      lfp F", "apply (rule lfp_wf_induction)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono F \\<and>\n             (\\<forall>f. mono f \\<longrightarrow> mono (F f));\n     \\<And>w f.\n        mono f \\<and> \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n        {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f\\<rbrakk>\n    \\<Longrightarrow> mono F\n 2. \\<lbrakk>mono F \\<and>\n             (\\<forall>f. mono f \\<longrightarrow> mono (F f));\n     \\<And>w f.\n        mono f \\<and> \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n        {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w.\n                         {. p w .} \\<circ> post_fun y \\<sqsubseteq>\n                         F (Sup_less\n                             (\\<lambda>x. {. p x .} \\<circ> post_fun y) w)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>\\<And>w f.\n                   mono f \\<and>\n                   \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n                   {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f;\n        mono F; \\<forall>f. mono f \\<longrightarrow> mono (F f)\\<rbrakk>\n       \\<Longrightarrow> {. p w .} \\<circ> post_fun y \\<sqsubseteq>\n                         F (Sup_less\n                             (\\<lambda>x. {. p x .} \\<circ> post_fun y) w)", "apply (simp add: Sup_less_comp [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>\\<And>w f.\n                   mono f \\<and>\n                   \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n                   {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f;\n        mono F; \\<forall>f. mono f \\<longrightarrow> mono (F f)\\<rbrakk>\n       \\<Longrightarrow> {. p w .} \\<circ> post_fun y \\<sqsubseteq>\n                         F (Sup_less (\\<lambda>x. {. p x .}) w \\<circ>\n                            post_fun y)", "apply (simp add: Sup_less_assert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>\\<And>w f.\n                   mono f \\<and>\n                   \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n                   {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f;\n        mono F; \\<forall>f. mono f \\<longrightarrow> mono (F f)\\<rbrakk>\n       \\<Longrightarrow> {. p w .} \\<circ> post_fun y \\<sqsubseteq>\n                         F ({. Sup_less p w .} \\<circ> post_fun y)", "apply (drule_tac x = \"{. Sup_less p w .} \\<circ> post_fun y\" in spec, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>\\<And>w f.\n                   mono f \\<and>\n                   \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n                   {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f;\n        mono F; \\<not> mono ({. Sup_less p w .} \\<circ> post_fun y)\\<rbrakk>\n       \\<Longrightarrow> {. p w .} \\<circ> post_fun y \\<sqsubseteq>\n                         F ({. Sup_less p w .} \\<circ> post_fun y)\n 2. \\<And>w.\n       \\<lbrakk>\\<And>w f.\n                   mono f \\<and>\n                   \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n                   {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f;\n        mono F; mono (F ({. Sup_less p w .} \\<circ> post_fun y))\\<rbrakk>\n       \\<Longrightarrow> {. p w .} \\<circ> post_fun y \\<sqsubseteq>\n                         F ({. Sup_less p w .} \\<circ> post_fun y)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>\\<And>w f.\n                   mono f \\<and>\n                   \\<Turnstile> Sup_less p w{| f |}y \\<Longrightarrow>\n                   {. p w .} \\<circ> post_fun y \\<sqsubseteq> F f;\n        mono F; mono (F ({. Sup_less p w .} \\<circ> post_fun y))\\<rbrakk>\n       \\<Longrightarrow> {. p w .} \\<circ> post_fun y \\<sqsubseteq>\n                         F ({. Sup_less p w .} \\<circ> post_fun y)", "by (simp add: hoare_refinement_post)"], ["", "theorem \"(\\<forall> t . \\<Turnstile> ({s . t \\<in> R s}) {|S|} q) \\<Longrightarrow> \\<Turnstile> ({:R:} p) {| S |} q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. \\<Turnstile> {s. t \\<in> R s}{| S |}q \\<Longrightarrow>\n    \\<Turnstile> {: R :} p{| S |}q", "apply (simp add: Hoare_def angelic_def subset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t x.\n       t \\<in> R x \\<longrightarrow> x \\<in> S q \\<Longrightarrow>\n    \\<forall>x. R x \\<inter> p \\<noteq> {} \\<longrightarrow> x \\<in> S q", "by auto"], ["", "end"]]}