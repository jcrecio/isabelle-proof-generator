{"file_name": "/home/qj213/afp-2021-10-22/thys/DataRefinementIBP/Statements.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DataRefinementIBP", "problem_names": ["lemma mono_top[simp]: \"mono top\"", "lemma mono_choice[simp]: \"mono S \\<Longrightarrow> mono T \\<Longrightarrow> mono (S \\<sqinter> T)\"", "lemma mono_assert [simp]: \"mono {.p.}\"", "lemma mono_assume [simp]: \"mono (assume P)\"", "lemma mono_demonic [simp]: \"mono [:Q:]\"", "theorem demonic_bottom:\n  \"[:R:] (\\<bottom>::('a::order_bot)) = {s . (R s) = \\<bottom>}\"", "theorem demonic_bottom_top [simp]:\n  \"[:(\\<bottom>::_::order_bot):]  = \\<top>\"", "theorem demonic_sup_inf:\n  \"[:Q \\<squnion> Q':] = [:Q:] \\<sqinter> [:Q':]\"", "theorem angelic_bottom [simp]:\n  \"angelic R \\<bottom>  = {}\"", "theorem angelic_disjunctive [simp]:\n  \"{:(R::('a \\<Rightarrow> 'b::complete_distrib_lattice)):} \\<in> Apply.Disjunctive\"", "lemma grd_choice[simp]: \"grd (S \\<sqinter> T) = (grd S) \\<squnion> (grd T)\"", "lemma grd_demonic: \"grd [:Q:] = {s . \\<exists> s' . s' \\<in> (Q s) }\"", "lemma grd_demonic_2[simp]: \"(s \\<notin> grd [:Q:]) = (\\<forall> s' . s' \\<notin>  (Q s))\"", "theorem grd_angelic:\n  \"grd {:R:} = UNIV\""], "translations": [["", "lemma mono_top[simp]: \"mono top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<top>", "by (simp add: mono_def top_fun_def)"], ["", "lemma mono_choice[simp]: \"mono S \\<Longrightarrow> mono T \\<Longrightarrow> mono (S \\<sqinter> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; mono T\\<rbrakk> \\<Longrightarrow> mono (S \\<sqinter> T)", "apply (simp add: mono_def inf_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y.\n                x \\<sqsubseteq> y \\<longrightarrow> S x \\<sqsubseteq> S y;\n     \\<forall>x y.\n        x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x y.\n                         x \\<sqsubseteq> y \\<longrightarrow>\n                         S x \\<sqinter> T x \\<sqsubseteq> S y \\<and>\n                         S x \\<sqinter> T x \\<sqsubseteq> T y", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<sqinter> T x \\<sqsubseteq> S y\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<sqinter> T x \\<sqsubseteq> T y", "apply (rule_tac y = \"S x\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<sqinter> T x \\<sqsubseteq> S x\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<sqsubseteq> S y\n 3. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<sqinter> T x \\<sqsubseteq> T y", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<sqinter> T x \\<sqsubseteq> T y", "apply (rule_tac y = \"T x\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<sqinter> T x \\<sqsubseteq> T x\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>x y.\n                   x \\<sqsubseteq> y \\<longrightarrow>\n                   S x \\<sqsubseteq> S y;\n        \\<forall>x y.\n           x \\<sqsubseteq> y \\<longrightarrow> T x \\<sqsubseteq> T y;\n        x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> T x \\<sqsubseteq> T y", "by simp_all"], ["", "subsection \"Assert statement\""], ["", "text \\<open>\nThe assert statement of a predicate $p$ when executed from a state $s$ fails\nif $s\\not\\in p$ and behaves as skip otherwise.\n\\<close>"], ["", "definition\n  assert::\"'a::semilattice_inf \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"{. _ .}\" [0] 1000) where\n  \"{.p.} q \\<equiv>  p \\<sqinter> q\""], ["", "lemma mono_assert [simp]: \"mono {.p.}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono {. p .}", "apply (simp add: assert_def mono_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow> p \\<sqinter> x \\<sqsubseteq> y", "apply (rule_tac y = \"x\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow> p \\<sqinter> x \\<sqsubseteq> x\n 2. \\<And>x y. x \\<sqsubseteq> y \\<Longrightarrow> x \\<sqsubseteq> y", "by simp_all"], ["", "subsection \"Assume statement\""], ["", "text \\<open>\nThe assume statement of a predicate $p$ when executed from a state $s$ is not enabled\nif $s\\not\\in p$ and behaves as skip otherwise.\n\\<close>"], ["", "definition\n  \"assume\" :: \"'a::boolean_algebra \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"[. _ .]\" [0] 1000) where\n  \"[. p .] q \\<equiv>  -p \\<squnion> q\""], ["", "lemma mono_assume [simp]: \"mono (assume P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono [. P .]", "apply (simp add: assume_def mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<sqsubseteq> y \\<longrightarrow> x \\<sqsubseteq> - P \\<squnion> y", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow> x \\<sqsubseteq> - P \\<squnion> y", "apply (rule_tac y = \"y\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<sqsubseteq> y \\<Longrightarrow> x \\<sqsubseteq> y\n 2. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow> y \\<sqsubseteq> - P \\<squnion> y", "by simp_all"], ["", "subsection \"Demonic update statement\""], ["", "text \\<open>\nThe demonic update statement of a relation $Q: \\mathit{State} \\to \\mathit{Sate} \\to bool$,\nwhen executed in a state $s$ computes nondeterministically a new state $s'$ such \n$Q\\ s \\ s'$ is true. In order for this statement to be correct all\npossible choices of $s'$ should be correct. If there is no state $s'$\nsuch that $Q\\ s \\ s'$, then the demonic update of $Q$ is not enabled\nin $s$.\n\\<close>"], ["", "definition\n  demonic :: \"('a \\<Rightarrow> 'b::ord) \\<Rightarrow> 'b::ord \\<Rightarrow> 'a set\" (\"[: _ :]\" [0] 1000) where\n  \"[:Q:] p = {s . Q s \\<le> p}\""], ["", "lemma mono_demonic [simp]: \"mono [:Q:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono [: Q :]", "apply (simp add: mono_def demonic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<sqsubseteq> y \\<longrightarrow>\n       {s. Q s \\<sqsubseteq> x} \\<subseteq> {s. Q s \\<sqsubseteq> y}", "by auto"], ["", "theorem demonic_bottom:\n  \"[:R:] (\\<bottom>::('a::order_bot)) = {s . (R s) = \\<bottom>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [: R :] \\<bottom> = {s. R s = \\<bottom>}", "apply (unfold demonic_def, safe, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<sqsubseteq> \\<bottom> \\<Longrightarrow> R x = \\<bottom>", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       R x \\<sqsubseteq> \\<bottom> \\<Longrightarrow>\n       R x \\<sqsubseteq> \\<bottom>\n 2. \\<And>x.\n       R x \\<sqsubseteq> \\<bottom> \\<Longrightarrow>\n       \\<bottom> \\<sqsubseteq> R x", "by auto"], ["", "theorem demonic_bottom_top [simp]:\n  \"[:(\\<bottom>::_::order_bot):]  = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [: \\<bottom> :] = \\<top>", "by (simp add: fun_eq_iff inf_fun_def sup_fun_def demonic_def top_fun_def bot_fun_def)"], ["", "theorem demonic_sup_inf:\n  \"[:Q \\<squnion> Q':] = [:Q:] \\<sqinter> [:Q':]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [: Q \\<squnion> Q' :] = [: Q :] \\<sqinter> [: Q' :]", "by (simp add: fun_eq_iff sup_fun_def inf_fun_def demonic_def, blast)"], ["", "subsection \"Angelic update statement\""], ["", "text \\<open>\nThe angelic update statement of a relation $Q: \\mathit{State} \\to \\mathit{State} \\to \\mathit{bool}$ is similar\nto the demonic version, except that it is enough that at least for one choice $s'$, $Q \\ s \\ s'$\nis correct. If there is no state $s'$\nsuch that $Q\\ s \\ s'$, then the angelic update of $Q$ fails in $s$.\n\\<close>"], ["", "definition\n  angelic :: \"('a \\<Rightarrow> 'b::{semilattice_inf,order_bot}) \\<Rightarrow> 'b \\<Rightarrow> 'a set\" \n               (\"{: _ :}\" [0] 1000) where\n  \"{:Q:} p = {s . (Q s) \\<sqinter> p \\<noteq> \\<bottom>}\""], ["", "syntax \"_update\" :: \"patterns => patterns => logic => logic\" (\"_ \\<leadsto> _ . _\" 0)"], ["", "translations\n  \"_update (_patterns x xs) (_patterns y ys) t\" == \"CONST id (_abs\n           (_pattern x xs) (_Coll (_pattern y ys) t))\"\n  \"_update x y t\" == \"CONST id (_abs x (_Coll y t))\""], ["", "term \"{: y, z \\<leadsto> x, z' . P x y z z' :}\""], ["", "theorem angelic_bottom [simp]:\n  \"angelic R \\<bottom>  = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {: R :} \\<bottom> = {}", "by (simp add: angelic_def inf_bot_bot)"], ["", "theorem angelic_disjunctive [simp]:\n  \"{:(R::('a \\<Rightarrow> 'b::complete_distrib_lattice)):} \\<in> Apply.Disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {: R :} \\<in> Apply.Disjunctive", "by (simp add: Apply.Disjunctive_def angelic_def inf_Sup, blast)"], ["", "subsection \"The guard of a statement\""], ["", "text \\<open>\nThe guard of a statement $S$ is the set of iniatial states from which $S$\nis enabled or fails.\n\\<close>"], ["", "definition\n  \"((grd S)::'a::boolean_algebra) = - (S bot)\""], ["", "lemma grd_choice[simp]: \"grd (S \\<sqinter> T) = (grd S) \\<squnion> (grd T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grd (S \\<sqinter> T) = grd S \\<squnion> grd T", "by (simp add: grd_def inf_fun_def)"], ["", "lemma grd_demonic: \"grd [:Q:] = {s . \\<exists> s' . s' \\<in> (Q s) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grd [: Q :] = {s. \\<exists>s'. s' \\<in> Q s}", "apply (simp add: grd_def demonic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - {s. Q s = {}} = {s. \\<exists>s'. s' \\<in> Q s}", "by blast"], ["", "lemma grd_demonic_2[simp]: \"(s \\<notin> grd [:Q:]) = (\\<forall> s' . s' \\<notin>  (Q s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<notin> grd [: Q :]) = (\\<forall>s'. s' \\<notin> Q s)", "by (simp add: grd_demonic)"], ["", "theorem grd_angelic:\n  \"grd {:R:} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grd {: R :} = UNIV", "by (simp add: grd_def)"], ["", "end"]]}