{"file_name": "/home/qj213/afp-2021-10-22/thys/Relational_Paths/Path_Algorithms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relational_Paths", "problem_names": ["lemma construct_path_pre:\n  assumes \"is_acyclic D\"\n      and \"point y\"\n      and \"point x\"\n      and \"D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\"\n    shows \"construct_path_inv y x y D 0\"", "lemma path_inv_points:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n  shows \"point q\"\n    and \"point (choose_point (D*q))\"", "lemma path_inv_choose_point_decrease:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n    shows \"W\\<noteq>0 \\<Longrightarrow> choose_point (D*q) \\<le> -((W + choose_point (D*q) * q\\<^sup>T)\\<^sup>T*1)\"", "lemma end_points:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n    shows \"choose_point (D*q) = start_points (W + choose_point (D*q) * q\\<^sup>T)\"\n      and \"y = end_points (W + choose_point (D*q) * q\\<^sup>T)\"", "lemma construct_path_inv:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n  shows \"construct_path_inv (choose_point (D*q)) x y D (W + choose_point (D*q)*q\\<^sup>T)\"", "theorem construct_path_partial: \"VARS p q W\n  { is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x }\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD\n  { W \\<le> D \\<and> terminating_path W \\<and> (W=0 \\<longleftrightarrow> x=y) \\<and> (W\\<noteq>0 \\<longleftrightarrow> x = start_points W \\<and> y = end_points W) }\"", "lemma decrease_set:\n  assumes \"\\<forall>x::'a . Q x \\<longrightarrow> P x\"\n      and \"P w\"\n      and \"\\<not> Q w\"\n    shows \"card { x . Q x } < card { x . P x }\"", "lemma decrease_variant:\n  assumes \"y \\<le> z\"\n      and \"w \\<le> z\"\n      and \"\\<not> w \\<le> y\"\n    shows \"card { x . x \\<le> y } < card { x . x \\<le> z }\"", "lemma construct_path_inv_termination:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n    shows \"card { z . z \\<le> -(W + choose_point (D*q)*q\\<^sup>T) } < card { z . z \\<le> -W }\"", "theorem construct_path_total: \"VARS p q W\n  [ is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x ]\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W }\n    VAR { card { z . z \\<le> -W } }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD\n  [ W \\<le> D \\<and> terminating_path W \\<and> (W=0 \\<longleftrightarrow> x=y) \\<and> (W\\<noteq>0 \\<longleftrightarrow> x = start_points W \\<and> y = end_points W) ]\"", "lemma topological_sort_pre:\n  assumes \"regressively_finite R\"\n  shows \"topological_sort_inv (choose_point (minimum R 1)) (choose_point (minimum R 1)) R 0\"", "lemma topological_sort_inv:\n  assumes \"v \\<noteq> 1\"\n      and \"topological_sort_inv q v R W\"\n    shows \"topological_sort_inv (choose_point (minimum R (- v))) (v +\n                      choose_point (minimum R (- v))) R (W + q * choose_point (minimum R (- v))\\<^sup>T)\"", "lemma topological_sort_post:\n assumes \"\\<not> v \\<noteq> 1\"\n     and \"topological_sort_inv q v R W\"\n   shows \"R \\<le> W\\<^sup>+ \\<and> terminating_path W \\<and> (W + W\\<^sup>T)*1 = -1'*1\"", "theorem topological_sort_partial: \"VARS p q v W\n  { regressively_finite R }\n  W := 0;\n  q := choose_point (minimum R 1);\n  v := q;\n  WHILE v \\<noteq> 1\n    INV { topological_sort_inv q v R W }\n     DO p := choose_point (minimum R (-v));\n        W := W + q*p\\<^sup>T;\n        q := p;\n        v := v + p\n     OD\n  { R \\<le> W\\<^sup>+ \\<and> terminating_path W \\<and> (W + W\\<^sup>T)*1 = -1'*1 }\"", "lemma topological_sort_inv_termination:\n  assumes \"v \\<noteq> 1\"\n      and \"topological_sort_inv q v R W\"\n    shows \"card {z . z \\<le> -(v + choose_point (minimum R (-v)))} < card { z . z \\<le> -v }\"", "theorem topological_sort_total: \"VARS p q v W\n  [ is_acyclic R ]\n  W := 0;\n  q := choose_point (minimum R 1);\n  v := q;\n  WHILE v \\<noteq> 1\n    INV { topological_sort_inv q v R W }\n    VAR { card { z . z \\<le> -v } }\n      DO p := choose_point (minimum R (-v));\n         W := W + q*p\\<^sup>T;\n         q := p;\n         v := v + p\n      OD\n   [ R \\<le> W\\<^sup>+ \\<and> terminating_path W \\<and> (W + W\\<^sup>T)*1 = -1'*1 ]\"", "lemma construct_tree_pre:\n  assumes \"construct_tree_pre x y R\"\n    shows \"construct_tree_inv x x y 0 R\"", "lemma construct_tree_inv_aux:\n  assumes \"\\<not> y \\<le> v\"\n      and \"construct_tree_inv v x y D R\"\n    shows \"singleton (choose_singleton (v*-v\\<^sup>T \\<cdot> R))\"", "lemma construct_tree_inv:\n  assumes \"\\<not> y \\<le> v\"\n      and \"construct_tree_inv v x y D R\"\n    shows \"construct_tree_inv (v + choose_singleton (v*-v\\<^sup>T \\<cdot> R)\\<^sup>T*1) x y (D +\n                               choose_singleton (v*-v\\<^sup>T \\<cdot> R)) R\"", "lemma construct_tree_post:\n  assumes \"y \\<le> v\"\n      and \"construct_tree_inv v x y D R\"\n    shows \"construct_tree_post x y D R\"", "theorem construct_tree_partial: \"VARS e v D\n  { construct_tree_pre x y R }\n  D := 0;\n  v := x;\n  WHILE \\<not> y \\<le> v\n    INV { construct_tree_inv v x y D R }\n     DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n        D := D + e;\n        v := v + e\\<^sup>T*1\n     OD\n  { construct_tree_post x y D R }\"", "lemma construct_tree_inv_termination:\n assumes \" \\<not> y \\<le> v\"\n     and \"construct_tree_inv v x y D R\"\n   shows \"card { z . z \\<le> -(v + choose_singleton (v*-v\\<^sup>T \\<cdot> R)\\<^sup>T*1) } < card { z . z \\<le> -v }\"", "theorem construct_tree_total: \"VARS e v D\n [ construct_tree_pre x y R ]\n D := 0;\n v := x;\n WHILE \\<not> y \\<le> v\n   INV { construct_tree_inv v x y D R }\n   VAR { card { z . z \\<le> -v } }\n    DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n       D := D + e;\n       v := v + e\\<^sup>T*1\n    OD\n [ construct_tree_post x y D R ]\"", "lemma construct_cycle_pre:\n assumes \" \\<not> is_acyclic R\"\n     and \"y = choose_point ((R\\<^sup>+ \\<cdot> 1')*1)\"\n     and \"x = choose_point (R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y)\"\n   shows \"construct_cycle_inv x x y 0 R\"", "lemma construct_cycle_pre2:\n assumes \"y \\<le> v\"\n     and \"construct_cycle_inv v x y D R\"\n   shows \"construct_path_inv y x y D 0 \\<and> D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\"", "lemma construct_cycle_post:\n  assumes \"\\<not> q \\<noteq> x\"\n      and \"(construct_path_inv q x y D W \\<and> D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R)\"\n    shows \"W + y * x\\<^sup>T \\<noteq> 0 \\<and> W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)\"", "theorem construct_cycle_partial: \"VARS e p q v x y C D W\n  { \\<not> is_acyclic R }\n  y := choose_point ((R\\<^sup>+ \\<cdot> 1')*1);\n  x := choose_point (R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y);\n  D := 0;\n  v := x;\n  WHILE \\<not> y \\<le> v\n    INV { construct_cycle_inv v x y D R }\n     DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n        D := D + e;\n        v := v + e\\<^sup>T*1\n     OD;\n  comment { is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x };\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W \\<and> D \\<le> R \\<and> D*x = 0 \\<and> y*x\\<^sup>T \\<le> R }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD;\n  comment { W \\<le> D \\<and> terminating_path W \\<and> (W = 0 \\<longleftrightarrow> q=y) \\<and> (W \\<noteq> 0 \\<longleftrightarrow> q = start_points W \\<and> y = end_points W) };\n  C := W + y*x\\<^sup>T\n  { C \\<noteq> 0 \\<and> C \\<le> R \\<and> cycle C }\"", "theorem construct_cycle_total: \"VARS e p q v x y C D W\n  [ \\<not> is_acyclic R ]\n  y := choose_point ((R\\<^sup>+ \\<cdot> 1')*1);\n  x := choose_point (R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y);\n  D := 0;\n  v := x;\n  WHILE \\<not> y \\<le> v\n    INV { construct_cycle_inv v x y D R }\n    VAR { card { z . z \\<le> -v } }\n     DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n        D := D + e;\n        v := v + e\\<^sup>T*1\n     OD;\n  comment { is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x };\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W \\<and> D \\<le> R \\<and> D*x = 0 \\<and> y*x\\<^sup>T \\<le> R }\n    VAR { card { z . z \\<le> -W } }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD;\n  comment { W \\<le> D \\<and> terminating_path W \\<and> (W = 0 \\<longleftrightarrow> q=y) \\<and> (W \\<noteq> 0 \\<longleftrightarrow> q = start_points W \\<and> y = end_points W)};\n  C := W + y*x\\<^sup>T\n [ C \\<noteq> 0 \\<and> C \\<le> R \\<and> cycle C ]\""], "translations": [["", "lemma construct_path_pre:\n  assumes \"is_acyclic D\"\n      and \"point y\"\n      and \"point x\"\n      and \"D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\"\n    shows \"construct_path_inv y x y D 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic D \\<and>\n    point x \\<and>\n    point y \\<and>\n    point y \\<and>\n    D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n    0 \\<le> D \\<and>\n    terminating_path 0 \\<and>\n    (0 = 0) = (y = y) \\<and>\n    (0 \\<noteq> 0) = (y = start_points 0 \\<and> y = end_points 0)", "apply (intro conjI, simp_all add: assms is_inj_def is_p_fun_def path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "using assms(2) cycle_iff"], ["proof (prove)\nusing this:\n  point y\n  point ?r \\<Longrightarrow>\n  (?x * ?r \\<noteq> 0) = (?r \\<le> ?x\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by fastforce"], ["", "text \\<open>\nThe following three lemmas are auxiliary lemmas for \\<open>construct_path_inv\\<close>.\nThey are pulled out of the main proof to have more structure.\n\\<close>"], ["", "lemma path_inv_points:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n  shows \"point q\"\n    and \"point (choose_point (D*q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point q &&& point (choose_point (D * q))", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. point q &&& point (choose_point (D * q))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. point (choose_point (D * q))", "by (metis assms choose_point_point comp_assoc is_vector_def point_def reachable_implies_predecessor)"], ["", "lemma path_inv_choose_point_decrease:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n    shows \"W\\<noteq>0 \\<Longrightarrow> choose_point (D*q) \\<le> -((W + choose_point (D*q) * q\\<^sup>T)\\<^sup>T*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "let ?q = \"choose_point (D*q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "let ?W = \"W + ?q * q\\<^sup>T\""], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "assume as: \"W\\<noteq>0\""], ["proof (state)\nthis:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "hence \"q*W \\<le> W\\<^sup>+\""], ["proof (prove)\nusing this:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. connected_root q W", "(* \"connected_root q W\" *)"], ["proof (prove)\nusing this:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. connected_root q W", "by (metis assms conv_contrav conv_invol conv_iso conv_terminating_path\n              forward_terminating_path_end_points_1 plus_conv point_def ss423bij\n              terminating_path_iff)"], ["proof (state)\nthis:\n  connected_root q W\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "hence \"?q \\<cdot> W\\<^sup>T*1 \\<le> D*q \\<cdot> W\\<^sup>T\\<^sup>+*q\""], ["proof (prove)\nusing this:\n  connected_root q W\n\ngoal (1 subgoal):\n 1. choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n    \\<le> D * q \\<cdot> W\\<^sup>T\\<^sup>+ * q", "using choose_point_decreasing meet_iso meet_isor inf_mono assms connected_root_iff2"], ["proof (prove)\nusing this:\n  connected_root q W\n  choose_point ?x \\<le> ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<cdot> ?x \\<le> ?z \\<cdot> ?y\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<cdot> ?b \\<le> ?c \\<cdot> ?d\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T * 1 \\<le> ?x\\<^sup>T\\<^sup>+ * ?r)\n\ngoal (1 subgoal):\n 1. choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n    \\<le> D * q \\<cdot> W\\<^sup>T\\<^sup>+ * q", "by simp"], ["proof (state)\nthis:\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n  \\<le> D * q \\<cdot> W\\<^sup>T\\<^sup>+ * q\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "also"], ["proof (state)\nthis:\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n  \\<le> D * q \\<cdot> W\\<^sup>T\\<^sup>+ * q\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "have \"... \\<le> (D \\<cdot> D\\<^sup>T\\<^sup>+)*q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D * q \\<cdot> W\\<^sup>T\\<^sup>+ * q\n    \\<le> (D \\<cdot> D\\<^sup>T\\<^sup>+) * q", "by (metis assms inj_distr point_def conv_contrav conv_invol conv_iso meet_isor\n              mult_isol_var mult_isor star_conv star_slide_var star_subdist sup.commute sup.orderE)"], ["proof (state)\nthis:\n  D * q \\<cdot> W\\<^sup>T\\<^sup>+ * q\n  \\<le> (D \\<cdot> D\\<^sup>T\\<^sup>+) * q\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "also"], ["proof (state)\nthis:\n  D * q \\<cdot> W\\<^sup>T\\<^sup>+ * q\n  \\<le> (D \\<cdot> D\\<^sup>T\\<^sup>+) * q\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "have \"... \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D \\<cdot> D\\<^sup>T\\<^sup>+) * q \\<le> 0", "by (metis acyclic_trans assms conv_zero step_has_target eq_iff galois_aux ss_p18)"], ["proof (state)\nthis:\n  (D \\<cdot> D\\<^sup>T\\<^sup>+) * q \\<le> 0\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "finally"], ["proof (chain)\npicking this:\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1 \\<le> 0", "have a: \"?q \\<le> -(W\\<^sup>T*1)\""], ["proof (prove)\nusing this:\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1 \\<le> 0\n\ngoal (1 subgoal):\n 1. choose_point (D * q) \\<le> - (W\\<^sup>T * 1)", "using galois_aux le_bot"], ["proof (prove)\nusing this:\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1 \\<le> 0\n  (?x \\<cdot> ?y = 0) = (?x \\<le> - ?y)\n  ?a \\<le> 0 \\<Longrightarrow> ?a = 0\n\ngoal (1 subgoal):\n 1. choose_point (D * q) \\<le> - (W\\<^sup>T * 1)", "by blast"], ["proof (state)\nthis:\n  choose_point (D * q) \\<le> - (W\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "have \"point ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (choose_point (D * q))", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. point (choose_point (D * q))", "by(rule path_inv_points(2))"], ["proof (state)\nthis:\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "hence \"?q \\<le> -(q*?q\\<^sup>T*1)\""], ["proof (prove)\nusing this:\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. choose_point (D * q) \\<le> - (q * choose_point (D * q)\\<^sup>T * 1)", "by (metis assms acyclic_imp_one_step_different_points(2) point_is_point\n            choose_point_decreasing edge_end end_point_char end_point_no_successor)"], ["proof (state)\nthis:\n  choose_point (D * q) \\<le> - (q * choose_point (D * q)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "with a"], ["proof (chain)\npicking this:\n  choose_point (D * q) \\<le> - (W\\<^sup>T * 1)\n  choose_point (D * q) \\<le> - (q * choose_point (D * q)\\<^sup>T * 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  choose_point (D * q) \\<le> - (W\\<^sup>T * 1)\n  choose_point (D * q) \\<le> - (q * choose_point (D * q)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "by (simp add: inf.boundedI)"], ["proof (state)\nthis:\n  choose_point (D * q)\n  \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma end_points:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n    shows \"choose_point (D*q) = start_points (W + choose_point (D*q) * q\\<^sup>T)\"\n      and \"y = end_points (W + choose_point (D*q) * q\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T) &&&\n    y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T)\n 2. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "let ?q = \"choose_point (D*q)\""], ["proof (state)\ngoal (2 subgoals):\n 1. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T)\n 2. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "let ?W = \"W + ?q * q\\<^sup>T\""], ["proof (state)\ngoal (2 subgoals):\n 1. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T)\n 2. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "show 1: \"?q = start_points ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)\n 2. start_points (W + choose_point (D * q) * q\\<^sup>T)\n    \\<le> choose_point (D * q)", "show\" start_points ?W \\<le> ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_points (W + choose_point (D * q) * q\\<^sup>T)\n    \\<le> choose_point (D * q)", "by (metis assms(1) path_inv_points(2) acyclic_imp_one_step_different_points(2)\n                choose_point_decreasing edge_end edge_start sup.commute\n                path_concatenation_start_points_approx point_is_point eq_iff sup_bot_left)"], ["proof (state)\nthis:\n  start_points (W + choose_point (D * q) * q\\<^sup>T)\n  \\<le> choose_point (D * q)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "show \"?q \\<le> start_points ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "have a: \"?q = ?q*q\\<^sup>T*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) = choose_point (D * q) * q\\<^sup>T * 1", "by (metis assms(1) comp_assoc point_equations(1) point_is_point aux4 conv_zero\n                  choose_point_decreasing choose_point_point conv_contrav conv_one point_def\n                  inf.orderE inf_compl_bot inf_compl_bot_right is_vector_def maddux_142\n                  sup_bot_left sur_def_var1)"], ["proof (state)\nthis:\n  choose_point (D * q) = choose_point (D * q) * q\\<^sup>T * 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "hence \"?q =(q \\<cdot> -q) + (?q \\<cdot> -q \\<cdot> -(?W\\<^sup>T*1))\""], ["proof (prove)\nusing this:\n  choose_point (D * q) = choose_point (D * q) * q\\<^sup>T * 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q) =\n    q \\<cdot> - q +\n    choose_point (D * q) \\<cdot> - q \\<cdot>\n    - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "by (metis assms path_inv_points(2) path_inv_choose_point_decrease\n                  acyclic_imp_one_step_different_points(1) choose_point_decreasing inf.orderE\n                  inf_compl_bot sup_inf_absorb edge_start point_is_point sup_bot_left)"], ["proof (state)\nthis:\n  choose_point (D * q) =\n  q \\<cdot> - q +\n  choose_point (D * q) \\<cdot> - q \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  choose_point (D * q) =\n  q \\<cdot> - q +\n  choose_point (D * q) \\<cdot> - q \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... \\<le> (W*1 \\<cdot> -(?W\\<^sup>T*1) \\<cdot> -q) + (?q \\<cdot> -q \\<cdot> -(?W\\<^sup>T*1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<cdot> - q +\n    choose_point (D * q) \\<cdot> - q \\<cdot>\n    - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n    \\<le> W * 1 \\<cdot>\n          - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n          - q +\n          choose_point (D * q) \\<cdot> - q \\<cdot>\n          - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "by simp"], ["proof (state)\nthis:\n  q \\<cdot> - q +\n  choose_point (D * q) \\<cdot> - q \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n  \\<le> W * 1 \\<cdot>\n        - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n        - q +\n        choose_point (D * q) \\<cdot> - q \\<cdot>\n        - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  q \\<cdot> - q +\n  choose_point (D * q) \\<cdot> - q \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n  \\<le> W * 1 \\<cdot>\n        - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n        - q +\n        choose_point (D * q) \\<cdot> - q \\<cdot>\n        - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = (W*1 + ?q) \\<cdot> -(q + ?W\\<^sup>T*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W * 1 \\<cdot>\n    - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n    - q +\n    choose_point (D * q) \\<cdot> - q \\<cdot>\n    - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) =\n    (W * 1 + choose_point (D * q)) \\<cdot>\n    - (q + (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)", "by (metis compl_sup inf_sup_distrib2 meet_assoc sup.commute)"], ["proof (state)\nthis:\n  W * 1 \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n  - q +\n  choose_point (D * q) \\<cdot> - q \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) =\n  (W * 1 + choose_point (D * q)) \\<cdot>\n  - (q + (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  W * 1 \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n  - q +\n  choose_point (D * q) \\<cdot> - q \\<cdot>\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) =\n  (W * 1 + choose_point (D * q)) \\<cdot>\n  - (q + (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... \\<le> ?W*1 \\<cdot> -(?W\\<^sup>T*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W * 1 + choose_point (D * q)) \\<cdot>\n    - (q + (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "using a"], ["proof (prove)\nusing this:\n  choose_point (D * q) = choose_point (D * q) * q\\<^sup>T * 1\n\ngoal (1 subgoal):\n 1. (W * 1 + choose_point (D * q)) \\<cdot>\n    - (q + (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "by (metis inf.left_commute distrib_right' compl_sup inf.cobounded2)"], ["proof (state)\nthis:\n  (W * 1 + choose_point (D * q)) \\<cdot>\n  - (q + (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1)\n  \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "finally"], ["proof (chain)\npicking this:\n  choose_point (D * q)\n  \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "show \"?q \\<le> start_points ?W\""], ["proof (prove)\nusing this:\n  choose_point (D * q)\n  \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. choose_point (D * q)\n    \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)", "."], ["proof (state)\nthis:\n  choose_point (D * q)\n  \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  choose_point (D * q)\n  \\<le> start_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  choose_point (D * q) = start_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "show \"y = end_points ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have point_nq: \"point ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (choose_point (D * q))", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. point (choose_point (D * q))", "by(rule path_inv_points(2))"], ["proof (state)\nthis:\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "hence yp: \"y \\<le> -?q\""], ["proof (prove)\nusing this:\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. y \\<le> - choose_point (D * q)", "using 1 assms"], ["proof (prove)\nusing this:\n  point (choose_point (D * q))\n  choose_point (D * q) = start_points (W + choose_point (D * q) * q\\<^sup>T)\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<le> - choose_point (D * q)", "by (metis acyclic_imp_one_step_different_points(2) choose_point_decreasing cycle_no_points(1)\n                finite_iff finite_iff_msc forward_finite_iff_msc path_aux1a path_edge_equals_cycle\n                point_is_point point_not_equal(1) terminating_iff1)"], ["proof (state)\nthis:\n  y \\<le> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"y = y + (W*1 \\<cdot> -(W\\<^sup>T*1) \\<cdot> -(W*1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = y + start_points W \\<cdot> - (W * 1)", "by (simp add: inf.commute)"], ["proof (state)\nthis:\n  y = y + start_points W \\<cdot> - (W * 1)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  y = y + start_points W \\<cdot> - (W * 1)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = y + (q \\<cdot> -(W*1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y + start_points W \\<cdot> - (W * 1) = y + q \\<cdot> - (W * 1)", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. y + start_points W \\<cdot> - (W * 1) = y + q \\<cdot> - (W * 1)", "by fastforce"], ["proof (state)\nthis:\n  y + start_points W \\<cdot> - (W * 1) = y + q \\<cdot> - (W * 1)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  y + start_points W \\<cdot> - (W * 1) = y + q \\<cdot> - (W * 1)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = y + (q \\<cdot> -(W*1) \\<cdot> -?q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y + q \\<cdot> - (W * 1) =\n    y + q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)", "by (metis calculation sup_assoc sup_inf_absorb)"], ["proof (state)\nthis:\n  y + q \\<cdot> - (W * 1) =\n  y + q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  y + q \\<cdot> - (W * 1) =\n  y + q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = (y \\<cdot> -?q) + (q \\<cdot> -(W*1) \\<cdot> -?q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y + q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n    y \\<cdot> - choose_point (D * q) +\n    q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)", "using yp"], ["proof (prove)\nusing this:\n  y \\<le> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y + q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n    y \\<cdot> - choose_point (D * q) +\n    q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)", "by (simp add: inf.absorb1)"], ["proof (state)\nthis:\n  y + q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  y \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  y + q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  y \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = (W\\<^sup>T*1 \\<cdot> -(W*1) \\<cdot> -?q) + (q \\<cdot> -(W*1) \\<cdot> -?q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<cdot> - choose_point (D * q) +\n    q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n    end_points W \\<cdot> - choose_point (D * q) +\n    q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<cdot> - choose_point (D * q) +\n    q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n    end_points W \\<cdot> - choose_point (D * q) +\n    q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)", "by fastforce"], ["proof (state)\nthis:\n  y \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  end_points W \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  y \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  end_points W \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = (W\\<^sup>T*1 + q) \\<cdot> -(W*1) \\<cdot> -?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. end_points W \\<cdot> - choose_point (D * q) +\n    q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n    (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)", "by (simp add: inf_sup_distrib2)"], ["proof (state)\nthis:\n  end_points W \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  end_points W \\<cdot> - choose_point (D * q) +\n  q \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = (W\\<^sup>T*1 + q) \\<cdot> -(W*1 + ?q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n    (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1 + choose_point (D * q))", "by (simp add: inf.assoc)"], ["proof (state)\nthis:\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1 + choose_point (D * q))\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1) \\<cdot> - choose_point (D * q) =\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1 + choose_point (D * q))\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = (W\\<^sup>T*1 + q*?q\\<^sup>T*1) \\<cdot> -(W*1 + ?q*q\\<^sup>T*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1 + choose_point (D * q)) =\n    (W\\<^sup>T * 1 + q * choose_point (D * q)\\<^sup>T * 1) \\<cdot>\n    - (W * 1 + choose_point (D * q) * q\\<^sup>T * 1)", "using point_nq"], ["proof (prove)\nusing this:\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1 + choose_point (D * q)) =\n    (W\\<^sup>T * 1 + q * choose_point (D * q)\\<^sup>T * 1) \\<cdot>\n    - (W * 1 + choose_point (D * q) * q\\<^sup>T * 1)", "by(metis assms(1) comp_assoc conv_contrav conv_one is_vector_def point_def sur_def_var1)"], ["proof (state)\nthis:\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1 + choose_point (D * q)) =\n  (W\\<^sup>T * 1 + q * choose_point (D * q)\\<^sup>T * 1) \\<cdot>\n  - (W * 1 + choose_point (D * q) * q\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "also"], ["proof (state)\nthis:\n  (W\\<^sup>T * 1 + q) \\<cdot> - (W * 1 + choose_point (D * q)) =\n  (W\\<^sup>T * 1 + q * choose_point (D * q)\\<^sup>T * 1) \\<cdot>\n  - (W * 1 + choose_point (D * q) * q\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "have \"... = (?W\\<^sup>T)*1 \\<cdot> -(?W*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W\\<^sup>T * 1 + q * choose_point (D * q)\\<^sup>T * 1) \\<cdot>\n    - (W * 1 + choose_point (D * q) * q\\<^sup>T * 1) =\n    end_points (W + choose_point (D * q) * q\\<^sup>T)", "by simp"], ["proof (state)\nthis:\n  (W\\<^sup>T * 1 + q * choose_point (D * q)\\<^sup>T * 1) \\<cdot>\n  - (W * 1 + choose_point (D * q) * q\\<^sup>T * 1) =\n  end_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "finally"], ["proof (chain)\npicking this:\n  y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "show ?thesis"], ["proof (prove)\nusing this:\n  y = end_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. y = end_points (W + choose_point (D * q) * q\\<^sup>T)", "."], ["proof (state)\nthis:\n  y = end_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y = end_points (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_path_inv:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n  shows \"construct_path_inv (choose_point (D*q)) x y D (W + choose_point (D*q)*q\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic D \\<and>\n    point x \\<and>\n    point y \\<and>\n    point (choose_point (D * q)) \\<and>\n    D\\<^sup>\\<star> * choose_point (D * q)\n    \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n    W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n    terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n    (W + choose_point (D * q) * q\\<^sup>T = 0) =\n    (choose_point (D * q) = y) \\<and>\n    (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "proof (intro conjI)"], ["proof (state)\ngoal (10 subgoals):\n 1. is_acyclic D\n 2. point x\n 3. point y\n 4. point (choose_point (D * q))\n 5. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 6. W + choose_point (D * q) * q\\<^sup>T \\<le> D\n 7. path (W + choose_point (D * q) * q\\<^sup>T)\n 8. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 9. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 10. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n     (choose_point (D * q) =\n      start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n      y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "let ?q = \"choose_point (D*q)\""], ["proof (state)\ngoal (10 subgoals):\n 1. is_acyclic D\n 2. point x\n 3. point y\n 4. point (choose_point (D * q))\n 5. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 6. W + choose_point (D * q) * q\\<^sup>T \\<le> D\n 7. path (W + choose_point (D * q) * q\\<^sup>T)\n 8. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 9. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 10. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n     (choose_point (D * q) =\n      start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n      y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "let ?W = \"W + ?q * q\\<^sup>T\""], ["proof (state)\ngoal (10 subgoals):\n 1. is_acyclic D\n 2. point x\n 3. point y\n 4. point (choose_point (D * q))\n 5. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 6. W + choose_point (D * q) * q\\<^sup>T \\<le> D\n 7. path (W + choose_point (D * q) * q\\<^sup>T)\n 8. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 9. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 10. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n     (choose_point (D * q) =\n      start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n      y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show \"is_acyclic D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic D", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. is_acyclic D", "by blast"], ["proof (state)\nthis:\n  is_acyclic D\n\ngoal (9 subgoals):\n 1. point x\n 2. point y\n 3. point (choose_point (D * q))\n 4. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 5. W + choose_point (D * q) * q\\<^sup>T \\<le> D\n 6. path (W + choose_point (D * q) * q\\<^sup>T)\n 7. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 8. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 9. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show point_y: \"point y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point y", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. point y", "by blast"], ["proof (state)\nthis:\n  point y\n\ngoal (8 subgoals):\n 1. point x\n 2. point (choose_point (D * q))\n 3. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 4. W + choose_point (D * q) * q\\<^sup>T \\<le> D\n 5. path (W + choose_point (D * q) * q\\<^sup>T)\n 6. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 7. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 8. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show \"point x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point x", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. point x", "by blast"], ["proof (state)\nthis:\n  point x\n\ngoal (7 subgoals):\n 1. point (choose_point (D * q))\n 2. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 3. W + choose_point (D * q) * q\\<^sup>T \\<le> D\n 4. path (W + choose_point (D * q) * q\\<^sup>T)\n 5. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 6. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 7. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show \"?W \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W + choose_point (D * q) * q\\<^sup>T \\<le> D", "using assms choose_point_decreasing le_sup_iff point_def ss423bij inf.boundedE"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  choose_point ?x \\<le> ?x\n  (?x + ?y \\<le> ?z) = (?x \\<le> ?z \\<and> ?y \\<le> ?z)\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  bijective ?x \\<Longrightarrow>\n  (?y * ?x\\<^sup>T \\<le> ?z) = (?y \\<le> ?z * ?x)\n  \\<lbrakk>?a \\<le> ?b \\<cdot> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. W + choose_point (D * q) * q\\<^sup>T \\<le> D", "by blast"], ["proof (state)\nthis:\n  W + choose_point (D * q) * q\\<^sup>T \\<le> D\n\ngoal (6 subgoals):\n 1. point (choose_point (D * q))\n 2. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 3. path (W + choose_point (D * q) * q\\<^sup>T)\n 4. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 5. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 6. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show \"D\\<^sup>\\<star>*?q \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "have \"D\\<^sup>+*q \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>+ * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "using assms conv_galois_2 order_trans star_1l"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  (?y * ?x \\<le> ?z) = (?y \\<le> - (- ?z * ?x\\<^sup>T))\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x\\<^sup>+ \\<le> ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. D\\<^sup>+ * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "by blast"], ["proof (state)\nthis:\n  D\\<^sup>+ * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "thus ?thesis"], ["proof (prove)\nusing this:\n  D\\<^sup>+ * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "by (metis choose_point_decreasing comp_assoc dual_order.trans mult_isol star_slide_var)"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> * choose_point (D * q) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (5 subgoals):\n 1. point (choose_point (D * q))\n 2. path (W + choose_point (D * q) * q\\<^sup>T)\n 3. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 4. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 5. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show point_nq: \"point ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (choose_point (D * q))", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. point (choose_point (D * q))", "by(rule path_inv_points(2))"], ["proof (state)\nthis:\n  point (choose_point (D * q))\n\ngoal (4 subgoals):\n 1. path (W + choose_point (D * q) * q\\<^sup>T)\n 2. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 3. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 4. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show pathW: \"path ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (W + choose_point (D * q) * q\\<^sup>T)", "proof(cases \"W=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow> path (W + choose_point (D * q) * q\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "assume \"W=0\""], ["proof (state)\nthis:\n  W = 0\n\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow> path (W + choose_point (D * q) * q\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  W = 0\n\ngoal (1 subgoal):\n 1. path (W + choose_point (D * q) * q\\<^sup>T)", "using assms edge_is_path point_is_point point_nq"], ["proof (prove)\nusing this:\n  W = 0\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  \\<lbrakk>is_point ?p; is_point ?q\\<rbrakk>\n  \\<Longrightarrow> path (?p * ?q\\<^sup>T)\n  point ?x = is_point ?x\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. path (W + choose_point (D * q) * q\\<^sup>T)", "by simp"], ["proof (state)\nthis:\n  path (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "assume a: \"W\\<noteq>0\""], ["proof (state)\nthis:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "have b: \"?q*q\\<^sup>T \\<le> 1*?q*q\\<^sup>T*-(?q*q\\<^sup>T*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T\n    \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n          - (choose_point (D * q) * q\\<^sup>T * 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T\n    \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n          - (choose_point (D * q) * q\\<^sup>T * 1)", "have \"?q*q\\<^sup>T \\<le>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T \\<le> 1", "by simp"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T \\<le> 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T\n    \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n          - (choose_point (D * q) * q\\<^sup>T * 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  choose_point (D * q) * q\\<^sup>T \\<le> 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T\n    \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n          - (choose_point (D * q) * q\\<^sup>T * 1)", "using assms point_nq"], ["proof (prove)\nusing this:\n  choose_point (D * q) * q\\<^sup>T \\<le> 1\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T\n    \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n          - (choose_point (D * q) * q\\<^sup>T * 1)", "by(metis different_points_consequences(1) point_def sur_def_var1\n               acyclic_imp_one_step_different_points(2) choose_point_decreasing comp_assoc\n               is_vector_def point_def point_equations(3,4) point_is_point)"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T\n  \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n        - (choose_point (D * q) * q\\<^sup>T * 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T\n  \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n        - (choose_point (D * q) * q\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "have c: \"W \\<le> -(1*W)*W*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating W", "using assms terminating_path_iff"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  terminating_path ?x =\n  (backward_terminating_path ?x \\<and> forward_terminating_path ?x)\n\ngoal (1 subgoal):\n 1. backward_terminating W", "by blast"], ["proof (state)\nthis:\n  backward_terminating W\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "have d: \"(?q*q\\<^sup>T)\\<^sup>T*1 \\<cdot> -((?q*q\\<^sup>T)*1) = W*1 \\<cdot> -(W\\<^sup>T*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. end_points (choose_point (D * q) * q\\<^sup>T) = start_points W", "using a"], ["proof (prove)\nusing this:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. end_points (choose_point (D * q) * q\\<^sup>T) = start_points W", "by (metis assms path_inv_points(2) acyclic_reachable_points choose_point_decreasing\n                  edge_end point_is_point comp_assoc point_def sur_total total_one)"], ["proof (state)\nthis:\n  end_points (choose_point (D * q) * q\\<^sup>T) = start_points W\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "have e: \"?q*q\\<^sup>T*1 \\<cdot> W\\<^sup>T*1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "have \"?q*q\\<^sup>T*1 \\<cdot> W\\<^sup>T*1 = ?q \\<cdot> W\\<^sup>T*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 =\n    choose_point (D * q) \\<cdot> W\\<^sup>T * 1", "using assms point_nq"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  point (choose_point (D * q))\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 =\n    choose_point (D * q) \\<cdot> W\\<^sup>T * 1", "by (metis comp_assoc conv_contrav conv_one is_vector_def point_def sur_def_var1)"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 =\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "also"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 =\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "have \"... \\<le> -(?W\\<^sup>T*1) \\<cdot> ?W\\<^sup>T*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n          (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1", "using assms path_inv_choose_point_decrease"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  \\<lbrakk>(is_acyclic ?D \\<and>\n            point ?x \\<and>\n            point ?y \\<and>\n            point ?q \\<and>\n            ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n            ?W \\<le> ?D \\<and>\n            terminating_path ?W \\<and>\n            (?W = 0) = (?q = ?y) \\<and>\n            (?W \\<noteq> 0) =\n            (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n           ?q \\<noteq> ?x;\n   ?W \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> choose_point (?D * ?q)\n                    \\<le> - ((?W +\n                              choose_point (?D * ?q) * ?q\\<^sup>T)\\<^sup>T *\n                             1)\n\ngoal (1 subgoal):\n 1. choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n    \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n          (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1", "by (smt a conv_contrav conv_iso conv_one inf_mono less_eq_def subdistl_eq)"], ["proof (state)\nthis:\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n  \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n        (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "also"], ["proof (state)\nthis:\n  choose_point (D * q) \\<cdot> W\\<^sup>T * 1\n  \\<le> - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n        (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "have \"... \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n    (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1\n    \\<le> 0", "using compl_inf_bot eq_refl"], ["proof (prove)\nusing this:\n  - ?x \\<cdot> ?x = 0\n  ?x = ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n    (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1\n    \\<le> 0", "by blast"], ["proof (state)\nthis:\n  - ((W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1) \\<cdot>\n  (W + choose_point (D * q) * q\\<^sup>T)\\<^sup>T * 1\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "finally"], ["proof (chain)\npicking this:\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 \\<le> 0\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "using bot_unique"], ["proof (prove)\nusing this:\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 \\<le> 0\n  (?a \\<le> 0) = (?a = 0)\n\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0", "by blast"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + choose_point (D * q) * q\\<^sup>T)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (W + choose_point (D * q) * q\\<^sup>T)", "using b c d e"], ["proof (prove)\nusing this:\n  choose_point (D * q) * q\\<^sup>T\n  \\<le> 1 * choose_point (D * q) * q\\<^sup>T *\n        - (choose_point (D * q) * q\\<^sup>T * 1)\n  backward_terminating W\n  end_points (choose_point (D * q) * q\\<^sup>T) = start_points W\n  choose_point (D * q) * q\\<^sup>T * 1 \\<cdot> W\\<^sup>T * 1 = 0\n\ngoal (1 subgoal):\n 1. path (W + choose_point (D * q) * q\\<^sup>T)", "by (metis assms comp_assoc edge_is_path path_concatenation_cycle_free\n                                point_is_point sup.commute point_nq)"], ["proof (state)\nthis:\n  path (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal (3 subgoals):\n 1. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 2. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n 3. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show \"?W = 0 \\<longleftrightarrow> ?q = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. W + choose_point (D * q) * q\\<^sup>T = 0 \\<Longrightarrow>\n    choose_point (D * q) = y\n 2. choose_point (D * q) = y \\<Longrightarrow>\n    W + choose_point (D * q) * q\\<^sup>T = 0", "apply (metis assms conv_zero dist_alt edge_start inf_compl_bot_right modular_1_aux' modular_2_aux'\n              point_is_point sup.left_idem sup_bot_left point_nq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) = y \\<Longrightarrow>\n    W + choose_point (D * q) * q\\<^sup>T = 0", "by (smt assms end_points(1) conv_contrav conv_invol cycle_no_points(1) end_point_iff2 has_start_end_points_iff path_aux1b path_edge_equals_cycle point_is_point start_point_iff2 sup_bot_left top_greatest pathW)"], ["proof (state)\nthis:\n  (W + choose_point (D * q) * q\\<^sup>T = 0) = (choose_point (D * q) = y)\n\ngoal (2 subgoals):\n 1. terminating (W + choose_point (D * q) * q\\<^sup>T)\n 2. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "show \"?W\\<noteq>0 \\<longleftrightarrow> ?q = start_points ?W \\<and> y = end_points ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n    (choose_point (D * q) =\n     start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n     y = end_points (W + choose_point (D * q) * q\\<^sup>T))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n    y = end_points (W + choose_point (D * q) * q\\<^sup>T)\n 2. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n    y = end_points (W + choose_point (D * q) * q\\<^sup>T) \\<Longrightarrow>\n    W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0", "using assms end_points"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  choose_point (?D * ?q) =\n  start_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T)\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  ?y = end_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T)\n\ngoal (2 subgoals):\n 1. W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0 \\<Longrightarrow>\n    choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n    y = end_points (W + choose_point (D * q) * q\\<^sup>T)\n 2. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n    y = end_points (W + choose_point (D * q) * q\\<^sup>T) \\<Longrightarrow>\n    W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n    y = end_points (W + choose_point (D * q) * q\\<^sup>T) \\<Longrightarrow>\n    W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n\ngoal (1 subgoal):\n 1. choose_point (D * q) =\n    start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n    y = end_points (W + choose_point (D * q) * q\\<^sup>T) \\<Longrightarrow>\n    W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n  (choose_point (D * q) =\n   start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n   y = end_points (W + choose_point (D * q) * q\\<^sup>T))\n\ngoal (1 subgoal):\n 1. terminating (W + choose_point (D * q) * q\\<^sup>T)", "show \"terminating ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminating (W + choose_point (D * q) * q\\<^sup>T)", "by (smt assms end_points end_point_iff2 has_start_end_points_iff point_is_point start_point_iff2\n            terminating_iff1 pathW point_nq)"], ["proof (state)\nthis:\n  terminating (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem construct_path_partial: \"VARS p q W\n  { is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x }\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD\n  { W \\<le> D \\<and> terminating_path W \\<and> (W=0 \\<longleftrightarrow> x=y) \\<and> (W\\<noteq>0 \\<longleftrightarrow> x = start_points W \\<and> y = end_points W) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {is_acyclic D \\<and>\n     point y \\<and>\n     point x \\<and> D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x} \n     W := 0;\n     q := y;\n     WHILE q \\<noteq> x\n      INV {is_acyclic D \\<and>\n           point x \\<and>\n           point y \\<and>\n           point q \\<and>\n           D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n           W \\<le> D \\<and>\n           terminating_path W \\<and>\n           (W = 0) = (q = y) \\<and>\n           (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)} \n      VAR {\\<lambda>(p, q, W). zero_class.zero} \n      DO p := choose_point (D * q); W := W + p * q\\<^sup>T; q := p OD \n     {W \\<le> D \\<and>\n      terminating_path W \\<and>\n      (W = 0) = (x = y) \\<and>\n      (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)}", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q W.\n       is_acyclic D \\<and>\n       point y \\<and>\n       point x \\<and>\n       D\\<^sup>\\<star> * y\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point y \\<and>\n       D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       0 \\<le> D \\<and>\n       terminating_path 0 \\<and>\n       (0 = 0) = (y = y) \\<and>\n       (0 \\<noteq> 0) = (y = start_points 0 \\<and> y = end_points 0)\n 2. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point (choose_point (D * q)) \\<and>\n       D\\<^sup>\\<star> * choose_point (D * q)\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n       terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T = 0) =\n       (choose_point (D * q) = y) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n       (choose_point (D * q) =\n        start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        y = end_points (W + choose_point (D * q) * q\\<^sup>T))\n 3. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "using construct_path_pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_acyclic ?D; point ?y; point ?x;\n   ?D\\<^sup>\\<star> * ?y \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x\\<rbrakk>\n  \\<Longrightarrow> is_acyclic ?D \\<and>\n                    point ?x \\<and>\n                    point ?y \\<and>\n                    point ?y \\<and>\n                    ?D\\<^sup>\\<star> * ?y\n                    \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n                    0 \\<le> ?D \\<and>\n                    terminating_path 0 \\<and>\n                    (0 = 0) = (?y = ?y) \\<and>\n                    (0 \\<noteq> 0) =\n                    (?y = start_points 0 \\<and> ?y = end_points 0)\n\ngoal (3 subgoals):\n 1. \\<And>p q W.\n       is_acyclic D \\<and>\n       point y \\<and>\n       point x \\<and>\n       D\\<^sup>\\<star> * y\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point y \\<and>\n       D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       0 \\<le> D \\<and>\n       terminating_path 0 \\<and>\n       (0 = 0) = (y = y) \\<and>\n       (0 \\<noteq> 0) = (y = start_points 0 \\<and> y = end_points 0)\n 2. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point (choose_point (D * q)) \\<and>\n       D\\<^sup>\\<star> * choose_point (D * q)\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n       terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T = 0) =\n       (choose_point (D * q) = y) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n       (choose_point (D * q) =\n        start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        y = end_points (W + choose_point (D * q) * q\\<^sup>T))\n 3. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point (choose_point (D * q)) \\<and>\n       D\\<^sup>\\<star> * choose_point (D * q)\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n       terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T = 0) =\n       (choose_point (D * q) = y) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n       (choose_point (D * q) =\n        start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        y = end_points (W + choose_point (D * q) * q\\<^sup>T))\n 2. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "using construct_path_inv"], ["proof (prove)\nusing this:\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  is_acyclic ?D \\<and>\n  point ?x \\<and>\n  point ?y \\<and>\n  point (choose_point (?D * ?q)) \\<and>\n  ?D\\<^sup>\\<star> * choose_point (?D * ?q)\n  \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n  ?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<le> ?D \\<and>\n  terminating_path (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T = 0) =\n  (choose_point (?D * ?q) = ?y) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<noteq> 0) =\n  (choose_point (?D * ?q) =\n   start_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n   ?y = end_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T))\n\ngoal (2 subgoals):\n 1. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point (choose_point (D * q)) \\<and>\n       D\\<^sup>\\<star> * choose_point (D * q)\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n       terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T = 0) =\n       (choose_point (D * q) = y) \\<and>\n       (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n       (choose_point (D * q) =\n        start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        y = end_points (W + choose_point (D * q) * q\\<^sup>T))\n 2. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "by fastforce"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point *)"], ["", "text \\<open>For termination, we additionally need finiteness.\\<close>"], ["", "context finite\nbegin"], ["", "lemma decrease_set:\n  assumes \"\\<forall>x::'a . Q x \\<longrightarrow> P x\"\n      and \"P w\"\n      and \"\\<not> Q w\"\n    shows \"card { x . Q x } < card { x . P x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. Q x} < card {x. P x}", "by (metis Collect_mono assms card_seteq finite mem_Collect_eq not_le)"], ["", "end"], ["", "class relation_algebra_rtc_tarski_choose_point_finite =\n      relation_algebra_rtc_tarski_choose_point + relation_algebra_rtc_tarski_point_finite\nbegin"], ["", "lemma decrease_variant:\n  assumes \"y \\<le> z\"\n      and \"w \\<le> z\"\n      and \"\\<not> w \\<le> y\"\n    shows \"card { x . x \\<le> y } < card { x . x \\<le> z }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. x \\<le> y} < card {x. x \\<le> z}", "by (metis Collect_mono assms card_seteq linorder_not_le dual_order.trans finite_code mem_Collect_eq)"], ["", "lemma construct_path_inv_termination:\n  assumes \"construct_path_inv q x y D W \\<and> q \\<noteq> x\"\n    shows \"card { z . z \\<le> -(W + choose_point (D*q)*q\\<^sup>T) } < card { z . z \\<le> -W }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {z. z \\<le> - (W + choose_point (D * q) * q\\<^sup>T)}\n    < card {z. z \\<le> - W}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {z. z \\<le> - (W + choose_point (D * q) * q\\<^sup>T)}\n    < card {z. z \\<le> - W}", "let ?q = \"choose_point (D*q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. card {z. z \\<le> - (W + choose_point (D * q) * q\\<^sup>T)}\n    < card {z. z \\<le> - W}", "let ?W = \"W + ?q * q\\<^sup>T\""], ["proof (state)\ngoal (1 subgoal):\n 1. card {z. z \\<le> - (W + choose_point (D * q) * q\\<^sup>T)}\n    < card {z. z \\<le> - W}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {z. z \\<le> - (W + choose_point (D * q) * q\\<^sup>T)}\n    < card {z. z \\<le> - W}", "proof (rule decrease_variant)"], ["proof (state)\ngoal (3 subgoals):\n 1. - (W + choose_point (D * q) * q\\<^sup>T) \\<le> - W\n 2. ?w \\<le> - W\n 3. \\<not> ?w \\<le> - (W + choose_point (D * q) * q\\<^sup>T)", "show \"-?W \\<le> -W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (W + choose_point (D * q) * q\\<^sup>T) \\<le> - W", "by simp"], ["proof (state)\nthis:\n  - (W + choose_point (D * q) * q\\<^sup>T) \\<le> - W\n\ngoal (2 subgoals):\n 1. ?w \\<le> - W\n 2. \\<not> ?w \\<le> - (W + choose_point (D * q) * q\\<^sup>T)", "show \"?q * q\\<^sup>T \\<le> -W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (D * q) * q\\<^sup>T \\<le> - W", "by (metis assms galois_aux inf_compl_bot_right maddux_142 mult_isor order_trans top_greatest)"], ["proof (state)\nthis:\n  choose_point (D * q) * q\\<^sup>T \\<le> - W\n\ngoal (1 subgoal):\n 1. \\<not> choose_point (D * q) * q\\<^sup>T\n           \\<le> - (W + choose_point (D * q) * q\\<^sup>T)", "show \"\\<not> (?q * q\\<^sup>T \\<le> -?W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> choose_point (D * q) * q\\<^sup>T\n           \\<le> - (W + choose_point (D * q) * q\\<^sup>T)", "using assms end_points(1)"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  q \\<noteq> x\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  choose_point (?D * ?q) =\n  start_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<not> choose_point (D * q) * q\\<^sup>T\n           \\<le> - (W + choose_point (D * q) * q\\<^sup>T)", "by (smt acyclic_imp_one_step_different_points(2) choose_point_decreasing compl_sup inf.absorb1\n              inf_compl_bot_right sup.commute sup_bot.left_neutral conv_zero end_points(2))"], ["proof (state)\nthis:\n  \\<not> choose_point (D * q) * q\\<^sup>T\n         \\<le> - (W + choose_point (D * q) * q\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {z. z \\<le> - (W + choose_point (D * q) * q\\<^sup>T)}\n  < card {z. z \\<le> - W}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem construct_path_total: \"VARS p q W\n  [ is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x ]\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W }\n    VAR { card { z . z \\<le> -W } }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD\n  [ W \\<le> D \\<and> terminating_path W \\<and> (W=0 \\<longleftrightarrow> x=y) \\<and> (W\\<noteq>0 \\<longleftrightarrow> x = start_points W \\<and> y = end_points W) ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [is_acyclic D \\<and>\n     point y \\<and>\n     point x \\<and> D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x] \n     W := 0;\n     q := y;\n     WHILE q \\<noteq> x\n      INV {is_acyclic D \\<and>\n           point x \\<and>\n           point y \\<and>\n           point q \\<and>\n           D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n           W \\<le> D \\<and>\n           terminating_path W \\<and>\n           (W = 0) = (q = y) \\<and>\n           (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)} \n      VAR {\\<lambda>(p, q, W). card {z. z \\<le> - W}} \n      DO p := choose_point (D * q); W := W + p * q\\<^sup>T; q := p OD \n     [W \\<le> D \\<and>\n      terminating_path W \\<and>\n      (W = 0) = (x = y) \\<and>\n      (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)]", "apply vcg_tc"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q W.\n       is_acyclic D \\<and>\n       point y \\<and>\n       point x \\<and>\n       D\\<^sup>\\<star> * y\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point y \\<and>\n       D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       0 \\<le> D \\<and>\n       terminating_path 0 \\<and>\n       (0 = 0) = (y = y) \\<and>\n       (0 \\<noteq> 0) = (y = start_points 0 \\<and> y = end_points 0)\n 2. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (choose_point (D * q), choose_point (D * q),\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (p, q, W) \\<Rightarrow>\n                    is_acyclic D \\<and>\n                    point x \\<and>\n                    point y \\<and>\n                    point q \\<and>\n                    D\\<^sup>\\<star> * q\n                    \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                    W \\<le> D \\<and>\n                    terminating_path W \\<and>\n                    (W = 0) = (q = y) \\<and>\n                    (W \\<noteq> 0) =\n                    (q = start_points W \\<and> y = end_points W)) \\<and>\n                 (case s of (p, q, W) \\<Rightarrow> card {z. z \\<le> - W})\n                 < n}\n 3. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "using construct_path_pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_acyclic ?D; point ?y; point ?x;\n   ?D\\<^sup>\\<star> * ?y \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x\\<rbrakk>\n  \\<Longrightarrow> is_acyclic ?D \\<and>\n                    point ?x \\<and>\n                    point ?y \\<and>\n                    point ?y \\<and>\n                    ?D\\<^sup>\\<star> * ?y\n                    \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n                    0 \\<le> ?D \\<and>\n                    terminating_path 0 \\<and>\n                    (0 = 0) = (?y = ?y) \\<and>\n                    (0 \\<noteq> 0) =\n                    (?y = start_points 0 \\<and> ?y = end_points 0)\n\ngoal (3 subgoals):\n 1. \\<And>p q W.\n       is_acyclic D \\<and>\n       point y \\<and>\n       point x \\<and>\n       D\\<^sup>\\<star> * y\n       \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<Longrightarrow>\n       is_acyclic D \\<and>\n       point x \\<and>\n       point y \\<and>\n       point y \\<and>\n       D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n       0 \\<le> D \\<and>\n       terminating_path 0 \\<and>\n       (0 = 0) = (y = y) \\<and>\n       (0 \\<noteq> 0) = (y = start_points 0 \\<and> y = end_points 0)\n 2. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (choose_point (D * q), choose_point (D * q),\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (p, q, W) \\<Rightarrow>\n                    is_acyclic D \\<and>\n                    point x \\<and>\n                    point y \\<and>\n                    point q \\<and>\n                    D\\<^sup>\\<star> * q\n                    \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                    W \\<le> D \\<and>\n                    terminating_path W \\<and>\n                    (W = 0) = (q = y) \\<and>\n                    (W \\<noteq> 0) =\n                    (q = start_points W \\<and> y = end_points W)) \\<and>\n                 (case s of (p, q, W) \\<Rightarrow> card {z. z \\<le> - W})\n                 < n}\n 3. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (choose_point (D * q), choose_point (D * q),\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (p, q, W) \\<Rightarrow>\n                    is_acyclic D \\<and>\n                    point x \\<and>\n                    point y \\<and>\n                    point q \\<and>\n                    D\\<^sup>\\<star> * q\n                    \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                    W \\<le> D \\<and>\n                    terminating_path W \\<and>\n                    (W = 0) = (q = y) \\<and>\n                    (W \\<noteq> 0) =\n                    (q = start_points W \\<and> y = end_points W)) \\<and>\n                 (case s of (p, q, W) \\<Rightarrow> card {z. z \\<le> - W})\n                 < n}\n 2. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "apply (rule CollectI, rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       case (choose_point (D * q), choose_point (D * q),\n             W + choose_point (D * q) * q\\<^sup>T) of\n       (p, q, W) \\<Rightarrow>\n         is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)\n 2. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (choose_point (D * q), choose_point (D * q),\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (p, q, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 3. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "using construct_path_inv"], ["proof (prove)\nusing this:\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  is_acyclic ?D \\<and>\n  point ?x \\<and>\n  point ?y \\<and>\n  point (choose_point (?D * ?q)) \\<and>\n  ?D\\<^sup>\\<star> * choose_point (?D * ?q)\n  \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n  ?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<le> ?D \\<and>\n  terminating_path (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T = 0) =\n  (choose_point (?D * ?q) = ?y) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<noteq> 0) =\n  (choose_point (?D * ?q) =\n   start_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n   ?y = end_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T))\n\ngoal (3 subgoals):\n 1. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       case (choose_point (D * q), choose_point (D * q),\n             W + choose_point (D * q) * q\\<^sup>T) of\n       (p, q, W) \\<Rightarrow>\n         is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)\n 2. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (choose_point (D * q), choose_point (D * q),\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (p, q, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 3. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (choose_point (D * q), choose_point (D * q),\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (p, q, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 2. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "using construct_path_inv_termination"], ["proof (prove)\nusing this:\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  card {z. z \\<le> - (?W + choose_point (?D * ?q) * ?q\\<^sup>T)}\n  < card {z. z \\<le> - ?W}\n\ngoal (2 subgoals):\n 1. \\<And>n p q W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (choose_point (D * q), choose_point (D * q),\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (p, q, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 2. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q W.\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point q \\<and>\n        D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W \\<le> D \\<and>\n        terminating_path W \\<and>\n        (W = 0) = (q = y) \\<and>\n        (W \\<noteq> 0) =\n        (q = start_points W \\<and> y = end_points W)) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W \\<le> D \\<and>\n       terminating_path W \\<and>\n       (W = 0) = (x = y) \\<and>\n       (W \\<noteq> 0) = (x = start_points W \\<and> y = end_points W)", "by fastforce"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point_finite *)"], ["", "subsection \\<open>Topological sorting\\<close>"], ["", "text \\<open>\nIn our second example we look at topological sorting.\nGiven a directed acyclic graph, the problem is to construct a linear order of its vertices that contains $x$ before $y$ for each edge $(x,y)$ of the graph.\nIf the input graph models dependencies between tasks, the output is a linear schedule of the tasks that respects all dependencies.\n\\<close>"], ["", "context relation_algebra_rtc_tarski_choose_point\nbegin"], ["", "abbreviation topological_sort_inv\n  where \"topological_sort_inv q v R W \\<equiv>\n         regressively_finite R \\<and> R \\<cdot> v*v\\<^sup>T \\<le> W\\<^sup>+ \\<and> terminating_path W \\<and> W*1 = v\\<cdot>-q \\<and>\n         (W = 0 \\<or> q = end_points W) \\<and> point q \\<and> R*v \\<le> v \\<and> q \\<le> v \\<and> is_vector v\""], ["", "lemma topological_sort_pre:\n  assumes \"regressively_finite R\"\n  shows \"topological_sort_inv (choose_point (minimum R 1)) (choose_point (minimum R 1)) R 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topological_sort_inv (choose_point (minimum R 1))\n     (choose_point (minimum R 1)) R 0", "proof (intro conjI,simp_all add:assms)"], ["proof (state)\ngoal (5 subgoals):\n 1. R \\<cdot>\n    choose_point (- (R\\<^sup>T * 1)) *\n    choose_point (- (R\\<^sup>T * 1))\\<^sup>T\n    \\<le> 0\n 2. path 0\n 3. point (choose_point (- (R\\<^sup>T * 1)))\n 4. R * choose_point (- (R\\<^sup>T * 1))\n    \\<le> choose_point (- (R\\<^sup>T * 1))\n 5. is_vector (choose_point (- (R\\<^sup>T * 1)))", "let ?q = \"choose_point (- (R\\<^sup>T * 1))\""], ["proof (state)\ngoal (5 subgoals):\n 1. R \\<cdot>\n    choose_point (- (R\\<^sup>T * 1)) *\n    choose_point (- (R\\<^sup>T * 1))\\<^sup>T\n    \\<le> 0\n 2. path 0\n 3. point (choose_point (- (R\\<^sup>T * 1)))\n 4. R * choose_point (- (R\\<^sup>T * 1))\n    \\<le> choose_point (- (R\\<^sup>T * 1))\n 5. is_vector (choose_point (- (R\\<^sup>T * 1)))", "show point_q: \"point ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (choose_point (- (R\\<^sup>T * 1)))", "using assms"], ["proof (prove)\nusing this:\n  regressively_finite R\n\ngoal (1 subgoal):\n 1. point (choose_point (- (R\\<^sup>T * 1)))", "by (metis (full_types) annir choose_point_point galois_aux2 is_inj_def is_sur_def\n                          is_vector_def one_idem_mult point_def ss_p18 inf_top_left one_compl)"], ["proof (state)\nthis:\n  point (choose_point (- (R\\<^sup>T * 1)))\n\ngoal (4 subgoals):\n 1. R \\<cdot>\n    choose_point (- (R\\<^sup>T * 1)) *\n    choose_point (- (R\\<^sup>T * 1))\\<^sup>T\n    \\<le> 0\n 2. path 0\n 3. R * choose_point (- (R\\<^sup>T * 1))\n    \\<le> choose_point (- (R\\<^sup>T * 1))\n 4. is_vector (choose_point (- (R\\<^sup>T * 1)))", "show \"R \\<cdot> ?q * ?q\\<^sup>T \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (- (R\\<^sup>T * 1)) *\n    choose_point (- (R\\<^sup>T * 1))\\<^sup>T\n    \\<le> 0", "by (metis choose_point_decreasing conv_invol end_point_char eq_iff inf_bot_left schroeder_2)"], ["proof (state)\nthis:\n  R \\<cdot>\n  choose_point (- (R\\<^sup>T * 1)) *\n  choose_point (- (R\\<^sup>T * 1))\\<^sup>T\n  \\<le> 0\n\ngoal (3 subgoals):\n 1. path 0\n 2. R * choose_point (- (R\\<^sup>T * 1))\n    \\<le> choose_point (- (R\\<^sup>T * 1))\n 3. is_vector (choose_point (- (R\\<^sup>T * 1)))", "show \"path 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path 0", "by (simp add: is_inj_def is_p_fun_def path_def)"], ["proof (state)\nthis:\n  path 0\n\ngoal (2 subgoals):\n 1. R * choose_point (- (R\\<^sup>T * 1))\n    \\<le> choose_point (- (R\\<^sup>T * 1))\n 2. is_vector (choose_point (- (R\\<^sup>T * 1)))", "show \"R*?q \\<le> ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R * choose_point (- (R\\<^sup>T * 1))\n    \\<le> choose_point (- (R\\<^sup>T * 1))", "by (metis choose_point_decreasing compl_bot_eq conv_galois_1 inf_compl_bot_left2 le_inf_iff)"], ["proof (state)\nthis:\n  R * choose_point (- (R\\<^sup>T * 1))\n  \\<le> choose_point (- (R\\<^sup>T * 1))\n\ngoal (1 subgoal):\n 1. is_vector (choose_point (- (R\\<^sup>T * 1)))", "show \"is_vector ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector (choose_point (- (R\\<^sup>T * 1)))", "using point_q point_def"], ["proof (prove)\nusing this:\n  point (choose_point (- (R\\<^sup>T * 1)))\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n\ngoal (1 subgoal):\n 1. is_vector (choose_point (- (R\\<^sup>T * 1)))", "by blast"], ["proof (state)\nthis:\n  is_vector (choose_point (- (R\\<^sup>T * 1)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma topological_sort_inv:\n  assumes \"v \\<noteq> 1\"\n      and \"topological_sort_inv q v R W\"\n    shows \"topological_sort_inv (choose_point (minimum R (- v))) (v +\n                      choose_point (minimum R (- v))) R (W + q * choose_point (minimum R (- v))\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topological_sort_inv (choose_point (minimum R (- v)))\n     (v + choose_point (minimum R (- v))) R\n     (W + q * choose_point (minimum R (- v))\\<^sup>T)", "proof (intro conjI)"], ["proof (state)\ngoal (10 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. point (choose_point (minimum R (- v)))\n 8. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 9. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 10. is_vector (v + choose_point (minimum R (- v)))", "let ?p = \"choose_point (minimum R (-v))\""], ["proof (state)\ngoal (10 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. point (choose_point (minimum R (- v)))\n 8. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 9. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 10. is_vector (v + choose_point (minimum R (- v)))", "let ?W = \"W + q*?p\\<^sup>T\""], ["proof (state)\ngoal (10 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. point (choose_point (minimum R (- v)))\n 8. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 9. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 10. is_vector (v + choose_point (minimum R (- v)))", "let ?v = \"v + ?p\""], ["proof (state)\ngoal (10 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. point (choose_point (minimum R (- v)))\n 8. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 9. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 10. is_vector (v + choose_point (minimum R (- v)))", "show point_p: \"point ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (choose_point (minimum R (- v)))", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> 1\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. point (choose_point (minimum R (- v)))", "by (metis choose_point_point compl_bot_eq double_compl galois_aux2 comp_assoc is_vector_def\n              vector_compl vector_mult)"], ["proof (state)\nthis:\n  point (choose_point (minimum R (- v)))\n\ngoal (9 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 8. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 9. is_vector (v + choose_point (minimum R (- v)))", "hence ep_np: \"end_points (q*?p\\<^sup>T) = ?p\""], ["proof (prove)\nusing this:\n  point (choose_point (minimum R (- v)))\n\ngoal (1 subgoal):\n 1. end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n    choose_point (minimum R (- v))", "using assms(2)"], ["proof (prove)\nusing this:\n  point (choose_point (minimum R (- v)))\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n    choose_point (minimum R (- v))", "by (metis aux4 choose_point_decreasing edge_end le_supI1 point_in_vector_or_complement_iff\n              point_is_point)"], ["proof (state)\nthis:\n  end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n  choose_point (minimum R (- v))\n\ngoal (9 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 8. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 9. is_vector (v + choose_point (minimum R (- v)))", "hence sp_q: \"start_points (q*?p\\<^sup>T) = q\""], ["proof (prove)\nusing this:\n  end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n  choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. start_points (q * choose_point (minimum R (- v))\\<^sup>T) = q", "using assms(2) point_p"], ["proof (prove)\nusing this:\n  end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n  choose_point (minimum R (- v))\n  topological_sort_inv q v R W\n  point (choose_point (minimum R (- v)))\n\ngoal (1 subgoal):\n 1. start_points (q * choose_point (minimum R (- v))\\<^sup>T) = q", "by (metis (no_types, lifting) conv_contrav conv_invol edge_start point_is_point)"], ["proof (state)\nthis:\n  start_points (q * choose_point (minimum R (- v))\\<^sup>T) = q\n\ngoal (9 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 8. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 9. is_vector (v + choose_point (minimum R (- v)))", "hence ep_sp: \"W \\<noteq> 0 \\<Longrightarrow> end_points W = start_points (q*?p\\<^sup>T)\""], ["proof (prove)\nusing this:\n  start_points (q * choose_point (minimum R (- v))\\<^sup>T) = q\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)", "using assms(2)"], ["proof (prove)\nusing this:\n  start_points (q * choose_point (minimum R (- v))\\<^sup>T) = q\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)", "by force"], ["proof (state)\nthis:\n  W \\<noteq> 0 \\<Longrightarrow>\n  end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (9 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 8. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 9. is_vector (v + choose_point (minimum R (- v)))", "have \"W*1 \\<cdot> (q*?p\\<^sup>T)\\<^sup>T*1 = v\\<cdot>-q\\<cdot>?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 =\n    v \\<cdot> - q \\<cdot> choose_point (minimum R (- v))", "using assms(2) point_p is_vector_def mult_assoc point_def point_equations(3) point_is_point"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n  point (choose_point (minimum R (- v)))\n  is_vector ?x \\<equiv> ?x = ?x * 1\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  is_point ?p \\<Longrightarrow> ?p\\<^sup>T * 1 = 1\n  point ?x = is_point ?x\n\ngoal (1 subgoal):\n 1. W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 =\n    v \\<cdot> - q \\<cdot> choose_point (minimum R (- v))", "by auto"], ["proof (state)\nthis:\n  W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 =\n  v \\<cdot> - q \\<cdot> choose_point (minimum R (- v))\n\ngoal (9 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 8. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 9. is_vector (v + choose_point (minimum R (- v)))", "hence 1: \"W*1 \\<cdot> (q*?p\\<^sup>T)\\<^sup>T*1 = 0\""], ["proof (prove)\nusing this:\n  W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 =\n  v \\<cdot> - q \\<cdot> choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 =\n    0", "by (metis choose_point_decreasing dual_order.trans galois_aux inf.cobounded2 inf.commute)"], ["proof (state)\nthis:\n  W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 = 0\n\ngoal (9 subgoals):\n 1. regressively_finite R\n 2. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 3. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 6. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 7. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 8. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 9. is_vector (v + choose_point (minimum R (- v)))", "show \"regressively_finite R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regressively_finite R", "using assms(2)"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. regressively_finite R", "by blast"], ["proof (state)\nthis:\n  regressively_finite R\n\ngoal (8 subgoals):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n 2. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 3. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 5. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 6. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 7. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 8. is_vector (v + choose_point (minimum R (- v)))", "show \"R \\<cdot> ?v*?v\\<^sup>T \\<le> ?W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have a: \"R \\<cdot> v*v\\<^sup>T \\<le> ?W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot> v * v\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "using assms(2)"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * v\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "by (meson mult_isol_var order.trans order_prop star_subdist)"], ["proof (state)\nthis:\n  R \\<cdot> v * v\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have b: \"R \\<cdot> v*?p\\<^sup>T \\<le> ?W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"R \\<cdot> v*?p\\<^sup>T \\<le> W*1*?p\\<^sup>T + q*?p\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> W * 1 * choose_point (minimum R (- v))\\<^sup>T +\n          q * choose_point (minimum R (- v))\\<^sup>T", "by (metis inf_le2 assms(2) aux4 double_compl inf_absorb2 distrib_right)"], ["proof (state)\nthis:\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> W * 1 * choose_point (minimum R (- v))\\<^sup>T +\n        q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "also"], ["proof (state)\nthis:\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> W * 1 * choose_point (minimum R (- v))\\<^sup>T +\n        q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"... = W*?p\\<^sup>T + q*?p\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W * 1 * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T =\n    W * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T", "using point_p"], ["proof (prove)\nusing this:\n  point (choose_point (minimum R (- v)))\n\ngoal (1 subgoal):\n 1. W * 1 * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T =\n    W * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T", "by (metis conv_contrav conv_one is_vector_def mult_assoc point_def)"], ["proof (state)\nthis:\n  W * 1 * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T =\n  W * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "also"], ["proof (state)\nthis:\n  W * 1 * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T =\n  W * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"... \\<le> W\\<^sup>+*end_points W*?p\\<^sup>T + q*?p\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> W\\<^sup>+ * end_points W *\n          choose_point (minimum R (- v))\\<^sup>T +\n          q * choose_point (minimum R (- v))\\<^sup>T", "using assms(2)"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. W * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> W\\<^sup>+ * end_points W *\n          choose_point (minimum R (- v))\\<^sup>T +\n          q * choose_point (minimum R (- v))\\<^sup>T", "by (meson forward_terminating_path_end_points_1 join_iso mult_isor terminating_path_iff)"], ["proof (state)\nthis:\n  W * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> W\\<^sup>+ * end_points W * choose_point (minimum R (- v))\\<^sup>T +\n        q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "also"], ["proof (state)\nthis:\n  W * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> W\\<^sup>+ * end_points W * choose_point (minimum R (- v))\\<^sup>T +\n        q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"... \\<le> W\\<^sup>+*q*?p\\<^sup>T + q*?p\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W\\<^sup>+ * end_points W * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n          q * choose_point (minimum R (- v))\\<^sup>T", "using assms(2)"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. W\\<^sup>+ * end_points W * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n          q * choose_point (minimum R (- v))\\<^sup>T", "by (metis annil eq_refl)"], ["proof (state)\nthis:\n  W\\<^sup>+ * end_points W * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n        q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "also"], ["proof (state)\nthis:\n  W\\<^sup>+ * end_points W * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n        q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"... = W\\<^sup>\\<star>*q*?p\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T =\n    W\\<^sup>\\<star> * q * choose_point (minimum R (- v))\\<^sup>T", "using conway.dagger_unfoldl_distr mult_assoc sup_commute"], ["proof (prove)\nusing this:\n  ?y + ?x\\<^sup>+ * ?y = ?x\\<^sup>\\<star> * ?y\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  ?x + ?y = ?y + ?x\n\ngoal (1 subgoal):\n 1. W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n    q * choose_point (minimum R (- v))\\<^sup>T =\n    W\\<^sup>\\<star> * q * choose_point (minimum R (- v))\\<^sup>T", "by fastforce"], ["proof (state)\nthis:\n  W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T =\n  W\\<^sup>\\<star> * q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "also"], ["proof (state)\nthis:\n  W\\<^sup>+ * q * choose_point (minimum R (- v))\\<^sup>T +\n  q * choose_point (minimum R (- v))\\<^sup>T =\n  W\\<^sup>\\<star> * q * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"... \\<le> ?W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W\\<^sup>\\<star> * q * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "by (metis mult_assoc mult_isol_var star_slide_var star_subdist sup_ge2)"], ["proof (state)\nthis:\n  W\\<^sup>\\<star> * q * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "finally"], ["proof (chain)\npicking this:\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "."], ["proof (state)\nthis:\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have c: \"R \\<cdot> ?p*v\\<^sup>T \\<le> ?W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"v \\<le> -?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le> - choose_point (minimum R (- v))", "using choose_point_decreasing compl_le_swap1 inf_le1 order_trans"], ["proof (prove)\nusing this:\n  choose_point ?x \\<le> ?x\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n  ?x \\<cdot> ?y \\<le> ?x\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. v \\<le> - choose_point (minimum R (- v))", "by blast"], ["proof (state)\nthis:\n  v \\<le> - choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "hence \"R*v \\<le> -?p\""], ["proof (prove)\nusing this:\n  v \\<le> - choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. R * v \\<le> - choose_point (minimum R (- v))", "using assms(2) order.trans"], ["proof (prove)\nusing this:\n  v \\<le> - choose_point (minimum R (- v))\n  topological_sort_inv q v R W\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. R * v \\<le> - choose_point (minimum R (- v))", "by blast"], ["proof (state)\nthis:\n  R * v \\<le> - choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  R * v \\<le> - choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "by (metis galois_aux inf_le2 schroeder_2)"], ["proof (state)\nthis:\n  R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have d: \"R \\<cdot> ?p*?p\\<^sup>T \\<le> ?W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"R \\<cdot> ?p*?p\\<^sup>T \\<le> R \\<cdot> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> R \\<cdot> 1'", "using point_p is_inj_def meet_isor point_def"], ["proof (prove)\nusing this:\n  point (choose_point (minimum R (- v)))\n  is_inj ?x \\<equiv> ?x * ?x\\<^sup>T \\<le> 1'\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<cdot> ?x \\<le> ?z \\<cdot> ?y\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> R \\<cdot> 1'", "by blast"], ["proof (state)\nthis:\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> R \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "also"], ["proof (state)\nthis:\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> R \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot> 1' = 0", "using assms(2) regressively_finite_irreflexive galois_aux"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n  regressively_finite ?x \\<Longrightarrow> ?x \\<le> - 1'\n  (?x \\<cdot> ?y = 0) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. R \\<cdot> 1' = 0", "by blast"], ["proof (state)\nthis:\n  R \\<cdot> 1' = 0\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "finally"], ["proof (chain)\npicking this:\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "using bot_least inf.absorb_iff2"], ["proof (prove)\nusing this:\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> 0\n  0 \\<le> ?a\n  (?b \\<le> ?a) = (?a \\<cdot> ?b = ?b)\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"R \\<cdot> ?v*?v\\<^sup>T = (R \\<cdot> v*v\\<^sup>T) + (R \\<cdot> v*?p\\<^sup>T) + (R \\<cdot> ?p*v\\<^sup>T) + (R \\<cdot> ?p*?p\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T =\n    R \\<cdot> v * v\\<^sup>T +\n    R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T +\n    R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T +\n    R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T", "by (metis conv_add distrib_left distrib_right inf_sup_distrib1 sup.commute sup.left_commute)"], ["proof (state)\nthis:\n  R \\<cdot>\n  (v + choose_point (minimum R (- v))) *\n  (v + choose_point (minimum R (- v)))\\<^sup>T =\n  R \\<cdot> v * v\\<^sup>T +\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T +\n  R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T +\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "also"], ["proof (state)\nthis:\n  R \\<cdot>\n  (v + choose_point (minimum R (- v))) *\n  (v + choose_point (minimum R (- v)))\\<^sup>T =\n  R \\<cdot> v * v\\<^sup>T +\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T +\n  R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T +\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "have \"... \\<le> ?W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<cdot> v * v\\<^sup>T +\n    R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T +\n    R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T +\n    R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "using a b c d"], ["proof (prove)\nusing this:\n  R \\<cdot> v * v\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n  R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot> v * v\\<^sup>T +\n    R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T +\n    R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T +\n    R \\<cdot>\n    choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "by (simp add: le_sup_iff)"], ["proof (state)\nthis:\n  R \\<cdot> v * v\\<^sup>T +\n  R \\<cdot> v * choose_point (minimum R (- v))\\<^sup>T +\n  R \\<cdot> choose_point (minimum R (- v)) * v\\<^sup>T +\n  R \\<cdot>\n  choose_point (minimum R (- v)) * choose_point (minimum R (- v))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "finally"], ["proof (chain)\npicking this:\n  R \\<cdot>\n  (v + choose_point (minimum R (- v))) *\n  (v + choose_point (minimum R (- v)))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<cdot>\n  (v + choose_point (minimum R (- v))) *\n  (v + choose_point (minimum R (- v)))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (1 subgoal):\n 1. R \\<cdot>\n    (v + choose_point (minimum R (- v))) *\n    (v + choose_point (minimum R (- v)))\\<^sup>T\n    \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+", "."], ["proof (state)\nthis:\n  R \\<cdot>\n  (v + choose_point (minimum R (- v))) *\n  (v + choose_point (minimum R (- v)))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<cdot>\n  (v + choose_point (minimum R (- v))) *\n  (v + choose_point (minimum R (- v)))\\<^sup>T\n  \\<le> (W + q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>+\n\ngoal (7 subgoals):\n 1. path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 3. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 4. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 5. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 6. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 7. is_vector (v + choose_point (minimum R (- v)))", "show pathW: \"path ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "proof (cases \"W = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "assume \"W = 0\""], ["proof (state)\nthis:\n  W = 0\n\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  W = 0\n\ngoal (1 subgoal):\n 1. path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "using assms(2) point_p edge_is_path point_is_point sup_bot_left"], ["proof (prove)\nusing this:\n  W = 0\n  topological_sort_inv q v R W\n  point (choose_point (minimum R (- v)))\n  \\<lbrakk>is_point ?p; is_point ?q\\<rbrakk>\n  \\<Longrightarrow> path (?p * ?q\\<^sup>T)\n  point ?x = is_point ?x\n  0 + ?x = ?x\n\ngoal (1 subgoal):\n 1. path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "by auto"], ["proof (state)\nthis:\n  path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "assume a1: \"W \\<noteq> 0\""], ["proof (state)\nthis:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "have fw_path: \"forward_terminating_path W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forward_terminating_path W", "using assms(2) terminating_iff"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n  terminating ?x = (backward_terminating ?x \\<and> forward_terminating ?x)\n\ngoal (1 subgoal):\n 1. forward_terminating_path W", "by blast"], ["proof (state)\nthis:\n  forward_terminating_path W\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "have bw_path: \"backward_terminating_path (q*?p\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path (q * choose_point (minimum R (- v))\\<^sup>T)", "using assms point_p sp_q"], ["proof (prove)\nusing this:\n  v \\<noteq> 1\n  topological_sort_inv q v R W\n  point (choose_point (minimum R (- v)))\n  start_points (q * choose_point (minimum R (- v))\\<^sup>T) = q\n\ngoal (1 subgoal):\n 1. backward_terminating_path (q * choose_point (minimum R (- v))\\<^sup>T)", "by (metis conv_backward_terminating conv_has_start_points conv_path edge_is_path\n                forward_terminating_iff1 point_is_point start_point_iff2)"], ["proof (state)\nthis:\n  backward_terminating_path (q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "using fw_path bw_path ep_sp 1 a1 path_concatenation_cycle_free"], ["proof (prove)\nusing this:\n  forward_terminating_path W\n  backward_terminating_path (q * choose_point (minimum R (- v))\\<^sup>T)\n  W \\<noteq> 0 \\<Longrightarrow>\n  end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)\n  W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 = 0\n  W \\<noteq> 0\n  \\<lbrakk>forward_terminating_path ?x; backward_terminating_path ?y;\n   end_points ?x = start_points ?y;\n   ?x * 1 \\<cdot> ?y\\<^sup>T * 1 = 0\\<rbrakk>\n  \\<Longrightarrow> path (?x + ?y)\n\ngoal (1 subgoal):\n 1. path (W + q * choose_point (minimum R (- v))\\<^sup>T)", "by blast"], ["proof (state)\nthis:\n  path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (6 subgoals):\n 1. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 3. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 4. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 5. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 6. is_vector (v + choose_point (minimum R (- v)))", "show \"terminating ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)", "proof (rule start_end_implies_terminating)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "show \"has_start_points ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "apply (cases \"W = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow>\n    has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "using assms(2) sp_q pathW"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n  start_points (q * choose_point (minimum R (- v))\\<^sup>T) = q\n  path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow>\n    has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "apply (metis (no_types, lifting) point_is_point start_point_iff2 sup_bot.left_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "using assms(2) ep_sp 1 pathW"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n  W \\<noteq> 0 \\<Longrightarrow>\n  end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)\n  W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 = 0\n  path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "by (metis has_start_end_points_iff path_concatenation_start_points start_point_iff2\n                terminating_iff1)"], ["proof (state)\nthis:\n  has_start_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "show \"has_end_points ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "apply (cases \"W = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow>\n    has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "using point_p ep_np ep_sp pathW end_point_iff2 point_is_point"], ["proof (prove)\nusing this:\n  point (choose_point (minimum R (- v)))\n  end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n  choose_point (minimum R (- v))\n  W \\<noteq> 0 \\<Longrightarrow>\n  end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)\n  path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n  path ?x \\<Longrightarrow> is_point (end_points ?x) = has_end_points ?x\n  point ?x = is_point ?x\n\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow>\n    has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. W \\<noteq> 0 \\<Longrightarrow>\n    has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "using point_p ep_np ep_sp 1 pathW"], ["proof (prove)\nusing this:\n  point (choose_point (minimum R (- v)))\n  end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n  choose_point (minimum R (- v))\n  W \\<noteq> 0 \\<Longrightarrow>\n  end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)\n  W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 = 0\n  path (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow>\n    has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "by (metis end_point_iff2 path_concatenation_end_points point_is_point)"], ["proof (state)\nthis:\n  has_end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminating (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (5 subgoals):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))\n 2. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 3. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 4. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 5. is_vector (v + choose_point (minimum R (- v)))", "show \"?W*1 = ?v\\<cdot>-?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))", "have \"?W*1 = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 = v", "by (metis assms(2) point_p is_vector_def mult_assoc point_def point_equations(3)\n                point_is_point aux4 distrib_right' inf_absorb2 sup.commute)"], ["proof (state)\nthis:\n  (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 = v\n\ngoal (1 subgoal):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))", "also"], ["proof (state)\nthis:\n  (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 = v\n\ngoal (1 subgoal):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))", "have \"... = v\\<cdot>-?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v \\<cdot> - choose_point (minimum R (- v))", "by (metis choose_point_decreasing compl_le_swap1 inf.cobounded1 inf.orderE order_trans)"], ["proof (state)\nthis:\n  v = v \\<cdot> - choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))", "finally"], ["proof (chain)\npicking this:\n  (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n  v \\<cdot> - choose_point (minimum R (- v))", "show ?thesis"], ["proof (prove)\nusing this:\n  (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n  v \\<cdot> - choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n    (v + choose_point (minimum R (- v))) \\<cdot>\n    - choose_point (minimum R (- v))", "by (simp add: inf_sup_distrib2)"], ["proof (state)\nthis:\n  (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n  (v + choose_point (minimum R (- v))) \\<cdot>\n  - choose_point (minimum R (- v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (W + q * choose_point (minimum R (- v))\\<^sup>T) * 1 =\n  (v + choose_point (minimum R (- v))) \\<cdot>\n  - choose_point (minimum R (- v))\n\ngoal (4 subgoals):\n 1. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 3. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 4. is_vector (v + choose_point (minimum R (- v)))", "show \"?W = 0 \\<or> ?p = end_points ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "using ep_np ep_sp 1"], ["proof (prove)\nusing this:\n  end_points (q * choose_point (minimum R (- v))\\<^sup>T) =\n  choose_point (minimum R (- v))\n  W \\<noteq> 0 \\<Longrightarrow>\n  end_points W = start_points (q * choose_point (minimum R (- v))\\<^sup>T)\n  W * 1 \\<cdot> (q * choose_point (minimum R (- v))\\<^sup>T)\\<^sup>T * 1 = 0\n\ngoal (1 subgoal):\n 1. W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n    choose_point (minimum R (- v)) =\n    end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)", "by (metis path_concatenation_end_points sup_bot_left)"], ["proof (state)\nthis:\n  W + q * choose_point (minimum R (- v))\\<^sup>T = 0 \\<or>\n  choose_point (minimum R (- v)) =\n  end_points (W + q * choose_point (minimum R (- v))\\<^sup>T)\n\ngoal (3 subgoals):\n 1. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))\n 2. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 3. is_vector (v + choose_point (minimum R (- v)))", "show \"R*?v \\<le> ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))", "using assms(2)"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. R * (v + choose_point (minimum R (- v)))\n    \\<le> v + choose_point (minimum R (- v))", "by (meson choose_point_decreasing conv_galois_1 inf.cobounded2 order.trans sup.coboundedI1\n              sup_least)"], ["proof (state)\nthis:\n  R * (v + choose_point (minimum R (- v)))\n  \\<le> v + choose_point (minimum R (- v))\n\ngoal (2 subgoals):\n 1. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n 2. is_vector (v + choose_point (minimum R (- v)))", "show \"?p \\<le> ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))", "by simp"], ["proof (state)\nthis:\n  choose_point (minimum R (- v)) \\<le> v + choose_point (minimum R (- v))\n\ngoal (1 subgoal):\n 1. is_vector (v + choose_point (minimum R (- v)))", "show \"is_vector ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector (v + choose_point (minimum R (- v)))", "using assms(2) point_p point_def vector_add"], ["proof (prove)\nusing this:\n  topological_sort_inv q v R W\n  point (choose_point (minimum R (- v)))\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  \\<lbrakk>is_vector ?x; is_vector ?y\\<rbrakk>\n  \\<Longrightarrow> is_vector (?x + ?y)\n\ngoal (1 subgoal):\n 1. is_vector (v + choose_point (minimum R (- v)))", "by blast"], ["proof (state)\nthis:\n  is_vector (v + choose_point (minimum R (- v)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma topological_sort_post:\n assumes \"\\<not> v \\<noteq> 1\"\n     and \"topological_sort_inv q v R W\"\n   shows \"R \\<le> W\\<^sup>+ \\<and> terminating_path W \\<and> (W + W\\<^sup>T)*1 = -1'*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<le> W\\<^sup>+ \\<and>\n    terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "proof (intro conjI,simp_all add:assms)"], ["proof (state)\ngoal (3 subgoals):\n 1. R \\<le> W\\<^sup>+\n 2. backward_terminating W \\<and> W \\<le> 1 * W * (- v + q)\n 3. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "show \"R \\<le> W\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<le> W\\<^sup>+", "using assms"], ["proof (prove)\nusing this:\n  \\<not> v \\<noteq> 1\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. R \\<le> W\\<^sup>+", "by force"], ["proof (state)\nthis:\n  R \\<le> W\\<^sup>+\n\ngoal (2 subgoals):\n 1. backward_terminating W \\<and> W \\<le> 1 * W * (- v + q)\n 2. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "show \" backward_terminating W \\<and> W \\<le> 1 * W * (- v + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating W \\<and> W \\<le> 1 * W * (- v + q)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> v \\<noteq> 1\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. backward_terminating W \\<and> W \\<le> 1 * W * (- v + q)", "by force"], ["proof (state)\nthis:\n  backward_terminating W \\<and> W \\<le> 1 * W * (- v + q)\n\ngoal (1 subgoal):\n 1. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "show \"v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "proof (cases \"W = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1\n 2. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "assume \"W = 0\""], ["proof (state)\nthis:\n  W = 0\n\ngoal (2 subgoals):\n 1. W = 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1\n 2. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  W = 0\n\ngoal (1 subgoal):\n 1. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "using assms"], ["proof (prove)\nusing this:\n  W = 0\n  \\<not> v \\<noteq> 1\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "by (metis compl_bot_eq conv_one conv_zero double_compl inf_top.left_neutral is_inj_def\n                  le_bot mult_1_right one_idem_mult point_def ss_p18 star_zero sup.absorb2 top_le)"], ["proof (state)\nthis:\n  v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "assume a1: \"W \\<noteq> 0\""], ["proof (state)\nthis:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "hence \"-1' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. - 1' \\<noteq> 0", "using assms backward_terminating_path_irreflexive le_bot"], ["proof (prove)\nusing this:\n  W \\<noteq> 0\n  \\<not> v \\<noteq> 1\n  topological_sort_inv q v R W\n  backward_terminating_path ?x \\<Longrightarrow> ?x \\<le> - 1'\n  ?a \\<le> 0 \\<Longrightarrow> ?a = 0\n\ngoal (1 subgoal):\n 1. - 1' \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  - 1' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "hence \"1 = 1*-1'*1\""], ["proof (prove)\nusing this:\n  - 1' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 = 1 * - 1' * 1", "by (simp add: tarski)"], ["proof (state)\nthis:\n  1 = 1 * - 1' * 1\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "also"], ["proof (state)\nthis:\n  1 = 1 * - 1' * 1\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "have \"... = -1'*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * - 1' * 1 = - 1' * 1", "by (metis comp_assoc distrib_left mult_1_left sup_top_left distrib_right sup_compl_top)"], ["proof (state)\nthis:\n  1 * - 1' * 1 = - 1' * 1\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "finally"], ["proof (chain)\npicking this:\n  1 = - 1' * 1", "have a: \"1 = -1'*1\""], ["proof (prove)\nusing this:\n  1 = - 1' * 1\n\ngoal (1 subgoal):\n 1. 1 = - 1' * 1", "."], ["proof (state)\nthis:\n  1 = - 1' * 1\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "have \"W*1 + W\\<^sup>T*1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W * 1 + W\\<^sup>T * 1 = 1", "using assms a1"], ["proof (prove)\nusing this:\n  \\<not> v \\<noteq> 1\n  topological_sort_inv q v R W\n  W \\<noteq> 0\n\ngoal (1 subgoal):\n 1. W * 1 + W\\<^sup>T * 1 = 1", "by (metis double_compl galois_aux4 inf.absorb_iff2 inf_top.left_neutral)"], ["proof (state)\nthis:\n  W * 1 + W\\<^sup>T * 1 = 1\n\ngoal (1 subgoal):\n 1. W \\<noteq> 0 \\<Longrightarrow> v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  W * 1 + W\\<^sup>T * 1 = 1\n\ngoal (1 subgoal):\n 1. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "using a"], ["proof (prove)\nusing this:\n  W * 1 + W\\<^sup>T * 1 = 1\n  1 = - 1' * 1\n\ngoal (1 subgoal):\n 1. v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<cdot> - q + W\\<^sup>T * 1 = - 1' * 1\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem topological_sort_partial: \"VARS p q v W\n  { regressively_finite R }\n  W := 0;\n  q := choose_point (minimum R 1);\n  v := q;\n  WHILE v \\<noteq> 1\n    INV { topological_sort_inv q v R W }\n     DO p := choose_point (minimum R (-v));\n        W := W + q*p\\<^sup>T;\n        q := p;\n        v := v + p\n     OD\n  { R \\<le> W\\<^sup>+ \\<and> terminating_path W \\<and> (W + W\\<^sup>T)*1 = -1'*1 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {regressively_finite R} \n     W := 0;\n     q := choose_point (minimum R 1);\n     v := q;\n     WHILE v \\<noteq> 1 INV {topological_sort_inv q v R W} \n      VAR {\\<lambda>(p, q, v, W). zero_class.zero} \n      DO p := choose_point (minimum R (- v));\n         W := W + q * p\\<^sup>T; q := p; v := v + p \n      OD \n     {R \\<le> W\\<^sup>+ \\<and>\n      terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1}", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q v W.\n       regressively_finite R \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R 1))\n        (choose_point (minimum R 1)) R 0\n 2. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and> v \\<noteq> 1 \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R (- v)))\n        (v + choose_point (minimum R (- v))) R\n        (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 3. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "using topological_sort_pre"], ["proof (prove)\nusing this:\n  regressively_finite ?R \\<Longrightarrow>\n  topological_sort_inv (choose_point (minimum ?R 1))\n   (choose_point (minimum ?R 1)) ?R 0\n\ngoal (3 subgoals):\n 1. \\<And>p q v W.\n       regressively_finite R \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R 1))\n        (choose_point (minimum R 1)) R 0\n 2. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and> v \\<noteq> 1 \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R (- v)))\n        (v + choose_point (minimum R (- v))) R\n        (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 3. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and> v \\<noteq> 1 \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R (- v)))\n        (v + choose_point (minimum R (- v))) R\n        (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "using topological_sort_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> 1; topological_sort_inv ?q ?v ?R ?W\\<rbrakk>\n  \\<Longrightarrow> topological_sort_inv (choose_point (minimum ?R (- ?v)))\n                     (?v + choose_point (minimum ?R (- ?v))) ?R\n                     (?W + ?q * choose_point (minimum ?R (- ?v))\\<^sup>T)\n\ngoal (2 subgoals):\n 1. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and> v \\<noteq> 1 \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R (- v)))\n        (v + choose_point (minimum R (- v))) R\n        (W + q * choose_point (minimum R (- v))\\<^sup>T)\n 2. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "using topological_sort_post"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?v \\<noteq> 1; topological_sort_inv ?q ?v ?R ?W\\<rbrakk>\n  \\<Longrightarrow> ?R \\<le> ?W\\<^sup>+ \\<and>\n                    terminating_path ?W \\<and>\n                    (?W + ?W\\<^sup>T) * 1 = - 1' * 1\n\ngoal (1 subgoal):\n 1. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "by blast"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point *)"], ["", "context relation_algebra_rtc_tarski_choose_point_finite\nbegin"], ["", "lemma topological_sort_inv_termination:\n  assumes \"v \\<noteq> 1\"\n      and \"topological_sort_inv q v R W\"\n    shows \"card {z . z \\<le> -(v + choose_point (minimum R (-v)))} < card { z . z \\<le> -v }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {z. z \\<le> - (v + choose_point (minimum R (- v)))}\n    < card {z. z \\<le> - v}", "proof (rule decrease_variant)"], ["proof (state)\ngoal (3 subgoals):\n 1. - (v + choose_point (minimum R (- v))) \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v + choose_point (minimum R (- v)))", "let ?p = \"choose_point (minimum R (-v))\""], ["proof (state)\ngoal (3 subgoals):\n 1. - (v + choose_point (minimum R (- v))) \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v + choose_point (minimum R (- v)))", "let ?v = \"v + ?p\""], ["proof (state)\ngoal (3 subgoals):\n 1. - (v + choose_point (minimum R (- v))) \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v + choose_point (minimum R (- v)))", "show \"-?v \\<le> -v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (v + choose_point (minimum R (- v))) \\<le> - v", "by simp"], ["proof (state)\nthis:\n  - (v + choose_point (minimum R (- v))) \\<le> - v\n\ngoal (2 subgoals):\n 1. ?w \\<le> - v\n 2. \\<not> ?w \\<le> - (v + choose_point (minimum R (- v)))", "show \"?p \\<le> -v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_point (minimum R (- v)) \\<le> - v", "using choose_point_decreasing inf.boundedE"], ["proof (prove)\nusing this:\n  choose_point ?x \\<le> ?x\n  \\<lbrakk>?a \\<le> ?b \\<cdot> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. choose_point (minimum R (- v)) \\<le> - v", "by blast"], ["proof (state)\nthis:\n  choose_point (minimum R (- v)) \\<le> - v\n\ngoal (1 subgoal):\n 1. \\<not> choose_point (minimum R (- v))\n           \\<le> - (v + choose_point (minimum R (- v)))", "have \"point ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (choose_point (minimum R (- v)))", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> 1\n  topological_sort_inv q v R W\n\ngoal (1 subgoal):\n 1. point (choose_point (minimum R (- v)))", "by (metis choose_point_point compl_bot_eq double_compl galois_aux2 comp_assoc is_vector_def\n              vector_compl vector_mult)"], ["proof (state)\nthis:\n  point (choose_point (minimum R (- v)))\n\ngoal (1 subgoal):\n 1. \\<not> choose_point (minimum R (- v))\n           \\<le> - (v + choose_point (minimum R (- v)))", "thus \"\\<not> (?p \\<le> -?v)\""], ["proof (prove)\nusing this:\n  point (choose_point (minimum R (- v)))\n\ngoal (1 subgoal):\n 1. \\<not> choose_point (minimum R (- v))\n           \\<le> - (v + choose_point (minimum R (- v)))", "by (metis annir compl_sup inf.absorb1 inf_compl_bot_right maddux_20 no_end_point_char)"], ["proof (state)\nthis:\n  \\<not> choose_point (minimum R (- v))\n         \\<le> - (v + choose_point (minimum R (- v)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nUse precondition \\<open>is_acyclic\\<close> instead of \\<open>regressively_finite\\<close>.\nThey are equivalent for finite graphs.\n\\<close>"], ["", "theorem topological_sort_total: \"VARS p q v W\n  [ is_acyclic R ]\n  W := 0;\n  q := choose_point (minimum R 1);\n  v := q;\n  WHILE v \\<noteq> 1\n    INV { topological_sort_inv q v R W }\n    VAR { card { z . z \\<le> -v } }\n      DO p := choose_point (minimum R (-v));\n         W := W + q*p\\<^sup>T;\n         q := p;\n         v := v + p\n      OD\n   [ R \\<le> W\\<^sup>+ \\<and> terminating_path W \\<and> (W + W\\<^sup>T)*1 = -1'*1 ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [is_acyclic R] \n     W := 0;\n     q := choose_point (minimum R 1);\n     v := q;\n     WHILE v \\<noteq> 1 INV {topological_sort_inv q v R W} \n      VAR {\\<lambda>(p, q, v, W). card {z. z \\<le> - v}} \n      DO p := choose_point (minimum R (- v));\n         W := W + q * p\\<^sup>T; q := p; v := v + p \n      OD \n     [R \\<le> W\\<^sup>+ \\<and>\n      terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1]", "apply vcg_tc"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q v W.\n       is_acyclic R \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R 1))\n        (choose_point (minimum R 1)) R 0\n 2. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_point (minimum R (- v)), choose_point (minimum R (- v)),\n        v + choose_point (minimum R (- v)),\n        W + q * choose_point (minimum R (- v))\\<^sup>T)\n       \\<in> {s. (case s of\n                  (p, q, v, W) \\<Rightarrow>\n                    topological_sort_inv q v R W) \\<and>\n                 (case s of\n                  (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n                 < n}\n 3. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "apply (drule acyclic_regressively_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q v W.\n       regressively_finite R \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R 1))\n        (choose_point (minimum R 1)) R 0\n 2. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_point (minimum R (- v)), choose_point (minimum R (- v)),\n        v + choose_point (minimum R (- v)),\n        W + q * choose_point (minimum R (- v))\\<^sup>T)\n       \\<in> {s. (case s of\n                  (p, q, v, W) \\<Rightarrow>\n                    topological_sort_inv q v R W) \\<and>\n                 (case s of\n                  (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n                 < n}\n 3. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "using topological_sort_pre"], ["proof (prove)\nusing this:\n  regressively_finite ?R \\<Longrightarrow>\n  topological_sort_inv (choose_point (minimum ?R 1))\n   (choose_point (minimum ?R 1)) ?R 0\n\ngoal (3 subgoals):\n 1. \\<And>p q v W.\n       regressively_finite R \\<Longrightarrow>\n       topological_sort_inv (choose_point (minimum R 1))\n        (choose_point (minimum R 1)) R 0\n 2. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_point (minimum R (- v)), choose_point (minimum R (- v)),\n        v + choose_point (minimum R (- v)),\n        W + q * choose_point (minimum R (- v))\\<^sup>T)\n       \\<in> {s. (case s of\n                  (p, q, v, W) \\<Rightarrow>\n                    topological_sort_inv q v R W) \\<and>\n                 (case s of\n                  (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n                 < n}\n 3. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_point (minimum R (- v)), choose_point (minimum R (- v)),\n        v + choose_point (minimum R (- v)),\n        W + q * choose_point (minimum R (- v))\\<^sup>T)\n       \\<in> {s. (case s of\n                  (p, q, v, W) \\<Rightarrow>\n                    topological_sort_inv q v R W) \\<and>\n                 (case s of\n                  (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n                 < n}\n 2. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "apply (rule CollectI, rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       case (choose_point (minimum R (- v)), choose_point (minimum R (- v)),\n             v + choose_point (minimum R (- v)),\n             W + q * choose_point (minimum R (- v))\\<^sup>T) of\n       (p, q, v, W) \\<Rightarrow> topological_sort_inv q v R W\n 2. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_point (minimum R (- v)),\n              choose_point (minimum R (- v)),\n              v + choose_point (minimum R (- v)),\n              W + q * choose_point (minimum R (- v))\\<^sup>T) of\n        (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 3. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "using topological_sort_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> 1; topological_sort_inv ?q ?v ?R ?W\\<rbrakk>\n  \\<Longrightarrow> topological_sort_inv (choose_point (minimum ?R (- ?v)))\n                     (?v + choose_point (minimum ?R (- ?v))) ?R\n                     (?W + ?q * choose_point (minimum ?R (- ?v))\\<^sup>T)\n\ngoal (3 subgoals):\n 1. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       case (choose_point (minimum R (- v)), choose_point (minimum R (- v)),\n             v + choose_point (minimum R (- v)),\n             W + q * choose_point (minimum R (- v))\\<^sup>T) of\n       (p, q, v, W) \\<Rightarrow> topological_sort_inv q v R W\n 2. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_point (minimum R (- v)),\n              choose_point (minimum R (- v)),\n              v + choose_point (minimum R (- v)),\n              W + q * choose_point (minimum R (- v))\\<^sup>T) of\n        (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 3. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_point (minimum R (- v)),\n              choose_point (minimum R (- v)),\n              v + choose_point (minimum R (- v)),\n              W + q * choose_point (minimum R (- v))\\<^sup>T) of\n        (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 2. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "using topological_sort_inv_termination"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> 1; topological_sort_inv ?q ?v ?R ?W\\<rbrakk>\n  \\<Longrightarrow> card\n                     {z. z \\<le> - (?v + choose_point (minimum ?R (- ?v)))}\n                    < card {z. z \\<le> - ?v}\n\ngoal (2 subgoals):\n 1. \\<And>n p q v W.\n       (topological_sort_inv q v R W \\<and> v \\<noteq> 1) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_point (minimum R (- v)),\n              choose_point (minimum R (- v)),\n              v + choose_point (minimum R (- v)),\n              W + q * choose_point (minimum R (- v))\\<^sup>T) of\n        (p, q, v, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 2. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "using topological_sort_post"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?v \\<noteq> 1; topological_sort_inv ?q ?v ?R ?W\\<rbrakk>\n  \\<Longrightarrow> ?R \\<le> ?W\\<^sup>+ \\<and>\n                    terminating_path ?W \\<and>\n                    (?W + ?W\\<^sup>T) * 1 = - 1' * 1\n\ngoal (1 subgoal):\n 1. \\<And>p q v W.\n       topological_sort_inv q v R W \\<and>\n       \\<not> v \\<noteq> 1 \\<Longrightarrow>\n       R \\<le> W\\<^sup>+ \\<and>\n       terminating_path W \\<and> (W + W\\<^sup>T) * 1 = - 1' * 1", "by blast"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point_finite *)"], ["", "subsection \\<open>Construction of a tree\\<close>"], ["", "text \\<open>\nOur last application is a correctness proof of an algorithm that constructs a non-empty cycle for a given directed graph.\nThis works in two steps.\nThe first step is to construct a directed tree from a given root along the edges of the graph.\n\\<close>"], ["", "context relation_algebra_rtc_tarski_choose_point\nbegin"], ["", "abbreviation construct_tree_pre\n  where \"construct_tree_pre x y R \\<equiv> y \\<le> R\\<^sup>T\\<^sup>\\<star>*x \\<and> point x\""], ["", "abbreviation construct_tree_inv\n  where \"construct_tree_inv v x y D R \\<equiv> construct_tree_pre x y R \\<and> is_acyclic D \\<and> is_inj D \\<and>\n                                         D \\<le> R \\<and> D*x = 0 \\<and> v = x + D\\<^sup>T*1 \\<and> x*v\\<^sup>T \\<le> D\\<^sup>\\<star> \\<and> D \\<le> v*v\\<^sup>T \\<and>\n                                         is_vector v\""], ["", "abbreviation construct_tree_post\n  where \"construct_tree_post x y D R \\<equiv> is_acyclic D \\<and> is_inj D \\<and> D \\<le> R \\<and> D*x = 0 \\<and> D\\<^sup>T*1 \\<le> D\\<^sup>T\\<^sup>\\<star>*x \\<and>\n                                        D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["", "lemma construct_tree_pre:\n  assumes \"construct_tree_pre x y R\"\n    shows \"construct_tree_inv x x y 0 R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_tree_inv x x y 0 R", "using assms"], ["proof (prove)\nusing this:\n  construct_tree_pre x y R\n\ngoal (1 subgoal):\n 1. construct_tree_inv x x y 0 R", "by (simp add: is_inj_def point_def)"], ["", "lemma construct_tree_inv_aux:\n  assumes \"\\<not> y \\<le> v\"\n      and \"construct_tree_inv v x y D R\"\n    shows \"singleton (choose_singleton (v*-v\\<^sup>T \\<cdot> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton (choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "proof (rule choose_singleton_singleton, rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. v * - v\\<^sup>T \\<cdot> R = 0 \\<Longrightarrow> False", "assume \"v*-v\\<^sup>T \\<cdot> R = 0\""], ["proof (state)\nthis:\n  v * - v\\<^sup>T \\<cdot> R = 0\n\ngoal (1 subgoal):\n 1. v * - v\\<^sup>T \\<cdot> R = 0 \\<Longrightarrow> False", "hence \"R\\<^sup>T\\<^sup>\\<star>*v \\<le> v\""], ["proof (prove)\nusing this:\n  v * - v\\<^sup>T \\<cdot> R = 0\n\ngoal (1 subgoal):\n 1. R\\<^sup>T\\<^sup>\\<star> * v \\<le> v", "by (metis galois_aux conv_compl conv_galois_1 conv_galois_2 conv_invol double_compl\n              star_inductl_var)"], ["proof (state)\nthis:\n  R\\<^sup>T\\<^sup>\\<star> * v \\<le> v\n\ngoal (1 subgoal):\n 1. v * - v\\<^sup>T \\<cdot> R = 0 \\<Longrightarrow> False", "hence \"y = 0\""], ["proof (prove)\nusing this:\n  R\\<^sup>T\\<^sup>\\<star> * v \\<le> v\n\ngoal (1 subgoal):\n 1. y = 0", "using assms"], ["proof (prove)\nusing this:\n  R\\<^sup>T\\<^sup>\\<star> * v \\<le> v\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n\ngoal (1 subgoal):\n 1. y = 0", "by (meson mult_isol order_trans sup.cobounded1)"], ["proof (state)\nthis:\n  y = 0\n\ngoal (1 subgoal):\n 1. v * - v\\<^sup>T \\<cdot> R = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  y = 0\n\ngoal (1 subgoal):\n 1. False", "using assms point_is_point"], ["proof (prove)\nusing this:\n  y = 0\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n  point ?x = is_point ?x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_tree_inv:\n  assumes \"\\<not> y \\<le> v\"\n      and \"construct_tree_inv v x y D R\"\n    shows \"construct_tree_inv (v + choose_singleton (v*-v\\<^sup>T \\<cdot> R)\\<^sup>T*1) x y (D +\n                               choose_singleton (v*-v\\<^sup>T \\<cdot> R)) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_tree_inv\n     (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n     (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R", "proof (intro conjI)"], ["proof (state)\ngoal (10 subgoals):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n 2. point x\n 3. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 4. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 5. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 6. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 7. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 8. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 9. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 10. is_vector\n      (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "let ?e = \"choose_singleton (v*-v\\<^sup>T \\<cdot> R)\""], ["proof (state)\ngoal (10 subgoals):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n 2. point x\n 3. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 4. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 5. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 6. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 7. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 8. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 9. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 10. is_vector\n      (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "let ?D = \"D + ?e\""], ["proof (state)\ngoal (10 subgoals):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n 2. point x\n 3. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 4. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 5. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 6. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 7. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 8. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 9. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 10. is_vector\n      (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "let ?v = \"v + ?e\\<^sup>T*1\""], ["proof (state)\ngoal (10 subgoals):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n 2. point x\n 3. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 4. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 5. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 6. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 7. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 8. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 9. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 10. is_vector\n      (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "have 1: \"?e \\<le> v*-v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T", "using choose_singleton_decreasing inf.boundedE"], ["proof (prove)\nusing this:\n  choose_singleton ?x \\<le> ?x\n  \\<lbrakk>?a \\<le> ?b \\<cdot> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T", "by blast"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n\ngoal (10 subgoals):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n 2. point x\n 3. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 4. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 5. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 6. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 7. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 8. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 9. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 10. is_vector\n      (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"point x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point x", "by (simp add: assms)"], ["proof (state)\nthis:\n  point x\n\ngoal (9 subgoals):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n 2. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 3. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 4. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 5. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 6. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 7. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 8. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 9. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"y \\<le> R\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x", "by (simp add: assms)"], ["proof (state)\nthis:\n  y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (8 subgoals):\n 1. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 2. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 3. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 4. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 5. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 6. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 7. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 8. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"is_acyclic ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "using 1 assms acyclic_inv"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n  \\<lbrakk>is_acyclic ?t; is_vector ?v; ?e \\<le> ?v * - ?v\\<^sup>T;\n   ?t \\<le> ?v * ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> is_acyclic (?t + ?e)\n\ngoal (1 subgoal):\n 1. is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "by fastforce"], ["proof (state)\nthis:\n  is_acyclic (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n\ngoal (7 subgoals):\n 1. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n 2. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 3. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 4. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 5. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 6. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 7. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"is_inj ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "using 1 construct_tree_inv_aux assms injective_inv"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> singleton\n                     (choose_singleton (?v * - ?v\\<^sup>T \\<cdot> ?R))\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n  \\<lbrakk>is_vector ?v; singleton ?e; ?e \\<le> ?v * - ?v\\<^sup>T;\n   ?t \\<le> ?v * ?v\\<^sup>T; is_inj ?t\\<rbrakk>\n  \\<Longrightarrow> is_inj (?t + ?e)\n\ngoal (1 subgoal):\n 1. is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "by blast"], ["proof (state)\nthis:\n  is_inj (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n\ngoal (6 subgoals):\n 1. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n 2. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 3. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 4. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 5. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 6. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"?D \\<le> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R", "apply (rule sup.boundedI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. D \\<le> R\n 2. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R", "using assms"], ["proof (prove)\nusing this:\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n\ngoal (2 subgoals):\n 1. D \\<le> R\n 2. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R", "using choose_singleton_decreasing inf.boundedE"], ["proof (prove)\nusing this:\n  choose_singleton ?x \\<le> ?x\n  \\<lbrakk>?a \\<le> ?b \\<cdot> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R", "by blast"], ["proof (state)\nthis:\n  D + choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> R\n\ngoal (5 subgoals):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n 2. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 3. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 4. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 5. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"?D*x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "have \"?D*x = ?e*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x =\n    choose_singleton (v * - v\\<^sup>T \\<cdot> R) * x", "by (simp add: assms)"], ["proof (state)\nthis:\n  (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x =\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) * x\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "also"], ["proof (state)\nthis:\n  (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x =\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) * x\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "have \"... \\<le> ?e*v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) * x\n    \\<le> choose_singleton (v * - v\\<^sup>T \\<cdot> R) * v", "by (simp add: assms mult_isol)"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) * x\n  \\<le> choose_singleton (v * - v\\<^sup>T \\<cdot> R) * v\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "also"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) * x\n  \\<le> choose_singleton (v * - v\\<^sup>T \\<cdot> R) * v\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "have \"... \\<le> v*-v\\<^sup>T*v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) * v\n    \\<le> v * - v\\<^sup>T * v", "using 1 mult_isor"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) * v\n    \\<le> v * - v\\<^sup>T * v", "by blast"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) * v \\<le> v * - v\\<^sup>T * v\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "also"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) * v \\<le> v * - v\\<^sup>T * v\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * - v\\<^sup>T * v = 0", "by (metis assms(2) annir comp_assoc vector_prop1)"], ["proof (state)\nthis:\n  v * - v\\<^sup>T * v = 0\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "finally"], ["proof (chain)\npicking this:\n  (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x \\<le> 0\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "using le_bot"], ["proof (prove)\nusing this:\n  (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x \\<le> 0\n  ?a \\<le> 0 \\<Longrightarrow> ?a = 0\n\ngoal (1 subgoal):\n 1. (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0", "by blast"], ["proof (state)\nthis:\n  (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) * x = 0\n\ngoal (4 subgoals):\n 1. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n 2. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 3. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 4. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"?v = x + ?D\\<^sup>T*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n    x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1", "by (simp add: assms sup_assoc)"], ["proof (state)\nthis:\n  v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 =\n  x + (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>T * 1\n\ngoal (3 subgoals):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n 2. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 3. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"x*?v\\<^sup>T \\<le> ?D\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"x*?v\\<^sup>T = x*v\\<^sup>T + x*1*?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T =\n    x * v\\<^sup>T + x * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)", "by (simp add: distrib_left mult_assoc)"], ["proof (state)\nthis:\n  x *\n  (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T =\n  x * v\\<^sup>T + x * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x *\n  (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T =\n  x * v\\<^sup>T + x * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"... \\<le> D\\<^sup>\\<star> + x*1*(?e \\<cdot> v*-v\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * v\\<^sup>T + x * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> D\\<^sup>\\<star> +\n          x * 1 *\n          (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot>\n           v * - v\\<^sup>T)", "using 1"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. x * v\\<^sup>T + x * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> D\\<^sup>\\<star> +\n          x * 1 *\n          (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot>\n           v * - v\\<^sup>T)", "by (metis assms(2) inf.absorb1 join_iso)"], ["proof (state)\nthis:\n  x * v\\<^sup>T + x * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> D\\<^sup>\\<star> +\n        x * 1 *\n        (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot>\n         v * - v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * v\\<^sup>T + x * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> D\\<^sup>\\<star> +\n        x * 1 *\n        (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot>\n         v * - v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"... = D\\<^sup>\\<star> + x*1*(?e \\<cdot> v \\<cdot> -v\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    x * 1 *\n    (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v * - v\\<^sup>T) =\n    D\\<^sup>\\<star> +\n    x * 1 *\n    (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v \\<cdot>\n     - v\\<^sup>T)", "by (metis assms(2) comp_assoc conv_compl inf.assoc vector_compl vector_meet_comp)"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * 1 *\n  (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v * - v\\<^sup>T) =\n  D\\<^sup>\\<star> +\n  x * 1 *\n  (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v \\<cdot>\n   - v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * 1 *\n  (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v * - v\\<^sup>T) =\n  D\\<^sup>\\<star> +\n  x * 1 *\n  (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v \\<cdot>\n   - v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"... \\<le> D\\<^sup>\\<star> + x*1*(?e \\<cdot> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    x * 1 *\n    (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v \\<cdot>\n     - v\\<^sup>T)\n    \\<le> D\\<^sup>\\<star> +\n          x * 1 * (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v)", "using join_isol mult_subdistl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z + ?x \\<le> ?z + ?y\n  ?x * (?y \\<cdot> ?z) \\<le> ?x * ?y\n\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    x * 1 *\n    (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v \\<cdot>\n     - v\\<^sup>T)\n    \\<le> D\\<^sup>\\<star> +\n          x * 1 * (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v)", "by fastforce"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * 1 *\n  (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v \\<cdot>\n   - v\\<^sup>T)\n  \\<le> D\\<^sup>\\<star> +\n        x * 1 * (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * 1 *\n  (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v \\<cdot>\n   - v\\<^sup>T)\n  \\<le> D\\<^sup>\\<star> +\n        x * 1 * (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"... = D\\<^sup>\\<star> + x*(1 \\<cdot> v\\<^sup>T)*?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    x * 1 * (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v) =\n    D\\<^sup>\\<star> +\n    x * (1 \\<cdot> v\\<^sup>T) * choose_singleton (v * - v\\<^sup>T \\<cdot> R)", "by (metis assms(2) inf.commute mult_assoc vector_2)"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * 1 * (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v) =\n  D\\<^sup>\\<star> +\n  x * (1 \\<cdot> v\\<^sup>T) * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * 1 * (choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<cdot> v) =\n  D\\<^sup>\\<star> +\n  x * (1 \\<cdot> v\\<^sup>T) * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"... = D\\<^sup>\\<star> + x*v\\<^sup>T*?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    x * (1 \\<cdot> v\\<^sup>T) *\n    choose_singleton (v * - v\\<^sup>T \\<cdot> R) =\n    D\\<^sup>\\<star> +\n    x * v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R)", "by simp"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * (1 \\<cdot> v\\<^sup>T) * choose_singleton (v * - v\\<^sup>T \\<cdot> R) =\n  D\\<^sup>\\<star> +\n  x * v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * (1 \\<cdot> v\\<^sup>T) * choose_singleton (v * - v\\<^sup>T \\<cdot> R) =\n  D\\<^sup>\\<star> +\n  x * v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"... \\<le> D\\<^sup>\\<star> + D\\<^sup>\\<star>*?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    x * v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> D\\<^sup>\\<star> +\n          D\\<^sup>\\<star> * choose_singleton (v * - v\\<^sup>T \\<cdot> R)", "using assms join_isol mult_isor"], ["proof (prove)\nusing this:\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n  ?x \\<le> ?y \\<Longrightarrow> ?z + ?x \\<le> ?z + ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    x * v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> D\\<^sup>\\<star> +\n          D\\<^sup>\\<star> * choose_singleton (v * - v\\<^sup>T \\<cdot> R)", "by blast"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> D\\<^sup>\\<star> +\n        D\\<^sup>\\<star> * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  x * v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> D\\<^sup>\\<star> +\n        D\\<^sup>\\<star> * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "have \"... \\<le> ?D\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> +\n    D\\<^sup>\\<star> * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "by (meson le_sup_iff prod_star_closure star_ext star_subdist)"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> +\n  D\\<^sup>\\<star> * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x * (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n  \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  x * (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n  \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x *\n    (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n    \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  x * (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n  \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x * (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n  \\<le> (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n 2. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"?D \\<le> ?v*?v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "proof (rule sup.boundedI)"], ["proof (state)\ngoal (2 subgoals):\n 1. D \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n            (v +\n             choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n             1)\\<^sup>T\n 2. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "show \"D \\<le> ?v*?v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n            (v +\n             choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n             1)\\<^sup>T", "using assms"], ["proof (prove)\nusing this:\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n\ngoal (1 subgoal):\n 1. D \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n            (v +\n             choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n             1)\\<^sup>T", "by (meson conv_add distrib_left le_supI1 conv_iso dual_order.trans mult_isol_var order_prop)"], ["proof (state)\nthis:\n  D \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "have \"?e \\<le> v*(-v\\<^sup>T \\<cdot> v\\<^sup>T*?e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> v *\n          (- v\\<^sup>T \\<cdot>\n           v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "using 1 inf.absorb_iff2 modular_1'"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n  (?b \\<le> ?a) = (?a \\<cdot> ?b = ?b)\n  ?x * ?y \\<cdot> ?z = ?x * (?y \\<cdot> ?x\\<^sup>T * ?z) \\<cdot> ?z\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> v *\n          (- v\\<^sup>T \\<cdot>\n           v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "by fastforce"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> v *\n        (- v\\<^sup>T \\<cdot>\n         v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "also"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> v *\n        (- v\\<^sup>T \\<cdot>\n         v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "have \"... \\<le> v*1*?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v *\n    (- v\\<^sup>T \\<cdot>\n     v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n    \\<le> v * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)", "by (simp add: comp_assoc le_infI2 mult_isol_var)"], ["proof (state)\nthis:\n  v *\n  (- v\\<^sup>T \\<cdot>\n   v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n  \\<le> v * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "also"], ["proof (state)\nthis:\n  v *\n  (- v\\<^sup>T \\<cdot>\n   v\\<^sup>T * choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n  \\<le> v * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "have \"... \\<le> ?v*?v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "by (metis conv_contrav conv_invol conv_iso conv_one mult_assoc mult_isol_var sup.cobounded1\n                sup_ge2)"], ["proof (state)\nthis:\n  v * 1 * choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n        (v +\n         choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "finally"], ["proof (chain)\npicking this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n        (v +\n         choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "show \"?e \\<le> ?v*?v\\<^sup>T\""], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n        (v +\n         choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n    \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n          (v +\n           choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n        (v +\n         choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\n  \\<le> (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) *\n        (v +\n         choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "show \"is_vector ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "using assms comp_assoc is_vector_def"], ["proof (prove)\nusing this:\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n  ?x * ?y * ?z = ?x * (?y * ?z)\n  is_vector ?x \\<equiv> ?x = ?x * 1\n\ngoal (1 subgoal):\n 1. is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)", "by fastforce"], ["proof (state)\nthis:\n  is_vector (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_tree_post:\n  assumes \"y \\<le> v\"\n      and \"construct_tree_inv v x y D R\"\n    shows \"construct_tree_post x y D R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "have \"v*x\\<^sup>T \\<le> D\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * x\\<^sup>T \\<le> D\\<^sup>T\\<^sup>\\<star>", "by (metis (no_types, lifting) assms(2) conv_contrav conv_invol conv_iso star_conv)"], ["proof (state)\nthis:\n  v * x\\<^sup>T \\<le> D\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "hence 1: \"v \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\nusing this:\n  v * x\\<^sup>T \\<le> D\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. v \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "using assms point_def ss423bij"], ["proof (prove)\nusing this:\n  v * x\\<^sup>T \\<le> D\\<^sup>T\\<^sup>\\<star>\n  y \\<le> v\n  construct_tree_inv v x y D R\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  bijective ?x \\<Longrightarrow>\n  (?y * ?x\\<^sup>T \\<le> ?z) = (?y \\<le> ?z * ?x)\n\ngoal (1 subgoal):\n 1. v \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "by blast"], ["proof (state)\nthis:\n  v \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "hence 2: \"D\\<^sup>T*1 \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\nusing this:\n  v \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. D\\<^sup>T * 1 \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "using assms le_supE"], ["proof (prove)\nusing this:\n  v \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n  y \\<le> v\n  construct_tree_inv v x y D R\n  \\<lbrakk>?a + ?b \\<le> ?x;\n   \\<lbrakk>?a \\<le> ?x; ?b \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. D\\<^sup>T * 1 \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "by blast"], ["proof (state)\nthis:\n  D\\<^sup>T * 1 \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "have \"D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "proof (rule star_inductl, rule sup.boundedI)"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 2. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "show \"y \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "using 1 assms order.trans"], ["proof (prove)\nusing this:\n  v \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n  y \\<le> v\n  construct_tree_inv v x y D R\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. y \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "by blast"], ["proof (state)\nthis:\n  y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "have \"D*(D\\<^sup>T\\<^sup>\\<star>*x) = D*x + D*D\\<^sup>T\\<^sup>+*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) = D * x + D * D\\<^sup>T\\<^sup>+ * x", "by (metis conway.dagger_unfoldl_distr distrib_left mult_assoc)"], ["proof (state)\nthis:\n  D * (D\\<^sup>T\\<^sup>\\<star> * x) = D * x + D * D\\<^sup>T\\<^sup>+ * x\n\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "also"], ["proof (state)\nthis:\n  D * (D\\<^sup>T\\<^sup>\\<star> * x) = D * x + D * D\\<^sup>T\\<^sup>+ * x\n\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "have \"... = D*D\\<^sup>T\\<^sup>+*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D * x + D * D\\<^sup>T\\<^sup>+ * x = D * D\\<^sup>T\\<^sup>+ * x", "using assms"], ["proof (prove)\nusing this:\n  y \\<le> v\n  construct_tree_inv v x y D R\n\ngoal (1 subgoal):\n 1. D * x + D * D\\<^sup>T\\<^sup>+ * x = D * D\\<^sup>T\\<^sup>+ * x", "by simp"], ["proof (state)\nthis:\n  D * x + D * D\\<^sup>T\\<^sup>+ * x = D * D\\<^sup>T\\<^sup>+ * x\n\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "also"], ["proof (state)\nthis:\n  D * x + D * D\\<^sup>T\\<^sup>+ * x = D * D\\<^sup>T\\<^sup>+ * x\n\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "have \"... \\<le> 1'*D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D * D\\<^sup>T\\<^sup>+ * x \\<le> 1' * D\\<^sup>T\\<^sup>\\<star> * x", "by (metis assms(2) is_inj_def mult_assoc mult_isor)"], ["proof (state)\nthis:\n  D * D\\<^sup>T\\<^sup>+ * x \\<le> 1' * D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "finally"], ["proof (chain)\npicking this:\n  D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> 1' * D\\<^sup>T\\<^sup>\\<star> * x", "show \"D*(D\\<^sup>T\\<^sup>\\<star>*x) \\<le> D\\<^sup>T\\<^sup>\\<star>*x\""], ["proof (prove)\nusing this:\n  D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> 1' * D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "by simp"], ["proof (state)\nthis:\n  D * (D\\<^sup>T\\<^sup>\\<star> * x) \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "thus \"construct_tree_post x y D R\""], ["proof (prove)\nusing this:\n  D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "using 2 assms"], ["proof (prove)\nusing this:\n  D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n  D\\<^sup>T * 1 \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n  y \\<le> v\n  construct_tree_inv v x y D R\n\ngoal (1 subgoal):\n 1. construct_tree_post x y D R", "by simp"], ["proof (state)\nthis:\n  construct_tree_post x y D R\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem construct_tree_partial: \"VARS e v D\n  { construct_tree_pre x y R }\n  D := 0;\n  v := x;\n  WHILE \\<not> y \\<le> v\n    INV { construct_tree_inv v x y D R }\n     DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n        D := D + e;\n        v := v + e\\<^sup>T*1\n     OD\n  { construct_tree_post x y D R }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {construct_tree_pre x y R} \n     D := 0;\n     v := x;\n     WHILE \\<not> y \\<le> v INV {construct_tree_inv v x y D R} \n      VAR {\\<lambda>(e, v, D). zero_class.zero} \n      DO e := choose_singleton (v * - v\\<^sup>T \\<cdot> R);\n         D := D + e; v := v + e\\<^sup>T * 1 \n      OD \n     {construct_tree_post x y D R}", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e v D.\n       construct_tree_pre x y R \\<Longrightarrow>\n       construct_tree_inv x x y 0 R\n 2. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 3. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "using construct_tree_pre"], ["proof (prove)\nusing this:\n  construct_tree_pre ?x ?y ?R \\<Longrightarrow>\n  construct_tree_inv ?x ?x ?y 0 ?R\n\ngoal (3 subgoals):\n 1. \\<And>e v D.\n       construct_tree_pre x y R \\<Longrightarrow>\n       construct_tree_inv x x y 0 R\n 2. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 3. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 2. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "using construct_tree_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> construct_tree_inv\n                     (?v +\n                      choose_singleton\n                       (?v * - ?v\\<^sup>T \\<cdot> ?R)\\<^sup>T *\n                      1)\n                     ?x ?y\n                     (?D + choose_singleton (?v * - ?v\\<^sup>T \\<cdot> ?R))\n                     ?R\n\ngoal (2 subgoals):\n 1. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 2. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "using construct_tree_post"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> construct_tree_post ?x ?y ?D ?R\n\ngoal (1 subgoal):\n 1. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "by blast"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point *)"], ["", "context relation_algebra_rtc_tarski_choose_point_finite\nbegin"], ["", "lemma construct_tree_inv_termination:\n assumes \" \\<not> y \\<le> v\"\n     and \"construct_tree_inv v x y D R\"\n   shows \"card { z . z \\<le> -(v + choose_singleton (v*-v\\<^sup>T \\<cdot> R)\\<^sup>T*1) } < card { z . z \\<le> -v }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {z. z \\<le> - (v +\n                    choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                    1)}\n    < card {z. z \\<le> - v}", "proof (rule decrease_variant)"], ["proof (state)\ngoal (3 subgoals):\n 1. - (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n    \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "let ?e = \"choose_singleton (v*-v\\<^sup>T \\<cdot> R)\""], ["proof (state)\ngoal (3 subgoals):\n 1. - (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n    \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "let ?v = \"v + ?e\\<^sup>T*1\""], ["proof (state)\ngoal (3 subgoals):\n 1. - (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n    \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "have 1: \"?e \\<le> v*-v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T", "using choose_singleton_decreasing inf.boundedE"], ["proof (prove)\nusing this:\n  choose_singleton ?x \\<le> ?x\n  \\<lbrakk>?a \\<le> ?b \\<cdot> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T", "by blast"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n\ngoal (3 subgoals):\n 1. - (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n    \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "have 2: \"singleton ?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton (choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "using construct_tree_inv_aux assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> singleton\n                     (choose_singleton (?v * - ?v\\<^sup>T \\<cdot> ?R))\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n\ngoal (1 subgoal):\n 1. singleton (choose_singleton (v * - v\\<^sup>T \\<cdot> R))", "by auto"], ["proof (state)\nthis:\n  singleton (choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n\ngoal (3 subgoals):\n 1. - (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n    \\<le> - v\n 2. ?w \\<le> - v\n 3. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "show \"-?v \\<le> -v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n    \\<le> - v", "by simp"], ["proof (state)\nthis:\n  - (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) \\<le> - v\n\ngoal (2 subgoals):\n 1. ?w \\<le> - v\n 2. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "have \"?e\\<^sup>T \\<le> -v*v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T\n    \\<le> - v * v\\<^sup>T", "using 1 conv_compl conv_iso"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R) \\<le> v * - v\\<^sup>T\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T\n    \\<le> - v * v\\<^sup>T", "by force"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T \\<le> - v * v\\<^sup>T\n\ngoal (2 subgoals):\n 1. ?w \\<le> - v\n 2. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "also"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T \\<le> - v * v\\<^sup>T\n\ngoal (2 subgoals):\n 1. ?w \\<le> - v\n 2. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "have \"... \\<le> -v*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - v * v\\<^sup>T \\<le> - v * 1", "by (simp add: mult_isol)"], ["proof (state)\nthis:\n  - v * v\\<^sup>T \\<le> - v * 1\n\ngoal (2 subgoals):\n 1. ?w \\<le> - v\n 2. \\<not> ?w \\<le> - (v +\n                       choose_singleton\n                        (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                       1)", "finally"], ["proof (chain)\npicking this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T \\<le> - v * 1", "show \"?e\\<^sup>T*1 \\<le> -v\""], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T \\<le> - v * 1\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 \\<le> - v", "using assms"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T \\<le> - v * 1\n  \\<not> y \\<le> v\n  construct_tree_inv v x y D R\n\ngoal (1 subgoal):\n 1. choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 \\<le> - v", "by (metis is_vector_def mult_isor one_compl)"], ["proof (state)\nthis:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 \\<le> - v\n\ngoal (1 subgoal):\n 1. \\<not> choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1\n           \\<le> - (v +\n                    choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                    1)", "thus \"\\<not> (?e\\<^sup>T*1 \\<le> -?v)\""], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 \\<le> - v\n\ngoal (1 subgoal):\n 1. \\<not> choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1\n           \\<le> - (v +\n                    choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                    1)", "using 2"], ["proof (prove)\nusing this:\n  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1 \\<le> - v\n  singleton (choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n\ngoal (1 subgoal):\n 1. \\<not> choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1\n           \\<le> - (v +\n                    choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T *\n                    1)", "by (metis annir compl_sup inf.absorb1 inf_compl_bot_right surj_one tarski)"], ["proof (state)\nthis:\n  \\<not> choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1\n         \\<le> - (v +\n                  choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem construct_tree_total: \"VARS e v D\n [ construct_tree_pre x y R ]\n D := 0;\n v := x;\n WHILE \\<not> y \\<le> v\n   INV { construct_tree_inv v x y D R }\n   VAR { card { z . z \\<le> -v } }\n    DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n       D := D + e;\n       v := v + e\\<^sup>T*1\n    OD\n [ construct_tree_post x y D R ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [construct_tree_pre x y R] \n     D := 0;\n     v := x;\n     WHILE \\<not> y \\<le> v INV {construct_tree_inv v x y D R} \n      VAR {\\<lambda>(e, v, D). card {z. z \\<le> - v}} \n      DO e := choose_singleton (v * - v\\<^sup>T \\<cdot> R);\n         D := D + e; v := v + e\\<^sup>T * 1 \n      OD \n     [construct_tree_post x y D R]", "apply vcg_tc"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e v D.\n       construct_tree_pre x y R \\<Longrightarrow>\n       construct_tree_inv x x y 0 R\n 2. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n        v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n        D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n       \\<in> {s. (case s of\n                  (e, v, D) \\<Rightarrow>\n                    construct_tree_inv v x y D R) \\<and>\n                 (case s of (e, v, D) \\<Rightarrow> card {z. z \\<le> - v})\n                 < n}\n 3. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "using construct_tree_pre"], ["proof (prove)\nusing this:\n  construct_tree_pre ?x ?y ?R \\<Longrightarrow>\n  construct_tree_inv ?x ?x ?y 0 ?R\n\ngoal (3 subgoals):\n 1. \\<And>e v D.\n       construct_tree_pre x y R \\<Longrightarrow>\n       construct_tree_inv x x y 0 R\n 2. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n        v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n        D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n       \\<in> {s. (case s of\n                  (e, v, D) \\<Rightarrow>\n                    construct_tree_inv v x y D R) \\<and>\n                 (case s of (e, v, D) \\<Rightarrow> card {z. z \\<le> - v})\n                 < n}\n 3. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n        v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n        D + choose_singleton (v * - v\\<^sup>T \\<cdot> R))\n       \\<in> {s. (case s of\n                  (e, v, D) \\<Rightarrow>\n                    construct_tree_inv v x y D R) \\<and>\n                 (case s of (e, v, D) \\<Rightarrow> card {z. z \\<le> - v})\n                 < n}\n 2. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "apply (rule CollectI, rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       case (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n             v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n             D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) of\n       (e, v, D) \\<Rightarrow> construct_tree_inv v x y D R\n 2. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) of\n        (e, v, D) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 3. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "using construct_tree_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> construct_tree_inv\n                     (?v +\n                      choose_singleton\n                       (?v * - ?v\\<^sup>T \\<cdot> ?R)\\<^sup>T *\n                      1)\n                     ?x ?y\n                     (?D + choose_singleton (?v * - ?v\\<^sup>T \\<cdot> ?R))\n                     ?R\n\ngoal (3 subgoals):\n 1. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       case (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n             v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n             D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) of\n       (e, v, D) \\<Rightarrow> construct_tree_inv v x y D R\n 2. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) of\n        (e, v, D) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 3. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) of\n        (e, v, D) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 2. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "using construct_tree_inv_termination"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> card\n                     {z. z \\<le> - (?v +\n                                    choose_singleton\n                                     (?v * - ?v\\<^sup>T \\<cdot>\n?R)\\<^sup>T *\n                                    1)}\n                    < card {z. z \\<le> - ?v}\n\ngoal (2 subgoals):\n 1. \\<And>n e v D.\n       (construct_tree_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) of\n        (e, v, D) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 2. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "using construct_tree_post"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> construct_tree_post ?x ?y ?D ?R\n\ngoal (1 subgoal):\n 1. \\<And>e v D.\n       construct_tree_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       construct_tree_post x y D R", "by blast"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point_finite *)"], ["", "subsection \\<open>Construction of a non-empty cycle\\<close>"], ["", "text \\<open>\nThe second step is to construct a path from the root to a given vertex in the tree.\nAdding an edge back to the root gives the cycle.\n\\<close>"], ["", "context relation_algebra_rtc_tarski_choose_point\nbegin"], ["", "abbreviation comment\n  where \"comment _ \\<equiv> SKIP\""], ["", "(* instead of inner comments *)"], ["", "abbreviation construct_cycle_inv\n  where \"construct_cycle_inv v x y D R \\<equiv> construct_tree_inv v x y D R \\<and> point y \\<and> y*x\\<^sup>T \\<le> R\""], ["", "lemma construct_cycle_pre:\n assumes \" \\<not> is_acyclic R\"\n     and \"y = choose_point ((R\\<^sup>+ \\<cdot> 1')*1)\"\n     and \"x = choose_point (R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y)\"\n   shows \"construct_cycle_inv x x y 0 R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_cycle_inv x x y 0 R", "proof(rule conjI, rule_tac [2] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. construct_tree_inv x x y 0 R\n 2. point y\n 3. y * x\\<^sup>T \\<le> R", "show point_y: \"point y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point y", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_acyclic R\n  y = choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)\n  x = choose_point (R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y)\n\ngoal (1 subgoal):\n 1. point y", "by (simp add: choose_point_point is_vector_def mult_assoc galois_aux ss_p18)"], ["proof (state)\nthis:\n  point y\n\ngoal (2 subgoals):\n 1. construct_tree_inv x x y 0 R\n 2. y * x\\<^sup>T \\<le> R", "have \"R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "have \"R\\<^sup>+ \\<cdot> 1' = (R\\<^sup>+)\\<^sup>T \\<cdot> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>+ \\<cdot> 1' = (R\\<^sup>+)\\<^sup>T \\<cdot> 1'", "by (metis (mono_tags, hide_lams) conv_e conv_times inf.cobounded1 inf.commute\n                many_strongly_connected_iff_6_eq mult_oner star_subid)"], ["proof (state)\nthis:\n  R\\<^sup>+ \\<cdot> 1' = (R\\<^sup>+)\\<^sup>T \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  R\\<^sup>+ \\<cdot> 1' = (R\\<^sup>+)\\<^sup>T \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "have \"... = R\\<^sup>T\\<^sup>+ \\<cdot> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R\\<^sup>+)\\<^sup>T \\<cdot> 1' = R\\<^sup>T\\<^sup>+ \\<cdot> 1'", "using plus_conv"], ["proof (prove)\nusing this:\n  (?x\\<^sup>+)\\<^sup>T = ?x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. (R\\<^sup>+)\\<^sup>T \\<cdot> 1' = R\\<^sup>T\\<^sup>+ \\<cdot> 1'", "by fastforce"], ["proof (state)\nthis:\n  (R\\<^sup>+)\\<^sup>T \\<cdot> 1' = R\\<^sup>T\\<^sup>+ \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (R\\<^sup>+)\\<^sup>T \\<cdot> 1' = R\\<^sup>T\\<^sup>+ \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "have \"... \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R)*R\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>T\\<^sup>+ \\<cdot> 1'\n    \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * R\\<^sup>T", "by (metis conv_contrav conv_e conv_invol modular_2_var mult_oner star_slide_var)"], ["proof (state)\nthis:\n  R\\<^sup>T\\<^sup>+ \\<cdot> 1'\n  \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * R\\<^sup>T\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  R\\<^sup>T\\<^sup>+ \\<cdot> 1'\n  \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * R\\<^sup>T\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "have \"... \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R)*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * R\\<^sup>T\n    \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1", "by (simp add: mult_isol)"], ["proof (state)\nthis:\n  (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * R\\<^sup>T\n  \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  R\\<^sup>+ \\<cdot> 1' \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1", "have a: \"(R\\<^sup>+ \\<cdot> 1')*1 \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R)*1\""], ["proof (prove)\nusing this:\n  R\\<^sup>+ \\<cdot> 1' \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1\n\ngoal (1 subgoal):\n 1. (R\\<^sup>+ \\<cdot> 1') * 1 \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1", "by (metis mult_assoc mult_isor one_idem_mult)"], ["proof (state)\nthis:\n  (R\\<^sup>+ \\<cdot> 1') * 1 \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "assume \"R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y = 0\""], ["proof (state)\nthis:\n  R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "hence \"(R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)*y = 0\""], ["proof (prove)\nusing this:\n  R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0\n\ngoal (1 subgoal):\n 1. (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y = 0", "using point_y inj_distr point_def"], ["proof (prove)\nusing this:\n  R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0\n  point y\n  is_inj ?z \\<Longrightarrow> (?x \\<cdot> ?y) * ?z = ?x * ?z \\<cdot> ?y * ?z\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n\ngoal (1 subgoal):\n 1. (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y = 0", "by blast"], ["proof (state)\nthis:\n  (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y = 0\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "hence \"(R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T*1 \\<le> -y\""], ["proof (prove)\nusing this:\n  (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y = 0\n\ngoal (1 subgoal):\n 1. (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1 \\<le> - y", "by (simp add: conv_galois_1)"], ["proof (state)\nthis:\n  (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1 \\<le> - y\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "hence \"y \\<le> -((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T*1)\""], ["proof (prove)\nusing this:\n  (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1 \\<le> - y\n\ngoal (1 subgoal):\n 1. y \\<le> - ((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1)", "using compl_le_swap1"], ["proof (prove)\nusing this:\n  (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1 \\<le> - y\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n\ngoal (1 subgoal):\n 1. y \\<le> - ((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1)", "by blast"], ["proof (state)\nthis:\n  y \\<le> - ((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  y \\<le> - ((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1)\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "have \"... = -((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R)*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1) =\n    - ((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1)", "by (simp add: star_conv)"], ["proof (state)\nthis:\n  - ((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1) =\n  - ((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1)\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  - ((R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)\\<^sup>T * 1) =\n  - ((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1)\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "have \"... \\<le> -((R\\<^sup>+ \\<cdot> 1')*1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1)\n    \\<le> - ((R\\<^sup>+ \\<cdot> 1') * 1)", "using a comp_anti"], ["proof (prove)\nusing this:\n  (R\\<^sup>+ \\<cdot> 1') * 1 \\<le> (R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1\n  (?x \\<le> ?y) = (- ?y \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. - ((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1)\n    \\<le> - ((R\\<^sup>+ \\<cdot> 1') * 1)", "by blast"], ["proof (state)\nthis:\n  - ((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1)\n  \\<le> - ((R\\<^sup>+ \\<cdot> 1') * 1)\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  - ((R\\<^sup>T\\<^sup>\\<star> \\<cdot> R) * 1)\n  \\<le> - ((R\\<^sup>+ \\<cdot> 1') * 1)\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "have \"... \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((R\\<^sup>+ \\<cdot> 1') * 1) \\<le> - y", "by (simp add: assms galois_aux ss_p18 choose_point_decreasing)"], ["proof (state)\nthis:\n  - ((R\\<^sup>+ \\<cdot> 1') * 1) \\<le> - y\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  y \\<le> - y", "have \"y = 0\""], ["proof (prove)\nusing this:\n  y \\<le> - y\n\ngoal (1 subgoal):\n 1. y = 0", "using inf.absorb2"], ["proof (prove)\nusing this:\n  y \\<le> - y\n  ?b \\<le> ?a \\<Longrightarrow> ?a \\<cdot> ?b = ?b\n\ngoal (1 subgoal):\n 1. y = 0", "by fastforce"], ["proof (state)\nthis:\n  y = 0\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  y = 0\n\ngoal (1 subgoal):\n 1. False", "using point_y annir point_equations(2) point_is_point tarski"], ["proof (prove)\nusing this:\n  y = 0\n  point y\n  ?x * 0 = 0\n  is_point ?p \\<Longrightarrow> 1 * ?p = 1\n  point ?x = is_point ?x\n  (?x \\<noteq> 0) = (1 * ?x * 1 = 1)\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y \\<noteq> 0\n\ngoal (2 subgoals):\n 1. construct_tree_inv x x y 0 R\n 2. y * x\\<^sup>T \\<le> R", "hence point_x: \"point x\""], ["proof (prove)\nusing this:\n  R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. point x", "by (metis point_y assms(3) inj_distr is_vector_def mult_assoc point_def choose_point_point)"], ["proof (state)\nthis:\n  point x\n\ngoal (2 subgoals):\n 1. construct_tree_inv x x y 0 R\n 2. y * x\\<^sup>T \\<le> R", "hence \"y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\""], ["proof (prove)\nusing this:\n  point x\n\ngoal (1 subgoal):\n 1. y \\<le> R\\<^sup>T\\<^sup>\\<star> * x", "by (metis assms(3) point_y choose_point_decreasing inf_le1 order.trans point_swap star_conv)"], ["proof (state)\nthis:\n  y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (2 subgoals):\n 1. construct_tree_inv x x y 0 R\n 2. y * x\\<^sup>T \\<le> R", "thus tree_inv: \"construct_tree_inv x x y 0 R\""], ["proof (prove)\nusing this:\n  y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. construct_tree_inv x x y 0 R", "using point_x construct_tree_pre"], ["proof (prove)\nusing this:\n  y \\<le> R\\<^sup>T\\<^sup>\\<star> * x\n  point x\n  construct_tree_pre ?x ?y ?R \\<Longrightarrow>\n  construct_tree_inv ?x ?x ?y 0 ?R\n\ngoal (1 subgoal):\n 1. construct_tree_inv x x y 0 R", "by blast"], ["proof (state)\nthis:\n  construct_tree_inv x x y 0 R\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "show \"y * x\\<^sup>T \\<le> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "have \"x \\<le> R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y", "using assms(3) choose_point_decreasing"], ["proof (prove)\nusing this:\n  x = choose_point (R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y)\n  choose_point ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. x \\<le> R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y", "by blast"], ["proof (state)\nthis:\n  x \\<le> R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "also"], ["proof (state)\nthis:\n  x \\<le> R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "have \"... = (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T)*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y =\n    (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y", "using point_y inj_distr point_def"], ["proof (prove)\nusing this:\n  point y\n  is_inj ?z \\<Longrightarrow> (?x \\<cdot> ?y) * ?z = ?x * ?z \\<cdot> ?y * ?z\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y =\n    (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y", "by fastforce"], ["proof (state)\nthis:\n  R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y =\n  (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "finally"], ["proof (chain)\npicking this:\n  x \\<le> (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y", "have \"x*y\\<^sup>T \\<le> R\\<^sup>\\<star> \\<cdot> R\\<^sup>T\""], ["proof (prove)\nusing this:\n  x \\<le> (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y\n\ngoal (1 subgoal):\n 1. x * y\\<^sup>T \\<le> R\\<^sup>\\<star> \\<cdot> R\\<^sup>T", "using point_y point_def ss423bij"], ["proof (prove)\nusing this:\n  x \\<le> (R\\<^sup>\\<star> \\<cdot> R\\<^sup>T) * y\n  point y\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  bijective ?x \\<Longrightarrow>\n  (?y * ?x\\<^sup>T \\<le> ?z) = (?y \\<le> ?z * ?x)\n\ngoal (1 subgoal):\n 1. x * y\\<^sup>T \\<le> R\\<^sup>\\<star> \\<cdot> R\\<^sup>T", "by blast"], ["proof (state)\nthis:\n  x * y\\<^sup>T \\<le> R\\<^sup>\\<star> \\<cdot> R\\<^sup>T\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "also"], ["proof (state)\nthis:\n  x * y\\<^sup>T \\<le> R\\<^sup>\\<star> \\<cdot> R\\<^sup>T\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "have \"... \\<le> R\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>\\<star> \\<cdot> R\\<^sup>T \\<le> R\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  R\\<^sup>\\<star> \\<cdot> R\\<^sup>T \\<le> R\\<^sup>T\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "finally"], ["proof (chain)\npicking this:\n  x * y\\<^sup>T \\<le> R\\<^sup>T", "show ?thesis"], ["proof (prove)\nusing this:\n  x * y\\<^sup>T \\<le> R\\<^sup>T\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "using conv_iso"], ["proof (prove)\nusing this:\n  x * y\\<^sup>T \\<le> R\\<^sup>T\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>T \\<le> R", "by force"], ["proof (state)\nthis:\n  y * x\\<^sup>T \\<le> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y * x\\<^sup>T \\<le> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_cycle_pre2:\n assumes \"y \\<le> v\"\n     and \"construct_cycle_inv v x y D R\"\n   shows \"construct_path_inv y x y D 0 \\<and> D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_acyclic D \\<and>\n     point x \\<and>\n     point y \\<and>\n     point y \\<and>\n     D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n     0 \\<le> D \\<and>\n     terminating_path 0 \\<and>\n     (0 = 0) = (y = y) \\<and>\n     (0 \\<noteq> 0) = (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n    D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R", "proof(intro conjI, simp_all add: assms)"], ["proof (state)\ngoal (3 subgoals):\n 1. D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n 2. path 0\n 3. y \\<noteq> 0", "show \"D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "using assms construct_tree_post"], ["proof (prove)\nusing this:\n  y \\<le> v\n  construct_cycle_inv v x y D R\n  \\<lbrakk>?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> construct_tree_post ?x ?y ?D ?R\n\ngoal (1 subgoal):\n 1. D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x", "by blast"], ["proof (state)\nthis:\n  D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x\n\ngoal (2 subgoals):\n 1. path 0\n 2. y \\<noteq> 0", "show \"path 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path 0", "by (simp add: is_inj_def is_p_fun_def path_def)"], ["proof (state)\nthis:\n  path 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "show \"y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "using assms(2) is_point_def point_is_point"], ["proof (prove)\nusing this:\n  construct_cycle_inv v x y D R\n  is_point ?x \\<equiv> is_vector ?x \\<and> is_inj ?x \\<and> ?x \\<noteq> 0\n  point ?x = is_point ?x\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_cycle_post:\n  assumes \"\\<not> q \\<noteq> x\"\n      and \"(construct_path_inv q x y D W \\<and> D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R)\"\n    shows \"W + y * x\\<^sup>T \\<noteq> 0 \\<and> W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n    W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "proof(intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. W + y * x\\<^sup>T \\<noteq> 0\n 2. W + y * x\\<^sup>T \\<le> R\n 3. path (W + y * x\\<^sup>T)\n 4. many_strongly_connected (W + y * x\\<^sup>T)", "let ?C = \"W + y*x\\<^sup>T\""], ["proof (state)\ngoal (4 subgoals):\n 1. W + y * x\\<^sup>T \\<noteq> 0\n 2. W + y * x\\<^sup>T \\<le> R\n 3. path (W + y * x\\<^sup>T)\n 4. many_strongly_connected (W + y * x\\<^sup>T)", "show \"?C \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W + y * x\\<^sup>T \\<noteq> 0", "by (metis assms acyclic_imp_one_step_different_points(2) no_trivial_inverse point_def ss423bij\n              sup_bot.monoid_axioms monoid.left_neutral)"], ["proof (state)\nthis:\n  W + y * x\\<^sup>T \\<noteq> 0\n\ngoal (3 subgoals):\n 1. W + y * x\\<^sup>T \\<le> R\n 2. path (W + y * x\\<^sup>T)\n 3. many_strongly_connected (W + y * x\\<^sup>T)", "show \"?C \\<le> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W + y * x\\<^sup>T \\<le> R", "using assms(2) order_trans sup.boundedI"], ["proof (prove)\nusing this:\n  (is_acyclic D \\<and>\n   point x \\<and>\n   point y \\<and>\n   point q \\<and>\n   D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n   W \\<le> D \\<and>\n   terminating_path W \\<and>\n   (W = 0) = (q = y) \\<and>\n   (W \\<noteq> 0) = (q = start_points W \\<and> y = end_points W)) \\<and>\n  D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?b + ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. W + y * x\\<^sup>T \\<le> R", "by blast"], ["proof (state)\nthis:\n  W + y * x\\<^sup>T \\<le> R\n\ngoal (2 subgoals):\n 1. path (W + y * x\\<^sup>T)\n 2. many_strongly_connected (W + y * x\\<^sup>T)", "show \"path (W + y * x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (W + y * x\\<^sup>T)", "by (metis assms construct_tree_pre edge_is_path less_eq_def path_edge_equals_cycle\n              point_is_point terminating_iff1)"], ["proof (state)\nthis:\n  path (W + y * x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. many_strongly_connected (W + y * x\\<^sup>T)", "show \"many_strongly_connected (W + y * x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. many_strongly_connected (W + y * x\\<^sup>T)", "by (metis assms construct_tree_pre bot_least conv_zero less_eq_def\n              path_edge_equals_cycle star_conv star_subid terminating_iff1)"], ["proof (state)\nthis:\n  many_strongly_connected (W + y * x\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem construct_cycle_partial: \"VARS e p q v x y C D W\n  { \\<not> is_acyclic R }\n  y := choose_point ((R\\<^sup>+ \\<cdot> 1')*1);\n  x := choose_point (R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y);\n  D := 0;\n  v := x;\n  WHILE \\<not> y \\<le> v\n    INV { construct_cycle_inv v x y D R }\n     DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n        D := D + e;\n        v := v + e\\<^sup>T*1\n     OD;\n  comment { is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x };\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W \\<and> D \\<le> R \\<and> D*x = 0 \\<and> y*x\\<^sup>T \\<le> R }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD;\n  comment { W \\<le> D \\<and> terminating_path W \\<and> (W = 0 \\<longleftrightarrow> q=y) \\<and> (W \\<noteq> 0 \\<longleftrightarrow> q = start_points W \\<and> y = end_points W) };\n  C := W + y*x\\<^sup>T\n  { C \\<noteq> 0 \\<and> C \\<le> R \\<and> cycle C }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<not> is_acyclic R} \n     y := choose_point ((R\\<^sup>+ \\<cdot> 1') * 1);\n     x := choose_point (R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y);\n     D := 0;\n     v := x;\n     WHILE \\<not> y \\<le> v INV {construct_cycle_inv v x y D R} \n      VAR {\\<lambda>(e, p, q, v, x, y, C, D, W). zero_class.zero} \n      DO e := choose_singleton (v * - v\\<^sup>T \\<cdot> R);\n         D := D + e; v := v + e\\<^sup>T * 1 \n      OD;\n     comment ?uu;\n     W := 0;\n     q := y;\n     WHILE q \\<noteq> x\n      INV {(is_acyclic D \\<and>\n            point x \\<and>\n            point y \\<and>\n            point q \\<and>\n            D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n            W \\<le> D \\<and>\n            terminating_path W \\<and>\n            (W = 0) = (q = y) \\<and>\n            (W \\<noteq> 0) =\n            (q = start_points W \\<and> y = end_points W)) \\<and>\n           D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R} \n      VAR {\\<lambda>(e, p, q, v, x, y, C, D, W). zero_class.zero} \n      DO p := choose_point (D * q); W := W + p * q\\<^sup>T; q := p OD;\n     comment ?uu; C := W + y * x\\<^sup>T \n     {C \\<noteq> 0 \\<and> C \\<le> R \\<and> cycle C}", "apply vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>e p q v x y C D W.\n       \\<not> is_acyclic R \\<Longrightarrow>\n       construct_cycle_inv\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)) 0 R\n 2. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_cycle_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 3. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 5. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_cycle_pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_acyclic ?R;\n   ?y = choose_point ((?R\\<^sup>+ \\<cdot> 1') * 1);\n   ?x =\n   choose_point (?R\\<^sup>\\<star> * ?y \\<cdot> ?R\\<^sup>T * ?y)\\<rbrakk>\n  \\<Longrightarrow> construct_cycle_inv ?x ?x ?y 0 ?R\n\ngoal (5 subgoals):\n 1. \\<And>e p q v x y C D W.\n       \\<not> is_acyclic R \\<Longrightarrow>\n       construct_cycle_inv\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)) 0 R\n 2. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_cycle_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 3. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 5. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_cycle_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 2. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_tree_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> construct_tree_inv\n                     (?v +\n                      choose_singleton\n                       (?v * - ?v\\<^sup>T \\<cdot> ?R)\\<^sup>T *\n                      1)\n                     ?x ?y\n                     (?D + choose_singleton (?v * - ?v\\<^sup>T \\<cdot> ?R))\n                     ?R\n\ngoal (4 subgoals):\n 1. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> y \\<le> v \\<Longrightarrow>\n       construct_cycle_inv\n        (v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1) x y\n        (D + choose_singleton (v * - v\\<^sup>T \\<cdot> R)) R\n 2. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_cycle_pre2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?v; construct_cycle_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> (is_acyclic ?D \\<and>\n                     point ?x \\<and>\n                     point ?y \\<and>\n                     point ?y \\<and>\n                     ?D\\<^sup>\\<star> * ?y\n                     \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n                     0 \\<le> ?D \\<and>\n                     terminating_path 0 \\<and>\n                     (0 = 0) = (?y = ?y) \\<and>\n                     (0 \\<noteq> 0) =\n                     (?y = start_points 0 \\<and> ?y = end_points 0)) \\<and>\n                    ?D \\<le> ?R \\<and>\n                    ?D * ?x = 0 \\<and> ?y * ?x\\<^sup>T \\<le> ?R\n\ngoal (3 subgoals):\n 1. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_path_inv"], ["proof (prove)\nusing this:\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  is_acyclic ?D \\<and>\n  point ?x \\<and>\n  point ?y \\<and>\n  point (choose_point (?D * ?q)) \\<and>\n  ?D\\<^sup>\\<star> * choose_point (?D * ?q)\n  \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n  ?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<le> ?D \\<and>\n  terminating_path (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T = 0) =\n  (choose_point (?D * ?q) = ?y) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<noteq> 0) =\n  (choose_point (?D * ?q) =\n   start_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n   ?y = end_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T))\n\ngoal (2 subgoals):\n 1. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       q \\<noteq> x \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point (choose_point (D * q)) \\<and>\n        D\\<^sup>\\<star> * choose_point (D * q)\n        \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        W + choose_point (D * q) * q\\<^sup>T \\<le> D \\<and>\n        terminating_path (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T = 0) =\n        (choose_point (D * q) = y) \\<and>\n        (W + choose_point (D * q) * q\\<^sup>T \\<noteq> 0) =\n        (choose_point (D * q) =\n         start_points (W + choose_point (D * q) * q\\<^sup>T) \\<and>\n         y = end_points (W + choose_point (D * q) * q\\<^sup>T))) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_cycle_post"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?q \\<noteq> ?x;\n   (is_acyclic ?D \\<and>\n    point ?x \\<and>\n    point ?y \\<and>\n    point ?q \\<and>\n    ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n    ?W \\<le> ?D \\<and>\n    terminating_path ?W \\<and>\n    (?W = 0) = (?q = ?y) \\<and>\n    (?W \\<noteq> 0) =\n    (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n   ?D \\<le> ?R \\<and> ?D * ?x = 0 \\<and> ?y * ?x\\<^sup>T \\<le> ?R\\<rbrakk>\n  \\<Longrightarrow> ?W + ?y * ?x\\<^sup>T \\<noteq> 0 \\<and>\n                    ?W + ?y * ?x\\<^sup>T \\<le> ?R \\<and>\n                    cycle (?W + ?y * ?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "by blast"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point *)"], ["", "context relation_algebra_rtc_tarski_choose_point_finite\nbegin"], ["", "theorem construct_cycle_total: \"VARS e p q v x y C D W\n  [ \\<not> is_acyclic R ]\n  y := choose_point ((R\\<^sup>+ \\<cdot> 1')*1);\n  x := choose_point (R\\<^sup>\\<star>*y \\<cdot> R\\<^sup>T*y);\n  D := 0;\n  v := x;\n  WHILE \\<not> y \\<le> v\n    INV { construct_cycle_inv v x y D R }\n    VAR { card { z . z \\<le> -v } }\n     DO e := choose_singleton (v*-v\\<^sup>T \\<cdot> R);\n        D := D + e;\n        v := v + e\\<^sup>T*1\n     OD;\n  comment { is_acyclic D \\<and> point y \\<and> point x \\<and> D\\<^sup>\\<star>*y \\<le> D\\<^sup>T\\<^sup>\\<star>*x };\n  W := 0;\n  q := y;\n  WHILE q \\<noteq> x\n    INV { construct_path_inv q x y D W \\<and> D \\<le> R \\<and> D*x = 0 \\<and> y*x\\<^sup>T \\<le> R }\n    VAR { card { z . z \\<le> -W } }\n     DO p := choose_point (D*q);\n        W := W + p*q\\<^sup>T;\n        q := p\n     OD;\n  comment { W \\<le> D \\<and> terminating_path W \\<and> (W = 0 \\<longleftrightarrow> q=y) \\<and> (W \\<noteq> 0 \\<longleftrightarrow> q = start_points W \\<and> y = end_points W)};\n  C := W + y*x\\<^sup>T\n [ C \\<noteq> 0 \\<and> C \\<le> R \\<and> cycle C ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<not> is_acyclic R] \n     y := choose_point ((R\\<^sup>+ \\<cdot> 1') * 1);\n     x := choose_point (R\\<^sup>\\<star> * y \\<cdot> R\\<^sup>T * y);\n     D := 0;\n     v := x;\n     WHILE \\<not> y \\<le> v INV {construct_cycle_inv v x y D R} \n      VAR {\\<lambda>(e, p, q, v, x, y, C, D, W). card {z. z \\<le> - v}} \n      DO e := choose_singleton (v * - v\\<^sup>T \\<cdot> R);\n         D := D + e; v := v + e\\<^sup>T * 1 \n      OD;\n     comment ?uu;\n     W := 0;\n     q := y;\n     WHILE q \\<noteq> x\n      INV {(is_acyclic D \\<and>\n            point x \\<and>\n            point y \\<and>\n            point q \\<and>\n            D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n            W \\<le> D \\<and>\n            terminating_path W \\<and>\n            (W = 0) = (q = y) \\<and>\n            (W \\<noteq> 0) =\n            (q = start_points W \\<and> y = end_points W)) \\<and>\n           D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R} \n      VAR {\\<lambda>(e, p, q, v, x, y, C, D, W). card {z. z \\<le> - W}} \n      DO p := choose_point (D * q); W := W + p * q\\<^sup>T; q := p OD;\n     comment ?uu; C := W + y * x\\<^sup>T \n     [C \\<noteq> 0 \\<and> C \\<le> R \\<and> cycle C]", "apply vcg_tc"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>e p q v x y C D W.\n       \\<not> is_acyclic R \\<Longrightarrow>\n       construct_cycle_inv\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)) 0 R\n 2. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n        v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1, x, y,\n        C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R), W)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    construct_cycle_inv v x y D R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - v})\n                 < n}\n 3. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 5. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_cycle_pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_acyclic ?R;\n   ?y = choose_point ((?R\\<^sup>+ \\<cdot> 1') * 1);\n   ?x =\n   choose_point (?R\\<^sup>\\<star> * ?y \\<cdot> ?R\\<^sup>T * ?y)\\<rbrakk>\n  \\<Longrightarrow> construct_cycle_inv ?x ?x ?y 0 ?R\n\ngoal (5 subgoals):\n 1. \\<And>e p q v x y C D W.\n       \\<not> is_acyclic R \\<Longrightarrow>\n       construct_cycle_inv\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point\n          (R\\<^sup>\\<star> *\n           choose_point ((R\\<^sup>+ \\<cdot> 1') * 1) \\<cdot>\n           R\\<^sup>T * choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)))\n        (choose_point ((R\\<^sup>+ \\<cdot> 1') * 1)) 0 R\n 2. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n        v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1, x, y,\n        C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R), W)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    construct_cycle_inv v x y D R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - v})\n                 < n}\n 3. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 5. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n        v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1, x, y,\n        C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R), W)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    construct_cycle_inv v x y D R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - v})\n                 < n}\n 2. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 3. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 4. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply (rule CollectI, rule conjI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       case (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n             v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n             x, y, C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n             W) of\n       (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n         construct_cycle_inv v x y D R\n 2. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              x, y, C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              W) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 3. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 5. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_tree_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> construct_tree_inv\n                     (?v +\n                      choose_singleton\n                       (?v * - ?v\\<^sup>T \\<cdot> ?R)\\<^sup>T *\n                      1)\n                     ?x ?y\n                     (?D + choose_singleton (?v * - ?v\\<^sup>T \\<cdot> ?R))\n                     ?R\n\ngoal (5 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       case (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n             v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n             x, y, C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n             W) of\n       (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n         construct_cycle_inv v x y D R\n 2. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              x, y, C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              W) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 3. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 4. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 5. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              x, y, C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              W) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 2. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 3. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 4. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_tree_inv_termination"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?y \\<le> ?v; construct_tree_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> card\n                     {z. z \\<le> - (?v +\n                                    choose_singleton\n                                     (?v * - ?v\\<^sup>T \\<cdot>\n?R)\\<^sup>T *\n                                    1)}\n                    < card {z. z \\<le> - ?v}\n\ngoal (4 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (construct_cycle_inv v x y D R \\<and> \\<not> y \\<le> v) \\<and>\n       card {z. z \\<le> - v} = n \\<Longrightarrow>\n       (case (choose_singleton (v * - v\\<^sup>T \\<cdot> R), p, q,\n              v + choose_singleton (v * - v\\<^sup>T \\<cdot> R)\\<^sup>T * 1,\n              x, y, C, D + choose_singleton (v * - v\\<^sup>T \\<cdot> R),\n              W) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - v})\n       < n\n 2. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 3. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 4. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_cycle_pre2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?v; construct_cycle_inv ?v ?x ?y ?D ?R\\<rbrakk>\n  \\<Longrightarrow> (is_acyclic ?D \\<and>\n                     point ?x \\<and>\n                     point ?y \\<and>\n                     point ?y \\<and>\n                     ?D\\<^sup>\\<star> * ?y\n                     \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n                     0 \\<le> ?D \\<and>\n                     terminating_path 0 \\<and>\n                     (0 = 0) = (?y = ?y) \\<and>\n                     (0 \\<noteq> 0) =\n                     (?y = start_points 0 \\<and> ?y = end_points 0)) \\<and>\n                    ?D \\<le> ?R \\<and>\n                    ?D * ?x = 0 \\<and> ?y * ?x\\<^sup>T \\<le> ?R\n\ngoal (3 subgoals):\n 1. \\<And>e p q v x y C D W.\n       construct_cycle_inv v x y D R \\<and>\n       \\<not> \\<not> y \\<le> v \\<Longrightarrow>\n       (is_acyclic D \\<and>\n        point x \\<and>\n        point y \\<and>\n        point y \\<and>\n        D\\<^sup>\\<star> * y \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n        0 \\<le> D \\<and>\n        terminating_path 0 \\<and>\n        (0 = 0) = (y = y) \\<and>\n        (0 \\<noteq> 0) =\n        (y = start_points 0 \\<and> y = end_points 0)) \\<and>\n       D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n        W + choose_point (D * q) * q\\<^sup>T)\n       \\<in> {s. (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    (is_acyclic D \\<and>\n                     point x \\<and>\n                     point y \\<and>\n                     point q \\<and>\n                     D\\<^sup>\\<star> * q\n                     \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n                     W \\<le> D \\<and>\n                     terminating_path W \\<and>\n                     (W = 0) = (q = y) \\<and>\n                     (W \\<noteq> 0) =\n                     (q = start_points W \\<and> y = end_points W)) \\<and>\n                    D \\<le> R \\<and>\n                    D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n                 (case s of\n                  (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n                    card {z. z \\<le> - W})\n                 < n}\n 2. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply (rule CollectI, rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       case (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n             W + choose_point (D * q) * q\\<^sup>T) of\n       (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n         (is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_path_inv"], ["proof (prove)\nusing this:\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  is_acyclic ?D \\<and>\n  point ?x \\<and>\n  point ?y \\<and>\n  point (choose_point (?D * ?q)) \\<and>\n  ?D\\<^sup>\\<star> * choose_point (?D * ?q)\n  \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n  ?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<le> ?D \\<and>\n  terminating_path (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T = 0) =\n  (choose_point (?D * ?q) = ?y) \\<and>\n  (?W + choose_point (?D * ?q) * ?q\\<^sup>T \\<noteq> 0) =\n  (choose_point (?D * ?q) =\n   start_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T) \\<and>\n   ?y = end_points (?W + choose_point (?D * ?q) * ?q\\<^sup>T))\n\ngoal (3 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       case (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n             W + choose_point (D * q) * q\\<^sup>T) of\n       (e, p, q, v, x, y, C, D, W) \\<Rightarrow>\n         (is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R\n 2. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 3. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 2. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_path_inv_termination"], ["proof (prove)\nusing this:\n  (is_acyclic ?D \\<and>\n   point ?x \\<and>\n   point ?y \\<and>\n   point ?q \\<and>\n   ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n   ?W \\<le> ?D \\<and>\n   terminating_path ?W \\<and>\n   (?W = 0) = (?q = ?y) \\<and>\n   (?W \\<noteq> 0) =\n   (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n  ?q \\<noteq> ?x \\<Longrightarrow>\n  card {z. z \\<le> - (?W + choose_point (?D * ?q) * ?q\\<^sup>T)}\n  < card {z. z \\<le> - ?W}\n\ngoal (2 subgoals):\n 1. \\<And>n e p q v x y C D W.\n       (((is_acyclic D \\<and>\n          point x \\<and>\n          point y \\<and>\n          point q \\<and>\n          D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n          W \\<le> D \\<and>\n          terminating_path W \\<and>\n          (W = 0) = (q = y) \\<and>\n          (W \\<noteq> 0) =\n          (q = start_points W \\<and> y = end_points W)) \\<and>\n         D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n        q \\<noteq> x) \\<and>\n       card {z. z \\<le> - W} = n \\<Longrightarrow>\n       (case (e, choose_point (D * q), choose_point (D * q), v, x, y, C, D,\n              W + choose_point (D * q) * q\\<^sup>T) of\n        (e, p, q, v, x, y, C, D, W) \\<Rightarrow> card {z. z \\<le> - W})\n       < n\n 2. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "using construct_cycle_post"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?q \\<noteq> ?x;\n   (is_acyclic ?D \\<and>\n    point ?x \\<and>\n    point ?y \\<and>\n    point ?q \\<and>\n    ?D\\<^sup>\\<star> * ?q \\<le> ?D\\<^sup>T\\<^sup>\\<star> * ?x \\<and>\n    ?W \\<le> ?D \\<and>\n    terminating_path ?W \\<and>\n    (?W = 0) = (?q = ?y) \\<and>\n    (?W \\<noteq> 0) =\n    (?q = start_points ?W \\<and> ?y = end_points ?W)) \\<and>\n   ?D \\<le> ?R \\<and> ?D * ?x = 0 \\<and> ?y * ?x\\<^sup>T \\<le> ?R\\<rbrakk>\n  \\<Longrightarrow> ?W + ?y * ?x\\<^sup>T \\<noteq> 0 \\<and>\n                    ?W + ?y * ?x\\<^sup>T \\<le> ?R \\<and>\n                    cycle (?W + ?y * ?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>e p q v x y C D W.\n       ((is_acyclic D \\<and>\n         point x \\<and>\n         point y \\<and>\n         point q \\<and>\n         D\\<^sup>\\<star> * q \\<le> D\\<^sup>T\\<^sup>\\<star> * x \\<and>\n         W \\<le> D \\<and>\n         terminating_path W \\<and>\n         (W = 0) = (q = y) \\<and>\n         (W \\<noteq> 0) =\n         (q = start_points W \\<and> y = end_points W)) \\<and>\n        D \\<le> R \\<and> D * x = 0 \\<and> y * x\\<^sup>T \\<le> R) \\<and>\n       \\<not> q \\<noteq> x \\<Longrightarrow>\n       W + y * x\\<^sup>T \\<noteq> 0 \\<and>\n       W + y * x\\<^sup>T \\<le> R \\<and> cycle (W + y * x\\<^sup>T)", "by blast"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_choose_point_finite *)"], ["", "end"]]}