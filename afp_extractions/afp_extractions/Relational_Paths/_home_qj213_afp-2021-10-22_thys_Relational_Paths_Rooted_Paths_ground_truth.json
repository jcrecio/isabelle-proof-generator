{"file_name": "/home/qj213/afp-2021-10-22/thys/Relational_Paths/Rooted_Paths.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relational_Paths", "problem_names": ["lemma step_has_target:\n  assumes \"x;r \\<noteq> 0\"\n    shows \"x\\<^sup>T;1 \\<noteq> 0\"", "lemma end_point_char:\n  \"x\\<^sup>T;p = 0 \\<longleftrightarrow> p \\<le> -(x;1)\"", "lemma successor_point:\n  assumes \"is_inj x\"\n      and \"point r\"\n      and \"x;r \\<noteq> 0\"\n    shows \"point (x;r)\"", "lemma no_end_point_char:\n  assumes \"point p\"\n    shows \"x\\<^sup>T;p \\<noteq> 0 \\<longleftrightarrow> p \\<le> x;1\"", "lemma no_end_point_char_converse:\n  assumes \"point p\"\n    shows \"x;p \\<noteq> 0 \\<longleftrightarrow> p \\<le> x\\<^sup>T;1\"", "lemma connected_root_iff1:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> 1;x \\<le> r\\<^sup>T;x\\<^sup>+\"", "lemma connected_root_iff2:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> x\\<^sup>T;1 \\<le> x\\<^sup>T\\<^sup>+;r\"", "lemma connected_root_aux:\n  \"x\\<^sup>T\\<^sup>+;r \\<le> x\\<^sup>T;1\"", "lemma connected_root_iff3:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> x\\<^sup>T;1 = x\\<^sup>T\\<^sup>+;r\"", "lemma connected_root_iff4:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> 1;x = r\\<^sup>T;x\\<^sup>+\"", "lemma has_root_contra:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x\\<^sup>T;r = 0\"\n    shows \"x = 0\"", "lemma has_root:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x \\<noteq> 0\"\n    shows \"x\\<^sup>T;r \\<noteq> 0\"", "lemma connected_root_move_root:\n  assumes \"connected_root r x\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"connected_root q x\"", "lemma root_cycle_converse:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x;r \\<noteq> 0\"\n    shows \"x\\<^sup>T;r \\<noteq> 0\"", "lemma path_iff_aux_1:\n  assumes \"bijective r\"\n    shows \"r;x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star> \\<longleftrightarrow> x \\<le> r\\<^sup>T;(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\"", "lemma path_iff_aux_2:\n  assumes \"bijective r\"\n  shows \"r;x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star> \\<longleftrightarrow> x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);r\"", "lemma path_iff_backward:\n  assumes \"is_inj x\"\n      and \"is_p_fun x\"\n      and \"point r\"\n      and \"r;x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"\n    shows \"connected x\"", "lemma empty_path_root_end:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"e = r \\<longleftrightarrow> x = 0\"", "lemma path_root_acyclic:\n  assumes \"path_root r x\"\n      and \"x;r = 0\"\n    shows \"is_acyclic x\"", "lemma start_points_in_root_aux:\n  assumes \"backward_finite_path_root r x\"\n  shows \"x;1 \\<le> x\\<^sup>T\\<^sup>\\<star>;r\"", "lemma start_points_in_root:\n  assumes \"backward_finite_path_root r x\"\n  shows \"start_points x \\<le> r\"", "lemma start_points_not_zero_contra:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"start_points x = 0\"\n      and \"x;r = 0\"\n    shows \"x = 0\"", "lemma start_points_not_zero:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x \\<noteq> 0\"\n      and \"x;r = 0\"\n    shows \"start_points x \\<noteq> 0\"", "lemma backward_terminating_path_root_aux:\n  assumes \"backward_terminating_path_root r x\"\n  shows \"x \\<le> x\\<^sup>T\\<^sup>\\<star>;-(x\\<^sup>T;1)\"", "lemma backward_finite_path_connected_aux:\n  assumes \"backward_finite_path_root r x\"\n    shows \"x\\<^sup>T;r;x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"", "lemma backward_finite_path_connected:\n  assumes \"backward_finite_path_root r x\"\n    shows \"connected x\"", "lemma backward_finite_path_root_path:\n  assumes \"backward_finite_path_root r x\"\n    shows \"path x\"", "lemma backward_finite_path_root_path_root:\n  assumes \"backward_finite_path_root r x\"\n    shows \"path_root r x\"", "lemma zero_backward_terminating_path_root:\n  assumes \"point r\"\n    shows \"backward_terminating_path_root r 0\"", "lemma backward_finite_path_root_move_root:\n  assumes \"backward_finite_path_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"backward_finite_path_root q x\"", "lemma non_empty_cycle_root_var_axioms_1:\n  \"non_empty_cycle_root r x \\<longleftrightarrow> x\\<^sup>T;1 \\<le> x\\<^sup>T\\<^sup>+;r \\<and> is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>T;1\"", "lemma non_empty_cycle_root_loop:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"r \\<le> x\\<^sup>T\\<^sup>+;r\"", "lemma cycle_root_end_empty:\n  assumes \"terminating_path_root_end r x e\"\n      and \"many_strongly_connected x\"\n    shows \"x = 0\"", "lemma cycle_root_end_empty_var:\n  assumes \"terminating_path_root_end r x e\"\n      and \"x \\<noteq> 0\"\n    shows \"\\<not> many_strongly_connected x\"", "lemma terminating_path_root_end_connected:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"x;1 \\<le> x\\<^sup>+;e\"", "lemma terminating_path_root_end_forward_finite:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"backward_finite_path_root e (x\\<^sup>T)\"", "lemma point_reachable_converse:\n  assumes \"is_vector v\"\n      and \"v \\<noteq> 0\"\n      and \"point r\"\n      and \"v \\<le> x\\<^sup>T\\<^sup>+;r\"\n    shows \"r \\<le> x\\<^sup>+;v\"", "lemma root_in_start_points:\n  assumes \"connected_root r x\"\n      and \"is_vector r\"\n      and \"x \\<noteq> 0\"\n      and \"x;r = 0\"\n    shows \"r \\<le> start_points x\"", "lemma root_equals_start_points:\n  assumes \"backward_terminating_path_root r x\"\n      and \"x \\<noteq> 0\"\n    shows \"r = start_points x\"", "lemma root_equals_end_points:\n  assumes \"backward_terminating_path_root r (x\\<^sup>T)\"\n      and \"x \\<noteq> 0\"\n    shows \"r = end_points x\"", "lemma root_in_edge_sources:\n  assumes \"connected_root r x\"\n      and \"x \\<noteq> 0\"\n      and \"is_vector r\"\n    shows \"r \\<le> x;1\"", "lemma non_empty_path_root_iff_aux:\n  assumes \"path_root r x\"\n      and \"x \\<noteq> 0\"\n    shows \"r \\<le> (x + x\\<^sup>T);1\"", "lemma backward_terminating_path_root_2:\n  assumes \"backward_terminating_path_root r x\"\n    shows \"backward_terminating x\"", "lemma backward_terminating_path_root:\n  assumes \"backward_terminating_path_root r x\"\n    shows \"backward_terminating_path x\"", "lemma cycle_iff:\n  assumes \"point r\"\n    shows \"x;r \\<noteq> 0 \\<longleftrightarrow> r \\<le> x\\<^sup>T;1\"", "lemma non_empty_cycle_root_iff:\n  assumes \"connected_root r x\"\n      and \"point r\"\n    shows \"x;r \\<noteq> 0 \\<longleftrightarrow> r \\<le> x\\<^sup>T\\<^sup>+;r\"", "lemma backward_finite_path_root_terminating_or_cycle:\n  \"backward_finite_path_root r x \\<longleftrightarrow> backward_terminating_path_root r x \\<or> non_empty_cycle_root r x\"", "lemma non_empty_cycle_root_msc:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"many_strongly_connected x\"", "lemma non_empty_cycle_root_msc_cycle:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"cycle x\"", "lemma non_empty_cycle_root_non_empty:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x \\<noteq> 0\"", "lemma non_empty_cycle_root_rtc_symmetric:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>T\\<^sup>\\<star>;r\"", "lemma non_empty_cycle_root_point_exchange:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point p\"\n    shows \"r \\<le> x\\<^sup>\\<star>;p \\<longleftrightarrow> p \\<le> x\\<^sup>\\<star>;r\"", "lemma non_empty_cycle_root_rtc_tc:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>+;r\"", "lemma non_empty_cycle_root_no_start_end_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x;1 = x\\<^sup>T;1\"", "lemma non_empty_cycle_root_move_root:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"non_empty_cycle_root q x\"", "lemma non_empty_cycle_root_loop_converse:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"r \\<le> x\\<^sup>+;r\"", "lemma non_empty_cycle_root_move_root_same_reachable:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>\\<star>;q\"", "lemma non_empty_cycle_root_move_root_same_reachable_2:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>T\\<^sup>\\<star>;q\"", "lemma non_empty_cycle_root_move_root_msc:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>T\\<^sup>\\<star>;q = x\\<^sup>\\<star>;q\"", "lemma non_empty_cycle_root_move_root_rtc_tc:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"x\\<^sup>\\<star>;q = x\\<^sup>+;q\"", "lemma non_empty_cycle_root_move_root_loop_converse:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"q \\<le> x\\<^sup>T\\<^sup>+;q\"", "lemma non_empty_cycle_root_move_root_loop:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"q \\<le> x\\<^sup>+;q\"", "lemma non_empty_cycle_root_msc_plus:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>+;r = x\\<^sup>T\\<^sup>+;r\"", "lemma non_empty_cycle_root_tc_start_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>+;r = x;1\"", "lemma non_empty_cycle_root_rtc_start_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>\\<star>;r = x;1\"", "lemma non_empty_cycle_root_converse_start_end_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>T \\<le> x;1;x\"", "lemma non_empty_cycle_root_start_end_points_plus:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x;1;x \\<le> x\\<^sup>+\"", "lemma non_empty_cycle_root_converse_plus:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>T \\<le> x\\<^sup>+\"", "lemma non_empty_cycle_root_plus_converse:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>+ = x\\<^sup>T\\<^sup>+\"", "lemma non_empty_cycle_root_converse:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"non_empty_cycle_root r (x\\<^sup>T)\"", "lemma non_empty_cycle_root_move_root_forward:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"r \\<le> x\\<^sup>\\<star>;q\"\n    shows \"non_empty_cycle_root q x\"", "lemma non_empty_cycle_root_move_root_forward_cycle:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"r \\<le> x\\<^sup>\\<star>;q\"\n    shows \"x;q \\<noteq> 0 \\<and> x\\<^sup>T;q \\<noteq> 0\"", "lemma non_empty_cycle_root_equivalences:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n    shows \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> q \\<le> x\\<^sup>\\<star>;r)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> x;q \\<noteq> 0)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> x\\<^sup>T;q \\<noteq> 0)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> q \\<le> x;1)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> q \\<le> x\\<^sup>T;1)\"", "lemma non_empty_cycle_root_chord:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point p\"\n      and \"point q\"\n      and \"r \\<le> x\\<^sup>\\<star>;p\"\n      and \"r \\<le> x\\<^sup>\\<star>;q\"\n    shows \"p \\<le> x\\<^sup>\\<star>;q\"", "lemma non_empty_cycle_root_var_axioms_2:\n  \"non_empty_cycle_root r x \\<longleftrightarrow> x;1 \\<le> x\\<^sup>+;r \\<and> is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x;1\"", "lemma non_empty_cycle_root_var_axioms_3:\n  \"non_empty_cycle_root r x \\<longleftrightarrow> x;1 \\<le> x\\<^sup>+;r \\<and> is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>+;x;1\"", "lemma non_empty_cycle_root_subset_equals:\n  assumes \"non_empty_cycle_root r x\"\n      and \"non_empty_cycle_root r y\"\n      and \"x \\<le> y\"\n    shows \"x = y\"", "lemma non_empty_cycle_root_subset_equals_change_root:\n  assumes \"non_empty_cycle_root r x\"\n      and \"non_empty_cycle_root q y\"\n      and \"x \\<le> y\"\n    shows \"x = y\"", "lemma non_empty_cycle_root_equivalences_2:\n  assumes \"non_empty_cycle_root r x\"\n     shows \"(v \\<le> x\\<^sup>\\<star>;r \\<longleftrightarrow> v \\<le> x\\<^sup>T;1)\"\n       and \"(v \\<le> x\\<^sup>\\<star>;r \\<longleftrightarrow> v \\<le> x;1)\"", "lemma cycle_root_non_empty:\n  assumes \"x \\<noteq> 0\"\n    shows \"cycle_root r x \\<longleftrightarrow> non_empty_cycle_root r x\"", "lemma start_points_path_aux:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"x;r = 0\"", "lemma start_points_path:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"backward_terminating_path_root r x\"", "lemma root_in_start_points_2:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"r \\<le> start_points x\"", "lemma root_equals_start_points_2:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"r = start_points x\"", "lemma start_points_injective:\n  assumes \"backward_finite_path_root r x\"\n    shows \"is_inj (start_points x)\"", "lemma backward_terminating_path_root_aux_2:\n assumes \"backward_finite_path_root r x\"\n     and \"start_points x \\<noteq> 0 \\<or> x = 0\"\n   shows \"x \\<le> x\\<^sup>T\\<^sup>\\<star>;-(x\\<^sup>T;1)\"", "lemma start_points_not_zero_iff:\n  assumes \"backward_finite_path_root r x\"\n    shows \"x;r = 0 \\<and> x \\<noteq> 0 \\<longleftrightarrow> start_points x \\<noteq> 0\"", "lemma backward_finite_path_root_acyclic_terminating_aux:\n  assumes \"backward_finite_path_root r x\"\n      and \"is_acyclic x\"\n    shows \"x;r = 0\"", "lemma backward_finite_path_root_acyclic_terminating_iff:\n  assumes \"backward_finite_path_root r x\"\n    shows \"is_acyclic x \\<longleftrightarrow> x;r = 0\"", "lemma backward_finite_path_root_acyclic_terminating:\n assumes \"backward_finite_path_root r x\"\n     and \"is_acyclic x\"\n   shows \"backward_terminating_path_root r x\"", "lemma non_empty_cycle_root_one_strongly_connected:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"one_strongly_connected x\"", "lemma backward_finite_path_root_nodes_reachable:\n  assumes \"backward_finite_path_root r x\"\n      and \"v \\<le> x;1 + x\\<^sup>T;1\"\n      and \"is_sur v\"\n    shows \"r \\<le> x\\<^sup>\\<star>;v\"", "lemma terminating_path_root_end_backward_terminating:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"backward_terminating_path_root r x\"", "lemma terminating_path_root_end_converse:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"terminating_path_root_end e (x\\<^sup>T) r\"", "lemma terminating_path_root_end_forward_terminating:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"backward_terminating_path_root e (x\\<^sup>T)\"", "lemma path_root_iff:\n  \"(\\<exists>r . path_root r x) \\<longleftrightarrow> path x\"", "lemma non_empty_path_root_iff:\n  \"(\\<exists>r . path_root r x \\<and> r \\<le> (x + x\\<^sup>T);1) \\<longleftrightarrow> path x \\<and> x \\<noteq> 0\"", "lemma non_empty_cycle_root_iff:\n  \"(\\<exists>r . non_empty_cycle_root r x) \\<longleftrightarrow> cycle x \\<and> x \\<noteq> 0\"", "lemma non_empty_cycle_subset_equals:\n  assumes \"cycle x\"\n      and \"cycle y\"\n      and \"x \\<le> y\"\n      and \"x \\<noteq> 0\"\n    shows \"x = y\"", "lemma cycle_root_iff:\n  \"(\\<exists>r . cycle_root r x) \\<longleftrightarrow> cycle x\"", "lemma backward_terminating_path_root_iff:\n  \"(\\<exists>r . backward_terminating_path_root r x) \\<longleftrightarrow> backward_terminating_path x\"", "lemma non_empty_backward_terminating_path_root_iff:\n  \"backward_terminating_path_root (start_points x) x \\<longleftrightarrow> backward_terminating_path x \\<and> x \\<noteq> 0\"", "lemma non_empty_backward_terminating_path_root_iff':\n  \"backward_finite_path_root (start_points x) x \\<longleftrightarrow> backward_terminating_path x \\<and> x \\<noteq> 0\"", "lemma backward_finite_path_root_iff:\n  \"(\\<exists>r . backward_finite_path_root r x) \\<longleftrightarrow> backward_finite_path x\"", "lemma non_empty_backward_finite_path_root_iff:\n  \"(\\<exists>r . backward_finite_path_root r x \\<and> r \\<le> x;1) \\<longleftrightarrow> backward_finite_path x \\<and> x \\<noteq> 0\"", "lemma terminating_path_root_end_aux:\n  assumes \"terminating_path x\"\n    shows \"\\<exists>r e . terminating_path_root_end r x e\"", "lemma terminating_path_root_end_iff:\n  \"(\\<exists>r e . terminating_path_root_end r x e) \\<longleftrightarrow> terminating_path x\"", "lemma non_empty_terminating_path_root_end_iff:\n  \"terminating_path_root_end (start_points x) x (end_points x) \\<longleftrightarrow> terminating_path x \\<and> x \\<noteq> 0\"", "lemma non_empty_finite_path_root_end_iff:\n  \"finite_path_root_end (start_points x) x (end_points x) \\<longleftrightarrow> terminating_path x \\<and> x \\<noteq> 0\""], "translations": [["", "lemma step_has_target:\n  assumes \"x;r \\<noteq> 0\"\n    shows \"x\\<^sup>T;1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 \\<noteq> 0", "using assms inf.commute inf_bot_right schroeder_1"], ["proof (prove)\nusing this:\n  x ; r \\<noteq> 0\n  ?a \\<cdot> ?b = ?b \\<cdot> ?a\n  ?x \\<cdot> 0 = 0\n  (?x ; ?y \\<cdot> ?z = 0) = (?y \\<cdot> ?x\\<^sup>T ; ?z = 0)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 \\<noteq> 0", "by fastforce"], ["", "lemma end_point_char:\n  \"x\\<^sup>T;p = 0 \\<longleftrightarrow> p \\<le> -(x;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T ; p = 0) = (p \\<le> - (x ; 1))", "using antisym bot_least compl_bot_eq conv_galois_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  0 \\<le> ?a\n  - 0 = 1\n  (?x ; ?y \\<le> ?z) = (?y \\<le> - (?x\\<^sup>T ; - ?z))\n\ngoal (1 subgoal):\n 1. (x\\<^sup>T ; p = 0) = (p \\<le> - (x ; 1))", "by fastforce"], ["", "end"], ["", "(* relation_algebra *)"], ["", "context relation_algebra_tarski\nbegin"], ["", "text \\<open>General theorems concerning points\\<close>"], ["", "lemma successor_point:\n  assumes \"is_inj x\"\n      and \"point r\"\n      and \"x;r \\<noteq> 0\"\n    shows \"point (x;r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (x ; r)", "using assms"], ["proof (prove)\nusing this:\n  is_inj x\n  point r\n  x ; r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. point (x ; r)", "by (simp add: inj_compose is_point_def is_vector_def mult_assoc point_is_point)"], ["", "lemma no_end_point_char:\n  assumes \"point p\"\n    shows \"x\\<^sup>T;p \\<noteq> 0 \\<longleftrightarrow> p \\<le> x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T ; p \\<noteq> 0) = (p \\<le> x ; 1)", "by (simp add: assms comp_assoc end_point_char is_vector_def point_in_vector_or_complement_iff)"], ["", "lemma no_end_point_char_converse:\n  assumes \"point p\"\n    shows \"x;p \\<noteq> 0 \\<longleftrightarrow> p \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; p \\<noteq> 0) = (p \\<le> x\\<^sup>T ; 1)", "using assms no_end_point_char"], ["proof (prove)\nusing this:\n  point p\n  point ?p \\<Longrightarrow>\n  (?x\\<^sup>T ; ?p \\<noteq> 0) = (?p \\<le> ?x ; 1)\n\ngoal (1 subgoal):\n 1. (x ; p \\<noteq> 0) = (p \\<le> x\\<^sup>T ; 1)", "by force"], ["", "end"], ["", "(* relation_algebra_tarski *)"], ["", "subsection \\<open>Consequences without the Tarski rule\\<close>"], ["", "context relation_algebra_rtc\nbegin"], ["", "text \\<open>Definitions for path classifications\\<close>"], ["", "definition path_root\n  where \"path_root r x \\<equiv> r;x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star> \\<and> is_inj x \\<and> is_p_fun x \\<and> point r\""], ["", "abbreviation connected_root\n  where \"connected_root r x \\<equiv> r;x \\<le> x\\<^sup>+\""], ["", "definition backward_finite_path_root\n  where \"backward_finite_path_root r x \\<equiv> connected_root r x \\<and> is_inj x \\<and> is_p_fun x \\<and> point r\""], ["", "abbreviation backward_terminating_path_root\n  where \"backward_terminating_path_root r x \\<equiv> backward_finite_path_root r x \\<and> x;r = 0\""], ["", "abbreviation cycle_root\n  where \"cycle_root r x \\<equiv> r;x \\<le> x\\<^sup>+ \\<cdot> x\\<^sup>T;1 \\<and> is_inj x \\<and> is_p_fun x \\<and> point r\""], ["", "abbreviation non_empty_cycle_root\n  where \"non_empty_cycle_root r x \\<equiv> backward_finite_path_root r x \\<and> r \\<le> x\\<^sup>T;1\""], ["", "abbreviation finite_path_root_end\n  where \"finite_path_root_end r x e \\<equiv> backward_finite_path_root r x \\<and> point e \\<and> r \\<le> x\\<^sup>\\<star>;e\""], ["", "abbreviation terminating_path_root_end\n  where \"terminating_path_root_end r x e \\<equiv> finite_path_root_end r x e \\<and> x\\<^sup>T;e = 0\""], ["", "text \\<open>Equivalent formulations of \\<open>connected_root\\<close>\\<close>"], ["", "lemma connected_root_iff1:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> 1;x \\<le> r\\<^sup>T;x\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_root r x = (1 ; x \\<le> r\\<^sup>T ; x\\<^sup>+)", "by (metis assms comp_assoc is_vector_def point_def ss423conv)"], ["", "lemma connected_root_iff2:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> x\\<^sup>T;1 \\<le> x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_root r x = (x\\<^sup>T ; 1 \\<le> x\\<^sup>T\\<^sup>+ ; r)", "by (metis assms conv_contrav conv_invol conv_iso conv_one star_conv star_slide_var\n          connected_root_iff1)"], ["", "lemma connected_root_aux:\n  \"x\\<^sup>T\\<^sup>+;r \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; r \\<le> x\\<^sup>T ; 1", "by (simp add: comp_assoc mult_isol)"], ["", "lemma connected_root_iff3:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> x\\<^sup>T;1 = x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_root r x = (x\\<^sup>T ; 1 = x\\<^sup>T\\<^sup>+ ; r)", "using assms antisym connected_root_aux connected_root_iff2"], ["proof (prove)\nusing this:\n  point r\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  ?x\\<^sup>T\\<^sup>+ ; ?r \\<le> ?x\\<^sup>T ; 1\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 \\<le> ?x\\<^sup>T\\<^sup>+ ; ?r)\n\ngoal (1 subgoal):\n 1. connected_root r x = (x\\<^sup>T ; 1 = x\\<^sup>T\\<^sup>+ ; r)", "by fastforce"], ["", "lemma connected_root_iff4:\n  assumes \"point r\"\n    shows \"connected_root r x \\<longleftrightarrow> 1;x = r\\<^sup>T;x\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_root r x = (1 ; x = r\\<^sup>T ; x\\<^sup>+)", "by (metis assms conv_contrav conv_invol conv_one star_conv star_slide_var connected_root_iff3)"], ["", "text \\<open>Consequences of \\<open>connected_root\\<close>\\<close>"], ["", "lemma has_root_contra:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x\\<^sup>T;r = 0\"\n    shows \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "using assms comp_assoc independence1 conv_zero ss_p18 connected_root_iff3"], ["proof (prove)\nusing this:\n  connected_root r x\n  point r\n  x\\<^sup>T ; r = 0\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?x ; ?y = 0 \\<Longrightarrow> ?x\\<^sup>\\<star> ; ?y = ?y\n  0\\<^sup>T = 0\n  (?x ; 1 = 0) = (?x = 0)\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n\ngoal (1 subgoal):\n 1. x = 0", "by force"], ["", "lemma has_root:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x \\<noteq> 0\"\n    shows \"x\\<^sup>T;r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<noteq> 0", "using has_root_contra assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>connected_root ?r ?x; point ?r; ?x\\<^sup>T ; ?r = 0\\<rbrakk>\n  \\<Longrightarrow> ?x = 0\n  connected_root r x\n  point r\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<noteq> 0", "by blast"], ["", "lemma connected_root_move_root:\n  assumes \"connected_root r x\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"connected_root q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_root q x", "by (metis assms comp_assoc mult_isol phl_cons1 star_slide_var star_trans_eq)"], ["", "lemma root_cycle_converse:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x;r \\<noteq> 0\"\n    shows \"x\\<^sup>T;r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<noteq> 0", "using assms conv_zero has_root"], ["proof (prove)\nusing this:\n  connected_root r x\n  point r\n  x ; r \\<noteq> 0\n  0\\<^sup>T = 0\n  \\<lbrakk>connected_root ?r ?x; point ?r; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?x\\<^sup>T ; ?r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<noteq> 0", "by fastforce"], ["", "text \\<open>Rooted paths\\<close>"], ["", "lemma path_iff_aux_1:\n  assumes \"bijective r\"\n    shows \"r;x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star> \\<longleftrightarrow> x \\<le> r\\<^sup>T;(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    (x \\<le> r\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>))", "by (simp add: assms ss423conv)"], ["", "lemma path_iff_aux_2:\n  assumes \"bijective r\"\n  shows \"r;x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star> \\<longleftrightarrow> x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    (x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    (x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)", "have \"((x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);r)\\<^sup>T = r\\<^sup>T;(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)\\<^sup>T =\n    r\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)", "by (metis conv_add conv_contrav conv_invol star_conv sup.commute)"], ["proof (state)\nthis:\n  ((x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)\\<^sup>T =\n  r\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    (x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)\\<^sup>T =\n  r\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    (x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)", "by (metis assms conv_invol conv_iso path_iff_aux_1)"], ["proof (state)\nthis:\n  (r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n  (x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_iff_backward:\n  assumes \"is_inj x\"\n      and \"is_p_fun x\"\n      and \"point r\"\n      and \"r;x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"\n    shows \"connected x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. connected x", "have \"x\\<^sup>T;1;x\\<^sup>T \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);r;1;x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x\\<^sup>T\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T", "using assms(3,4) path_iff_aux_2 mult_isor point_def"], ["proof (prove)\nusing this:\n  point r\n  r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n  bijective ?r \\<Longrightarrow>\n  (?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>) =\n  (?x\\<^sup>T \\<le> (?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>) ; ?r)\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x\\<^sup>T\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "have \"... = (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);r;1;x\\<^sup>T;x;x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T =\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T ; x ;\n    x\\<^sup>T", "using assms(1) comp_assoc inj_p_fun p_fun_triple"], ["proof (prove)\nusing this:\n  is_inj x\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_inj ?x = is_p_fun (?x\\<^sup>T)\n  is_p_fun ?x \\<Longrightarrow> ?x = ?x ; ?x\\<^sup>T ; ?x\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T =\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T ; x ;\n    x\\<^sup>T", "by fastforce"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T =\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T ; x ;\n  x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T =\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T ; x ;\n  x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "have \"... \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);r;x;x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T ; x ;\n    x\\<^sup>T\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; x ; x\\<^sup>T", "by (metis assms(3) mult_double_iso top_greatest point_def is_vector_def comp_assoc)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T ; x ;\n  x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; x ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; 1 ; x\\<^sup>T ; x ;\n  x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; x ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "have \"... \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; x ; x\\<^sup>T\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          x\\<^sup>T", "by (metis assms(4) comp_assoc mult_double_iso)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; x ; x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; r ; x ; x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        x\\<^sup>T\n\ngoal (1 subgoal):\n 1. connected x", "have \"... \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    x\\<^sup>T\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)", "using le_supI2 mult_isol star_ext"], ["proof (prove)\nusing this:\n  ?x \\<le> ?b \\<Longrightarrow> ?x \\<le> ?a + ?b\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n  ?x \\<le> ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    x\\<^sup>T\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)", "by blast"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n  x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n  x\\<^sup>T\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n        (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. connected x", "have \"... = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "using assms(1,2) cancel_separate_converse_idempotent"], ["proof (prove)\nusing this:\n  is_inj x\n  is_p_fun x\n  \\<lbrakk>is_inj ?x; is_p_fun ?x\\<rbrakk>\n  \\<Longrightarrow> (?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>) ;\n                    (?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>) =\n                    ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n  x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. connected x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T ; 1 ; x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; 1 ; x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. connected x", "by (metis conv_add conv_contrav conv_invol conv_one mult_assoc star_conv sup.orderE sup.orderI\n              sup_commute)"], ["proof (state)\nthis:\n  connected x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma empty_path_root_end:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"e = r \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e = r) = (x = 0)", "apply(standard)"], ["proof (prove)\ngoal (2 subgoals):\n 1. e = r \\<Longrightarrow> x = 0\n 2. x = 0 \\<Longrightarrow> e = r", "using assms has_root backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  terminating_path_root_end r x e\n  \\<lbrakk>connected_root ?r ?x; point ?r; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?x\\<^sup>T ; ?r \\<noteq> 0\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (2 subgoals):\n 1. e = r \\<Longrightarrow> x = 0\n 2. x = 0 \\<Longrightarrow> e = r", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> e = r", "by (metis assms antisym conv_e conv_zero independence1 is_inj_def mult_oner point_swap\n          backward_finite_path_root_def ss423conv sur_def_var1 x_leq_triple_x)"], ["", "lemma path_root_acyclic:\n  assumes \"path_root r x\"\n      and \"x;r = 0\"\n    shows \"is_acyclic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"x\\<^sup>+\\<cdot>1' = (x\\<^sup>+)\\<^sup>T\\<cdot>x\\<^sup>+\\<cdot>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<cdot> 1' = (x\\<^sup>+)\\<^sup>T \\<cdot> x\\<^sup>+ \\<cdot> 1'", "by (metis conv_e conv_times inf.assoc inf.left_idem inf_le2 many_strongly_connected_iff_7 mult_oner star_subid)"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<cdot> 1' = (x\\<^sup>+)\\<^sup>T \\<cdot> x\\<^sup>+ \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<cdot> 1' = (x\\<^sup>+)\\<^sup>T \\<cdot> x\\<^sup>+ \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... \\<le> x\\<^sup>T;1\\<cdot>x\\<^sup>+\\<cdot>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+)\\<^sup>T \\<cdot> x\\<^sup>+ \\<cdot> 1'\n    \\<le> x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1'", "by (metis conv_contrav inf.commute maddux_20 meet_double_iso plus_top star_conv star_slide_var)"], ["proof (state)\nthis:\n  (x\\<^sup>+)\\<^sup>T \\<cdot> x\\<^sup>+ \\<cdot> 1'\n  \\<le> x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. is_acyclic x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>+ \\<cdot> 1' \\<le> x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1'", "have \"r;(x\\<^sup>+\\<cdot>1') \\<le> r;(x\\<^sup>T;1\\<cdot>x\\<^sup>+\\<cdot>1')\""], ["proof (prove)\nusing this:\n  x\\<^sup>+ \\<cdot> 1' \\<le> x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1'\n\ngoal (1 subgoal):\n 1. r ; (x\\<^sup>+ \\<cdot> 1')\n    \\<le> r ; (x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1')", "using mult_isol"], ["proof (prove)\nusing this:\n  x\\<^sup>+ \\<cdot> 1' \\<le> x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1'\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n\ngoal (1 subgoal):\n 1. r ; (x\\<^sup>+ \\<cdot> 1')\n    \\<le> r ; (x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1')", "by blast"], ["proof (state)\nthis:\n  r ; (x\\<^sup>+ \\<cdot> 1')\n  \\<le> r ; (x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  r ; (x\\<^sup>+ \\<cdot> 1')\n  \\<le> r ; (x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... = (r\\<cdot>1;x);(x\\<^sup>+\\<cdot>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; (x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1') =\n    (r \\<cdot> 1 ; x) ; (x\\<^sup>+ \\<cdot> 1')", "by (metis (no_types, lifting) comp_assoc conv_contrav conv_invol conv_one inf.assoc is_vector_def one_idem_mult vector_2)"], ["proof (state)\nthis:\n  r ; (x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1') =\n  (r \\<cdot> 1 ; x) ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  r ; (x\\<^sup>T ; 1 \\<cdot> x\\<^sup>+ \\<cdot> 1') =\n  (r \\<cdot> 1 ; x) ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... = r;x;(x\\<^sup>+\\<cdot>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<cdot> 1 ; x) ; (x\\<^sup>+ \\<cdot> 1') =\n    r ; x ; (x\\<^sup>+ \\<cdot> 1')", "by (metis assms(1) path_root_def point_def inf_top_right vector_1)"], ["proof (state)\nthis:\n  (r \\<cdot> 1 ; x) ; (x\\<^sup>+ \\<cdot> 1') =\n  r ; x ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  (r \\<cdot> 1 ; x) ; (x\\<^sup>+ \\<cdot> 1') =\n  r ; x ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);(x\\<^sup>+\\<cdot>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; x ; (x\\<^sup>+ \\<cdot> 1')\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          (x\\<^sup>+ \\<cdot> 1')", "using assms(1) mult_isor path_root_def"], ["proof (prove)\nusing this:\n  path_root r x\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n  path_root ?r ?x \\<equiv>\n  ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star> \\<and>\n  is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. r ; x ; (x\\<^sup>+ \\<cdot> 1')\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n          (x\\<^sup>+ \\<cdot> 1')", "by blast"], ["proof (state)\nthis:\n  r ; x ; (x\\<^sup>+ \\<cdot> 1')\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  r ; x ; (x\\<^sup>+ \\<cdot> 1')\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... = x\\<^sup>\\<star>;(x\\<^sup>+\\<cdot>1') + x\\<^sup>T\\<^sup>+;(x\\<^sup>+\\<cdot>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; (x\\<^sup>+ \\<cdot> 1') =\n    x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') +\n    x\\<^sup>T\\<^sup>+ ; (x\\<^sup>+ \\<cdot> 1')", "by (metis distrib_right star_star_plus sup.commute)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; (x\\<^sup>+ \\<cdot> 1') =\n  x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') +\n  x\\<^sup>T\\<^sup>+ ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; (x\\<^sup>+ \\<cdot> 1') =\n  x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') +\n  x\\<^sup>T\\<^sup>+ ; (x\\<^sup>+ \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... \\<le> x\\<^sup>\\<star>;(x\\<^sup>+\\<cdot>1') + x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') +\n    x\\<^sup>T\\<^sup>+ ; (x\\<^sup>+ \\<cdot> 1')\n    \\<le> x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') + x\\<^sup>T ; 1", "by (metis join_isol mult_isol plus_top top_greatest)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') +\n  x\\<^sup>T\\<^sup>+ ; (x\\<^sup>+ \\<cdot> 1')\n  \\<le> x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') + x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "finally"], ["proof (chain)\npicking this:\n  r ; (x\\<^sup>+ \\<cdot> 1')\n  \\<le> x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') + x\\<^sup>T ; 1", "have \"r;(x\\<^sup>+\\<cdot>1');1 \\<le> x\\<^sup>\\<star>;(x\\<^sup>+\\<cdot>1');1 + x\\<^sup>T;1\""], ["proof (prove)\nusing this:\n  r ; (x\\<^sup>+ \\<cdot> 1')\n  \\<le> x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') + x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r ; (x\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 + x\\<^sup>T ; 1", "by (metis distrib_right inf_absorb2 mult_assoc mult_subdistr one_idem_mult)"], ["proof (state)\nthis:\n  r ; (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 + x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "hence 1: \"r;(x\\<^sup>+\\<cdot>1');1 \\<le> x\\<^sup>T;1\""], ["proof (prove)\nusing this:\n  r ; (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 + x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "by (metis assms(1) inj_implies_step_forwards_backwards sup_absorb2 path_root_def)"], ["proof (state)\nthis:\n  r ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"x\\<^sup>+\\<cdot>1' \\<le> (x\\<^sup>+\\<cdot>1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<cdot> 1' \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1", "by (simp add: maddux_20)"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<cdot> 1' \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<cdot> 1' \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... \\<le> r\\<^sup>T;r;(x\\<^sup>+\\<cdot>1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> r\\<^sup>T ; r ; (x\\<^sup>+ \\<cdot> 1') ; 1", "by (metis assms(1) comp_assoc order.refl point_def ss423conv path_root_def)"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> r\\<^sup>T ; r ; (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> r\\<^sup>T ; r ; (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... \\<le> r\\<^sup>T;x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T ; r ; (x\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> r\\<^sup>T ; x\\<^sup>T ; 1", "using 1"], ["proof (prove)\nusing this:\n  r ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r\\<^sup>T ; r ; (x\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> r\\<^sup>T ; x\\<^sup>T ; 1", "by (simp add: comp_assoc mult_isol)"], ["proof (state)\nthis:\n  r\\<^sup>T ; r ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> r\\<^sup>T ; x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  r\\<^sup>T ; r ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> r\\<^sup>T ; x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T ; x\\<^sup>T ; 1 = 0", "using assms(2) annil conv_contrav conv_zero"], ["proof (prove)\nusing this:\n  x ; r = 0\n  0 ; ?x = 0\n  (?x ; ?y)\\<^sup>T = ?y\\<^sup>T ; ?x\\<^sup>T\n  0\\<^sup>T = 0\n\ngoal (1 subgoal):\n 1. r\\<^sup>T ; x\\<^sup>T ; 1 = 0", "by force"], ["proof (state)\nthis:\n  r\\<^sup>T ; x\\<^sup>T ; 1 = 0\n\ngoal (1 subgoal):\n 1. is_acyclic x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>+ \\<cdot> 1' \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>+ \\<cdot> 1' \\<le> 0\n\ngoal (1 subgoal):\n 1. is_acyclic x", "using galois_aux le_bot"], ["proof (prove)\nusing this:\n  x\\<^sup>+ \\<cdot> 1' \\<le> 0\n  (?x \\<cdot> ?y = 0) = (?x \\<le> - ?y)\n  ?a \\<le> 0 \\<Longrightarrow> ?a = 0\n\ngoal (1 subgoal):\n 1. is_acyclic x", "by blast"], ["proof (state)\nthis:\n  is_acyclic x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Start points and end points\\<close>"], ["", "lemma start_points_in_root_aux:\n  assumes \"backward_finite_path_root r x\"\n  shows \"x;1 \\<le> x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "have \"x;1 \\<le> x;x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x ; x\\<^sup>T\\<^sup>+ ; r", "by (metis assms inf_top.left_neutral modular_var_2 mult_assoc connected_root_iff3\n              backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x ; 1 \\<le> x ; x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "also"], ["proof (state)\nthis:\n  x ; 1 \\<le> x ; x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "have \"... \\<le> 1';x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T\\<^sup>+ ; r \\<le> 1' ; x\\<^sup>T\\<^sup>\\<star> ; r", "by (metis assms is_inj_def mult_assoc mult_isor backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x ; x\\<^sup>T\\<^sup>+ ; r \\<le> 1' ; x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "finally"], ["proof (chain)\npicking this:\n  x ; 1 \\<le> 1' ; x\\<^sup>T\\<^sup>\\<star> ; r", "show ?thesis"], ["proof (prove)\nusing this:\n  x ; 1 \\<le> 1' ; x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "by simp"], ["proof (state)\nthis:\n  x ; 1 \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_points_in_root:\n  assumes \"backward_finite_path_root r x\"\n  shows \"start_points x \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_points x \\<le> r", "using assms galois_1 sup_commute connected_root_iff3 backward_finite_path_root_def\n      start_points_in_root_aux"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  (?x \\<cdot> - ?y \\<le> ?z) = (?x \\<le> ?y + ?z)\n  ?x + ?y = ?y + ?x\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  backward_finite_path_root ?r ?x \\<Longrightarrow>\n  ?x ; 1 \\<le> ?x\\<^sup>T\\<^sup>\\<star> ; ?r\n\ngoal (1 subgoal):\n 1. start_points x \\<le> r", "by fastforce"], ["", "lemma start_points_not_zero_contra:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"start_points x = 0\"\n      and \"x;r = 0\"\n    shows \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = 0", "have \"x;1 \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_start_points x", "using assms(3) galois_aux"], ["proof (prove)\nusing this:\n  start_points x = 0\n  (?x \\<cdot> ?y = 0) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. no_start_points x", "by force"], ["proof (state)\nthis:\n  no_start_points x\n\ngoal (1 subgoal):\n 1. x = 0", "also"], ["proof (state)\nthis:\n  no_start_points x\n\ngoal (1 subgoal):\n 1. x = 0", "have \"... \\<le> -r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 \\<le> - r", "using assms(4) comp_res compl_bot_eq"], ["proof (prove)\nusing this:\n  x ; r = 0\n  ?x\\<^sup>T ; - (?x ; ?y) \\<le> - ?y\n  - 0 = 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 \\<le> - r", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 \\<le> - r\n\ngoal (1 subgoal):\n 1. x = 0", "finally"], ["proof (chain)\npicking this:\n  x ; 1 \\<le> - r", "show ?thesis"], ["proof (prove)\nusing this:\n  x ; 1 \\<le> - r\n\ngoal (1 subgoal):\n 1. x = 0", "using assms(1,2) has_root_contra galois_aux schroeder_1"], ["proof (prove)\nusing this:\n  x ; 1 \\<le> - r\n  connected_root r x\n  point r\n  \\<lbrakk>connected_root ?r ?x; point ?r; ?x\\<^sup>T ; ?r = 0\\<rbrakk>\n  \\<Longrightarrow> ?x = 0\n  (?x \\<cdot> ?y = 0) = (?x \\<le> - ?y)\n  (?x ; ?y \\<cdot> ?z = 0) = (?y \\<cdot> ?x\\<^sup>T ; ?z = 0)\n\ngoal (1 subgoal):\n 1. x = 0", "by force"], ["proof (state)\nthis:\n  x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_points_not_zero:\n  assumes \"connected_root r x\"\n      and \"point r\"\n      and \"x \\<noteq> 0\"\n      and \"x;r = 0\"\n    shows \"start_points x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_points x \\<noteq> 0", "using assms start_points_not_zero_contra"], ["proof (prove)\nusing this:\n  connected_root r x\n  point r\n  x \\<noteq> 0\n  x ; r = 0\n  \\<lbrakk>connected_root ?r ?x; point ?r; start_points ?x = 0;\n   ?x ; ?r = 0\\<rbrakk>\n  \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. start_points x \\<noteq> 0", "by blast"], ["", "text \\<open>Backwards terminating and backwards finite\\<close>"], ["", "lemma backward_terminating_path_root_aux:\n  assumes \"backward_terminating_path_root r x\"\n  shows \"x \\<le> x\\<^sup>T\\<^sup>\\<star>;-(x\\<^sup>T;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "have \"x\\<^sup>T\\<^sup>\\<star>;r \\<le> x\\<^sup>T\\<^sup>\\<star>;-(x\\<^sup>T;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; r\n    \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "using assms comp_res compl_bot_eq compl_le_swap1 mult_isol"], ["proof (prove)\nusing this:\n  backward_terminating_path_root r x\n  ?x\\<^sup>T ; - (?x ; ?y) \\<le> - ?y\n  - 0 = 1\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; r\n    \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>\\<star> ; r\n  \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)\n\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>T\\<^sup>\\<star> ; r\n  \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)\n\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "using assms dual_order.trans maddux_20 start_points_in_root_aux"], ["proof (prove)\nusing this:\n  x\\<^sup>T\\<^sup>\\<star> ; r\n  \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)\n  backward_terminating_path_root r x\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?x \\<le> ?x ; 1\n  backward_finite_path_root ?r ?x \\<Longrightarrow>\n  ?x ; 1 \\<le> ?x\\<^sup>T\\<^sup>\\<star> ; ?r\n\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "by blast"], ["proof (state)\nthis:\n  x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma backward_finite_path_connected_aux:\n  assumes \"backward_finite_path_root r x\"\n    shows \"x\\<^sup>T;r;x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"x\\<^sup>T;r;x\\<^sup>T \\<cdot> r\\<^sup>T = x\\<^sup>T;r;(x\\<^sup>T \\<cdot> r\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T =\n    x\\<^sup>T ; r ; (x\\<^sup>T \\<cdot> r\\<^sup>T)", "by (metis conv_invol conv_times vector_1_comm comp_assoc conv_contrav assms\n              backward_finite_path_root_def point_def)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T =\n  x\\<^sup>T ; r ; (x\\<^sup>T \\<cdot> r\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T =\n  x\\<^sup>T ; r ; (x\\<^sup>T \\<cdot> r\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>T;r;r\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; (x\\<^sup>T \\<cdot> r\\<^sup>T)\n    \\<le> x\\<^sup>T ; r ; r\\<^sup>T", "by (simp add: mult_isol)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; (x\\<^sup>T \\<cdot> r\\<^sup>T)\n  \\<le> x\\<^sup>T ; r ; r\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; (x\\<^sup>T \\<cdot> r\\<^sup>T)\n  \\<le> x\\<^sup>T ; r ; r\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have 1: \"... \\<le> x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; r\\<^sup>T \\<le> x\\<^sup>T", "by (metis assms comp_assoc is_inj_def mult_1_right mult_isol point_def\n              backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; r\\<^sup>T \\<le> x\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; r\\<^sup>T \\<le> x\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>T\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>\\<star>", "have 2: \"x\\<^sup>T;r;x\\<^sup>T \\<cdot> r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T\n    \\<le> x\\<^sup>T\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "let ?v = \"x;1 \\<cdot> -r\""], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"?v \\<le> x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<cdot> - r \\<le> x\\<^sup>T\\<^sup>+ ; r", "by (simp add: assms galois_1 start_points_in_root_aux)"], ["proof (state)\nthis:\n  x ; 1 \\<cdot> - r \\<le> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "hence \"r\\<^sup>T;x \\<cdot> ?v \\<le> r\\<^sup>T;x \\<cdot> x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\nusing this:\n  x ; 1 \\<cdot> - r \\<le> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. r\\<^sup>T ; x \\<cdot> (x ; 1 \\<cdot> - r)\n    \\<le> r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r", "using meet_isor"], ["proof (prove)\nusing this:\n  x ; 1 \\<cdot> - r \\<le> x\\<^sup>T\\<^sup>+ ; r\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<cdot> ?x \\<le> ?z \\<cdot> ?y\n\ngoal (1 subgoal):\n 1. r\\<^sup>T ; x \\<cdot> (x ; 1 \\<cdot> - r)\n    \\<le> r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r", "by blast"], ["proof (state)\nthis:\n  r\\<^sup>T ; x \\<cdot> (x ; 1 \\<cdot> - r)\n  \\<le> r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  r\\<^sup>T ; x \\<cdot> (x ; 1 \\<cdot> - r)\n  \\<le> r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have 3: \"... = x\\<^sup>T\\<^sup>+;r \\<cdot> 1;r\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r =\n    x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x", "by (metis assms conv_contrav conv_one inf_commute is_vector_def point_def\n              backward_finite_path_root_def)"], ["proof (state)\nthis:\n  r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r =\n  x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r =\n  x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... = (x\\<^sup>T\\<^sup>+;r \\<cdot> 1);r\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x =\n    (x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1) ; r\\<^sup>T ; x", "using 3"], ["proof (prove)\nusing this:\n  r\\<^sup>T ; x \\<cdot> x\\<^sup>T\\<^sup>+ ; r =\n  x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x =\n    (x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1) ; r\\<^sup>T ; x", "by (metis comp_assoc inf_commute is_vector_def star_conv vector_1 assms\n                      backward_finite_path_root_def point_def)"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x =\n  (x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1) ; r\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1 ; r\\<^sup>T ; x =\n  (x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1) ; r\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... = x\\<^sup>T\\<^sup>+;r;r\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1) ; r\\<^sup>T ; x =\n    x\\<^sup>T\\<^sup>+ ; r ; r\\<^sup>T ; x", "by simp"], ["proof (state)\nthis:\n  (x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1) ; r\\<^sup>T ; x =\n  x\\<^sup>T\\<^sup>+ ; r ; r\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  (x\\<^sup>T\\<^sup>+ ; r \\<cdot> 1) ; r\\<^sup>T ; x =\n  x\\<^sup>T\\<^sup>+ ; r ; r\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>T\\<^sup>+;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; r ; r\\<^sup>T ; x \\<le> x\\<^sup>T\\<^sup>+ ; x", "using 1"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r ; r\\<^sup>T \\<le> x\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; r ; r\\<^sup>T ; x \\<le> x\\<^sup>T\\<^sup>+ ; x", "by (metis mult_assoc mult_isol mult_isor star_slide_var)"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>+ ; r ; r\\<^sup>T ; x \\<le> x\\<^sup>T\\<^sup>+ ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>+ ; r ; r\\<^sup>T ; x \\<le> x\\<^sup>T\\<^sup>+ ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... = x\\<^sup>T\\<^sup>\\<star>;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; x = x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x", "by (simp add: star_slide_var)"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>+ ; x = x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>+ ; x = x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x \\<le> x\\<^sup>T\\<^sup>\\<star>", "by (metis assms backward_finite_path_root_def is_p_fun_def mult_1_right mult_assoc mult_isol_var\n              star_1l star_inductl_star)"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x \\<le> x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  r\\<^sup>T ; x \\<cdot> (x ; 1 \\<cdot> - r) \\<le> x\\<^sup>T\\<^sup>\\<star>", "have 4: \"x\\<^sup>T;r \\<cdot> ?v\\<^sup>T \\<le> x\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  r\\<^sup>T ; x \\<cdot> (x ; 1 \\<cdot> - r) \\<le> x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<cdot> (x ; 1 \\<cdot> - r)\\<^sup>T \\<le> x\\<^sup>\\<star>", "using conv_iso star_conv"], ["proof (prove)\nusing this:\n  r\\<^sup>T ; x \\<cdot> (x ; 1 \\<cdot> - r) \\<le> x\\<^sup>T\\<^sup>\\<star>\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  (?x\\<^sup>\\<star>)\\<^sup>T = ?x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<cdot> (x ; 1 \\<cdot> - r)\\<^sup>T \\<le> x\\<^sup>\\<star>", "by force"], ["proof (state)\nthis:\n  x\\<^sup>T ; r \\<cdot> (x ; 1 \\<cdot> - r)\\<^sup>T \\<le> x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"x\\<^sup>T;r;x\\<^sup>T \\<cdot> -r\\<^sup>T = (x\\<^sup>T;r \\<cdot> 1);x\\<^sup>T \\<cdot> -r\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T =\n    (x\\<^sup>T ; r \\<cdot> 1) ; x\\<^sup>T \\<cdot> - r\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T =\n  (x\\<^sup>T ; r \\<cdot> 1) ; x\\<^sup>T \\<cdot> - r\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T =\n  (x\\<^sup>T ; r \\<cdot> 1) ; x\\<^sup>T \\<cdot> - r\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... = x\\<^sup>T;r \\<cdot> 1;x\\<^sup>T \\<cdot> -r\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T ; r \\<cdot> 1) ; x\\<^sup>T \\<cdot> - r\\<^sup>T =\n    x\\<^sup>T ; r \\<cdot> 1 ; x\\<^sup>T \\<cdot> - r\\<^sup>T", "by (metis inf.commute is_vector_def comp_assoc vector_1 assms backward_finite_path_root_def\n              point_def)"], ["proof (state)\nthis:\n  (x\\<^sup>T ; r \\<cdot> 1) ; x\\<^sup>T \\<cdot> - r\\<^sup>T =\n  x\\<^sup>T ; r \\<cdot> 1 ; x\\<^sup>T \\<cdot> - r\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  (x\\<^sup>T ; r \\<cdot> 1) ; x\\<^sup>T \\<cdot> - r\\<^sup>T =\n  x\\<^sup>T ; r \\<cdot> 1 ; x\\<^sup>T \\<cdot> - r\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<cdot> 1 ; x\\<^sup>T \\<cdot> - r\\<^sup>T\n    \\<le> x\\<^sup>\\<star>", "using 4"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r \\<cdot> (x ; 1 \\<cdot> - r)\\<^sup>T \\<le> x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<cdot> 1 ; x\\<^sup>T \\<cdot> - r\\<^sup>T\n    \\<le> x\\<^sup>\\<star>", "by (simp add: conv_compl inf.assoc)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r \\<cdot> 1 ; x\\<^sup>T \\<cdot> - r\\<^sup>T\n  \\<le> x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T \\<le> x\\<^sup>\\<star>", "have \"(x\\<^sup>T;r;x\\<^sup>T \\<cdot> -r\\<^sup>T) + (x\\<^sup>T;r;x\\<^sup>T \\<cdot> r\\<^sup>T) \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T \\<le> x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T +\n    x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "using 2 sup.mono"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T \\<le> x\\<^sup>\\<star>\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>\\<star>\n  \\<lbrakk>?c \\<le> ?a; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c + ?d \\<le> ?a + ?b\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T +\n    x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T +\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> - r\\<^sup>T +\n  x\\<^sup>T ; r ; x\\<^sup>T \\<cdot> r\\<^sup>T\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma backward_finite_path_connected:\n  assumes \"backward_finite_path_root r x\"\n    shows \"connected x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. connected x", "from assms"], ["proof (chain)\npicking this:\n  backward_finite_path_root r x", "obtain r where 1: \"backward_finite_path_root r x\""], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        backward_finite_path_root r x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  backward_finite_path_root r x\n\ngoal (1 subgoal):\n 1. connected x", "have \"x\\<^sup>T;(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) = x\\<^sup>T;(1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n  x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n  x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. connected x", "have \"... = x\\<^sup>T;x\\<^sup>+ + x\\<^sup>T\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+ =\n    x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+", "using calculation distrib_left star_star_plus"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n  x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+\n  ?a ; (?b + ?c) = ?a ; ?b + ?a ; ?c\n  ?x\\<^sup>\\<star> + ?y\\<^sup>\\<star> = ?x\\<^sup>+ + ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+ =\n    x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+ =\n  x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; (1' + x\\<^sup>+) + x\\<^sup>T\\<^sup>+ =\n  x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. connected x", "have \"... \\<le> 1';x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+\n    \\<le> 1' ; x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+", "using 1"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+\n    \\<le> 1' ; x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+", "by (metis add_iso comp_assoc is_p_fun_def mult_isor backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+\n  \\<le> 1' ; x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; x\\<^sup>+ + x\\<^sup>T\\<^sup>+\n  \\<le> 1' ; x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. connected x", "have \"... \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1' ; x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "using join_isol"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z + ?x \\<le> ?z + ?y\n\ngoal (1 subgoal):\n 1. 1' ; x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  1' ; x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>+\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. connected x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "have \"x\\<^sup>T;r;x\\<^sup>T + x\\<^sup>T;(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T +\n    x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "using 1 backward_finite_path_connected_aux"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n  backward_finite_path_root r x\n  backward_finite_path_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>T ; ?r ; ?x\\<^sup>T\n  \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r ; x\\<^sup>T +\n    x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T ; r ; x\\<^sup>T +\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. connected x", "hence \"x\\<^sup>T\\<^sup>\\<star>;x\\<^sup>T;r;x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r ; x\\<^sup>T +\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "using star_inductl comp_assoc"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r ; x\\<^sup>T +\n  x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n  ?z + ?x ; ?y \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> ; ?z \\<le> ?y\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; r ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; r ; x\\<^sup>T\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. connected x", "hence \"x\\<^sup>T;1;x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; r ; x\\<^sup>T\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "using 1 backward_finite_path_root_def connected_root_iff3 star_slide_var"], ["proof (prove)\nusing this:\n  x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; r ; x\\<^sup>T\n  \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n  backward_finite_path_root r x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  ?x\\<^sup>\\<star> ; ?x = ?x\\<^sup>+\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x\\<^sup>T\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. connected x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; 1 ; x\\<^sup>T \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. connected x", "by (metis (mono_tags, lifting) sup.commute comp_assoc conv_add conv_contrav conv_invol conv_iso\n              conv_one star_conv)"], ["proof (state)\nthis:\n  connected x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma backward_finite_path_root_path:\n  assumes \"backward_finite_path_root r x\"\n    shows \"path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path x", "using assms path_def backward_finite_path_connected backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n  backward_finite_path_root ?r ?x \\<Longrightarrow> connected ?x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. path x", "by blast"], ["", "lemma backward_finite_path_root_path_root:\n  assumes \"backward_finite_path_root r x\"\n    shows \"path_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_root r x", "using assms backward_finite_path_root_def le_supI1 star_star_plus path_root_def"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  ?x \\<le> ?a \\<Longrightarrow> ?x \\<le> ?a + ?b\n  ?x\\<^sup>\\<star> + ?y\\<^sup>\\<star> = ?x\\<^sup>+ + ?y\\<^sup>\\<star>\n  path_root ?r ?x \\<equiv>\n  ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star> \\<and>\n  is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. path_root r x", "by fastforce"], ["", "lemma zero_backward_terminating_path_root:\n  assumes \"point r\"\n    shows \"backward_terminating_path_root r 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path_root r 0", "by (simp add: assms is_inj_def is_p_fun_def backward_finite_path_root_def)"], ["", "lemma backward_finite_path_root_move_root:\n  assumes \"backward_finite_path_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"backward_finite_path_root q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_finite_path_root q x", "using assms connected_root_move_root backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  point q\n  q \\<le> x\\<^sup>\\<star> ; r\n  \\<lbrakk>connected_root ?r ?x; ?q \\<le> ?x\\<^sup>\\<star> ; ?r\\<rbrakk>\n  \\<Longrightarrow> connected_root ?q ?x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. backward_finite_path_root q x", "by blast"], ["", "text \\<open>Cycle\\<close>"], ["", "lemma non_empty_cycle_root_var_axioms_1:\n  \"non_empty_cycle_root r x \\<longleftrightarrow> x\\<^sup>T;1 \\<le> x\\<^sup>T\\<^sup>+;r \\<and> is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x =\n    (x\\<^sup>T ; 1 \\<le> x\\<^sup>T\\<^sup>+ ; r \\<and>\n     is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>T ; 1)", "using connected_root_iff2 backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 \\<le> ?x\\<^sup>T\\<^sup>+ ; ?r)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x =\n    (x\\<^sup>T ; 1 \\<le> x\\<^sup>T\\<^sup>+ ; r \\<and>\n     is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>T ; 1)", "by blast"], ["", "lemma non_empty_cycle_root_loop:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"r \\<le> x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>T\\<^sup>+ ; r", "using assms connected_root_iff3 backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>T\\<^sup>+ ; r", "by fastforce"], ["", "lemma cycle_root_end_empty:\n  assumes \"terminating_path_root_end r x e\"\n      and \"many_strongly_connected x\"\n    shows \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "by (metis assms has_root_contra point_swap backward_finite_path_root_def\n          backward_finite_path_root_move_root star_conv)"], ["", "lemma cycle_root_end_empty_var:\n  assumes \"terminating_path_root_end r x e\"\n      and \"x \\<noteq> 0\"\n    shows \"\\<not> many_strongly_connected x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> many_strongly_connected x", "using assms cycle_root_end_empty"], ["proof (prove)\nusing this:\n  terminating_path_root_end r x e\n  x \\<noteq> 0\n  \\<lbrakk>terminating_path_root_end ?r ?x ?e;\n   many_strongly_connected ?x\\<rbrakk>\n  \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> many_strongly_connected x", "by blast"], ["", "text \\<open>Terminating path\\<close>"], ["", "lemma terminating_path_root_end_connected:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"x;1 \\<le> x\\<^sup>+;e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"x;1 \\<le> x;x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x ; x\\<^sup>T ; 1", "by (metis comp_assoc inf_top.left_neutral modular_var_2)"], ["proof (state)\nthis:\n  x ; 1 \\<le> x ; x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "also"], ["proof (state)\nthis:\n  x ; 1 \\<le> x ; x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"... = x;x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; 1 = x ; x\\<^sup>T\\<^sup>+ ; r", "using assms backward_finite_path_root_def connected_root_iff3 comp_assoc"], ["proof (prove)\nusing this:\n  terminating_path_root_end r x e\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; 1 = x ; x\\<^sup>T\\<^sup>+ ; r", "by fastforce"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; 1 = x ; x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "also"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; 1 = x ; x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"... \\<le> x;x\\<^sup>T\\<^sup>+;x\\<^sup>\\<star>;e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T\\<^sup>+ ; r\n    \\<le> x ; x\\<^sup>T\\<^sup>+ ; x\\<^sup>\\<star> ; e", "by (simp add: assms comp_assoc mult_isol)"], ["proof (state)\nthis:\n  x ; x\\<^sup>T\\<^sup>+ ; r\n  \\<le> x ; x\\<^sup>T\\<^sup>+ ; x\\<^sup>\\<star> ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "also"], ["proof (state)\nthis:\n  x ; x\\<^sup>T\\<^sup>+ ; r\n  \\<le> x ; x\\<^sup>T\\<^sup>+ ; x\\<^sup>\\<star> ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"... = x;x\\<^sup>T;(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T\\<^sup>+ ; x\\<^sup>\\<star> ; e =\n    x ; x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; e", "using assms cancel_separate_p_fun_converse comp_assoc backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  terminating_path_root_end r x e\n  is_p_fun ?x \\<Longrightarrow>\n  ?x\\<^sup>T\\<^sup>\\<star> ; ?x\\<^sup>\\<star> =\n  ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T\\<^sup>+ ; x\\<^sup>\\<star> ; e =\n    x ; x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; e", "by fastforce"], ["proof (state)\nthis:\n  x ; x\\<^sup>T\\<^sup>+ ; x\\<^sup>\\<star> ; e =\n  x ; x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "also"], ["proof (state)\nthis:\n  x ; x\\<^sup>T\\<^sup>+ ; x\\<^sup>\\<star> ; e =\n  x ; x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"... = x;x\\<^sup>T;(x\\<^sup>+ + x\\<^sup>T\\<^sup>\\<star>);e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; e =\n    x ; x\\<^sup>T ; (x\\<^sup>+ + x\\<^sup>T\\<^sup>\\<star>) ; e", "by (simp add: star_star_plus)"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; e =\n  x ; x\\<^sup>T ; (x\\<^sup>+ + x\\<^sup>T\\<^sup>\\<star>) ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "also"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; e =\n  x ; x\\<^sup>T ; (x\\<^sup>+ + x\\<^sup>T\\<^sup>\\<star>) ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"... = x;x\\<^sup>T;x\\<^sup>+;e + x;x\\<^sup>T\\<^sup>+;e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; (x\\<^sup>+ + x\\<^sup>T\\<^sup>\\<star>) ; e =\n    x ; x\\<^sup>T ; x\\<^sup>+ ; e + x ; x\\<^sup>T\\<^sup>+ ; e", "by (simp add: comp_assoc distrib_left)"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; (x\\<^sup>+ + x\\<^sup>T\\<^sup>\\<star>) ; e =\n  x ; x\\<^sup>T ; x\\<^sup>+ ; e + x ; x\\<^sup>T\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "also"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; (x\\<^sup>+ + x\\<^sup>T\\<^sup>\\<star>) ; e =\n  x ; x\\<^sup>T ; x\\<^sup>+ ; e + x ; x\\<^sup>T\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"... = x;x\\<^sup>T;x\\<^sup>+;e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; x\\<^sup>+ ; e + x ; x\\<^sup>T\\<^sup>+ ; e =\n    x ; x\\<^sup>T ; x\\<^sup>+ ; e", "by (simp add: assms comp_assoc independence1)"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; x\\<^sup>+ ; e + x ; x\\<^sup>T\\<^sup>+ ; e =\n  x ; x\\<^sup>T ; x\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "also"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; x\\<^sup>+ ; e + x ; x\\<^sup>T\\<^sup>+ ; e =\n  x ; x\\<^sup>T ; x\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "have \"... \\<le> x\\<^sup>+;e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; x\\<^sup>+ ; e \\<le> x\\<^sup>+ ; e", "by (metis assms annil independence1 is_inj_def mult_isor mult_oner backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; x\\<^sup>+ ; e \\<le> x\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "finally"], ["proof (chain)\npicking this:\n  x ; 1 \\<le> x\\<^sup>+ ; e", "show ?thesis"], ["proof (prove)\nusing this:\n  x ; 1 \\<le> x\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; e", "."], ["proof (state)\nthis:\n  x ; 1 \\<le> x\\<^sup>+ ; e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminating_path_root_end_forward_finite:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"backward_finite_path_root e (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_finite_path_root e (x\\<^sup>T)", "using assms terminating_path_root_end_connected inj_p_fun connected_root_iff2\n      backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  terminating_path_root_end r x e\n  terminating_path_root_end ?r ?x ?e \\<Longrightarrow>\n  ?x ; 1 \\<le> ?x\\<^sup>+ ; ?e\n  is_inj ?x = is_p_fun (?x\\<^sup>T)\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 \\<le> ?x\\<^sup>T\\<^sup>+ ; ?r)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. backward_finite_path_root e (x\\<^sup>T)", "by force"], ["", "end"], ["", "(* relation_algebra_rtc *)"], ["", "subsection \\<open>Consequences with the Tarski rule\\<close>"], ["", "context relation_algebra_rtc_tarski\nbegin"], ["", "text \\<open>Some (more) results about points\\<close>"], ["", "lemma point_reachable_converse:\n  assumes \"is_vector v\"\n      and \"v \\<noteq> 0\"\n      and \"point r\"\n      and \"v \\<le> x\\<^sup>T\\<^sup>+;r\"\n    shows \"r \\<le> x\\<^sup>+;v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "have \"v\\<^sup>T;v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sup>T ; v \\<noteq> 0", "by (metis assms(2) inf.idem inf_bot_right mult_1_right schroeder_1)"], ["proof (state)\nthis:\n  v\\<^sup>T ; v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "hence \"1;v\\<^sup>T;v = 1\""], ["proof (prove)\nusing this:\n  v\\<^sup>T ; v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 ; v\\<^sup>T ; v = 1", "using assms(1) is_vector_def mult_assoc tarski"], ["proof (prove)\nusing this:\n  v\\<^sup>T ; v \\<noteq> 0\n  is_vector v\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  ?a ; ?b ; ?c = ?a ; (?b ; ?c)\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n\ngoal (1 subgoal):\n 1. 1 ; v\\<^sup>T ; v = 1", "by force"], ["proof (state)\nthis:\n  1 ; v\\<^sup>T ; v = 1\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "hence 1: \"r = r;v\\<^sup>T;v\""], ["proof (prove)\nusing this:\n  1 ; v\\<^sup>T ; v = 1\n\ngoal (1 subgoal):\n 1. r = r ; v\\<^sup>T ; v", "by (metis assms(3) is_vector_def mult_assoc point_def)"], ["proof (state)\nthis:\n  r = r ; v\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "have \"v;r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ; r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+", "using assms(3,4) point_def ss423bij"], ["proof (prove)\nusing this:\n  point r\n  v \\<le> x\\<^sup>T\\<^sup>+ ; r\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  bijective ?x \\<Longrightarrow>\n  (?y ; ?x\\<^sup>T \\<le> ?z) = (?y \\<le> ?z ; ?x)\n\ngoal (1 subgoal):\n 1. v ; r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  v ; r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "hence \"r;v\\<^sup>T \\<le> x\\<^sup>+\""], ["proof (prove)\nusing this:\n  v ; r\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+\n\ngoal (1 subgoal):\n 1. r ; v\\<^sup>T \\<le> x\\<^sup>+", "by (metis conv_contrav conv_invol conv_iso star_conv star_slide_var)"], ["proof (state)\nthis:\n  r ; v\\<^sup>T \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "thus ?thesis"], ["proof (prove)\nusing this:\n  r ; v\\<^sup>T \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "using 1"], ["proof (prove)\nusing this:\n  r ; v\\<^sup>T \\<le> x\\<^sup>+\n  r = r ; v\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; v", "by (metis mult_isor)"], ["proof (state)\nthis:\n  r \\<le> x\\<^sup>+ ; v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Roots\\<close>"], ["", "lemma root_in_start_points:\n  assumes \"connected_root r x\"\n      and \"is_vector r\"\n      and \"x \\<noteq> 0\"\n      and \"x;r = 0\"\n    shows \"r \\<le> start_points x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "have \"r = r;x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = r ; x ; 1", "by (metis assms(2,3) comp_assoc is_vector_def tarski)"], ["proof (state)\nthis:\n  r = r ; x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "also"], ["proof (state)\nthis:\n  r = r ; x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "have \"... \\<le> x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; x ; 1 \\<le> x ; 1", "by (metis assms(1) comp_assoc one_idem_mult phl_seq top_greatest)"], ["proof (state)\nthis:\n  r ; x ; 1 \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "finally"], ["proof (chain)\npicking this:\n  r \\<le> x ; 1", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "using assms(4) comp_res compl_bot_eq compl_le_swap1 inf.boundedI"], ["proof (prove)\nusing this:\n  r \\<le> x ; 1\n  x ; r = 0\n  ?x\\<^sup>T ; - (?x ; ?y) \\<le> - ?y\n  - 0 = 1\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n  \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<cdot> ?c\n\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "by blast"], ["proof (state)\nthis:\n  r \\<le> start_points x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_equals_start_points:\n  assumes \"backward_terminating_path_root r x\"\n      and \"x \\<noteq> 0\"\n    shows \"r = start_points x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = start_points x", "using assms antisym point_def backward_finite_path_root_def start_points_in_root root_in_start_points"], ["proof (prove)\nusing this:\n  backward_terminating_path_root r x\n  x \\<noteq> 0\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  backward_finite_path_root ?r ?x \\<Longrightarrow> start_points ?x \\<le> ?r\n  \\<lbrakk>connected_root ?r ?x; is_vector ?r; ?x \\<noteq> 0;\n   ?x ; ?r = 0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<le> start_points ?x\n\ngoal (1 subgoal):\n 1. r = start_points x", "by fastforce"], ["", "lemma root_equals_end_points:\n  assumes \"backward_terminating_path_root r (x\\<^sup>T)\"\n      and \"x \\<noteq> 0\"\n    shows \"r = end_points x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = end_points x", "by (metis assms conv_invol step_has_target ss_p18 root_equals_start_points)"], ["", "lemma root_in_edge_sources:\n  assumes \"connected_root r x\"\n      and \"x \\<noteq> 0\"\n      and \"is_vector r\"\n    shows \"r \\<le> x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "have \"r;1;x;1 \\<le> x\\<^sup>+;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; 1 ; x ; 1 \\<le> x\\<^sup>+ ; 1", "using assms(1,3) is_vector_def mult_isor"], ["proof (prove)\nusing this:\n  connected_root r x\n  is_vector r\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n\ngoal (1 subgoal):\n 1. r ; 1 ; x ; 1 \\<le> x\\<^sup>+ ; 1", "by fastforce"], ["proof (state)\nthis:\n  r ; 1 ; x ; 1 \\<le> x\\<^sup>+ ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  r ; 1 ; x ; 1 \\<le> x\\<^sup>+ ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "by (metis assms(2) comp_assoc conway.dagger_unfoldl_distr dual_order.trans maddux_20 sup.commute\n              sup_absorb2 tarski top_greatest)"], ["proof (state)\nthis:\n  r \\<le> x ; 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Rooted Paths\\<close>"], ["", "lemma non_empty_path_root_iff_aux:\n  assumes \"path_root r x\"\n      and \"x \\<noteq> 0\"\n    shows \"r \\<le> (x + x\\<^sup>T);1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"(r;x \\<cdot> 1');1 = (x\\<^sup>T;r\\<^sup>T \\<cdot> 1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r ; x \\<cdot> 1') ; 1 = (x\\<^sup>T ; r\\<^sup>T \\<cdot> 1') ; 1", "by (metis conv_contrav conv_e conv_times inf.cobounded2 is_test_def test_eq_conv)"], ["proof (state)\nthis:\n  (r ; x \\<cdot> 1') ; 1 = (x\\<^sup>T ; r\\<^sup>T \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  (r ; x \\<cdot> 1') ; 1 = (x\\<^sup>T ; r\\<^sup>T \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... \\<le> x\\<^sup>T;r\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T ; r\\<^sup>T \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; r\\<^sup>T ; 1", "using mult_subdistr"], ["proof (prove)\nusing this:\n  (?x \\<cdot> ?y) ; ?z \\<le> ?x ; ?z\n\ngoal (1 subgoal):\n 1. (x\\<^sup>T ; r\\<^sup>T \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; r\\<^sup>T ; 1", "by blast"], ["proof (state)\nthis:\n  (x\\<^sup>T ; r\\<^sup>T \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; r\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  (x\\<^sup>T ; r\\<^sup>T \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; r\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r\\<^sup>T ; 1 \\<le> x\\<^sup>T ; 1", "by (metis mult_assoc mult_double_iso one_idem_mult top_greatest)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r\\<^sup>T ; 1 \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "finally"], ["proof (chain)\npicking this:\n  (r ; x \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "have 1: \"(r;x \\<cdot> 1');1 \\<le> x\\<^sup>T;1\""], ["proof (prove)\nusing this:\n  (r ; x \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. (r ; x \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "."], ["proof (state)\nthis:\n  (r ; x \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"r \\<le> r;1;x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> r ; 1 ; x ; 1", "using assms(2) comp_assoc maddux_20 tarski"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?x \\<le> ?x ; 1\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n\ngoal (1 subgoal):\n 1. r \\<le> r ; 1 ; x ; 1", "by fastforce"], ["proof (state)\nthis:\n  r \\<le> r ; 1 ; x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  r \\<le> r ; 1 ; x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... = r;x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; 1 ; x ; 1 = r ; x ; 1", "using assms(1) path_root_def point_def is_vector_def"], ["proof (prove)\nusing this:\n  path_root r x\n  path_root ?r ?x \\<equiv>\n  ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star> \\<and>\n  is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n\ngoal (1 subgoal):\n 1. r ; 1 ; x ; 1 = r ; x ; 1", "by simp"], ["proof (state)\nthis:\n  r ; 1 ; x ; 1 = r ; x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  r ; 1 ; x ; 1 = r ; x ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... = (r;x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>));1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; x ; 1 =\n    (r ; x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)) ; 1", "using assms(1) path_root_def"], ["proof (prove)\nusing this:\n  path_root r x\n  path_root ?r ?x \\<equiv>\n  ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star> \\<and>\n  is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. r ; x ; 1 =\n    (r ; x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)) ; 1", "by (simp add: inf.absorb_iff1)"], ["proof (state)\nthis:\n  r ; x ; 1 =\n  (r ; x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)) ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  r ; x ; 1 =\n  (r ; x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)) ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... = (r;x \\<cdot> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + 1'));1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r ; x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)) ; 1 =\n    (r ; x \\<cdot> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + 1')) ; 1", "by (metis star_star_plus star_unfoldl_eq sup_commute sup_left_commute)"], ["proof (state)\nthis:\n  (r ; x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)) ; 1 =\n  (r ; x \\<cdot> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + 1')) ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  (r ; x \\<cdot> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>)) ; 1 =\n  (r ; x \\<cdot> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + 1')) ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... \\<le> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + (r;x \\<cdot> 1'));1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r ; x \\<cdot> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + 1')) ; 1\n    \\<le> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + r ; x \\<cdot> 1') ; 1", "by (metis inf_le2 inf_sup_distrib1 mult_isor order_refl sup_mono)"], ["proof (state)\nthis:\n  (r ; x \\<cdot> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + 1')) ; 1\n  \\<le> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + r ; x \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  (r ; x \\<cdot> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + 1')) ; 1\n  \\<le> (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + r ; x \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... \\<le> x;1 + x\\<^sup>T;1 + (r;x \\<cdot> 1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + r ; x \\<cdot> 1') ; 1\n    \\<le> x ; 1 + x\\<^sup>T ; 1 + (r ; x \\<cdot> 1') ; 1", "by (simp add: plus_top)"], ["proof (state)\nthis:\n  (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + r ; x \\<cdot> 1') ; 1\n  \\<le> x ; 1 + x\\<^sup>T ; 1 + (r ; x \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "also"], ["proof (state)\nthis:\n  (x\\<^sup>+ + x\\<^sup>T\\<^sup>+ + r ; x \\<cdot> 1') ; 1\n  \\<le> x ; 1 + x\\<^sup>T ; 1 + (r ; x \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "have \"... = x;1 + x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 + x\\<^sup>T ; 1 + (r ; x \\<cdot> 1') ; 1 = x ; 1 + x\\<^sup>T ; 1", "using 1 sup.coboundedI2 sup.order_iff"], ["proof (prove)\nusing this:\n  (r ; x \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1\n  ?c \\<le> ?b \\<Longrightarrow> ?c \\<le> ?a + ?b\n  (?b \\<le> ?a) = (?a = ?a + ?b)\n\ngoal (1 subgoal):\n 1. x ; 1 + x\\<^sup>T ; 1 + (r ; x \\<cdot> 1') ; 1 = x ; 1 + x\\<^sup>T ; 1", "by fastforce"], ["proof (state)\nthis:\n  x ; 1 + x\\<^sup>T ; 1 + (r ; x \\<cdot> 1') ; 1 = x ; 1 + x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "finally"], ["proof (chain)\npicking this:\n  r \\<le> x ; 1 + x\\<^sup>T ; 1", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<le> x ; 1 + x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r \\<le> (x + x\\<^sup>T) ; 1", "by simp"], ["proof (state)\nthis:\n  r \\<le> (x + x\\<^sup>T) ; 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Backwards terminating and backwards finite\\<close>"], ["", "lemma backward_terminating_path_root_2:\n  assumes \"backward_terminating_path_root r x\"\n    shows \"backward_terminating x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating x", "using assms backward_terminating_iff2 path_def backward_terminating_path_root_aux\n      backward_finite_path_connected backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  backward_terminating_path_root r x\n  path ?x \\<Longrightarrow>\n  backward_terminating ?x =\n  (?x \\<le> ?x\\<^sup>T\\<^sup>\\<star> ; - (?x\\<^sup>T ; 1))\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n  backward_terminating_path_root ?r ?x \\<Longrightarrow>\n  ?x \\<le> ?x\\<^sup>T\\<^sup>\\<star> ; - (?x\\<^sup>T ; 1)\n  backward_finite_path_root ?r ?x \\<Longrightarrow> connected ?x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. backward_terminating x", "by blast"], ["", "lemma backward_terminating_path_root:\n  assumes \"backward_terminating_path_root r x\"\n    shows \"backward_terminating_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path x", "using assms backward_finite_path_root_path backward_terminating_path_root_2"], ["proof (prove)\nusing this:\n  backward_terminating_path_root r x\n  backward_finite_path_root ?r ?x \\<Longrightarrow> path ?x\n  backward_terminating_path_root ?r ?x \\<Longrightarrow>\n  backward_terminating ?x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x", "by fastforce"], ["", "text \\<open>(Non-empty) Cycle\\<close>"], ["", "lemma cycle_iff:\n  assumes \"point r\"\n    shows \"x;r \\<noteq> 0 \\<longleftrightarrow> r \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; r \\<noteq> 0) = (r \\<le> x\\<^sup>T ; 1)", "by (simp add: assms no_end_point_char_converse)"], ["", "lemma non_empty_cycle_root_iff:\n  assumes \"connected_root r x\"\n      and \"point r\"\n    shows \"x;r \\<noteq> 0 \\<longleftrightarrow> r \\<le> x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; r \\<noteq> 0) = (r \\<le> x\\<^sup>T\\<^sup>+ ; r)", "using assms connected_root_iff3 cycle_iff"], ["proof (prove)\nusing this:\n  connected_root r x\n  point r\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  point ?r \\<Longrightarrow>\n  (?x ; ?r \\<noteq> 0) = (?r \\<le> ?x\\<^sup>T ; 1)\n\ngoal (1 subgoal):\n 1. (x ; r \\<noteq> 0) = (r \\<le> x\\<^sup>T\\<^sup>+ ; r)", "by simp"], ["", "lemma backward_finite_path_root_terminating_or_cycle:\n  \"backward_finite_path_root r x \\<longleftrightarrow> backward_terminating_path_root r x \\<or> non_empty_cycle_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_finite_path_root r x =\n    (backward_terminating_path_root r x \\<or> non_empty_cycle_root r x)", "using cycle_iff backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  point ?r \\<Longrightarrow>\n  (?x ; ?r \\<noteq> 0) = (?r \\<le> ?x\\<^sup>T ; 1)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. backward_finite_path_root r x =\n    (backward_terminating_path_root r x \\<or> non_empty_cycle_root r x)", "by blast"], ["", "lemma non_empty_cycle_root_msc:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"many_strongly_connected x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. many_strongly_connected x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. many_strongly_connected x", "let ?p = \"x\\<^sup>T;r\""], ["proof (state)\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have 1: \"is_point ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_point (x\\<^sup>T ; r)", "unfolding is_point_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector (x\\<^sup>T ; r) \\<and>\n    is_inj (x\\<^sup>T ; r) \\<and> x\\<^sup>T ; r \\<noteq> 0", "using conjI assms is_vector_def mult_assoc point_def inj_compose p_fun_inj\n      cycle_iff backward_finite_path_root_def root_cycle_converse"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P; ?Q\\<rbrakk> \\<Longrightarrow> ?P \\<and> ?Q\n  non_empty_cycle_root r x\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  ?a ; ?b ; ?c = ?a ; (?b ; ?c)\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  \\<lbrakk>is_inj ?x; is_inj ?y\\<rbrakk> \\<Longrightarrow> is_inj (?x ; ?y)\n  is_p_fun ?x = is_inj (?x\\<^sup>T)\n  point ?r \\<Longrightarrow>\n  (?x ; ?r \\<noteq> 0) = (?r \\<le> ?x\\<^sup>T ; 1)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  \\<lbrakk>connected_root ?r ?x; point ?r; ?x ; ?r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?x\\<^sup>T ; ?r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_vector (x\\<^sup>T ; r) \\<and>\n    is_inj (x\\<^sup>T ; r) \\<and> x\\<^sup>T ; r \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  is_point (x\\<^sup>T ; r)\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"?p \\<le> x\\<^sup>T\\<^sup>+;?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<le> x\\<^sup>T\\<^sup>+ ; (x\\<^sup>T ; r)", "by (metis assms comp_assoc mult_isol star_slide_var non_empty_cycle_root_loop)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r \\<le> x\\<^sup>T\\<^sup>+ ; (x\\<^sup>T ; r)\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "hence \"?p \\<le> x\\<^sup>+;?p\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r \\<le> x\\<^sup>T\\<^sup>+ ; (x\\<^sup>T ; r)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<le> x\\<^sup>+ ; (x\\<^sup>T ; r)", "using 1 bot_least point_def point_is_point point_reachable_converse"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r \\<le> x\\<^sup>T\\<^sup>+ ; (x\\<^sup>T ; r)\n  is_point (x\\<^sup>T ; r)\n  0 \\<le> ?a\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  point ?x = is_point ?x\n  \\<lbrakk>is_vector ?v; ?v \\<noteq> 0; point ?r;\n   ?v \\<le> ?x\\<^sup>T\\<^sup>+ ; ?r\\<rbrakk>\n  \\<Longrightarrow> ?r \\<le> ?x\\<^sup>+ ; ?v\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<le> x\\<^sup>+ ; (x\\<^sup>T ; r)", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>T ; r \\<le> x\\<^sup>+ ; (x\\<^sup>T ; r)\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; r \\<le> x\\<^sup>+ ; (x\\<^sup>T ; r)\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... = x\\<^sup>\\<star>;(x;x\\<^sup>T);r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; (x\\<^sup>T ; r) = x\\<^sup>\\<star> ; (x ; x\\<^sup>T) ; r", "by (metis comp_assoc star_slide_var)"], ["proof (state)\nthis:\n  x\\<^sup>+ ; (x\\<^sup>T ; r) = x\\<^sup>\\<star> ; (x ; x\\<^sup>T) ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>+ ; (x\\<^sup>T ; r) = x\\<^sup>\\<star> ; (x ; x\\<^sup>T) ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... \\<le> x\\<^sup>\\<star>;1';r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x ; x\\<^sup>T) ; r \\<le> x\\<^sup>\\<star> ; 1' ; r", "using assms is_inj_def mult_double_iso backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  is_inj ?x \\<equiv> ?x ; ?x\\<^sup>T \\<le> 1'\n  ?x \\<le> ?y \\<Longrightarrow> ?w ; ?x ; ?z \\<le> ?w ; ?y ; ?z\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x ; x\\<^sup>T) ; r \\<le> x\\<^sup>\\<star> ; 1' ; r", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; (x ; x\\<^sup>T) ; r \\<le> x\\<^sup>\\<star> ; 1' ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T ; r \\<le> x\\<^sup>\\<star> ; 1' ; r", "have 2: \"?p \\<le> x\\<^sup>\\<star>;r\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r \\<le> x\\<^sup>\\<star> ; 1' ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r \\<le> x\\<^sup>\\<star> ; r", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T ; r \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"x\\<^sup>T;x\\<^sup>\\<star>;r = ?p + x\\<^sup>T;x\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; x\\<^sup>\\<star> ; r =\n    x\\<^sup>T ; r + x\\<^sup>T ; x\\<^sup>+ ; r", "by (metis conway.dagger_unfoldl_distr distrib_left mult_assoc)"], ["proof (state)\nthis:\n  x\\<^sup>T ; x\\<^sup>\\<star> ; r =\n  x\\<^sup>T ; r + x\\<^sup>T ; x\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; x\\<^sup>\\<star> ; r =\n  x\\<^sup>T ; r + x\\<^sup>T ; x\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... \\<le> ?p + 1';x\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r + x\\<^sup>T ; x\\<^sup>+ ; r\n    \\<le> x\\<^sup>T ; r + 1' ; x\\<^sup>\\<star> ; r", "by (metis assms is_p_fun_def join_isol mult_assoc mult_isor backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r + x\\<^sup>T ; x\\<^sup>+ ; r\n  \\<le> x\\<^sup>T ; r + 1' ; x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; r + x\\<^sup>T ; x\\<^sup>+ ; r\n  \\<le> x\\<^sup>T ; r + 1' ; x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... = x\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r + 1' ; x\\<^sup>\\<star> ; r = x\\<^sup>\\<star> ; r", "using 2"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; r \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; r + 1' ; x\\<^sup>\\<star> ; r = x\\<^sup>\\<star> ; r", "by (simp add: sup_absorb2)"], ["proof (state)\nthis:\n  x\\<^sup>T ; r + 1' ; x\\<^sup>\\<star> ; r = x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T ; x\\<^sup>\\<star> ; r \\<le> x\\<^sup>\\<star> ; r", "have 3: \"x\\<^sup>T\\<^sup>\\<star>;r \\<le> x\\<^sup>\\<star>;r\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; x\\<^sup>\\<star> ; r \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>\\<star> ; r", "by (metis star_inductl comp_assoc conway.dagger_unfoldl_distr le_supI order_prop)"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"x\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+ ; r", "by (metis assms maddux_20 connected_root_iff3 backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... \\<le> x\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r", "using 3"], ["proof (prove)\nusing this:\n  x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r", "by (metis assms conway.dagger_unfoldl_distr sup_absorb2 non_empty_cycle_root_loop)"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r", "have 4: \"x\\<^sup>T \\<le> x\\<^sup>\\<star>;r\""], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r", "."], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"x\\<^sup>T \\<le> x\\<^sup>T;x;x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>T ; x ; x\\<^sup>T", "by (metis conv_invol x_leq_triple_x)"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>T ; x ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>T ; x ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... \\<le> 1;x;x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; x ; x\\<^sup>T \\<le> 1 ; x ; x\\<^sup>T", "by (simp add: mult_isor)"], ["proof (state)\nthis:\n  x\\<^sup>T ; x ; x\\<^sup>T \\<le> 1 ; x ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; x ; x\\<^sup>T \\<le> 1 ; x ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... = r\\<^sup>T;x\\<^sup>+;x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ; x ; x\\<^sup>T = r\\<^sup>T ; x\\<^sup>+ ; x\\<^sup>T", "using assms connected_root_iff4 backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (1 ; ?x = ?r\\<^sup>T ; ?x\\<^sup>+)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. 1 ; x ; x\\<^sup>T = r\\<^sup>T ; x\\<^sup>+ ; x\\<^sup>T", "by fastforce"], ["proof (state)\nthis:\n  1 ; x ; x\\<^sup>T = r\\<^sup>T ; x\\<^sup>+ ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  1 ; x ; x\\<^sup>T = r\\<^sup>T ; x\\<^sup>+ ; x\\<^sup>T\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... \\<le> r\\<^sup>T;x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T ; x\\<^sup>+ ; x\\<^sup>T \\<le> r\\<^sup>T ; x\\<^sup>\\<star>", "by (metis assms is_inj_def mult_1_right mult_assoc mult_isol backward_finite_path_root_def\n              star_slide_var)"], ["proof (state)\nthis:\n  r\\<^sup>T ; x\\<^sup>+ ; x\\<^sup>T \\<le> r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T \\<le> r\\<^sup>T ; x\\<^sup>\\<star>", "have \"x\\<^sup>T \\<le> x\\<^sup>\\<star>;r \\<cdot> r\\<^sup>T;x\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r \\<cdot> r\\<^sup>T ; x\\<^sup>\\<star>", "using 4"], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> r\\<^sup>T ; x\\<^sup>\\<star>\n  x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r \\<cdot> r\\<^sup>T ; x\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r \\<cdot> r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>\\<star> ; r \\<cdot> r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... = x\\<^sup>\\<star>;r \\<cdot> 1;r\\<^sup>T;x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r \\<cdot> r\\<^sup>T ; x\\<^sup>\\<star> =\n    x\\<^sup>\\<star> ; r \\<cdot> 1 ; r\\<^sup>T ; x\\<^sup>\\<star>", "by (metis assms conv_contrav conv_one is_vector_def point_def backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; r \\<cdot> r\\<^sup>T ; x\\<^sup>\\<star> =\n  x\\<^sup>\\<star> ; r \\<cdot> 1 ; r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; r \\<cdot> r\\<^sup>T ; x\\<^sup>\\<star> =\n  x\\<^sup>\\<star> ; r \\<cdot> 1 ; r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... = (x\\<^sup>\\<star>;r \\<cdot> 1);r\\<^sup>T;x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r \\<cdot> 1 ; r\\<^sup>T ; x\\<^sup>\\<star> =\n    (x\\<^sup>\\<star> ; r \\<cdot> 1) ; r\\<^sup>T ; x\\<^sup>\\<star>", "by (metis (no_types, lifting) assms is_vector_def mult_assoc point_def\n              backward_finite_path_root_def vector_1)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; r \\<cdot> 1 ; r\\<^sup>T ; x\\<^sup>\\<star> =\n  (x\\<^sup>\\<star> ; r \\<cdot> 1) ; r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; r \\<cdot> 1 ; r\\<^sup>T ; x\\<^sup>\\<star> =\n  (x\\<^sup>\\<star> ; r \\<cdot> 1) ; r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... = x\\<^sup>\\<star>;r;r\\<^sup>T;x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> ; r \\<cdot> 1) ; r\\<^sup>T ; x\\<^sup>\\<star> =\n    x\\<^sup>\\<star> ; r ; r\\<^sup>T ; x\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> ; r \\<cdot> 1) ; r\\<^sup>T ; x\\<^sup>\\<star> =\n  x\\<^sup>\\<star> ; r ; r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> ; r \\<cdot> 1) ; r\\<^sup>T ; x\\<^sup>\\<star> =\n  x\\<^sup>\\<star> ; r ; r\\<^sup>T ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... \\<le> x\\<^sup>\\<star>;x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r ; r\\<^sup>T ; x\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> ; x\\<^sup>\\<star>", "by (metis assms is_inj_def mult_1_right mult_assoc mult_isol mult_isor point_def\n              backward_finite_path_root_def)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; r ; r\\<^sup>T ; x\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; r ; r\\<^sup>T ; x\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> ; x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "have \"... \\<le> x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive (x\\<^sup>\\<star>)", "by simp"], ["proof (state)\nthis:\n  transitive (x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>T \\<le> x\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. many_strongly_connected x", "by (simp add: many_strongly_connected_iff_1)"], ["proof (state)\nthis:\n  many_strongly_connected x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_cycle_root_msc_cycle:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"cycle x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle x", "using assms backward_finite_path_root_path non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  backward_finite_path_root ?r ?x \\<Longrightarrow> path ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. cycle x", "by fastforce"], ["", "lemma non_empty_cycle_root_non_empty:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "using assms cycle_iff annil backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point ?r \\<Longrightarrow>\n  (?x ; ?r \\<noteq> 0) = (?r \\<le> ?x\\<^sup>T ; 1)\n  0 ; ?x = 0\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by blast"], ["", "lemma non_empty_cycle_root_rtc_symmetric:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r = x\\<^sup>T\\<^sup>\\<star> ; r", "using assms non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r = x\\<^sup>T\\<^sup>\\<star> ; r", "by fastforce"], ["", "lemma non_empty_cycle_root_point_exchange:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point p\"\n    shows \"r \\<le> x\\<^sup>\\<star>;p \\<longleftrightarrow> p \\<le> x\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<le> x\\<^sup>\\<star> ; p) = (p \\<le> x\\<^sup>\\<star> ; r)", "by (metis assms(1,2) inj_sur_semi_swap point_def non_empty_cycle_root_msc\n          backward_finite_path_root_def star_conv)"], ["", "lemma non_empty_cycle_root_rtc_tc:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r = x\\<^sup>+ ; r", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. x\\<^sup>\\<star> ; r \\<le> x\\<^sup>+ ; r\n 2. x\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r", "have \"r \\<le> x\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; r", "using assms many_strongly_connected_iff_7 non_empty_cycle_root_loop non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  many_strongly_connected ?x = (?x\\<^sup>T\\<^sup>+ = ?x\\<^sup>+)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?r \\<le> ?x\\<^sup>T\\<^sup>+ ; ?r\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; r", "by simp"], ["proof (state)\nthis:\n  r \\<le> x\\<^sup>+ ; r\n\ngoal (2 subgoals):\n 1. x\\<^sup>\\<star> ; r \\<le> x\\<^sup>+ ; r\n 2. x\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r", "thus \"x\\<^sup>\\<star>;r \\<le> x\\<^sup>+;r\""], ["proof (prove)\nusing this:\n  r \\<le> x\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r \\<le> x\\<^sup>+ ; r", "using sup_absorb2"], ["proof (prove)\nusing this:\n  r \\<le> x\\<^sup>+ ; r\n  ?x \\<le> ?y \\<Longrightarrow> ?x + ?y = ?y\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r \\<le> x\\<^sup>+ ; r", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; r \\<le> x\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r", "show \"x\\<^sup>+;r \\<le> x\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r", "by (simp add: mult_isor)"], ["proof (state)\nthis:\n  x\\<^sup>+ ; r \\<le> x\\<^sup>\\<star> ; r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_cycle_root_no_start_end_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x;1 = x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_start_end_points x", "using assms many_strongly_connected_implies_no_start_end_points non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  many_strongly_connected ?x \\<Longrightarrow> no_start_end_points ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. no_start_end_points x", "by blast"], ["", "lemma non_empty_cycle_root_move_root:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"non_empty_cycle_root q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_cycle_root q x", "by (metis assms cycle_iff dual_order.trans backward_finite_path_root_move_root start_points_in_root\n          root_equals_start_points non_empty_cycle_root_non_empty)"], ["", "lemma non_empty_cycle_root_loop_converse:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"r \\<le> x\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; r", "using assms less_eq_def non_empty_cycle_root_rtc_tc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  (?x \\<le> ?y) = (?x + ?y = ?y)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?r = ?x\\<^sup>+ ; ?r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>+ ; r", "by fastforce"], ["", "lemma non_empty_cycle_root_move_root_same_reachable:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>\\<star>;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r = x\\<^sup>\\<star> ; q", "by (metis assms many_strongly_connected_iff_7 connected_root_iff3 connected_root_move_root\n          backward_finite_path_root_def non_empty_cycle_root_msc non_empty_cycle_root_rtc_tc)"], ["", "lemma non_empty_cycle_root_move_root_same_reachable_2:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"x\\<^sup>\\<star>;r = x\\<^sup>T\\<^sup>\\<star>;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r = x\\<^sup>T\\<^sup>\\<star> ; q", "using assms non_empty_cycle_root_move_root_same_reachable non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point q\n  q \\<le> x\\<^sup>\\<star> ; r\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?q;\n   ?q \\<le> ?x\\<^sup>\\<star> ; ?r\\<rbrakk>\n  \\<Longrightarrow> ?x\\<^sup>\\<star> ; ?r = ?x\\<^sup>\\<star> ; ?q\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r = x\\<^sup>T\\<^sup>\\<star> ; q", "by simp"], ["", "lemma non_empty_cycle_root_move_root_msc:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>T\\<^sup>\\<star>;q = x\\<^sup>\\<star>;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; q = x\\<^sup>\\<star> ; q", "using assms non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; q = x\\<^sup>\\<star> ; q", "by simp"], ["", "lemma non_empty_cycle_root_move_root_rtc_tc:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"x\\<^sup>\\<star>;q = x\\<^sup>+;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; q = x\\<^sup>+ ; q", "using assms non_empty_cycle_root_move_root non_empty_cycle_root_rtc_tc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point q\n  q \\<le> x\\<^sup>\\<star> ; r\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?q;\n   ?q \\<le> ?x\\<^sup>\\<star> ; ?r\\<rbrakk>\n  \\<Longrightarrow> non_empty_cycle_root ?q ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?r = ?x\\<^sup>+ ; ?r\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; q = x\\<^sup>+ ; q", "by blast"], ["", "lemma non_empty_cycle_root_move_root_loop_converse:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"q \\<le> x\\<^sup>T\\<^sup>+;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<le> x\\<^sup>T\\<^sup>+ ; q", "using assms non_empty_cycle_root_loop non_empty_cycle_root_move_root"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point q\n  q \\<le> x\\<^sup>\\<star> ; r\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?r \\<le> ?x\\<^sup>T\\<^sup>+ ; ?r\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?q;\n   ?q \\<le> ?x\\<^sup>\\<star> ; ?r\\<rbrakk>\n  \\<Longrightarrow> non_empty_cycle_root ?q ?x\n\ngoal (1 subgoal):\n 1. q \\<le> x\\<^sup>T\\<^sup>+ ; q", "by blast"], ["", "lemma non_empty_cycle_root_move_root_loop:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"q \\<le> x\\<^sup>\\<star>;r\"\n    shows \"q \\<le> x\\<^sup>+;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<le> x\\<^sup>+ ; q", "using assms non_empty_cycle_root_loop_converse non_empty_cycle_root_move_root"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point q\n  q \\<le> x\\<^sup>\\<star> ; r\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> ?r \\<le> ?x\\<^sup>+ ; ?r\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?q;\n   ?q \\<le> ?x\\<^sup>\\<star> ; ?r\\<rbrakk>\n  \\<Longrightarrow> non_empty_cycle_root ?q ?x\n\ngoal (1 subgoal):\n 1. q \\<le> x\\<^sup>+ ; q", "by blast"], ["", "lemma non_empty_cycle_root_msc_plus:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>+;r = x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; r = x\\<^sup>T\\<^sup>+ ; r", "using assms many_strongly_connected_iff_7 non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  many_strongly_connected ?x = (?x\\<^sup>T\\<^sup>+ = ?x\\<^sup>+)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; r = x\\<^sup>T\\<^sup>+ ; r", "by fastforce"], ["", "lemma non_empty_cycle_root_tc_start_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>+;r = x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; r = x ; 1", "by (metis assms connected_root_iff3 backward_finite_path_root_def non_empty_cycle_root_msc_plus\n          non_empty_cycle_root_no_start_end_points)"], ["", "lemma non_empty_cycle_root_rtc_start_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>\\<star>;r = x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; r = x ; 1", "by (simp add: assms non_empty_cycle_root_rtc_tc non_empty_cycle_root_tc_start_points)"], ["", "lemma non_empty_cycle_root_converse_start_end_points:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>T \\<le> x;1;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x ; 1 ; x", "by (metis assms conv_contrav conv_invol conv_one inf.boundedI maddux_20 maddux_21 vector_meet_comp_x\n          non_empty_cycle_root_no_start_end_points)"], ["", "lemma non_empty_cycle_root_start_end_points_plus:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x;1;x \\<le> x\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected_root (x ; 1) x", "using assms eq_iff one_strongly_connected_iff one_strongly_connected_implies_7_eq\n      backward_finite_path_connected non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  one_strongly_connected ?x =\n  (connected ?x \\<and> many_strongly_connected ?x)\n  one_strongly_connected ?x \\<Longrightarrow> ?x ; 1 ; ?x = ?x\\<^sup>+\n  backward_finite_path_root ?r ?x \\<Longrightarrow> connected ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. connected_root (x ; 1) x", "by blast"], ["", "lemma non_empty_cycle_root_converse_plus:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>T \\<le> x\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>+", "using assms many_strongly_connected_iff_2 non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  many_strongly_connected ?x = (?x\\<^sup>T \\<le> ?x\\<^sup>+)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>+", "by blast"], ["", "lemma non_empty_cycle_root_plus_converse:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"x\\<^sup>+ = x\\<^sup>T\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ = x\\<^sup>T\\<^sup>+", "using assms many_strongly_connected_iff_7 non_empty_cycle_root_msc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  many_strongly_connected ?x = (?x\\<^sup>T\\<^sup>+ = ?x\\<^sup>+)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ = x\\<^sup>T\\<^sup>+", "by fastforce"], ["", "lemma non_empty_cycle_root_converse:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"non_empty_cycle_root r (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_cycle_root r (x\\<^sup>T)", "by (metis assms conv_invol inj_p_fun connected_root_iff3 backward_finite_path_root_def\n          non_empty_cycle_root_msc_plus non_empty_cycle_root_tc_start_points)"], ["", "lemma non_empty_cycle_root_move_root_forward:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"r \\<le> x\\<^sup>\\<star>;q\"\n    shows \"non_empty_cycle_root q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_cycle_root q x", "by (metis assms backward_finite_path_root_move_root non_empty_cycle_root_no_start_end_points\n          non_empty_cycle_root_point_exchange non_empty_cycle_root_rtc_start_points)"], ["", "lemma non_empty_cycle_root_move_root_forward_cycle:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n      and \"r \\<le> x\\<^sup>\\<star>;q\"\n    shows \"x;q \\<noteq> 0 \\<and> x\\<^sup>T;q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; q \\<noteq> 0 \\<and> x\\<^sup>T ; q \\<noteq> 0", "by (metis assms comp_assoc independence1 ss_p18 non_empty_cycle_root_move_root_forward\n          non_empty_cycle_root_msc_plus non_empty_cycle_root_non_empty\n          non_empty_cycle_root_tc_start_points)"], ["", "lemma non_empty_cycle_root_equivalences:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point q\"\n    shows \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> q \\<le> x\\<^sup>\\<star>;r)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> x;q \\<noteq> 0)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> x\\<^sup>T;q \\<noteq> 0)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> q \\<le> x;1)\"\n      and \"(r \\<le> x\\<^sup>\\<star>;q \\<longleftrightarrow> q \\<le> x\\<^sup>T;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r \\<le> x\\<^sup>\\<star> ; q) = (q \\<le> x\\<^sup>\\<star> ; r) &&&\n     (r \\<le> x\\<^sup>\\<star> ; q) = (x ; q \\<noteq> 0)) &&&\n    (r \\<le> x\\<^sup>\\<star> ; q) = (x\\<^sup>T ; q \\<noteq> 0) &&&\n    (r \\<le> x\\<^sup>\\<star> ; q) = (q \\<le> x ; 1) &&&\n    (r \\<le> x\\<^sup>\\<star> ; q) = (q \\<le> x\\<^sup>T ; 1)", "using assms cycle_iff no_end_point_char non_empty_cycle_root_no_start_end_points\n      non_empty_cycle_root_point_exchange non_empty_cycle_root_rtc_start_points"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point q\n  point ?r \\<Longrightarrow>\n  (?x ; ?r \\<noteq> 0) = (?r \\<le> ?x\\<^sup>T ; 1)\n  point ?p \\<Longrightarrow>\n  (?x\\<^sup>T ; ?p \\<noteq> 0) = (?p \\<le> ?x ; 1)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> no_start_end_points ?x\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?p\\<rbrakk>\n  \\<Longrightarrow> (?r \\<le> ?x\\<^sup>\\<star> ; ?p) =\n                    (?p \\<le> ?x\\<^sup>\\<star> ; ?r)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?r = ?x ; 1\n\ngoal (1 subgoal):\n 1. ((r \\<le> x\\<^sup>\\<star> ; q) = (q \\<le> x\\<^sup>\\<star> ; r) &&&\n     (r \\<le> x\\<^sup>\\<star> ; q) = (x ; q \\<noteq> 0)) &&&\n    (r \\<le> x\\<^sup>\\<star> ; q) = (x\\<^sup>T ; q \\<noteq> 0) &&&\n    (r \\<le> x\\<^sup>\\<star> ; q) = (q \\<le> x ; 1) &&&\n    (r \\<le> x\\<^sup>\\<star> ; q) = (q \\<le> x\\<^sup>T ; 1)", "by metis+"], ["", "lemma non_empty_cycle_root_chord:\n  assumes \"non_empty_cycle_root r x\"\n      and \"point p\"\n      and \"point q\"\n      and \"r \\<le> x\\<^sup>\\<star>;p\"\n      and \"r \\<le> x\\<^sup>\\<star>;q\"\n    shows \"p \\<le> x\\<^sup>\\<star>;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> x\\<^sup>\\<star> ; q", "using assms non_empty_cycle_root_move_root_same_reachable non_empty_cycle_root_point_exchange"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  point p\n  point q\n  r \\<le> x\\<^sup>\\<star> ; p\n  r \\<le> x\\<^sup>\\<star> ; q\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?q;\n   ?q \\<le> ?x\\<^sup>\\<star> ; ?r\\<rbrakk>\n  \\<Longrightarrow> ?x\\<^sup>\\<star> ; ?r = ?x\\<^sup>\\<star> ; ?q\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?p\\<rbrakk>\n  \\<Longrightarrow> (?r \\<le> ?x\\<^sup>\\<star> ; ?p) =\n                    (?p \\<le> ?x\\<^sup>\\<star> ; ?r)\n\ngoal (1 subgoal):\n 1. p \\<le> x\\<^sup>\\<star> ; q", "by fastforce"], ["", "lemma non_empty_cycle_root_var_axioms_2:\n  \"non_empty_cycle_root r x \\<longleftrightarrow> x;1 \\<le> x\\<^sup>+;r \\<and> is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x =\n    (x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n     is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x ; 1)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. non_empty_cycle_root r x \\<Longrightarrow>\n    x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n    is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x ; 1\n 2. x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n    is_inj x \\<and>\n    is_p_fun x \\<and> point r \\<and> r \\<le> x ; 1 \\<Longrightarrow>\n    non_empty_cycle_root r x", "apply (metis eq_iff backward_finite_path_root_def non_empty_cycle_root_no_start_end_points\n              non_empty_cycle_root_tc_start_points)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n    is_inj x \\<and>\n    is_p_fun x \\<and> point r \\<and> r \\<le> x ; 1 \\<Longrightarrow>\n    non_empty_cycle_root r x", "by (metis conv_invol p_fun_inj connected_root_iff2 connected_root_iff3\n          non_empty_cycle_root_var_axioms_1 non_empty_cycle_root_msc_plus\n          non_empty_cycle_root_rtc_start_points non_empty_cycle_root_rtc_tc)"], ["", "lemma non_empty_cycle_root_var_axioms_3:\n  \"non_empty_cycle_root r x \\<longleftrightarrow> x;1 \\<le> x\\<^sup>+;r \\<and> is_inj x \\<and> is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>+;x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x =\n    (x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n     is_inj x \\<and>\n     is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>+ ; x ; 1)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. non_empty_cycle_root r x \\<Longrightarrow>\n    x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n    is_inj x \\<and>\n    is_p_fun x \\<and> point r \\<and> r \\<le> x\\<^sup>+ ; x ; 1\n 2. x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n    is_inj x \\<and>\n    is_p_fun x \\<and>\n    point r \\<and> r \\<le> x\\<^sup>+ ; x ; 1 \\<Longrightarrow>\n    non_empty_cycle_root r x", "apply (metis comp_assoc eq_refl backward_finite_path_root_def star_inductl_var_eq2\n              non_empty_cycle_root_no_start_end_points non_empty_cycle_root_rtc_start_points\n              non_empty_cycle_root_tc_start_points)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<le> x\\<^sup>+ ; r \\<and>\n    is_inj x \\<and>\n    is_p_fun x \\<and>\n    point r \\<and> r \\<le> x\\<^sup>+ ; x ; 1 \\<Longrightarrow>\n    non_empty_cycle_root r x", "by (metis annir comp_assoc conv_contrav no_end_point_char non_empty_cycle_root_var_axioms_2)"], ["", "lemma non_empty_cycle_root_subset_equals:\n  assumes \"non_empty_cycle_root r x\"\n      and \"non_empty_cycle_root r y\"\n      and \"x \\<le> y\"\n    shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"y;x\\<^sup>T\\<^sup>\\<star>;r = y;x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ; x\\<^sup>T\\<^sup>\\<star> ; r = y ; x\\<^sup>T\\<^sup>+ ; r", "using assms(1) comp_assoc non_empty_cycle_root_msc non_empty_cycle_root_msc_plus\n          non_empty_cycle_root_rtc_tc"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>+ ; ?r = ?x\\<^sup>T\\<^sup>+ ; ?r\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?r = ?x\\<^sup>+ ; ?r\n\ngoal (1 subgoal):\n 1. y ; x\\<^sup>T\\<^sup>\\<star> ; r = y ; x\\<^sup>T\\<^sup>+ ; r", "by fastforce"], ["proof (state)\nthis:\n  y ; x\\<^sup>T\\<^sup>\\<star> ; r = y ; x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x = y", "also"], ["proof (state)\nthis:\n  y ; x\\<^sup>T\\<^sup>\\<star> ; r = y ; x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x = y", "have \"... \\<le> y;y\\<^sup>T;x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ; x\\<^sup>T\\<^sup>+ ; r\n    \\<le> y ; y\\<^sup>T ; x\\<^sup>T\\<^sup>\\<star> ; r", "using assms(3) comp_assoc conv_iso mult_double_iso"], ["proof (prove)\nusing this:\n  x \\<le> y\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  ?x \\<le> ?y \\<Longrightarrow> ?w ; ?x ; ?z \\<le> ?w ; ?y ; ?z\n\ngoal (1 subgoal):\n 1. y ; x\\<^sup>T\\<^sup>+ ; r\n    \\<le> y ; y\\<^sup>T ; x\\<^sup>T\\<^sup>\\<star> ; r", "by fastforce"], ["proof (state)\nthis:\n  y ; x\\<^sup>T\\<^sup>+ ; r\n  \\<le> y ; y\\<^sup>T ; x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x = y", "also"], ["proof (state)\nthis:\n  y ; x\\<^sup>T\\<^sup>+ ; r\n  \\<le> y ; y\\<^sup>T ; x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x = y", "have \"... \\<le> x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ; y\\<^sup>T ; x\\<^sup>T\\<^sup>\\<star> ; r\n    \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "using assms(2) backward_finite_path_root_def is_inj_def"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r y\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  is_inj ?x \\<equiv> ?x ; ?x\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. y ; y\\<^sup>T ; x\\<^sup>T\\<^sup>\\<star> ; r\n    \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "by (meson dual_order.trans mult_isor order.refl prod_star_closure star_ref)"], ["proof (state)\nthis:\n  y ; y\\<^sup>T ; x\\<^sup>T\\<^sup>\\<star> ; r\n  \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x = y", "finally"], ["proof (chain)\npicking this:\n  y ; x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "have \"r + y;x\\<^sup>T\\<^sup>\\<star>;r \\<le> x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\nusing this:\n  y ; x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. r + y ; x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "by (metis conway.dagger_unfoldl_distr le_supI sup.cobounded1)"], ["proof (state)\nthis:\n  r + y ; x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x = y", "hence \"y\\<^sup>\\<star>;r \\<le> x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\nusing this:\n  r + y ; x\\<^sup>T\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "by (simp add: comp_assoc rtc_inductl)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. x = y", "hence \"y;1 \\<le> x;1\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. y ; 1 \\<le> x ; 1", "using assms(1,2) non_empty_cycle_root_msc non_empty_cycle_root_rtc_start_points"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> ; r \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n  non_empty_cycle_root r x\n  non_empty_cycle_root r y\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> many_strongly_connected ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?r = ?x ; 1\n\ngoal (1 subgoal):\n 1. y ; 1 \\<le> x ; 1", "by fastforce"], ["proof (state)\nthis:\n  y ; 1 \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  y ; 1 \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. x = y", "using assms(2,3) backward_finite_path_root_def ss422iv"], ["proof (prove)\nusing this:\n  y ; 1 \\<le> x ; 1\n  non_empty_cycle_root r y\n  x \\<le> y\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  \\<lbrakk>is_p_fun ?y; ?x \\<le> ?y; ?y ; 1 \\<le> ?x ; 1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. x = y", "by blast"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_cycle_root_subset_equals_change_root:\n  assumes \"non_empty_cycle_root r x\"\n      and \"non_empty_cycle_root q y\"\n      and \"x \\<le> y\"\n    shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"r \\<le> y;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> y ; 1", "by (metis assms(1,3) dual_order.trans mult_isor non_empty_cycle_root_no_start_end_points)"], ["proof (state)\nthis:\n  r \\<le> y ; 1\n\ngoal (1 subgoal):\n 1. x = y", "hence \"non_empty_cycle_root r y\""], ["proof (prove)\nusing this:\n  r \\<le> y ; 1\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r y", "by (metis assms(1,2) connected_root_move_root backward_finite_path_root_def\n              non_empty_cycle_root_no_start_end_points non_empty_cycle_root_rtc_start_points)"], ["proof (state)\nthis:\n  non_empty_cycle_root r y\n\ngoal (1 subgoal):\n 1. x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r y\n\ngoal (1 subgoal):\n 1. x = y", "using assms(1,3) non_empty_cycle_root_subset_equals"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r y\n  non_empty_cycle_root r x\n  x \\<le> y\n  \\<lbrakk>non_empty_cycle_root ?r ?x; non_empty_cycle_root ?r ?y;\n   ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. x = y", "by blast"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_cycle_root_equivalences_2:\n  assumes \"non_empty_cycle_root r x\"\n     shows \"(v \\<le> x\\<^sup>\\<star>;r \\<longleftrightarrow> v \\<le> x\\<^sup>T;1)\"\n       and \"(v \\<le> x\\<^sup>\\<star>;r \\<longleftrightarrow> v \\<le> x;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<le> x\\<^sup>\\<star> ; r) = (v \\<le> x\\<^sup>T ; 1) &&&\n    (v \\<le> x\\<^sup>\\<star> ; r) = (v \\<le> x ; 1)", "using assms non_empty_cycle_root_no_start_end_points non_empty_cycle_root_rtc_start_points"], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> no_start_end_points ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?r = ?x ; 1\n\ngoal (1 subgoal):\n 1. (v \\<le> x\\<^sup>\\<star> ; r) = (v \\<le> x\\<^sup>T ; 1) &&&\n    (v \\<le> x\\<^sup>\\<star> ; r) = (v \\<le> x ; 1)", "by metis+"], ["", "lemma cycle_root_non_empty:\n  assumes \"x \\<noteq> 0\"\n    shows \"cycle_root r x \\<longleftrightarrow> non_empty_cycle_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_root r x = non_empty_cycle_root r x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cycle_root r x \\<Longrightarrow> non_empty_cycle_root r x\n 2. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "assume 1: \"cycle_root r x\""], ["proof (state)\nthis:\n  cycle_root r x\n\ngoal (2 subgoals):\n 1. cycle_root r x \\<Longrightarrow> non_empty_cycle_root r x\n 2. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "have \"r \\<le> r;1;x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> r ; 1 ; x ; 1", "using assms comp_assoc maddux_20 tarski"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?x \\<le> ?x ; 1\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n\ngoal (1 subgoal):\n 1. r \\<le> r ; 1 ; x ; 1", "by fastforce"], ["proof (state)\nthis:\n  r \\<le> r ; 1 ; x ; 1\n\ngoal (2 subgoals):\n 1. cycle_root r x \\<Longrightarrow> non_empty_cycle_root r x\n 2. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "also"], ["proof (state)\nthis:\n  r \\<le> r ; 1 ; x ; 1\n\ngoal (2 subgoals):\n 1. cycle_root r x \\<Longrightarrow> non_empty_cycle_root r x\n 2. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "have \"... \\<le> (x\\<^sup>+ \\<cdot> x\\<^sup>T;1);1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; 1 ; x ; 1 \\<le> (x\\<^sup>+ \\<cdot> x\\<^sup>T ; 1) ; 1", "using 1"], ["proof (prove)\nusing this:\n  cycle_root r x\n\ngoal (1 subgoal):\n 1. r ; 1 ; x ; 1 \\<le> (x\\<^sup>+ \\<cdot> x\\<^sup>T ; 1) ; 1", "by (simp add: is_vector_def mult_isor point_def)"], ["proof (state)\nthis:\n  r ; 1 ; x ; 1 \\<le> (x\\<^sup>+ \\<cdot> x\\<^sup>T ; 1) ; 1\n\ngoal (2 subgoals):\n 1. cycle_root r x \\<Longrightarrow> non_empty_cycle_root r x\n 2. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "also"], ["proof (state)\nthis:\n  r ; 1 ; x ; 1 \\<le> (x\\<^sup>+ \\<cdot> x\\<^sup>T ; 1) ; 1\n\ngoal (2 subgoals):\n 1. cycle_root r x \\<Longrightarrow> non_empty_cycle_root r x\n 2. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "have \"... \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> x\\<^sup>T ; 1) ; 1 \\<le> x\\<^sup>T ; 1", "by (simp add: ra_1)"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> x\\<^sup>T ; 1) ; 1 \\<le> x\\<^sup>T ; 1\n\ngoal (2 subgoals):\n 1. cycle_root r x \\<Longrightarrow> non_empty_cycle_root r x\n 2. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "finally"], ["proof (chain)\npicking this:\n  r \\<le> x\\<^sup>T ; 1", "show \"non_empty_cycle_root r x\""], ["proof (prove)\nusing this:\n  r \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x", "using 1 backward_finite_path_root_def inf.boundedE"], ["proof (prove)\nusing this:\n  r \\<le> x\\<^sup>T ; 1\n  cycle_root r x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  \\<lbrakk>?a \\<le> ?b \\<cdot> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x", "by blast"], ["proof (state)\nthis:\n  non_empty_cycle_root r x\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "assume \"non_empty_cycle_root r x\""], ["proof (state)\nthis:\n  non_empty_cycle_root r x\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x \\<Longrightarrow> cycle_root r x", "thus \"cycle_root r x\""], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n\ngoal (1 subgoal):\n 1. cycle_root r x", "by (metis backward_finite_path_root_def inf.orderE maddux_20 non_empty_cycle_root_plus_converse\n              ra_1)"], ["proof (state)\nthis:\n  cycle_root r x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Start points and end points\\<close>"], ["", "lemma start_points_path_aux:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"x;r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; r = 0", "by (metis assms compl_inf_bot inf.commute non_empty_cycle_root_no_start_end_points\n          backward_finite_path_root_terminating_or_cycle)"], ["", "lemma start_points_path:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"backward_terminating_path_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path_root r x", "by (simp add: assms start_points_path_aux)"], ["", "lemma root_in_start_points_2:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"r \\<le> start_points x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "by (metis assms conv_zero eq_refl galois_aux2 root_equals_start_points start_points_path_aux)"], ["", "lemma root_equals_start_points_2:\n  assumes \"backward_finite_path_root r x\"\n      and \"start_points x \\<noteq> 0\"\n    shows \"r = start_points x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = start_points x", "by (metis assms inf_bot_left ss_p18 root_equals_start_points start_points_path)"], ["", "lemma start_points_injective:\n  assumes \"backward_finite_path_root r x\"\n    shows \"is_inj (start_points x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj (start_points x)", "by (metis assms compl_bot_eq inj_def_var1 point_def backward_finite_path_root_def top_greatest\n          root_equals_start_points_2)"], ["", "lemma backward_terminating_path_root_aux_2:\n assumes \"backward_finite_path_root r x\"\n     and \"start_points x \\<noteq> 0 \\<or> x = 0\"\n   shows \"x \\<le> x\\<^sup>T\\<^sup>\\<star>;-(x\\<^sup>T;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "using assms bot_least backward_terminating_path_root_aux start_points_path"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  start_points x \\<noteq> 0 \\<or> x = 0\n  0 \\<le> ?a\n  backward_terminating_path_root ?r ?x \\<Longrightarrow>\n  ?x \\<le> ?x\\<^sup>T\\<^sup>\\<star> ; - (?x\\<^sup>T ; 1)\n  \\<lbrakk>backward_finite_path_root ?r ?x;\n   start_points ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> backward_terminating_path_root ?r ?x\n\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>T\\<^sup>\\<star> ; - (x\\<^sup>T ; 1)", "by blast"], ["", "lemma start_points_not_zero_iff:\n  assumes \"backward_finite_path_root r x\"\n    shows \"x;r = 0 \\<and> x \\<noteq> 0 \\<longleftrightarrow> start_points x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; r = 0 \\<and> x \\<noteq> 0) = (start_points x \\<noteq> 0)", "by (metis assms conv_zero inf_compl_bot backward_finite_path_root_def start_points_not_zero_contra\n          start_points_path_aux)"], ["", "text \\<open>Backwards terminating and backwards finite: Part II\\<close>"], ["", "lemma backward_finite_path_root_acyclic_terminating_aux:\n  assumes \"backward_finite_path_root r x\"\n      and \"is_acyclic x\"\n    shows \"x;r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; r = 0", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x ; r = 0\n 2. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x ; r = 0\n 2. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. x ; r = 0", "by simp"], ["proof (state)\nthis:\n  x ; r = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "assume \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "hence 1: \"r \\<le> x;1\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "using assms(1) has_root_contra no_end_point_char backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  backward_finite_path_root r x\n  \\<lbrakk>connected_root ?r ?x; point ?r; ?x\\<^sup>T ; ?r = 0\\<rbrakk>\n  \\<Longrightarrow> ?x = 0\n  point ?p \\<Longrightarrow>\n  (?x\\<^sup>T ; ?p \\<noteq> 0) = (?p \\<le> ?x ; 1)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "by blast"], ["proof (state)\nthis:\n  r \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "have \"r\\<cdot>(x\\<^sup>T;1) = r\\<cdot>(x\\<^sup>T\\<^sup>+;r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<cdot> x\\<^sup>T ; 1 = r \\<cdot> x\\<^sup>T\\<^sup>+ ; r", "using assms(1) connected_root_iff3 backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. r \\<cdot> x\\<^sup>T ; 1 = r \\<cdot> x\\<^sup>T\\<^sup>+ ; r", "by fastforce"], ["proof (state)\nthis:\n  r \\<cdot> x\\<^sup>T ; 1 = r \\<cdot> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "also"], ["proof (state)\nthis:\n  r \\<cdot> x\\<^sup>T ; 1 = r \\<cdot> x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "have \"... \\<le> r\\<cdot>(-1';r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<cdot> x\\<^sup>T\\<^sup>+ ; r \\<le> r \\<cdot> - 1' ; r", "by (metis assms(2) conv_compl conv_contrav conv_e conv_iso meet_isor mult_isor star_conv\n              star_slide_var)"], ["proof (state)\nthis:\n  r \\<cdot> x\\<^sup>T\\<^sup>+ ; r \\<le> r \\<cdot> - 1' ; r\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "also"], ["proof (state)\nthis:\n  r \\<cdot> x\\<^sup>T\\<^sup>+ ; r \\<le> r \\<cdot> - 1' ; r\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<cdot> - 1' ; r = 0", "by (metis (no_types) assms(1) inj_distr annil inf_compl_bot mult_1_left point_def\n              backward_finite_path_root_def)"], ["proof (state)\nthis:\n  r \\<cdot> - 1' ; r = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "finally"], ["proof (chain)\npicking this:\n  r \\<cdot> x\\<^sup>T ; 1 \\<le> 0", "have \"r \\<le> start_points x\""], ["proof (prove)\nusing this:\n  r \\<cdot> x\\<^sup>T ; 1 \\<le> 0\n\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "using 1 galois_aux inf.boundedI le_bot"], ["proof (prove)\nusing this:\n  r \\<cdot> x\\<^sup>T ; 1 \\<le> 0\n  r \\<le> x ; 1\n  (?x \\<cdot> ?y = 0) = (?x \\<le> - ?y)\n  \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<cdot> ?c\n  ?a \\<le> 0 \\<Longrightarrow> ?a = 0\n\ngoal (1 subgoal):\n 1. r \\<le> start_points x", "by blast"], ["proof (state)\nthis:\n  r \\<le> start_points x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x ; r = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  r \\<le> start_points x\n\ngoal (1 subgoal):\n 1. x ; r = 0", "using assms(1) annir le_bot start_points_path"], ["proof (prove)\nusing this:\n  r \\<le> start_points x\n  backward_finite_path_root r x\n  ?x ; 0 = 0\n  ?a \\<le> 0 \\<Longrightarrow> ?a = 0\n  \\<lbrakk>backward_finite_path_root ?r ?x;\n   start_points ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> backward_terminating_path_root ?r ?x\n\ngoal (1 subgoal):\n 1. x ; r = 0", "by blast"], ["proof (state)\nthis:\n  x ; r = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma backward_finite_path_root_acyclic_terminating_iff:\n  assumes \"backward_finite_path_root r x\"\n    shows \"is_acyclic x \\<longleftrightarrow> x;r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic x = (x ; r = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_acyclic x \\<Longrightarrow> x ; r = 0\n 2. x ; r = 0 \\<Longrightarrow> is_acyclic x", "apply (simp add: assms backward_finite_path_root_acyclic_terminating_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; r = 0 \\<Longrightarrow> is_acyclic x", "using assms backward_finite_path_root_path_root path_root_acyclic"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  backward_finite_path_root ?r ?x \\<Longrightarrow> path_root ?r ?x\n  \\<lbrakk>path_root ?r ?x; ?x ; ?r = 0\\<rbrakk>\n  \\<Longrightarrow> is_acyclic ?x\n\ngoal (1 subgoal):\n 1. x ; r = 0 \\<Longrightarrow> is_acyclic x", "by blast"], ["", "lemma backward_finite_path_root_acyclic_terminating:\n assumes \"backward_finite_path_root r x\"\n     and \"is_acyclic x\"\n   shows \"backward_terminating_path_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path_root r x", "by (simp add: assms backward_finite_path_root_acyclic_terminating_aux)"], ["", "lemma non_empty_cycle_root_one_strongly_connected:\n  assumes \"non_empty_cycle_root r x\"\n    shows \"one_strongly_connected x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_strongly_connected x", "by (metis assms one_strongly_connected_iff order_trans star_1l star_star_plus sup.absorb2\n          non_empty_cycle_root_msc non_empty_cycle_root_start_end_points_plus)"], ["", "lemma backward_finite_path_root_nodes_reachable:\n  assumes \"backward_finite_path_root r x\"\n      and \"v \\<le> x;1 + x\\<^sup>T;1\"\n      and \"is_sur v\"\n    shows \"r \\<le> x\\<^sup>\\<star>;v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "have \"v \\<le> x;1 + x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le> x ; 1 + x\\<^sup>T\\<^sup>+ ; r", "using assms connected_root_iff3 backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  v \\<le> x ; 1 + x\\<^sup>T ; 1\n  is_sur v\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. v \\<le> x ; 1 + x\\<^sup>T\\<^sup>+ ; r", "by fastforce"], ["proof (state)\nthis:\n  v \\<le> x ; 1 + x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "also"], ["proof (state)\nthis:\n  v \\<le> x ; 1 + x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "have \"... \\<le> x\\<^sup>T\\<^sup>\\<star>;r + x\\<^sup>T\\<^sup>+;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 + x\\<^sup>T\\<^sup>+ ; r\n    \\<le> x\\<^sup>T\\<^sup>\\<star> ; r + x\\<^sup>T\\<^sup>+ ; r", "using assms(1) join_iso start_points_in_root_aux"], ["proof (prove)\nusing this:\n  backward_finite_path_root r x\n  ?x \\<le> ?y \\<Longrightarrow> ?x + ?z \\<le> ?y + ?z\n  backward_finite_path_root ?r ?x \\<Longrightarrow>\n  ?x ; 1 \\<le> ?x\\<^sup>T\\<^sup>\\<star> ; ?r\n\ngoal (1 subgoal):\n 1. x ; 1 + x\\<^sup>T\\<^sup>+ ; r\n    \\<le> x\\<^sup>T\\<^sup>\\<star> ; r + x\\<^sup>T\\<^sup>+ ; r", "by blast"], ["proof (state)\nthis:\n  x ; 1 + x\\<^sup>T\\<^sup>+ ; r\n  \\<le> x\\<^sup>T\\<^sup>\\<star> ; r + x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "also"], ["proof (state)\nthis:\n  x ; 1 + x\\<^sup>T\\<^sup>+ ; r\n  \\<le> x\\<^sup>T\\<^sup>\\<star> ; r + x\\<^sup>T\\<^sup>+ ; r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "have \"... = x\\<^sup>T\\<^sup>\\<star>;r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; r + x\\<^sup>T\\<^sup>+ ; r =\n    x\\<^sup>T\\<^sup>\\<star> ; r", "using mult_isor sup.absorb1"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n  ?b \\<le> ?a \\<Longrightarrow> ?a + ?b = ?a\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; r + x\\<^sup>T\\<^sup>+ ; r =\n    x\\<^sup>T\\<^sup>\\<star> ; r", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>T\\<^sup>\\<star> ; r + x\\<^sup>T\\<^sup>+ ; r =\n  x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "finally"], ["proof (chain)\npicking this:\n  v \\<le> x\\<^sup>T\\<^sup>\\<star> ; r", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "using assms(1,3)"], ["proof (prove)\nusing this:\n  v \\<le> x\\<^sup>T\\<^sup>\\<star> ; r\n  backward_finite_path_root r x\n  is_sur v\n\ngoal (1 subgoal):\n 1. r \\<le> x\\<^sup>\\<star> ; v", "by (simp add: inj_sur_semi_swap point_def backward_finite_path_root_def star_conv\n                  inj_sur_semi_swap_short)"], ["proof (state)\nthis:\n  r \\<le> x\\<^sup>\\<star> ; v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminating_path_root_end_backward_terminating:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"backward_terminating_path_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path_root r x", "using assms non_empty_cycle_root_move_root_forward_cycle\n      backward_finite_path_root_terminating_or_cycle"], ["proof (prove)\nusing this:\n  terminating_path_root_end r x e\n  \\<lbrakk>non_empty_cycle_root ?r ?x; point ?q;\n   ?r \\<le> ?x\\<^sup>\\<star> ; ?q\\<rbrakk>\n  \\<Longrightarrow> ?x ; ?q \\<noteq> 0 \\<and> ?x\\<^sup>T ; ?q \\<noteq> 0\n  backward_finite_path_root ?r ?x =\n  (backward_terminating_path_root ?r ?x \\<or> non_empty_cycle_root ?r ?x)\n\ngoal (1 subgoal):\n 1. backward_terminating_path_root r x", "by blast"], ["", "lemma terminating_path_root_end_converse:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"terminating_path_root_end e (x\\<^sup>T) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminating_path_root_end e (x\\<^sup>T) r", "by (metis assms terminating_path_root_end_backward_terminating backward_finite_path_root_def\n          conv_invol terminating_path_root_end_forward_finite point_swap star_conv)"], ["", "lemma terminating_path_root_end_forward_terminating:\n  assumes \"terminating_path_root_end r x e\"\n    shows \"backward_terminating_path_root e (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path_root e (x\\<^sup>T)", "using assms terminating_path_root_end_converse"], ["proof (prove)\nusing this:\n  terminating_path_root_end r x e\n  terminating_path_root_end ?r ?x ?e \\<Longrightarrow>\n  terminating_path_root_end ?e (?x\\<^sup>T) ?r\n\ngoal (1 subgoal):\n 1. backward_terminating_path_root e (x\\<^sup>T)", "by blast"], ["", "end"], ["", "(* relation_algebra_rtc_tarski *)"], ["", "subsection \\<open>Consequences with the Tarski rule and the point axiom\\<close>"], ["", "context relation_algebra_rtc_tarski_point\nbegin"], ["", "text \\<open>Rooted paths\\<close>"], ["", "lemma path_root_iff:\n  \"(\\<exists>r . path_root r x) \\<longleftrightarrow> path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. path_root r x) = path x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>r. path_root r x \\<Longrightarrow> path x\n 2. path x \\<Longrightarrow> \\<exists>r. path_root r x", "assume \"\\<exists>r . path_root r x\""], ["proof (state)\nthis:\n  \\<exists>r. path_root r x\n\ngoal (2 subgoals):\n 1. \\<exists>r. path_root r x \\<Longrightarrow> path x\n 2. path x \\<Longrightarrow> \\<exists>r. path_root r x", "thus \"path x\""], ["proof (prove)\nusing this:\n  \\<exists>r. path_root r x\n\ngoal (1 subgoal):\n 1. path x", "using path_def path_iff_backward point_def path_root_def"], ["proof (prove)\nusing this:\n  \\<exists>r. path_root r x\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n  \\<lbrakk>is_inj ?x; is_p_fun ?x; point ?r;\n   ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>\\<rbrakk>\n  \\<Longrightarrow> connected ?x\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  path_root ?r ?x \\<equiv>\n  ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star> \\<and>\n  is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. path x", "by blast"], ["proof (state)\nthis:\n  path x\n\ngoal (1 subgoal):\n 1. path x \\<Longrightarrow> \\<exists>r. path_root r x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. path x \\<Longrightarrow> \\<exists>r. path_root r x", "assume 1: \"path x\""], ["proof (state)\nthis:\n  path x\n\ngoal (1 subgoal):\n 1. path x \\<Longrightarrow> \\<exists>r. path_root r x", "show \"\\<exists>r . path_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. path_root r x", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>r. path_root r x\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>r. path_root r x\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r. path_root r x", "by (simp add: is_inj_def is_p_fun_def point_exists path_root_def)"], ["proof (state)\nthis:\n  \\<exists>r. path_root r x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "assume \"\\<not>(x = 0)\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "hence \"x;1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x ; 1 \\<noteq> 0", "by (simp add: ss_p18)"], ["proof (state)\nthis:\n  x ; 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "from this"], ["proof (chain)\npicking this:\n  x ; 1 \\<noteq> 0", "obtain r where 2: \"point r \\<and> r \\<le> x;1\""], ["proof (prove)\nusing this:\n  x ; 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        point r \\<and> r \\<le> x ; 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using comp_assoc is_vector_def one_idem_mult point_below_vector"], ["proof (prove)\nusing this:\n  x ; 1 \\<noteq> 0\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  1 ; 1 = 1\n  \\<lbrakk>is_vector ?v; ?v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. point x \\<and> x \\<le> ?v\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        point r \\<and> r \\<le> x ; 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  point r \\<and> r \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "hence \"r;x \\<le> x;1;x\""], ["proof (prove)\nusing this:\n  point r \\<and> r \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. r ; x \\<le> x ; 1 ; x", "by (simp add: mult_isor)"], ["proof (state)\nthis:\n  r ; x \\<le> x ; 1 ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "also"], ["proof (state)\nthis:\n  r ; x \\<le> x ; 1 ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "have \"... \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected x", "using 1 path_def"], ["proof (prove)\nusing this:\n  path x\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n\ngoal (1 subgoal):\n 1. connected x", "by blast"], ["proof (state)\nthis:\n  connected x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<exists>r. path_root r x", "finally"], ["proof (chain)\npicking this:\n  r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<exists>r. path_root r x", "using 1 2 path_def path_root_def"], ["proof (prove)\nusing this:\n  r ; x \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n  path x\n  point r \\<and> r \\<le> x ; 1\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n  path_root ?r ?x \\<equiv>\n  ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star> \\<and>\n  is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. \\<exists>r. path_root r x", "by blast"], ["proof (state)\nthis:\n  \\<exists>r. path_root r x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r. path_root r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_path_root_iff:\n  \"(\\<exists>r . path_root r x \\<and> r \\<le> (x + x\\<^sup>T);1) \\<longleftrightarrow> path x \\<and> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. path_root r x \\<and> r \\<le> (x + x\\<^sup>T) ; 1) =\n    (path x \\<and> x \\<noteq> 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>r.\n       path_root r x \\<and> r \\<le> (x + x\\<^sup>T) ; 1 \\<Longrightarrow>\n    path x \\<and> x \\<noteq> 0\n 2. path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. path_root r x \\<and> r \\<le> (x + x\\<^sup>T) ; 1", "using non_empty_cycle_root_non_empty path_root_def zero_backward_terminating_path_root path_root_iff"], ["proof (prove)\nusing this:\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> ?x \\<noteq> 0\n  path_root ?r ?x \\<equiv>\n  ?r ; ?x \\<le> ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star> \\<and>\n  is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  point ?r \\<Longrightarrow> backward_terminating_path_root ?r 0\n  (\\<exists>r. path_root r ?x) = path ?x\n\ngoal (2 subgoals):\n 1. \\<exists>r.\n       path_root r x \\<and> r \\<le> (x + x\\<^sup>T) ; 1 \\<Longrightarrow>\n    path x \\<and> x \\<noteq> 0\n 2. path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. path_root r x \\<and> r \\<le> (x + x\\<^sup>T) ; 1", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. path_root r x \\<and> r \\<le> (x + x\\<^sup>T) ; 1", "using path_root_iff non_empty_path_root_iff_aux"], ["proof (prove)\nusing this:\n  (\\<exists>r. path_root r ?x) = path ?x\n  \\<lbrakk>path_root ?r ?x; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<le> (?x + ?x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. path_root r x \\<and> r \\<le> (x + x\\<^sup>T) ; 1", "by blast"], ["", "text \\<open>(Non-empty) Cycle\\<close>"], ["", "lemma non_empty_cycle_root_iff:\n  \"(\\<exists>r . non_empty_cycle_root r x) \\<longleftrightarrow> cycle x \\<and> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. non_empty_cycle_root r x) = (cycle x \\<and> x \\<noteq> 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>r. non_empty_cycle_root r x \\<Longrightarrow>\n    cycle x \\<and> x \\<noteq> 0\n 2. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "assume \"\\<exists>r . non_empty_cycle_root r x\""], ["proof (state)\nthis:\n  \\<exists>r. non_empty_cycle_root r x\n\ngoal (2 subgoals):\n 1. \\<exists>r. non_empty_cycle_root r x \\<Longrightarrow>\n    cycle x \\<and> x \\<noteq> 0\n 2. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "thus \"cycle x \\<and> x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>r. non_empty_cycle_root r x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0", "using non_empty_cycle_root_msc_cycle non_empty_cycle_root_non_empty"], ["proof (prove)\nusing this:\n  \\<exists>r. non_empty_cycle_root r x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> cycle ?x\n  non_empty_cycle_root ?r ?x \\<Longrightarrow> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  cycle x \\<and> x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "assume 1: \"cycle x \\<and> x \\<noteq> 0\""], ["proof (state)\nthis:\n  cycle x \\<and> x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "hence \"x\\<^sup>T;1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cycle x \\<and> x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 \\<noteq> 0", "using many_strongly_connected_implies_no_start_end_points ss_p18"], ["proof (prove)\nusing this:\n  cycle x \\<and> x \\<noteq> 0\n  many_strongly_connected ?x \\<Longrightarrow> no_start_end_points ?x\n  (?x ; 1 = 0) = (?x = 0)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "from this"], ["proof (chain)\npicking this:\n  x\\<^sup>T ; 1 \\<noteq> 0", "obtain r where 2: \"point r \\<and> r \\<le> x\\<^sup>T;1\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        point r \\<and> r \\<le> x\\<^sup>T ; 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using comp_assoc is_vector_def one_idem_mult point_below_vector"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; 1 \\<noteq> 0\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  1 ; 1 = 1\n  \\<lbrakk>is_vector ?v; ?v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. point x \\<and> x \\<le> ?v\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        point r \\<and> r \\<le> x\\<^sup>T ; 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  point r \\<and> r \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "have 3: \"x\\<^sup>T;1;x\\<^sup>T \\<le> x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_strongly_connected x", "using 1 one_strongly_connected_iff path_def"], ["proof (prove)\nusing this:\n  cycle x \\<and> x \\<noteq> 0\n  one_strongly_connected ?x =\n  (connected ?x \\<and> many_strongly_connected ?x)\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n\ngoal (1 subgoal):\n 1. one_strongly_connected x", "by blast"], ["proof (state)\nthis:\n  one_strongly_connected x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "have \"r;x \\<le> x\\<^sup>T;1;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ; x \\<le> x\\<^sup>T ; 1 ; x", "using 2"], ["proof (prove)\nusing this:\n  point r \\<and> r \\<le> x\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. r ; x \\<le> x\\<^sup>T ; 1 ; x", "by (simp add: is_vector_def mult_isor point_def)"], ["proof (state)\nthis:\n  r ; x \\<le> x\\<^sup>T ; 1 ; x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "also"], ["proof (state)\nthis:\n  r ; x \\<le> x\\<^sup>T ; 1 ; x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "have \"... \\<le> x\\<^sup>T;1;x;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x \\<le> x\\<^sup>T ; 1 ; x ; x\\<^sup>T ; x", "using comp_assoc mult_isol x_leq_triple_x"], ["proof (prove)\nusing this:\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n  ?x \\<le> ?x ; ?x\\<^sup>T ; ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x \\<le> x\\<^sup>T ; 1 ; x ; x\\<^sup>T ; x", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x \\<le> x\\<^sup>T ; 1 ; x ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x \\<le> x\\<^sup>T ; 1 ; x ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "have \"... \\<le> x\\<^sup>T;1;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x ; x\\<^sup>T ; x \\<le> x\\<^sup>T ; 1 ; x\\<^sup>T ; x", "by (metis mult_assoc mult_double_iso top_greatest)"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x ; x\\<^sup>T ; x \\<le> x\\<^sup>T ; 1 ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x ; x\\<^sup>T ; x \\<le> x\\<^sup>T ; 1 ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "have \"... \\<le> x\\<^sup>\\<star>;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x\\<^sup>T ; x \\<le> x\\<^sup>\\<star> ; x", "using 3 mult_isor"], ["proof (prove)\nusing this:\n  one_strongly_connected x\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 ; x\\<^sup>T ; x \\<le> x\\<^sup>\\<star> ; x", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 ; x\\<^sup>T ; x \\<le> x\\<^sup>\\<star> ; x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "finally"], ["proof (chain)\npicking this:\n  r ; x \\<le> x\\<^sup>\\<star> ; x", "have \"connected_root r x\""], ["proof (prove)\nusing this:\n  r ; x \\<le> x\\<^sup>\\<star> ; x\n\ngoal (1 subgoal):\n 1. connected_root r x", "by (simp add: star_slide_var)"], ["proof (state)\nthis:\n  connected_root r x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "hence \"non_empty_cycle_root r x\""], ["proof (prove)\nusing this:\n  connected_root r x\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x", "using 1 2 path_def backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  connected_root r x\n  cycle x \\<and> x \\<noteq> 0\n  point r \\<and> r \\<le> x\\<^sup>T ; 1\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. non_empty_cycle_root r x", "by fastforce"], ["proof (state)\nthis:\n  non_empty_cycle_root r x\n\ngoal (1 subgoal):\n 1. cycle x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. non_empty_cycle_root r x", "thus \"\\<exists>r . non_empty_cycle_root r x\""], ["proof (prove)\nusing this:\n  non_empty_cycle_root r x\n\ngoal (1 subgoal):\n 1. \\<exists>r. non_empty_cycle_root r x", ".."], ["proof (state)\nthis:\n  \\<exists>r. non_empty_cycle_root r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_cycle_subset_equals:\n  assumes \"cycle x\"\n      and \"cycle y\"\n      and \"x \\<le> y\"\n      and \"x \\<noteq> 0\"\n    shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (metis assms le_bot non_empty_cycle_root_subset_equals_change_root non_empty_cycle_root_iff)"], ["", "lemma cycle_root_iff:\n  \"(\\<exists>r . cycle_root r x) \\<longleftrightarrow> cycle x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. cycle_root r x) = cycle x", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (\\<exists>r. cycle_root r x) = cycle x\n 2. x \\<noteq> 0 \\<Longrightarrow> (\\<exists>r. cycle_root r x) = cycle x", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (\\<exists>r. cycle_root r x) = cycle x\n 2. x \\<noteq> 0 \\<Longrightarrow> (\\<exists>r. cycle_root r x) = cycle x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>r. cycle_root r x) = cycle x", "using path_def point_exists"], ["proof (prove)\nusing this:\n  x = 0\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n  \\<exists>x. point x\n\ngoal (1 subgoal):\n 1. (\\<exists>r. cycle_root r x) = cycle x", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>r. cycle_root r x) = cycle x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> (\\<exists>r. cycle_root r x) = cycle x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> (\\<exists>r. cycle_root r x) = cycle x", "assume \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> (\\<exists>r. cycle_root r x) = cycle x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>r. cycle_root r x) = cycle x", "using cycle_root_non_empty non_empty_cycle_root_iff"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ?x \\<noteq> 0 \\<Longrightarrow>\n  cycle_root ?r ?x = non_empty_cycle_root ?r ?x\n  (\\<exists>r. non_empty_cycle_root r ?x) = (cycle ?x \\<and> ?x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>r. cycle_root r x) = cycle x", "by simp"], ["proof (state)\nthis:\n  (\\<exists>r. cycle_root r x) = cycle x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Backwards terminating and backwards finite\\<close>"], ["", "lemma backward_terminating_path_root_iff:\n  \"(\\<exists>r . backward_terminating_path_root r x) \\<longleftrightarrow> backward_terminating_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. backward_terminating_path_root r x) =\n    backward_terminating_path x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>r. backward_terminating_path_root r x \\<Longrightarrow>\n    backward_terminating_path x\n 2. backward_terminating_path x \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "assume \"\\<exists>r . backward_terminating_path_root r x\""], ["proof (state)\nthis:\n  \\<exists>r. backward_terminating_path_root r x\n\ngoal (2 subgoals):\n 1. \\<exists>r. backward_terminating_path_root r x \\<Longrightarrow>\n    backward_terminating_path x\n 2. backward_terminating_path x \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "thus \"backward_terminating_path x\""], ["proof (prove)\nusing this:\n  \\<exists>r. backward_terminating_path_root r x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x", "using backward_terminating_path_root"], ["proof (prove)\nusing this:\n  \\<exists>r. backward_terminating_path_root r x\n  backward_terminating_path_root ?r ?x \\<Longrightarrow>\n  backward_terminating_path ?x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x", "by fastforce"], ["proof (state)\nthis:\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. backward_terminating_path x \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "assume 1: \"backward_terminating_path x\""], ["proof (state)\nthis:\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "show \"\\<exists>r . backward_terminating_path_root r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. backward_terminating_path_root r x", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>r. backward_terminating_path_root r x\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>r. backward_terminating_path_root r x\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r. backward_terminating_path_root r x", "using point_exists zero_backward_terminating_path_root"], ["proof (prove)\nusing this:\n  x = 0\n  \\<exists>x. point x\n  point ?r \\<Longrightarrow> backward_terminating_path_root ?r 0\n\ngoal (1 subgoal):\n 1. \\<exists>r. backward_terminating_path_root r x", "by blast"], ["proof (state)\nthis:\n  \\<exists>r. backward_terminating_path_root r x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "let ?r = \"start_points x\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "assume \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "hence 2: \"is_point ?r\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_point (start_points x)", "using 1 start_point_iff2 backward_terminating_iff1"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  backward_terminating_path x\n  path ?x \\<Longrightarrow> is_point (start_points ?x) = has_start_points ?x\n  path ?x \\<Longrightarrow>\n  backward_terminating ?x = (has_start_points ?x \\<or> ?x = 0)\n\ngoal (1 subgoal):\n 1. is_point (start_points x)", "by fastforce"], ["proof (state)\nthis:\n  is_point (start_points x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have 3: \"x;?r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; start_points x = 0", "by (metis inf_top.right_neutral modular_1_aux')"], ["proof (state)\nthis:\n  x ; start_points x = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have \"x;1;x \\<le> x;1;x;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 ; x \\<le> x ; 1 ; x ; x\\<^sup>T ; x", "using comp_assoc mult_isol x_leq_triple_x"], ["proof (prove)\nusing this:\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n  ?x \\<le> ?x ; ?x\\<^sup>T ; ?x\n\ngoal (1 subgoal):\n 1. x ; 1 ; x \\<le> x ; 1 ; x ; x\\<^sup>T ; x", "by fastforce"], ["proof (state)\nthis:\n  x ; 1 ; x \\<le> x ; 1 ; x ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "also"], ["proof (state)\nthis:\n  x ; 1 ; x \\<le> x ; 1 ; x ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have \"... \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 ; x ; x\\<^sup>T ; x\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; x\\<^sup>T ; x", "using 1 mult_isor path_def"], ["proof (prove)\nusing this:\n  backward_terminating_path x\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n  path ?x \\<equiv> connected ?x \\<and> is_p_fun ?x \\<and> is_inj ?x\n\ngoal (1 subgoal):\n 1. x ; 1 ; x ; x\\<^sup>T ; x\n    \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; x\\<^sup>T ; x", "by blast"], ["proof (state)\nthis:\n  x ; 1 ; x ; x\\<^sup>T ; x\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "also"], ["proof (state)\nthis:\n  x ; 1 ; x ; x\\<^sup>T ; x\n  \\<le> (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have \"... = (1' + x\\<^sup>+ + x\\<^sup>T\\<^sup>+);x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; x\\<^sup>T ; x =\n    (1' + x\\<^sup>+ + x\\<^sup>T\\<^sup>+) ; x\\<^sup>T ; x", "by (metis star_star_plus star_unfoldl_eq sup.commute)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; x\\<^sup>T ; x =\n  (1' + x\\<^sup>+ + x\\<^sup>T\\<^sup>+) ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ; x\\<^sup>T ; x =\n  (1' + x\\<^sup>+ + x\\<^sup>T\\<^sup>+) ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have \"... = x\\<^sup>T;x + x\\<^sup>+;x\\<^sup>T;x + x\\<^sup>T\\<^sup>+;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1' + x\\<^sup>+ + x\\<^sup>T\\<^sup>+) ; x\\<^sup>T ; x =\n    x\\<^sup>T ; x + x\\<^sup>+ ; x\\<^sup>T ; x +\n    x\\<^sup>T\\<^sup>+ ; x\\<^sup>T ; x", "by (metis distrib_right' mult_onel)"], ["proof (state)\nthis:\n  (1' + x\\<^sup>+ + x\\<^sup>T\\<^sup>+) ; x\\<^sup>T ; x =\n  x\\<^sup>T ; x + x\\<^sup>+ ; x\\<^sup>T ; x +\n  x\\<^sup>T\\<^sup>+ ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "also"], ["proof (state)\nthis:\n  (1' + x\\<^sup>+ + x\\<^sup>T\\<^sup>+) ; x\\<^sup>T ; x =\n  x\\<^sup>T ; x + x\\<^sup>+ ; x\\<^sup>T ; x +\n  x\\<^sup>T\\<^sup>+ ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have \"... = x\\<^sup>T;(x + x\\<^sup>T\\<^sup>\\<star>;x\\<^sup>T;x) + x\\<^sup>+;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; x + x\\<^sup>+ ; x\\<^sup>T ; x +\n    x\\<^sup>T\\<^sup>+ ; x\\<^sup>T ; x =\n    x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n    x\\<^sup>+ ; x\\<^sup>T ; x", "using comp_assoc distrib_left sup.commute sup.assoc"], ["proof (prove)\nusing this:\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?a ; (?b + ?c) = ?a ; ?b + ?a ; ?c\n  ?a + ?b = ?b + ?a\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; x + x\\<^sup>+ ; x\\<^sup>T ; x +\n    x\\<^sup>T\\<^sup>+ ; x\\<^sup>T ; x =\n    x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n    x\\<^sup>+ ; x\\<^sup>T ; x", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T ; x + x\\<^sup>+ ; x\\<^sup>T ; x +\n  x\\<^sup>T\\<^sup>+ ; x\\<^sup>T ; x =\n  x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n  x\\<^sup>+ ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; x + x\\<^sup>+ ; x\\<^sup>T ; x +\n  x\\<^sup>T\\<^sup>+ ; x\\<^sup>T ; x =\n  x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n  x\\<^sup>+ ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have \"... \\<le> x\\<^sup>T;1 + x\\<^sup>+;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n    x\\<^sup>+ ; x\\<^sup>T ; x\n    \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; x\\<^sup>T ; x", "using join_iso mult_isol"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x + ?z \\<le> ?y + ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n    x\\<^sup>+ ; x\\<^sup>T ; x\n    \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; x\\<^sup>T ; x", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n  x\\<^sup>+ ; x\\<^sup>T ; x\n  \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; (x + x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>T ; x) +\n  x\\<^sup>+ ; x\\<^sup>T ; x\n  \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "have \"... \\<le> x\\<^sup>T;1 + x\\<^sup>+;1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 + x\\<^sup>+ ; x\\<^sup>T ; x\n    \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; 1'", "using 1"], ["proof (prove)\nusing this:\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; 1 + x\\<^sup>+ ; x\\<^sup>T ; x\n    \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; 1'", "by (metis comp_assoc join_isol mult_isol path_def is_p_fun_def)"], ["proof (state)\nthis:\n  x\\<^sup>T ; 1 + x\\<^sup>+ ; x\\<^sup>T ; x\n  \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; 1'\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "finally"], ["proof (chain)\npicking this:\n  x ; 1 ; x \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; 1'", "have \"-(x\\<^sup>T;1) \\<cdot> x;1;x \\<le> x\\<^sup>+\""], ["proof (prove)\nusing this:\n  x ; 1 ; x \\<le> x\\<^sup>T ; 1 + x\\<^sup>+ ; 1'\n\ngoal (1 subgoal):\n 1. - (x\\<^sup>T ; 1) \\<cdot> x ; 1 ; x \\<le> x\\<^sup>+", "by (simp add: galois_1 inf.commute)"], ["proof (state)\nthis:\n  - (x\\<^sup>T ; 1) \\<cdot> x ; 1 ; x \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "hence \"?r;x \\<le> x\\<^sup>+\""], ["proof (prove)\nusing this:\n  - (x\\<^sup>T ; 1) \\<cdot> x ; 1 ; x \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. connected_root (start_points x) x", "by (metis inf_commute one_compl ra_1)"], ["proof (state)\nthis:\n  connected_root (start_points x) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "hence \"backward_terminating_path_root ?r x\""], ["proof (prove)\nusing this:\n  connected_root (start_points x) x\n\ngoal (1 subgoal):\n 1. backward_terminating_path_root (start_points x) x", "using 1 2 3"], ["proof (prove)\nusing this:\n  connected_root (start_points x) x\n  backward_terminating_path x\n  is_point (start_points x)\n  x ; start_points x = 0\n\ngoal (1 subgoal):\n 1. backward_terminating_path_root (start_points x) x", "by (simp add: point_is_point backward_finite_path_root_def path_def)"], ["proof (state)\nthis:\n  backward_terminating_path_root (start_points x) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_terminating_path_root r x", "thus ?thesis"], ["proof (prove)\nusing this:\n  backward_terminating_path_root (start_points x) x\n\ngoal (1 subgoal):\n 1. \\<exists>r. backward_terminating_path_root r x", ".."], ["proof (state)\nthis:\n  \\<exists>r. backward_terminating_path_root r x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r. backward_terminating_path_root r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_backward_terminating_path_root_iff:\n  \"backward_terminating_path_root (start_points x) x \\<longleftrightarrow> backward_terminating_path x \\<and> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path_root (start_points x) x =\n    (backward_terminating_path x \\<and> x \\<noteq> 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. backward_terminating_path_root (start_points x) x \\<Longrightarrow>\n    backward_terminating_path x \\<and> x \\<noteq> 0\n 2. backward_terminating_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    backward_terminating_path_root (start_points x) x", "apply (metis backward_finite_path_root_path backward_terminating_path_root_2 conv_zero\n               inf.cobounded1 non_empty_cycle_root_non_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    backward_terminating_path_root (start_points x) x", "using backward_terminating_path_root_iff root_equals_start_points"], ["proof (prove)\nusing this:\n  (\\<exists>r. backward_terminating_path_root r ?x) =\n  backward_terminating_path ?x\n  \\<lbrakk>backward_terminating_path_root ?r ?x; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?r = start_points ?x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    backward_terminating_path_root (start_points x) x", "by blast"], ["", "lemma non_empty_backward_terminating_path_root_iff':\n  \"backward_finite_path_root (start_points x) x \\<longleftrightarrow> backward_terminating_path x \\<and> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_finite_path_root (start_points x) x =\n    (backward_terminating_path x \\<and> x \\<noteq> 0)", "using start_point_no_predecessor non_empty_backward_terminating_path_root_iff"], ["proof (prove)\nusing this:\n  ?x ; start_points ?x = 0\n  backward_terminating_path_root (start_points ?x) ?x =\n  (backward_terminating_path ?x \\<and> ?x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. backward_finite_path_root (start_points x) x =\n    (backward_terminating_path x \\<and> x \\<noteq> 0)", "by simp"], ["", "lemma backward_finite_path_root_iff:\n  \"(\\<exists>r . backward_finite_path_root r x) \\<longleftrightarrow> backward_finite_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. backward_finite_path_root r x) = backward_finite_path x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>r. backward_finite_path_root r x \\<Longrightarrow>\n    backward_finite_path x\n 2. backward_finite_path x \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x", "assume \"\\<exists>r . backward_finite_path_root r x\""], ["proof (state)\nthis:\n  \\<exists>r. backward_finite_path_root r x\n\ngoal (2 subgoals):\n 1. \\<exists>r. backward_finite_path_root r x \\<Longrightarrow>\n    backward_finite_path x\n 2. backward_finite_path x \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x", "thus \"backward_finite_path x\""], ["proof (prove)\nusing this:\n  \\<exists>r. backward_finite_path_root r x\n\ngoal (1 subgoal):\n 1. backward_finite_path x", "by (meson backward_finite_iff_msc non_empty_cycle_root_msc backward_finite_path_root_path\n              backward_finite_path_root_terminating_or_cycle backward_terminating_path_root)"], ["proof (state)\nthis:\n  backward_finite_path x\n\ngoal (1 subgoal):\n 1. backward_finite_path x \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. backward_finite_path x \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x", "assume \"backward_finite_path x\""], ["proof (state)\nthis:\n  backward_finite_path x\n\ngoal (1 subgoal):\n 1. backward_finite_path x \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x", "thus \"\\<exists>r . backward_finite_path_root r x\""], ["proof (prove)\nusing this:\n  backward_finite_path x\n\ngoal (1 subgoal):\n 1. \\<exists>r. backward_finite_path_root r x", "by (metis backward_finite_iff_msc point_exists non_empty_cycle_root_iff\n              zero_backward_terminating_path_root backward_terminating_path_root_iff)"], ["proof (state)\nthis:\n  \\<exists>r. backward_finite_path_root r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_backward_finite_path_root_iff:\n  \"(\\<exists>r . backward_finite_path_root r x \\<and> r \\<le> x;1) \\<longleftrightarrow> backward_finite_path x \\<and> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. backward_finite_path_root r x \\<and> r \\<le> x ; 1) =\n    (backward_finite_path x \\<and> x \\<noteq> 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>r.\n       backward_finite_path_root r x \\<and> r \\<le> x ; 1 \\<Longrightarrow>\n    backward_finite_path x \\<and> x \\<noteq> 0\n 2. backward_finite_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x \\<and> r \\<le> x ; 1", "apply (metis backward_finite_path_root_iff annir backward_finite_path_root_def le_bot\n              no_end_point_char ss_p18)"], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_finite_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x \\<and> r \\<le> x ; 1", "using backward_finite_path_root_iff backward_finite_path_root_def point_def root_in_edge_sources"], ["proof (prove)\nusing this:\n  (\\<exists>r. backward_finite_path_root r ?x) = backward_finite_path ?x\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  \\<lbrakk>connected_root ?r ?x; ?x \\<noteq> 0; is_vector ?r\\<rbrakk>\n  \\<Longrightarrow> ?r \\<le> ?x ; 1\n\ngoal (1 subgoal):\n 1. backward_finite_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r. backward_finite_path_root r x \\<and> r \\<le> x ; 1", "by blast"], ["", "text \\<open>Terminating\\<close>"], ["", "lemma terminating_path_root_end_aux:\n  assumes \"terminating_path x\"\n    shows \"\\<exists>r e . terminating_path_root_end r x e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r e. terminating_path_root_end r x e", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>r e. terminating_path_root_end r x e\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>r e. terminating_path_root_end r x e\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r e. terminating_path_root_end r x e", "using point_exists zero_backward_terminating_path_root"], ["proof (prove)\nusing this:\n  x = 0\n  \\<exists>x. point x\n  point ?r \\<Longrightarrow> backward_terminating_path_root ?r 0\n\ngoal (1 subgoal):\n 1. \\<exists>r e. terminating_path_root_end r x e", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>r e. terminating_path_root_end r x e\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "assume 1: \"\\<not>(x = 0)\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "have 2: \"backward_terminating_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path x", "using assms"], ["proof (prove)\nusing this:\n  terminating_path x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x", "by simp"], ["proof (state)\nthis:\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "from this"], ["proof (chain)\npicking this:\n  backward_terminating_path x", "obtain r where 3: \"backward_terminating_path_root r x\""], ["proof (prove)\nusing this:\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        backward_terminating_path_root r x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using backward_terminating_path_root_iff"], ["proof (prove)\nusing this:\n  backward_terminating_path x\n  (\\<exists>r. backward_terminating_path_root r ?x) =\n  backward_terminating_path ?x\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        backward_terminating_path_root r x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  backward_terminating_path_root r x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "have \"backward_terminating_path (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_terminating_path (x\\<^sup>T)", "using 2"], ["proof (prove)\nusing this:\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. backward_terminating_path (x\\<^sup>T)", "by (metis assms backward_terminating_iff1 conv_backward_terminating_path conv_invol\n                      conv_zero inf_top.left_neutral)"], ["proof (state)\nthis:\n  backward_terminating_path (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "from this"], ["proof (chain)\npicking this:\n  backward_terminating_path (x\\<^sup>T)", "obtain e where 4: \"backward_terminating_path_root e (x\\<^sup>T)\""], ["proof (prove)\nusing this:\n  backward_terminating_path (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        backward_terminating_path_root e (x\\<^sup>T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using backward_terminating_path_root_iff"], ["proof (prove)\nusing this:\n  backward_terminating_path (x\\<^sup>T)\n  (\\<exists>r. backward_terminating_path_root r ?x) =\n  backward_terminating_path ?x\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        backward_terminating_path_root e (x\\<^sup>T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  backward_terminating_path_root e (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "have \"r \\<le> x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "using 1 3 root_in_edge_sources backward_finite_path_root_def point_def"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  backward_terminating_path_root r x\n  \\<lbrakk>connected_root ?r ?x; ?x \\<noteq> 0; is_vector ?r\\<rbrakk>\n  \\<Longrightarrow> ?r \\<le> ?x ; 1\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n\ngoal (1 subgoal):\n 1. r \\<le> x ; 1", "by fastforce"], ["proof (state)\nthis:\n  r \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "also"], ["proof (state)\nthis:\n  r \\<le> x ; 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "have \"... = x\\<^sup>+;e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 = x\\<^sup>+ ; e", "using 4 connected_root_iff3 backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  backward_terminating_path_root e (x\\<^sup>T)\n  point ?r \\<Longrightarrow>\n  connected_root ?r ?x = (?x\\<^sup>T ; 1 = ?x\\<^sup>T\\<^sup>+ ; ?r)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. x ; 1 = x\\<^sup>+ ; e", "by fastforce"], ["proof (state)\nthis:\n  x ; 1 = x\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "also"], ["proof (state)\nthis:\n  x ; 1 = x\\<^sup>+ ; e\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "have \"... \\<le> x\\<^sup>\\<star>;e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; e \\<le> x\\<^sup>\\<star> ; e", "by (simp add: mult_isor)"], ["proof (state)\nthis:\n  x\\<^sup>+ ; e \\<le> x\\<^sup>\\<star> ; e\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "finally"], ["proof (chain)\npicking this:\n  r \\<le> x\\<^sup>\\<star> ; e", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<le> x\\<^sup>\\<star> ; e\n\ngoal (1 subgoal):\n 1. \\<exists>r e. terminating_path_root_end r x e", "using 3 4 backward_finite_path_root_def"], ["proof (prove)\nusing this:\n  r \\<le> x\\<^sup>\\<star> ; e\n  backward_terminating_path_root r x\n  backward_terminating_path_root e (x\\<^sup>T)\n  backward_finite_path_root ?r ?x \\<equiv>\n  connected_root ?r ?x \\<and> is_inj ?x \\<and> is_p_fun ?x \\<and> point ?r\n\ngoal (1 subgoal):\n 1. \\<exists>r e. terminating_path_root_end r x e", "by blast"], ["proof (state)\nthis:\n  \\<exists>r e. terminating_path_root_end r x e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminating_path_root_end_iff:\n  \"(\\<exists>r e . terminating_path_root_end r x e) \\<longleftrightarrow> terminating_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r e. terminating_path_root_end r x e) = terminating_path x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>r e. terminating_path_root_end r x e \\<Longrightarrow>\n    terminating_path x\n 2. terminating_path x \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "assume 1: \"\\<exists>r e . terminating_path_root_end r x e\""], ["proof (state)\nthis:\n  \\<exists>r e. terminating_path_root_end r x e\n\ngoal (2 subgoals):\n 1. \\<exists>r e. terminating_path_root_end r x e \\<Longrightarrow>\n    terminating_path x\n 2. terminating_path x \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "show \"terminating_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminating_path x", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> terminating_path x\n 2. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> terminating_path x\n 2. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. terminating_path x", "by (simp add: is_inj_def is_p_fun_def path_def)"], ["proof (state)\nthis:\n  terminating_path x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "assume \"\\<not>(x = 0)\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "hence 2: \"\\<not> many_strongly_connected x\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> many_strongly_connected x", "using 1 cycle_root_end_empty"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  \\<exists>r e. terminating_path_root_end r x e\n  \\<lbrakk>terminating_path_root_end ?r ?x ?e;\n   many_strongly_connected ?x\\<rbrakk>\n  \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> many_strongly_connected x", "by blast"], ["proof (state)\nthis:\n  \\<not> many_strongly_connected x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "hence 3: \"backward_terminating_path x\""], ["proof (prove)\nusing this:\n  \\<not> many_strongly_connected x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x", "using 1 backward_terminating_path_root terminating_path_root_end_backward_terminating"], ["proof (prove)\nusing this:\n  \\<not> many_strongly_connected x\n  \\<exists>r e. terminating_path_root_end r x e\n  backward_terminating_path_root ?r ?x \\<Longrightarrow>\n  backward_terminating_path ?x\n  terminating_path_root_end ?r ?x ?e \\<Longrightarrow>\n  backward_terminating_path_root ?r ?x\n\ngoal (1 subgoal):\n 1. backward_terminating_path x", "by blast"], ["proof (state)\nthis:\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "have \"\\<exists>e . backward_finite_path_root e (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e. backward_finite_path_root e (x\\<^sup>T)", "using 1 terminating_path_root_end_converse"], ["proof (prove)\nusing this:\n  \\<exists>r e. terminating_path_root_end r x e\n  terminating_path_root_end ?r ?x ?e \\<Longrightarrow>\n  terminating_path_root_end ?e (?x\\<^sup>T) ?r\n\ngoal (1 subgoal):\n 1. \\<exists>e. backward_finite_path_root e (x\\<^sup>T)", "by blast"], ["proof (state)\nthis:\n  \\<exists>e. backward_finite_path_root e (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "hence \"backward_terminating_path (x\\<^sup>T)\""], ["proof (prove)\nusing this:\n  \\<exists>e. backward_finite_path_root e (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. backward_terminating_path (x\\<^sup>T)", "using 1 backward_terminating_path_root terminating_path_root_end_converse"], ["proof (prove)\nusing this:\n  \\<exists>e. backward_finite_path_root e (x\\<^sup>T)\n  \\<exists>r e. terminating_path_root_end r x e\n  backward_terminating_path_root ?r ?x \\<Longrightarrow>\n  backward_terminating_path ?x\n  terminating_path_root_end ?r ?x ?e \\<Longrightarrow>\n  terminating_path_root_end ?e (?x\\<^sup>T) ?r\n\ngoal (1 subgoal):\n 1. backward_terminating_path (x\\<^sup>T)", "by blast"], ["proof (state)\nthis:\n  backward_terminating_path (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "hence \"forward_terminating_path x\""], ["proof (prove)\nusing this:\n  backward_terminating_path (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. forward_terminating_path x", "by (simp add: conv_backward_terminating_path)"], ["proof (state)\nthis:\n  forward_terminating_path x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> terminating_path x", "thus ?thesis"], ["proof (prove)\nusing this:\n  forward_terminating_path x\n\ngoal (1 subgoal):\n 1. terminating_path x", "using 3"], ["proof (prove)\nusing this:\n  forward_terminating_path x\n  backward_terminating_path x\n\ngoal (1 subgoal):\n 1. terminating_path x", "by (simp add: inf.boundedI)"], ["proof (state)\nthis:\n  terminating_path x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminating_path x\n\ngoal (1 subgoal):\n 1. terminating_path x \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. terminating_path x \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "assume \"terminating_path x\""], ["proof (state)\nthis:\n  terminating_path x\n\ngoal (1 subgoal):\n 1. terminating_path x \\<Longrightarrow>\n    \\<exists>r e. terminating_path_root_end r x e", "thus \"\\<exists>r e . terminating_path_root_end r x e\""], ["proof (prove)\nusing this:\n  terminating_path x\n\ngoal (1 subgoal):\n 1. \\<exists>r e. terminating_path_root_end r x e", "using terminating_path_root_end_aux"], ["proof (prove)\nusing this:\n  terminating_path x\n  terminating_path ?x \\<Longrightarrow>\n  \\<exists>r e. terminating_path_root_end r ?x e\n\ngoal (1 subgoal):\n 1. \\<exists>r e. terminating_path_root_end r x e", "by blast"], ["proof (state)\nthis:\n  \\<exists>r e. terminating_path_root_end r x e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_terminating_path_root_end_iff:\n  \"terminating_path_root_end (start_points x) x (end_points x) \\<longleftrightarrow> terminating_path x \\<and> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminating_path_root_end (start_points x) x (end_points x) =\n    (terminating_path x \\<and> x \\<noteq> 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. terminating_path_root_end (start_points x) x\n     (end_points x) \\<Longrightarrow>\n    terminating_path x \\<and> x \\<noteq> 0\n 2. terminating_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    terminating_path_root_end (start_points x) x (end_points x)", "apply (metis conv_zero non_empty_backward_terminating_path_root_iff terminating_path_root_end_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminating_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    terminating_path_root_end (start_points x) x (end_points x)", "using terminating_path_root_end_iff terminating_path_root_end_forward_terminating\n      root_equals_end_points terminating_path_root_end_backward_terminating root_equals_start_points"], ["proof (prove)\nusing this:\n  (\\<exists>r e. terminating_path_root_end r ?x e) = terminating_path ?x\n  terminating_path_root_end ?r ?x ?e \\<Longrightarrow>\n  backward_terminating_path_root ?e (?x\\<^sup>T)\n  \\<lbrakk>backward_terminating_path_root ?r (?x\\<^sup>T);\n   ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?r = end_points ?x\n  terminating_path_root_end ?r ?x ?e \\<Longrightarrow>\n  backward_terminating_path_root ?r ?x\n  \\<lbrakk>backward_terminating_path_root ?r ?x; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?r = start_points ?x\n\ngoal (1 subgoal):\n 1. terminating_path x \\<and> x \\<noteq> 0 \\<Longrightarrow>\n    terminating_path_root_end (start_points x) x (end_points x)", "by blast"], ["", "lemma non_empty_finite_path_root_end_iff:\n  \"finite_path_root_end (start_points x) x (end_points x) \\<longleftrightarrow> terminating_path x \\<and> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_path_root_end (start_points x) x (end_points x) =\n    (terminating_path x \\<and> x \\<noteq> 0)", "using non_empty_terminating_path_root_end_iff end_point_no_successor"], ["proof (prove)\nusing this:\n  terminating_path_root_end (start_points ?x) ?x (end_points ?x) =\n  (terminating_path ?x \\<and> ?x \\<noteq> 0)\n  ?x\\<^sup>T ; end_points ?x = 0\n\ngoal (1 subgoal):\n 1. finite_path_root_end (start_points x) x (end_points x) =\n    (terminating_path x \\<and> x \\<noteq> 0)", "by simp"], ["", "end"], ["", "(* relation_algebra_rtc_tarski_point *)"], ["", "end"]]}