{"file_name": "/home/qj213/afp-2021-10-22/thys/Relational_Paths/More_Relation_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relational_Paths", "problem_names": ["lemma x_leq_triple_x:\n  \"x \\<le> x;x\\<^sup>T;x\"", "lemma inj_triple:\n  assumes \"is_inj x\"\n    shows \"x = x;x\\<^sup>T;x\"", "lemma p_fun_triple:\n  assumes \"is_p_fun x\"\n    shows \"x = x;x\\<^sup>T;x\"", "lemma loop_backward_forward:\n  \"x\\<^sup>T \\<le> -(1') + x\"", "lemma inj_sur_semi_swap:\n  assumes \"is_sur z\"\n      and \"is_inj x\"\n    shows \"z \\<le> y;x \\<Longrightarrow> x \\<le> y\\<^sup>T;z\"", "lemma inj_sur_semi_swap_short:\n  assumes \"is_sur z\"\n      and \"is_inj x\"\n    shows \"z \\<le> y\\<^sup>T;x \\<Longrightarrow> x \\<le> y;z\"", "lemma bij_swap:\n  assumes \"bijective z\"\n      and \"bijective x\"\n    shows \"z \\<le> y\\<^sup>T;x \\<longleftrightarrow> x \\<le> y;z\"", "lemma ss422iv:\n  assumes \"is_p_fun y\"\n      and \"x \\<le> y\"\n      and \"y;1 \\<le> x;1\"\n    shows \"x = y\"", "lemma ss423conv:\n  assumes \"bijective x\"\n    shows \"x ; y \\<le> z \\<longleftrightarrow> y \\<le> x\\<^sup>T ; z\"", "lemma ss423bij:\n  assumes \"bijective x\"\n    shows \"y ; x\\<^sup>T \\<le> z \\<longleftrightarrow> y \\<le> z ; x\"", "lemma inj_distr:\n  assumes \"is_inj z\"\n    shows \"(x\\<cdot>y);z = (x;z)\\<cdot>(y;z)\"", "lemma test_converse:\n  \"x \\<cdot> 1' = x\\<^sup>T \\<cdot> 1'\"", "lemma injective_down_closed:\n  assumes \"is_inj x\"\n      and \"y \\<le> x\"\n    shows \"is_inj y\"", "lemma injective_sup:\n  assumes \"is_inj t\"\n      and \"e;t\\<^sup>T \\<le> 1'\"\n      and \"is_inj e\"\n    shows \"is_inj (t + e)\"", "lemma vector_meet_comp:\n  assumes \"is_vector v\"\n      and \"is_vector w\"\n    shows \"v;w\\<^sup>T = v\\<cdot>w\\<^sup>T\"", "lemma vector_meet_comp':\n  assumes \"is_vector v\"\n    shows \"v;v\\<^sup>T = v\\<cdot>v\\<^sup>T\"", "lemma vector_meet_comp_x:\n  \"x;1;x\\<^sup>T = x;1\\<cdot>1;x\\<^sup>T\"", "lemma vector_meet_comp_x':\n  \"x;1;x = x;1\\<cdot>1;x\"", "lemma vector_prop1:\n  assumes \"is_vector v\"\n    shows \"-v\\<^sup>T;v = 0\"", "lemma ee:\n  assumes \"is_vector v\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n    shows \"e;e = 0\"", "lemma et:\n  assumes \"is_vector v\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n      and \"t \\<le> v;v\\<^sup>T\"\n    shows \"e;t = 0\"\n      and \"e;t\\<^sup>T = 0\"", "lemma point_swap:\n  assumes \"point p\"\n      and \"point q\"\n    shows \"p \\<le> x;q \\<longleftrightarrow> q \\<le> x\\<^sup>T;p\"", "lemma singleton_injective:\n  assumes \"singleton x\"\n    shows \"is_inj x\"", "lemma injective_inv:\n  assumes \"is_vector v\"\n      and \"singleton e\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n      and \"t \\<le> v;v\\<^sup>T\"\n      and \"is_inj t\"\n    shows \"is_inj (t + e)\"", "lemma singleton_is_point:\n  assumes \"singleton p\"\n    shows \"point (p;1)\"", "lemma singleton_transp:\n  assumes \"singleton p\"\n    shows \"singleton (p\\<^sup>T)\"", "lemma point_to_singleton:\n  assumes \"singleton p\"\n    shows \"singleton (1'\\<cdot>p;p\\<^sup>T)\"", "lemma singleton_singletonT:\n  assumes \"singleton p\"\n    shows \"p;p\\<^sup>T \\<le> 1'\"", "lemma regressively_finite_minimum:\n  \"regressively_finite R \\<Longrightarrow> is_vector v \\<Longrightarrow> v \\<noteq> 0 \\<Longrightarrow> minimum R v \\<noteq> 0\"", "lemma regressively_finite_irreflexive:\n  assumes \"regressively_finite x\"\n    shows \"x \\<le> -1'\"", "lemma point_equations:\n  assumes \"is_point p\"\n  shows \"p;1=p\"\n    and \"1;p=1\"\n    and \"p\\<^sup>T;1=1\"\n    and \"1;p\\<^sup>T=p\\<^sup>T\"", "lemma point_singleton:\n  assumes \"is_point p\"\n      and \"is_vector v\"\n      and \"v \\<noteq> 0\"\n      and \"v \\<le> p\"\n    shows \"v = p\"", "lemma point_not_equal_aux:\n  assumes \"is_point p\"\n      and \"is_point q\"\n    shows \"p\\<noteq>q \\<longleftrightarrow> p \\<cdot> -q \\<noteq> 0\"", "lemma point_not_equal:\n  assumes \"is_point p\"\n      and \"is_point q\"\n    shows \"p\\<noteq>q \\<longleftrightarrow> p\\<le>-q\"\n      and \"p\\<le>-q \\<longleftrightarrow> p;q\\<^sup>T \\<le> -1'\"\n      and \"p;q\\<^sup>T \\<le> -1' \\<longleftrightarrow> p\\<^sup>T;q \\<le> 0\"", "lemma point_is_point:\n  \"point x \\<longleftrightarrow> is_point x\"", "lemma point_in_vector_or_complement:\n  assumes \"point p\"\n      and \"is_vector v\"\n    shows \"p \\<le> v \\<or> p \\<le> -v\"", "lemma point_in_vector_or_complement_iff:\n  assumes \"point p\"\n      and \"is_vector v\"\n    shows \"p \\<le> v \\<longleftrightarrow> \\<not>(p \\<le> -v)\"", "lemma different_points_consequences:\n  assumes \"point p\"\n      and \"point q\"\n      and \"p\\<noteq>q\"\n    shows \"p\\<^sup>T;-q=1\"\n      and \"-q\\<^sup>T;p=1\"\n      and \"-(p\\<^sup>T;-q)=0\"\n      and \"-(-q\\<^sup>T;p)=0\"", "lemma singleton_pq:\n  assumes \"point p\"\n      and \"point q\"\n    shows \"singleton (p;q\\<^sup>T)\"", "lemma singleton_equal_aux:\n  assumes \"singleton p\"\n      and \"singleton q\"\n      and \"q\\<le>p\"\n    shows \"p \\<le> q;1\"", "lemma singleton_equal:\n assumes \"singleton p\"\n     and \"singleton q\"\n     and \"q\\<le>p\"\n   shows \"q=p\"", "lemma singleton_nonsplit:\n  assumes \"singleton p\"\n      and \"x\\<le>p\"\n    shows \"x=0 \\<or> x=p\"", "lemma singleton_nonzero:\n  assumes \"singleton p\"\n    shows \"p\\<noteq>0\"", "lemma singleton_sum:\n  assumes \"singleton p\"\n    shows \"p \\<le> x+y \\<longleftrightarrow> (p\\<le>x \\<or> p\\<le>y)\"", "lemma singleton_iff:\n \"singleton x \\<longleftrightarrow> x \\<noteq> 0 \\<and> x\\<^sup>T;1;x + x;1;x\\<^sup>T \\<le> 1'\"", "lemma singleton_not_atom_in_relation_algebra_tarski:\n assumes \"p\\<noteq>0\"\n     and \"\\<forall>x . x\\<le>p \\<longrightarrow> x=0 \\<or> x=p\"\n   shows \"singleton p\"", "lemma point_exists:\n  \"\\<exists>x . point x\"", "lemma point_below_vector:\n  assumes \"is_vector v\"\n      and \"v \\<noteq> 0\"\n    shows \"\\<exists>x . point x \\<and> x \\<le> v\"", "lemma atom_is_singleton:\n  assumes \"p\\<noteq>0\"\n      and \"\\<forall>x . x\\<le>p \\<longrightarrow> x=0 \\<or> x=p\"\n    shows \"singleton p\"", "lemma singleton_iff_atom:\n  \"singleton p \\<longleftrightarrow> p\\<noteq>0 \\<and> (\\<forall>x . x\\<le>p \\<longrightarrow> x=0 \\<or> x=p)\"", "lemma maddux_tarski:\n  assumes \"x\\<noteq>0\"\n  shows \"\\<exists>y . y\\<noteq>0 \\<and> y\\<le>x \\<and> is_p_fun y\"", "lemma intermediate_point_theorem:\n  assumes \"point p\"\n      and \"point r\"\n    shows \"p \\<le> x;y;r \\<longleftrightarrow> (\\<exists>q . point q \\<and> p \\<le> x;q \\<and> q \\<le> y;r)\"", "lemma unfoldl_inductl_implies_unfoldr:\n  assumes \"\\<And>x. 1' + x;(rtc x) \\<le> rtc x\"\n      and \"\\<And>x y z. x+y;z \\<le> z \\<Longrightarrow> rtc(y);x \\<le> z\"\n    shows \"1' + rtc(x);x \\<le> rtc x\"", "lemma star_transpose_swap:\n  assumes \"\\<And>x. 1' + x;(rtc x) \\<le> rtc x\"\n      and \"\\<And>x y z. x+y;z \\<le> z \\<Longrightarrow> rtc(y);x \\<le> z\"\n    shows \"rtc(x\\<^sup>T) = (rtc x)\\<^sup>T\"", "lemma unfoldl_inductl_implies_inductr:\n  assumes \"\\<And>x. 1' + x;(rtc x) \\<le> rtc x\"\n      and \"\\<And>x y z. x+y;z \\<le> z \\<Longrightarrow> rtc(y);x \\<le> z\"\n    shows \"x+z;y \\<le> z \\<Longrightarrow> x;rtc(y) \\<le> z\"", "lemma star_denest_10:\n  assumes \"x;y=0\"\n    shows \"(x+y)\\<^sup>\\<star> = y;y\\<^sup>\\<star>;x\\<^sup>\\<star>+x\\<^sup>\\<star>\"", "lemma star_star_plus:\n  \"x\\<^sup>\\<star> + y\\<^sup>\\<star> = x\\<^sup>+ + y\\<^sup>\\<star>\"", "lemma cancel_separate:\n  assumes \"x ; y \\<le> 1'\"\n  shows \"x\\<^sup>\\<star> ; y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\"", "lemma cancel_separate_inj_converse:\n  assumes \"is_inj x\"\n    shows \"x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star> = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"", "lemma cancel_separate_p_fun_converse:\n  assumes \"is_p_fun x\"\n    shows \"x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>\\<star> = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"", "lemma cancel_separate_converse_idempotent:\n  assumes \"is_inj x\"\n      and \"is_p_fun x\"\n    shows \"(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"", "lemma triple_star:\n  assumes \"is_inj x\"\n      and \"is_p_fun x\"\n    shows \"x\\<^sup>\\<star>;x\\<^sup>T\\<^sup>\\<star>;x\\<^sup>\\<star> = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"", "lemma inj_xxts:\n  assumes \"is_inj x\"\n    shows \"x;x\\<^sup>T\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\"", "lemma plus_top:\n  \"x\\<^sup>+;1 = x;1\"", "lemma top_plus:\n  \"1;x\\<^sup>+ = 1;x\"", "lemma plus_conv:\n  \"(x\\<^sup>+)\\<^sup>T = x\\<^sup>T\\<^sup>+\"", "lemma inj_implies_step_forwards_backwards:\n  assumes \"is_inj x\"\n    shows \"x\\<^sup>\\<star>;(x\\<^sup>+\\<cdot>1');1 \\<le> x\\<^sup>T;1\"", "lemma acyclic_inv:\n  assumes \"is_acyclic t\"\n      and \"is_vector v\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n      and \"t \\<le> v;v\\<^sup>T\"\n    shows \"is_acyclic (t + e)\"", "lemma acyclic_single_step:\n  assumes \"is_acyclic x\"\n    shows \"x \\<le> -1'\"", "lemma acyclic_reachable_points:\n  assumes \"is_point p\"\n      and \"is_point q\"\n      and \"p \\<le> x;q\"\n      and \"is_acyclic x\"\n    shows \"p\\<noteq>q\"", "lemma acyclic_trans:\n assumes \"is_acyclic x\"\n   shows \"x \\<le> -(x\\<^sup>T\\<^sup>+)\"", "lemma acyclic_trans':\n assumes \"is_acyclic x\"\n   shows \"x\\<^sup>\\<star> \\<le> -(x\\<^sup>T\\<^sup>+)\"", "lemma regressively_finite_acyclic:\n  assumes \"regressively_finite x\"\n    shows \"is_acyclic x\"", "lemma power_suc_below_plus:\n  \"x \\<up> Suc n \\<le> x\\<^sup>+\"", "lemma point_loop_not_acyclic:\n  assumes \"is_point p\"\n      and \"p \\<le> x \\<up> Suc n ; p\"\n    shows \"\\<not> is_acyclic x\"", "lemma acyclic_power_vanishes:\n  assumes \"is_acyclic x\"\n    shows \"\\<exists>n . x \\<up> Suc n = 0\"", "lemma acyclic_regressively_finite:\n  assumes \"is_acyclic x\"\n    shows \"regressively_finite x\"", "lemma acyclic_is_regressively_finite:\n  \"is_acyclic x \\<longleftrightarrow> regressively_finite x\""], "translations": [["", "lemma x_leq_triple_x:\n  \"x \\<le> x;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "have \"x = x;1' \\<cdot> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x ; 1' \\<cdot> 1", "by simp"], ["proof (state)\nthis:\n  x = x ; 1' \\<cdot> 1\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "also"], ["proof (state)\nthis:\n  x = x ; 1' \\<cdot> 1\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "have \"... \\<le> (x \\<cdot> 1;1'\\<^sup>T);(1' \\<cdot> x\\<^sup>T;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1' \\<cdot> 1\n    \\<le> (x \\<cdot> 1 ; 1'\\<^sup>T) ; (1' \\<cdot> x\\<^sup>T ; 1)", "by (rule dedekind)"], ["proof (state)\nthis:\n  x ; 1' \\<cdot> 1\n  \\<le> (x \\<cdot> 1 ; 1'\\<^sup>T) ; (1' \\<cdot> x\\<^sup>T ; 1)\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "also"], ["proof (state)\nthis:\n  x ; 1' \\<cdot> 1\n  \\<le> (x \\<cdot> 1 ; 1'\\<^sup>T) ; (1' \\<cdot> x\\<^sup>T ; 1)\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "have \"... = x;(x\\<^sup>T;1 \\<cdot> 1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> 1 ; 1'\\<^sup>T) ; (1' \\<cdot> x\\<^sup>T ; 1) =\n    x ; (x\\<^sup>T ; 1 \\<cdot> 1')", "by (simp add: inf.commute)"], ["proof (state)\nthis:\n  (x \\<cdot> 1 ; 1'\\<^sup>T) ; (1' \\<cdot> x\\<^sup>T ; 1) =\n  x ; (x\\<^sup>T ; 1 \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "also"], ["proof (state)\nthis:\n  (x \\<cdot> 1 ; 1'\\<^sup>T) ; (1' \\<cdot> x\\<^sup>T ; 1) =\n  x ; (x\\<^sup>T ; 1 \\<cdot> 1')\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "have \"... \\<le> x;(x\\<^sup>T \\<cdot> 1';1\\<^sup>T);(1 \\<cdot> (x\\<^sup>T)\\<^sup>T;1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (x\\<^sup>T ; 1 \\<cdot> 1')\n    \\<le> x ; (x\\<^sup>T \\<cdot> 1' ; 1\\<^sup>T) ;\n          (1 \\<cdot> (x\\<^sup>T)\\<^sup>T ; 1')", "by (metis comp_assoc dedekind mult_isol)"], ["proof (state)\nthis:\n  x ; (x\\<^sup>T ; 1 \\<cdot> 1')\n  \\<le> x ; (x\\<^sup>T \\<cdot> 1' ; 1\\<^sup>T) ;\n        (1 \\<cdot> (x\\<^sup>T)\\<^sup>T ; 1')\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "also"], ["proof (state)\nthis:\n  x ; (x\\<^sup>T ; 1 \\<cdot> 1')\n  \\<le> x ; (x\\<^sup>T \\<cdot> 1' ; 1\\<^sup>T) ;\n        (1 \\<cdot> (x\\<^sup>T)\\<^sup>T ; 1')\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "have \"... \\<le> x;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (x\\<^sup>T \\<cdot> 1' ; 1\\<^sup>T) ;\n    (1 \\<cdot> (x\\<^sup>T)\\<^sup>T ; 1')\n    \\<le> x ; x\\<^sup>T ; x", "by simp"], ["proof (state)\nthis:\n  x ; (x\\<^sup>T \\<cdot> 1' ; 1\\<^sup>T) ;\n  (1 \\<cdot> (x\\<^sup>T)\\<^sup>T ; 1')\n  \\<le> x ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "finally"], ["proof (chain)\npicking this:\n  x \\<le> x ; x\\<^sup>T ; x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> x ; x\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. x \\<le> x ; x\\<^sup>T ; x", "."], ["proof (state)\nthis:\n  x \\<le> x ; x\\<^sup>T ; x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_triple:\n  assumes \"is_inj x\"\n    shows \"x = x;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x ; x\\<^sup>T ; x", "by (metis assms eq_iff inf_absorb2 is_inj_def mult_1_left mult_subdistr x_leq_triple_x)"], ["", "lemma p_fun_triple:\n  assumes \"is_p_fun x\"\n    shows \"x = x;x\\<^sup>T;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x ; x\\<^sup>T ; x", "by (metis assms comp_assoc eq_iff is_p_fun_def mult_isol mult_oner x_leq_triple_x)"], ["", "lemma loop_backward_forward:\n  \"x\\<^sup>T \\<le> -(1') + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> - 1' + x", "by (metis conv_e conv_times inf.cobounded2 test_dom test_domain test_eq_conv galois_2 inf.commute\n           sup.commute)"], ["", "lemma inj_sur_semi_swap:\n  assumes \"is_sur z\"\n      and \"is_inj x\"\n    shows \"z \\<le> y;x \\<Longrightarrow> x \\<le> y\\<^sup>T;z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> y ; x \\<Longrightarrow> x \\<le> y\\<^sup>T ; z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<le> y ; x \\<Longrightarrow> x \\<le> y\\<^sup>T ; z", "assume \"z \\<le> y;x\""], ["proof (state)\nthis:\n  z \\<le> y ; x\n\ngoal (1 subgoal):\n 1. z \\<le> y ; x \\<Longrightarrow> x \\<le> y\\<^sup>T ; z", "hence \"z;x\\<^sup>T \\<le> y;(x;x\\<^sup>T)\""], ["proof (prove)\nusing this:\n  z \\<le> y ; x\n\ngoal (1 subgoal):\n 1. z ; x\\<^sup>T \\<le> y ; (x ; x\\<^sup>T)", "by (metis mult_isor mult_assoc)"], ["proof (state)\nthis:\n  z ; x\\<^sup>T \\<le> y ; (x ; x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. z \\<le> y ; x \\<Longrightarrow> x \\<le> y\\<^sup>T ; z", "hence \"z;x\\<^sup>T \\<le> y\""], ["proof (prove)\nusing this:\n  z ; x\\<^sup>T \\<le> y ; (x ; x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. z ; x\\<^sup>T \\<le> y", "using \\<open>is_inj x\\<close>"], ["proof (prove)\nusing this:\n  z ; x\\<^sup>T \\<le> y ; (x ; x\\<^sup>T)\n  is_inj x\n\ngoal (1 subgoal):\n 1. z ; x\\<^sup>T \\<le> y", "unfolding is_inj_def"], ["proof (prove)\nusing this:\n  z ; x\\<^sup>T \\<le> y ; (x ; x\\<^sup>T)\n  x ; x\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. z ; x\\<^sup>T \\<le> y", "by (metis mult_isol order.trans mult_1_right)"], ["proof (state)\nthis:\n  z ; x\\<^sup>T \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<le> y ; x \\<Longrightarrow> x \\<le> y\\<^sup>T ; z", "hence \"(z\\<^sup>T;z);x\\<^sup>T \\<le> z\\<^sup>T;y\""], ["proof (prove)\nusing this:\n  z ; x\\<^sup>T \\<le> y\n\ngoal (1 subgoal):\n 1. z\\<^sup>T ; z ; x\\<^sup>T \\<le> z\\<^sup>T ; y", "by (metis mult_isol mult_assoc)"], ["proof (state)\nthis:\n  z\\<^sup>T ; z ; x\\<^sup>T \\<le> z\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. z \\<le> y ; x \\<Longrightarrow> x \\<le> y\\<^sup>T ; z", "hence \"x\\<^sup>T \\<le> z\\<^sup>T;y\""], ["proof (prove)\nusing this:\n  z\\<^sup>T ; z ; x\\<^sup>T \\<le> z\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> z\\<^sup>T ; y", "using \\<open>is_sur z\\<close>"], ["proof (prove)\nusing this:\n  z\\<^sup>T ; z ; x\\<^sup>T \\<le> z\\<^sup>T ; y\n  is_sur z\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> z\\<^sup>T ; y", "unfolding is_sur_def"], ["proof (prove)\nusing this:\n  z\\<^sup>T ; z ; x\\<^sup>T \\<le> z\\<^sup>T ; y\n  reflexive (z\\<^sup>T ; z)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> z\\<^sup>T ; y", "by (metis mult_isor order.trans mult_1_left)"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> z\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. z \\<le> y ; x \\<Longrightarrow> x \\<le> y\\<^sup>T ; z", "thus ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> z\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. x \\<le> y\\<^sup>T ; z", "using conv_iso"], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> z\\<^sup>T ; y\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x \\<le> y\\<^sup>T ; z", "by fastforce"], ["proof (state)\nthis:\n  x \\<le> y\\<^sup>T ; z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_sur_semi_swap_short:\n  assumes \"is_sur z\"\n      and \"is_inj x\"\n    shows \"z \\<le> y\\<^sup>T;x \\<Longrightarrow> x \\<le> y;z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> y\\<^sup>T ; x \\<Longrightarrow> x \\<le> y ; z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<le> y\\<^sup>T ; x \\<Longrightarrow> x \\<le> y ; z", "assume as: \"z \\<le> y\\<^sup>T;x\""], ["proof (state)\nthis:\n  z \\<le> y\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. z \\<le> y\\<^sup>T ; x \\<Longrightarrow> x \\<le> y ; z", "hence \"z;x\\<^sup>T \\<le> y\\<^sup>T\""], ["proof (prove)\nusing this:\n  z \\<le> y\\<^sup>T ; x\n\ngoal (1 subgoal):\n 1. z ; x\\<^sup>T \\<le> y\\<^sup>T", "using \\<open>z \\<le> y\\<^sup>T;x\\<close> \\<open>is_inj x\\<close>"], ["proof (prove)\nusing this:\n  z \\<le> y\\<^sup>T ; x\n  z \\<le> y\\<^sup>T ; x\n  is_inj x\n\ngoal (1 subgoal):\n 1. z ; x\\<^sup>T \\<le> y\\<^sup>T", "unfolding is_inj_def"], ["proof (prove)\nusing this:\n  z \\<le> y\\<^sup>T ; x\n  z \\<le> y\\<^sup>T ; x\n  x ; x\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. z ; x\\<^sup>T \\<le> y\\<^sup>T", "by (metis assms(2) conv_invol inf.orderI inf_absorb1 inj_p_fun ss_422iii)"], ["proof (state)\nthis:\n  z ; x\\<^sup>T \\<le> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. z \\<le> y\\<^sup>T ; x \\<Longrightarrow> x \\<le> y ; z", "hence \"x\\<^sup>T \\<le> z\\<^sup>T;y\\<^sup>T\""], ["proof (prove)\nusing this:\n  z ; x\\<^sup>T \\<le> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> z\\<^sup>T ; y\\<^sup>T", "using \\<open>is_sur z\\<close>"], ["proof (prove)\nusing this:\n  z ; x\\<^sup>T \\<le> y\\<^sup>T\n  is_sur z\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> z\\<^sup>T ; y\\<^sup>T", "unfolding is_sur_def"], ["proof (prove)\nusing this:\n  z ; x\\<^sup>T \\<le> y\\<^sup>T\n  reflexive (z\\<^sup>T ; z)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> z\\<^sup>T ; y\\<^sup>T", "by (metis as assms inj_sur_semi_swap conv_contrav conv_invol conv_iso)"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> z\\<^sup>T ; y\\<^sup>T\n\ngoal (1 subgoal):\n 1. z \\<le> y\\<^sup>T ; x \\<Longrightarrow> x \\<le> y ; z", "thus \"x \\<le> y;z\""], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> z\\<^sup>T ; y\\<^sup>T\n\ngoal (1 subgoal):\n 1. x \\<le> y ; z", "using conv_iso"], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> z\\<^sup>T ; y\\<^sup>T\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x \\<le> y ; z", "by fastforce"], ["proof (state)\nthis:\n  x \\<le> y ; z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_swap:\n  assumes \"bijective z\"\n      and \"bijective x\"\n    shows \"z \\<le> y\\<^sup>T;x \\<longleftrightarrow> x \\<le> y;z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<le> y\\<^sup>T ; x) = (x \\<le> y ; z)", "by (metis assms inj_sur_semi_swap conv_invol)"], ["", "text \\<open>The following result is \\cite[Proposition 4.2.2(iv)]{SchmidtStroehlein1993}.\\<close>"], ["", "lemma ss422iv:\n  assumes \"is_p_fun y\"\n      and \"x \\<le> y\"\n      and \"y;1 \\<le> x;1\"\n    shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"y \\<le> (x;1)\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x ; 1 \\<cdot> y", "using assms(3) le_infI maddux_20 order_trans"], ["proof (prove)\nusing this:\n  y ; 1 \\<le> x ; 1\n  \\<lbrakk>?x \\<le> ?a; ?x \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?a \\<cdot> ?b\n  ?x \\<le> ?x ; 1\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. y \\<le> x ; 1 \\<cdot> y", "by blast"], ["proof (state)\nthis:\n  y \\<le> x ; 1 \\<cdot> y\n\ngoal (1 subgoal):\n 1. x = y", "also"], ["proof (state)\nthis:\n  y \\<le> x ; 1 \\<cdot> y\n\ngoal (1 subgoal):\n 1. x = y", "have \"... \\<le> x;x\\<^sup>T;y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 \\<cdot> y \\<le> x ; x\\<^sup>T ; y", "by (metis inf_top_left modular_1_var comp_assoc)"], ["proof (state)\nthis:\n  x ; 1 \\<cdot> y \\<le> x ; x\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. x = y", "also"], ["proof (state)\nthis:\n  x ; 1 \\<cdot> y \\<le> x ; x\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. x = y", "have \"... \\<le> x;y\\<^sup>T;y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; y \\<le> x ; y\\<^sup>T ; y", "using assms(2) conv_iso mult_double_iso"], ["proof (prove)\nusing this:\n  x \\<le> y\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  ?x \\<le> ?y \\<Longrightarrow> ?w ; ?x ; ?z \\<le> ?w ; ?y ; ?z\n\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T ; y \\<le> x ; y\\<^sup>T ; y", "by blast"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; y \\<le> x ; y\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. x = y", "also"], ["proof (state)\nthis:\n  x ; x\\<^sup>T ; y \\<le> x ; y\\<^sup>T ; y\n\ngoal (1 subgoal):\n 1. x = y", "have \"... \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y\\<^sup>T ; y \\<le> x", "using assms(1) comp_assoc is_p_fun_def mult_isol mult_1_right"], ["proof (prove)\nusing this:\n  is_p_fun y\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_p_fun ?x \\<equiv> ?x\\<^sup>T ; ?x \\<le> 1'\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n  ?a ; 1' = ?a\n\ngoal (1 subgoal):\n 1. x ; y\\<^sup>T ; y \\<le> x", "by fastforce"], ["proof (state)\nthis:\n  x ; y\\<^sup>T ; y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "finally"], ["proof (chain)\npicking this:\n  y \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: assms(2) antisym)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following results are variants of \\cite[Proposition 4.2.3]{SchmidtStroehlein1993}.\\<close>"], ["", "lemma ss423conv:\n  assumes \"bijective x\"\n    shows \"x ; y \\<le> z \\<longleftrightarrow> y \\<le> x\\<^sup>T ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; y \\<le> z) = (y \\<le> x\\<^sup>T ; z)", "by (metis assms conv_contrav conv_iso inj_p_fun is_map_def ss423 sur_total)"], ["", "lemma ss423bij:\n  assumes \"bijective x\"\n    shows \"y ; x\\<^sup>T \\<le> z \\<longleftrightarrow> y \\<le> z ; x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ; x\\<^sup>T \\<le> z) = (y \\<le> z ; x)", "by (simp add: assms is_map_def p_fun_inj ss423 total_sur)"], ["", "lemma inj_distr:\n  assumes \"is_inj z\"\n    shows \"(x\\<cdot>y);z = (x;z)\\<cdot>(y;z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y) ; z = x ; z \\<cdot> y ; z", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<cdot> y) ; z \\<le> x ; z \\<cdot> y ; z\n 2. x ; z \\<cdot> y ; z \\<le> (x \\<cdot> y) ; z", "using mult_subdistr_var"], ["proof (prove)\nusing this:\n  (?x \\<cdot> ?y) ; ?z \\<le> ?x ; ?z \\<cdot> ?y ; ?z\n\ngoal (2 subgoals):\n 1. (x \\<cdot> y) ; z \\<le> x ; z \\<cdot> y ; z\n 2. x ; z \\<cdot> y ; z \\<le> (x \\<cdot> y) ; z", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; z \\<cdot> y ; z \\<le> (x \\<cdot> y) ; z", "using assms conv_iso inj_p_fun p_fun_distl"], ["proof (prove)\nusing this:\n  is_inj z\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  is_inj ?x = is_p_fun (?x\\<^sup>T)\n  is_p_fun ?x \\<Longrightarrow>\n  ?x ; (?y \\<cdot> ?z) = ?x ; ?y \\<cdot> ?x ; ?z\n\ngoal (1 subgoal):\n 1. x ; z \\<cdot> y ; z \\<le> (x \\<cdot> y) ; z", "by fastforce"], ["", "lemma test_converse:\n  \"x \\<cdot> 1' = x\\<^sup>T \\<cdot> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> 1' = x\\<^sup>T \\<cdot> 1'", "by (metis conv_e conv_times inf_le2 is_test_def test_eq_conv)"], ["", "lemma injective_down_closed:\n  assumes \"is_inj x\"\n      and \"y \\<le> x\"\n    shows \"is_inj y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj y", "by (meson assms conv_iso dual_order.trans is_inj_def mult_isol_var)"], ["", "lemma injective_sup:\n  assumes \"is_inj t\"\n      and \"e;t\\<^sup>T \\<le> 1'\"\n      and \"is_inj e\"\n    shows \"is_inj (t + e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj (t + e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_inj (t + e)", "have 1: \"t;e\\<^sup>T \\<le> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ; e\\<^sup>T \\<le> 1'", "using assms(2) conv_contrav conv_e conv_invol conv_iso"], ["proof (prove)\nusing this:\n  e ; t\\<^sup>T \\<le> 1'\n  (?x ; ?y)\\<^sup>T = ?y\\<^sup>T ; ?x\\<^sup>T\n  1'\\<^sup>T = 1'\n  (?x\\<^sup>T)\\<^sup>T = ?x\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. t ; e\\<^sup>T \\<le> 1'", "by fastforce"], ["proof (state)\nthis:\n  t ; e\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. is_inj (t + e)", "have \"(t + e);(t + e)\\<^sup>T = t;t\\<^sup>T + t;e\\<^sup>T + e;t\\<^sup>T + e;e\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t + e) ; (t + e)\\<^sup>T =\n    t ; t\\<^sup>T + t ; e\\<^sup>T + e ; t\\<^sup>T + e ; e\\<^sup>T", "by (metis conv_add distrib_left distrib_right' sup_assoc)"], ["proof (state)\nthis:\n  (t + e) ; (t + e)\\<^sup>T =\n  t ; t\\<^sup>T + t ; e\\<^sup>T + e ; t\\<^sup>T + e ; e\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_inj (t + e)", "also"], ["proof (state)\nthis:\n  (t + e) ; (t + e)\\<^sup>T =\n  t ; t\\<^sup>T + t ; e\\<^sup>T + e ; t\\<^sup>T + e ; e\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_inj (t + e)", "have \"... \\<le> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ; t\\<^sup>T + t ; e\\<^sup>T + e ; t\\<^sup>T + e ; e\\<^sup>T \\<le> 1'", "using 1 assms"], ["proof (prove)\nusing this:\n  t ; e\\<^sup>T \\<le> 1'\n  is_inj t\n  e ; t\\<^sup>T \\<le> 1'\n  is_inj e\n\ngoal (1 subgoal):\n 1. t ; t\\<^sup>T + t ; e\\<^sup>T + e ; t\\<^sup>T + e ; e\\<^sup>T \\<le> 1'", "by (simp add: is_inj_def le_supI)"], ["proof (state)\nthis:\n  t ; t\\<^sup>T + t ; e\\<^sup>T + e ; t\\<^sup>T + e ; e\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. is_inj (t + e)", "finally"], ["proof (chain)\npicking this:\n  (t + e) ; (t + e)\\<^sup>T \\<le> 1'", "show ?thesis"], ["proof (prove)\nusing this:\n  (t + e) ; (t + e)\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. is_inj (t + e)", "unfolding is_inj_def"], ["proof (prove)\nusing this:\n  (t + e) ; (t + e)\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. (t + e) ; (t + e)\\<^sup>T \\<le> 1'", "."], ["proof (state)\nthis:\n  is_inj (t + e)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Some (more) results about vectors\\<close>"], ["", "lemma vector_meet_comp:\n  assumes \"is_vector v\"\n      and \"is_vector w\"\n    shows \"v;w\\<^sup>T = v\\<cdot>w\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ; w\\<^sup>T = v \\<cdot> w\\<^sup>T", "by (metis assms conv_contrav conv_one inf_top_right is_vector_def vector_1)"], ["", "lemma vector_meet_comp':\n  assumes \"is_vector v\"\n    shows \"v;v\\<^sup>T = v\\<cdot>v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ; v\\<^sup>T = v \\<cdot> v\\<^sup>T", "using assms vector_meet_comp"], ["proof (prove)\nusing this:\n  is_vector v\n  \\<lbrakk>is_vector ?v; is_vector ?w\\<rbrakk>\n  \\<Longrightarrow> ?v ; ?w\\<^sup>T = ?v \\<cdot> ?w\\<^sup>T\n\ngoal (1 subgoal):\n 1. v ; v\\<^sup>T = v \\<cdot> v\\<^sup>T", "by blast"], ["", "lemma vector_meet_comp_x:\n  \"x;1;x\\<^sup>T = x;1\\<cdot>1;x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 ; x\\<^sup>T = x ; 1 \\<cdot> 1 ; x\\<^sup>T", "by (metis comp_assoc inf_top.right_neutral is_vector_def one_idem_mult vector_1)"], ["", "lemma vector_meet_comp_x':\n  \"x;1;x = x;1\\<cdot>1;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 1 ; x = x ; 1 \\<cdot> 1 ; x", "by (metis inf_commute inf_top.right_neutral ra_1)"], ["", "lemma vector_prop1:\n  assumes \"is_vector v\"\n    shows \"-v\\<^sup>T;v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - v\\<^sup>T ; v = 0", "by (metis assms compl_inf_bot inf_top.right_neutral one_compl one_idem_mult vector_2)"], ["", "text \\<open>The following results and a number of others in this theory are from \\cite{Guttmann2017a}.\\<close>"], ["", "lemma ee:\n  assumes \"is_vector v\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n    shows \"e;e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e ; e = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e ; e = 0", "have \"e;v \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e ; v \\<le> 0", "by (metis assms annir mult_isor vector_prop1 comp_assoc)"], ["proof (state)\nthis:\n  e ; v \\<le> 0\n\ngoal (1 subgoal):\n 1. e ; e = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  e ; v \\<le> 0\n\ngoal (1 subgoal):\n 1. e ; e = 0", "by (metis assms(2) annil antisym bot_least comp_assoc mult_isol)"], ["proof (state)\nthis:\n  e ; e = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma et:\n  assumes \"is_vector v\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n      and \"t \\<le> v;v\\<^sup>T\"\n    shows \"e;t = 0\"\n      and \"e;t\\<^sup>T = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e ; t = 0 &&& e ; t\\<^sup>T = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. e ; t = 0\n 2. e ; t\\<^sup>T = 0", "have \"e;t \\<le> v;-v\\<^sup>T;v;v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e ; t \\<le> v ; - v\\<^sup>T ; v ; v\\<^sup>T", "by (metis assms(2-3) mult_isol_var comp_assoc)"], ["proof (state)\nthis:\n  e ; t \\<le> v ; - v\\<^sup>T ; v ; v\\<^sup>T\n\ngoal (2 subgoals):\n 1. e ; t = 0\n 2. e ; t\\<^sup>T = 0", "thus \"e;t = 0\""], ["proof (prove)\nusing this:\n  e ; t \\<le> v ; - v\\<^sup>T ; v ; v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e ; t = 0", "by (simp add: assms(1) comp_assoc le_bot vector_prop1)"], ["proof (state)\nthis:\n  e ; t = 0\n\ngoal (1 subgoal):\n 1. e ; t\\<^sup>T = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e ; t\\<^sup>T = 0", "have \"t\\<^sup>T \\<le> v;v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>T \\<le> v ; v\\<^sup>T", "using assms(3) conv_iso"], ["proof (prove)\nusing this:\n  t \\<le> v ; v\\<^sup>T\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. t\\<^sup>T \\<le> v ; v\\<^sup>T", "by fastforce"], ["proof (state)\nthis:\n  t\\<^sup>T \\<le> v ; v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e ; t\\<^sup>T = 0", "hence \"e;t\\<^sup>T \\<le> v;-v\\<^sup>T;v;v\\<^sup>T\""], ["proof (prove)\nusing this:\n  t\\<^sup>T \\<le> v ; v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e ; t\\<^sup>T \\<le> v ; - v\\<^sup>T ; v ; v\\<^sup>T", "by (metis assms(2) mult_isol_var comp_assoc)"], ["proof (state)\nthis:\n  e ; t\\<^sup>T \\<le> v ; - v\\<^sup>T ; v ; v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e ; t\\<^sup>T = 0", "thus \"e;t\\<^sup>T = 0\""], ["proof (prove)\nusing this:\n  e ; t\\<^sup>T \\<le> v ; - v\\<^sup>T ; v ; v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e ; t\\<^sup>T = 0", "by (simp add: assms(1) comp_assoc le_bot vector_prop1)"], ["proof (state)\nthis:\n  e ; t\\<^sup>T = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Some (more) results about points\\<close>"], ["", "definition point\n  where \"point x \\<equiv> is_vector x \\<and> bijective x\""], ["", "lemma point_swap:\n  assumes \"point p\"\n      and \"point q\"\n    shows \"p \\<le> x;q \\<longleftrightarrow> q \\<le> x\\<^sup>T;p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> x ; q) = (q \\<le> x\\<^sup>T ; p)", "by (metis assms conv_invol inj_sur_semi_swap point_def)"], ["", "text \\<open>Some (more) results about singletons\\<close>"], ["", "abbreviation singleton\n  where \"singleton x \\<equiv> bijective (x;1) \\<and> bijective (x\\<^sup>T;1)\""], ["", "lemma singleton_injective:\n  assumes \"singleton x\"\n    shows \"is_inj x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj x", "using assms injective_down_closed maddux_20"], ["proof (prove)\nusing this:\n  singleton x\n  \\<lbrakk>is_inj ?x; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> is_inj ?y\n  ?x \\<le> ?x ; 1\n\ngoal (1 subgoal):\n 1. is_inj x", "by blast"], ["", "lemma injective_inv:\n  assumes \"is_vector v\"\n      and \"singleton e\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n      and \"t \\<le> v;v\\<^sup>T\"\n      and \"is_inj t\"\n    shows \"is_inj (t + e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj (t + e)", "by (metis assms singleton_injective injective_sup bot_least et(2))"], ["", "lemma singleton_is_point:\n  assumes \"singleton p\"\n    shows \"point (p;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point (p ; 1)", "by (simp add: assms comp_assoc is_vector_def point_def)"], ["", "lemma singleton_transp:\n  assumes \"singleton p\"\n    shows \"singleton (p\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton (p\\<^sup>T)", "by (simp add: assms)"], ["", "lemma point_to_singleton:\n  assumes \"singleton p\"\n    shows \"singleton (1'\\<cdot>p;p\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton (1' \\<cdot> p ; p\\<^sup>T)", "using assms dom_def_aux_var dom_one is_vector_def point_def"], ["proof (prove)\nusing this:\n  singleton p\n  d ?x = 1' \\<cdot> ?x ; ?x\\<^sup>T\n  ?x ; 1 = d ?x ; 1\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n\ngoal (1 subgoal):\n 1. singleton (1' \\<cdot> p ; p\\<^sup>T)", "by fastforce"], ["", "lemma singleton_singletonT:\n  assumes \"singleton p\"\n    shows \"p;p\\<^sup>T \\<le> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; p\\<^sup>T \\<le> 1'", "using assms singleton_injective is_inj_def"], ["proof (prove)\nusing this:\n  singleton p\n  singleton ?x \\<Longrightarrow> is_inj ?x\n  is_inj ?x \\<equiv> ?x ; ?x\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. p ; p\\<^sup>T \\<le> 1'", "by blast"], ["", "text \\<open>Minimality\\<close>"], ["", "abbreviation minimum\n  where \"minimum x v \\<equiv> v \\<cdot> -(x\\<^sup>T;v)\""], ["", "text \\<open>Regressively finite\\<close>"], ["", "abbreviation regressively_finite\n  where \"regressively_finite x \\<equiv> \\<forall>v . is_vector v \\<and> v \\<le> x\\<^sup>T;v \\<longrightarrow> v = 0\""], ["", "lemma regressively_finite_minimum:\n  \"regressively_finite R \\<Longrightarrow> is_vector v \\<Longrightarrow> v \\<noteq> 0 \\<Longrightarrow> minimum R v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>regressively_finite R; is_vector v; v \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> minimum R v \\<noteq> 0", "using galois_aux2"], ["proof (prove)\nusing this:\n  (?x \\<cdot> - ?y = 0) = (?x \\<le> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>regressively_finite R; is_vector v; v \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> minimum R v \\<noteq> 0", "by blast"], ["", "lemma regressively_finite_irreflexive:\n  assumes \"regressively_finite x\"\n    shows \"x \\<le> -1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - 1'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> - 1'", "have 1: \"is_vector ((x\\<^sup>T \\<cdot> 1');1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector ((x\\<^sup>T \\<cdot> 1') ; 1)", "by (simp add: is_vector_def mult_assoc)"], ["proof (state)\nthis:\n  is_vector ((x\\<^sup>T \\<cdot> 1') ; 1)\n\ngoal (1 subgoal):\n 1. x \\<le> - 1'", "have \"(x\\<^sup>T \\<cdot> 1');1 = (x\\<^sup>T \\<cdot> 1');(x\\<^sup>T \\<cdot> 1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T \\<cdot> 1') ; 1 =\n    (x\\<^sup>T \\<cdot> 1') ; (x\\<^sup>T \\<cdot> 1') ; 1", "by (simp add: is_test_def test_comp_eq_mult)"], ["proof (state)\nthis:\n  (x\\<^sup>T \\<cdot> 1') ; 1 =\n  (x\\<^sup>T \\<cdot> 1') ; (x\\<^sup>T \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. x \\<le> - 1'", "with 1"], ["proof (chain)\npicking this:\n  is_vector ((x\\<^sup>T \\<cdot> 1') ; 1)\n  (x\\<^sup>T \\<cdot> 1') ; 1 =\n  (x\\<^sup>T \\<cdot> 1') ; (x\\<^sup>T \\<cdot> 1') ; 1", "have \"(x\\<^sup>T \\<cdot> 1');1 = 0\""], ["proof (prove)\nusing this:\n  is_vector ((x\\<^sup>T \\<cdot> 1') ; 1)\n  (x\\<^sup>T \\<cdot> 1') ; 1 =\n  (x\\<^sup>T \\<cdot> 1') ; (x\\<^sup>T \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. (x\\<^sup>T \\<cdot> 1') ; 1 = 0", "by (metis assms comp_assoc mult_subdistr)"], ["proof (state)\nthis:\n  (x\\<^sup>T \\<cdot> 1') ; 1 = 0\n\ngoal (1 subgoal):\n 1. x \\<le> - 1'", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x\\<^sup>T \\<cdot> 1') ; 1 = 0\n\ngoal (1 subgoal):\n 1. x \\<le> - 1'", "by (metis conv_e conv_invol conv_times conv_zero galois_aux ss_p18)"], ["proof (state)\nthis:\n  x \\<le> - 1'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* relation_algebra *)"], ["", "subsection \\<open>Relation algebras satisfying the Tarski rule\\<close>"], ["", "class relation_algebra_tarski = relation_algebra +\n  assumes tarski: \"x \\<noteq> 0 \\<longleftrightarrow> 1;x;1 = 1\"\nbegin"], ["", "text \\<open>Some (more) results about points\\<close>"], ["", "lemma point_equations:\n  assumes \"is_point p\"\n  shows \"p;1=p\"\n    and \"1;p=1\"\n    and \"p\\<^sup>T;1=1\"\n    and \"1;p\\<^sup>T=p\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ; 1 = p &&& 1 ; p = 1) &&&\n    p\\<^sup>T ; 1 = 1 &&& 1 ; p\\<^sup>T = p\\<^sup>T", "apply (metis assms is_point_def is_vector_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1 ; p = 1\n 2. p\\<^sup>T ; 1 = 1\n 3. 1 ; p\\<^sup>T = p\\<^sup>T", "using assms is_point_def is_vector_def tarski vector_comp"], ["proof (prove)\nusing this:\n  is_point p\n  is_point ?x \\<equiv> is_vector ?x \\<and> is_inj ?x \\<and> ?x \\<noteq> 0\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n  \\<lbrakk>is_vector ?x; is_vector ?y\\<rbrakk>\n  \\<Longrightarrow> is_vector (?x ; ?y)\n\ngoal (3 subgoals):\n 1. 1 ; p = 1\n 2. p\\<^sup>T ; 1 = 1\n 3. 1 ; p\\<^sup>T = p\\<^sup>T", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. p\\<^sup>T ; 1 = 1\n 2. 1 ; p\\<^sup>T = p\\<^sup>T", "apply (metis assms conv_contrav conv_one conv_zero is_point_def is_vector_def tarski)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ; p\\<^sup>T = p\\<^sup>T", "by (metis assms conv_contrav conv_one is_point_def is_vector_def)"], ["", "text \\<open>The following result is \\cite[Proposition 2.4.5(i)]{SchmidtStroehlein1993}.\\<close>"], ["", "lemma point_singleton:\n  assumes \"is_point p\"\n      and \"is_vector v\"\n      and \"v \\<noteq> 0\"\n      and \"v \\<le> p\"\n    shows \"v = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = p", "have \"1;v = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ; v = 1", "using assms(2,3) comp_assoc is_vector_def tarski"], ["proof (prove)\nusing this:\n  is_vector v\n  v \\<noteq> 0\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n\ngoal (1 subgoal):\n 1. 1 ; v = 1", "by fastforce"], ["proof (state)\nthis:\n  1 ; v = 1\n\ngoal (1 subgoal):\n 1. v = p", "hence \"p = 1;v \\<cdot> p\""], ["proof (prove)\nusing this:\n  1 ; v = 1\n\ngoal (1 subgoal):\n 1. p = 1 ; v \\<cdot> p", "by simp"], ["proof (state)\nthis:\n  p = 1 ; v \\<cdot> p\n\ngoal (1 subgoal):\n 1. v = p", "also"], ["proof (state)\nthis:\n  p = 1 ; v \\<cdot> p\n\ngoal (1 subgoal):\n 1. v = p", "have \"... \\<le> (1 \\<cdot> p;v\\<^sup>T);(v \\<cdot> 1\\<^sup>T;p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ; v \\<cdot> p\n    \\<le> (1 \\<cdot> p ; v\\<^sup>T) ; (v \\<cdot> 1\\<^sup>T ; p)", "using dedekind"], ["proof (prove)\nusing this:\n  ?x ; ?y \\<cdot> ?z\n  \\<le> (?x \\<cdot> ?z ; ?y\\<^sup>T) ; (?y \\<cdot> ?x\\<^sup>T ; ?z)\n\ngoal (1 subgoal):\n 1. 1 ; v \\<cdot> p\n    \\<le> (1 \\<cdot> p ; v\\<^sup>T) ; (v \\<cdot> 1\\<^sup>T ; p)", "by blast"], ["proof (state)\nthis:\n  1 ; v \\<cdot> p\n  \\<le> (1 \\<cdot> p ; v\\<^sup>T) ; (v \\<cdot> 1\\<^sup>T ; p)\n\ngoal (1 subgoal):\n 1. v = p", "also"], ["proof (state)\nthis:\n  1 ; v \\<cdot> p\n  \\<le> (1 \\<cdot> p ; v\\<^sup>T) ; (v \\<cdot> 1\\<^sup>T ; p)\n\ngoal (1 subgoal):\n 1. v = p", "have \"... \\<le> p;v\\<^sup>T;v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<cdot> p ; v\\<^sup>T) ; (v \\<cdot> 1\\<^sup>T ; p)\n    \\<le> p ; v\\<^sup>T ; v", "by (simp add: mult_subdistl)"], ["proof (state)\nthis:\n  (1 \\<cdot> p ; v\\<^sup>T) ; (v \\<cdot> 1\\<^sup>T ; p)\n  \\<le> p ; v\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. v = p", "also"], ["proof (state)\nthis:\n  (1 \\<cdot> p ; v\\<^sup>T) ; (v \\<cdot> 1\\<^sup>T ; p)\n  \\<le> p ; v\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. v = p", "have \"... \\<le> p;p\\<^sup>T;v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; v\\<^sup>T ; v \\<le> p ; p\\<^sup>T ; v", "using assms(4) conv_iso mult_double_iso"], ["proof (prove)\nusing this:\n  v \\<le> p\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  ?x \\<le> ?y \\<Longrightarrow> ?w ; ?x ; ?z \\<le> ?w ; ?y ; ?z\n\ngoal (1 subgoal):\n 1. p ; v\\<^sup>T ; v \\<le> p ; p\\<^sup>T ; v", "by blast"], ["proof (state)\nthis:\n  p ; v\\<^sup>T ; v \\<le> p ; p\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. v = p", "also"], ["proof (state)\nthis:\n  p ; v\\<^sup>T ; v \\<le> p ; p\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. v = p", "have \"... \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; p\\<^sup>T ; v \\<le> v", "by (metis assms(1) is_inj_def is_point_def mult_isor mult_onel)"], ["proof (state)\nthis:\n  p ; p\\<^sup>T ; v \\<le> v\n\ngoal (1 subgoal):\n 1. v = p", "finally"], ["proof (chain)\npicking this:\n  p \\<le> v", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<le> v\n\ngoal (1 subgoal):\n 1. v = p", "using assms(4)"], ["proof (prove)\nusing this:\n  p \\<le> v\n  v \\<le> p\n\ngoal (1 subgoal):\n 1. v = p", "by simp"], ["proof (state)\nthis:\n  v = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma point_not_equal_aux:\n  assumes \"is_point p\"\n      and \"is_point q\"\n    shows \"p\\<noteq>q \\<longleftrightarrow> p \\<cdot> -q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> q) = (p \\<cdot> - q \\<noteq> 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> q \\<Longrightarrow> p \\<cdot> - q \\<noteq> 0\n 2. p \\<cdot> - q \\<noteq> 0 \\<Longrightarrow> p \\<noteq> q", "show \"p \\<noteq> q \\<Longrightarrow> p \\<cdot> - q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p \\<cdot> - q \\<noteq> 0", "proof (rule contrapos_nn)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> q \\<Longrightarrow> \\<not> ?Q\n 2. \\<lbrakk>p \\<noteq> q; p \\<cdot> - q = 0\\<rbrakk> \\<Longrightarrow> ?Q", "assume \"p \\<cdot> -q = 0\""], ["proof (state)\nthis:\n  p \\<cdot> - q = 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> q \\<Longrightarrow> \\<not> ?Q\n 2. \\<lbrakk>p \\<noteq> q; p \\<cdot> - q = 0\\<rbrakk> \\<Longrightarrow> ?Q", "thus \"p = q\""], ["proof (prove)\nusing this:\n  p \\<cdot> - q = 0\n\ngoal (1 subgoal):\n 1. p = q", "using assms galois_aux2 is_point_def point_singleton"], ["proof (prove)\nusing this:\n  p \\<cdot> - q = 0\n  is_point p\n  is_point q\n  (?x \\<cdot> - ?y = 0) = (?x \\<le> ?y)\n  is_point ?x \\<equiv> is_vector ?x \\<and> is_inj ?x \\<and> ?x \\<noteq> 0\n  \\<lbrakk>is_point ?p; is_vector ?v; ?v \\<noteq> 0; ?v \\<le> ?p\\<rbrakk>\n  \\<Longrightarrow> ?v = ?p\n\ngoal (1 subgoal):\n 1. p = q", "by fastforce"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p \\<noteq> q", "qed"], ["proof (state)\nthis:\n  p \\<noteq> q \\<Longrightarrow> p \\<cdot> - q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<cdot> - q \\<noteq> 0 \\<Longrightarrow> p \\<noteq> q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<cdot> - q \\<noteq> 0 \\<Longrightarrow> p \\<noteq> q", "show \"p \\<cdot> - q \\<noteq> 0 \\<Longrightarrow> p \\<noteq> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<cdot> - q \\<noteq> 0 \\<Longrightarrow> p \\<noteq> q", "using inf_compl_bot"], ["proof (prove)\nusing this:\n  ?x \\<cdot> - ?x = 0\n\ngoal (1 subgoal):\n 1. p \\<cdot> - q \\<noteq> 0 \\<Longrightarrow> p \\<noteq> q", "by blast"], ["proof (state)\nthis:\n  p \\<cdot> - q \\<noteq> 0 \\<Longrightarrow> p \\<noteq> q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following result is part of \\cite[Proposition 2.4.5(ii)]{SchmidtStroehlein1993}.\\<close>"], ["", "lemma point_not_equal:\n  assumes \"is_point p\"\n      and \"is_point q\"\n    shows \"p\\<noteq>q \\<longleftrightarrow> p\\<le>-q\"\n      and \"p\\<le>-q \\<longleftrightarrow> p;q\\<^sup>T \\<le> -1'\"\n      and \"p;q\\<^sup>T \\<le> -1' \\<longleftrightarrow> p\\<^sup>T;q \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> q) = (p \\<le> - q) &&&\n    (p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1') &&&\n    (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (p \\<noteq> q) = (p \\<le> - q)\n 2. (p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1')\n 3. (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "have \"p \\<noteq> q \\<Longrightarrow> p \\<le> - q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p \\<le> - q", "by (metis assms point_not_equal_aux is_point_def vector_compl vector_mult point_singleton\n              inf.orderI inf.cobounded1)"], ["proof (state)\nthis:\n  p \\<noteq> q \\<Longrightarrow> p \\<le> - q\n\ngoal (3 subgoals):\n 1. (p \\<noteq> q) = (p \\<le> - q)\n 2. (p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1')\n 3. (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "thus \"p\\<noteq>q \\<longleftrightarrow> p\\<le>-q\""], ["proof (prove)\nusing this:\n  p \\<noteq> q \\<Longrightarrow> p \\<le> - q\n\ngoal (1 subgoal):\n 1. (p \\<noteq> q) = (p \\<le> - q)", "by (metis assms(1) galois_aux inf.orderE is_point_def order.refl)"], ["proof (state)\nthis:\n  (p \\<noteq> q) = (p \\<le> - q)\n\ngoal (2 subgoals):\n 1. (p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1')\n 2. (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1')\n 2. (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "show \"(p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1')", "by (simp add: conv_galois_2)"], ["proof (state)\nthis:\n  (p \\<le> - q) = (p ; q\\<^sup>T \\<le> - 1')\n\ngoal (1 subgoal):\n 1. (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "show \"(p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)", "by (metis assms(2) compl_bot_eq conv_galois_2 galois_aux maddux_141 mult_1_right\n              point_equations(4))"], ["proof (state)\nthis:\n  (p ; q\\<^sup>T \\<le> - 1') = (p\\<^sup>T ; q \\<le> 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma point_is_point:\n  \"point x \\<longleftrightarrow> is_point x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point x = is_point x", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. point x \\<Longrightarrow> is_point x\n 2. is_point x \\<Longrightarrow> point x", "apply (simp add: is_point_def point_def surj_one tarski)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_point x \\<Longrightarrow> point x", "using is_point_def is_vector_def mult_assoc point_def sur_def_var1 tarski"], ["proof (prove)\nusing this:\n  is_point ?x \\<equiv> is_vector ?x \\<and> is_inj ?x \\<and> ?x \\<noteq> 0\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  ?a ; ?b ; ?c = ?a ; (?b ; ?c)\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  is_sur ?x = (1 ; ?x = 1)\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n\ngoal (1 subgoal):\n 1. is_point x \\<Longrightarrow> point x", "by fastforce"], ["", "lemma point_in_vector_or_complement:\n  assumes \"point p\"\n      and \"is_vector v\"\n    shows \"p \\<le> v \\<or> p \\<le> -v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> v \\<or> p \\<le> - v", "proof (cases \"p \\<le> -v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v\n 2. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "assume \"p \\<le> -v\""], ["proof (state)\nthis:\n  p \\<le> - v\n\ngoal (2 subgoals):\n 1. p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v\n 2. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<le> - v\n\ngoal (1 subgoal):\n 1. p \\<le> v \\<or> p \\<le> - v", "by simp"], ["proof (state)\nthis:\n  p \\<le> v \\<or> p \\<le> - v\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "assume \"\\<not>(p \\<le> -v)\""], ["proof (state)\nthis:\n  \\<not> p \\<le> - v\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "hence \"p\\<cdot>v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> p \\<le> - v\n\ngoal (1 subgoal):\n 1. p \\<cdot> v \\<noteq> 0", "by (simp add: galois_aux)"], ["proof (state)\nthis:\n  p \\<cdot> v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "hence \"1;(p\\<cdot>v) = 1\""], ["proof (prove)\nusing this:\n  p \\<cdot> v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 ; (p \\<cdot> v) = 1", "using assms comp_assoc is_vector_def point_def tarski vector_mult"], ["proof (prove)\nusing this:\n  p \\<cdot> v \\<noteq> 0\n  point p\n  is_vector v\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n  \\<lbrakk>is_vector ?x; is_vector ?y\\<rbrakk>\n  \\<Longrightarrow> is_vector (?x \\<cdot> ?y)\n\ngoal (1 subgoal):\n 1. 1 ; (p \\<cdot> v) = 1", "by fastforce"], ["proof (state)\nthis:\n  1 ; (p \\<cdot> v) = 1\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "hence \"p \\<le> p;(p\\<cdot>v)\\<^sup>T;(p\\<cdot>v)\""], ["proof (prove)\nusing this:\n  1 ; (p \\<cdot> v) = 1\n\ngoal (1 subgoal):\n 1. p \\<le> p ; (p \\<cdot> v)\\<^sup>T ; (p \\<cdot> v)", "by (metis inf_top.left_neutral modular_2_var)"], ["proof (state)\nthis:\n  p \\<le> p ; (p \\<cdot> v)\\<^sup>T ; (p \\<cdot> v)\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "also"], ["proof (state)\nthis:\n  p \\<le> p ; (p \\<cdot> v)\\<^sup>T ; (p \\<cdot> v)\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "have \"... \\<le> p;p\\<^sup>T;v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; (p \\<cdot> v)\\<^sup>T ; (p \\<cdot> v) \\<le> p ; p\\<^sup>T ; v", "by (simp add: mult_isol_var)"], ["proof (state)\nthis:\n  p ; (p \\<cdot> v)\\<^sup>T ; (p \\<cdot> v) \\<le> p ; p\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "also"], ["proof (state)\nthis:\n  p ; (p \\<cdot> v)\\<^sup>T ; (p \\<cdot> v) \\<le> p ; p\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "have \"... \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; p\\<^sup>T ; v \\<le> v", "using assms(1) comp_assoc point_def ss423conv"], ["proof (prove)\nusing this:\n  point p\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  bijective ?x \\<Longrightarrow>\n  (?x ; ?y \\<le> ?z) = (?y \\<le> ?x\\<^sup>T ; ?z)\n\ngoal (1 subgoal):\n 1. p ; p\\<^sup>T ; v \\<le> v", "by fastforce"], ["proof (state)\nthis:\n  p ; p\\<^sup>T ; v \\<le> v\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> v \\<or> p \\<le> - v", "finally"], ["proof (chain)\npicking this:\n  p \\<le> v", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<le> v\n\ngoal (1 subgoal):\n 1. p \\<le> v \\<or> p \\<le> - v", ".."], ["proof (state)\nthis:\n  p \\<le> v \\<or> p \\<le> - v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma point_in_vector_or_complement_iff:\n  assumes \"point p\"\n      and \"is_vector v\"\n    shows \"p \\<le> v \\<longleftrightarrow> \\<not>(p \\<le> -v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> v) = (\\<not> p \\<le> - v)", "by (metis assms annir compl_top_eq galois_aux inf.orderE one_compl point_def ss423conv tarski\n          top_greatest point_in_vector_or_complement)"], ["", "lemma different_points_consequences:\n  assumes \"point p\"\n      and \"point q\"\n      and \"p\\<noteq>q\"\n    shows \"p\\<^sup>T;-q=1\"\n      and \"-q\\<^sup>T;p=1\"\n      and \"-(p\\<^sup>T;-q)=0\"\n      and \"-(-q\\<^sup>T;p)=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p\\<^sup>T ; - q = 1 &&& - q\\<^sup>T ; p = 1) &&&\n    - (p\\<^sup>T ; - q) = 0 &&& - (- q\\<^sup>T ; p) = 0", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. p\\<^sup>T ; - q = 1\n 2. - q\\<^sup>T ; p = 1\n 3. - (p\\<^sup>T ; - q) = 0\n 4. - (- q\\<^sup>T ; p) = 0", "have \"p \\<le> -q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> - q", "by (metis assms compl_le_swap1 inf.absorb1 inf.absorb2 point_def point_in_vector_or_complement)"], ["proof (state)\nthis:\n  p \\<le> - q\n\ngoal (4 subgoals):\n 1. p\\<^sup>T ; - q = 1\n 2. - q\\<^sup>T ; p = 1\n 3. - (p\\<^sup>T ; - q) = 0\n 4. - (- q\\<^sup>T ; p) = 0", "thus 1: \"p\\<^sup>T;-q=1\""], ["proof (prove)\nusing this:\n  p \\<le> - q\n\ngoal (1 subgoal):\n 1. p\\<^sup>T ; - q = 1", "using assms(1)"], ["proof (prove)\nusing this:\n  p \\<le> - q\n  point p\n\ngoal (1 subgoal):\n 1. p\\<^sup>T ; - q = 1", "by (metis is_vector_def point_def ss423conv top_le)"], ["proof (state)\nthis:\n  p\\<^sup>T ; - q = 1\n\ngoal (3 subgoals):\n 1. - q\\<^sup>T ; p = 1\n 2. - (p\\<^sup>T ; - q) = 0\n 3. - (- q\\<^sup>T ; p) = 0", "thus 2: \"-q\\<^sup>T;p=1\""], ["proof (prove)\nusing this:\n  p\\<^sup>T ; - q = 1\n\ngoal (1 subgoal):\n 1. - q\\<^sup>T ; p = 1", "using conv_compl conv_one"], ["proof (prove)\nusing this:\n  p\\<^sup>T ; - q = 1\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n  1\\<^sup>T = 1\n\ngoal (1 subgoal):\n 1. - q\\<^sup>T ; p = 1", "by force"], ["proof (state)\nthis:\n  - q\\<^sup>T ; p = 1\n\ngoal (2 subgoals):\n 1. - (p\\<^sup>T ; - q) = 0\n 2. - (- q\\<^sup>T ; p) = 0", "from 1"], ["proof (chain)\npicking this:\n  p\\<^sup>T ; - q = 1", "show \"-(p\\<^sup>T;-q)=0\""], ["proof (prove)\nusing this:\n  p\\<^sup>T ; - q = 1\n\ngoal (1 subgoal):\n 1. - (p\\<^sup>T ; - q) = 0", "by simp"], ["proof (state)\nthis:\n  - (p\\<^sup>T ; - q) = 0\n\ngoal (1 subgoal):\n 1. - (- q\\<^sup>T ; p) = 0", "from 2"], ["proof (chain)\npicking this:\n  - q\\<^sup>T ; p = 1", "show \"-(-q\\<^sup>T;p)=0\""], ["proof (prove)\nusing this:\n  - q\\<^sup>T ; p = 1\n\ngoal (1 subgoal):\n 1. - (- q\\<^sup>T ; p) = 0", "by simp"], ["proof (state)\nthis:\n  - (- q\\<^sup>T ; p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Some (more) results about singletons\\<close>"], ["", "lemma singleton_pq:\n  assumes \"point p\"\n      and \"point q\"\n    shows \"singleton (p;q\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton (p ; q\\<^sup>T)", "using assms comp_assoc point_def point_equations(1,3) point_is_point"], ["proof (prove)\nusing this:\n  point p\n  point q\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  is_point ?p \\<Longrightarrow> ?p ; 1 = ?p\n  is_point ?p \\<Longrightarrow> ?p\\<^sup>T ; 1 = 1\n  point ?x = is_point ?x\n\ngoal (1 subgoal):\n 1. singleton (p ; q\\<^sup>T)", "by fastforce"], ["", "lemma singleton_equal_aux:\n  assumes \"singleton p\"\n      and \"singleton q\"\n      and \"q\\<le>p\"\n    shows \"p \\<le> q;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "have pLp: \"p;1;p\\<^sup>T \\<le>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; 1 ; p\\<^sup>T \\<le> 1'", "by (simp add: assms(1) maddux_21 ss423conv)"], ["proof (state)\nthis:\n  p ; 1 ; p\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "have \"p = 1;(q\\<^sup>T;q;1) \\<cdot> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p", "using tarski"], ["proof (prove)\nusing this:\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n\ngoal (1 subgoal):\n 1. p = 1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p", "by (metis assms(2) annir singleton_injective inf.commute inf_top.right_neutral inj_triple\n              mult_assoc surj_one)"], ["proof (state)\nthis:\n  p = 1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "also"], ["proof (state)\nthis:\n  p = 1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "have \"... \\<le> (1 \\<cdot> p;(q\\<^sup>T;q;1)\\<^sup>T);(q\\<^sup>T;q;1 \\<cdot> 1;p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p\n    \\<le> (1 \\<cdot> p ; (q\\<^sup>T ; q ; 1)\\<^sup>T) ;\n          (q\\<^sup>T ; q ; 1 \\<cdot> 1 ; p)", "using dedekind"], ["proof (prove)\nusing this:\n  ?x ; ?y \\<cdot> ?z\n  \\<le> (?x \\<cdot> ?z ; ?y\\<^sup>T) ; (?y \\<cdot> ?x\\<^sup>T ; ?z)\n\ngoal (1 subgoal):\n 1. 1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p\n    \\<le> (1 \\<cdot> p ; (q\\<^sup>T ; q ; 1)\\<^sup>T) ;\n          (q\\<^sup>T ; q ; 1 \\<cdot> 1 ; p)", "by (metis conv_one)"], ["proof (state)\nthis:\n  1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p\n  \\<le> (1 \\<cdot> p ; (q\\<^sup>T ; q ; 1)\\<^sup>T) ;\n        (q\\<^sup>T ; q ; 1 \\<cdot> 1 ; p)\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "also"], ["proof (state)\nthis:\n  1 ; (q\\<^sup>T ; q ; 1) \\<cdot> p\n  \\<le> (1 \\<cdot> p ; (q\\<^sup>T ; q ; 1)\\<^sup>T) ;\n        (q\\<^sup>T ; q ; 1 \\<cdot> 1 ; p)\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "have \"... \\<le> p;1;q\\<^sup>T;q;q\\<^sup>T;q;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<cdot> p ; (q\\<^sup>T ; q ; 1)\\<^sup>T) ;\n    (q\\<^sup>T ; q ; 1 \\<cdot> 1 ; p)\n    \\<le> p ; 1 ; q\\<^sup>T ; q ; q\\<^sup>T ; q ; 1", "by (simp add: comp_assoc mult_isol)"], ["proof (state)\nthis:\n  (1 \\<cdot> p ; (q\\<^sup>T ; q ; 1)\\<^sup>T) ;\n  (q\\<^sup>T ; q ; 1 \\<cdot> 1 ; p)\n  \\<le> p ; 1 ; q\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "also"], ["proof (state)\nthis:\n  (1 \\<cdot> p ; (q\\<^sup>T ; q ; 1)\\<^sup>T) ;\n  (q\\<^sup>T ; q ; 1 \\<cdot> 1 ; p)\n  \\<le> p ; 1 ; q\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "have \"... \\<le> p;1;p\\<^sup>T;q;q\\<^sup>T;q;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; 1 ; q\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n    \\<le> p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1", "using assms(3)"], ["proof (prove)\nusing this:\n  q \\<le> p\n\ngoal (1 subgoal):\n 1. p ; 1 ; q\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n    \\<le> p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1", "by (metis comp_assoc conv_iso mult_double_iso)"], ["proof (state)\nthis:\n  p ; 1 ; q\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n  \\<le> p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "also"], ["proof (state)\nthis:\n  p ; 1 ; q\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n  \\<le> p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "have \"... \\<le> 1';q;q\\<^sup>T;q;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n    \\<le> 1' ; q ; q\\<^sup>T ; q ; 1", "using pLp"], ["proof (prove)\nusing this:\n  p ; 1 ; p\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n    \\<le> 1' ; q ; q\\<^sup>T ; q ; 1", "using mult_isor"], ["proof (prove)\nusing this:\n  p ; 1 ; p\\<^sup>T \\<le> 1'\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n\ngoal (1 subgoal):\n 1. p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1\n    \\<le> 1' ; q ; q\\<^sup>T ; q ; 1", "by blast"], ["proof (state)\nthis:\n  p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1 \\<le> 1' ; q ; q\\<^sup>T ; q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "also"], ["proof (state)\nthis:\n  p ; 1 ; p\\<^sup>T ; q ; q\\<^sup>T ; q ; 1 \\<le> 1' ; q ; q\\<^sup>T ; q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "have \"... \\<le> q;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1' ; q ; q\\<^sup>T ; q ; 1 \\<le> q ; 1", "using assms(2) singleton_singletonT"], ["proof (prove)\nusing this:\n  singleton q\n  singleton ?p \\<Longrightarrow> ?p ; ?p\\<^sup>T \\<le> 1'\n\ngoal (1 subgoal):\n 1. 1' ; q ; q\\<^sup>T ; q ; 1 \\<le> q ; 1", "by (simp add: comp_assoc mult_isol)"], ["proof (state)\nthis:\n  1' ; q ; q\\<^sup>T ; q ; 1 \\<le> q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "finally"], ["proof (chain)\npicking this:\n  p \\<le> q ; 1", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<le> q ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "."], ["proof (state)\nthis:\n  p \\<le> q ; 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_equal:\n assumes \"singleton p\"\n     and \"singleton q\"\n     and \"q\\<le>p\"\n   shows \"q=p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q = p", "have p1: \"p \\<le> q;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "using assms"], ["proof (prove)\nusing this:\n  singleton p\n  singleton q\n  q \\<le> p\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1", "by (rule singleton_equal_aux)"], ["proof (state)\nthis:\n  p \\<le> q ; 1\n\ngoal (1 subgoal):\n 1. q = p", "have \"p\\<^sup>T \\<le> q\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sup>T \\<le> q\\<^sup>T ; 1", "using assms singleton_equal_aux singleton_transp conv_iso"], ["proof (prove)\nusing this:\n  singleton p\n  singleton q\n  q \\<le> p\n  \\<lbrakk>singleton ?p; singleton ?q; ?q \\<le> ?p\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> ?q ; 1\n  singleton ?p \\<Longrightarrow> singleton (?p\\<^sup>T)\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. p\\<^sup>T \\<le> q\\<^sup>T ; 1", "by fastforce"], ["proof (state)\nthis:\n  p\\<^sup>T \\<le> q\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. q = p", "hence p2: \"p \\<le> 1;q\""], ["proof (prove)\nusing this:\n  p\\<^sup>T \\<le> q\\<^sup>T ; 1\n\ngoal (1 subgoal):\n 1. p \\<le> 1 ; q", "using conv_iso"], ["proof (prove)\nusing this:\n  p\\<^sup>T \\<le> q\\<^sup>T ; 1\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. p \\<le> 1 ; q", "by force"], ["proof (state)\nthis:\n  p \\<le> 1 ; q\n\ngoal (1 subgoal):\n 1. q = p", "have \"p \\<le> q;1 \\<cdot> 1;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> q ; 1 \\<cdot> 1 ; q", "using p1 p2 inf.boundedI"], ["proof (prove)\nusing this:\n  p \\<le> q ; 1\n  p \\<le> 1 ; q\n  \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<cdot> ?c\n\ngoal (1 subgoal):\n 1. p \\<le> q ; 1 \\<cdot> 1 ; q", "by blast"], ["proof (state)\nthis:\n  p \\<le> q ; 1 \\<cdot> 1 ; q\n\ngoal (1 subgoal):\n 1. q = p", "also"], ["proof (state)\nthis:\n  p \\<le> q ; 1 \\<cdot> 1 ; q\n\ngoal (1 subgoal):\n 1. q = p", "have \"... \\<le> (q \\<cdot> 1;q;1);(1 \\<cdot> q\\<^sup>T;1;q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q ; 1 \\<cdot> 1 ; q\n    \\<le> (q \\<cdot> 1 ; q ; 1) ; (1 \\<cdot> q\\<^sup>T ; 1 ; q)", "using dedekind"], ["proof (prove)\nusing this:\n  ?x ; ?y \\<cdot> ?z\n  \\<le> (?x \\<cdot> ?z ; ?y\\<^sup>T) ; (?y \\<cdot> ?x\\<^sup>T ; ?z)\n\ngoal (1 subgoal):\n 1. q ; 1 \\<cdot> 1 ; q\n    \\<le> (q \\<cdot> 1 ; q ; 1) ; (1 \\<cdot> q\\<^sup>T ; 1 ; q)", "by (metis comp_assoc conv_one)"], ["proof (state)\nthis:\n  q ; 1 \\<cdot> 1 ; q\n  \\<le> (q \\<cdot> 1 ; q ; 1) ; (1 \\<cdot> q\\<^sup>T ; 1 ; q)\n\ngoal (1 subgoal):\n 1. q = p", "also"], ["proof (state)\nthis:\n  q ; 1 \\<cdot> 1 ; q\n  \\<le> (q \\<cdot> 1 ; q ; 1) ; (1 \\<cdot> q\\<^sup>T ; 1 ; q)\n\ngoal (1 subgoal):\n 1. q = p", "have \"... \\<le> q;q\\<^sup>T;1;q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q \\<cdot> 1 ; q ; 1) ; (1 \\<cdot> q\\<^sup>T ; 1 ; q)\n    \\<le> q ; q\\<^sup>T ; 1 ; q", "by (simp add: mult_isor comp_assoc)"], ["proof (state)\nthis:\n  (q \\<cdot> 1 ; q ; 1) ; (1 \\<cdot> q\\<^sup>T ; 1 ; q)\n  \\<le> q ; q\\<^sup>T ; 1 ; q\n\ngoal (1 subgoal):\n 1. q = p", "also"], ["proof (state)\nthis:\n  (q \\<cdot> 1 ; q ; 1) ; (1 \\<cdot> q\\<^sup>T ; 1 ; q)\n  \\<le> q ; q\\<^sup>T ; 1 ; q\n\ngoal (1 subgoal):\n 1. q = p", "have \"... \\<le> q;1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q ; q\\<^sup>T ; 1 ; q \\<le> q ; 1'", "by (metis assms(2) conv_contrav conv_invol conv_one is_inj_def mult_assoc mult_isol\n              one_idem_mult)"], ["proof (state)\nthis:\n  q ; q\\<^sup>T ; 1 ; q \\<le> q ; 1'\n\ngoal (1 subgoal):\n 1. q = p", "also"], ["proof (state)\nthis:\n  q ; q\\<^sup>T ; 1 ; q \\<le> q ; 1'\n\ngoal (1 subgoal):\n 1. q = p", "have \"... \\<le> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q ; 1' \\<le> q", "by simp"], ["proof (state)\nthis:\n  q ; 1' \\<le> q\n\ngoal (1 subgoal):\n 1. q = p", "finally"], ["proof (chain)\npicking this:\n  p \\<le> q", "have \"p \\<le> q\""], ["proof (prove)\nusing this:\n  p \\<le> q\n\ngoal (1 subgoal):\n 1. p \\<le> q", "."], ["proof (state)\nthis:\n  p \\<le> q\n\ngoal (1 subgoal):\n 1. q = p", "thus \"q=p\""], ["proof (prove)\nusing this:\n  p \\<le> q\n\ngoal (1 subgoal):\n 1. q = p", "using assms(3)"], ["proof (prove)\nusing this:\n  p \\<le> q\n  q \\<le> p\n\ngoal (1 subgoal):\n 1. q = p", "by simp"], ["proof (state)\nthis:\n  q = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_nonsplit:\n  assumes \"singleton p\"\n      and \"x\\<le>p\"\n    shows \"x=0 \\<or> x=p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0 \\<or> x = p", "proof (cases \"x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x = 0 \\<or> x = p\n 2. x \\<noteq> 0 \\<Longrightarrow> x = 0 \\<or> x = p", "assume \"x=0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x = 0 \\<or> x = p\n 2. x \\<noteq> 0 \\<Longrightarrow> x = 0 \\<or> x = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<or> x = p", ".."], ["proof (state)\nthis:\n  x = 0 \\<or> x = p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x = 0 \\<or> x = p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x = 0 \\<or> x = p", "assume 1: \"x\\<noteq>0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x = 0 \\<or> x = p", "have \"singleton x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton x", "proof (safe)"], ["proof (state)\ngoal (4 subgoals):\n 1. is_inj (x ; 1)\n 2. is_sur (x ; 1)\n 3. is_inj (x\\<^sup>T ; 1)\n 4. is_sur (x\\<^sup>T ; 1)", "show \"is_inj (x;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj (x ; 1)", "using assms injective_down_closed mult_isor"], ["proof (prove)\nusing this:\n  singleton p\n  x \\<le> p\n  \\<lbrakk>is_inj ?x; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> is_inj ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n\ngoal (1 subgoal):\n 1. is_inj (x ; 1)", "by blast"], ["proof (state)\nthis:\n  is_inj (x ; 1)\n\ngoal (3 subgoals):\n 1. is_sur (x ; 1)\n 2. is_inj (x\\<^sup>T ; 1)\n 3. is_sur (x\\<^sup>T ; 1)", "show \"is_inj (x\\<^sup>T;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj (x\\<^sup>T ; 1)", "using assms conv_iso injective_down_closed mult_isol_var"], ["proof (prove)\nusing this:\n  singleton p\n  x \\<le> p\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  \\<lbrakk>is_inj ?x; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> is_inj ?y\n  \\<lbrakk>?u \\<le> ?x; ?v \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?u ; ?v \\<le> ?x ; ?y\n\ngoal (1 subgoal):\n 1. is_inj (x\\<^sup>T ; 1)", "by blast"], ["proof (state)\nthis:\n  is_inj (x\\<^sup>T ; 1)\n\ngoal (2 subgoals):\n 1. is_sur (x ; 1)\n 2. is_sur (x\\<^sup>T ; 1)", "show \"is_sur (x;1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sur (x ; 1)", "using 1 comp_assoc sur_def_var1 tarski"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_sur ?x = (1 ; ?x = 1)\n  (?x \\<noteq> 0) = (1 ; ?x ; 1 = 1)\n\ngoal (1 subgoal):\n 1. is_sur (x ; 1)", "by fastforce"], ["proof (state)\nthis:\n  is_sur (x ; 1)\n\ngoal (1 subgoal):\n 1. is_sur (x\\<^sup>T ; 1)", "thus \"is_sur (x\\<^sup>T;1)\""], ["proof (prove)\nusing this:\n  is_sur (x ; 1)\n\ngoal (1 subgoal):\n 1. is_sur (x\\<^sup>T ; 1)", "by (metis conv_contrav conv_one mult.semigroup_axioms sur_def_var1 semigroup.assoc)"], ["proof (state)\nthis:\n  is_sur (x\\<^sup>T ; 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  singleton x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x = 0 \\<or> x = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  singleton x\n\ngoal (1 subgoal):\n 1. x = 0 \\<or> x = p", "using assms singleton_equal"], ["proof (prove)\nusing this:\n  singleton x\n  singleton p\n  x \\<le> p\n  \\<lbrakk>singleton ?p; singleton ?q; ?q \\<le> ?p\\<rbrakk>\n  \\<Longrightarrow> ?q = ?p\n\ngoal (1 subgoal):\n 1. x = 0 \\<or> x = p", "by blast"], ["proof (state)\nthis:\n  x = 0 \\<or> x = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_nonzero:\n  assumes \"singleton p\"\n    shows \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> False", "assume \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> False", "hence \"point 0\""], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. point 0", "using assms singleton_is_point"], ["proof (prove)\nusing this:\n  p = 0\n  singleton p\n  singleton ?p \\<Longrightarrow> point (?p ; 1)\n\ngoal (1 subgoal):\n 1. point 0", "by fastforce"], ["proof (state)\nthis:\n  point 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  point 0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: is_point_def point_is_point)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_sum:\n  assumes \"singleton p\"\n    shows \"p \\<le> x+y \\<longleftrightarrow> (p\\<le>x \\<or> p\\<le>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> x + y) = (p \\<le> x \\<or> p \\<le> y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> x + y \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y\n 2. p \\<le> x \\<or> p \\<le> y \\<Longrightarrow> p \\<le> x + y", "show \"p \\<le> x + y \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "assume as: \"p \\<le> x + y\""], ["proof (state)\nthis:\n  p \\<le> x + y\n\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "show \"p \\<le> x \\<or> p \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> x \\<or> p \\<le> y", "proof (cases \"p\\<le>x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y\n 2. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "assume \"p\\<le>x\""], ["proof (state)\nthis:\n  p \\<le> x\n\ngoal (2 subgoals):\n 1. p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y\n 2. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<le> x\n\ngoal (1 subgoal):\n 1. p \\<le> x \\<or> p \\<le> y", ".."], ["proof (state)\nthis:\n  p \\<le> x \\<or> p \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "assume a:\"\\<not>(p\\<le>x)\""], ["proof (state)\nthis:\n  \\<not> p \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "hence \"p\\<cdot>x \\<noteq> p\""], ["proof (prove)\nusing this:\n  \\<not> p \\<le> x\n\ngoal (1 subgoal):\n 1. p \\<cdot> x \\<noteq> p", "using a inf.orderI"], ["proof (prove)\nusing this:\n  \\<not> p \\<le> x\n  \\<not> p \\<le> x\n  ?a = ?a \\<cdot> ?b \\<Longrightarrow> ?a \\<le> ?b\n\ngoal (1 subgoal):\n 1. p \\<cdot> x \\<noteq> p", "by fastforce"], ["proof (state)\nthis:\n  p \\<cdot> x \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "hence \"p \\<le> -x\""], ["proof (prove)\nusing this:\n  p \\<cdot> x \\<noteq> p\n\ngoal (1 subgoal):\n 1. p \\<le> - x", "using assms singleton_nonsplit galois_aux inf_le1"], ["proof (prove)\nusing this:\n  p \\<cdot> x \\<noteq> p\n  singleton p\n  \\<lbrakk>singleton ?p; ?x \\<le> ?p\\<rbrakk>\n  \\<Longrightarrow> ?x = 0 \\<or> ?x = ?p\n  (?x \\<cdot> ?y = 0) = (?x \\<le> - ?y)\n  ?x \\<cdot> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. p \\<le> - x", "by blast"], ["proof (state)\nthis:\n  p \\<le> - x\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "hence \"p\\<le>y\""], ["proof (prove)\nusing this:\n  p \\<le> - x\n\ngoal (1 subgoal):\n 1. p \\<le> y", "using as"], ["proof (prove)\nusing this:\n  p \\<le> - x\n  p \\<le> x + y\n\ngoal (1 subgoal):\n 1. p \\<le> y", "by (metis galois_1 inf.orderE)"], ["proof (state)\nthis:\n  p \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> x \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<le> y\n\ngoal (1 subgoal):\n 1. p \\<le> x \\<or> p \\<le> y", "by simp"], ["proof (state)\nthis:\n  p \\<le> x \\<or> p \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<le> x \\<or> p \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<le> x + y \\<Longrightarrow> p \\<le> x \\<or> p \\<le> y\n\ngoal (1 subgoal):\n 1. p \\<le> x \\<or> p \\<le> y \\<Longrightarrow> p \\<le> x + y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<le> x \\<or> p \\<le> y \\<Longrightarrow> p \\<le> x + y", "show \"p \\<le> x \\<or> p \\<le> y \\<Longrightarrow> p \\<le> x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> x \\<or> p \\<le> y \\<Longrightarrow> p \\<le> x + y", "using sup.coboundedI1 sup.coboundedI2"], ["proof (prove)\nusing this:\n  ?c \\<le> ?a \\<Longrightarrow> ?c \\<le> ?a + ?b\n  ?c \\<le> ?b \\<Longrightarrow> ?c \\<le> ?a + ?b\n\ngoal (1 subgoal):\n 1. p \\<le> x \\<or> p \\<le> y \\<Longrightarrow> p \\<le> x + y", "by blast"], ["proof (state)\nthis:\n  p \\<le> x \\<or> p \\<le> y \\<Longrightarrow> p \\<le> x + y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_iff:\n \"singleton x \\<longleftrightarrow> x \\<noteq> 0 \\<and> x\\<^sup>T;1;x + x;1;x\\<^sup>T \\<le> 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton x =\n    (x \\<noteq> 0 \\<and> x\\<^sup>T ; 1 ; x + x ; 1 ; x\\<^sup>T \\<le> 1')", "by (smt comp_assoc conv_contrav conv_invol conv_one is_inj_def le_sup_iff one_idem_mult\n        sur_def_var1 tarski)"], ["", "lemma singleton_not_atom_in_relation_algebra_tarski:\n assumes \"p\\<noteq>0\"\n     and \"\\<forall>x . x\\<le>p \\<longrightarrow> x=0 \\<or> x=p\"\n   shows \"singleton p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton p", "nitpick [expect=genuine]"], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton p", "oops"], ["", "end"], ["", "(* relation_algebra_tarski *)"], ["", "subsection \\<open>Relation algebras satisfying the point axiom\\<close>"], ["", "class relation_algebra_point = relation_algebra +\n  assumes point_axiom: \"x \\<noteq> 0 \\<longrightarrow> (\\<exists>y z . point y \\<and> point z \\<and> y;z\\<^sup>T \\<le> x)\"\nbegin"], ["", "text \\<open>Some (more) results about points\\<close>"], ["", "lemma point_exists:\n  \"\\<exists>x . point x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. point x", "by (metis (full_types) eq_iff is_inj_def is_sur_def is_vector_def point_axiom point_def)"], ["", "lemma point_below_vector:\n  assumes \"is_vector v\"\n      and \"v \\<noteq> 0\"\n    shows \"\\<exists>x . point x \\<and> x \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. point x \\<and> x \\<le> v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. point x \\<and> x \\<le> v", "from assms(2)"], ["proof (chain)\npicking this:\n  v \\<noteq> 0", "obtain y and z where 1: \"point y \\<and> point z \\<and> y;z\\<^sup>T \\<le> v\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y z.\n        point y \\<and>\n        point z \\<and> y ; z\\<^sup>T \\<le> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using point_axiom"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  ?x \\<noteq> 0 \\<longrightarrow>\n  (\\<exists>y z. point y \\<and> point z \\<and> y ; z\\<^sup>T \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>y z.\n        point y \\<and>\n        point z \\<and> y ; z\\<^sup>T \\<le> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  point y \\<and> point z \\<and> y ; z\\<^sup>T \\<le> v\n\ngoal (1 subgoal):\n 1. \\<exists>x. point x \\<and> x \\<le> v", "have \"z\\<^sup>T;1 = (1;z)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>T ; 1 = (1 ; z)\\<^sup>T", "using conv_contrav conv_one"], ["proof (prove)\nusing this:\n  (?x ; ?y)\\<^sup>T = ?y\\<^sup>T ; ?x\\<^sup>T\n  1\\<^sup>T = 1\n\ngoal (1 subgoal):\n 1. z\\<^sup>T ; 1 = (1 ; z)\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  z\\<^sup>T ; 1 = (1 ; z)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<exists>x. point x \\<and> x \\<le> v", "hence \"y;(1;z)\\<^sup>T \\<le> v\""], ["proof (prove)\nusing this:\n  z\\<^sup>T ; 1 = (1 ; z)\\<^sup>T\n\ngoal (1 subgoal):\n 1. y ; (1 ; z)\\<^sup>T \\<le> v", "using 1"], ["proof (prove)\nusing this:\n  z\\<^sup>T ; 1 = (1 ; z)\\<^sup>T\n  point y \\<and> point z \\<and> y ; z\\<^sup>T \\<le> v\n\ngoal (1 subgoal):\n 1. y ; (1 ; z)\\<^sup>T \\<le> v", "by (metis assms(1) comp_assoc is_vector_def mult_isor)"], ["proof (state)\nthis:\n  y ; (1 ; z)\\<^sup>T \\<le> v\n\ngoal (1 subgoal):\n 1. \\<exists>x. point x \\<and> x \\<le> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  y ; (1 ; z)\\<^sup>T \\<le> v\n\ngoal (1 subgoal):\n 1. \\<exists>x. point x \\<and> x \\<le> v", "using 1"], ["proof (prove)\nusing this:\n  y ; (1 ; z)\\<^sup>T \\<le> v\n  point y \\<and> point z \\<and> y ; z\\<^sup>T \\<le> v\n\ngoal (1 subgoal):\n 1. \\<exists>x. point x \\<and> x \\<le> v", "by (metis conv_one is_vector_def point_def sur_def_var1)"], ["proof (state)\nthis:\n  \\<exists>x. point x \\<and> x \\<le> v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* relation_algebra_point *)"], ["", "class relation_algebra_tarski_point = relation_algebra_tarski + relation_algebra_point\nbegin"], ["", "lemma atom_is_singleton:\n  assumes \"p\\<noteq>0\"\n      and \"\\<forall>x . x\\<le>p \\<longrightarrow> x=0 \\<or> x=p\"\n    shows \"singleton p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton p", "by (metis assms singleton_nonzero singleton_pq point_axiom)"], ["", "lemma singleton_iff_atom:\n  \"singleton p \\<longleftrightarrow> p\\<noteq>0 \\<and> (\\<forall>x . x\\<le>p \\<longrightarrow> x=0 \\<or> x=p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton p =\n    (p \\<noteq> 0 \\<and> (\\<forall>x\\<le>p. x = 0 \\<or> x = p))", "using singleton_nonsplit singleton_nonzero atom_is_singleton"], ["proof (prove)\nusing this:\n  \\<lbrakk>singleton ?p; ?x \\<le> ?p\\<rbrakk>\n  \\<Longrightarrow> ?x = 0 \\<or> ?x = ?p\n  singleton ?p \\<Longrightarrow> ?p \\<noteq> 0\n  \\<lbrakk>?p \\<noteq> 0; \\<forall>x\\<le>?p. x = 0 \\<or> x = ?p\\<rbrakk>\n  \\<Longrightarrow> singleton ?p\n\ngoal (1 subgoal):\n 1. singleton p =\n    (p \\<noteq> 0 \\<and> (\\<forall>x\\<le>p. x = 0 \\<or> x = p))", "by blast"], ["", "lemma maddux_tarski:\n  assumes \"x\\<noteq>0\"\n  shows \"\\<exists>y . y\\<noteq>0 \\<and> y\\<le>x \\<and> is_p_fun y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y", "obtain p q where 1: \"point p \\<and> point q \\<and> p;q\\<^sup>T \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        point p \\<and>\n        point q \\<and> p ; q\\<^sup>T \\<le> x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms point_axiom"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ?x \\<noteq> 0 \\<longrightarrow>\n  (\\<exists>y z. point y \\<and> point z \\<and> y ; z\\<^sup>T \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        point p \\<and>\n        point q \\<and> p ; q\\<^sup>T \\<le> x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  point p \\<and> point q \\<and> p ; q\\<^sup>T \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y", "hence 2: \"p;q\\<^sup>T\\<noteq>0\""], ["proof (prove)\nusing this:\n  point p \\<and> point q \\<and> p ; q\\<^sup>T \\<le> x\n\ngoal (1 subgoal):\n 1. p ; q\\<^sup>T \\<noteq> 0", "by (simp add: singleton_nonzero singleton_pq)"], ["proof (state)\nthis:\n  p ; q\\<^sup>T \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y", "have \"is_p_fun (p;q\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_p_fun (p ; q\\<^sup>T)", "using 1"], ["proof (prove)\nusing this:\n  point p \\<and> point q \\<and> p ; q\\<^sup>T \\<le> x\n\ngoal (1 subgoal):\n 1. is_p_fun (p ; q\\<^sup>T)", "by (meson singleton_singletonT singleton_pq singleton_transp is_inj_def p_fun_inj)"], ["proof (state)\nthis:\n  is_p_fun (p ; q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_p_fun (p ; q\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y", "using 1 2"], ["proof (prove)\nusing this:\n  is_p_fun (p ; q\\<^sup>T)\n  point p \\<and> point q \\<and> p ; q\\<^sup>T \\<le> x\n  p ; q\\<^sup>T \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y", "by force"], ["proof (state)\nthis:\n  \\<exists>y. y \\<noteq> 0 \\<and> y \\<le> x \\<and> is_p_fun y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Intermediate Point Theorem \\cite[Proposition 2.4.8]{SchmidtStroehlein1993}\\<close>"], ["", "lemma intermediate_point_theorem:\n  assumes \"point p\"\n      and \"point r\"\n    shows \"p \\<le> x;y;r \\<longleftrightarrow> (\\<exists>q . point q \\<and> p \\<le> x;q \\<and> q \\<le> y;r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> x ; y ; r) =\n    (\\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> x ; y ; r \\<Longrightarrow>\n    \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n 2. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "assume 1: \"p \\<le> x;y;r\""], ["proof (state)\nthis:\n  p \\<le> x ; y ; r\n\ngoal (2 subgoals):\n 1. p \\<le> x ; y ; r \\<Longrightarrow>\n    \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n 2. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "let ?v = \"x\\<^sup>T;p \\<cdot> y;r\""], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> x ; y ; r \\<Longrightarrow>\n    \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n 2. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "have 2: \"is_vector ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector (x\\<^sup>T ; p \\<cdot> y ; r)", "using assms comp_assoc is_vector_def point_def vector_mult"], ["proof (prove)\nusing this:\n  point p\n  point r\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  is_vector ?x \\<equiv> ?x = ?x ; 1\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  \\<lbrakk>is_vector ?x; is_vector ?y\\<rbrakk>\n  \\<Longrightarrow> is_vector (?x \\<cdot> ?y)\n\ngoal (1 subgoal):\n 1. is_vector (x\\<^sup>T ; p \\<cdot> y ; r)", "by fastforce"], ["proof (state)\nthis:\n  is_vector (x\\<^sup>T ; p \\<cdot> y ; r)\n\ngoal (2 subgoals):\n 1. p \\<le> x ; y ; r \\<Longrightarrow>\n    \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n 2. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "have \"?v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; p \\<cdot> y ; r \\<noteq> 0", "using 1"], ["proof (prove)\nusing this:\n  p \\<le> x ; y ; r\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; p \\<cdot> y ; r \\<noteq> 0", "by (metis assms(1) inf.absorb2 is_point_def maddux_141 point_is_point mult.assoc)"], ["proof (state)\nthis:\n  x\\<^sup>T ; p \\<cdot> y ; r \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<le> x ; y ; r \\<Longrightarrow>\n    \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n 2. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "hence \"\\<exists>q . point q \\<and> q \\<le> ?v\""], ["proof (prove)\nusing this:\n  x\\<^sup>T ; p \\<cdot> y ; r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>q. point q \\<and> q \\<le> x\\<^sup>T ; p \\<cdot> y ; r", "using 2 point_below_vector"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; p \\<cdot> y ; r \\<noteq> 0\n  is_vector (x\\<^sup>T ; p \\<cdot> y ; r)\n  \\<lbrakk>is_vector ?v; ?v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. point x \\<and> x \\<le> ?v\n\ngoal (1 subgoal):\n 1. \\<exists>q. point q \\<and> q \\<le> x\\<^sup>T ; p \\<cdot> y ; r", "by blast"], ["proof (state)\nthis:\n  \\<exists>q. point q \\<and> q \\<le> x\\<^sup>T ; p \\<cdot> y ; r\n\ngoal (2 subgoals):\n 1. p \\<le> x ; y ; r \\<Longrightarrow>\n    \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n 2. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "thus \"\\<exists>q . point q \\<and> p \\<le> x;q \\<and> q \\<le> y;r\""], ["proof (prove)\nusing this:\n  \\<exists>q. point q \\<and> q \\<le> x\\<^sup>T ; p \\<cdot> y ; r\n\ngoal (1 subgoal):\n 1. \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r", "using assms(1) point_swap"], ["proof (prove)\nusing this:\n  \\<exists>q. point q \\<and> q \\<le> x\\<^sup>T ; p \\<cdot> y ; r\n  point p\n  \\<lbrakk>point ?p; point ?q\\<rbrakk>\n  \\<Longrightarrow> (?p \\<le> ?x ; ?q) = (?q \\<le> ?x\\<^sup>T ; ?p)\n\ngoal (1 subgoal):\n 1. \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "assume \"\\<exists>q . point q \\<and> p \\<le> x;q \\<and> q \\<le> y;r\""], ["proof (state)\nthis:\n  \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r \\<Longrightarrow>\n    p \\<le> x ; y ; r", "thus \"p \\<le> x;y;r\""], ["proof (prove)\nusing this:\n  \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n\ngoal (1 subgoal):\n 1. p \\<le> x ; y ; r", "using comp_assoc mult_isol order_trans"], ["proof (prove)\nusing this:\n  \\<exists>q. point q \\<and> p \\<le> x ; q \\<and> q \\<le> y ; r\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. p \\<le> x ; y ; r", "by fastforce"], ["proof (state)\nthis:\n  p \\<le> x ; y ; r\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* relation_algebra_tarski_point *)\n\n(*\nThe following shows that rtc can be defined with only 2 axioms.\nThis should eventually go into AFP/Relation_Algebra_RTC.relation_algebra_rtc.\nThere the class definition should be replaced with:\n\nclass relation_algebra_rtc = relation_algebra + star_op +\n  assumes rtc_unfoldl: \"1' + x ; x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\"\n      and rtc_inductl: \"z + x ; y \\<le> y \\<longrightarrow> x\\<^sup>\\<star> ; z \\<le> y\"\n\nand the following lemmas:\n*)"], ["", "context relation_algebra\nbegin"], ["", "lemma unfoldl_inductl_implies_unfoldr:\n  assumes \"\\<And>x. 1' + x;(rtc x) \\<le> rtc x\"\n      and \"\\<And>x y z. x+y;z \\<le> z \\<Longrightarrow> rtc(y);x \\<le> z\"\n    shows \"1' + rtc(x);x \\<le> rtc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1' + rtc x ; x \\<le> rtc x", "by (metis assms le_sup_iff mult_oner order.trans subdistl_eq sup_absorb2 sup_ge1)"], ["", "lemma star_transpose_swap:\n  assumes \"\\<And>x. 1' + x;(rtc x) \\<le> rtc x\"\n      and \"\\<And>x y z. x+y;z \\<le> z \\<Longrightarrow> rtc(y);x \\<le> z\"\n    shows \"rtc(x\\<^sup>T) = (rtc x)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtc (x\\<^sup>T) = rtc x\\<^sup>T", "apply(simp only: eq_iff; rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rtc (x\\<^sup>T) \\<le> rtc x\\<^sup>T\n 2. rtc x\\<^sup>T \\<le> rtc (x\\<^sup>T)", "apply (metis assms conv_add conv_contrav conv_e conv_iso mult_1_right\n             unfoldl_inductl_implies_unfoldr )"], ["proof (prove)\ngoal (1 subgoal):\n 1. rtc x\\<^sup>T \\<le> rtc (x\\<^sup>T)", "by (metis assms conv_add conv_contrav conv_e conv_invol conv_iso mult_1_right\n          unfoldl_inductl_implies_unfoldr)"], ["", "lemma unfoldl_inductl_implies_inductr:\n  assumes \"\\<And>x. 1' + x;(rtc x) \\<le> rtc x\"\n      and \"\\<And>x y z. x+y;z \\<le> z \\<Longrightarrow> rtc(y);x \\<le> z\"\n    shows \"x+z;y \\<le> z \\<Longrightarrow> x;rtc(y) \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + z ; y \\<le> z \\<Longrightarrow> x ; rtc y \\<le> z", "by (metis assms conv_add conv_contrav conv_iso star_transpose_swap)"], ["", "end"], ["", "(* relation_algebra *)"], ["", "context relation_algebra_rtc\nbegin"], ["", "abbreviation tc (\"(_\\<^sup>+)\" [101] 100) where \"tc x \\<equiv> x;x\\<^sup>\\<star>\""], ["", "abbreviation is_acyclic\n  where \"is_acyclic x \\<equiv> x\\<^sup>+ \\<le> -1'\""], ["", "text \\<open>General theorems\\<close>"], ["", "lemma star_denest_10:\n  assumes \"x;y=0\"\n    shows \"(x+y)\\<^sup>\\<star> = y;y\\<^sup>\\<star>;x\\<^sup>\\<star>+x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y)\\<^sup>\\<star> = y\\<^sup>+ ; x\\<^sup>\\<star> + x\\<^sup>\\<star>", "using assms bubble_sort sup.commute"], ["proof (prove)\nusing this:\n  x ; y = 0\n  ?y ; ?x \\<le> ?x ; ?y \\<Longrightarrow>\n  (?x + ?y)\\<^sup>\\<star> = ?x\\<^sup>\\<star> ; ?y\\<^sup>\\<star>\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. (x + y)\\<^sup>\\<star> = y\\<^sup>+ ; x\\<^sup>\\<star> + x\\<^sup>\\<star>", "by auto"], ["", "lemma star_star_plus:\n  \"x\\<^sup>\\<star> + y\\<^sup>\\<star> = x\\<^sup>+ + y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> + y\\<^sup>\\<star> = x\\<^sup>+ + y\\<^sup>\\<star>", "by (metis (full_types) sup.left_commute star_plus_one star_unfoldl_eq sup.commute)"], ["", "text \\<open>The following two lemmas are from \\cite{Guttmann2018b}.\\<close>"], ["", "lemma cancel_separate:\n  assumes \"x ; y \\<le> 1'\"\n  shows \"x\\<^sup>\\<star> ; y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "have \"x ; y\\<^sup>\\<star> = x + x ; y ; y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y\\<^sup>\\<star> = x + x ; y ; y\\<^sup>\\<star>", "by (metis comp_assoc conway.dagger_unfoldl_distr distrib_left mult_oner)"], ["proof (state)\nthis:\n  x ; y\\<^sup>\\<star> = x + x ; y ; y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x ; y\\<^sup>\\<star> = x + x ; y ; y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "have \"... \\<le> x + y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + x ; y ; y\\<^sup>\\<star> \\<le> x + y\\<^sup>\\<star>", "by (metis assms join_isol star_invol star_plus_one star_subdist_var_2 sup.absorb2 sup.assoc)"], ["proof (state)\nthis:\n  x + x ; y ; y\\<^sup>\\<star> \\<le> x + y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x + x ; y ; y\\<^sup>\\<star> \\<le> x + y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "using join_iso"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x + ?z \\<le> ?y + ?z\n\ngoal (1 subgoal):\n 1. x + y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  x + y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x ; y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "have \"x ; (x\\<^sup>\\<star> + y\\<^sup>\\<star>) \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x ; y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x ; (x\\<^sup>\\<star> + y\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "by (simp add: distrib_left le_supI1)"], ["proof (state)\nthis:\n  x ; (x\\<^sup>\\<star> + y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x ; (x\\<^sup>\\<star> + y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>", "by (simp add: rtc_inductl)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + y\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cancel_separate_inj_converse:\n  assumes \"is_inj x\"\n    shows \"x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star> = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star> =\n    x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star>", "using assms cancel_separate is_inj_def"], ["proof (prove)\nusing this:\n  is_inj x\n  ?x ; ?y \\<le> 1' \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?y\\<^sup>\\<star>\n  \\<le> ?x\\<^sup>\\<star> + ?y\\<^sup>\\<star>\n  is_inj ?x \\<equiv> ?x ; ?x\\<^sup>T \\<le> 1'\n\ngoal (2 subgoals):\n 1. x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star>", "by (metis conway.dagger_unfoldl_distr le_supI mult_1_right mult_isol sup.cobounded1)"], ["", "lemma cancel_separate_p_fun_converse:\n  assumes \"is_p_fun x\"\n    shows \"x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>\\<star> = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>\\<star> =\n    x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "using sup_commute assms cancel_separate_inj_converse p_fun_inj"], ["proof (prove)\nusing this:\n  ?x + ?y = ?y + ?x\n  is_p_fun x\n  is_inj ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> ; ?x\\<^sup>T\\<^sup>\\<star> =\n  ?x\\<^sup>\\<star> + ?x\\<^sup>T\\<^sup>\\<star>\n  is_p_fun ?x = is_inj (?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>\\<star> =\n    x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by fastforce"], ["", "lemma cancel_separate_converse_idempotent:\n  assumes \"is_inj x\"\n      and \"is_p_fun x\"\n    shows \"(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>);(x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) ;\n    (x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>) =\n    x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by (metis assms cancel_separate cancel_separate_p_fun_converse church_rosser_equiv is_inj_def\n          star_denest_var_6)"], ["", "lemma triple_star:\n  assumes \"is_inj x\"\n      and \"is_p_fun x\"\n    shows \"x\\<^sup>\\<star>;x\\<^sup>T\\<^sup>\\<star>;x\\<^sup>\\<star> = x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; x\\<^sup>T\\<^sup>\\<star> ; x\\<^sup>\\<star> =\n    x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by (simp add: assms cancel_separate_inj_converse cancel_separate_p_fun_converse)"], ["", "lemma inj_xxts:\n  assumes \"is_inj x\"\n    shows \"x;x\\<^sup>T\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; x\\<^sup>T\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> + x\\<^sup>T\\<^sup>\\<star>", "by (metis assms cancel_separate_inj_converse distrib_right less_eq_def star_ext)"], ["", "lemma plus_top:\n  \"x\\<^sup>+;1 = x;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ ; 1 = x ; 1", "by (metis comp_assoc conway.dagger_unfoldr_distr sup_top_left)"], ["", "lemma top_plus:\n  \"1;x\\<^sup>+ = 1;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ; x\\<^sup>+ = 1 ; x", "by (metis comp_assoc conway.dagger_unfoldr_distr star_denest_var_2 star_ext star_slide_var\n           sup_top_left top_unique)"], ["", "lemma plus_conv:\n  \"(x\\<^sup>+)\\<^sup>T = x\\<^sup>T\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+)\\<^sup>T = x\\<^sup>T\\<^sup>+", "by (simp add: star_conv star_slide_var)"], ["", "lemma inj_implies_step_forwards_backwards:\n  assumes \"is_inj x\"\n    shows \"x\\<^sup>\\<star>;(x\\<^sup>+\\<cdot>1');1 \\<le> x\\<^sup>T;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "have \"(x\\<^sup>+\\<cdot>1');1 \\<le> (x\\<^sup>\\<star>\\<cdot>x\\<^sup>T);(x\\<cdot>(x\\<^sup>\\<star>)\\<^sup>T);1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ;\n          (x \\<cdot> (x\\<^sup>\\<star>)\\<^sup>T) ;\n          1", "by (metis conv_contrav conv_e dedekind mult_1_right mult_isor star_slide_var)"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ;\n        (x \\<cdot> (x\\<^sup>\\<star>)\\<^sup>T) ;\n        1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "also"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ;\n        (x \\<cdot> (x\\<^sup>\\<star>)\\<^sup>T) ;\n        1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "have \"... \\<le> (x\\<^sup>\\<star>\\<cdot>x\\<^sup>T);1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ;\n    (x \\<cdot> (x\\<^sup>\\<star>)\\<^sup>T) ;\n    1\n    \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1", "by (simp add: comp_assoc mult_isol)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ;\n  (x \\<cdot> (x\\<^sup>\\<star>)\\<^sup>T) ;\n  1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "finally"], ["proof (chain)\npicking this:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1", "have 1: \"(x\\<^sup>+\\<cdot>1');1 \\<le> (x\\<^sup>\\<star>\\<cdot>x\\<^sup>T);1\""], ["proof (prove)\nusing this:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1", "."], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "have \"x;(x\\<^sup>\\<star>\\<cdot>x\\<^sup>T);1 \\<le> (x\\<^sup>+\\<cdot>x;x\\<^sup>T);1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n    \\<le> (x\\<^sup>+ \\<cdot> x ; x\\<^sup>T) ; 1", "by (metis inf_idem meet_interchange mult_isor)"], ["proof (state)\nthis:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>+ \\<cdot> x ; x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "also"], ["proof (state)\nthis:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>+ \\<cdot> x ; x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "have \"... \\<le> (x\\<^sup>+\\<cdot>1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> x ; x\\<^sup>T) ; 1 \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1", "using assms is_inj_def meet_isor mult_isor"], ["proof (prove)\nusing this:\n  is_inj x\n  is_inj ?x \\<equiv> ?x ; ?x\\<^sup>T \\<le> 1'\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<cdot> ?x \\<le> ?z \\<cdot> ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> x ; x\\<^sup>T) ; 1 \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1", "by fastforce"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> x ; x\\<^sup>T) ; 1 \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "finally"], ["proof (chain)\npicking this:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1", "have \"x;(x\\<^sup>\\<star>\\<cdot>x\\<^sup>T);1 \\<le> (x\\<^sup>\\<star>\\<cdot>x\\<^sup>T);1\""], ["proof (prove)\nusing this:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n    \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1", "using 1"], ["proof (prove)\nusing this:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>+ \\<cdot> 1') ; 1\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n    \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1", "by fastforce"], ["proof (state)\nthis:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "hence \"x\\<^sup>\\<star>;(x\\<^sup>+\\<cdot>1');1 \\<le> (x\\<^sup>\\<star>\\<cdot>x\\<^sup>T);1\""], ["proof (prove)\nusing this:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1", "using 1"], ["proof (prove)\nusing this:\n  x ; (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1", "by (simp add: comp_assoc rtc_inductl)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "thus \"x\\<^sup>\\<star>;(x\\<^sup>+\\<cdot>1');1 \\<le> x\\<^sup>T;1\""], ["proof (prove)\nusing this:\n  x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "using inf.cobounded2 mult_isor order_trans"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> (x\\<^sup>\\<star> \\<cdot> x\\<^sup>T) ; 1\n  ?a \\<cdot> ?b \\<le> ?b\n  ?x \\<le> ?y \\<Longrightarrow> ?x ; ?z \\<le> ?y ; ?z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1", "by blast"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> ; (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Acyclic relations\\<close>"], ["", "text \\<open>The following result is from \\cite{Guttmann2017c}.\\<close>"], ["", "lemma acyclic_inv:\n  assumes \"is_acyclic t\"\n      and \"is_vector v\"\n      and \"e \\<le> v;-v\\<^sup>T\"\n      and \"t \\<le> v;v\\<^sup>T\"\n    shows \"is_acyclic (t + e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"t\\<^sup>+;e \\<le> t\\<^sup>+;v;-v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; e \\<le> t\\<^sup>+ ; v ; - v\\<^sup>T", "by (simp add: assms(3) mult_assoc mult_isol)"], ["proof (state)\nthis:\n  t\\<^sup>+ ; e \\<le> t\\<^sup>+ ; v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  t\\<^sup>+ ; e \\<le> t\\<^sup>+ ; v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... \\<le> v;v\\<^sup>T;t\\<^sup>\\<star>;v;-v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; v ; - v\\<^sup>T\n    \\<le> v ; v\\<^sup>T ; t\\<^sup>\\<star> ; v ; - v\\<^sup>T", "by (simp add: assms(4) mult_isor)"], ["proof (state)\nthis:\n  t\\<^sup>+ ; v ; - v\\<^sup>T\n  \\<le> v ; v\\<^sup>T ; t\\<^sup>\\<star> ; v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  t\\<^sup>+ ; v ; - v\\<^sup>T\n  \\<le> v ; v\\<^sup>T ; t\\<^sup>\\<star> ; v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... \\<le> v;-v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ; v\\<^sup>T ; t\\<^sup>\\<star> ; v ; - v\\<^sup>T \\<le> v ; - v\\<^sup>T", "by (metis assms(2) mult_double_iso top_greatest is_vector_def mult_assoc)"], ["proof (state)\nthis:\n  v ; v\\<^sup>T ; t\\<^sup>\\<star> ; v ; - v\\<^sup>T \\<le> v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  v ; v\\<^sup>T ; t\\<^sup>\\<star> ; v ; - v\\<^sup>T \\<le> v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... \\<le> -1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ; - v\\<^sup>T \\<le> - 1'", "by (simp add: conv_galois_1)"], ["proof (state)\nthis:\n  v ; - v\\<^sup>T \\<le> - 1'\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "finally"], ["proof (chain)\npicking this:\n  t\\<^sup>+ ; e \\<le> - 1'", "have 1: \"t\\<^sup>+;e \\<le> -1'\""], ["proof (prove)\nusing this:\n  t\\<^sup>+ ; e \\<le> - 1'\n\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; e \\<le> - 1'", "."], ["proof (state)\nthis:\n  t\\<^sup>+ ; e \\<le> - 1'\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"e \\<le> v;-v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<le> v ; - v\\<^sup>T", "using assms(3)"], ["proof (prove)\nusing this:\n  e \\<le> v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e \\<le> v ; - v\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  e \\<le> v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  e \\<le> v ; - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... \\<le> -1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ; - v\\<^sup>T \\<le> - 1'", "by (simp add: conv_galois_1)"], ["proof (state)\nthis:\n  v ; - v\\<^sup>T \\<le> - 1'\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "finally"], ["proof (chain)\npicking this:\n  e \\<le> - 1'", "have 2: \"t\\<^sup>+;e + e \\<le> -1'\""], ["proof (prove)\nusing this:\n  e \\<le> - 1'\n\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; e + e \\<le> - 1'", "using 1"], ["proof (prove)\nusing this:\n  e \\<le> - 1'\n  t\\<^sup>+ ; e \\<le> - 1'\n\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; e + e \\<le> - 1'", "by simp"], ["proof (state)\nthis:\n  t\\<^sup>+ ; e + e \\<le> - 1'\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have 3: \"e;t\\<^sup>\\<star> = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e ; t\\<^sup>\\<star> = e", "by (metis assms(2-4) et(1) independence2)"], ["proof (state)\nthis:\n  e ; t\\<^sup>\\<star> = e\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have 4: \"e\\<^sup>\\<star> = 1' + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<^sup>\\<star> = 1' + e", "using assms(2-3) ee boffa_var bot_least"], ["proof (prove)\nusing this:\n  is_vector v\n  e \\<le> v ; - v\\<^sup>T\n  \\<lbrakk>is_vector ?v; ?e \\<le> ?v ; - ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> ?e ; ?e = 0\n  transitive ?x \\<Longrightarrow> ?x\\<^sup>\\<star> = 1' + ?x\n  0 \\<le> ?a\n\ngoal (1 subgoal):\n 1. e\\<^sup>\\<star> = 1' + e", "by blast"], ["proof (state)\nthis:\n  e\\<^sup>\\<star> = 1' + e\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"(t + e)\\<^sup>+ = (t + e);t\\<^sup>\\<star>;(e;t\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t + e)\\<^sup>+ =\n    (t + e) ; t\\<^sup>\\<star> ; (e ; t\\<^sup>\\<star>)\\<^sup>\\<star>", "by (simp add: comp_assoc)"], ["proof (state)\nthis:\n  (t + e)\\<^sup>+ =\n  (t + e) ; t\\<^sup>\\<star> ; (e ; t\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  (t + e)\\<^sup>+ =\n  (t + e) ; t\\<^sup>\\<star> ; (e ; t\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... = (t + e);t\\<^sup>\\<star>;(1' + e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t + e) ; t\\<^sup>\\<star> ; (e ; t\\<^sup>\\<star>)\\<^sup>\\<star> =\n    (t + e) ; t\\<^sup>\\<star> ; (1' + e)", "using 3 4"], ["proof (prove)\nusing this:\n  e ; t\\<^sup>\\<star> = e\n  e\\<^sup>\\<star> = 1' + e\n\ngoal (1 subgoal):\n 1. (t + e) ; t\\<^sup>\\<star> ; (e ; t\\<^sup>\\<star>)\\<^sup>\\<star> =\n    (t + e) ; t\\<^sup>\\<star> ; (1' + e)", "by simp"], ["proof (state)\nthis:\n  (t + e) ; t\\<^sup>\\<star> ; (e ; t\\<^sup>\\<star>)\\<^sup>\\<star> =\n  (t + e) ; t\\<^sup>\\<star> ; (1' + e)\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  (t + e) ; t\\<^sup>\\<star> ; (e ; t\\<^sup>\\<star>)\\<^sup>\\<star> =\n  (t + e) ; t\\<^sup>\\<star> ; (1' + e)\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... = t\\<^sup>+;(1' + e) + e;t\\<^sup>\\<star>;(1' + e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t + e) ; t\\<^sup>\\<star> ; (1' + e) =\n    t\\<^sup>+ ; (1' + e) + e ; t\\<^sup>\\<star> ; (1' + e)", "by simp"], ["proof (state)\nthis:\n  (t + e) ; t\\<^sup>\\<star> ; (1' + e) =\n  t\\<^sup>+ ; (1' + e) + e ; t\\<^sup>\\<star> ; (1' + e)\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  (t + e) ; t\\<^sup>\\<star> ; (1' + e) =\n  t\\<^sup>+ ; (1' + e) + e ; t\\<^sup>\\<star> ; (1' + e)\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... = t\\<^sup>+;(1' + e) + e;(1' + e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; (1' + e) + e ; t\\<^sup>\\<star> ; (1' + e) =\n    t\\<^sup>+ ; (1' + e) + e ; (1' + e)", "using 3"], ["proof (prove)\nusing this:\n  e ; t\\<^sup>\\<star> = e\n\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; (1' + e) + e ; t\\<^sup>\\<star> ; (1' + e) =\n    t\\<^sup>+ ; (1' + e) + e ; (1' + e)", "by simp"], ["proof (state)\nthis:\n  t\\<^sup>+ ; (1' + e) + e ; t\\<^sup>\\<star> ; (1' + e) =\n  t\\<^sup>+ ; (1' + e) + e ; (1' + e)\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  t\\<^sup>+ ; (1' + e) + e ; t\\<^sup>\\<star> ; (1' + e) =\n  t\\<^sup>+ ; (1' + e) + e ; (1' + e)\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... = t\\<^sup>+;(1' + e) + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; (1' + e) + e ; (1' + e) = t\\<^sup>+ ; (1' + e) + e", "using 4 assms(2-3) ee independence2"], ["proof (prove)\nusing this:\n  e\\<^sup>\\<star> = 1' + e\n  is_vector v\n  e \\<le> v ; - v\\<^sup>T\n  \\<lbrakk>is_vector ?v; ?e \\<le> ?v ; - ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> ?e ; ?e = 0\n  ?x ; ?y = 0 \\<Longrightarrow> ?x ; ?y\\<^sup>\\<star> = ?x\n\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; (1' + e) + e ; (1' + e) = t\\<^sup>+ ; (1' + e) + e", "by fastforce"], ["proof (state)\nthis:\n  t\\<^sup>+ ; (1' + e) + e ; (1' + e) = t\\<^sup>+ ; (1' + e) + e\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  t\\<^sup>+ ; (1' + e) + e ; (1' + e) = t\\<^sup>+ ; (1' + e) + e\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... = t\\<^sup>+ + t\\<^sup>+;e + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>+ ; (1' + e) + e = t\\<^sup>+ + t\\<^sup>+ ; e + e", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  t\\<^sup>+ ; (1' + e) + e = t\\<^sup>+ + t\\<^sup>+ ; e + e\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "also"], ["proof (state)\nthis:\n  t\\<^sup>+ ; (1' + e) + e = t\\<^sup>+ + t\\<^sup>+ ; e + e\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "have \"... \\<le> -1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>+ + t\\<^sup>+ ; e + e \\<le> - 1'", "using assms(1) 2"], ["proof (prove)\nusing this:\n  is_acyclic t\n  t\\<^sup>+ ; e + e \\<le> - 1'\n\ngoal (1 subgoal):\n 1. t\\<^sup>+ + t\\<^sup>+ ; e + e \\<le> - 1'", "by simp"], ["proof (state)\nthis:\n  t\\<^sup>+ + t\\<^sup>+ ; e + e \\<le> - 1'\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "finally"], ["proof (chain)\npicking this:\n  is_acyclic (t + e)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_acyclic (t + e)\n\ngoal (1 subgoal):\n 1. is_acyclic (t + e)", "."], ["proof (state)\nthis:\n  is_acyclic (t + e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_single_step:\n  assumes \"is_acyclic x\"\n    shows \"x \\<le> -1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - 1'", "by (metis assms dual_order.trans mult_isol mult_oner star_ref)"], ["", "lemma acyclic_reachable_points:\n  assumes \"is_point p\"\n      and \"is_point q\"\n      and \"p \\<le> x;q\"\n      and \"is_acyclic x\"\n    shows \"p\\<noteq>q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "assume \"p=q\""], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "hence \"p \\<le> x;q \\<cdot> q\""], ["proof (prove)\nusing this:\n  p = q\n\ngoal (1 subgoal):\n 1. p \\<le> x ; q \\<cdot> q", "by (simp add: assms(3) eq_iff inf.absorb2)"], ["proof (state)\nthis:\n  p \\<le> x ; q \\<cdot> q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  p \\<le> x ; q \\<cdot> q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "have \"... = (x \\<cdot> 1');q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; q \\<cdot> q = (x \\<cdot> 1') ; q", "using assms(2) inj_distr is_point_def"], ["proof (prove)\nusing this:\n  is_point q\n  is_inj ?z \\<Longrightarrow> (?x \\<cdot> ?y) ; ?z = ?x ; ?z \\<cdot> ?y ; ?z\n  is_point ?x \\<equiv> is_vector ?x \\<and> is_inj ?x \\<and> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x ; q \\<cdot> q = (x \\<cdot> 1') ; q", "by simp"], ["proof (state)\nthis:\n  x ; q \\<cdot> q = (x \\<cdot> 1') ; q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  x ; q \\<cdot> q = (x \\<cdot> 1') ; q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "have \"... \\<le> (-1' \\<cdot> 1');q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> 1') ; q \\<le> (- 1' \\<cdot> 1') ; q", "using acyclic_single_step assms(4)"], ["proof (prove)\nusing this:\n  is_acyclic ?x \\<Longrightarrow> ?x \\<le> - 1'\n  is_acyclic x\n\ngoal (1 subgoal):\n 1. (x \\<cdot> 1') ; q \\<le> (- 1' \\<cdot> 1') ; q", "by (metis abel_semigroup.commute inf.abel_semigroup_axioms\n          meet_isor mult_isor)"], ["proof (state)\nthis:\n  (x \\<cdot> 1') ; q \\<le> (- 1' \\<cdot> 1') ; q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (x \\<cdot> 1') ; q \\<le> (- 1' \\<cdot> 1') ; q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1' \\<cdot> 1') ; q = 0", "by simp"], ["proof (state)\nthis:\n  (- 1' \\<cdot> 1') ; q = 0\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  p \\<le> 0", "have \"p \\<le> 0\""], ["proof (prove)\nusing this:\n  p \\<le> 0\n\ngoal (1 subgoal):\n 1. p \\<le> 0", "."], ["proof (state)\nthis:\n  p \\<le> 0\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  p \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "using assms(1) bot_unique is_point_def"], ["proof (prove)\nusing this:\n  p \\<le> 0\n  is_point p\n  (?a \\<le> 0) = (?a = 0)\n  is_point ?x \\<equiv> is_vector ?x \\<and> is_inj ?x \\<and> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_trans:\n assumes \"is_acyclic x\"\n   shows \"x \\<le> -(x\\<^sup>T\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - x\\<^sup>T\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> - x\\<^sup>T\\<^sup>+", "have \"\\<exists>c\\<ge>x. c \\<le> - (x\\<^sup>+)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<ge>x. c \\<le> - (x\\<^sup>+)\\<^sup>T", "by (metis assms compl_mono conv_galois_2 conv_iso double_compl mult_onel star_1l)"], ["proof (state)\nthis:\n  \\<exists>c\\<ge>x. c \\<le> - (x\\<^sup>+)\\<^sup>T\n\ngoal (1 subgoal):\n 1. x \\<le> - x\\<^sup>T\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>c\\<ge>x. c \\<le> - (x\\<^sup>+)\\<^sup>T\n\ngoal (1 subgoal):\n 1. x \\<le> - x\\<^sup>T\\<^sup>+", "by (metis dual_order.trans plus_conv)"], ["proof (state)\nthis:\n  x \\<le> - x\\<^sup>T\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_trans':\n assumes \"is_acyclic x\"\n   shows \"x\\<^sup>\\<star> \\<le> -(x\\<^sup>T\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> - x\\<^sup>T\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> - x\\<^sup>T\\<^sup>+", "have \"x\\<^sup>\\<star> \\<le> - (- (- (x\\<^sup>T ; - (- 1'))) ; (x\\<^sup>\\<star>)\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star>\n    \\<le> - (- (- (x\\<^sup>T ; - (- 1'))) ; (x\\<^sup>\\<star>)\\<^sup>T)", "by (metis assms conv_galois_1 conv_galois_2 order_trans star_trans)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star>\n  \\<le> - (- (- (x\\<^sup>T ; - (- 1'))) ; (x\\<^sup>\\<star>)\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> - x\\<^sup>T\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  x\\<^sup>\\<star>\n  \\<le> - (- (- (x\\<^sup>T ; - (- 1'))) ; (x\\<^sup>\\<star>)\\<^sup>T)", "show ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<star>\n  \\<le> - (- (- (x\\<^sup>T ; - (- 1'))) ; (x\\<^sup>\\<star>)\\<^sup>T)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> - x\\<^sup>T\\<^sup>+", "by (simp add: star_conv)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> \\<le> - x\\<^sup>T\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Regressively finite\\<close>"], ["", "lemma regressively_finite_acyclic:\n  assumes \"regressively_finite x\"\n    shows \"is_acyclic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acyclic x", "have 1: \"is_vector ((x\\<^sup>+ \\<cdot> 1');1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector ((x\\<^sup>+ \\<cdot> 1') ; 1)", "by (simp add: is_vector_def mult_assoc)"], ["proof (state)\nthis:\n  is_vector ((x\\<^sup>+ \\<cdot> 1') ; 1)\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"(x\\<^sup>+ \\<cdot> 1');1 = (x\\<^sup>T\\<^sup>+ \\<cdot> 1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> 1') ; 1 = (x\\<^sup>T\\<^sup>+ \\<cdot> 1') ; 1", "by (metis plus_conv test_converse)"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 = (x\\<^sup>T\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 = (x\\<^sup>T\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... \\<le> x\\<^sup>T;(1';x\\<^sup>T\\<^sup>\\<star> \\<cdot> x);1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T\\<^sup>+ \\<cdot> 1') ; 1\n    \\<le> x\\<^sup>T ; (1' ; x\\<^sup>T\\<^sup>\\<star> \\<cdot> x) ; 1", "by (metis conv_invol modular_1_var mult_isor mult_oner mult_onel)"], ["proof (state)\nthis:\n  (x\\<^sup>T\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> x\\<^sup>T ; (1' ; x\\<^sup>T\\<^sup>\\<star> \\<cdot> x) ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  (x\\<^sup>T\\<^sup>+ \\<cdot> 1') ; 1\n  \\<le> x\\<^sup>T ; (1' ; x\\<^sup>T\\<^sup>\\<star> \\<cdot> x) ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... \\<le> x\\<^sup>T;(1' \\<cdot> x\\<^sup>+);x\\<^sup>T\\<^sup>\\<star>;1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; (1' ; x\\<^sup>T\\<^sup>\\<star> \\<cdot> x) ; 1\n    \\<le> x\\<^sup>T ; (1' \\<cdot> x\\<^sup>+) ; x\\<^sup>T\\<^sup>\\<star> ; 1", "by (metis comp_assoc conv_invol modular_2_var mult_isol mult_isor star_conv)"], ["proof (state)\nthis:\n  x\\<^sup>T ; (1' ; x\\<^sup>T\\<^sup>\\<star> \\<cdot> x) ; 1\n  \\<le> x\\<^sup>T ; (1' \\<cdot> x\\<^sup>+) ; x\\<^sup>T\\<^sup>\\<star> ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "also"], ["proof (state)\nthis:\n  x\\<^sup>T ; (1' ; x\\<^sup>T\\<^sup>\\<star> \\<cdot> x) ; 1\n  \\<le> x\\<^sup>T ; (1' \\<cdot> x\\<^sup>+) ; x\\<^sup>T\\<^sup>\\<star> ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "have \"... = x\\<^sup>T;(x\\<^sup>+ \\<cdot> 1');1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T ; (1' \\<cdot> x\\<^sup>+) ; x\\<^sup>T\\<^sup>\\<star> ; 1 =\n    x\\<^sup>T ; (x\\<^sup>+ \\<cdot> 1') ; 1", "by (metis comp_assoc conway.dagger_unfoldr_distr inf.commute sup.cobounded1 top_le)"], ["proof (state)\nthis:\n  x\\<^sup>T ; (1' \\<cdot> x\\<^sup>+) ; x\\<^sup>T\\<^sup>\\<star> ; 1 =\n  x\\<^sup>T ; (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. is_acyclic x", "finally"], ["proof (chain)\npicking this:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; (x\\<^sup>+ \\<cdot> 1') ; 1", "have \"(x\\<^sup>+ \\<cdot> 1');1 = 0\""], ["proof (prove)\nusing this:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; (x\\<^sup>+ \\<cdot> 1') ; 1\n\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> 1') ; 1 = 0", "using 1 assms"], ["proof (prove)\nusing this:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 \\<le> x\\<^sup>T ; (x\\<^sup>+ \\<cdot> 1') ; 1\n  is_vector ((x\\<^sup>+ \\<cdot> 1') ; 1)\n  regressively_finite x\n\ngoal (1 subgoal):\n 1. (x\\<^sup>+ \\<cdot> 1') ; 1 = 0", "by (simp add: comp_assoc)"], ["proof (state)\nthis:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 = 0\n\ngoal (1 subgoal):\n 1. is_acyclic x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x\\<^sup>+ \\<cdot> 1') ; 1 = 0\n\ngoal (1 subgoal):\n 1. is_acyclic x", "by (simp add: galois_aux ss_p18)"], ["proof (state)\nthis:\n  is_acyclic x\n\ngoal:\nNo subgoals!", "qed"], ["", "notation power (infixr \"\\<up>\" 80)"], ["", "lemma power_suc_below_plus:\n  \"x \\<up> Suc n \\<le> x\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power.power 1' (;) x (Suc n) \\<le> x\\<^sup>+", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. power.power 1' (;) x (Suc zero_class.zero) \\<le> x\\<^sup>+\n 2. \\<And>n.\n       power.power 1' (;) x (Suc n) \\<le> x\\<^sup>+ \\<Longrightarrow>\n       power.power 1' (;) x (Suc (Suc n)) \\<le> x\\<^sup>+", "using mult_isol star_ref"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n  reflexive (?x\\<^sup>\\<star>)\n\ngoal (2 subgoals):\n 1. power.power 1' (;) x (Suc zero_class.zero) \\<le> x\\<^sup>+\n 2. \\<And>n.\n       power.power 1' (;) x (Suc n) \\<le> x\\<^sup>+ \\<Longrightarrow>\n       power.power 1' (;) x (Suc (Suc n)) \\<le> x\\<^sup>+", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       power.power 1' (;) x (Suc n) \\<le> x\\<^sup>+ \\<Longrightarrow>\n       power.power 1' (;) x (Suc (Suc n)) \\<le> x\\<^sup>+", "by (simp add: mult_isol_var order_trans)"], ["", "end"], ["", "(* relation_algebra_rtc *)"], ["", "class relation_algebra_rtc_tarski = relation_algebra_rtc + relation_algebra_tarski\nbegin"], ["", "lemma point_loop_not_acyclic:\n  assumes \"is_point p\"\n      and \"p \\<le> x \\<up> Suc n ; p\"\n    shows \"\\<not> is_acyclic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_acyclic x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_acyclic x", "have \"p \\<le> x\\<^sup>+ ; p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> x\\<^sup>+ ; p", "by (meson assms dual_order.trans point_def point_is_point ss423bij power_suc_below_plus)"], ["proof (state)\nthis:\n  p \\<le> x\\<^sup>+ ; p\n\ngoal (1 subgoal):\n 1. \\<not> is_acyclic x", "hence \"p ; p\\<^sup>T \\<le> x\\<^sup>+\""], ["proof (prove)\nusing this:\n  p \\<le> x\\<^sup>+ ; p\n\ngoal (1 subgoal):\n 1. p ; p\\<^sup>T \\<le> x\\<^sup>+", "using assms(1) point_def point_is_point ss423bij"], ["proof (prove)\nusing this:\n  p \\<le> x\\<^sup>+ ; p\n  is_point p\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  point ?x = is_point ?x\n  bijective ?x \\<Longrightarrow>\n  (?y ; ?x\\<^sup>T \\<le> ?z) = (?y \\<le> ?z ; ?x)\n\ngoal (1 subgoal):\n 1. p ; p\\<^sup>T \\<le> x\\<^sup>+", "by blast"], ["proof (state)\nthis:\n  p ; p\\<^sup>T \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> is_acyclic x", "thus ?thesis"], ["proof (prove)\nusing this:\n  p ; p\\<^sup>T \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> is_acyclic x", "using assms(1) order.trans point_not_equal(1) point_not_equal(2)"], ["proof (prove)\nusing this:\n  p ; p\\<^sup>T \\<le> x\\<^sup>+\n  is_point p\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n  \\<lbrakk>is_point ?p; is_point ?q\\<rbrakk>\n  \\<Longrightarrow> (?p \\<noteq> ?q) = (?p \\<le> - ?q)\n  \\<lbrakk>is_point ?p; is_point ?q\\<rbrakk>\n  \\<Longrightarrow> (?p \\<le> - ?q) = (?p ; ?q\\<^sup>T \\<le> - 1')\n\ngoal (1 subgoal):\n 1. \\<not> is_acyclic x", "by blast"], ["proof (state)\nthis:\n  \\<not> is_acyclic x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class relation_algebra_rtc_point = relation_algebra_rtc + relation_algebra_point"], ["", "class relation_algebra_rtc_tarski_point = relation_algebra_rtc_tarski + relation_algebra_rtc_point +\n                                          relation_algebra_tarski_point"], ["", "text \\<open>\nFinite graphs: the axiom says the algebra has finitely many elements.\nThis means the relations have a finite base set.\n\\<close>"], ["", "class relation_algebra_rtc_tarski_point_finite = relation_algebra_rtc_tarski_point + finite\nbegin"], ["", "text \\<open>For a finite acyclic relation, the powers eventually vanish.\\<close>"], ["", "lemma acyclic_power_vanishes:\n  assumes \"is_acyclic x\"\n    shows \"\\<exists>n . x \\<up> Suc n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. power.power 1' (;) x (Suc n) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. power.power 1' (;) x (Suc n) = 0", "let ?n = \"card { p . is_point p }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. power.power 1' (;) x (Suc n) = 0", "let ?p = \"x \\<up> ?n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. power.power 1' (;) x (Suc n) = 0", "have \"?p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "assume \"?p \\<noteq> 0\""], ["proof (state)\nthis:\n  power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0", "obtain p q where 1: \"point p \\<and> point q \\<and> p;q\\<^sup>T \\<le> ?p\""], ["proof (prove)\nusing this:\n  power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        point p \\<and>\n        point q \\<and>\n        p ; q\\<^sup>T\n        \\<le> power.power 1' (;) x (card {p. is_point p}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using point_axiom"], ["proof (prove)\nusing this:\n  power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0\n  ?x \\<noteq> 0 \\<longrightarrow>\n  (\\<exists>y z. point y \\<and> point z \\<and> y ; z\\<^sup>T \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        point p \\<and>\n        point q \\<and>\n        p ; q\\<^sup>T\n        \\<le> power.power 1' (;) x (card {p. is_point p}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  point p \\<and>\n  point q \\<and>\n  p ; q\\<^sup>T \\<le> power.power 1' (;) x (card {p. is_point p})\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "hence 2: \"p \\<le> ?p;q\""], ["proof (prove)\nusing this:\n  point p \\<and>\n  point q \\<and>\n  p ; q\\<^sup>T \\<le> power.power 1' (;) x (card {p. is_point p})\n\ngoal (1 subgoal):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p}) ; q", "using point_def ss423bij"], ["proof (prove)\nusing this:\n  point p \\<and>\n  point q \\<and>\n  p ; q\\<^sup>T \\<le> power.power 1' (;) x (card {p. is_point p})\n  point ?x \\<equiv> is_vector ?x \\<and> bijective ?x\n  bijective ?x \\<Longrightarrow>\n  (?y ; ?x\\<^sup>T \\<le> ?z) = (?y \\<le> ?z ; ?x)\n\ngoal (1 subgoal):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p}) ; q", "by blast"], ["proof (state)\nthis:\n  p \\<le> power.power 1' (;) x (card {p. is_point p}) ; q\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "have \"\\<forall>n\\<le>?n . (\\<exists>f. \\<forall>i\\<le>n . is_point (f i) \\<and> (\\<forall>j\\<le>i . p \\<le> x\\<up>(?n-i) ; f i \\<and> f i \\<le> x\\<up>(i-j) ; f j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<le>card {p. is_point p}.\n       \\<exists>f.\n          \\<forall>i\\<le>n.\n             is_point (f i) \\<and>\n             (\\<forall>j\\<le>i.\n                 p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                         f i \\<and>\n                 f i \\<le> power.power 1' (;) x (i - j) ; f j)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "show \"n\\<le>?n \\<longrightarrow> (\\<exists>f. \\<forall>i\\<le>n . is_point (f i) \\<and> (\\<forall>j\\<le>i . p \\<le> x\\<up>(?n-i) ; f i \\<and> f i \\<le> x\\<up>(i-j) ; f j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> card {p. is_point p} \\<longrightarrow>\n    (\\<exists>f.\n        \\<forall>i\\<le>n.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j))", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. zero_class.zero \\<le> card {p. is_point p} \\<longrightarrow>\n    (\\<exists>f.\n        \\<forall>i\\<le>zero_class.zero.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j))\n 2. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i\n                  \\<le> power.power 1' (;) x (i - j) ;\n                        f j)) \\<Longrightarrow>\n       Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>Suc n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. zero_class.zero \\<le> card {p. is_point p} \\<longrightarrow>\n    (\\<exists>f.\n        \\<forall>i\\<le>zero_class.zero.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j))\n 2. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i\n                  \\<le> power.power 1' (;) x (i - j) ;\n                        f j)) \\<Longrightarrow>\n       Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>Suc n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_class.zero \\<le> card {p. is_point p} \\<longrightarrow>\n    (\\<exists>f.\n        \\<forall>i\\<le>zero_class.zero.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j))", "using 1 2 point_is_point"], ["proof (prove)\nusing this:\n  point p \\<and>\n  point q \\<and>\n  p ; q\\<^sup>T \\<le> power.power 1' (;) x (card {p. is_point p})\n  p \\<le> power.power 1' (;) x (card {p. is_point p}) ; q\n  point ?x = is_point ?x\n\ngoal (1 subgoal):\n 1. zero_class.zero \\<le> card {p. is_point p} \\<longrightarrow>\n    (\\<exists>f.\n        \\<forall>i\\<le>zero_class.zero.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j))", "by fastforce"], ["proof (state)\nthis:\n  zero_class.zero \\<le> card {p. is_point p} \\<longrightarrow>\n  (\\<exists>f.\n      \\<forall>i\\<le>zero_class.zero.\n         is_point (f i) \\<and>\n         (\\<forall>j\\<le>i.\n             p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                     f i \\<and>\n             f i \\<le> power.power 1' (;) x (i - j) ; f j))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i\n                  \\<le> power.power 1' (;) x (i - j) ;\n                        f j)) \\<Longrightarrow>\n       Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>Suc n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i\n                  \\<le> power.power 1' (;) x (i - j) ;\n                        f j)) \\<Longrightarrow>\n       Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>Suc n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> card {p. is_point p} \\<longrightarrow>\n  (\\<exists>f.\n      \\<forall>i\\<le>n.\n         is_point (f i) \\<and>\n         (\\<forall>j\\<le>i.\n             p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                     f i \\<and>\n             f i \\<le> power.power 1' (;) x (i - j) ; f j))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i\n                  \\<le> power.power 1' (;) x (i - j) ;\n                        f j)) \\<Longrightarrow>\n       Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>Suc n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i\n                  \\<le> power.power 1' (;) x (i - j) ;\n                        f j)) \\<Longrightarrow>\n       Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>Suc n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "assume 3: \"n\\<le>?n \\<longrightarrow> (\\<exists>f . \\<forall>i\\<le>n . is_point (f i) \\<and> (\\<forall>j\\<le>i . p \\<le> x \\<up> (?n-i) ; f i \\<and> f i \\<le> x \\<up> (i-j) ; f j))\""], ["proof (state)\nthis:\n  n \\<le> card {p. is_point p} \\<longrightarrow>\n  (\\<exists>f.\n      \\<forall>i\\<le>n.\n         is_point (f i) \\<and>\n         (\\<forall>j\\<le>i.\n             p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                     f i \\<and>\n             f i \\<le> power.power 1' (;) x (i - j) ; f j))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i\n                  \\<le> power.power 1' (;) x (i - j) ;\n                        f j)) \\<Longrightarrow>\n       Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n       (\\<exists>f.\n           \\<forall>i\\<le>Suc n.\n              is_point (f i) \\<and>\n              (\\<forall>j\\<le>i.\n                  p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                          f i \\<and>\n                  f i \\<le> power.power 1' (;) x (i - j) ; f j))", "show \"Suc n\\<le>?n \\<longrightarrow> (\\<exists>f . \\<forall>i\\<le>Suc n . is_point (f i) \\<and> (\\<forall>j\\<le>i . p \\<le> x \\<up> (?n-i) ; f i \\<and> f i \\<le> x \\<up> (i-j) ; f j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n    (\\<exists>f.\n        \\<forall>i\\<le>Suc n.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "assume 4: \"Suc n\\<le>?n\""], ["proof (state)\nthis:\n  Suc n \\<le> card {p. is_point p}\n\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "from this"], ["proof (chain)\npicking this:\n  Suc n \\<le> card {p. is_point p}", "obtain f where 5: \"\\<forall>i\\<le>n . is_point (f i) \\<and> (\\<forall>j\\<le>i . p \\<le> x \\<up> (?n-i) ; f i \\<and> f i \\<le> x \\<up> (i-j) ; f j)\""], ["proof (prove)\nusing this:\n  Suc n \\<le> card {p. is_point p}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>i\\<le>n.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i\n               \\<le> power.power 1' (;) x (i - j) ; f j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 3"], ["proof (prove)\nusing this:\n  Suc n \\<le> card {p. is_point p}\n  n \\<le> card {p. is_point p} \\<longrightarrow>\n  (\\<exists>f.\n      \\<forall>i\\<le>n.\n         is_point (f i) \\<and>\n         (\\<forall>j\\<le>i.\n             p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                     f i \\<and>\n             f i \\<le> power.power 1' (;) x (i - j) ; f j))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>i\\<le>n.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i\n               \\<le> power.power 1' (;) x (i - j) ; f j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "have \"p \\<le> x \\<up> (?n-n) ; f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p} - n) ; f n", "using 5"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal (1 subgoal):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p} - n) ; f n", "by blast"], ["proof (state)\nthis:\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - n) ; f n\n\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "also"], ["proof (state)\nthis:\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - n) ; f n\n\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "have \"... = x \\<up> (?n-n-one_class.one) ; x ; f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p} - n) ; f n =\n    power.power 1' (;) x (card {p. is_point p} - n - one_class.one) ; x ;\n    f n", "using 4"], ["proof (prove)\nusing this:\n  Suc n \\<le> card {p. is_point p}\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p} - n) ; f n =\n    power.power 1' (;) x (card {p. is_point p} - n - one_class.one) ; x ;\n    f n", "by (metis (no_types) Suc_diff_le diff_Suc_1 diff_Suc_Suc power_Suc2)"], ["proof (state)\nthis:\n  power.power 1' (;) x (card {p. is_point p} - n) ; f n =\n  power.power 1' (;) x (card {p. is_point p} - n - one_class.one) ; x ; f n\n\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "finally"], ["proof (chain)\npicking this:\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - n - one_class.one) ;\n          x ;\n          f n", "obtain r where 6: \"point r \\<and> p \\<le> x \\<up> (?n-Suc n) ; r \\<and> r \\<le> x ; f n\""], ["proof (prove)\nusing this:\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - n - one_class.one) ;\n          x ;\n          f n\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        point r \\<and>\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n                r \\<and>\n        r \\<le> x ; f n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 1 5 intermediate_point_theorem point_is_point"], ["proof (prove)\nusing this:\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - n - one_class.one) ;\n          x ;\n          f n\n  point p \\<and>\n  point q \\<and>\n  p ; q\\<^sup>T \\<le> power.power 1' (;) x (card {p. is_point p})\n  \\<forall>i\\<le>n.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n  \\<lbrakk>point ?p; point ?r\\<rbrakk>\n  \\<Longrightarrow> (?p \\<le> ?x ; ?y ; ?r) =\n                    (\\<exists>q.\n                        point q \\<and>\n                        ?p \\<le> ?x ; q \\<and> q \\<le> ?y ; ?r)\n  point ?x = is_point ?x\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        point r \\<and>\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n                r \\<and>\n        r \\<le> x ; f n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  point r \\<and>\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ; r \\<and>\n  r \\<le> x ; f n\n\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "let ?g = \"\\<lambda>m . if m = Suc n then r else f m\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "have \"\\<forall>i\\<le>Suc n . is_point (?g i) \\<and> (\\<forall>j\\<le>i . p \\<le> x \\<up> (?n-i) ; ?g i \\<and> ?g i \\<le> x \\<up> (i-j) ; ?g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>Suc n.\n       is_point (if i = Suc n then r else f i) \\<and>\n       (\\<forall>j\\<le>i.\n           p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                   (if i = Suc n then r else f i) \\<and>\n           (if i = Suc n then r else f i)\n           \\<le> power.power 1' (;) x (i - j) ;\n                 (if j = Suc n then r else f j))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> Suc n \\<longrightarrow>\n       is_point (if i = Suc n then r else f i) \\<and>\n       (\\<forall>j\\<le>i.\n           p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                   (if i = Suc n then r else f i) \\<and>\n           (if i = Suc n then r else f i)\n           \\<le> power.power 1' (;) x (i - j) ;\n                 (if j = Suc n then r else f j))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> Suc n \\<longrightarrow>\n       is_point (if i = Suc n then r else f i) \\<and>\n       (\\<forall>j\\<le>i.\n           p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                   (if i = Suc n then r else f i) \\<and>\n           (if i = Suc n then r else f i)\n           \\<le> power.power 1' (;) x (i - j) ;\n                 (if j = Suc n then r else f j))", "show \"i\\<le>Suc n \\<longrightarrow> is_point (?g i) \\<and> (\\<forall>j\\<le>i . p \\<le> x \\<up> (?n-i) ; ?g i \\<and> ?g i \\<le> x \\<up> (i-j) ; ?g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "proof (cases \"i\\<le>n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))\n 2. \\<not> i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "case True"], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal (2 subgoals):\n 1. i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))\n 2. \\<not> i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "using 5"], ["proof (prove)\nusing this:\n  i \\<le> n\n  \\<forall>i\\<le>n.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal (1 subgoal):\n 1. i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "by simp"], ["proof (state)\nthis:\n  i \\<le> Suc n \\<longrightarrow>\n  is_point (if i = Suc n then r else f i) \\<and>\n  (\\<forall>j\\<le>i.\n      p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n              (if i = Suc n then r else f i) \\<and>\n      (if i = Suc n then r else f i)\n      \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "have \"is_point (?g (Suc n)) \\<and> (\\<forall>j\\<le>Suc n . p \\<le> x \\<up> (?n-Suc n) ; ?g (Suc n) \\<and> ?g (Suc n) \\<le> x \\<up> (Suc n-j) ; ?g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_point (if Suc n = Suc n then r else f (Suc n)) \\<and>\n    (\\<forall>j\\<le>Suc n.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n                (if Suc n = Suc n then r else f (Suc n)) \\<and>\n        (if Suc n = Suc n then r else f (Suc n))\n        \\<le> power.power 1' (;) x (Suc n - j) ;\n              (if j = Suc n then r else f j))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_point (if Suc n = Suc n then r else f (Suc n))\n 2. \\<forall>j\\<le>Suc n.\n       p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n               (if Suc n = Suc n then r else f (Suc n)) \\<and>\n       (if Suc n = Suc n then r else f (Suc n))\n       \\<le> power.power 1' (;) x (Suc n - j) ;\n             (if j = Suc n then r else f j)", "show \"is_point (?g (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_point (if Suc n = Suc n then r else f (Suc n))", "using 6 point_is_point"], ["proof (prove)\nusing this:\n  point r \\<and>\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ; r \\<and>\n  r \\<le> x ; f n\n  point ?x = is_point ?x\n\ngoal (1 subgoal):\n 1. is_point (if Suc n = Suc n then r else f (Suc n))", "by fastforce"], ["proof (state)\nthis:\n  is_point (if Suc n = Suc n then r else f (Suc n))\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>Suc n.\n       p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n               (if Suc n = Suc n then r else f (Suc n)) \\<and>\n       (if Suc n = Suc n then r else f (Suc n))\n       \\<le> power.power 1' (;) x (Suc n - j) ;\n             (if j = Suc n then r else f j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>Suc n.\n       p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n               (if Suc n = Suc n then r else f (Suc n)) \\<and>\n       (if Suc n = Suc n then r else f (Suc n))\n       \\<le> power.power 1' (;) x (Suc n - j) ;\n             (if j = Suc n then r else f j)", "show \"\\<forall>j\\<le>Suc n . p \\<le> x \\<up> (?n-Suc n) ; ?g (Suc n) \\<and> ?g (Suc n) \\<le> x \\<up> (Suc n-j) ; ?g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>Suc n.\n       p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n               (if Suc n = Suc n then r else f (Suc n)) \\<and>\n       (if Suc n = Suc n then r else f (Suc n))\n       \\<le> power.power 1' (;) x (Suc n - j) ;\n             (if j = Suc n then r else f j)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> Suc n \\<longrightarrow>\n       p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n               (if Suc n = Suc n then r else f (Suc n)) \\<and>\n       (if Suc n = Suc n then r else f (Suc n))\n       \\<le> power.power 1' (;) x (Suc n - j) ;\n             (if j = Suc n then r else f j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> Suc n \\<longrightarrow>\n       p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n               (if Suc n = Suc n then r else f (Suc n)) \\<and>\n       (if Suc n = Suc n then r else f (Suc n))\n       \\<le> power.power 1' (;) x (Suc n - j) ;\n             (if j = Suc n then r else f j)", "show \"j\\<le>Suc n \\<longrightarrow> p \\<le> x \\<up> (?n-Suc n) ; ?g (Suc n) \\<and> ?g (Suc n) \\<le> x \\<up> (Suc n-j) ; ?g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> Suc n \\<longrightarrow>\n    p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n            (if Suc n = Suc n then r else f (Suc n)) \\<and>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<le> Suc n \\<Longrightarrow>\n    p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n            (if Suc n = Suc n then r else f (Suc n)) \\<and>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "assume 7: \"j\\<le>Suc n\""], ["proof (state)\nthis:\n  j \\<le> Suc n\n\ngoal (1 subgoal):\n 1. j \\<le> Suc n \\<Longrightarrow>\n    p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n            (if Suc n = Suc n then r else f (Suc n)) \\<and>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "show \"p \\<le> x \\<up> (?n-Suc n) ; ?g (Suc n) \\<and> ?g (Suc n) \\<le> x \\<up> (Suc n-j) ; ?g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n            (if Suc n = Suc n then r else f (Suc n)) \\<and>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n            (if Suc n = Suc n then r else f (Suc n))\n 2. (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "show \"p \\<le> x \\<up> (?n-Suc n) ; ?g (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n            (if Suc n = Suc n then r else f (Suc n))", "using 6"], ["proof (prove)\nusing this:\n  point r \\<and>\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ; r \\<and>\n  r \\<le> x ; f n\n\ngoal (1 subgoal):\n 1. p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n            (if Suc n = Suc n then r else f (Suc n))", "by simp"], ["proof (state)\nthis:\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n          (if Suc n = Suc n then r else f (Suc n))\n\ngoal (1 subgoal):\n 1. (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "show \"?g (Suc n) \\<le> x \\<up> (Suc n-j) ; ?g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "proof (cases \"j = Suc n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n 2. j \\<noteq> Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "case True"], ["proof (state)\nthis:\n  j = Suc n\n\ngoal (2 subgoals):\n 1. j = Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n 2. j \\<noteq> Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = Suc n\n\ngoal (1 subgoal):\n 1. (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "by simp"], ["proof (state)\nthis:\n  (if Suc n = Suc n then r else f (Suc n))\n  \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "case False"], ["proof (state)\nthis:\n  j \\<noteq> Suc n\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "hence \"f n \\<le> x \\<up> (n-j) ; f j\""], ["proof (prove)\nusing this:\n  j \\<noteq> Suc n\n\ngoal (1 subgoal):\n 1. f n \\<le> power.power 1' (;) x (n - j) ; f j", "using 5 7"], ["proof (prove)\nusing this:\n  j \\<noteq> Suc n\n  \\<forall>i\\<le>n.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n  j \\<le> Suc n\n\ngoal (1 subgoal):\n 1. f n \\<le> power.power 1' (;) x (n - j) ; f j", "by fastforce"], ["proof (state)\nthis:\n  f n \\<le> power.power 1' (;) x (n - j) ; f j\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "hence \"x ; f n \\<le> x \\<up> (Suc n-j) ; f j\""], ["proof (prove)\nusing this:\n  f n \\<le> power.power 1' (;) x (n - j) ; f j\n\ngoal (1 subgoal):\n 1. x ; f n \\<le> power.power 1' (;) x (Suc n - j) ; f j", "using 7 False Suc_diff_le comp_assoc mult_isol"], ["proof (prove)\nusing this:\n  f n \\<le> power.power 1' (;) x (n - j) ; f j\n  j \\<le> Suc n\n  j \\<noteq> Suc n\n  ?n \\<le> ?m \\<Longrightarrow> Suc ?m - ?n = Suc (?m - ?n)\n  ?x ; ?y ; ?z = ?x ; (?y ; ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?z ; ?x \\<le> ?z ; ?y\n\ngoal (1 subgoal):\n 1. x ; f n \\<le> power.power 1' (;) x (Suc n - j) ; f j", "by fastforce"], ["proof (state)\nthis:\n  x ; f n \\<le> power.power 1' (;) x (Suc n - j) ; f j\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc n \\<Longrightarrow>\n    (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x ; f n \\<le> power.power 1' (;) x (Suc n - j) ; f j\n\ngoal (1 subgoal):\n 1. (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "using 6 False"], ["proof (prove)\nusing this:\n  x ; f n \\<le> power.power 1' (;) x (Suc n - j) ; f j\n  point r \\<and>\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ; r \\<and>\n  r \\<le> x ; f n\n  j \\<noteq> Suc n\n\ngoal (1 subgoal):\n 1. (if Suc n = Suc n then r else f (Suc n))\n    \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)", "by fastforce"], ["proof (state)\nthis:\n  (if Suc n = Suc n then r else f (Suc n))\n  \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if Suc n = Suc n then r else f (Suc n))\n  \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n          (if Suc n = Suc n then r else f (Suc n)) \\<and>\n  (if Suc n = Suc n then r else f (Suc n))\n  \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j \\<le> Suc n \\<longrightarrow>\n  p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n          (if Suc n = Suc n then r else f (Suc n)) \\<and>\n  (if Suc n = Suc n then r else f (Suc n))\n  \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j\\<le>Suc n.\n     p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n             (if Suc n = Suc n then r else f (Suc n)) \\<and>\n     (if Suc n = Suc n then r else f (Suc n))\n     \\<le> power.power 1' (;) x (Suc n - j) ; (if j = Suc n then r else f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_point (if Suc n = Suc n then r else f (Suc n)) \\<and>\n  (\\<forall>j\\<le>Suc n.\n      p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n              (if Suc n = Suc n then r else f (Suc n)) \\<and>\n      (if Suc n = Suc n then r else f (Suc n))\n      \\<le> power.power 1' (;) x (Suc n - j) ;\n            (if j = Suc n then r else f j))\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> n \\<Longrightarrow>\n    i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_point (if Suc n = Suc n then r else f (Suc n)) \\<and>\n  (\\<forall>j\\<le>Suc n.\n      p \\<le> power.power 1' (;) x (card {p. is_point p} - Suc n) ;\n              (if Suc n = Suc n then r else f (Suc n)) \\<and>\n      (if Suc n = Suc n then r else f (Suc n))\n      \\<le> power.power 1' (;) x (Suc n - j) ;\n            (if j = Suc n then r else f j))\n\ngoal (1 subgoal):\n 1. i \\<le> Suc n \\<longrightarrow>\n    is_point (if i = Suc n then r else f i) \\<and>\n    (\\<forall>j\\<le>i.\n        p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                (if i = Suc n then r else f i) \\<and>\n        (if i = Suc n then r else f i)\n        \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))", "by (simp add: False le_Suc_eq)"], ["proof (state)\nthis:\n  i \\<le> Suc n \\<longrightarrow>\n  is_point (if i = Suc n then r else f i) \\<and>\n  (\\<forall>j\\<le>i.\n      p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n              (if i = Suc n then r else f i) \\<and>\n      (if i = Suc n then r else f i)\n      \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<le> Suc n \\<longrightarrow>\n  is_point (if i = Suc n then r else f i) \\<and>\n  (\\<forall>j\\<le>i.\n      p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n              (if i = Suc n then r else f i) \\<and>\n      (if i = Suc n then r else f i)\n      \\<le> power.power 1' (;) x (i - j) ; (if j = Suc n then r else f j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<le>Suc n.\n     is_point (if i = Suc n then r else f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 (if i = Suc n then r else f i) \\<and>\n         (if i = Suc n then r else f i)\n         \\<le> power.power 1' (;) x (i - j) ;\n               (if j = Suc n then r else f j))\n\ngoal (1 subgoal):\n 1. Suc n \\<le> card {p. is_point p} \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "thus \"\\<exists>f . \\<forall>i\\<le>Suc n . is_point (f i) \\<and> (\\<forall>j\\<le>i . p \\<le> x \\<up> (?n-i) ; f i \\<and> f i \\<le> x \\<up> (i-j) ; f j)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>Suc n.\n     is_point (if i = Suc n then r else f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 (if i = Suc n then r else f i) \\<and>\n         (if i = Suc n then r else f i)\n         \\<le> power.power 1' (;) x (i - j) ;\n               (if j = Suc n then r else f j))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>i\\<le>Suc n.\n          is_point (f i) \\<and>\n          (\\<forall>j\\<le>i.\n              p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                      f i \\<and>\n              f i \\<le> power.power 1' (;) x (i - j) ; f j)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<forall>i\\<le>Suc n.\n        is_point (f i) \\<and>\n        (\\<forall>j\\<le>i.\n            p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                    f i \\<and>\n            f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc n \\<le> card {p. is_point p} \\<longrightarrow>\n  (\\<exists>f.\n      \\<forall>i\\<le>Suc n.\n         is_point (f i) \\<and>\n         (\\<forall>j\\<le>i.\n             p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                     f i \\<and>\n             f i \\<le> power.power 1' (;) x (i - j) ; f j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<le> card {p. is_point p} \\<longrightarrow>\n  (\\<exists>f.\n      \\<forall>i\\<le>n.\n         is_point (f i) \\<and>\n         (\\<forall>j\\<le>i.\n             p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                     f i \\<and>\n             f i \\<le> power.power 1' (;) x (i - j) ; f j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<le>card {p. is_point p}.\n     \\<exists>f.\n        \\<forall>i\\<le>n.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<forall>n\\<le>card {p. is_point p}.\n     \\<exists>f.\n        \\<forall>i\\<le>n.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j)", "obtain f where 8: \"\\<forall>i\\<le>?n . is_point (f i) \\<and> (\\<forall>j\\<le>i . p \\<le> x \\<up> (?n-i) ; f i \\<and> f i \\<le> x \\<up> (i-j) ; f j)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<le>card {p. is_point p}.\n     \\<exists>f.\n        \\<forall>i\\<le>n.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>i\\<le>card {p. is_point p}.\n           is_point (f i) \\<and>\n           (\\<forall>j\\<le>i.\n               p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                       f i \\<and>\n               f i\n               \\<le> power.power 1' (;) x (i - j) ; f j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i\\<le>card {p. is_point p}.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "let ?A = \"{ k . k\\<le>?n }\""], ["proof (state)\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "have \"f ` ?A \\<subseteq> { p . is_point p }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {k. k \\<le> card {p. is_point p}} \\<subseteq> {p. is_point p}", "using 8"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>card {p. is_point p}.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n\ngoal (1 subgoal):\n 1. f ` {k. k \\<le> card {p. is_point p}} \\<subseteq> {p. is_point p}", "by blast"], ["proof (state)\nthis:\n  f ` {k. k \\<le> card {p. is_point p}} \\<subseteq> {p. is_point p}\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "hence \"card (f ` ?A) \\<le> ?n\""], ["proof (prove)\nusing this:\n  f ` {k. k \\<le> card {p. is_point p}} \\<subseteq> {p. is_point p}\n\ngoal (1 subgoal):\n 1. card (f ` {k. k \\<le> card {p. is_point p}}) \\<le> card {p. is_point p}", "by (simp add: card_mono)"], ["proof (state)\nthis:\n  card (f ` {k. k \\<le> card {p. is_point p}}) \\<le> card {p. is_point p}\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "hence \"\\<not> inj_on f ?A\""], ["proof (prove)\nusing this:\n  card (f ` {k. k \\<le> card {p. is_point p}}) \\<le> card {p. is_point p}\n\ngoal (1 subgoal):\n 1. \\<not> inj_on f {k. k \\<le> card {p. is_point p}}", "by (simp add: pigeonhole)"], ["proof (state)\nthis:\n  \\<not> inj_on f {k. k \\<le> card {p. is_point p}}\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> inj_on f {k. k \\<le> card {p. is_point p}}", "obtain i j where 9: \"i \\<le> ?n \\<and> j \\<le> ?n \\<and> i \\<noteq> j \\<and> f i = f j\""], ["proof (prove)\nusing this:\n  \\<not> inj_on f {k. k \\<le> card {p. is_point p}}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        i \\<le> card {p. is_point p} \\<and>\n        j \\<le> card {p. is_point p} \\<and>\n        i \\<noteq> j \\<and> f i = f j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) inj_on_def mem_Collect_eq)"], ["proof (state)\nthis:\n  i \\<le> card {p. is_point p} \\<and>\n  j \\<le> card {p. is_point p} \\<and> i \\<noteq> j \\<and> f i = f j\n\ngoal (1 subgoal):\n 1. power.power 1' (;) x (card {p. is_point p}) \\<noteq> 0 \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (cases \"i < j\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> False\n 2. \\<not> i < j \\<Longrightarrow> False", "using 8 9"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>card {p. is_point p}.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n  i \\<le> card {p. is_point p} \\<and>\n  j \\<le> card {p. is_point p} \\<and> i \\<noteq> j \\<and> f i = f j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> False\n 2. \\<not> i < j \\<Longrightarrow> False", "apply (metis Suc_diff_le Suc_leI assms diff_Suc_Suc order_less_imp_le\n                            point_loop_not_acyclic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> False", "using 8 9"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>card {p. is_point p}.\n     is_point (f i) \\<and>\n     (\\<forall>j\\<le>i.\n         p \\<le> power.power 1' (;) x (card {p. is_point p} - i) ;\n                 f i \\<and>\n         f i \\<le> power.power 1' (;) x (i - j) ; f j)\n  i \\<le> card {p. is_point p} \\<and>\n  j \\<le> card {p. is_point p} \\<and> i \\<noteq> j \\<and> f i = f j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> False", "by (metis assms neqE point_loop_not_acyclic Suc_diff_le Suc_leI assms diff_Suc_Suc\n                        order_less_imp_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power.power 1' (;) x (card {p. is_point p}) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. power.power 1' (;) x (Suc n) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  power.power 1' (;) x (card {p. is_point p}) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. power.power 1' (;) x (Suc n) = 0", "by (metis annir power.simps(2))"], ["proof (state)\nthis:\n  \\<exists>n. power.power 1' (;) x (Suc n) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Hence finite acyclic relations are regressively finite.\\<close>"], ["", "lemma acyclic_regressively_finite:\n  assumes \"is_acyclic x\"\n    shows \"regressively_finite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regressively_finite x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<longrightarrow> v = 0", "have \"is_acyclic (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic (x\\<^sup>T)", "using assms acyclic_trans' compl_le_swap1 order_trans star_ref"], ["proof (prove)\nusing this:\n  is_acyclic x\n  is_acyclic ?x \\<Longrightarrow>\n  ?x\\<^sup>\\<star> \\<le> - ?x\\<^sup>T\\<^sup>+\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  reflexive (?x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. is_acyclic (x\\<^sup>T)", "by blast"], ["proof (state)\nthis:\n  is_acyclic (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<longrightarrow> v = 0", "from this"], ["proof (chain)\npicking this:\n  is_acyclic (x\\<^sup>T)", "obtain n where 1: \"x\\<^sup>T \\<up> Suc n = 0\""], ["proof (prove)\nusing this:\n  is_acyclic (x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        power.power 1' (;) (x\\<^sup>T) (Suc n) = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using acyclic_power_vanishes"], ["proof (prove)\nusing this:\n  is_acyclic (x\\<^sup>T)\n  is_acyclic ?x \\<Longrightarrow>\n  \\<exists>n. power.power 1' (;) ?x (Suc n) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        power.power 1' (;) (x\\<^sup>T) (Suc n) = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  power.power 1' (;) (x\\<^sup>T) (Suc n) = 0\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<longrightarrow> v = 0", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<longrightarrow> v = 0", "show \"is_vector v \\<and> v \\<le> x\\<^sup>T;v \\<longrightarrow> v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<longrightarrow> v = 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<Longrightarrow> v = 0", "assume 2: \"is_vector v \\<and> v \\<le> x\\<^sup>T;v\""], ["proof (state)\nthis:\n  is_vector v \\<and> v \\<le> x\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<Longrightarrow> v = 0", "have \"v \\<le> x\\<^sup>T \\<up> Suc n ; v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc zero_class.zero) ; v\n 2. \\<And>n.\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v \\<Longrightarrow>\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc zero_class.zero) ; v\n 2. \\<And>n.\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v \\<Longrightarrow>\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc zero_class.zero) ; v", "using 2"], ["proof (prove)\nusing this:\n  is_vector v \\<and> v \\<le> x\\<^sup>T ; v\n\ngoal (1 subgoal):\n 1. v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc zero_class.zero) ; v", "by simp"], ["proof (state)\nthis:\n  v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc zero_class.zero) ; v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v \\<Longrightarrow>\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v \\<Longrightarrow>\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "case (Suc n)"], ["proof (state)\nthis:\n  v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v \\<Longrightarrow>\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "hence \"x\\<^sup>T ; v \\<le> x\\<^sup>T \\<up> Suc (Suc n) ; v\""], ["proof (prove)\nusing this:\n  v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v\n\ngoal (1 subgoal):\n 1. x\\<^sup>T ; v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "by (simp add: comp_assoc mult_isol)"], ["proof (state)\nthis:\n  x\\<^sup>T ; v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v \\<Longrightarrow>\n       v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "thus ?case"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v\n\ngoal (1 subgoal):\n 1. v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "using 2 dual_order.trans"], ["proof (prove)\nusing this:\n  x\\<^sup>T ; v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v\n  is_vector v \\<and> v \\<le> x\\<^sup>T ; v\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v", "by blast"], ["proof (state)\nthis:\n  v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc (Suc n)) ; v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v\n\ngoal (1 subgoal):\n 1. is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<Longrightarrow> v = 0", "thus \"v = 0\""], ["proof (prove)\nusing this:\n  v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v\n\ngoal (1 subgoal):\n 1. v = 0", "using 1"], ["proof (prove)\nusing this:\n  v \\<le> power.power 1' (;) (x\\<^sup>T) (Suc n) ; v\n  power.power 1' (;) (x\\<^sup>T) (Suc n) = 0\n\ngoal (1 subgoal):\n 1. v = 0", "by (simp add: le_bot)"], ["proof (state)\nthis:\n  v = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_vector v \\<and> v \\<le> x\\<^sup>T ; v \\<longrightarrow> v = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_is_regressively_finite:\n  \"is_acyclic x \\<longleftrightarrow> regressively_finite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acyclic x = regressively_finite x", "using acyclic_regressively_finite regressively_finite_acyclic"], ["proof (prove)\nusing this:\n  is_acyclic ?x \\<Longrightarrow> regressively_finite ?x\n  regressively_finite ?x \\<Longrightarrow> is_acyclic ?x\n\ngoal (1 subgoal):\n 1. is_acyclic x = regressively_finite x", "by blast"], ["", "end"], ["", "(* end relation_algebra_rtc_tarski_point_finite *)"], ["", "end"]]}