{"file_name": "/home/qj213/afp-2021-10-22/thys/AutoFocus-Stream/AF_Stream_Exec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AutoFocus-Stream", "problem_names": ["lemma f_Exec_one: \"f_Exec_Comp trans_fun [m] c = trans_fun m c\"", "lemma f_Exec_Stream_length[rule_format, simp]:\"\n  \\<forall>c. length (f_Exec_Comp_Stream trans_fun xs c) = length xs\"", "lemma f_Exec_Stream_empty_conv:\"\n  (f_Exec_Comp_Stream trans_fun xs c = []) = (xs = [])\"", "lemma f_Exec_Stream_not_empty_conv:\"\n  (f_Exec_Comp_Stream trans_fun xs c \\<noteq> []) = (xs \\<noteq> [])\"", "lemma f_Exec_eq_f_Exec_Stream_last[rule_format]:\"\n  \\<forall>c. f_Exec_Comp trans_fun xs c = last (c # (f_Exec_Comp_Stream trans_fun xs c))\"", "lemma f_Exec_Stream_nth: \"\n  \\<And>n c. n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c ! n = f_Exec_Comp trans_fun (xs \\<down> Suc n) c\"", "lemma f_Exec_Stream_nth2: \"\n  n \\<le> length xs \\<Longrightarrow>\n  (c # f_Exec_Comp_Stream trans_fun xs c) ! n = f_Exec_Comp trans_fun (xs \\<down> n) c\"", "lemma f_Exec_N_all:\"\n  length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_N trans_fun n xs c = f_Exec_Comp trans_fun xs c\"", "lemma f_Exec_Stream_append[rule_format]:\"\\<forall>c.\n  f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream trans_fun xs c) @\n    (f_Exec_Comp_Stream trans_fun ys (f_Exec_Comp trans_fun xs c))\"", "lemma f_Exec_Stream_snoc: \"\n  f_Exec_Comp_Stream trans_fun (xs @ [x]) c =\n    f_Exec_Comp_Stream trans_fun xs c @\n    [trans_fun x (f_Exec_Comp trans_fun xs c)]\"", "lemma f_Exec_snoc: \"\n  f_Exec_Comp trans_fun (xs @ [x]) c =\n  trans_fun x (f_Exec_Comp trans_fun xs c)\"", "lemma f_Exec_N_append[rule_format]:\"\n  f_Exec_Comp_N trans_fun (a + b) xs c =\n  f_Exec_Comp_N trans_fun b (xs \\<up> a) (f_Exec_Comp_N trans_fun a xs c)\"", "theorem f_Exec_Stream_take:\"\n  (f_Exec_Comp_Stream trans_fun xs c) \\<down> n =\n  f_Exec_Comp_Stream trans_fun (xs \\<down> n) c\"", "theorem f_Exec_Stream_drop:\"\n  (f_Exec_Comp_Stream trans_fun xs c) \\<up> n =\n  f_Exec_Comp_Stream trans_fun (xs \\<up> n)\n    (f_Exec_Comp trans_fun (xs \\<down> n) c)\"", "lemma i_Exec_Stream_nth: \"\n  i_Exec_Comp_Stream trans_fun input c n = f_Exec_Comp trans_fun (input \\<Down> Suc n) c\"", "lemma i_Exec_Stream_nth_Suc: \"\n  i_Exec_Comp_Stream trans_fun input c (Suc n) =\n  trans_fun (input (Suc n)) (i_Exec_Comp_Stream trans_fun input c n)\"", "lemma i_Exec_Stream_nth_Suc_first: \"\n  i_Exec_Comp_Stream trans_fun input c (Suc n) =\n  (i_Exec_Comp_Stream trans_fun (input \\<Up> Suc 0) (trans_fun (input 0) c) n)\"", "lemma f_Exec_Stream_nth_eq_i_Exec_Stream_nth: \"\n  n < n' \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun (input \\<Down> n') c ! n =\n  i_Exec_Comp_Stream trans_fun input c n\"", "lemma i_Exec_Stream_append: \"\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (f_Exec_Comp trans_fun xs c)\"", "lemma i_Exec_Stream_append_last_Cons: \"\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (\n    last (c # f_Exec_Comp_Stream trans_fun xs c))\"", "lemma i_Exec_Stream_append_last: \"\n  xs \\<noteq> [] \\<Longrightarrow>\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (\n    last (f_Exec_Comp_Stream trans_fun xs c))\"", "lemma i_Exec_Stream_append_if: \"\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (\n    if xs = [] then c\n    else last (f_Exec_Comp_Stream trans_fun xs c))\"", "theorem i_Exec_Stream_take:\"\n  (i_Exec_Comp_Stream trans_fun input c) \\<Down> n =\n  f_Exec_Comp_Stream trans_fun (input \\<Down> n) c\"", "theorem i_Exec_Stream_drop:\"\n  (i_Exec_Comp_Stream trans_fun input c) \\<Up> n =\n  i_Exec_Comp_Stream trans_fun (input \\<Up> n) (f_Exec_Comp trans_fun (input \\<Down> n) c)\"", "lemma f_Exec_Stream_expand_aggregate_map_take: \"\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag \\<down> n =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs \\<down> n) \\<odot>\\<^sub>f k) c)) k ag\"", "lemma i_Exec_Stream_expand_aggregate_map_take: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag \\<Down> n =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c)) k ag\"", "lemma f_Exec_Stream_expand_aggregate_map_drop: \"\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag \\<up> n =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs \\<up> n) \\<odot>\\<^sub>f k) (\n    f_Exec_Comp trans_fun ((xs \\<down> n) \\<odot>\\<^sub>f k) c))) k ag\"", "lemma i_Exec_Stream_expand_aggregate_map_drop: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag \\<Up> n =\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun ((input \\<Up> n) \\<odot>\\<^sub>i k) (\n    f_Exec_Comp trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c))) k ag\"", "lemma f_Exec_Stream_expand_aggregate_map_nth_eq_i_nth: \"\n  \\<lbrakk> 0 < k; n < n' \\<rbrakk> \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (input \\<Down> n' \\<odot>\\<^sub>f k) c)) k ag ! n =\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag n\"", "lemma f_Exec_Stream_expand_shrink_last_map_nth_eq_f_Exec_Comp: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c) \\<div>\\<^bsub>fl\\<^esub> k ! n =\n  f (f_Exec_Comp trans_fun ((xs \\<down> Suc n) \\<odot>\\<^sub>f k) c)\"", "lemma f_Exec_Stream_expand_aggregate_map_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag ! n =\n  ag (map f (f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)))\"", "lemma i_Exec_Stream_expand_aggregate_map_nth: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag n =\n  ag (map f (f_Exec_Comp_Stream trans_fun (input n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c)))\"", "lemma f_Exec_Stream_expand_snoc: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c \\<up> (n * k) \\<down> k =\n  f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)\"", "lemma f_Exec_Stream_expand_map_aggregate_append: \"\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs @ ys) \\<odot>\\<^sub>f k) c)) k ag =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag @\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (ys \\<odot>\\<^sub>f k) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c))) k ag\"", "lemma i_Exec_Stream_expand_map_aggregate_append: \"\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun ((xs \\<frown> input) \\<odot>\\<^sub>i k) c)) k ag =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag \\<frown>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c))) k ag\"", "lemma f_Exec_Stream_expand_map_aggregate_Cons: \"\n  0 < k \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((x # xs) \\<odot>\\<^sub>f k) c)) k ag =\n  ag (map f (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)) #\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))) k ag\"", "lemma f_Exec_Stream_expand_map_aggregate_snoc: \"\n  0 < k \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs @ [x]) \\<odot>\\<^sub>f k) c)) k ag =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag @\n  [ag (map f (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)))]\"", "lemma i_Exec_Stream_expand_map_aggregate_Cons: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (([x] \\<frown> input) \\<odot>\\<^sub>i k) c)) k ag =\n  [ag (map f (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))] \\<frown>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))) k ag\"", "lemma f_Exec_N_eq_f_Exec_Stream_nth:\"\n  n \\<le> length xs \\<Longrightarrow>\n  f_Exec_Comp_N trans_fun n xs c = (c # f_Exec_Comp_Stream trans_fun xs c) ! n\"", "theorem f_Exec_Stream_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  (f_Exec_Comp_Stream trans_fun xs c) \\<down> n = (f_Exec_Comp_Stream trans_fun ys c) \\<down> n\"", "theorem i_Exec_Stream_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  (i_Exec_Comp_Stream trans_fun input1 c) \\<Down> n = (i_Exec_Comp_Stream trans_fun input2 c) \\<Down> n\"", "lemma f_Exec_Stream_Init_length[rule_format, simp]:\"\n  \\<forall>c. length (f_Exec_Comp_Stream_Init trans_fun xs c) = Suc (length xs)\"", "lemma f_Exec_Stream_Init_not_empty:\"\n  (f_Exec_Comp_Stream_Init trans_fun xs c \\<noteq> [])\"", "lemma f_Exec_eq_f_Exec_Stream_Init_last[rule_format]:\"\n  \\<forall>c. f_Exec_Comp trans_fun xs c = last (f_Exec_Comp_Stream_Init trans_fun xs c)\"", "lemma f_Exec_Stream_Init_eq_f_Exec_Stream_Cons[rule_format]: \"\n  \\<forall>c. f_Exec_Comp_Stream_Init trans_fun xs c = c # f_Exec_Comp_Stream trans_fun xs c\"", "lemma f_Exec_N_eq_last_f_Exec_Stream_Init_take:\"\n  f_Exec_Comp_N trans_fun n xs c =\n  last (f_Exec_Comp_Stream_Init trans_fun (xs \\<down> n) c)\"", "lemma f_Exec_Stream_Init_nth: \"\n  n \\<le> length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! n = f_Exec_Comp trans_fun (xs \\<down> n) c\"", "lemma f_Exec_Stream_Init_nth_0: \"f_Exec_Comp_Stream_Init trans_fun xs c ! 0 = c\"", "lemma f_Exec_Stream_Init_hd: \"hd (f_Exec_Comp_Stream_Init trans_fun xs c) = c\"", "lemma f_Exec_Stream_Init_nth_Suc_eq_f_Exec_Stream_nth: \"\n  f_Exec_Comp_Stream_Init trans_fun xs c ! (Suc n) = f_Exec_Comp_Stream trans_fun xs c ! n\"", "lemma f_Exec_Stream_Init_append:\"\n  f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream_Init trans_fun xs c) @\n    tl (f_Exec_Comp_Stream_Init trans_fun ys (f_Exec_Comp trans_fun xs c))\"", "lemma f_Exec_Stream_Init_f_Exec_Stream_append:\"\n  f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream_Init trans_fun xs c) @\n    (f_Exec_Comp_Stream trans_fun ys (f_Exec_Comp trans_fun xs c))\"", "lemma f_Exec_Stream_Init_take:\"\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<down> Suc n =\n  f_Exec_Comp_Stream_Init trans_fun (xs \\<down> n) c\"", "lemma f_Exec_Stream_Init_drop:\"\n  n \\<le> length xs \\<Longrightarrow>\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<up> n =\n  f_Exec_Comp_Stream_Init trans_fun (xs \\<up> n)\n    (f_Exec_Comp trans_fun (xs \\<down> n) c)\"", "lemma f_Exec_Stream_Init_drop_geq_not_valid:\"\n  length xs \\<le> n \\<Longrightarrow>\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<up> Suc n \\<noteq>\n  f_Exec_Comp_Stream_Init trans_fun arbitrary_input arbitrary_comp\"", "lemma i_Exec_Stream_Init_nth: \"\n  i_Exec_Comp_Stream_Init trans_fun input c n = f_Exec_Comp trans_fun (input \\<Down> n) c\"", "lemma i_Exec_Stream_Init_nth_0: \"\n  i_Exec_Comp_Stream_Init trans_fun input c 0 = c\"", "lemma i_Exec_Stream_Init_nth_Suc_eq_i_Exec_Stream_nth: \"\n  i_Exec_Comp_Stream_Init trans_fun input c (Suc n) = i_Exec_Comp_Stream trans_fun input c n\"", "lemma i_Exec_Stream_Init_eq_i_Exec_Stream_Cons: \"\n  i_Exec_Comp_Stream_Init trans_fun input c = [c] \\<frown> i_Exec_Comp_Stream trans_fun input c\"", "lemma i_Exec_Stream_Init_append:\"\n  i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    (f_Exec_Comp_Stream_Init trans_fun input1 c) \\<frown>\n    ((i_Exec_Comp_Stream_Init trans_fun input2 (f_Exec_Comp trans_fun input1 c)) \\<Up> Suc 0)\"", "lemma i_Exec_Stream_Init_i_Exec_Stream_append:\"\n  i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    (f_Exec_Comp_Stream_Init trans_fun input1 c) \\<frown>\n    (i_Exec_Comp_Stream trans_fun input2 (f_Exec_Comp trans_fun input1 c))\"", "lemma i_Exec_Stream_Init_take:\"\n  (i_Exec_Comp_Stream_Init trans_fun input c) \\<Down> Suc n =\n  f_Exec_Comp_Stream_Init trans_fun (input \\<Down> n) c\"", "lemma i_Exec_Stream_Init_drop:\"\n  (i_Exec_Comp_Stream_Init trans_fun input c) \\<Up> n =\n  i_Exec_Comp_Stream_Init trans_fun (input \\<Up> n)\n    (f_Exec_Comp trans_fun (input \\<Down> n) c)\"", "theorem f_Exec_Stream_Init_strictly_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<down> Suc n = (f_Exec_Comp_Stream_Init trans_fun ys c) \\<down> Suc n\"", "theorem i_Exec_Stream_Init_strictly_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  (i_Exec_Comp_Stream_Init trans_fun input1 c) \\<Down> Suc n = (i_Exec_Comp_Stream_Init trans_fun input2 c) \\<Down> Suc n\"", "theorem f_Exec_N_eq_f_Exec_Stream_Init_nth:\"\n  n \\<le> length xs \\<Longrightarrow>\n  f_Exec_Comp_N trans_fun n xs c = f_Exec_Comp_Stream_Init trans_fun xs c ! n\"", "lemma list_Previous_nth: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = (case n of 0 \\<Rightarrow> init | Suc n' \\<Rightarrow> xs ! n')\"", "lemma ilist_Previous_nth: \"f\\<^bsup>\\<leftarrow> init\\<^esup> n = (case n of 0 \\<Rightarrow> init | Suc n' \\<Rightarrow> f n')\"", "lemma list_Previous_nth_if: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = (if n = 0 then init else xs ! (n - Suc 0))\"", "lemma ilist_Previous_nth_if: \"f\\<^bsup>\\<leftarrow> init\\<^esup> n = (if n = 0 then init else f (n - Suc 0))\"", "lemma list_Previous_Cons: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = (init # xs) ! n\"", "lemma ilist_Previous_Cons: \"f\\<^bsup>\\<leftarrow> init\\<^esup> n = ([init] \\<frown> f) n\"", "lemma list_Previous_0: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> 0 = init\"", "lemma ilist_Previous_0: \"f\\<^bsup>\\<leftarrow> init\\<^esup> 0 = init\"", "lemma list_Previous_gr0: \"0 < n \\<Longrightarrow> xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = xs ! (n - Suc 0)\"", "lemma ilist_Previous_gr0: \"0 < n \\<Longrightarrow> f\\<^bsup>\\<leftarrow> init\\<^esup> n = f (n - Suc 0)\"", "lemma list_Previous_Suc: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> (Suc n) = xs ! n\"", "lemma ilist_Previous_Suc: \"f\\<^bsup>\\<leftarrow> init\\<^esup> (Suc n) = f n\"", "lemma f_Exec_Stream_Previous_f_Exec_Stream_Init: \"\n  f_Exec_Comp_Stream_Init trans_fun xs c ! n =\n  (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n\"", "lemma i_Exec_Stream_Previous_i_Exec_Stream_Init: \"\n  i_Exec_Comp_Stream_Init trans_fun input c n =\n  (i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n\"", "lemma f_Exec_Stream_hd: \"\n  0 < length xs \\<Longrightarrow> hd (f_Exec_Comp_Stream trans_fun xs c) = trans_fun (hd xs) c\"", "lemma f_Exec_Stream_nth_0: \"\n  0 < length xs \\<Longrightarrow> (f_Exec_Comp_Stream trans_fun xs c) ! 0= trans_fun (xs ! 0) c\"", "lemma f_Exec_Stream_nth_gr0_calc: \"\n  \\<lbrakk> n < length xs; 0 < n \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c ! n =\n  trans_fun (xs ! n) (f_Exec_Comp_Stream trans_fun xs c ! (n - 1))\"", "lemma f_Exec_Stream_nth_calc_Previous: \"\n  n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c ! n =\n  trans_fun (xs ! n) ((f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n)\"", "lemma i_Exec_Stream_nth_0: \"\n  (i_Exec_Comp_Stream trans_fun input c) 0 = trans_fun (input 0) c\"", "lemma i_Exec_Stream_nth_gr0_calc: \"\n  0 < n \\<Longrightarrow>\n  (i_Exec_Comp_Stream trans_fun input c) n =\n  trans_fun (input n) ((i_Exec_Comp_Stream trans_fun input c) (n - 1))\"", "lemma i_Exec_Stream_nth_calc_Previous: \"\n  i_Exec_Comp_Stream trans_fun input c n =\n  trans_fun (input n) ((i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n)\"", "lemma f_Exec_Stream_Init_nth_Suc_calc: \"\n  n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n =\n  trans_fun (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n)\"", "lemma f_Exec_Stream_Init_nth_Plus1_calc: \"\n  n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! (n + 1)=\n  trans_fun (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n)\"", "lemma f_Exec_Stream_Init_nth_gr0_calc: \"\n  \\<lbrakk> n \\<le> length xs; 0 < n \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! n =\n  trans_fun (xs ! (n - 1)) (f_Exec_Comp_Stream_Init trans_fun xs c ! (n - 1))\"", "lemma i_Exec_Stream_Init_nth_Suc_calc: \"\n  i_Exec_Comp_Stream_Init trans_fun input c (Suc n) =\n  trans_fun (input n) (i_Exec_Comp_Stream_Init trans_fun input c n)\"", "lemma i_Exec_Stream_Init_nth_Plus1_calc: \"\n  i_Exec_Comp_Stream_Init trans_fun input c (n + 1) =\n  trans_fun (input n) (i_Exec_Comp_Stream_Init trans_fun input c n)\"", "lemma i_Exec_Stream_Init_nth_gr0_calc: \"\n  0 < n \\<Longrightarrow>\n  i_Exec_Comp_Stream_Init trans_fun input c n =\n  trans_fun (input (n - 1)) (i_Exec_Comp_Stream_Init trans_fun input c (n - 1))\"", "lemma f_Exec_Stream_Pre_Post1: \"\n  \\<lbrakk> n < length xs;\n    c_n = (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (f_Exec_Comp_Stream trans_fun xs c ! n)) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\"", "lemma f_Exec_Stream_Pre_Post2: \"\n  \\<lbrakk> n < length xs;\n    c_n = (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (xs ! n) (f_Exec_Comp_Stream trans_fun xs c ! n)) =\n  (P c_n \\<longrightarrow> Q x_n (trans_fun x_n c_n))\"", "lemma f_Exec_Stream_Pre_Post2_Suc: \"\n  \\<lbrakk> Suc n < length xs;\n    c_n = f_Exec_Comp_Stream trans_fun xs c ! n; x_n1 = xs ! Suc n \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (xs ! Suc n) (f_Exec_Comp_Stream trans_fun xs c ! Suc n)) =\n  (P c_n \\<longrightarrow> Q x_n1 (trans_fun x_n1 c_n))\"", "lemma f_Exec_Stream_Init_Pre_Post1: \"\n  \\<lbrakk> n < length xs;\n    c_n = f_Exec_Comp_Stream_Init trans_fun xs c ! n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n)) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\"", "lemma f_Exec_Stream_Init_Pre_Post2: \"\n  \\<lbrakk> n < length xs;\n    c_n = f_Exec_Comp_Stream_Init trans_fun xs c ! n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n) \\<longrightarrow>\n     Q (f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n)) =\n  (P x_n c_n \\<longrightarrow> Q (trans_fun x_n c_n))\"", "lemma i_Exec_Stream_Pre_Post1: \"\n  \\<lbrakk> c_n = (i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (i_Exec_Comp_Stream trans_fun input c n)) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\"", "lemma i_Exec_Stream_Pre_Post2: \"\n  \\<lbrakk> c_n = (i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (input n) (i_Exec_Comp_Stream trans_fun input c n)) =\n  (P c_n \\<longrightarrow> Q x_n (trans_fun x_n c_n))\"", "lemma i_Exec_Stream_Pre_Post2_Suc: \"\n  \\<lbrakk> c_n = i_Exec_Comp_Stream trans_fun input c n; x_n1 = input (Suc n) \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (input (Suc n)) (i_Exec_Comp_Stream trans_fun input c (Suc n))) =\n  (P c_n \\<longrightarrow> Q x_n1 (trans_fun x_n1 c_n))\"", "lemma i_Exec_Stream_Init_Pre_Post1: \"\n  \\<lbrakk> c_n = i_Exec_Comp_Stream_Init trans_fun input c n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (i_Exec_Comp_Stream_Init trans_fun input c (Suc n))) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\"", "lemma i_Exec_Stream_Init_Pre_Post2: \"\n  \\<lbrakk> c_n = i_Exec_Comp_Stream_Init trans_fun input c n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P (input n) (i_Exec_Comp_Stream_Init trans_fun input c n) \\<longrightarrow>\n     Q (i_Exec_Comp_Stream_Init trans_fun input c (Suc n))) =\n  (P x_n c_n \\<longrightarrow> Q (trans_fun x_n c_n))\"", "lemma f_Exec_Stream_prefix: \"\n  prefix xs ys \\<Longrightarrow>\n  prefix (f_Exec_Comp_Stream trans_fun xs c)\n         (f_Exec_Comp_Stream trans_fun ys c)\"", "lemma i_Exec_Stream_prefix: \"\n xs \\<sqsubseteq> input \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c \\<sqsubseteq>\n  i_Exec_Comp_Stream trans_fun input c\"", "lemma f_Exec_N_prefix: \"\n  \\<lbrakk> n \\<le> length xs; prefix xs ys \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_N trans_fun n xs c =\n  f_Exec_Comp_N trans_fun n ys c\"", "theorem f_Exec_Stream_prefix_causal[rule_format]:\"\n  n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c \\<down> n =\n  f_Exec_Comp_Stream trans_fun ys c \\<down> n\"", "lemma f_Exec_Stream_Init_prefix:\"\n  prefix xs ys \\<Longrightarrow>\n  prefix (f_Exec_Comp_Stream_Init trans_fun xs c)\n         (f_Exec_Comp_Stream_Init trans_fun ys c)\"", "lemma i_Exec_Stream_Init_prefix: \"\n xs \\<sqsubseteq> input \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c \\<sqsubseteq>\n  i_Exec_Comp_Stream_Init trans_fun input c\"", "theorem f_Exec_Stream_Init_prefix_strictly_causal[rule_format]:\"\n  n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c \\<down> Suc n =\n  f_Exec_Comp_Stream_Init trans_fun ys c \\<down> Suc n\"", "lemma Deterministic_f_Exec: \"\n  \\<lbrakk> Deterministic_Trans_Fun trans_fun localState; localState c1 = localState c2; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp trans_fun xs c1 = f_Exec_Comp trans_fun xs c2\"", "lemma Deterministic_f_Exec_Stream: \"\n  \\<lbrakk> Deterministic_Trans_Fun trans_fun localState; localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c1 = f_Exec_Comp_Stream trans_fun xs c2\"", "lemma Deterministic_i_Exec_Stream: \"\n  \\<lbrakk> Deterministic_Trans_Fun trans_fun localState; localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream trans_fun input c1 = i_Exec_Comp_Stream trans_fun input c2\"", "lemmas Streams_Connected_defs =\n  f_Streams_Connected_def\n  i_Streams_Connected_def", "lemma f_Streams_Connected_imp_not_empty: \"f_Streams_Connected outS inS \\<Longrightarrow> inS \\<noteq> []\"", "lemma f_Streams_Connected_nth_conv: \"\n  f_Streams_Connected outS inS =\n  (length inS = Suc (length outS) \\<and>\n  (\\<forall>i<length inS. inS ! i = (case i of 0 \\<Rightarrow> \\<NoMsg> | Suc k \\<Rightarrow> outS ! k)))\"", "lemma f_Streams_Connected_nth_conv_if: \"\n  f_Streams_Connected outS inS =\n  (length inS = Suc (length outS) \\<and>\n  (\\<forall>i<length inS. inS ! i = (if i = 0 then \\<NoMsg> else outS ! (i - Suc 0))))\"", "lemma i_Streams_Connected_nth_conv: \"\n  i_Streams_Connected outS inS =\n  (\\<forall>i. inS i = (case i of 0 \\<Rightarrow> \\<NoMsg> | Suc k \\<Rightarrow> outS k))\"", "lemma i_Streams_Connected_nth_conv_if: \"\n  i_Streams_Connected outS inS =\n  (\\<forall>i. inS i = (if i = 0 then \\<NoMsg> else outS (i - Suc 0)))\"", "lemma f_Exec_Stream_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun xs c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c) = channel\"", "lemma i_Exec_Stream_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    i_Streams_Connected\n      (output_fun \\<circ> (i_Exec_Comp_Stream trans_fun input c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c) = channel\"", "lemma f_Exec_Stream_output_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    output1 = map output_fun (f_Exec_Comp_Stream trans_fun xs c);\n    output2 = map output_fun (f_Exec_Comp_Stream trans_fun ys c) \\<rbrakk> \\<Longrightarrow>\n  output1 \\<down> n = output2 \\<down> n\"", "lemma f_Exec_Stream_Init_output_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    output1 = map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c);\n    output2 = map output_fun (f_Exec_Comp_Stream_Init trans_fun ys c) \\<rbrakk> \\<Longrightarrow>\n  output1 \\<down> Suc n = output2 \\<down> Suc n\"", "lemma i_Exec_Stream_output_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    output1 = output_fun \\<circ> i_Exec_Comp_Stream trans_fun input1 c;\n    output2 = output_fun \\<circ> i_Exec_Comp_Stream trans_fun input2 c \\<rbrakk> \\<Longrightarrow>\n  output1 \\<Down> n = output2 \\<Down> n\"", "lemma i_Exec_Stream_Init_output_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    output1 = output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input1 c;\n    output2 = output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input2 c \\<rbrakk> \\<Longrightarrow>\n  output1 \\<Down> Suc n = output2 \\<Down> Suc n\"", "lemma f_Exec_Stream_Connected_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun xs c))\n      channel1;\n    f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun ys c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<down> Suc n = channel2 \\<down> Suc n\"", "lemma i_Exec_Stream_Connected_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    i_Streams_Connected\n      (portOutput \\<circ> (i_Exec_Comp_Stream trans_fun input1 c))\n      channel1;\n    i_Streams_Connected\n      (portOutput \\<circ> (i_Exec_Comp_Stream trans_fun input2 c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<Down> Suc n = channel2 \\<Down> Suc n\"", "lemmas Streams_Connected_Init_defs =\n  f_Streams_Connected_Init_def\n  i_Streams_Connected_Init_def", "lemma f_Streams_Connected_Init_nth_conv: \"\n  f_Streams_Connected_Init outS inS =\n  (length inS = length outS \\<and> (\\<forall>i<length inS. inS ! i = outS ! i))\"", "lemma i_Streams_Connected_Init_nth_conv: \"\n  i_Streams_Connected_Init outS inS =\n  (\\<forall>i. inS i = outS i)\"", "lemma f_Exec_Stream_Init_eq_output_channel2: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c) = channel\"", "lemma i_Exec_Stream_Init_eq_output_channel2: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    i_Streams_Connected_Init\n      (output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c) = channel\"", "lemma f_Exec_Stream_Connected_Init_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c))\n      channel1;\n    f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun ys c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<down> Suc n = channel2 \\<down> Suc n\"", "lemma i_Exec_Stream_Connected_Init_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    i_Streams_Connected_Init\n      (portOutput \\<circ> (i_Exec_Comp_Stream_Init trans_fun input1 c))\n      channel1;\n    i_Streams_Connected_Init\n      (portOutput \\<circ> (i_Exec_Comp_Stream_Init trans_fun input2 c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<Down> Suc n = channel2 \\<Down> Suc n\"", "lemma f_State_Change_exists_set: \"\n  \\<lbrakk> n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n1) c);\n    P (f_Exec_Comp trans_fun (input \\<down> n2) c) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<in>I. n1 \\<le> n \\<and> n < n2 \\<and>\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n) c) \\<and>\n    P (f_Exec_Comp trans_fun (input \\<down> (inext n I)) c)\"", "lemma f_State_Change_exists: \"\n  \\<lbrakk> n1 \\<le> n2;\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n1) c);\n    P (f_Exec_Comp trans_fun (input \\<down> n2) c) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<ge>n1. n < n2 \\<and>\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n) c) \\<and>\n    P (f_Exec_Comp trans_fun (input \\<down> (Suc n)) c)\"", "lemma i_State_Change_exists_set: \"\n  \\<lbrakk> n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n1);\n    P (i_Exec_Comp_Stream trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<in>I. n1 \\<le> n \\<and> n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream trans_fun input c (inext n I))\"", "lemma i_State_Change_exists: \"\n  \\<lbrakk> n1 \\<le> n2;\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n1);\n    P (i_Exec_Comp_Stream trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<ge>n1. n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream trans_fun input c (Suc n))\"", "lemma i_State_Change_Init_exists_set: \"\n  \\<lbrakk> n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n1);\n    P (i_Exec_Comp_Stream_Init trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<in>I. n1 \\<le> n \\<and> n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream_Init trans_fun input c (inext n I))\"", "lemma i_State_Change_Init_exists: \"\n  \\<lbrakk> n1 \\<le> n2;\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n1);\n    P (i_Exec_Comp_Stream_Init trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<ge>n1. n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream_Init trans_fun input c (Suc n))\"", "lemma Equiv_Exec_equiv_statesI: \"\n  \\<lbrakk> equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec\n      m equiv_states\n        localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 (f_Exec_Comp trans_fun1 (input_fun1 m # \\<NoMsg>\\<^bsup>k1 - Suc 0\\<^esup>) c1))\n    (localState2 (f_Exec_Comp trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2))\"", "lemma Equiv_Exec_output_eqI: \"\n  \\<lbrakk> equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec\n      m equiv_states\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  last_message (map output_fun1 (\n    f_Exec_Comp_Stream trans_fun1 (input_fun1 m # \\<NoMsg>\\<^bsup>k1 - Suc 0\\<^esup>) c1)) =\n  last_message (map output_fun2 (\n    f_Exec_Comp_Stream trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2))\"", "lemma Equiv_Exec_equiv_statesI': \"\n  \\<lbrakk> equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec\n      m equiv_states\n        localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n   (localState1 (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup> (trans_fun1 (input_fun1 m) c1)))\n   (localState2 (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup> (trans_fun2 (input_fun2 m) c2)))\"", "lemma Equiv_Exec_le1: \"\n  \\<lbrakk> k1 \\<le> Suc 0; k2 \\<le> Suc 0;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec m\n      equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  output_fun1 (trans_fun1 (input_fun1 m) c1) =\n  output_fun2 (trans_fun2 (input_fun2 m) c2) \\<and>\n  equiv_states\n    (localState1 (trans_fun1 (input_fun1 m) c1))\n    (localState2 (trans_fun2 (input_fun2 m) c2))\"", "lemma Equiv_Exec_stable_set_UNIV: \"\n  Equiv_Exec_stable_set\n    UNIV equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 =\n  Equiv_Exec_stable\n    equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2\"", "lemma Equiv_Exec_stable_setI: \"\n  \\<lbrakk> Equiv_Exec_stable_set A\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2;\n    set input \\<subseteq> A; m \\<in> A \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n        m equiv_states\n        localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2\n        (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)\n        (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)\"", "lemma Equiv_Exec_stableI: \"\n  Equiv_Exec_stable\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 \\<Longrightarrow>\n  Equiv_Exec m\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2\n    (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)\n    (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)\"", "lemma Equiv_Exec_refl: \"\n  \\<lbrakk> \\<And>c. equiv_states (localState c) (localState c) \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n    m equiv_states\n    localState localState input_fun input_fun output_fun output_fun\n    trans_fun trans_fun k k c c\"", "lemma Equiv_Exec_sym[rule_format]: \"\n  \\<lbrakk> \\<forall>c1 c2.\n      equiv_states (localState1 c1) (localState2 c2) =\n      equiv_states (localState2 c2) (localState1 c1) \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n    m equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 =\n  Equiv_Exec\n    m equiv_states\n    localState2 localState1 input_fun2 input_fun1 output_fun2 output_fun1\n    trans_fun2 trans_fun1 k2 k1 c2 c1\"", "lemma Equiv_Exec_sym2: \"\n  \\<lbrakk> equiv_states_sym = (\\<lambda>s1 s2. equiv_states s2 s1) \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n    m equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 =\n  Equiv_Exec\n    m equiv_states_sym\n    localState2 localState1 input_fun2 input_fun1 output_fun2 output_fun1\n    trans_fun2 trans_fun1 k2 k1 c2 c1\"", "lemma Equiv_Exec_sym2_ex: \"\n  \\<exists>equiv_states_sym.\n    Equiv_Exec\n      m equiv_states\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2 =\n    Equiv_Exec\n      m equiv_states_sym\n      localState2 localState1 input_fun2 input_fun1 output_fun2 output_fun1\n      trans_fun2 trans_fun1 k2 k1 c2 c1\"", "lemma Equiv_Exec_trans: \"\n  \\<lbrakk> Equiv_Exec\n      m equiv_states12\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n    Equiv_Exec\n      m equiv_states23\n      localState2 localState3 input_fun2 input_fun3 output_fun2 output_fun3\n      trans_fun2 trans_fun3 k2 k3 c2 c3;\n    equiv_states13 = (\\<lambda>s1 s3. (\n      if s1 = localState1 c1 \\<and> s3 = localState3 c3 then\n        equiv_states12 s1 (localState2 c2) \\<and>\n        equiv_states23 (localState2 c2) s3\n      else\n        equiv_states12 s1 (\n          localState2 (f_Exec_Comp trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2))) \\<and>\n        equiv_states23 (\n          localState2 (f_Exec_Comp trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2)) s3) \\<rbrakk> \\<Longrightarrow>\n    Equiv_Exec\n      m equiv_states13\n      localState1 localState3 input_fun1 input_fun3 output_fun1 output_fun3\n      trans_fun1 trans_fun3 k1 k3 c1 c3\"", "lemma Equiv_Exec_trans_ex: \"\n  \\<lbrakk> Equiv_Exec\n      m equiv_states12\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n    Equiv_Exec\n      m equiv_states23\n      localState2 localState3 input_fun2 input_fun3 output_fun2 output_fun3\n      trans_fun2 trans_fun3 k2 k3 c2 c3 \\<rbrakk> \\<Longrightarrow>\n    \\<exists>equiv_states13. Equiv_Exec\n      m equiv_states13\n      localState1 localState3 input_fun1 input_fun3 output_fun1 output_fun3\n      trans_fun1 trans_fun3 k1 k3 c1 c3\"", "lemma Exec_Equal_StateD: \"\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  trans_fun m c1 = trans_fun m c2\"", "lemma Exec_Equal_StateD': \"\n  Exec_Equal_State localState trans_fun \\<Longrightarrow>\n  \\<forall>c1 c2 m. localState c1 = localState c2 \\<longrightarrow> trans_fun m c1 = trans_fun m c2\"", "lemma Exec_Equal_StateI: \"\n  (\\<And>c1 c2 m. localState c1 = localState c2 \\<Longrightarrow> trans_fun m c1 = trans_fun m c2)\n  \\<Longrightarrow> Exec_Equal_State localState trans_fun\"", "lemma f_Exec_Equal_State: \"\\<And>c1 c2.\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp trans_fun xs c1 = f_Exec_Comp trans_fun xs c2\"", "lemma f_Exec_Stream_Equal_State: \"\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c1 =\n  f_Exec_Comp_Stream trans_fun xs c2\"", "lemma i_Exec_Stream_Equal_State: \"\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream trans_fun input c1 =\n  i_Exec_Comp_Stream trans_fun input c2\"", "lemma State_IdleD: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun state;\n    localState c = state \\<rbrakk> \\<Longrightarrow>\n  localState (trans_fun \\<NoMsg> c) = state \\<and>\n  output_fun (trans_fun \\<NoMsg> c) = \\<NoMsg>\"", "lemma State_IdleD': \"\n  State_Idle localState output_fun trans_fun state \\<Longrightarrow>\n  \\<forall>c. localState c = state \\<longrightarrow>\n  localState (trans_fun \\<NoMsg> c) = state \\<and>\n  output_fun (trans_fun \\<NoMsg> c) = \\<NoMsg>\"", "lemma State_IdleI: \"\n  \\<lbrakk> \\<And>c. localState c = state \\<Longrightarrow>\n    localState (trans_fun \\<NoMsg> c) = state \\<and>\n    output_fun (trans_fun \\<NoMsg> c) = \\<NoMsg> \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun state\"", "lemma State_Idle_step[rule_format]: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c) \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun (localState (trans_fun \\<NoMsg> c))\"", "lemma f_Exec_State_Idle_replicate_NoMsg_state[rule_format]: \"\n  \\<And>c. State_Idle localState output_fun trans_fun (localState c) \\<Longrightarrow>\n  localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = localState c\"", "lemma f_Exec_State_Idle_replicate_NoMsg_gr0_output[rule_format]: \"\\<And>c.\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c); 0 < n \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\"", "lemma f_Exec_State_Idle_replicate_NoMsg_output[rule_format]: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c);\n    output_fun c = \\<NoMsg> \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\"", "lemma f_Exec_Stream_State_Idle_replicate_NoMsg_output[rule_format]: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c) \\<rbrakk> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\\<^bsup>n\\<^esup>\"", "lemma State_Idle_append_replicate_NoMsg_output_last_message: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c)) \\<rbrakk> \\<Longrightarrow>\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c)) =\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun xs c))\"", "lemma State_Idle_append_replicate_NoMsg_output_Msg_eq_last_message: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c));\n    output_fun (f_Exec_Comp trans_fun xs c) \\<noteq> \\<NoMsg>;\n    xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c)) =\n  output_fun (f_Exec_Comp trans_fun xs c)\"", "lemma State_Idle_imp_exists_state_change: \"\n  \\<lbrakk> \\<not> State_Idle localState output_fun trans_fun (localState c);\n    State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c)) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>i<n. (\n    \\<not> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>i\\<^esup> c)) \\<and> (\n    \\<forall>j\\<le>n. i < j \\<longrightarrow> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>j\\<^esup> c))))\"", "lemma State_Idle_imp_exists_state_change2: \"\n  \\<lbrakk> \\<not> State_Idle localState output_fun trans_fun (localState c);\n    State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c)) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>i<n. (\n    (\\<forall>j\\<le>i. \\<not> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>i\\<^esup> c))) \\<and>\n    (\\<forall>j\\<le>n. i < j \\<longrightarrow> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>j\\<^esup> c))))\"", "lemma f_Exec_Stream_Acc_Output_length[simp]: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c) = length xs\"", "lemma f_Exec_Stream_Acc_LocalState_length[simp]: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c) = length xs\"", "lemmas f_Exec_Stream_Acc_length =\n  f_Exec_Stream_Acc_LocalState_length\n  f_Exec_Stream_Acc_Output_length", "lemma f_Exec_Stream_Acc_Output_Nil[simp]: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun [] c = []\"", "lemma f_Exec_Stream_Acc_LocalState_Nil[simp]: \"\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun [] c = []\"", "lemmas f_Exec_Stream_Acc_Nil =\n  f_Exec_Stream_Acc_LocalState_Nil\n  f_Exec_Stream_Acc_Output_Nil", "lemma f_Exec_Stream_Acc_Output_0[simp]: \"\n  f_Exec_Comp_Stream_Acc_Output 0 output_fun trans_fun xs c = []\"", "lemma f_Exec_Stream_Acc_LocalState_0[simp]: \"\n  f_Exec_Comp_Stream_Acc_LocalState 0 localState trans_fun xs c = []\"", "lemmas f_Exec_Stream_Acc_0 =\n  f_Exec_Stream_Acc_LocalState_0\n  f_Exec_Stream_Acc_Output_0", "lemma f_Exec_Stream_Acc_Output_1[simp]: \"\n  f_Exec_Comp_Stream_Acc_Output (Suc 0) output_fun trans_fun xs c =\n  map output_fun (f_Exec_Comp_Stream trans_fun xs c)\"", "lemma f_Exec_Stream_Acc_LocalState_1[simp]: \"\n  f_Exec_Comp_Stream_Acc_LocalState (Suc 0) localState trans_fun xs c =\n  map localState (f_Exec_Comp_Stream trans_fun xs c)\"", "lemma i_Exec_Stream_Acc_Output_1[simp]: \"\n  i_Exec_Comp_Stream_Acc_Output (Suc 0) output_fun trans_fun input c =\n  output_fun \\<circ> (i_Exec_Comp_Stream trans_fun input c)\"", "lemma i_Exec_Stream_Acc_LocalState_1[simp]: \"\n  i_Exec_Comp_Stream_Acc_LocalState (Suc 0) localState trans_fun input c =\n  localState \\<circ> (i_Exec_Comp_Stream trans_fun input c)\"", "lemma f_Exec_Stream_Acc_Output_eq_last_message_hold: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  (map output_fun (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) \\<longmapsto>\\<^sub>f k \\<div>\\<^bsub>fl\\<^esub> k\"", "lemma i_Exec_Stream_Acc_Output_eq_last_message_hold: \"0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  (output_fun \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) \\<longmapsto>\\<^sub>i k \\<div>\\<^bsub>il\\<^esub> k\"", "lemma f_Exec_Stream_Acc_Output_take: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<down> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<down> n) c\"", "lemma f_Exec_Stream_Acc_Output_drop: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<up> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<up> n) (\n    f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)\"", "lemma i_Exec_Stream_Acc_Output_take: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c \\<Down> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Down> n) c\"", "lemma i_Exec_Stream_Acc_Output_drop: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c \\<Up> n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Up> n) (\n    f_Exec_Comp trans_fun (input \\<Down> n \\<odot>\\<^sub>f k) c)\"", "lemma i_Exec_Stream_Acc_LocalState_take: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c \\<Down> n =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Down> n) c\"", "lemma i_Exec_Stream_Acc_LocalState_drop: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c \\<Up> n =\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Up> n) (\n    f_Exec_Comp trans_fun (input \\<Down> n \\<odot>\\<^sub>f k) c)\"", "lemma f_Exec_Stream_Acc_Output_append: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs @ ys) c =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c @\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\"", "lemma f_Exec_Stream_Acc_Output_Cons: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (x # xs) c =\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)) #\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\"", "lemma f_Exec_Stream_Acc_Output_one: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun [x] c =\n  [last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))]\"", "lemma f_Exec_Stream_Acc_Output_snoc: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs @ [x]) c =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c @\n  [last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)))]\"", "lemma i_Exec_Stream_Acc_Output_append: \"\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\"", "lemma i_Exec_Stream_Acc_Output_Cons: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ([x] \\<frown> input) c =\n  [last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))] \\<frown>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\"", "lemma f_Exec_Stream_Acc_LocalState_append: \"\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs @ ys) c =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c @\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun ys (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\"", "lemma f_Exec_Stream_Acc_LocalState_Cons: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (x # xs) c =\n  localState (f_Exec_Comp trans_fun (x #  \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c) #\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\"", "lemma f_Exec_Stream_Acc_LocalState_one: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun [x] c =\n  [localState (f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)]\"", "lemma f_Exec_Stream_Acc_LocalState_snoc: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs @ [x]) c =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c @\n  [localState (f_Exec_Comp trans_fun ((xs @ [x]) \\<odot>\\<^sub>f k) c)]\"", "lemma i_Exec_Stream_Acc_LocalState_append: \"\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\"", "lemma i_Exec_Stream_Acc_LocalState_Cons: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun ([x] \\<frown> input) c =\n  [localState (f_Exec_Comp trans_fun (x #  \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)] \\<frown>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\"", "lemma f_Exec_Stream_Acc_Output_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c ! n =\n  last_message (map output_fun (\n    f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n      f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)))\"", "lemma f_Exec_Stream_Acc_Output_nth_eq_i_nth: \"\n  \\<lbrakk> 0 < k; n < n' \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Down> n') c ! n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n\"", "lemma i_Exec_Stream_Acc_Output_nth: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n =\n  last_message (map output_fun (\n    f_Exec_Comp_Stream trans_fun (input n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n      f_Exec_Comp trans_fun (input \\<Down> n \\<odot>\\<^sub>f k) c)))\"", "lemma f_Exec_Stream_Acc_LocalState_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! n =\n  localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot>\\<^sub>f k) c)\"", "lemma f_Exec_Stream_Acc_LocalState_nth_eq_i_nth: \"\n  \\<lbrakk> 0 < k; n < n' \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Down> n') c ! n =\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c n\"", "lemma i_Exec_Stream_Acc_LocalState_nth: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c n =\n  localState (f_Exec_Comp trans_fun (input \\<Down> Suc n \\<odot>\\<^sub>f k) c)\"", "lemma f_Exec_Stream_Acc_Output_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<down> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys c \\<down> n\"", "lemma i_Exec_Stream_Acc_Output_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c \\<Down> n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c \\<Down> n\"", "lemma f_Exec_Stream_Acc_Output_Connected_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c)\n      channel1;\n    f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys c)\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<down> Suc n = channel2 \\<down> Suc n\"", "lemma i_Exec_Stream_Acc_Output_Connected_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c)\n      channel1;\n    i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c)\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<Down> Suc n = channel2 \\<Down> Suc n\"", "lemma Deterministic_trans_fun_imp_acc_trans_fun:\n  \"Deterministic_Trans_Fun trans_fun localState \\<Longrightarrow>\n    Deterministic_Trans_Fun (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState\"", "lemma is_Pointwise_Output_Shrink_list_imp_is_Pointwise_Output_Shrink:\n  \"\\<lbrakk> is_Pointwise_Output_Shrink_list pointwise_shrink fs; output_fun \\<in> set fs \\<rbrakk> \\<Longrightarrow>\n    is_Pointwise_Output_Shrink pointwise_shrink output_fun\"", "lemma is_Pointwise_Output_Shrink_list_eq_is_Pointwise_Output_Shrink_all:\n  \"(is_Pointwise_Output_Shrink_list pointwise_shrink fs) =\n    (\\<forall>output_fun \\<in> set fs. is_Pointwise_Output_Shrink pointwise_shrink output_fun)\"", "lemma is_Pointwise_Output_Shrink_subset:\n  \"\\<lbrakk> is_Pointwise_Output_Shrink_list pointwise_shrink fs; set fs' \\<subseteq> set fs \\<rbrakk> \\<Longrightarrow>\n    is_Pointwise_Output_Shrink_list pointwise_shrink fs'\"", "lemma f_Exec_Stream_Acc_LocalState_eq_Acc_Trans_Fun_Step_LocalState: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c =\n  map localState (f_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) xs c)\"", "lemma f_Exec_Stream_Acc_Output_eq_Acc_Trans_Fun_Step_Output: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState;\n    is_Pointwise_Output_Shrink pointwise_shrink output_fun \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  map output_fun (f_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) xs c)\"", "lemma i_Exec_Stream_Acc_LocalState_eq_Acc_Trans_Fun_Step_LocalState: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c =\n  localState \\<circ> (i_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) input c)\"", "lemma i_Exec_Stream_Acc_Output_eq_Acc_Trans_Fun_Step_Output: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState;\n    is_Pointwise_Output_Shrink pointwise_shrink output_fun \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  output_fun \\<circ> (i_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) input c)\"", "lemma f_Exec_Stream_Acc_Output_Init_length: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c) = Suc (length xs)\"", "lemma f_Exec_Stream_Acc_LocalState_Init_length: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun xs c) = Suc (length xs)\"", "lemma f_Exec_Stream_Acc_Output_Init_Nil: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun [] c = [output_fun c]\"", "lemma f_Exec_Stream_Acc_LocalState_Init_Nil: \"\n  f_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun [] c = [localState c]\"", "lemma f_Exec_Stream_Acc_Output_Init_1: \"\n  f_Exec_Comp_Stream_Acc_Output_Init (Suc 0) output_fun trans_fun xs c =\n  map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c)\"", "lemma f_Exec_Stream_Acc_LocalState_Init_1: \"\n  f_Exec_Comp_Stream_Acc_LocalState_Init (Suc 0) localState trans_fun xs c =\n  map localState (f_Exec_Comp_Stream_Init trans_fun xs c)\"", "lemma i_Exec_Stream_Acc_Output_Init_1: \"\n  i_Exec_Comp_Stream_Acc_Output_Init (Suc 0) output_fun trans_fun input c =\n  output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c)\"", "lemma i_Exec_Stream_Acc_LocalState_Init_1: \"\n  i_Exec_Comp_Stream_Acc_LocalState_Init (Suc 0) localState trans_fun input c =\n  localState \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c)\"", "lemma f_Exec_Stream_Acc_Output_Init_take: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<down> (Suc n) =\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun (xs \\<down> n) c\"", "lemma f_Exec_Stream_Acc_Output_Init_drop': \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<up> Suc n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<up> n\"", "lemma i_Exec_Stream_Acc_Output_Init_take: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c \\<Down> (Suc n) =\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun (input \\<Down> n) c\"", "lemma i_Exec_Stream_Acc_Output_Init_drop': \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<Up> Suc n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<Up> n\"", "lemma f_Exec_Stream_Acc_Output_Init_strictly_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<down> Suc n =\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun ys c \\<down> Suc n\"", "lemma i_Exec_Stream_Acc_Output_Init_strictly_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input1 c \\<Down> Suc n =\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input2 c \\<Down> Suc n\"", "lemma f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c =\n  output_fun c # f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c\"", "lemma f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons_output: \"\n  output_fun c = \\<NoMsg> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c =\n  \\<NoMsg> # f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c\"", "lemma f_Exec_Stream__Acc_OutputInit_tl_eq_f_Exec_Stream_Acc_Output: \"\n  tl (f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c) =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c\"", "lemma f_Exec_Stream_Previous_f_Exec_Stream_Acc_Output_Init: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c ! n =\n  (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c)\\<^bsup>\\<leftarrow>' output_fun c\\<^esup> n\"", "lemma f_Exec_Stream_Acc_Output_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c)\n      channel \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c = channel\"", "lemma i_Exec_Stream_Acc_Output_Init_eq_i_Exec_Stream_Acc_Output_Cons: \"\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c =\n  [output_fun c] \\<frown> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c\"", "lemma i_Exec_Stream_Acc_Output_Init_eq_i_Exec_Stream_Acc_Output_Cons_output: \"\n  output_fun c = \\<NoMsg> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c =\n  [\\<NoMsg> ] \\<frown> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c\"", "lemma i_Exec_Stream_Previous_i_Exec_Stream_Acc_Output_Init: \"\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c n =\n  (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c)\\<^bsup>\\<leftarrow> output_fun c\\<^esup> n\"", "lemma i_Exec_Stream_Acc_Output_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c)\n      channel \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c = channel\"", "lemma f_Equiv_Exec_Stream_expand_shrink_equiv_state_set[rule_format]: \"\n  \\<And>c1 c2 i. \\<lbrakk>\n   0 < k1; 0 < k2;\n   equiv_states (localState1 c1) (localState2 c2);\n   \\<forall>input0. set input0 \\<subseteq> A \\<longrightarrow> (\\<forall>m\\<in>A.\n      Equiv_Exec m equiv_states\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2\n      (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n      (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2));\n      \\<comment> \\<open>\\<open>equiv_states\\<close> relation implies equivalent executions\\<close>\n      \\<comment> \\<open>not only at the beginning but also after processing an input\\<close>\n   set input \\<subseteq> A; i < length input \\<rbrakk> \\<Longrightarrow>\n   equiv_states\n     (localState1 ((f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1) \\<div>\\<^bsub>fl\\<^esub> k1 ! i))\n     (localState2 ((f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2) \\<div>\\<^bsub>fl\\<^esub> k2 ! i))\"", "lemma f_Equiv_Exec_expand_shrink_equiv_state_set:\"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    set input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1))\n    (localState2 (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2))\"", "lemma f_Equiv_Exec_expand_shrink_equiv_state:\"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1))\n    (localState2 (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2))\"", "lemma i_Equiv_Exec_Stream_expand_shrink_equiv_state_set[rule_format]: \"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n        m equiv_states localState1 localState2\n        input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n       (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n       (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 ((i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1 \\<div>\\<^bsub>il\\<^esub> k1) i))\n    (localState2 ((i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2 \\<div>\\<^bsub>il\\<^esub> k2) i))\"", "lemma i_Equiv_Exec_Stream_expand_shrink_equiv_state: \"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n        m equiv_states localState1 localState2\n        input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n       (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n       (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 ((i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1 \\<div>\\<^bsub>il\\<^esub> k1) i))\n    (localState2 ((i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2 \\<div>\\<^bsub>il\\<^esub> k2) i))\"", "lemma f_Equiv_Exec_Stream_expand_shrink_output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk> set input0 \\<subseteq> A; m \\<in> A \\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    set input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  (map output_fun1 (\n    f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)) \\<div>\\<^sub>f k1 =\n  (map output_fun2 (\n    f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)) \\<div>\\<^sub>f k2\"", "lemma f_Equiv_Exec_Stream_expand_shrink_output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2\n         trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  (map output_fun1 (\n    f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)) \\<div>\\<^sub>f k1 =\n  (map output_fun2 (\n    f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)) \\<div>\\<^sub>f k2\"", "lemma i_Equiv_Exec_Stream_expand_shrink_output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk> set input0 \\<subseteq> A; m \\<in> A \\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2\n         trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  (output_fun1 \\<circ>\n    i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1) \\<div>\\<^sub>i k1 =\n  (output_fun2 \\<circ>\n    i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2) \\<div>\\<^sub>i k2\"", "lemma i_Equiv_Exec_Stream_expand_shrink_output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  (output_fun1 \\<circ>\n    i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1) \\<div>\\<^sub>i k1 =\n  (output_fun2 \\<circ>\n    i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2) \\<div>\\<^sub>i k2\"", "lemma f_Equiv_Exec_Stream_Acc_LocalState_set: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n      \\<comment> \\<open>\\<open>equiv_states\\<close> relation implies equivalent executions\\<close>\n      \\<comment> \\<open>not only at the beginning but also after processing an input\\<close>\n    set input \\<subseteq> A;\n    i < length input \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (f_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (map input_fun1 input) c1 ! i)\n    (f_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (map input_fun2 input) c2 ! i)\"", "lemma f_Equiv_Exec_Stream_Acc_LocalState: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n      \\<comment> \\<open>\\<open>equiv_states\\<close> relation implies equivalent executions\\<close>\n      \\<comment> \\<open>not only at the beginning but also after processing an input\\<close>\n    i < length input \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (f_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (map input_fun1 input) c1 ! i)\n    (f_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (map input_fun2 input) c2 ! i)\"", "lemma f_Equiv_Exec_Stream_Acc_Output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n    set input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (map input_fun1 input) c1 =\n  f_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (map input_fun2 input) c2\"", "lemma f_Equiv_Exec_Stream_Acc_Output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (map input_fun1 input) c1 =\n  f_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (map input_fun2 input) c2\"", "lemma i_Equiv_Exec_Stream_Acc_LocalState_set: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (i_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (input_fun1 \\<circ> input) c1 i)\n    (i_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (input_fun2 \\<circ> input) c2 i)\"", "lemma i_Equiv_Exec_Stream_Acc_LocalState: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (i_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (input_fun1 \\<circ> input) c1 i)\n    (i_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (input_fun2 \\<circ> input) c2 i)\"", "lemma i_Equiv_Exec_Stream_Acc_Output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (input_fun1 \\<circ> input) c1 =\n  i_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (input_fun2 \\<circ> input) c2\"", "lemma i_Equiv_Exec_Stream_Acc_Output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (input_fun1 \\<circ> input) c1 =\n  i_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (input_fun2 \\<circ> input) c2\"", "lemma f_Exec_Stream_Acc_LocalState__State_Idle_nth[rule_format]: \"\n  \\<And>c i.\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! n);\n    i < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! i =\n  f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! i\"", "lemma i_Exec_Stream_Acc_LocalState__State_Idle_nth[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c n) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c i =\n  i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c i\"", "lemma f_Exec_Stream_Acc_Output__State_Idle_nth[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! n);\n    i < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c ! i =\n  f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun xs c ! i\"", "lemma f_Exec_Stream_Acc_Output__State_Idle_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n<length xs. State_Idle localState output_fun trans_fun (\n      f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! n) \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun xs c\"", "lemma i_Exec_Stream_Acc_Output__State_Idle_nth[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c n) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c i =\n  i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun input c i\"", "lemma i_Exec_Stream_Acc_Output__State_Idle_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n. State_Idle localState output_fun trans_fun (\n      i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c n) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun input c\"", "lemma f_Exec_Stream_Acc_LocalState__State_Idle_all[rule_format]: \"\n  \\<And>c xs. \\<lbrakk> 0 < l; l \\<le> k;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c));\n    i < length xs \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun (\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! i)\"", "lemma i_Exec_Stream_Acc_LocalState__State_Idle_all[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun (\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c i)\"", "lemma f_Exec_Stream_Acc_Output__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun xs c\"", "lemma i_Exec_Stream_Acc_Output__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun input c\"", "lemma f_Exec_Stream_Acc_LocalState__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c =\n  f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c\"", "lemma i_Exec_Stream_Acc_LocalState__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c =\n  i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c\"", "lemma f_Exec_input_map: \"\\<And>c.\n  f_Exec_Comp trans_fun (map f xs) c = f_Exec_Comp (trans_fun \\<circ> f) xs c\"", "lemma f_Exec_Stream_input_map: \"\n  f_Exec_Comp_Stream trans_fun (map f xs) c =\n  f_Exec_Comp_Stream (trans_fun \\<circ> f) xs c\"", "lemma i_Exec_Stream_input_map: \"\n  i_Exec_Comp_Stream trans_fun (f \\<circ> input) c =\n  i_Exec_Comp_Stream (trans_fun \\<circ> f) input c\""], "translations": [["", "lemma f_Exec_one: \"f_Exec_Comp trans_fun [m] c = trans_fun m c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp trans_fun [m] c = trans_fun m c", "by simp"], ["", "lemma f_Exec_Stream_length[rule_format, simp]:\"\n  \\<forall>c. length (f_Exec_Comp_Stream trans_fun xs c) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. length (f_Exec_Comp_Stream trans_fun xs c) = length xs", "by (induct xs, simp_all)"], ["", "lemma f_Exec_Stream_empty_conv:\"\n  (f_Exec_Comp_Stream trans_fun xs c = []) = (xs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f_Exec_Comp_Stream trans_fun xs c = []) = (xs = [])", "by (simp add: length_0_conv[symmetric] del: length_0_conv)"], ["", "lemma f_Exec_Stream_not_empty_conv:\"\n  (f_Exec_Comp_Stream trans_fun xs c \\<noteq> []) = (xs \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f_Exec_Comp_Stream trans_fun xs c \\<noteq> []) = (xs \\<noteq> [])", "by (simp add: f_Exec_Stream_empty_conv)"], ["", "lemma f_Exec_eq_f_Exec_Stream_last[rule_format]:\"\n  \\<forall>c. f_Exec_Comp trans_fun xs c = last (c # (f_Exec_Comp_Stream trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       f_Exec_Comp trans_fun xs c =\n       last (c # f_Exec_Comp_Stream trans_fun xs c)", "by (induct xs, simp_all)"], ["", "corollary f_Exec_eq_f_Exec_Stream_last2[rule_format]: \"\n  xs \\<noteq> [] \\<Longrightarrow>\n  f_Exec_Comp trans_fun xs c = last (f_Exec_Comp_Stream trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    f_Exec_Comp trans_fun xs c = last (f_Exec_Comp_Stream trans_fun xs c)", "by (simp add: f_Exec_eq_f_Exec_Stream_last f_Exec_Stream_empty_conv[symmetric, of xs trans_fun c])"], ["", "corollary f_Exec_eq_f_Exec_Stream_last_if: \"\n  f_Exec_Comp trans_fun xs c = (if xs = [] then c else last (f_Exec_Comp_Stream trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp trans_fun xs c =\n    (if xs = [] then c else last (f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: f_Exec_eq_f_Exec_Stream_last2)"], ["", "corollary f_Exec_take_eq_last_f_Exec_Stream_take:\"\n  \\<lbrakk> xs \\<noteq> []; 0 < n \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp trans_fun (xs \\<down> n) c =\n  last (f_Exec_Comp_Stream trans_fun (xs \\<down> n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; 0 < n\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp trans_fun (xs \\<down> n) c =\n                      last (f_Exec_Comp_Stream trans_fun (xs \\<down> n) c)", "by (simp add: f_Exec_eq_f_Exec_Stream_last2 take_not_empty_conv)"], ["", "corollary f_Exec_N_eq_last_f_Exec_Stream_take:\"\n  \\<lbrakk> xs \\<noteq> []; 0 < n \\<rbrakk> \\<Longrightarrow>\n    f_Exec_Comp_N trans_fun n xs c =\n    last (f_Exec_Comp_Stream trans_fun (xs \\<down> n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; 0 < n\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_N trans_fun n xs c =\n                      last (f_Exec_Comp_Stream trans_fun (xs \\<down> n) c)", "by (simp add: f_Exec_Comp_N_def f_Exec_take_eq_last_f_Exec_Stream_take)"], ["", "lemma f_Exec_Stream_nth: \"\n  \\<And>n c. n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c ! n = f_Exec_Comp trans_fun (xs \\<down> Suc n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       n < length xs \\<Longrightarrow>\n       f_Exec_Comp_Stream trans_fun xs c ! n =\n       f_Exec_Comp trans_fun (xs \\<down> Suc n) c", "apply (induct xs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs n c.\n       \\<lbrakk>\\<And>n c.\n                   n < length xs \\<Longrightarrow>\n                   f_Exec_Comp_Stream trans_fun xs c ! n =\n                   f_Exec_Comp trans_fun (xs \\<down> Suc n) c;\n        n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream trans_fun (a # xs) c ! n =\n                         f_Exec_Comp trans_fun ((a # xs) \\<down> Suc n) c", "apply (simp add: nth_Cons')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_nth2: \"\n  n \\<le> length xs \\<Longrightarrow>\n  (c # f_Exec_Comp_Stream trans_fun xs c) ! n = f_Exec_Comp trans_fun (xs \\<down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    (c # f_Exec_Comp_Stream trans_fun xs c) ! n =\n    f_Exec_Comp trans_fun (xs \\<down> n) c", "by (simp add: nth_Cons' f_Exec_Stream_nth)"], ["", "lemma f_Exec_N_all:\"\n  length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_N trans_fun n xs c = f_Exec_Comp trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_N trans_fun n xs c = f_Exec_Comp trans_fun xs c", "by (simp add: f_Exec_Comp_N_def)"], ["", "lemma f_Exec_Stream_append[rule_format]:\"\\<forall>c.\n  f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream trans_fun xs c) @\n    (f_Exec_Comp_Stream trans_fun ys (f_Exec_Comp trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n       f_Exec_Comp_Stream trans_fun xs c @\n       f_Exec_Comp_Stream trans_fun ys (f_Exec_Comp trans_fun xs c)", "by (induct xs, simp_all)"], ["", "corollary f_Exec_Stream_append_last_Cons[rule_format]:\"\n  f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream trans_fun xs c) @\n    (f_Exec_Comp_Stream trans_fun ys (last (c # (f_Exec_Comp_Stream  trans_fun xs c))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream trans_fun xs c @\n    f_Exec_Comp_Stream trans_fun ys\n     (last (c # f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: f_Exec_Stream_append f_Exec_eq_f_Exec_Stream_last)"], ["", "corollary f_Exec_Stream_append_last[rule_format]:\"\n  xs \\<noteq> [] \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream trans_fun xs c) @\n    (f_Exec_Comp_Stream trans_fun ys (last (f_Exec_Comp_Stream  trans_fun xs c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream trans_fun xs c @\n    f_Exec_Comp_Stream trans_fun ys\n     (last (f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: f_Exec_Stream_append_last_Cons f_Exec_Stream_empty_conv)"], ["", "corollary f_Exec_Stream_append_if:\"\n  f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream trans_fun xs c) @\n    (f_Exec_Comp_Stream trans_fun ys (\n      if xs = [] then c else last (f_Exec_Comp_Stream trans_fun xs c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream trans_fun xs c @\n    f_Exec_Comp_Stream trans_fun ys\n     (if xs = [] then c else last (f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: f_Exec_Stream_append f_Exec_eq_f_Exec_Stream_last_if)"], ["", "corollary f_Exec_append:\"\n  f_Exec_Comp trans_fun (xs @ ys) c =\n  f_Exec_Comp trans_fun ys (f_Exec_Comp trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp trans_fun (xs @ ys) c =\n    f_Exec_Comp trans_fun ys (f_Exec_Comp trans_fun xs c)", "by (simp add: f_Exec_eq_f_Exec_Stream_last f_Exec_Stream_append_if f_Exec_Stream_empty_conv)"], ["", "corollary f_Exec_Stream_Cons_rev: \"\n  xs \\<noteq> [] \\<Longrightarrow>\n  (trans_fun (hd xs) c) #\n  f_Exec_Comp_Stream trans_fun (tl xs) (trans_fun (hd xs) c) =\n  f_Exec_Comp_Stream trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    trans_fun (hd xs) c #\n    f_Exec_Comp_Stream trans_fun (tl xs) (trans_fun (hd xs) c) =\n    f_Exec_Comp_Stream trans_fun xs c", "by (subst f_Exec_Stream_Cons[symmetric], simp)"], ["", "lemma f_Exec_Stream_snoc: \"\n  f_Exec_Comp_Stream trans_fun (xs @ [x]) c =\n    f_Exec_Comp_Stream trans_fun xs c @\n    [trans_fun x (f_Exec_Comp trans_fun xs c)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream trans_fun (xs @ [x]) c =\n    f_Exec_Comp_Stream trans_fun xs c @\n    [trans_fun x (f_Exec_Comp trans_fun xs c)]", "by (simp add: f_Exec_Stream_append)"], ["", "lemma f_Exec_snoc: \"\n  f_Exec_Comp trans_fun (xs @ [x]) c =\n  trans_fun x (f_Exec_Comp trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp trans_fun (xs @ [x]) c =\n    trans_fun x (f_Exec_Comp trans_fun xs c)", "by (simp add: f_Exec_append)"], ["", "lemma f_Exec_N_append[rule_format]:\"\n  f_Exec_Comp_N trans_fun (a + b) xs c =\n  f_Exec_Comp_N trans_fun b (xs \\<up> a) (f_Exec_Comp_N trans_fun a xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_N trans_fun (a + b) xs c =\n    f_Exec_Comp_N trans_fun b (xs \\<up> a) (f_Exec_Comp_N trans_fun a xs c)", "apply (simp add: f_Exec_Comp_N_def f_Exec_append[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp trans_fun (xs \\<down> (a + b)) c =\n    f_Exec_Comp trans_fun (xs \\<down> a @ xs \\<up> a \\<down> b) c", "apply (simp add: take_drop add.commute[of b])"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp trans_fun (xs \\<down> (a + b)) c =\n    f_Exec_Comp trans_fun (xs \\<down> a @ xs \\<down> (a + b) \\<up> a) c", "apply (rule subst[of \"xs \\<down> (a + b) \\<down> a\" \"xs \\<down> a\" ], simp add: min_eqL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp trans_fun (xs \\<down> (a + b)) c =\n    f_Exec_Comp trans_fun\n     (xs \\<down> (a + b) \\<down> a @ xs \\<down> (a + b) \\<up> a) c", "apply (subst append_take_drop_id, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Exec_N_Suc[rule_format]:\"\n  f_Exec_Comp_N trans_fun (Suc n) xs c =\n  f_Exec_Comp_N trans_fun (Suc 0) (xs \\<up> n) (f_Exec_Comp_N trans_fun n xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_N trans_fun (Suc n) xs c =\n    f_Exec_Comp_N trans_fun (Suc 0) (xs \\<up> n)\n     (f_Exec_Comp_N trans_fun n xs c)", "by (simp add: f_Exec_N_append[symmetric])"], ["", "corollary f_Exec_N_Suc2[rule_format]:\"\n  n < length xs \\<Longrightarrow>\n  f_Exec_Comp_N trans_fun (Suc n) xs c =\n  trans_fun (xs ! n) (f_Exec_Comp_N trans_fun n xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    f_Exec_Comp_N trans_fun (Suc n) xs c =\n    trans_fun (xs ! n) (f_Exec_Comp_N trans_fun n xs c)", "by (simp add: f_Exec_Comp_N_def take_Suc_conv_app_nth f_Exec_append)"], ["", "theorem f_Exec_Stream_take:\"\n  (f_Exec_Comp_Stream trans_fun xs c) \\<down> n =\n  f_Exec_Comp_Stream trans_fun (xs \\<down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream trans_fun xs c \\<down> n =\n    f_Exec_Comp_Stream trans_fun (xs \\<down> n) c", "apply (case_tac \"length xs \\<le> n\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun xs c \\<down> n =\n    f_Exec_Comp_Stream trans_fun (xs \\<down> n) c", "apply (rule subst[OF append_take_drop_id, of _ n xs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun (xs \\<down> n @ xs \\<up> n) c \\<down> n =\n    f_Exec_Comp_Stream trans_fun ((xs \\<down> n @ xs \\<up> n) \\<down> n) c", "apply (simp add: f_Exec_Stream_append del: append_take_drop_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem f_Exec_Stream_drop:\"\n  (f_Exec_Comp_Stream trans_fun xs c) \\<up> n =\n  f_Exec_Comp_Stream trans_fun (xs \\<up> n)\n    (f_Exec_Comp trans_fun (xs \\<down> n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream trans_fun xs c \\<up> n =\n    f_Exec_Comp_Stream trans_fun (xs \\<up> n)\n     (f_Exec_Comp trans_fun (xs \\<down> n) c)", "apply (case_tac \"length xs \\<le> n\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun xs c \\<up> n =\n    f_Exec_Comp_Stream trans_fun (xs \\<up> n)\n     (f_Exec_Comp trans_fun (xs \\<down> n) c)", "apply (rule subst[OF append_take_drop_id, of _ n xs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun (xs \\<down> n @ xs \\<up> n) c \\<up> n =\n    f_Exec_Comp_Stream trans_fun ((xs \\<down> n @ xs \\<up> n) \\<up> n)\n     (f_Exec_Comp trans_fun ((xs \\<down> n @ xs \\<up> n) \\<down> n) c)", "apply (simp add: f_Exec_Stream_append del: append_take_drop_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_nth: \"\n  i_Exec_Comp_Stream trans_fun input c n = f_Exec_Comp trans_fun (input \\<Down> Suc n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun input c n =\n    f_Exec_Comp trans_fun (input \\<Down> Suc n) c", "by (simp add: i_Exec_Comp_Stream_def)"], ["", "lemma i_Exec_Stream_nth_Suc: \"\n  i_Exec_Comp_Stream trans_fun input c (Suc n) =\n  trans_fun (input (Suc n)) (i_Exec_Comp_Stream trans_fun input c n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun input c (Suc n) =\n    trans_fun (input (Suc n)) (i_Exec_Comp_Stream trans_fun input c n)", "by (simp add: i_Exec_Stream_nth i_take_Suc_conv_app_nth f_Exec_append)"], ["", "lemma i_Exec_Stream_nth_Suc_first: \"\n  i_Exec_Comp_Stream trans_fun input c (Suc n) =\n  (i_Exec_Comp_Stream trans_fun (input \\<Up> Suc 0) (trans_fun (input 0) c) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun input c (Suc n) =\n    i_Exec_Comp_Stream trans_fun (input \\<Up> Suc 0) (trans_fun (input 0) c)\n     n", "by (simp add: i_Exec_Stream_nth i_take_Suc)"], ["", "lemma f_Exec_Stream_nth_eq_i_Exec_Stream_nth: \"\n  n < n' \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun (input \\<Down> n') c ! n =\n  i_Exec_Comp_Stream trans_fun input c n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < n' \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun (input \\<Down> n') c ! n =\n    i_Exec_Comp_Stream trans_fun input c n", "by (simp add: f_Exec_Stream_nth i_Exec_Stream_nth min_eqR)"], ["", "lemma i_Exec_Stream_append: \"\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (f_Exec_Comp trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n    f_Exec_Comp_Stream trans_fun xs c \\<frown>\n    i_Exec_Comp_Stream trans_fun input (f_Exec_Comp trans_fun xs c)", "by (simp add: ilist_eq_iff i_Exec_Stream_nth f_Exec_Stream_nth f_Exec_append i_append_nth Suc_diff_le)"], ["", "lemma i_Exec_Stream_append_last_Cons: \"\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (\n    last (c # f_Exec_Comp_Stream trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n    f_Exec_Comp_Stream trans_fun xs c \\<frown>\n    i_Exec_Comp_Stream trans_fun input\n     (last (c # f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: f_Exec_eq_f_Exec_Stream_last i_Exec_Stream_append)"], ["", "lemma i_Exec_Stream_append_last: \"\n  xs \\<noteq> [] \\<Longrightarrow>\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (\n    last (f_Exec_Comp_Stream trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n    f_Exec_Comp_Stream trans_fun xs c \\<frown>\n    i_Exec_Comp_Stream trans_fun input\n     (last (f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: f_Exec_Stream_empty_conv i_Exec_Stream_append_last_Cons)"], ["", "lemma i_Exec_Stream_append_if: \"\n  i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream trans_fun input (\n    if xs = [] then c\n    else last (f_Exec_Comp_Stream trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun (xs \\<frown> input) c =\n    f_Exec_Comp_Stream trans_fun xs c \\<frown>\n    i_Exec_Comp_Stream trans_fun input\n     (if xs = [] then c else last (f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: i_Exec_Stream_append_last)"], ["", "corollary i_Exec_Stream_Cons: \"\n  i_Exec_Comp_Stream trans_fun ([x] \\<frown> input) c =\n  [trans_fun x c] \\<frown> i_Exec_Comp_Stream trans_fun input (trans_fun x c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun ([x] \\<frown> input) c =\n    [trans_fun x c] \\<frown>\n    i_Exec_Comp_Stream trans_fun input (trans_fun x c)", "by (simp add: i_Exec_Stream_append)"], ["", "corollary i_Exec_Stream_Cons_rev: \"\n  [trans_fun (input 0) c] \\<frown>\n  i_Exec_Comp_Stream trans_fun (input \\<Up> Suc 0) (trans_fun (input 0) c) =\n  i_Exec_Comp_Stream trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [trans_fun (input 0) c] \\<frown>\n    i_Exec_Comp_Stream trans_fun (input \\<Up> Suc 0)\n     (trans_fun (input 0) c) =\n    i_Exec_Comp_Stream trans_fun input c", "apply (insert i_Exec_Stream_append[of trans_fun \"[input 0]\" \"input \\<Up> Suc 0\" c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun ([input 0] \\<frown> input \\<Up> Suc 0) c =\n    f_Exec_Comp_Stream trans_fun [input 0] c \\<frown>\n    i_Exec_Comp_Stream trans_fun (input \\<Up> Suc 0)\n     (f_Exec_Comp trans_fun [input 0] c) \\<Longrightarrow>\n    [trans_fun (input 0) c] \\<frown>\n    i_Exec_Comp_Stream trans_fun (input \\<Up> Suc 0)\n     (trans_fun (input 0) c) =\n    i_Exec_Comp_Stream trans_fun input c", "apply (simp add: i_drop_Suc_conv_tl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem i_Exec_Stream_take:\"\n  (i_Exec_Comp_Stream trans_fun input c) \\<Down> n =\n  f_Exec_Comp_Stream trans_fun (input \\<Down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun input c \\<Down> n =\n    f_Exec_Comp_Stream trans_fun (input \\<Down> n) c", "by (simp add: list_eq_iff f_Exec_Stream_nth i_Exec_Stream_nth min_eqR)"], ["", "theorem i_Exec_Stream_drop:\"\n  (i_Exec_Comp_Stream trans_fun input c) \\<Up> n =\n  i_Exec_Comp_Stream trans_fun (input \\<Up> n) (f_Exec_Comp trans_fun (input \\<Down> n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun input c \\<Up> n =\n    i_Exec_Comp_Stream trans_fun (input \\<Up> n)\n     (f_Exec_Comp trans_fun (input \\<Down> n) c)", "apply (rule subst[OF i_append_i_take_i_drop_id, of _ n input])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun (input \\<Down> n \\<frown> input \\<Up> n)\n     c \\<Up>\n    n =\n    i_Exec_Comp_Stream trans_fun\n     ((input \\<Down> n \\<frown> input \\<Up> n) \\<Up> n)\n     (f_Exec_Comp trans_fun\n       ((input \\<Down> n \\<frown> input \\<Up> n) \\<Down> n) c)", "apply (simp add: i_Exec_Stream_append  i_drop_def del: i_append_i_take_i_drop_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_expand_aggregate_map_take: \"\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag \\<down> n =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs \\<down> n) \\<odot>\\<^sub>f k) c)) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c)) k\n     ag \\<down>\n    n =\n    f_aggregate\n     (map f (f_Exec_Comp_Stream trans_fun (xs \\<down> n \\<odot> k) c)) k ag", "by (simp add: f_aggregate_take_mult[symmetric] take_map f_Exec_Stream_take f_expand_take_mult)"], ["", "corollary f_Exec_Stream_expand_aggregate_take: \"\n  f_aggregate (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c) k ag \\<down> n =\n  f_aggregate (f_Exec_Comp_Stream trans_fun ((xs \\<down> n) \\<odot>\\<^sub>f k) c) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_aggregate (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c) k ag \\<down>\n    n =\n    f_aggregate (f_Exec_Comp_Stream trans_fun (xs \\<down> n \\<odot> k) c) k\n     ag", "by (insert f_Exec_Stream_expand_aggregate_map_take[of n id trans_fun xs k c ag], simp add: map_id)"], ["", "lemma i_Exec_Stream_expand_aggregate_map_take: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag \\<Down> n =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c)) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_aggregate (f \\<circ> i_Exec_Comp_Stream trans_fun (input \\<odot> k) c)\n     k ag \\<Down>\n    n =\n    f_aggregate\n     (map f (f_Exec_Comp_Stream trans_fun (input \\<Down> n \\<odot> k) c)) k\n     ag", "by (simp add: i_aggregate_i_take_mult[symmetric] i_Exec_Stream_take i_expand_i_take_mult)"], ["", "corollary i_Exec_Stream_expand_aggregate_take: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c) k ag \\<Down> n =\n  f_aggregate (f_Exec_Comp_Stream trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot> k) c) k\n     ag \\<Down>\n    n =\n    f_aggregate (f_Exec_Comp_Stream trans_fun (input \\<Down> n \\<odot> k) c)\n     k ag", "by (drule i_Exec_Stream_expand_aggregate_map_take[of k n id trans_fun input c ag], simp add: map_id)"], ["", "lemma f_Exec_Stream_expand_aggregate_map_drop: \"\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag \\<up> n =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs \\<up> n) \\<odot>\\<^sub>f k) (\n    f_Exec_Comp trans_fun ((xs \\<down> n) \\<odot>\\<^sub>f k) c))) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c)) k\n     ag \\<up>\n    n =\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun (xs \\<up> n \\<odot> k)\n         (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k) c)))\n     k ag", "by (simp add: f_aggregate_drop_mult[symmetric] drop_map f_Exec_Stream_drop f_expand_take_mult f_expand_drop_mult)"], ["", "corollary f_Exec_Stream_expand_aggregate_drop: \"\n  f_aggregate (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c) k ag \\<up> n =\n  f_aggregate (f_Exec_Comp_Stream trans_fun ((xs \\<up> n) \\<odot>\\<^sub>f k) (\n    f_Exec_Comp trans_fun ((xs \\<down> n) \\<odot>\\<^sub>f k) c)) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_aggregate (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c) k ag \\<up>\n    n =\n    f_aggregate\n     (f_Exec_Comp_Stream trans_fun (xs \\<up> n \\<odot> k)\n       (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k) c))\n     k ag", "by (insert f_Exec_Stream_expand_aggregate_map_drop[of n id trans_fun xs k c ag], simp add: map_id)"], ["", "lemma i_Exec_Stream_expand_aggregate_map_drop: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag \\<Up> n =\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun ((input \\<Up> n) \\<odot>\\<^sub>i k) (\n    f_Exec_Comp trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c))) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_aggregate (f \\<circ> i_Exec_Comp_Stream trans_fun (input \\<odot> k) c)\n     k ag \\<Up>\n    n =\n    i_aggregate\n     (f \\<circ>\n      i_Exec_Comp_Stream trans_fun (input \\<Up> n \\<odot> k)\n       (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c))\n     k ag", "by (simp add: i_aggregate_i_drop_mult[symmetric] i_Exec_Stream_drop i_expand_i_take_mult i_expand_i_drop_mult)"], ["", "corollary i_Exec_Stream_expand_aggregate_drop: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c) k ag \\<Up> n =\n  i_aggregate (i_Exec_Comp_Stream trans_fun ((input \\<Up> n) \\<odot>\\<^sub>i k) (\n    f_Exec_Comp trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c)) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot> k) c) k\n     ag \\<Up>\n    n =\n    i_aggregate\n     (i_Exec_Comp_Stream trans_fun (input \\<Up> n \\<odot> k)\n       (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c))\n     k ag", "by (drule i_Exec_Stream_expand_aggregate_map_drop[of k n id trans_fun input c ag], simp)"], ["", "lemma f_Exec_Stream_expand_aggregate_map_nth_eq_i_nth: \"\n  \\<lbrakk> 0 < k; n < n' \\<rbrakk> \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (input \\<Down> n' \\<odot>\\<^sub>f k) c)) k ag ! n =\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < n'\\<rbrakk>\n    \\<Longrightarrow> f_aggregate\n                       (map f\n                         (f_Exec_Comp_Stream trans_fun\n                           (input \\<Down> n' \\<odot> k) c))\n                       k ag !\n                      n =\n                      i_aggregate\n                       (f \\<circ>\n                        i_Exec_Comp_Stream trans_fun (input \\<odot> k) c)\n                       k ag n", "apply (simp add: f_aggregate_nth i_aggregate_nth f_Exec_Stream_take f_Exec_Stream_drop i_Exec_Stream_take i_Exec_Stream_drop drop_map take_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < n'\\<rbrakk>\n    \\<Longrightarrow> ag (map f\n                           (f_Exec_Comp_Stream trans_fun\n                             (input \\<Down> n' \\<odot> k \\<up>\n                              (n * k) \\<down>\n                              k)\n                             (f_Exec_Comp trans_fun\n                               (input \\<Down> n' \\<odot> k \\<down> (n * k))\n                               c))) =\n                      ag (map f\n                           (f_Exec_Comp_Stream trans_fun\n                             (input \\<odot> k \\<Up> (n * k) \\<Down> k)\n                             (f_Exec_Comp trans_fun\n                               (input \\<odot> k \\<Down> (n * k)) c)))", "apply (simp add: f_expand_take_mod i_expand_i_take_mod f_expand_drop_mod i_expand_i_drop_mod i_drop_i_take_1 drop_take_1 min_eqR)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Exec_Stream_expand_aggregate_map_nth_eq_i_nth': \"\n  0 < k \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (input \\<Down> Suc n \\<odot>\\<^sub>f k) c)) k ag ! n =\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun (input \\<Down> Suc n \\<odot> k) c))\n     k ag !\n    n =\n    i_aggregate (f \\<circ> i_Exec_Comp_Stream trans_fun (input \\<odot> k) c)\n     k ag n", "by (simp add: f_Exec_Stream_expand_aggregate_map_nth_eq_i_nth)"], ["", "corollary f_Exec_Stream_expand_aggregate_nth_eq_i_nth: \"\n  \\<lbrakk> 0 < k; n < n' \\<rbrakk> \\<Longrightarrow>\n  f_aggregate (f_Exec_Comp_Stream trans_fun (input \\<Down> n' \\<odot>\\<^sub>f k) c) k ag ! n =\n  i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c) k ag n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < n'\\<rbrakk>\n    \\<Longrightarrow> f_aggregate\n                       (f_Exec_Comp_Stream trans_fun\n                         (input \\<Down> n' \\<odot> k) c)\n                       k ag !\n                      n =\n                      i_aggregate\n                       (i_Exec_Comp_Stream trans_fun (input \\<odot> k) c) k\n                       ag n", "by (drule f_Exec_Stream_expand_aggregate_map_nth_eq_i_nth[where f=id], simp_all add: map_id)"], ["", "corollary f_Exec_Stream_expand_aggregate_nth_eq_i_nth': \"\n  0 < k \\<Longrightarrow>\n  f_aggregate (f_Exec_Comp_Stream trans_fun (input \\<Down> Suc n \\<odot>\\<^sub>f k) c) k ag ! n =\n  i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c) k ag n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate\n     (f_Exec_Comp_Stream trans_fun (input \\<Down> Suc n \\<odot> k) c) k ag !\n    n =\n    i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot> k) c) k ag n", "by (simp add: f_Exec_Stream_expand_aggregate_nth_eq_i_nth)"], ["", "lemma f_Exec_Stream_expand_shrink_last_map_nth_eq_f_Exec_Comp: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c) \\<div>\\<^bsub>fl\\<^esub> k ! n =\n  f (f_Exec_Comp trans_fun ((xs \\<down> Suc n) \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> map f\n                       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n                         c) \\<div>\\<^sub>l\n                      k !\n                      n =\n                      f (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                          c)", "apply (simp add: f_shrink_last_map f_shrink_last_length f_shrink_last_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c !\n                         (n * k + k - Suc 0)) =\n                      f (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                          c)", "apply (subgoal_tac \"n * k + k - Suc 0 < length xs * k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; n < length xs;\n     n * k + k - Suc 0 < length xs * k\\<rbrakk>\n    \\<Longrightarrow> f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c !\n                         (n * k + k - Suc 0)) =\n                      f (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                          c)\n 2. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> n * k + k - Suc 0 < length xs * k", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> n * k + k - Suc 0 < length xs * k\n 2. \\<lbrakk>0 < k; n < length xs;\n     n * k + k - Suc 0 < length xs * k\\<rbrakk>\n    \\<Longrightarrow> f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c !\n                         (n * k + k - Suc 0)) =\n                      f (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                          c)", "apply (drule Suc_leI[of n])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; Suc n \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> n * k + k - Suc 0 < length xs * k\n 2. \\<lbrakk>0 < k; n < length xs;\n     n * k + k - Suc 0 < length xs * k\\<rbrakk>\n    \\<Longrightarrow> f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c !\n                         (n * k + k - Suc 0)) =\n                      f (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                          c)", "apply (drule mult_le_mono1[of _ _ k], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs;\n     n * k + k - Suc 0 < length xs * k\\<rbrakk>\n    \\<Longrightarrow> f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c !\n                         (n * k + k - Suc 0)) =\n                      f (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                          c)", "apply (simp add: f_Exec_Stream_nth add.commute[of k] f_expand_take_mult[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Exec_Stream_expand_shrink_last_nth_eq_f_Exec_Comp: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c \\<div>\\<^bsub>fl\\<^esub> k ! n =\n  f_Exec_Comp trans_fun ((xs \\<down> Suc n) \\<odot>\\<^sub>f k) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n                       c \\<div>\\<^sub>l\n                      k !\n                      n =\n                      f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c", "by (drule f_Exec_Stream_expand_shrink_last_map_nth_eq_f_Exec_Comp[where f=id], simp_all add: map_id)"], ["", "lemma f_Exec_Stream_expand_aggregate_map_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag ! n =\n  ag (map f (f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f_aggregate\n                       (map f\n                         (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c))\n                       k ag !\n                      n =\n                      ag (map f\n                           (f_Exec_Comp_Stream trans_fun\n                             (xs ! n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                               c)))", "apply (simp add: f_aggregate_nth take_map drop_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> ag (map f\n                           (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n                             c \\<up>\n                            (n * k) \\<down>\n                            k)) =\n                      ag (f (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> k) c)) #\n                          map f\n                           (f_Exec_Comp_Stream trans_fun\n                             NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                             (trans_fun (xs ! n)\n                               (f_Exec_Comp trans_fun\n                                 (xs \\<down> n \\<odot> k) c))))", "apply (simp add: take_map drop_map f_Exec_Stream_drop f_Exec_Stream_take f_expand_take_mod f_expand_drop_mod drop_take_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Exec_Stream_expand_aggregate_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_aggregate (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c) k ag ! n =\n  ag (f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f_aggregate\n                       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c) k\n                       ag !\n                      n =\n                      ag (f_Exec_Comp_Stream trans_fun\n                           (xs ! n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                             c))", "by (drule f_Exec_Stream_expand_aggregate_map_nth[where f=id], simp_all add: map_id)"], ["", "corollary f_Exec_Stream_expand_shrink_map_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) \\<div>\\<^sub>f k ! n =\n  last_message (map f (f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> map f\n                       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n                         c) \\<div>\n                      k !\n                      n =\n                      last_message\n                       (map f\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                             c)))", "by (simp add: f_shrink_def f_Exec_Stream_expand_aggregate_map_nth)"], ["", "lemma i_Exec_Stream_expand_aggregate_map_nth: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) k ag n =\n  ag (map f (f_Exec_Comp_Stream trans_fun (input n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_aggregate (f \\<circ> i_Exec_Comp_Stream trans_fun (input \\<odot> k) c)\n     k ag n =\n    ag (map f\n         (f_Exec_Comp_Stream trans_fun\n           (input n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n           (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c)))", "by (simp add: i_aggregate_nth i_Exec_Stream_drop i_Exec_Stream_take i_expand_i_take_mod i_expand_i_drop_mod i_drop_i_take_1)"], ["", "corollary i_Exec_Stream_expand_aggregate_nth: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c) k ag n =\n  ag (f_Exec_Comp_Stream trans_fun (input n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun ((input \\<Down> n) \\<odot>\\<^sub>f k) c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_aggregate (i_Exec_Comp_Stream trans_fun (input \\<odot> k) c) k ag n =\n    ag (f_Exec_Comp_Stream trans_fun\n         (input n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c))", "by (drule i_Exec_Stream_expand_aggregate_map_nth[where f=id], simp add: map_id)"], ["", "corollary i_Exec_Stream_expand_shrink_map_nth: \"\n  0 < k \\<Longrightarrow>\n  ((f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) \\<div>\\<^sub>i k) n =\n  last_message (map f (f_Exec_Comp_Stream trans_fun (input n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (input \\<Down> n \\<odot>\\<^sub>f k) c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    ((f \\<circ> i_Exec_Comp_Stream trans_fun (input \\<odot> k) c) \\<div> k)\n     n =\n    last_message\n     (map f\n       (f_Exec_Comp_Stream trans_fun\n         (input n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c)))", "by (simp add: i_shrink_def i_Exec_Stream_expand_aggregate_map_nth)"], ["", "lemma f_Exec_Stream_expand_snoc: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c \\<up> (n * k) \\<down> k =\n  f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c \\<up>\n                      (n * k) \\<down>\n                      k =\n                      f_Exec_Comp_Stream trans_fun\n                       (xs ! n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                       (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k) c)", "by (simp add: f_Exec_Stream_drop f_Exec_Stream_take f_expand_take_mod f_expand_drop_mod drop_take_1)"], ["", "lemma f_Exec_Stream_expand_map_aggregate_append: \"\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs @ ys) \\<odot>\\<^sub>f k) c)) k ag =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag @\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (ys \\<odot>\\<^sub>f k) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c))) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_aggregate\n     (map f (f_Exec_Comp_Stream trans_fun ((xs @ ys) \\<odot> k) c)) k ag =\n    f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c)) k\n     ag @\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun (ys \\<odot> k)\n         (f_Exec_Comp trans_fun (xs \\<odot> k) c)))\n     k ag", "by (simp add: f_Exec_Stream_append f_aggregate_append_mod)"], ["", "lemma i_Exec_Stream_expand_map_aggregate_append: \"\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun ((xs \\<frown> input) \\<odot>\\<^sub>i k) c)) k ag =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag \\<frown>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c))) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_aggregate\n     (f \\<circ>\n      i_Exec_Comp_Stream trans_fun ((xs \\<frown> input) \\<odot> k) c)\n     k ag =\n    f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c)) k\n     ag \\<frown>\n    i_aggregate\n     (f \\<circ>\n      i_Exec_Comp_Stream trans_fun (input \\<odot> k)\n       (f_Exec_Comp trans_fun (xs \\<odot> k) c))\n     k ag", "by (simp add: i_expand_i_append i_Exec_Stream_append i_aggregate_i_append_mod)"], ["", "lemma f_Exec_Stream_expand_map_aggregate_Cons: \"\n  0 < k \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((x # xs) \\<odot>\\<^sub>f k) c)) k ag =\n  ag (map f (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)) #\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate\n     (map f (f_Exec_Comp_Stream trans_fun ((x # xs) \\<odot> k) c)) k ag =\n    ag (map f\n         (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n           c)) #\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n         (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\n     k ag", "apply (subst append_eq_Cons[of x xs, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate\n     (map f (f_Exec_Comp_Stream trans_fun (([x] @ xs) \\<odot> k) c)) k ag =\n    ag (map f\n         (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n           c)) #\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n         (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\n     k ag", "apply (subst f_Exec_Stream_expand_map_aggregate_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate (map f (f_Exec_Comp_Stream trans_fun ([x] \\<odot> k) c)) k\n     ag @\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n         (f_Exec_Comp trans_fun ([x] \\<odot> k) c)))\n     k ag =\n    ag (map f\n         (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n           c)) #\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n         (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\n     k ag", "apply (simp add: f_aggregate_one)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_expand_map_aggregate_snoc: \"\n  0 < k \\<Longrightarrow>\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun ((xs @ [x]) \\<odot>\\<^sub>f k) c)) k ag =\n  f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) k ag @\n  [ag (map f (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate\n     (map f (f_Exec_Comp_Stream trans_fun ((xs @ [x]) \\<odot> k) c)) k ag =\n    f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c)) k\n     ag @\n    [ag (map f\n          (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n            (f_Exec_Comp trans_fun (xs \\<odot> k) c)))]", "apply (subst f_Exec_Stream_expand_map_aggregate_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c)) k\n     ag @\n    f_aggregate\n     (map f\n       (f_Exec_Comp_Stream trans_fun ([x] \\<odot> k)\n         (f_Exec_Comp trans_fun (xs \\<odot> k) c)))\n     k ag =\n    f_aggregate (map f (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c)) k\n     ag @\n    [ag (map f\n          (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n            (f_Exec_Comp trans_fun (xs \\<odot> k) c)))]", "apply (simp add: f_aggregate_one)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_expand_map_aggregate_Cons: \"\n  0 < k \\<Longrightarrow>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (([x] \\<frown> input) \\<odot>\\<^sub>i k) c)) k ag =\n  [ag (map f (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))] \\<frown>\n  i_aggregate (f \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))) k ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_aggregate\n     (f \\<circ>\n      i_Exec_Comp_Stream trans_fun (([x] \\<frown> input) \\<odot> k) c)\n     k ag =\n    [ag (map f\n          (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n            c))] \\<frown>\n    i_aggregate\n     (f \\<circ>\n      i_Exec_Comp_Stream trans_fun (input \\<odot> k)\n       (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\n     k ag", "apply (subst i_Exec_Stream_expand_map_aggregate_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_aggregate (map f (f_Exec_Comp_Stream trans_fun ([x] \\<odot> k) c)) k\n     ag \\<frown>\n    i_aggregate\n     (f \\<circ>\n      i_Exec_Comp_Stream trans_fun (input \\<odot> k)\n       (f_Exec_Comp trans_fun ([x] \\<odot> k) c))\n     k ag =\n    [ag (map f\n          (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n            c))] \\<frown>\n    i_aggregate\n     (f \\<circ>\n      i_Exec_Comp_Stream trans_fun (input \\<odot> k)\n       (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\n     k ag", "apply (simp add: f_aggregate_one)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_N_eq_f_Exec_Stream_nth:\"\n  n \\<le> length xs \\<Longrightarrow>\n  f_Exec_Comp_N trans_fun n xs c = (c # f_Exec_Comp_Stream trans_fun xs c) ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    f_Exec_Comp_N trans_fun n xs c =\n    (c # f_Exec_Comp_Stream trans_fun xs c) ! n", "by (simp add: f_Exec_Comp_N_def f_Exec_Stream_nth2)"], ["", "theorem f_Exec_Stream_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  (f_Exec_Comp_Stream trans_fun xs c) \\<down> n = (f_Exec_Comp_Stream trans_fun ys c) \\<down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun xs c \\<down> n =\n    f_Exec_Comp_Stream trans_fun ys c \\<down> n", "by (simp add: f_Exec_Stream_take)"], ["", "theorem i_Exec_Stream_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  (i_Exec_Comp_Stream trans_fun input1 c) \\<Down> n = (i_Exec_Comp_Stream trans_fun input2 c) \\<Down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n    i_Exec_Comp_Stream trans_fun input1 c \\<Down> n =\n    i_Exec_Comp_Stream trans_fun input2 c \\<Down> n", "by (simp add: i_Exec_Stream_take)"], ["", "text \\<open>Results for \\<open>f_Exec_Comp_Stream_Init\\<close>\\<close>"], ["", "text \\<open>\n  \\<open>f_Exec_Comp_Stream_Init\\<close> computes the execution stream of a component\n  with the initial value of the component\n  at the beginning of the result stream.\\<close>"], ["", "lemma f_Exec_Stream_Init_length[rule_format, simp]:\"\n  \\<forall>c. length (f_Exec_Comp_Stream_Init trans_fun xs c) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       length (f_Exec_Comp_Stream_Init trans_fun xs c) = Suc (length xs)", "by (induct xs, simp_all)"], ["", "lemma f_Exec_Stream_Init_not_empty:\"\n  (f_Exec_Comp_Stream_Init trans_fun xs c \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun xs c \\<noteq> []", "by (simp add: length_0_conv[symmetric] del: length_0_conv)"], ["", "lemma f_Exec_eq_f_Exec_Stream_Init_last[rule_format]:\"\n  \\<forall>c. f_Exec_Comp trans_fun xs c = last (f_Exec_Comp_Stream_Init trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       f_Exec_Comp trans_fun xs c =\n       last (f_Exec_Comp_Stream_Init trans_fun xs c)", "by (induct xs, simp_all add: f_Exec_Stream_Init_not_empty)"], ["", "lemma f_Exec_Stream_Init_eq_f_Exec_Stream_Cons[rule_format]: \"\n  \\<forall>c. f_Exec_Comp_Stream_Init trans_fun xs c = c # f_Exec_Comp_Stream trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       f_Exec_Comp_Stream_Init trans_fun xs c =\n       c # f_Exec_Comp_Stream trans_fun xs c", "by (induct xs, simp_all)"], ["", "corollary f_Exec_Stream_Init_eq_f_Exec_Stream_Cons_output: \"\n  output_fun c = \\<NoMsg> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c) =\n  \\<NoMsg> # map output_fun (f_Exec_Comp_Stream trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_fun c = NoMsg \\<Longrightarrow>\n    map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c) =\n    NoMsg # map output_fun (f_Exec_Comp_Stream trans_fun xs c)", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["", "corollary f_Exec_Stream_Init_tl_eq_f_Exec_Stream: \"\n  tl (f_Exec_Comp_Stream_Init trans_fun xs c) = f_Exec_Comp_Stream trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (f_Exec_Comp_Stream_Init trans_fun xs c) =\n    f_Exec_Comp_Stream trans_fun xs c", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["", "lemma f_Exec_N_eq_last_f_Exec_Stream_Init_take:\"\n  f_Exec_Comp_N trans_fun n xs c =\n  last (f_Exec_Comp_Stream_Init trans_fun (xs \\<down> n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_N trans_fun n xs c =\n    last (f_Exec_Comp_Stream_Init trans_fun (xs \\<down> n) c)", "by (simp add: f_Exec_Comp_N_def f_Exec_eq_f_Exec_Stream_Init_last)"], ["", "lemma f_Exec_Stream_Init_nth: \"\n  n \\<le> length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! n = f_Exec_Comp trans_fun (xs \\<down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c ! n =\n    f_Exec_Comp trans_fun (xs \\<down> n) c", "apply (subst f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    (c # f_Exec_Comp_Stream trans_fun xs c) ! n =\n    f_Exec_Comp trans_fun (xs \\<down> n) c", "apply (case_tac n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>n \\<le> length xs; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (c # f_Exec_Comp_Stream trans_fun xs c) ! n =\n                         f_Exec_Comp trans_fun (xs \\<down> n) c", "apply (simp add: f_Exec_Stream_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Init_nth_0: \"f_Exec_Comp_Stream_Init trans_fun xs c ! 0 = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun xs c ! 0 = c", "by (simp add: f_Exec_Stream_Init_nth)"], ["", "lemma f_Exec_Stream_Init_hd: \"hd (f_Exec_Comp_Stream_Init trans_fun xs c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (f_Exec_Comp_Stream_Init trans_fun xs c) = c", "by (simp add: hd_conv_nth f_Exec_Stream_Init_not_empty f_Exec_Stream_Init_nth_0)"], ["", "lemma f_Exec_Stream_Init_nth_Suc_eq_f_Exec_Stream_nth: \"\n  f_Exec_Comp_Stream_Init trans_fun xs c ! (Suc n) = f_Exec_Comp_Stream trans_fun xs c ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n =\n    f_Exec_Comp_Stream trans_fun xs c ! n", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["", "lemma f_Exec_Stream_Init_append:\"\n  f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream_Init trans_fun xs c) @\n    tl (f_Exec_Comp_Stream_Init trans_fun ys (f_Exec_Comp trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream_Init trans_fun xs c @\n    tl (f_Exec_Comp_Stream_Init trans_fun ys (f_Exec_Comp trans_fun xs c))", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons f_Exec_Stream_append)"], ["", "corollary f_Exec_Stream_Init_append_last:\"\n  f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream_Init trans_fun xs c) @\n    tl (f_Exec_Comp_Stream_Init trans_fun ys (last (f_Exec_Comp_Stream_Init trans_fun xs c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream_Init trans_fun xs c @\n    tl (f_Exec_Comp_Stream_Init trans_fun ys\n         (last (f_Exec_Comp_Stream_Init trans_fun xs c)))", "by (simp add: f_Exec_Stream_Init_append f_Exec_eq_f_Exec_Stream_Init_last)"], ["", "lemma f_Exec_Stream_Init_f_Exec_Stream_append:\"\n  f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    (f_Exec_Comp_Stream_Init trans_fun xs c) @\n    (f_Exec_Comp_Stream trans_fun ys (f_Exec_Comp trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream_Init trans_fun xs c @\n    f_Exec_Comp_Stream trans_fun ys (f_Exec_Comp trans_fun xs c)", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons f_Exec_Stream_append)"], ["", "lemma f_Exec_Stream_Init_take:\"\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<down> Suc n =\n  f_Exec_Comp_Stream_Init trans_fun (xs \\<down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun xs c \\<down> Suc n =\n    f_Exec_Comp_Stream_Init trans_fun (xs \\<down> n) c", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons f_Exec_Stream_take)"], ["", "lemma f_Exec_Stream_Init_drop:\"\n  n \\<le> length xs \\<Longrightarrow>\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<up> n =\n  f_Exec_Comp_Stream_Init trans_fun (xs \\<up> n)\n    (f_Exec_Comp trans_fun (xs \\<down> n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c \\<up> n =\n    f_Exec_Comp_Stream_Init trans_fun (xs \\<up> n)\n     (f_Exec_Comp trans_fun (xs \\<down> n) c)", "apply (case_tac n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>n \\<le> length xs; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Init trans_fun xs c \\<up> n =\n                         f_Exec_Comp_Stream_Init trans_fun (xs \\<up> n)\n                          (f_Exec_Comp trans_fun (xs \\<down> n) c)", "apply (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons f_Exec_Stream_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length xs; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream trans_fun (xs \\<up> nat)\n                          (f_Exec_Comp trans_fun (xs \\<down> nat) c) =\n                         f_Exec_Comp trans_fun (xs \\<down> Suc nat) c #\n                         f_Exec_Comp_Stream trans_fun (xs \\<up> Suc nat)\n                          (f_Exec_Comp trans_fun (xs \\<down> Suc nat) c)", "apply (simp add: take_Suc_conv_app_nth f_Exec_append Cons_nth_drop_Suc[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Init_drop_geq_not_valid:\"\n  length xs \\<le> n \\<Longrightarrow>\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<up> Suc n \\<noteq>\n  f_Exec_Comp_Stream_Init trans_fun arbitrary_input arbitrary_comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c \\<up> Suc n \\<noteq>\n    f_Exec_Comp_Stream_Init trans_fun arbitrary_input arbitrary_comp", "by (simp add: f_Exec_Stream_Init_not_empty[symmetric])"], ["", "lemma i_Exec_Stream_Init_nth: \"\n  i_Exec_Comp_Stream_Init trans_fun input c n = f_Exec_Comp trans_fun (input \\<Down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c n =\n    f_Exec_Comp trans_fun (input \\<Down> n) c", "by (simp add: i_Exec_Comp_Stream_Init_def)"], ["", "lemma i_Exec_Stream_Init_nth_0: \"\n  i_Exec_Comp_Stream_Init trans_fun input c 0 = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c 0 = c", "by (simp add: i_Exec_Stream_Init_nth)"], ["", "lemma i_Exec_Stream_Init_nth_Suc_eq_i_Exec_Stream_nth: \"\n  i_Exec_Comp_Stream_Init trans_fun input c (Suc n) = i_Exec_Comp_Stream trans_fun input c n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c (Suc n) =\n    i_Exec_Comp_Stream trans_fun input c n", "by (simp add: i_Exec_Stream_Init_nth i_Exec_Stream_nth)"], ["", "lemma i_Exec_Stream_Init_eq_i_Exec_Stream_Cons: \"\n  i_Exec_Comp_Stream_Init trans_fun input c = [c] \\<frown> i_Exec_Comp_Stream trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c =\n    [c] \\<frown> i_Exec_Comp_Stream trans_fun input c", "by (simp add: ilist_eq_iff i_Exec_Stream_Init_nth i_append_nth i_Exec_Stream_nth)"], ["", "corollary i_Exec_Stream_Init_eq_i_Exec_Stream_Cons_output: \"\n  output_fun c = \\<NoMsg> \\<Longrightarrow>\n  output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input c =\n  [\\<NoMsg>] \\<frown> (output_fun \\<circ> i_Exec_Comp_Stream trans_fun input c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_fun c = NoMsg \\<Longrightarrow>\n    output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input c =\n    [NoMsg] \\<frown>\n    (output_fun \\<circ> i_Exec_Comp_Stream trans_fun input c)", "by (simp add: i_Exec_Stream_Init_eq_i_Exec_Stream_Cons)"], ["", "lemma i_Exec_Stream_Init_append:\"\n  i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    (f_Exec_Comp_Stream_Init trans_fun input1 c) \\<frown>\n    ((i_Exec_Comp_Stream_Init trans_fun input2 (f_Exec_Comp trans_fun input1 c)) \\<Up> Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    f_Exec_Comp_Stream_Init trans_fun input1 c \\<frown>\n    i_Exec_Comp_Stream_Init trans_fun input2\n     (f_Exec_Comp trans_fun input1 c) \\<Up>\n    Suc 0", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons i_Exec_Stream_Init_eq_i_Exec_Stream_Cons i_Exec_Stream_append)"], ["", "corollary i_Exec_Stream_Init_append_last:\"\n  i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    (f_Exec_Comp_Stream_Init trans_fun input1 c) \\<frown>\n    ((i_Exec_Comp_Stream_Init trans_fun input2 (last (f_Exec_Comp_Stream_Init trans_fun input1 c))) \\<Up> Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    f_Exec_Comp_Stream_Init trans_fun input1 c \\<frown>\n    i_Exec_Comp_Stream_Init trans_fun input2\n     (last (f_Exec_Comp_Stream_Init trans_fun input1 c)) \\<Up>\n    Suc 0", "by (simp add: i_Exec_Stream_Init_append f_Exec_eq_f_Exec_Stream_Init_last)"], ["", "lemma i_Exec_Stream_Init_i_Exec_Stream_append:\"\n  i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    (f_Exec_Comp_Stream_Init trans_fun input1 c) \\<frown>\n    (i_Exec_Comp_Stream trans_fun input2 (f_Exec_Comp trans_fun input1 c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun (input1 \\<frown> input2) c =\n    f_Exec_Comp_Stream_Init trans_fun input1 c \\<frown>\n    i_Exec_Comp_Stream trans_fun input2 (f_Exec_Comp trans_fun input1 c)", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons i_Exec_Stream_Init_eq_i_Exec_Stream_Cons i_Exec_Stream_append)"], ["", "lemma i_Exec_Stream_Init_take:\"\n  (i_Exec_Comp_Stream_Init trans_fun input c) \\<Down> Suc n =\n  f_Exec_Comp_Stream_Init trans_fun (input \\<Down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c \\<Down> Suc n =\n    f_Exec_Comp_Stream_Init trans_fun (input \\<Down> n) c", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons i_Exec_Stream_Init_eq_i_Exec_Stream_Cons i_Exec_Stream_take)"], ["", "lemma i_Exec_Stream_Init_drop:\"\n  (i_Exec_Comp_Stream_Init trans_fun input c) \\<Up> n =\n  i_Exec_Comp_Stream_Init trans_fun (input \\<Up> n)\n    (f_Exec_Comp trans_fun (input \\<Down> n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c \\<Up> n =\n    i_Exec_Comp_Stream_Init trans_fun (input \\<Up> n)\n     (f_Exec_Comp trans_fun (input \\<Down> n) c)", "apply (case_tac n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       i_Exec_Comp_Stream_Init trans_fun input c \\<Up> n =\n       i_Exec_Comp_Stream_Init trans_fun (input \\<Up> n)\n        (f_Exec_Comp trans_fun (input \\<Down> n) c)", "apply (simp add: i_Exec_Stream_Init_eq_i_Exec_Stream_Cons i_Exec_Stream_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       i_Exec_Comp_Stream trans_fun (input \\<Up> nat)\n        (f_Exec_Comp trans_fun (input \\<Down> nat) c) =\n       [f_Exec_Comp trans_fun (input \\<Down> Suc nat) c] \\<frown>\n       i_Exec_Comp_Stream trans_fun (input \\<Up> Suc nat)\n        (f_Exec_Comp trans_fun (input \\<Down> Suc nat) c)", "apply (simp add: ilist_eq_iff i_take_Suc_conv_app_nth f_Exec_append i_Exec_Stream_nth i_append_nth i_take_first i_take_drop_eq_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<forall>x>0.\n          trans_fun (input (nat + x))\n           (f_Exec_Comp trans_fun (map input [nat..<nat + x])\n             (f_Exec_Comp trans_fun (input \\<Down> nat) c)) =\n          trans_fun (input (nat + x))\n           (f_Exec_Comp trans_fun (map input [Suc nat..<nat + x])\n             (trans_fun (input nat)\n               (f_Exec_Comp trans_fun (input \\<Down> nat) c)))", "apply (simp add: upt_conv_Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem f_Exec_Stream_Init_strictly_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  (f_Exec_Comp_Stream_Init trans_fun xs c) \\<down> Suc n = (f_Exec_Comp_Stream_Init trans_fun ys c) \\<down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c \\<down> Suc n =\n    f_Exec_Comp_Stream_Init trans_fun ys c \\<down> Suc n", "by (simp add: f_Exec_Stream_Init_take)"], ["", "theorem i_Exec_Stream_Init_strictly_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  (i_Exec_Comp_Stream_Init trans_fun input1 c) \\<Down> Suc n = (i_Exec_Comp_Stream_Init trans_fun input2 c) \\<Down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n    i_Exec_Comp_Stream_Init trans_fun input1 c \\<Down> Suc n =\n    i_Exec_Comp_Stream_Init trans_fun input2 c \\<Down> Suc n", "by (simp add: i_Exec_Stream_Init_take)"], ["", "theorem f_Exec_N_eq_f_Exec_Stream_Init_nth:\"\n  n \\<le> length xs \\<Longrightarrow>\n  f_Exec_Comp_N trans_fun n xs c = f_Exec_Comp_Stream_Init trans_fun xs c ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    f_Exec_Comp_N trans_fun n xs c =\n    f_Exec_Comp_Stream_Init trans_fun xs c ! n", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons f_Exec_N_eq_f_Exec_Stream_nth)"], ["", "text \\<open>Basic results for previous element functions\\<close>"], ["", "text \\<open>\n  The functions \\<open>list_Previous\\<close> and \\<open>ilist_Previous\\<close>\n  return the previous element of the list relatively to the specified position @{term n}\n  or the initial element if @{term n} is 0,\\<close>"], ["", "definition list_Previous :: \"'value list \\<Rightarrow> 'value \\<Rightarrow> nat \\<Rightarrow> 'value\"\n  where \"list_Previous xs init n \\<equiv>\n    case n of\n      0 \\<Rightarrow> init\n    | Suc n' \\<Rightarrow> xs ! n'\""], ["", "definition ilist_Previous :: \"'value ilist \\<Rightarrow> 'value \\<Rightarrow> nat \\<Rightarrow> 'value\"\n  where \"ilist_Previous f init n \\<equiv>\n    case n of\n      0 \\<Rightarrow> init\n    | Suc n' \\<Rightarrow> f n'\""], ["", "abbreviation \"list_Previous'\" :: \"'value list \\<Rightarrow> 'value \\<Rightarrow> nat \\<Rightarrow> 'value\"\n    ( \"_\\<^bsup>\\<leftarrow>'' _\\<^esup> _\" [1000, 10, 100] 100)\n  where \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> n \\<equiv> list_Previous xs init n\""], ["", "abbreviation \"ilist_Previous'\" :: \"'value ilist \\<Rightarrow> 'value \\<Rightarrow> nat \\<Rightarrow> 'value\"\n    ( \"_\\<^bsup>\\<leftarrow> _\\<^esup> _\" [1000, 10, 100] 100)\n  where \"f\\<^bsup>\\<leftarrow> init\\<^esup> n \\<equiv> ilist_Previous f init n\""], ["", "lemma list_Previous_nth: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = (case n of 0 \\<Rightarrow> init | Suc n' \\<Rightarrow> xs ! n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs\\<^bsup>\\<leftarrow>' init\\<^esup> n =\n    (case n of 0 \\<Rightarrow> init | Suc n' \\<Rightarrow> xs ! n')", "by (simp add: list_Previous_def)"], ["", "lemma ilist_Previous_nth: \"f\\<^bsup>\\<leftarrow> init\\<^esup> n = (case n of 0 \\<Rightarrow> init | Suc n' \\<Rightarrow> f n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^bsup>\\<leftarrow> init\\<^esup> n =\n    (case n of 0 \\<Rightarrow> init | Suc n' \\<Rightarrow> f n')", "by (simp add: ilist_Previous_def)"], ["", "lemma list_Previous_nth_if: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = (if n = 0 then init else xs ! (n - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs\\<^bsup>\\<leftarrow>' init\\<^esup> n =\n    (if n = 0 then init else xs ! (n - Suc 0))", "by (case_tac n, simp_all add: list_Previous_nth)"], ["", "lemma ilist_Previous_nth_if: \"f\\<^bsup>\\<leftarrow> init\\<^esup> n = (if n = 0 then init else f (n - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^bsup>\\<leftarrow> init\\<^esup> n =\n    (if n = 0 then init else f (n - Suc 0))", "by (case_tac n, simp_all add: ilist_Previous_nth)"], ["", "lemma list_Previous_Cons: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = (init # xs) ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = (init # xs) ! n", "by (case_tac n, simp_all add: list_Previous_nth)"], ["", "lemma ilist_Previous_Cons: \"f\\<^bsup>\\<leftarrow> init\\<^esup> n = ([init] \\<frown> f) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^bsup>\\<leftarrow> init\\<^esup> n = ([init] \\<frown> f) n", "by (case_tac n, simp_all add: ilist_Previous_nth)"], ["", "lemma list_Previous_0: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> 0 = init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs\\<^bsup>\\<leftarrow>' init\\<^esup> 0 = init", "by (simp add: list_Previous_def)"], ["", "lemma ilist_Previous_0: \"f\\<^bsup>\\<leftarrow> init\\<^esup> 0 = init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^bsup>\\<leftarrow> init\\<^esup> 0 = init", "by (simp add: ilist_Previous_def)"], ["", "lemma list_Previous_gr0: \"0 < n \\<Longrightarrow> xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = xs ! (n - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    xs\\<^bsup>\\<leftarrow>' init\\<^esup> n = xs ! (n - Suc 0)", "by (case_tac n, simp_all add: list_Previous_nth)"], ["", "lemma ilist_Previous_gr0: \"0 < n \\<Longrightarrow> f\\<^bsup>\\<leftarrow> init\\<^esup> n = f (n - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    f\\<^bsup>\\<leftarrow> init\\<^esup> n = f (n - Suc 0)", "by (case_tac n, simp_all add: ilist_Previous_nth)"], ["", "lemma list_Previous_Suc: \"xs\\<^bsup>\\<leftarrow>' init\\<^esup> (Suc n) = xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs\\<^bsup>\\<leftarrow>' init\\<^esup> Suc n = xs ! n", "by (simp add: list_Previous_def)"], ["", "lemma ilist_Previous_Suc: \"f\\<^bsup>\\<leftarrow> init\\<^esup> (Suc n) = f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^bsup>\\<leftarrow> init\\<^esup> Suc n = f n", "by (simp add: ilist_Previous_def)"], ["", "lemma f_Exec_Stream_Previous_f_Exec_Stream_Init: \"\n  f_Exec_Comp_Stream_Init trans_fun xs c ! n =\n  (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Init trans_fun xs c ! n =\n    (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons list_Previous_Cons)"], ["", "lemma i_Exec_Stream_Previous_i_Exec_Stream_Init: \"\n  i_Exec_Comp_Stream_Init trans_fun input c n =\n  (i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c n =\n    (i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n", "by (simp add: i_Exec_Stream_Init_eq_i_Exec_Stream_Cons ilist_Previous_Cons)"], ["", "lemma f_Exec_Stream_hd: \"\n  0 < length xs \\<Longrightarrow> hd (f_Exec_Comp_Stream trans_fun xs c) = trans_fun (hd xs) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow>\n    hd (f_Exec_Comp_Stream trans_fun xs c) = trans_fun (hd xs) c", "by (case_tac xs, simp+)"], ["", "lemma f_Exec_Stream_nth_0: \"\n  0 < length xs \\<Longrightarrow> (f_Exec_Comp_Stream trans_fun xs c) ! 0= trans_fun (xs ! 0) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun xs c ! 0 = trans_fun (xs ! 0) c", "by (case_tac xs, simp+)"], ["", "text \\<open>\n  The calculation of the n-th result stream element\n  from the previous result stream element and the current input stream element.\\<close>"], ["", "lemma f_Exec_Stream_nth_gr0_calc: \"\n  \\<lbrakk> n < length xs; 0 < n \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c ! n =\n  trans_fun (xs ! n) (f_Exec_Comp_Stream trans_fun xs c ! (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs; 0 < n\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream trans_fun xs c ! n =\n                      trans_fun (xs ! n)\n                       (f_Exec_Comp_Stream trans_fun xs c ! (n - 1))", "by (simp add: f_Exec_Stream_nth take_Suc_conv_app_nth f_Exec_append)"], ["", "lemma f_Exec_Stream_nth_calc_Previous: \"\n  n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c ! n =\n  trans_fun (xs ! n) ((f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun xs c ! n =\n    trans_fun (xs ! n)\n     ((f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n)", "apply (case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length xs; n = 0\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream trans_fun xs c ! n =\n                      trans_fun (xs ! n)\n                       ((f_Exec_Comp_Stream trans_fun xs\n                          c)\\<^bsup>\\<leftarrow>' c\\<^esup> n)\n 2. \\<And>nat.\n       \\<lbrakk>n < length xs; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream trans_fun xs c ! n =\n                         trans_fun (xs ! n)\n                          ((f_Exec_Comp_Stream trans_fun xs\n                             c)\\<^bsup>\\<leftarrow>' c\\<^esup> n)", "apply (simp add: list_Previous_0 f_Exec_Stream_nth_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>n < length xs; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream trans_fun xs c ! n =\n                         trans_fun (xs ! n)\n                          ((f_Exec_Comp_Stream trans_fun xs\n                             c)\\<^bsup>\\<leftarrow>' c\\<^esup> n)", "apply (simp add: list_Previous_def f_Exec_Stream_nth_gr0_calc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_nth_0: \"\n  (i_Exec_Comp_Stream trans_fun input c) 0 = trans_fun (input 0) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun input c 0 = trans_fun (input 0) c", "by (simp add: i_Exec_Stream_nth i_take_first)"], ["", "lemma i_Exec_Stream_nth_gr0_calc: \"\n  0 < n \\<Longrightarrow>\n  (i_Exec_Comp_Stream trans_fun input c) n =\n  trans_fun (input n) ((i_Exec_Comp_Stream trans_fun input c) (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    i_Exec_Comp_Stream trans_fun input c n =\n    trans_fun (input n) (i_Exec_Comp_Stream trans_fun input c (n - 1))", "by (simp add: i_Exec_Stream_nth i_take_Suc_conv_app_nth f_Exec_append)"], ["", "text \\<open>\n  The component state (and thus its output) at time point @{term \"n\"}\n  is computed from the previous state\n  (the state at time @{term \"n-1\"} for @{term \"n > 0\"}\n  or the initial state for @{term \"n = 0\"})\n  and the input at time @{term \"n\"}.\\<close>"], ["", "lemma i_Exec_Stream_nth_calc_Previous: \"\n  i_Exec_Comp_Stream trans_fun input c n =\n  trans_fun (input n) ((i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun input c n =\n    trans_fun (input n)\n     ((i_Exec_Comp_Stream trans_fun input\n        c)\\<^bsup>\\<leftarrow> c\\<^esup> n)", "by (simp add: i_Exec_Stream_nth ilist_Previous_nth_if i_take_first i_take_Suc_conv_app_nth f_Exec_append)"], ["", "lemma f_Exec_Stream_Init_nth_Suc_calc: \"\n  n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n =\n  trans_fun (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n =\n    trans_fun (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n)", "by (simp add: f_Exec_Stream_Init_eq_f_Exec_Stream_Cons f_Exec_Stream_nth nth_Cons' length_greater_0_conv[THEN iffD1, OF gr_implies_gr0] take_Suc_conv_app_nth f_Exec_append)"], ["", "lemma f_Exec_Stream_Init_nth_Plus1_calc: \"\n  n < length xs \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! (n + 1)=\n  trans_fun (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c ! (n + 1) =\n    trans_fun (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n)", "by (simp add: f_Exec_Stream_Init_nth_Suc_calc)"], ["", "lemma f_Exec_Stream_Init_nth_gr0_calc: \"\n  \\<lbrakk> n \\<le> length xs; 0 < n \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c ! n =\n  trans_fun (xs ! (n - 1)) (f_Exec_Comp_Stream_Init trans_fun xs c ! (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs; 0 < n\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Init trans_fun xs c ! n =\n                      trans_fun (xs ! (n - 1))\n                       (f_Exec_Comp_Stream_Init trans_fun xs c ! (n - 1))", "by (clarsimp simp: gr0_conv_Suc f_Exec_Stream_Init_nth_Suc_calc)"], ["", "text \\<open>\n  At the beginning,\n  the component state (and thus its output)\n  for the execution stream with initial state\n  is represented by the initial state,\n  contrary to the @{term \"i_Exec_Comp_Stream\"}\n  that does not contain the initial state.\\<close>"], ["", "text \\<open>\n  The component state (and thus its output) at time point @{term \"n + 1\"}\n  for the execution stream with initial state\n  is computed from the previous state\n  (the state at time @{term \"n\"})\n  and the previous input\n  (input at time @{term \"n\"}),\n  contrary to the @{term \"i_Exec_Comp_Stream\"},\n  where each state at time @{term \"n\"}\n  represents the resulting state after processing the input at time @{term \"n\"}.\\<close>"], ["", "lemma i_Exec_Stream_Init_nth_Suc_calc: \"\n  i_Exec_Comp_Stream_Init trans_fun input c (Suc n) =\n  trans_fun (input n) (i_Exec_Comp_Stream_Init trans_fun input c n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c (Suc n) =\n    trans_fun (input n) (i_Exec_Comp_Stream_Init trans_fun input c n)", "by (simp add: i_Exec_Stream_Init_nth i_take_Suc_conv_app_nth f_Exec_append)"], ["", "lemma i_Exec_Stream_Init_nth_Plus1_calc: \"\n  i_Exec_Comp_Stream_Init trans_fun input c (n + 1) =\n  trans_fun (input n) (i_Exec_Comp_Stream_Init trans_fun input c n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Init trans_fun input c (n + 1) =\n    trans_fun (input n) (i_Exec_Comp_Stream_Init trans_fun input c n)", "by (simp add: i_Exec_Stream_Init_nth_Suc_calc)"], ["", "lemma i_Exec_Stream_Init_nth_gr0_calc: \"\n  0 < n \\<Longrightarrow>\n  i_Exec_Comp_Stream_Init trans_fun input c n =\n  trans_fun (input (n - 1)) (i_Exec_Comp_Stream_Init trans_fun input c (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    i_Exec_Comp_Stream_Init trans_fun input c n =\n    trans_fun (input (n - 1))\n     (i_Exec_Comp_Stream_Init trans_fun input c (n - 1))", "by (clarsimp simp: gr0_conv_Suc i_Exec_Stream_Init_nth_Suc_calc)"], ["", "text \\<open>Correlation between Pre/Post-Conditions for\n  \\<open>f_Exec_Comp_Stream\\<close> and \\<open>f_Exec_Comp_Stream_Init\\<close>\\<close>"], ["", "lemma f_Exec_Stream_Pre_Post1: \"\n  \\<lbrakk> n < length xs;\n    c_n = (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (f_Exec_Comp_Stream trans_fun xs c ! n)) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs;\n     c_n =\n     (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n;\n     x_n = xs ! n\\<rbrakk>\n    \\<Longrightarrow> (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (f_Exec_Comp_Stream trans_fun xs c ! n)) =\n                      (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (trans_fun x_n c_n))", "by (simp add: f_Exec_Stream_nth_calc_Previous)"], ["", "text \\<open>Direct relation between input and result after transition\\<close>"], ["", "lemma f_Exec_Stream_Pre_Post2: \"\n  \\<lbrakk> n < length xs;\n    c_n = (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (xs ! n) (f_Exec_Comp_Stream trans_fun xs c ! n)) =\n  (P c_n \\<longrightarrow> Q x_n (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs;\n     c_n =\n     (f_Exec_Comp_Stream trans_fun xs c)\\<^bsup>\\<leftarrow>' c\\<^esup> n;\n     x_n = xs ! n\\<rbrakk>\n    \\<Longrightarrow> (P c_n \\<longrightarrow>\n                       Q (xs ! n) (f_Exec_Comp_Stream trans_fun xs c ! n)) =\n                      (P c_n \\<longrightarrow> Q x_n (trans_fun x_n c_n))", "by (simp add: f_Exec_Stream_nth_calc_Previous)"], ["", "lemma f_Exec_Stream_Pre_Post2_Suc: \"\n  \\<lbrakk> Suc n < length xs;\n    c_n = f_Exec_Comp_Stream trans_fun xs c ! n; x_n1 = xs ! Suc n \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (xs ! Suc n) (f_Exec_Comp_Stream trans_fun xs c ! Suc n)) =\n  (P c_n \\<longrightarrow> Q x_n1 (trans_fun x_n1 c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc n < length xs; c_n = f_Exec_Comp_Stream trans_fun xs c ! n;\n     x_n1 = xs ! Suc n\\<rbrakk>\n    \\<Longrightarrow> (P c_n \\<longrightarrow>\n                       Q (xs ! Suc n)\n                        (f_Exec_Comp_Stream trans_fun xs c ! Suc n)) =\n                      (P c_n \\<longrightarrow> Q x_n1 (trans_fun x_n1 c_n))", "by (simp add: f_Exec_Stream_nth_gr0_calc)"], ["", "lemma f_Exec_Stream_Init_Pre_Post1: \"\n  \\<lbrakk> n < length xs;\n    c_n = f_Exec_Comp_Stream_Init trans_fun xs c ! n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n)) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs;\n     c_n = f_Exec_Comp_Stream_Init trans_fun xs c ! n; x_n = xs ! n\\<rbrakk>\n    \\<Longrightarrow> (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n)) =\n                      (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (trans_fun x_n c_n))", "by (simp add: f_Exec_Stream_Init_nth_Suc_calc)"], ["", "text \\<open>Direct relation between input and state before transition\\<close>"], ["", "lemma f_Exec_Stream_Init_Pre_Post2: \"\n  \\<lbrakk> n < length xs;\n    c_n = f_Exec_Comp_Stream_Init trans_fun xs c ! n; x_n = xs ! n \\<rbrakk> \\<Longrightarrow>\n  (P (xs ! n) (f_Exec_Comp_Stream_Init trans_fun xs c ! n) \\<longrightarrow>\n     Q (f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n)) =\n  (P x_n c_n \\<longrightarrow> Q (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs;\n     c_n = f_Exec_Comp_Stream_Init trans_fun xs c ! n; x_n = xs ! n\\<rbrakk>\n    \\<Longrightarrow> (P (xs ! n)\n                        (f_Exec_Comp_Stream_Init trans_fun xs c !\n                         n) \\<longrightarrow>\n                       Q (f_Exec_Comp_Stream_Init trans_fun xs c ! Suc n)) =\n                      (P x_n c_n \\<longrightarrow> Q (trans_fun x_n c_n))", "by (simp add: f_Exec_Stream_Init_nth_Suc_calc)"], ["", "lemma i_Exec_Stream_Pre_Post1: \"\n  \\<lbrakk> c_n = (i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (i_Exec_Comp_Stream trans_fun input c n)) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_n =\n             (i_Exec_Comp_Stream trans_fun input\n               c)\\<^bsup>\\<leftarrow> c\\<^esup> n;\n     x_n = input n\\<rbrakk>\n    \\<Longrightarrow> (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (i_Exec_Comp_Stream trans_fun input c n)) =\n                      (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (trans_fun x_n c_n))", "by (simp add: i_Exec_Stream_nth_calc_Previous)"], ["", "text \\<open>Direct relation between input and result after transition\\<close>"], ["", "lemma i_Exec_Stream_Pre_Post2: \"\n  \\<lbrakk> c_n = (i_Exec_Comp_Stream trans_fun input c)\\<^bsup>\\<leftarrow> c\\<^esup> n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (input n) (i_Exec_Comp_Stream trans_fun input c n)) =\n  (P c_n \\<longrightarrow> Q x_n (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_n =\n             (i_Exec_Comp_Stream trans_fun input\n               c)\\<^bsup>\\<leftarrow> c\\<^esup> n;\n     x_n = input n\\<rbrakk>\n    \\<Longrightarrow> (P c_n \\<longrightarrow>\n                       Q (input n)\n                        (i_Exec_Comp_Stream trans_fun input c n)) =\n                      (P c_n \\<longrightarrow> Q x_n (trans_fun x_n c_n))", "by (simp add: i_Exec_Stream_nth_calc_Previous)"], ["", "lemma i_Exec_Stream_Pre_Post2_Suc: \"\n  \\<lbrakk> c_n = i_Exec_Comp_Stream trans_fun input c n; x_n1 = input (Suc n) \\<rbrakk> \\<Longrightarrow>\n  (P c_n \\<longrightarrow> Q (input (Suc n)) (i_Exec_Comp_Stream trans_fun input c (Suc n))) =\n  (P c_n \\<longrightarrow> Q x_n1 (trans_fun x_n1 c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_n = i_Exec_Comp_Stream trans_fun input c n;\n     x_n1 = input (Suc n)\\<rbrakk>\n    \\<Longrightarrow> (P c_n \\<longrightarrow>\n                       Q (input (Suc n))\n                        (i_Exec_Comp_Stream trans_fun input c (Suc n))) =\n                      (P c_n \\<longrightarrow> Q x_n1 (trans_fun x_n1 c_n))", "by (simp add: i_Exec_Stream_nth_gr0_calc)"], ["", "lemma i_Exec_Stream_Init_Pre_Post1: \"\n  \\<lbrakk> c_n = i_Exec_Comp_Stream_Init trans_fun input c n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (i_Exec_Comp_Stream_Init trans_fun input c (Suc n))) =\n  (P1 x_n \\<and> P2 c_n \\<longrightarrow> Q (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_n = i_Exec_Comp_Stream_Init trans_fun input c n;\n     x_n = input n\\<rbrakk>\n    \\<Longrightarrow> (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (i_Exec_Comp_Stream_Init trans_fun input c\n                           (Suc n))) =\n                      (P1 x_n \\<and> P2 c_n \\<longrightarrow>\n                       Q (trans_fun x_n c_n))", "by (simp add: i_Exec_Stream_Init_nth_Suc_calc)"], ["", "text \\<open>Direct relation between input and state before transition\\<close>"], ["", "lemma i_Exec_Stream_Init_Pre_Post2: \"\n  \\<lbrakk> c_n = i_Exec_Comp_Stream_Init trans_fun input c n; x_n = input n \\<rbrakk> \\<Longrightarrow>\n  (P (input n) (i_Exec_Comp_Stream_Init trans_fun input c n) \\<longrightarrow>\n     Q (i_Exec_Comp_Stream_Init trans_fun input c (Suc n))) =\n  (P x_n c_n \\<longrightarrow> Q (trans_fun x_n c_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_n = i_Exec_Comp_Stream_Init trans_fun input c n;\n     x_n = input n\\<rbrakk>\n    \\<Longrightarrow> (P (input n)\n                        (i_Exec_Comp_Stream_Init trans_fun input c\n                          n) \\<longrightarrow>\n                       Q (i_Exec_Comp_Stream_Init trans_fun input c\n                           (Suc n))) =\n                      (P x_n c_n \\<longrightarrow> Q (trans_fun x_n c_n))", "by (simp add: i_Exec_Stream_Init_nth_Suc_calc)"], ["", "text \\<open>Basic results for stream prefices\\<close>"], ["", "lemma f_Exec_Stream_prefix: \"\n  prefix xs ys \\<Longrightarrow>\n  prefix (f_Exec_Comp_Stream trans_fun xs c)\n         (f_Exec_Comp_Stream trans_fun ys c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<Longrightarrow>\n    prefix (f_Exec_Comp_Stream trans_fun xs c)\n     (f_Exec_Comp_Stream trans_fun ys c)", "by (clarsimp simp: prefix_def f_Exec_Stream_append)"], ["", "lemma i_Exec_Stream_prefix: \"\n xs \\<sqsubseteq> input \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c \\<sqsubseteq>\n  i_Exec_Comp_Stream trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> input \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun xs c \\<sqsubseteq>\n    i_Exec_Comp_Stream trans_fun input c", "by (simp add: iprefix_eq_iprefix_take i_Exec_Stream_take)"], ["", "lemma f_Exec_N_prefix: \"\n  \\<lbrakk> n \\<le> length xs; prefix xs ys \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_N trans_fun n xs c =\n  f_Exec_Comp_N trans_fun n ys c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs; prefix xs ys\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_N trans_fun n xs c =\n                      f_Exec_Comp_N trans_fun n ys c", "by (simp add: f_Exec_Comp_N_def prefix_imp_take_eq)"], ["", "theorem f_Exec_Stream_prefix_causal[rule_format]:\"\n  n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c \\<down> n =\n  f_Exec_Comp_Stream trans_fun ys c \\<down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow>\n    f_Exec_Comp_Stream trans_fun xs c \\<down> n =\n    f_Exec_Comp_Stream trans_fun ys c \\<down> n", "by (rule f_Exec_Stream_causal, rule inf_prefix_take_correct)"], ["", "lemma f_Exec_Stream_Init_prefix:\"\n  prefix xs ys \\<Longrightarrow>\n  prefix (f_Exec_Comp_Stream_Init trans_fun xs c)\n         (f_Exec_Comp_Stream_Init trans_fun ys c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<Longrightarrow>\n    prefix (f_Exec_Comp_Stream_Init trans_fun xs c)\n     (f_Exec_Comp_Stream_Init trans_fun ys c)", "by (clarsimp simp: prefix_def f_Exec_Stream_Init_append)"], ["", "lemma i_Exec_Stream_Init_prefix: \"\n xs \\<sqsubseteq> input \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c \\<sqsubseteq>\n  i_Exec_Comp_Stream_Init trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> input \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c \\<sqsubseteq>\n    i_Exec_Comp_Stream_Init trans_fun input c", "by (simp add: iprefix_eq_iprefix_take i_Exec_Stream_Init_take)"], ["", "theorem f_Exec_Stream_Init_prefix_strictly_causal[rule_format]:\"\n  n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow>\n  f_Exec_Comp_Stream_Init trans_fun xs c \\<down> Suc n =\n  f_Exec_Comp_Stream_Init trans_fun ys c \\<down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow>\n    f_Exec_Comp_Stream_Init trans_fun xs c \\<down> Suc n =\n    f_Exec_Comp_Stream_Init trans_fun ys c \\<down> Suc n", "by (rule f_Exec_Stream_Init_strictly_causal, rule inf_prefix_take_correct)"], ["", "text \\<open>\n  A predicate indicating\n  whether a component is deterministically dependent\n  on the local state extracted by the the given local state function.\\<close>"], ["", "definition Deterministic_Trans_Fun ::\n    \"('comp, 'input) Comp_Trans_Fun \\<Rightarrow> ('comp, 'state) Comp_Local_State \\<Rightarrow> bool\"\n  where \"Deterministic_Trans_Fun trans_fun localState \\<equiv>\n    \\<forall>c1 c2 x. localState c1 = localState c2 \\<longrightarrow> trans_fun x c1 = trans_fun x c2\""], ["", "lemma Deterministic_f_Exec: \"\n  \\<lbrakk> Deterministic_Trans_Fun trans_fun localState; localState c1 = localState c2; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp trans_fun xs c1 = f_Exec_Comp trans_fun xs c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n     localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                      f_Exec_Comp trans_fun xs c2", "apply (unfold Deterministic_Trans_Fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c1 c2 x.\n                localState c1 = localState c2 \\<longrightarrow>\n                trans_fun x c1 = trans_fun x c2;\n     localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                      f_Exec_Comp trans_fun xs c2", "apply (case_tac xs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>c1 c2 x.\n                   localState c1 = localState c2 \\<longrightarrow>\n                   trans_fun x c1 = trans_fun x c2;\n        localState c1 = localState c2; xs \\<noteq> [];\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                         f_Exec_Comp trans_fun xs c2", "apply (rename_tac y ys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<forall>c1 c2 x.\n                   localState c1 = localState c2 \\<longrightarrow>\n                   trans_fun x c1 = trans_fun x c2;\n        localState c1 = localState c2; xs \\<noteq> []; xs = y # ys\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                         f_Exec_Comp trans_fun xs c2", "apply (drule_tac x=c1 in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ys.\n       \\<lbrakk>localState c1 = localState c2; xs \\<noteq> []; xs = y # ys;\n        \\<forall>c2 x.\n           localState c1 = localState c2 \\<longrightarrow>\n           trans_fun x c1 = trans_fun x c2\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                         f_Exec_Comp trans_fun xs c2", "apply (drule_tac x=c2 in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ys.\n       \\<lbrakk>localState c1 = localState c2; xs \\<noteq> []; xs = y # ys;\n        \\<forall>x.\n           localState c1 = localState c2 \\<longrightarrow>\n           trans_fun x c1 = trans_fun x c2\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                         f_Exec_Comp trans_fun xs c2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Deterministic_f_Exec_Stream: \"\n  \\<lbrakk> Deterministic_Trans_Fun trans_fun localState; localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c1 = f_Exec_Comp_Stream trans_fun xs c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n     localState c1 = localState c2\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream trans_fun xs c1 =\n                      f_Exec_Comp_Stream trans_fun xs c2", "apply (clarsimp simp: list_eq_iff f_Exec_Stream_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2; i < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (xs \\<down> Suc i) c1 =\n                         f_Exec_Comp trans_fun (xs \\<down> Suc i) c2", "apply (rule Deterministic_f_Exec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2; i < length xs\\<rbrakk>\n       \\<Longrightarrow> Deterministic_Trans_Fun trans_fun (?localState5 i)\n 2. \\<And>i.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2; i < length xs\\<rbrakk>\n       \\<Longrightarrow> ?localState5 i c1 = ?localState5 i c2\n 3. \\<And>i.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2; i < length xs\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i \\<noteq> []", "apply (simp add: length_greater_0_conv[THEN iffD1, OF gr_implies_gr0])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Deterministic_i_Exec_Stream: \"\n  \\<lbrakk> Deterministic_Trans_Fun trans_fun localState; localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream trans_fun input c1 = i_Exec_Comp_Stream trans_fun input c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n     localState c1 = localState c2\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream trans_fun input c1 =\n                      i_Exec_Comp_Stream trans_fun input c2", "apply (clarsimp simp: ilist_eq_iff i_Exec_Stream_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (input \\<Down> Suc x) c1 =\n                         f_Exec_Comp trans_fun (input \\<Down> Suc x) c2", "apply (rule Deterministic_f_Exec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> Deterministic_Trans_Fun trans_fun (?localState1 x)\n 2. \\<And>x.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> ?localState1 x c1 = ?localState1 x c2\n 3. \\<And>x.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> input \\<Down> Suc x \\<noteq> []", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Connected streams\\<close>"], ["", "text \\<open>\n  A predicate indicating for two message streams,\n  that the ports, they correspond to, are connected.\n  The predicate implies strict causality.\\<close>"], ["", "definition f_Streams_Connected :: \"'a fstream_af \\<Rightarrow> 'a fstream_af \\<Rightarrow> bool\"\n  where \"f_Streams_Connected outS inS \\<equiv> inS = \\<NoMsg> # outS\""], ["", "definition i_Streams_Connected :: \"'a istream_af \\<Rightarrow> 'a istream_af \\<Rightarrow> bool\"\n  where \"i_Streams_Connected outS inS \\<equiv> inS = [\\<NoMsg>] \\<frown> outS\""], ["", "lemmas Streams_Connected_defs =\n  f_Streams_Connected_def\n  i_Streams_Connected_def"], ["", "lemma f_Streams_Connected_imp_not_empty: \"f_Streams_Connected outS inS \\<Longrightarrow> inS \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Streams_Connected outS inS \\<Longrightarrow> inS \\<noteq> []", "by (simp add: f_Streams_Connected_def)"], ["", "lemma f_Streams_Connected_nth_conv: \"\n  f_Streams_Connected outS inS =\n  (length inS = Suc (length outS) \\<and>\n  (\\<forall>i<length inS. inS ! i = (case i of 0 \\<Rightarrow> \\<NoMsg> | Suc k \\<Rightarrow> outS ! k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Streams_Connected outS inS =\n    (length inS = Suc (length outS) \\<and>\n     (\\<forall>i<length inS.\n         inS ! i =\n         (case i of 0 \\<Rightarrow> NoMsg | Suc k \\<Rightarrow> outS ! k)))", "by (simp add: f_Streams_Connected_def list_eq_iff nth_Cons)"], ["", "lemma f_Streams_Connected_nth_conv_if: \"\n  f_Streams_Connected outS inS =\n  (length inS = Suc (length outS) \\<and>\n  (\\<forall>i<length inS. inS ! i = (if i = 0 then \\<NoMsg> else outS ! (i - Suc 0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Streams_Connected outS inS =\n    (length inS = Suc (length outS) \\<and>\n     (\\<forall>i<length inS.\n         inS ! i = (if i = 0 then NoMsg else outS ! (i - Suc 0))))", "apply (subst f_Streams_Connected_nth_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length inS = Suc (length outS) \\<and>\n     (\\<forall>i<length inS.\n         inS ! i =\n         (case i of 0 \\<Rightarrow> NoMsg\n          | Suc x \\<Rightarrow> outS ! x))) =\n    (length inS = Suc (length outS) \\<and>\n     (\\<forall>i<length inS.\n         inS ! i = (if i = 0 then NoMsg else outS ! (i - Suc 0))))", "apply (rule conj_cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length inS = Suc (length outS) \\<Longrightarrow>\n    (\\<forall>i<length inS.\n        inS ! i =\n        (case i of 0 \\<Rightarrow> NoMsg | Suc x \\<Rightarrow> outS ! x)) =\n    (\\<forall>i<length inS.\n        inS ! i = (if i = 0 then NoMsg else outS ! (i - Suc 0)))", "apply (rule all_imp_eqI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length inS = Suc (length outS); i < length inS\\<rbrakk>\n       \\<Longrightarrow> (inS ! i =\n                          (case i of 0 \\<Rightarrow> NoMsg\n                           | Suc x \\<Rightarrow> outS ! x)) =\n                         (inS ! i =\n                          (if i = 0 then NoMsg else outS ! (i - Suc 0)))", "apply (rename_tac i, case_tac i, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Streams_Connected_nth_conv: \"\n  i_Streams_Connected outS inS =\n  (\\<forall>i. inS i = (case i of 0 \\<Rightarrow> \\<NoMsg> | Suc k \\<Rightarrow> outS k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Streams_Connected outS inS =\n    (\\<forall>i.\n        inS i =\n        (case i of 0 \\<Rightarrow> NoMsg | Suc k \\<Rightarrow> outS k))", "by (simp add: i_Streams_Connected_def ilist_eq_iff i_append_nth_Cons)"], ["", "lemma i_Streams_Connected_nth_conv_if: \"\n  i_Streams_Connected outS inS =\n  (\\<forall>i. inS i = (if i = 0 then \\<NoMsg> else outS (i - Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Streams_Connected outS inS =\n    (\\<forall>i. inS i = (if i = 0 then NoMsg else outS (i - Suc 0)))", "apply (subst i_Streams_Connected_nth_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        inS i =\n        (case i of 0 \\<Rightarrow> NoMsg | Suc x \\<Rightarrow> outS x)) =\n    (\\<forall>i. inS i = (if i = 0 then NoMsg else outS (i - Suc 0)))", "apply (rule all_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (inS i =\n        (case i of 0 \\<Rightarrow> NoMsg | Suc x \\<Rightarrow> outS x)) =\n       (inS i = (if i = 0 then NoMsg else outS (i - Suc 0)))", "apply (rename_tac i, case_tac i, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun xs c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c) = channel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>output_fun c = NoMsg;\n     f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun xs c)) channel\\<rbrakk>\n    \\<Longrightarrow> map output_fun\n                       (f_Exec_Comp_Stream_Init trans_fun xs c) =\n                      channel", "by (simp add: f_Streams_Connected_def f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["", "lemma i_Exec_Stream_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    i_Streams_Connected\n      (output_fun \\<circ> (i_Exec_Comp_Stream trans_fun input c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c) = channel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>output_fun c = NoMsg;\n     i_Streams_Connected\n      (output_fun \\<circ> i_Exec_Comp_Stream trans_fun input c)\n      channel\\<rbrakk>\n    \\<Longrightarrow> output_fun \\<circ>\n                      i_Exec_Comp_Stream_Init trans_fun input c =\n                      channel", "by (simp add: i_Streams_Connected_def i_Exec_Stream_Init_eq_i_Exec_Stream_Cons)"], ["", "lemma f_Exec_Stream_output_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    output1 = map output_fun (f_Exec_Comp_Stream trans_fun xs c);\n    output2 = map output_fun (f_Exec_Comp_Stream trans_fun ys c) \\<rbrakk> \\<Longrightarrow>\n  output1 \\<down> n = output2 \\<down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<down> n = ys \\<down> n;\n     output1 = map output_fun (f_Exec_Comp_Stream trans_fun xs c);\n     output2 = map output_fun (f_Exec_Comp_Stream trans_fun ys c)\\<rbrakk>\n    \\<Longrightarrow> output1 \\<down> n = output2 \\<down> n", "by (simp add: take_map f_Exec_Stream_causal[of n xs])"], ["", "lemma f_Exec_Stream_Init_output_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    output1 = map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c);\n    output2 = map output_fun (f_Exec_Comp_Stream_Init trans_fun ys c) \\<rbrakk> \\<Longrightarrow>\n  output1 \\<down> Suc n = output2 \\<down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<down> n = ys \\<down> n;\n     output1 = map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c);\n     output2 =\n     map output_fun (f_Exec_Comp_Stream_Init trans_fun ys c)\\<rbrakk>\n    \\<Longrightarrow> output1 \\<down> Suc n = output2 \\<down> Suc n", "by (simp add: take_map f_Exec_Stream_Init_strictly_causal[of n xs])"], ["", "lemma i_Exec_Stream_output_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    output1 = output_fun \\<circ> i_Exec_Comp_Stream trans_fun input1 c;\n    output2 = output_fun \\<circ> i_Exec_Comp_Stream trans_fun input2 c \\<rbrakk> \\<Longrightarrow>\n  output1 \\<Down> n = output2 \\<Down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     output1 = output_fun \\<circ> i_Exec_Comp_Stream trans_fun input1 c;\n     output2 =\n     output_fun \\<circ> i_Exec_Comp_Stream trans_fun input2 c\\<rbrakk>\n    \\<Longrightarrow> output1 \\<Down> n = output2 \\<Down> n", "by (simp add: i_Exec_Stream_causal[of n input1])"], ["", "lemma i_Exec_Stream_Init_output_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    output1 = output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input1 c;\n    output2 = output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input2 c \\<rbrakk> \\<Longrightarrow>\n  output1 \\<Down> Suc n = output2 \\<Down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     output1 =\n     output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input1 c;\n     output2 =\n     output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input2 c\\<rbrakk>\n    \\<Longrightarrow> output1 \\<Down> Suc n = output2 \\<Down> Suc n", "by (simp add: i_Exec_Stream_Init_strictly_causal[of n input1])"], ["", "lemma f_Exec_Stream_Connected_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun xs c))\n      channel1;\n    f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun ys c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<down> Suc n = channel2 \\<down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<down> n = ys \\<down> n;\n     f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun xs c)) channel1;\n     f_Streams_Connected\n      (map output_fun (f_Exec_Comp_Stream trans_fun ys c)) channel2\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<down> Suc n = channel2 \\<down> Suc n", "by (simp add: f_Streams_Connected_def take_map f_Exec_Stream_take)"], ["", "lemma i_Exec_Stream_Connected_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    i_Streams_Connected\n      (portOutput \\<circ> (i_Exec_Comp_Stream trans_fun input1 c))\n      channel1;\n    i_Streams_Connected\n      (portOutput \\<circ> (i_Exec_Comp_Stream trans_fun input2 c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<Down> Suc n = channel2 \\<Down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     i_Streams_Connected\n      (portOutput \\<circ> i_Exec_Comp_Stream trans_fun input1 c) channel1;\n     i_Streams_Connected\n      (portOutput \\<circ> i_Exec_Comp_Stream trans_fun input2 c)\n      channel2\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<Down> Suc n = channel2 \\<Down> Suc n", "by (simp add: i_Streams_Connected_def i_take_Suc_Cons i_Exec_Stream_take)"], ["", "text \\<open>\n  A predicate for the semantics with initial state in result stream\n  indicating for two message streams that the ports, they correspond to, are connected.\\<close>"], ["", "definition f_Streams_Connected_Init :: \"'a fstream_af \\<Rightarrow> 'a fstream_af \\<Rightarrow> bool\"\n  where \"f_Streams_Connected_Init outS inS \\<equiv> inS = outS\""], ["", "definition i_Streams_Connected_Init :: \"'a istream_af \\<Rightarrow> 'a istream_af \\<Rightarrow> bool\"\n  where \"i_Streams_Connected_Init outS inS \\<equiv> inS = outS\""], ["", "lemmas Streams_Connected_Init_defs =\n  f_Streams_Connected_Init_def\n  i_Streams_Connected_Init_def"], ["", "lemma f_Streams_Connected_Init_nth_conv: \"\n  f_Streams_Connected_Init outS inS =\n  (length inS = length outS \\<and> (\\<forall>i<length inS. inS ! i = outS ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Streams_Connected_Init outS inS =\n    (length inS = length outS \\<and>\n     (\\<forall>i<length inS. inS ! i = outS ! i))", "by (simp add: f_Streams_Connected_Init_def list_eq_iff)"], ["", "lemma i_Streams_Connected_Init_nth_conv: \"\n  i_Streams_Connected_Init outS inS =\n  (\\<forall>i. inS i = outS i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Streams_Connected_Init outS inS = (\\<forall>i. inS i = outS i)", "by (simp add: i_Streams_Connected_Init_def ilist_eq_iff)"], ["", "lemma f_Exec_Stream_Init_eq_output_channel2: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c) = channel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>output_fun c = NoMsg;\n     f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c))\n      channel\\<rbrakk>\n    \\<Longrightarrow> map output_fun\n                       (f_Exec_Comp_Stream_Init trans_fun xs c) =\n                      channel", "by (simp add: f_Streams_Connected_Init_def f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["", "lemma i_Exec_Stream_Init_eq_output_channel2: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    i_Streams_Connected_Init\n      (output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c))\n      channel \\<rbrakk> \\<Longrightarrow>\n  output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c) = channel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>output_fun c = NoMsg;\n     i_Streams_Connected_Init\n      (output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input c)\n      channel\\<rbrakk>\n    \\<Longrightarrow> output_fun \\<circ>\n                      i_Exec_Comp_Stream_Init trans_fun input c =\n                      channel", "by (simp add: i_Streams_Connected_Init_def i_Exec_Stream_Init_eq_i_Exec_Stream_Cons)"], ["", "lemma f_Exec_Stream_Connected_Init_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c))\n      channel1;\n    f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun ys c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<down> Suc n = channel2 \\<down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<down> n = ys \\<down> n;\n     f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c)) channel1;\n     f_Streams_Connected_Init\n      (map output_fun (f_Exec_Comp_Stream_Init trans_fun ys c))\n      channel2\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<down> Suc n = channel2 \\<down> Suc n", "by (simp add: f_Streams_Connected_Init_def f_Exec_Stream_Init_eq_f_Exec_Stream_Cons take_map f_Exec_Stream_take)"], ["", "lemma i_Exec_Stream_Connected_Init_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    i_Streams_Connected_Init\n      (portOutput \\<circ> (i_Exec_Comp_Stream_Init trans_fun input1 c))\n      channel1;\n    i_Streams_Connected_Init\n      (portOutput \\<circ> (i_Exec_Comp_Stream_Init trans_fun input2 c))\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<Down> Suc n = channel2 \\<Down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     i_Streams_Connected_Init\n      (portOutput \\<circ> i_Exec_Comp_Stream_Init trans_fun input1 c)\n      channel1;\n     i_Streams_Connected_Init\n      (portOutput \\<circ> i_Exec_Comp_Stream_Init trans_fun input2 c)\n      channel2\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<Down> Suc n = channel2 \\<Down> Suc n", "by (simp add: i_Streams_Connected_Init_def i_Exec_Stream_Init_eq_i_Exec_Stream_Cons i_Exec_Stream_take)"], ["", "subsubsection \\<open>Additional auxiliary results\\<close>"], ["", "text \\<open>The following lemma shows that,\n  if the system state is different at some time points\n  with respect to a certain predicate @{term P},\n  then there exists a defined time point between these two,\n  where the state change has taken place\\<close>"], ["", "lemma f_State_Change_exists_set: \"\n  \\<lbrakk> n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n1) c);\n    P (f_Exec_Comp trans_fun (input \\<down> n2) c) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<in>I. n1 \\<le> n \\<and> n < n2 \\<and>\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n) c) \\<and>\n    P (f_Exec_Comp trans_fun (input \\<down> (inext n I)) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n     \\<not> P (f_Exec_Comp trans_fun (input \\<down> n1) c);\n     P (f_Exec_Comp trans_fun (input \\<down> n2) c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n\\<in>I.\n                         n1 \\<le> n \\<and>\n                         n < n2 \\<and>\n                         \\<not> P (f_Exec_Comp trans_fun (input \\<down> n)\n                                    c) \\<and>\n                         P (f_Exec_Comp trans_fun (input \\<down> inext n I)\n                             c)", "by (rule inext_predicate_change_exists)"], ["", "lemma f_State_Change_exists: \"\n  \\<lbrakk> n1 \\<le> n2;\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n1) c);\n    P (f_Exec_Comp trans_fun (input \\<down> n2) c) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<ge>n1. n < n2 \\<and>\n    \\<not> P (f_Exec_Comp trans_fun (input \\<down> n) c) \\<and>\n    P (f_Exec_Comp trans_fun (input \\<down> (Suc n)) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<le> n2;\n     \\<not> P (f_Exec_Comp trans_fun (input \\<down> n1) c);\n     P (f_Exec_Comp trans_fun (input \\<down> n2) c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n\\<ge>n1.\n                         n < n2 \\<and>\n                         \\<not> P (f_Exec_Comp trans_fun (input \\<down> n)\n                                    c) \\<and>\n                         P (f_Exec_Comp trans_fun (input \\<down> Suc n) c)", "by (rule nat_Suc_predicate_change_exists)"], ["", "lemma i_State_Change_exists_set: \"\n  \\<lbrakk> n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n1);\n    P (i_Exec_Comp_Stream trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<in>I. n1 \\<le> n \\<and> n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream trans_fun input c (inext n I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n     \\<not> P (i_Exec_Comp_Stream trans_fun input c n1);\n     P (i_Exec_Comp_Stream trans_fun input c n2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n\\<in>I.\n                         n1 \\<le> n \\<and>\n                         n < n2 \\<and>\n                         \\<not> P (i_Exec_Comp_Stream trans_fun input c\n                                    n) \\<and>\n                         P (i_Exec_Comp_Stream trans_fun input c\n                             (inext n I))", "by (rule inext_predicate_change_exists)"], ["", "lemma i_State_Change_exists: \"\n  \\<lbrakk> n1 \\<le> n2;\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n1);\n    P (i_Exec_Comp_Stream trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<ge>n1. n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream trans_fun input c (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<le> n2;\n     \\<not> P (i_Exec_Comp_Stream trans_fun input c n1);\n     P (i_Exec_Comp_Stream trans_fun input c n2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n\\<ge>n1.\n                         n < n2 \\<and>\n                         \\<not> P (i_Exec_Comp_Stream trans_fun input c\n                                    n) \\<and>\n                         P (i_Exec_Comp_Stream trans_fun input c (Suc n))", "by (rule nat_Suc_predicate_change_exists)"], ["", "lemma i_State_Change_Init_exists_set: \"\n  \\<lbrakk> n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n1);\n    P (i_Exec_Comp_Stream_Init trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<in>I. n1 \\<le> n \\<and> n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream_Init trans_fun input c (inext n I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<le> n2; n1 \\<in> I; n2 \\<in> I;\n     \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n1);\n     P (i_Exec_Comp_Stream_Init trans_fun input c n2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n\\<in>I.\n                         n1 \\<le> n \\<and>\n                         n < n2 \\<and>\n                         \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c\n                                    n) \\<and>\n                         P (i_Exec_Comp_Stream_Init trans_fun input c\n                             (inext n I))", "by (rule inext_predicate_change_exists)"], ["", "lemma i_State_Change_Init_exists: \"\n  \\<lbrakk> n1 \\<le> n2;\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n1);\n    P (i_Exec_Comp_Stream_Init trans_fun input c n2) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>n\\<ge>n1. n < n2 \\<and>\n    \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n) \\<and>\n    P (i_Exec_Comp_Stream_Init trans_fun input c (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<le> n2;\n     \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c n1);\n     P (i_Exec_Comp_Stream_Init trans_fun input c n2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n\\<ge>n1.\n                         n < n2 \\<and>\n                         \\<not> P (i_Exec_Comp_Stream_Init trans_fun input c\n                                    n) \\<and>\n                         P (i_Exec_Comp_Stream_Init trans_fun input c\n                             (Suc n))", "by (rule nat_Suc_predicate_change_exists)"], ["", "subsection \\<open>Components with accelerated execution\\<close>"], ["", "text \\<open>\n  This section deals with variable execution speed components.\n  A component accelerated by a (clocking) factor @{term k}\n  processes streams expanded by factor @{term k}\n  and its output streams are compressed by factor @{term k}.\\<close>"], ["", "subsubsection \\<open>Equivalence relation for executions\\<close>"], ["", "text \\<open>\n  A predicate indicating for\n  two components together with transition functions\n  and a given equivalence predicate for their local states,\n  that the components exhibit equivalent observable behaviour\n  after expanding input streams and shrinking output streams\n  by a constant factor,\n  given that their local states are equivalent\n  with respect to the specified equivalence relations.\\<close>"], ["", "definition\n  Equiv_Exec :: \"\n    'input \\<Rightarrow>\n    ('state1 \\<Rightarrow> 'state2 \\<Rightarrow> bool) \\<Rightarrow> \\<comment> \\<open>Equivalence predicate for local states\\<close>\n    ('comp1, 'state1) Comp_Local_State \\<Rightarrow>\n    ('comp2, 'state2) Comp_Local_State \\<Rightarrow>\n    ('input, 'input1) Port_Input_Value \\<Rightarrow> \\<comment> \\<open>Input adaptor for first component\\<close>\n    ('input, 'input2) Port_Input_Value \\<Rightarrow> \\<comment> \\<open>Input adaptor for second component\\<close>\n    ('comp1, 'output) Port_Output_Value \\<Rightarrow>\n    ('comp2, 'output) Port_Output_Value \\<Rightarrow>\n    ('comp1, 'input1 message_af) Comp_Trans_Fun \\<Rightarrow>\n    ('comp2, 'input2 message_af) Comp_Trans_Fun \\<Rightarrow>\n    nat \\<Rightarrow> nat \\<Rightarrow> 'comp1 \\<Rightarrow> 'comp2 \\<Rightarrow> bool\"\nwhere\n  \"Equiv_Exec\n    m equiv_states\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2 \\<equiv>\n    equiv_states (localState1 c1) (localState2 c2) \\<longrightarrow> (\n      last_message (map output_fun1 (\n        f_Exec_Comp_Stream trans_fun1 (input_fun1 m # \\<NoMsg>\\<^bsup>k1 - Suc 0\\<^esup>) c1)) =\n      last_message (map output_fun2 (\n        f_Exec_Comp_Stream trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<and>\n      equiv_states\n        (localState1 (f_Exec_Comp trans_fun1 (input_fun1 m # \\<NoMsg>\\<^bsup>k1 - Suc 0\\<^esup>) c1))\n        (localState2 (f_Exec_Comp trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2)))\""], ["", "text \\<open>\n  Predicate indicating for\n  two components together with transition functions\n  and a given equivalence predicate for their local states,\n  that the equivalence predicate is stable\n  with respect to component execution,\n  i.e., it determines the equivalence\n  of components' local states\n  both for the initial states and after the components\n  have processed an arbitrary input.\n  The restricting version @{term \"Equiv_Exec_stable_set\"}\n  guarantees stability only for inputs from a given restriction set,\n  the not-restricting version guarantees stability for all inputs.\\<close>"], ["", "definition\n  Equiv_Exec_stable_set :: \"\n    'input set \\<Rightarrow>\n    ('state1 \\<Rightarrow> 'state2 \\<Rightarrow> bool) \\<Rightarrow> \\<comment> \\<open>Equivalence predicate for local states\\<close>\n    ('comp1, 'state1) Comp_Local_State \\<Rightarrow>\n    ('comp2, 'state2) Comp_Local_State \\<Rightarrow>\n    ('input, 'input1) Port_Input_Value \\<Rightarrow> \\<comment> \\<open>Input adaptor for first component\\<close>\n    ('input, 'input2) Port_Input_Value \\<Rightarrow> \\<comment> \\<open>Input adaptor for second component\\<close>\n    ('comp1, 'output) Port_Output_Value \\<Rightarrow>\n    ('comp2, 'output) Port_Output_Value \\<Rightarrow>\n    ('comp1, 'input1 message_af) Comp_Trans_Fun \\<Rightarrow>\n    ('comp2, 'input2 message_af) Comp_Trans_Fun \\<Rightarrow>\n    nat \\<Rightarrow> nat \\<Rightarrow> 'comp1 \\<Rightarrow> 'comp2 \\<Rightarrow> bool\"\nwhere\n  \"Equiv_Exec_stable_set A\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 \\<equiv>\n   \\<forall>input m. set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n     Equiv_Exec m\n       equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n       trans_fun1 trans_fun2 k1 k2\n       (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)\n       (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)\""], ["", "definition\n  Equiv_Exec_stable :: \"\n    ('state1 \\<Rightarrow> 'state2 \\<Rightarrow> bool) \\<Rightarrow> \\<comment> \\<open>Equivalence predicate for local states\\<close>\n    ('comp1, 'state1) Comp_Local_State \\<Rightarrow>\n    ('comp2, 'state2) Comp_Local_State \\<Rightarrow>\n    ('input, 'input1) Port_Input_Value \\<Rightarrow> \\<comment> \\<open>Input adaptor for first component\\<close>\n    ('input, 'input2) Port_Input_Value \\<Rightarrow> \\<comment> \\<open>Input adaptor for second component\\<close>\n    ('comp1, 'output) Port_Output_Value \\<Rightarrow>\n    ('comp2, 'output) Port_Output_Value \\<Rightarrow>\n    ('comp1, 'input1 message_af) Comp_Trans_Fun \\<Rightarrow>\n    ('comp2, 'input2 message_af) Comp_Trans_Fun \\<Rightarrow>\n    nat \\<Rightarrow> nat \\<Rightarrow> 'comp1 \\<Rightarrow> 'comp2 \\<Rightarrow> bool\"\nwhere\n  \"Equiv_Exec_stable\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 \\<equiv>\n   \\<forall>input m.\n     Equiv_Exec m\n       equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n       trans_fun1 trans_fun2 k1 k2\n       (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)\n       (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)\""], ["", "lemma Equiv_Exec_equiv_statesI: \"\n  \\<lbrakk> equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec\n      m equiv_states\n        localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 (f_Exec_Comp trans_fun1 (input_fun1 m # \\<NoMsg>\\<^bsup>k1 - Suc 0\\<^esup>) c1))\n    (localState2 (f_Exec_Comp trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec m equiv_states localState1 localState2 input_fun1 input_fun2\n      output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (input_fun1 m # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                           c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (input_fun2 m # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                           c2))", "by (simp add: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_output_eqI: \"\n  \\<lbrakk> equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec\n      m equiv_states\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  last_message (map output_fun1 (\n    f_Exec_Comp_Stream trans_fun1 (input_fun1 m # \\<NoMsg>\\<^bsup>k1 - Suc 0\\<^esup>) c1)) =\n  last_message (map output_fun2 (\n    f_Exec_Comp_Stream trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec m equiv_states localState1 localState2 input_fun1 input_fun2\n      output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (input_fun1 m # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                           c1)) =\n                      last_message\n                       (map output_fun2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (input_fun2 m # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                           c2))", "by (simp add: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_equiv_statesI': \"\n  \\<lbrakk> equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec\n      m equiv_states\n        localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n   (localState1 (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup> (trans_fun1 (input_fun1 m) c1)))\n   (localState2 (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup> (trans_fun2 (input_fun2 m) c2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec m equiv_states localState1 localState2 input_fun1 input_fun2\n      output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                           (trans_fun1 (input_fun1 m) c1)))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                           (trans_fun2 (input_fun2 m) c2)))", "by (simp add: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_le1: \"\n  \\<lbrakk> k1 \\<le> Suc 0; k2 \\<le> Suc 0;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec m\n      equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  output_fun1 (trans_fun1 (input_fun1 m) c1) =\n  output_fun2 (trans_fun2 (input_fun2 m) c2) \\<and>\n  equiv_states\n    (localState1 (trans_fun1 (input_fun1 m) c1))\n    (localState2 (trans_fun2 (input_fun2 m) c2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k1 \\<le> Suc 0; k2 \\<le> Suc 0;\n     equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec m equiv_states localState1 localState2 input_fun1 input_fun2\n      output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2\\<rbrakk>\n    \\<Longrightarrow> output_fun1 (trans_fun1 (input_fun1 m) c1) =\n                      output_fun2 (trans_fun2 (input_fun2 m) c2) \\<and>\n                      equiv_states\n                       (localState1 (trans_fun1 (input_fun1 m) c1))\n                       (localState2 (trans_fun2 (input_fun2 m) c2))", "by (simp add: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_stable_set_UNIV: \"\n  Equiv_Exec_stable_set\n    UNIV equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 =\n  Equiv_Exec_stable\n    equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equiv_Exec_stable_set UNIV equiv_states localState1 localState2\n     input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n     k2 c1 c2 =\n    Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n     input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2", "by (simp add: Equiv_Exec_stable_set_def Equiv_Exec_stable_def)"], ["", "lemma Equiv_Exec_stable_setI: \"\n  \\<lbrakk> Equiv_Exec_stable_set A\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2;\n    set input \\<subseteq> A; m \\<in> A \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n        m equiv_states\n        localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n        trans_fun1 trans_fun2 k1 k2\n        (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)\n        (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Equiv_Exec_stable_set A equiv_states localState1 localState2\n              input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1\n              trans_fun2 k1 k2 c1 c2;\n     set input \\<subseteq> A; m \\<in> A\\<rbrakk>\n    \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                       input_fun1 input_fun2 output_fun1 output_fun2\n                       trans_fun1 trans_fun2 k1 k2\n                       (f_Exec_Comp trans_fun1\n                         (map input_fun1 input \\<odot> k1) c1)\n                       (f_Exec_Comp trans_fun2\n                         (map input_fun2 input \\<odot> k2) c2)", "by (simp add: Equiv_Exec_stable_set_def)"], ["", "lemma Equiv_Exec_stableI: \"\n  Equiv_Exec_stable\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 \\<Longrightarrow>\n  Equiv_Exec m\n    equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2\n    (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)\n    (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n     input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n     c2 \\<Longrightarrow>\n    Equiv_Exec m equiv_states localState1 localState2 input_fun1 input_fun2\n     output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n     (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n     (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2)", "by (simp add: Equiv_Exec_stable_def)"], ["", "text \\<open>Reflexitity, symmetry and transitivity results for @{term \"Equiv_Exec\"}\\<close>"], ["", "lemma Equiv_Exec_refl: \"\n  \\<lbrakk> \\<And>c. equiv_states (localState c) (localState c) \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n    m equiv_states\n    localState localState input_fun input_fun output_fun output_fun\n    trans_fun trans_fun k k c c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. equiv_states (localState c) (localState c)) \\<Longrightarrow>\n    Equiv_Exec m equiv_states localState localState input_fun input_fun\n     output_fun output_fun trans_fun trans_fun k k c c", "by (simp add: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_sym[rule_format]: \"\n  \\<lbrakk> \\<forall>c1 c2.\n      equiv_states (localState1 c1) (localState2 c2) =\n      equiv_states (localState2 c2) (localState1 c1) \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n    m equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 =\n  Equiv_Exec\n    m equiv_states\n    localState2 localState1 input_fun2 input_fun1 output_fun2 output_fun1\n    trans_fun2 trans_fun1 k2 k1 c2 c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c1 c2.\n       equiv_states (localState1 c1) (localState2 c2) =\n       equiv_states (localState2 c2) (localState1 c1) \\<Longrightarrow>\n    Equiv_Exec m equiv_states localState1 localState2 input_fun1 input_fun2\n     output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2 =\n    Equiv_Exec m equiv_states localState2 localState1 input_fun2 input_fun1\n     output_fun2 output_fun1 trans_fun2 trans_fun1 k2 k1 c2 c1", "by (fastforce simp: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_sym2: \"\n  \\<lbrakk> equiv_states_sym = (\\<lambda>s1 s2. equiv_states s2 s1) \\<rbrakk> \\<Longrightarrow>\n  Equiv_Exec\n    m equiv_states\n    localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n    trans_fun1 trans_fun2 k1 k2 c1 c2 =\n  Equiv_Exec\n    m equiv_states_sym\n    localState2 localState1 input_fun2 input_fun1 output_fun2 output_fun1\n    trans_fun2 trans_fun1 k2 k1 c2 c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_states_sym =\n    (\\<lambda>s1 s2. equiv_states s2 s1) \\<Longrightarrow>\n    Equiv_Exec m equiv_states localState1 localState2 input_fun1 input_fun2\n     output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2 =\n    Equiv_Exec m equiv_states_sym localState2 localState1 input_fun2\n     input_fun1 output_fun2 output_fun1 trans_fun2 trans_fun1 k2 k1 c2 c1", "by (fastforce simp: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_sym2_ex: \"\n  \\<exists>equiv_states_sym.\n    Equiv_Exec\n      m equiv_states\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2 =\n    Equiv_Exec\n      m equiv_states_sym\n      localState2 localState1 input_fun2 input_fun1 output_fun2 output_fun1\n      trans_fun2 trans_fun1 k2 k1 c2 c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>equiv_states_sym.\n       Equiv_Exec m equiv_states localState1 localState2 input_fun1\n        input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n        c2 =\n       Equiv_Exec m equiv_states_sym localState2 localState1 input_fun2\n        input_fun1 output_fun2 output_fun1 trans_fun2 trans_fun1 k2 k1 c2 c1", "by (rule exI, rule Equiv_Exec_sym2, simp)"], ["", "lemma Equiv_Exec_trans: \"\n  \\<lbrakk> Equiv_Exec\n      m equiv_states12\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n    Equiv_Exec\n      m equiv_states23\n      localState2 localState3 input_fun2 input_fun3 output_fun2 output_fun3\n      trans_fun2 trans_fun3 k2 k3 c2 c3;\n    equiv_states13 = (\\<lambda>s1 s3. (\n      if s1 = localState1 c1 \\<and> s3 = localState3 c3 then\n        equiv_states12 s1 (localState2 c2) \\<and>\n        equiv_states23 (localState2 c2) s3\n      else\n        equiv_states12 s1 (\n          localState2 (f_Exec_Comp trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2))) \\<and>\n        equiv_states23 (\n          localState2 (f_Exec_Comp trans_fun2 (input_fun2 m # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2)) s3) \\<rbrakk> \\<Longrightarrow>\n    Equiv_Exec\n      m equiv_states13\n      localState1 localState3 input_fun1 input_fun3 output_fun1 output_fun3\n      trans_fun1 trans_fun3 k1 k3 c1 c3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Equiv_Exec m equiv_states12 localState1 localState2 input_fun1\n              input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n              c1 c2;\n     Equiv_Exec m equiv_states23 localState2 localState3 input_fun2\n      input_fun3 output_fun2 output_fun3 trans_fun2 trans_fun3 k2 k3 c2 c3;\n     equiv_states13 =\n     (\\<lambda>s1 s3.\n         (if s1 = localState1 c1 \\<and> s3 = localState3 c3\n          then equiv_states12 s1 (localState2 c2) \\<and>\n               equiv_states23 (localState2 c2) s3\n          else equiv_states12 s1\n                (localState2\n                  (f_Exec_Comp trans_fun2\n                    (input_fun2 m # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                    c2))) \\<and>\n         equiv_states23\n          (localState2\n            (f_Exec_Comp trans_fun2\n              (input_fun2 m # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2))\n          s3)\\<rbrakk>\n    \\<Longrightarrow> Equiv_Exec m equiv_states13 localState1 localState3\n                       input_fun1 input_fun3 output_fun1 output_fun3\n                       trans_fun1 trans_fun3 k1 k3 c1 c3", "by (fastforce simp: Equiv_Exec_def)"], ["", "lemma Equiv_Exec_trans_ex: \"\n  \\<lbrakk> Equiv_Exec\n      m equiv_states12\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n    Equiv_Exec\n      m equiv_states23\n      localState2 localState3 input_fun2 input_fun3 output_fun2 output_fun3\n      trans_fun2 trans_fun3 k2 k3 c2 c3 \\<rbrakk> \\<Longrightarrow>\n    \\<exists>equiv_states13. Equiv_Exec\n      m equiv_states13\n      localState1 localState3 input_fun1 input_fun3 output_fun1 output_fun3\n      trans_fun1 trans_fun3 k1 k3 c1 c3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Equiv_Exec m equiv_states12 localState1 localState2 input_fun1\n              input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n              c1 c2;\n     Equiv_Exec m equiv_states23 localState2 localState3 input_fun2\n      input_fun3 output_fun2 output_fun3 trans_fun2 trans_fun3 k2 k3 c2\n      c3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>equiv_states13.\n                         Equiv_Exec m equiv_states13 localState1 localState3\n                          input_fun1 input_fun3 output_fun1 output_fun3\n                          trans_fun1 trans_fun3 k1 k3 c1 c3", "by (blast intro: Equiv_Exec_trans)"], ["", "text \\<open>A predicate indicating for\n  a given local state extraction function and\n  a given transition function,\n  that components, whose states are equal with regard to the\n  local state extraction function,\n  are transformed into equal componenents,\n  when the transition function is applied with the same input.\\<close>"], ["", "definition Exec_Equal_State ::\n    \"('comp, 'state) Comp_Local_State \\<Rightarrow> ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow> bool\"\n  where \"Exec_Equal_State localState trans_fun \\<equiv>\n    \\<forall>c1 c2 m. localState c1 = localState c2 \\<longrightarrow> trans_fun m c1 = trans_fun m c2\""], ["", "lemma Exec_Equal_StateD: \"\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  trans_fun m c1 = trans_fun m c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Exec_Equal_State localState trans_fun;\n     localState c1 = localState c2\\<rbrakk>\n    \\<Longrightarrow> trans_fun m c1 = trans_fun m c2", "by (unfold Exec_Equal_State_def, blast)"], ["", "lemma Exec_Equal_StateD': \"\n  Exec_Equal_State localState trans_fun \\<Longrightarrow>\n  \\<forall>c1 c2 m. localState c1 = localState c2 \\<longrightarrow> trans_fun m c1 = trans_fun m c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Exec_Equal_State localState trans_fun \\<Longrightarrow>\n    \\<forall>c1 c2 m.\n       localState c1 = localState c2 \\<longrightarrow>\n       trans_fun m c1 = trans_fun m c2", "by (unfold Exec_Equal_State_def, blast)"], ["", "lemma Exec_Equal_StateI: \"\n  (\\<And>c1 c2 m. localState c1 = localState c2 \\<Longrightarrow> trans_fun m c1 = trans_fun m c2)\n  \\<Longrightarrow> Exec_Equal_State localState trans_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1 c2 m.\n        localState c1 = localState c2 \\<Longrightarrow>\n        trans_fun m c1 = trans_fun m c2) \\<Longrightarrow>\n    Exec_Equal_State localState trans_fun", "by (unfold Exec_Equal_State_def, blast)"], ["", "lemma f_Exec_Equal_State: \"\\<And>c1 c2.\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp trans_fun xs c1 = f_Exec_Comp trans_fun xs c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                         f_Exec_Comp trans_fun xs c2", "apply (induct xs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>Exec_Equal_State localState trans_fun;\n                    localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                                     f_Exec_Comp trans_fun xs c2;\n        Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2", "apply (case_tac \"xs = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>Exec_Equal_State localState trans_fun;\n                    localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                                     f_Exec_Comp trans_fun xs c2;\n        Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; a # xs \\<noteq> []; xs = []\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2\n 2. \\<And>a xs c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>Exec_Equal_State localState trans_fun;\n                    localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                                     f_Exec_Comp trans_fun xs c2;\n        Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; a # xs \\<noteq> [];\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c1 c2.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; xs = []\\<rbrakk>\n       \\<Longrightarrow> trans_fun a c1 = trans_fun a c2\n 2. \\<And>a xs c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>Exec_Equal_State localState trans_fun;\n                    localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                                     f_Exec_Comp trans_fun xs c2;\n        Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; a # xs \\<noteq> [];\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2", "apply (rule Exec_Equal_StateD, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>Exec_Equal_State localState trans_fun;\n                    localState c1 = localState c2; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> f_Exec_Comp trans_fun xs c1 =\n                                     f_Exec_Comp trans_fun xs c2;\n        Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; a # xs \\<noteq> [];\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2", "apply (drule_tac x=\"trans_fun a c1\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c1 c2.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; a # xs \\<noteq> []; xs \\<noteq> [];\n        \\<And>c2.\n           \\<lbrakk>Exec_Equal_State localState trans_fun;\n            localState (trans_fun a c1) = localState c2;\n            xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> f_Exec_Comp trans_fun xs (trans_fun a c1) =\n                             f_Exec_Comp trans_fun xs c2\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2", "apply (drule_tac x=\"trans_fun a c2\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c1 c2.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; a # xs \\<noteq> []; xs \\<noteq> [];\n        \\<lbrakk>Exec_Equal_State localState trans_fun;\n         localState (trans_fun a c1) = localState (trans_fun a c2);\n         xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> f_Exec_Comp trans_fun xs (trans_fun a c1) =\n                          f_Exec_Comp trans_fun xs (trans_fun a c2)\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2", "apply (drule_tac ?c1.0=c1 and ?c2.0=c2 and m=a in Exec_Equal_StateD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c1 c2.\n       \\<lbrakk>localState c1 = localState c2; a # xs \\<noteq> [];\n        xs \\<noteq> [];\n        \\<lbrakk>Exec_Equal_State localState trans_fun;\n         localState (trans_fun a c1) = localState (trans_fun a c2);\n         xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> f_Exec_Comp trans_fun xs (trans_fun a c1) =\n                          f_Exec_Comp trans_fun xs (trans_fun a c2);\n        trans_fun a c1 = trans_fun a c2\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (a # xs) c1 =\n                         f_Exec_Comp trans_fun (a # xs) c2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Equal_State: \"\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream trans_fun xs c1 =\n  f_Exec_Comp_Stream trans_fun xs c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Exec_Equal_State localState trans_fun;\n     localState c1 = localState c2\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream trans_fun xs c1 =\n                      f_Exec_Comp_Stream trans_fun xs c2", "apply (clarsimp simp: list_eq_iff f_Exec_Stream_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; i < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (xs \\<down> Suc i) c1 =\n                         f_Exec_Comp trans_fun (xs \\<down> Suc i) c2", "apply (drule gr_implies_gr0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (xs \\<down> Suc i) c1 =\n                         f_Exec_Comp trans_fun (xs \\<down> Suc i) c2", "apply (rule f_Exec_Equal_State)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State (?localState7 i) trans_fun\n 2. \\<And>i.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> ?localState7 i c1 = ?localState7 i c2\n 3. \\<And>i.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i \\<noteq> []", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Equal_State: \"\n  \\<lbrakk> Exec_Equal_State localState trans_fun;\n    localState c1 = localState c2 \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream trans_fun input c1 =\n  i_Exec_Comp_Stream trans_fun input c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Exec_Equal_State localState trans_fun;\n     localState c1 = localState c2\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream trans_fun input c1 =\n                      i_Exec_Comp_Stream trans_fun input c2", "apply (clarsimp simp: ilist_eq_iff i_Exec_Stream_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp trans_fun (input \\<Down> Suc x) c1 =\n                         f_Exec_Comp trans_fun (input \\<Down> Suc x) c2", "apply (rule f_Exec_Equal_State)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State (?localState1 x) trans_fun\n 2. \\<And>x.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> ?localState1 x c1 = ?localState1 x c2\n 3. \\<And>x.\n       \\<lbrakk>Exec_Equal_State localState trans_fun;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> input \\<Down> Suc x \\<noteq> []", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Idle states\\<close>"], ["", "definition State_Idle ::\n  \"('comp, 'state) Comp_Local_State \\<Rightarrow> ('comp \\<Rightarrow> 'output message_af) \\<Rightarrow>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  where \"State_Idle localState output_fun trans_fun state \\<equiv>\n    \\<forall>c. localState c = state \\<longrightarrow>\n      localState (trans_fun \\<NoMsg> c) = state \\<and>\n      output_fun (trans_fun \\<NoMsg> c) = \\<NoMsg>\""], ["", "lemma State_IdleD: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun state;\n    localState c = state \\<rbrakk> \\<Longrightarrow>\n  localState (trans_fun \\<NoMsg> c) = state \\<and>\n  output_fun (trans_fun \\<NoMsg> c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun state;\n     localState c = state\\<rbrakk>\n    \\<Longrightarrow> localState (trans_fun NoMsg c) = state \\<and>\n                      output_fun (trans_fun NoMsg c) = NoMsg", "by (unfold State_Idle_def, blast)"], ["", "lemma State_IdleD': \"\n  State_Idle localState output_fun trans_fun state \\<Longrightarrow>\n  \\<forall>c. localState c = state \\<longrightarrow>\n  localState (trans_fun \\<NoMsg> c) = state \\<and>\n  output_fun (trans_fun \\<NoMsg> c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Idle localState output_fun trans_fun state \\<Longrightarrow>\n    \\<forall>c.\n       localState c = state \\<longrightarrow>\n       localState (trans_fun NoMsg c) = state \\<and>\n       output_fun (trans_fun NoMsg c) = NoMsg", "by (unfold State_Idle_def, blast)"], ["", "lemma State_IdleI: \"\n  \\<lbrakk> \\<And>c. localState c = state \\<Longrightarrow>\n    localState (trans_fun \\<NoMsg> c) = state \\<and>\n    output_fun (trans_fun \\<NoMsg> c) = \\<NoMsg> \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        localState c = state \\<Longrightarrow>\n        localState (trans_fun NoMsg c) = state \\<and>\n        output_fun (trans_fun NoMsg c) = NoMsg) \\<Longrightarrow>\n    State_Idle localState output_fun trans_fun state", "by (unfold State_Idle_def, blast)"], ["", "lemma State_Idle_step[rule_format]: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c) \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun (localState (trans_fun \\<NoMsg> c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Idle localState output_fun trans_fun\n     (localState c) \\<Longrightarrow>\n    State_Idle localState output_fun trans_fun\n     (localState (trans_fun NoMsg c))", "apply (frule State_IdleD[OF _ refl], erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun (localState c);\n     localState (trans_fun NoMsg c) = localState c;\n     output_fun (trans_fun NoMsg c) = NoMsg\\<rbrakk>\n    \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                       (localState (trans_fun NoMsg c))", "apply (rule State_IdleI, rename_tac c0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c0.\n       \\<lbrakk>State_Idle localState output_fun trans_fun (localState c);\n        localState (trans_fun NoMsg c) = localState c;\n        output_fun (trans_fun NoMsg c) = NoMsg;\n        localState c0 = localState (trans_fun NoMsg c)\\<rbrakk>\n       \\<Longrightarrow> localState (trans_fun NoMsg c0) =\n                         localState (trans_fun NoMsg c) \\<and>\n                         output_fun (trans_fun NoMsg c0) = NoMsg", "apply (drule_tac c=c0 in State_IdleD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c0.\n       \\<lbrakk>localState (trans_fun NoMsg c) = localState c;\n        output_fun (trans_fun NoMsg c) = NoMsg;\n        localState c0 = localState (trans_fun NoMsg c)\\<rbrakk>\n       \\<Longrightarrow> localState c0 = localState c\n 2. \\<And>c0.\n       \\<lbrakk>localState (trans_fun NoMsg c) = localState c;\n        output_fun (trans_fun NoMsg c) = NoMsg;\n        localState c0 = localState (trans_fun NoMsg c);\n        localState (trans_fun NoMsg c0) = localState c \\<and>\n        output_fun (trans_fun NoMsg c0) = NoMsg\\<rbrakk>\n       \\<Longrightarrow> localState (trans_fun NoMsg c0) =\n                         localState (trans_fun NoMsg c) \\<and>\n                         output_fun (trans_fun NoMsg c0) = NoMsg", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_State_Idle_replicate_NoMsg_state[rule_format]: \"\n  \\<And>c. State_Idle localState output_fun trans_fun (localState c) \\<Longrightarrow>\n  localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = localState c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       State_Idle localState output_fun trans_fun\n        (localState c) \\<Longrightarrow>\n       localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n       localState c", "apply (induct n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   State_Idle localState output_fun trans_fun\n                    (localState c) \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                   localState c;\n        State_Idle localState output_fun trans_fun (localState c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         localState c", "apply (frule State_Idle_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   State_Idle localState output_fun trans_fun\n                    (localState c) \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                   localState c;\n        State_Idle localState output_fun trans_fun (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (trans_fun NoMsg c))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         localState c", "apply (drule_tac c=c in State_IdleD, rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   State_Idle localState output_fun trans_fun\n                    (localState c) \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                   localState c;\n        State_Idle localState output_fun trans_fun\n         (localState (trans_fun NoMsg c));\n        localState (trans_fun NoMsg c) = localState c \\<and>\n        output_fun (trans_fun NoMsg c) = NoMsg\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         localState c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_State_Idle_replicate_NoMsg_gr0_output[rule_format]: \"\\<And>c.\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c); 0 < n \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>State_Idle localState output_fun trans_fun (localState c);\n        0 < n\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                         NoMsg", "apply (induct n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>State_Idle localState output_fun trans_fun\n                             (localState c);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> output_fun\n(f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                                     NoMsg;\n        State_Idle localState output_fun trans_fun (localState c);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         NoMsg", "apply (case_tac \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>State_Idle localState output_fun trans_fun\n                             (localState c);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> output_fun\n(f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                                     NoMsg;\n        State_Idle localState output_fun trans_fun (localState c);\n        0 < Suc n; n = 0\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         NoMsg\n 2. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>State_Idle localState output_fun trans_fun\n                             (localState c);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> output_fun\n(f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                                     NoMsg;\n        State_Idle localState output_fun trans_fun (localState c);\n        0 < Suc n; n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         NoMsg", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n c.\n       \\<lbrakk>State_Idle localState output_fun trans_fun (localState c);\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> output_fun (trans_fun NoMsg c) = NoMsg\n 2. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>State_Idle localState output_fun trans_fun\n                             (localState c);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> output_fun\n(f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                                     NoMsg;\n        State_Idle localState output_fun trans_fun (localState c);\n        0 < Suc n; n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         NoMsg", "apply (rule State_IdleD[THEN conjunct2], assumption, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>State_Idle localState output_fun trans_fun\n                             (localState c);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> output_fun\n(f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                                     NoMsg;\n        State_Idle localState output_fun trans_fun (localState c);\n        0 < Suc n; n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         NoMsg", "apply (drule State_Idle_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>State_Idle localState output_fun trans_fun\n                             (localState c);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> output_fun\n(f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                                     NoMsg;\n        0 < Suc n; n \\<noteq> 0;\n        State_Idle localState output_fun trans_fun\n         (localState (trans_fun NoMsg c))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc n\\<^esup>\n                            c) =\n                         NoMsg", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_State_Idle_replicate_NoMsg_output[rule_format]: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c);\n    output_fun c = \\<NoMsg> \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun (localState c);\n     output_fun c = NoMsg\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                      NoMsg", "apply (case_tac \"n = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun (localState c);\n     output_fun c = NoMsg; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                      NoMsg", "apply (simp add: f_Exec_State_Idle_replicate_NoMsg_gr0_output)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_State_Idle_replicate_NoMsg_output[rule_format]: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (localState c) \\<rbrakk> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\\<^bsup>n\\<^esup>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Idle localState output_fun trans_fun\n     (localState c) \\<Longrightarrow>\n    map output_fun (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n    NoMsg\\<^bsup>n\\<^esup>", "by (simp add: list_eq_iff f_Exec_Stream_nth min_eqL f_Exec_State_Idle_replicate_NoMsg_gr0_output del: replicate.simps)"], ["", "corollary f_Exec_State_Idle_append_replicate_NoMsg_state: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c)) \\<rbrakk> \\<Longrightarrow>\n  localState (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c) =\n  localState (f_Exec_Comp trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Idle localState output_fun trans_fun\n     (localState (f_Exec_Comp trans_fun xs c)) \\<Longrightarrow>\n    localState (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>n\\<^esup>) c) =\n    localState (f_Exec_Comp trans_fun xs c)", "by (simp add: f_Exec_append f_Exec_State_Idle_replicate_NoMsg_state)"], ["", "corollary f_Exec_State_Idle_append_replicate_NoMsg_ge_state: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>m\\<^esup>) c));\n    m \\<le> n \\<rbrakk> \\<Longrightarrow>\n  localState (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c) =\n  localState (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>m\\<^esup>) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState\n                (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c));\n     m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> localState\n                       (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>n\\<^esup>)\n                         c) =\n                      localState\n                       (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>)\n                         c)", "apply (rule_tac t=n and s=\"m + (n - m)\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState\n                (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c));\n     m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> localState\n                       (f_Exec_Comp trans_fun\n                         (xs @ NoMsg\\<^bsup>m + (n - m)\\<^esup>) c) =\n                      localState\n                       (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>)\n                         c)", "apply (simp only: replicate_add append_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState\n                (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c));\n     m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> localState\n                       (f_Exec_Comp trans_fun\n                         ((xs @ NoMsg\\<^bsup>m\\<^esup>) @\n                          NoMsg\\<^bsup>n - m\\<^esup>)\n                         c) =\n                      localState\n                       (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>)\n                         c)", "apply (rule f_Exec_State_Idle_append_replicate_NoMsg_state, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Exec_State_Idle_replicate_NoMsg_ge_state: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>m\\<^esup> c));\n    m \\<le> n \\<rbrakk> \\<Longrightarrow>\n  localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) =\n  localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>m\\<^esup> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>m\\<^esup> c));\n     m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> localState\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                      localState\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>m\\<^esup> c)", "by (cut_tac f_Exec_State_Idle_append_replicate_NoMsg_ge_state[where xs=\"[]\"], simp+)"], ["", "corollary f_Exec_State_Idle_append_replicate_NoMsg_gr0_output: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c));\n    0 < n \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (f_Exec_Comp trans_fun xs c));\n     0 < n\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>n\\<^esup>)\n                         c) =\n                      NoMsg", "by (simp add: f_Exec_append f_Exec_State_Idle_replicate_NoMsg_gr0_output)"], ["", "corollary f_Exec_Stream_State_Idle_append_replicate_NoMsg_gr0_output: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c)) \\<rbrakk> \\<Longrightarrow>\n  map output_fun (f_Exec_Comp_Stream trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c) =\n  map output_fun (f_Exec_Comp_Stream trans_fun xs c) @ \\<NoMsg>\\<^bsup>n\\<^esup>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Idle localState output_fun trans_fun\n     (localState (f_Exec_Comp trans_fun xs c)) \\<Longrightarrow>\n    map output_fun\n     (f_Exec_Comp_Stream trans_fun (xs @ NoMsg\\<^bsup>n\\<^esup>) c) =\n    map output_fun (f_Exec_Comp_Stream trans_fun xs c) @\n    NoMsg\\<^bsup>n\\<^esup>", "by (simp add: f_Exec_Stream_append f_Exec_Stream_State_Idle_replicate_NoMsg_output)"], ["", "corollary f_Exec_State_Idle_append_replicate_NoMsg_gr_output: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>m\\<^esup>) c));\n    m < n \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState\n                (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c));\n     m < n\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>n\\<^esup>)\n                         c) =\n                      NoMsg", "apply (rule_tac t=n and s=\"m + (n - m)\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState\n                (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c));\n     m < n\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun\n                         (xs @ NoMsg\\<^bsup>m + (n - m)\\<^esup>) c) =\n                      NoMsg", "apply (simp only: replicate_add append_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState\n                (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c));\n     m < n\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun\n                         ((xs @ NoMsg\\<^bsup>m\\<^esup>) @\n                          NoMsg\\<^bsup>n - m\\<^esup>)\n                         c) =\n                      NoMsg", "apply (rule f_Exec_State_Idle_append_replicate_NoMsg_gr0_output, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Exec_State_Idle_append_replicate_NoMsg_ge_output: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>m\\<^esup>) c));\n    output_fun (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>m\\<^esup>) c) = \\<NoMsg>; m \\<le> n \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState\n                (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c));\n     output_fun (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>m\\<^esup>) c) =\n     NoMsg;\n     m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun (xs @ NoMsg\\<^bsup>n\\<^esup>)\n                         c) =\n                      NoMsg", "by (fastforce simp: order_le_less f_Exec_State_Idle_append_replicate_NoMsg_gr_output)"], ["", "corollary f_Exec_State_Idle_replicate_NoMsg_gr_output: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>m\\<^esup> c));\n    m < n \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>m\\<^esup> c));\n     m < n\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                      NoMsg", "by (cut_tac xs=\"[]\" in f_Exec_State_Idle_append_replicate_NoMsg_gr_output, simp+)"], ["", "corollary f_Exec_State_Idle_replicate_NoMsg_ge_output: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>m\\<^esup> c));\n    output_fun (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>m\\<^esup> c) = \\<NoMsg>; m \\<le> n \\<rbrakk> \\<Longrightarrow>\n  output_fun (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c) = \\<NoMsg>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>m\\<^esup> c));\n     output_fun (f_Exec_Comp trans_fun NoMsg\\<^bsup>m\\<^esup> c) = NoMsg;\n     m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> output_fun\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c) =\n                      NoMsg", "by (fastforce simp: order_le_less f_Exec_State_Idle_replicate_NoMsg_gr_output)"], ["", "lemma State_Idle_append_replicate_NoMsg_output_last_message: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c)) \\<rbrakk> \\<Longrightarrow>\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c)) =\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun xs c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Idle localState output_fun trans_fun\n     (localState (f_Exec_Comp trans_fun xs c)) \\<Longrightarrow>\n    last_message\n     (map output_fun\n       (f_Exec_Comp_Stream trans_fun (xs @ NoMsg\\<^bsup>n\\<^esup>) c)) =\n    last_message (map output_fun (f_Exec_Comp_Stream trans_fun xs c))", "by (simp add: f_Exec_Stream_State_Idle_append_replicate_NoMsg_gr0_output last_message_append_replicate_NoMsg)"], ["", "lemma State_Idle_append_replicate_NoMsg_output_Msg_eq_last_message: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c));\n    output_fun (f_Exec_Comp trans_fun xs c) \\<noteq> \\<NoMsg>;\n    xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun (xs @ \\<NoMsg>\\<^bsup>n\\<^esup>) c)) =\n  output_fun (f_Exec_Comp trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (f_Exec_Comp trans_fun xs c));\n     output_fun (f_Exec_Comp trans_fun xs c) \\<noteq> NoMsg;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs @ NoMsg\\<^bsup>n\\<^esup>) c)) =\n                      output_fun (f_Exec_Comp trans_fun xs c)", "apply (simp add: State_Idle_append_replicate_NoMsg_output_last_message f_Exec_eq_f_Exec_Stream_last2 )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (last (f_Exec_Comp_Stream trans_fun xs c)));\n     output_fun (last (f_Exec_Comp_Stream trans_fun xs c)) \\<noteq> NoMsg;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun xs c)) =\n                      output_fun (last (f_Exec_Comp_Stream trans_fun xs c))", "apply (subst last_message_Msg_eq_last)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (last (f_Exec_Comp_Stream trans_fun xs c)));\n     output_fun (last (f_Exec_Comp_Stream trans_fun xs c)) \\<noteq> NoMsg;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> map output_fun\n                       (f_Exec_Comp_Stream trans_fun xs c) \\<noteq>\n                      []\n 2. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (last (f_Exec_Comp_Stream trans_fun xs c)));\n     output_fun (last (f_Exec_Comp_Stream trans_fun xs c)) \\<noteq> NoMsg;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun xs c)) \\<noteq>\n                      NoMsg\n 3. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (last (f_Exec_Comp_Stream trans_fun xs c)));\n     output_fun (last (f_Exec_Comp_Stream trans_fun xs c)) \\<noteq> NoMsg;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun xs c)) =\n                      output_fun (last (f_Exec_Comp_Stream trans_fun xs c))", "apply (simp add: map_last f_Exec_Stream_not_empty_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary State_Idle_output_Msg_eq_last_message: \"\n  \\<lbrakk> State_Idle localState output_fun trans_fun (\n      localState (f_Exec_Comp trans_fun xs c));\n    output_fun (f_Exec_Comp trans_fun xs c) \\<noteq> \\<NoMsg>;\n    xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun xs c)) =\n  output_fun (f_Exec_Comp trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>State_Idle localState output_fun trans_fun\n              (localState (f_Exec_Comp trans_fun xs c));\n     output_fun (f_Exec_Comp trans_fun xs c) \\<noteq> NoMsg;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun xs c)) =\n                      output_fun (f_Exec_Comp trans_fun xs c)", "by (rule_tac n=0 in subst[OF State_Idle_append_replicate_NoMsg_output_Msg_eq_last_message, rule_format], simp+)"], ["", "lemma State_Idle_imp_exists_state_change: \"\n  \\<lbrakk> \\<not> State_Idle localState output_fun trans_fun (localState c);\n    State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c)) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>i<n. (\n    \\<not> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>i\\<^esup> c)) \\<and> (\n    \\<forall>j\\<le>n. i < j \\<longrightarrow> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>j\\<^esup> c))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                     (localState c);\n     State_Idle localState output_fun trans_fun\n      (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n.\n                         \\<not> State_Idle localState output_fun trans_fun\n                                 (localState\n                                   (f_Exec_Comp trans_fun\n                                     NoMsg\\<^bsup>i\\<^esup> c)) \\<and>\n                         (\\<forall>j\\<le>n.\n                             i < j \\<longrightarrow>\n                             State_Idle localState output_fun trans_fun\n                              (localState\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>j\\<^esup> c)))", "apply (cut_tac\n  a=0 and b=n and\n  P=\"\\<lambda>x. State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>x\\<^esup> c))\"\n  in nat_Suc_predicate_change_exists, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                     (localState c);\n     State_Idle localState output_fun trans_fun\n      (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n     \\<exists>na<n.\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>na\\<^esup> c)) \\<and>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>na\\<^esup>\n             (trans_fun NoMsg c)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n.\n                         \\<not> State_Idle localState output_fun trans_fun\n                                 (localState\n                                   (f_Exec_Comp trans_fun\n                                     NoMsg\\<^bsup>i\\<^esup> c)) \\<and>\n                         (\\<forall>j\\<le>n.\n                             i < j \\<longrightarrow>\n                             State_Idle localState output_fun trans_fun\n                              (localState\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>j\\<^esup> c)))", "apply (clarify, rename_tac n1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1.\n       \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                        (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n        n1 < n;\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup> c));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup>\n             (trans_fun NoMsg c)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<n.\n                            \\<not> State_Idle localState output_fun\n                                    trans_fun\n                                    (localState\n(f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c)) \\<and>\n                            (\\<forall>j\\<le>n.\n                                i < j \\<longrightarrow>\n                                State_Idle localState output_fun trans_fun\n                                 (localState\n                                   (f_Exec_Comp trans_fun\n                                     NoMsg\\<^bsup>j\\<^esup> c)))", "apply (rule_tac x=n1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1.\n       \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                        (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n        n1 < n;\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup> c));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup>\n             (trans_fun NoMsg c)))\\<rbrakk>\n       \\<Longrightarrow> n1 < n \\<and>\n                         \\<not> State_Idle localState output_fun trans_fun\n                                 (localState\n                                   (f_Exec_Comp trans_fun\n                                     NoMsg\\<^bsup>n1\\<^esup> c)) \\<and>\n                         (\\<forall>j\\<le>n.\n                             n1 < j \\<longrightarrow>\n                             State_Idle localState output_fun trans_fun\n                              (localState\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>j\\<^esup> c)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1 j.\n       \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                        (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup> c));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup>\n             (trans_fun NoMsg c)));\n        j \\<le> n; n1 < j\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun NoMsg\\<^bsup>j\\<^esup>\n                              c))", "apply (rule_tac t=\"j\" and s=\"Suc n1 + (j - Suc n1)\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1 j.\n       \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                        (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup> c));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup>\n             (trans_fun NoMsg c)));\n        j \\<le> n; n1 < j\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>Suc n1 + (j - Suc n1)\\<^esup> c))", "apply (subst replicate_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1 j.\n       \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                        (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup> c));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>n1\\<^esup>\n             (trans_fun NoMsg c)));\n        j \\<le> n; n1 < j\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (NoMsg\\<^bsup>Suc n1\\<^esup> @\n                               NoMsg\\<^bsup>j - Suc n1\\<^esup>)\n                              c))", "apply (simp add: replicate_add f_Exec_State_Idle_append_replicate_NoMsg_state)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma State_Idle_imp_exists_state_change2: \"\n  \\<lbrakk> \\<not> State_Idle localState output_fun trans_fun (localState c);\n    State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>n\\<^esup> c)) \\<rbrakk> \\<Longrightarrow>\n  \\<exists>i<n. (\n    (\\<forall>j\\<le>i. \\<not> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>i\\<^esup> c))) \\<and>\n    (\\<forall>j\\<le>n. i < j \\<longrightarrow> State_Idle localState output_fun trans_fun (localState (f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>j\\<^esup> c))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                     (localState c);\n     State_Idle localState output_fun trans_fun\n      (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n.\n                         (\\<forall>j\\<le>i.\n                             \\<not> State_Idle localState output_fun\n                                     trans_fun\n                                     (localState\n (f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c))) \\<and>\n                         (\\<forall>j\\<le>n.\n                             i < j \\<longrightarrow>\n                             State_Idle localState output_fun trans_fun\n                              (localState\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>j\\<^esup> c)))", "apply (frule State_Idle_imp_exists_state_change, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                     (localState c);\n     State_Idle localState output_fun trans_fun\n      (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n     \\<exists>i<n.\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c)) \\<and>\n        (\\<forall>j\\<le>n.\n            i < j \\<longrightarrow>\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>j\\<^esup> c)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n.\n                         (\\<forall>j\\<le>i.\n                             \\<not> State_Idle localState output_fun\n                                     trans_fun\n                                     (localState\n (f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c))) \\<and>\n                         (\\<forall>j\\<le>n.\n                             i < j \\<longrightarrow>\n                             State_Idle localState output_fun trans_fun\n                              (localState\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>j\\<^esup> c)))", "apply (clarify, rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                        (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n        i < n;\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c));\n        \\<forall>j\\<le>n.\n           i < j \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun NoMsg\\<^bsup>j\\<^esup> c))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<n.\n                            (\\<forall>j\\<le>i.\n                                \\<not> State_Idle localState output_fun\n  trans_fun\n  (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c))) \\<and>\n                            (\\<forall>j\\<le>n.\n                                i < j \\<longrightarrow>\n                                State_Idle localState output_fun trans_fun\n                                 (localState\n                                   (f_Exec_Comp trans_fun\n                                     NoMsg\\<^bsup>j\\<^esup> c)))", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> State_Idle localState output_fun trans_fun\n                        (localState c);\n        State_Idle localState output_fun trans_fun\n         (localState (f_Exec_Comp trans_fun NoMsg\\<^bsup>n\\<^esup> c));\n        i < n;\n        \\<not> State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c));\n        \\<forall>j\\<le>n.\n           i < j \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun NoMsg\\<^bsup>j\\<^esup> c))\\<rbrakk>\n       \\<Longrightarrow> i < n \\<and>\n                         (\\<forall>j\\<le>i.\n                             \\<not> State_Idle localState output_fun\n                                     trans_fun\n                                     (localState\n (f_Exec_Comp trans_fun NoMsg\\<^bsup>i\\<^esup> c))) \\<and>\n                         (\\<forall>j\\<le>n.\n                             i < j \\<longrightarrow>\n                             State_Idle localState output_fun trans_fun\n                              (localState\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>j\\<^esup> c)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Basic definitions for accelerated execution\\<close>"], ["", "text \\<open>Stream processing with accelerated components\\<close>"], ["", "definition f_Exec_Comp_Stream_Acc_Output ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'output message_af) \\<Rightarrow> \\<comment> \\<open>Output extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    'input fstream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'output fstream_af\"\n  where \"f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<equiv>\n    (map output_fun (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) \\<div>\\<^sub>f k\""], ["", "definition f_Exec_Comp_Stream_Acc_LocalState ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'state) \\<Rightarrow> \\<comment> \\<open>Local state extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    'input fstream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'state list\"\n  where \"f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c \\<equiv>\n    (map localState (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) \\<div>\\<^bsub>fl\\<^esub> k\""], ["", "definition i_Exec_Comp_Stream_Acc_Output ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'output message_af) \\<Rightarrow> \\<comment> \\<open>Output extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    'input istream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'output istream_af\"\n  where \"i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c \\<equiv>\n    (output_fun \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) \\<div>\\<^sub>i k\""], ["", "definition i_Exec_Comp_Stream_Acc_LocalState ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'state) \\<Rightarrow> \\<comment> \\<open>Local state extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    'input istream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'state ilist\"\n  where \"i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c \\<equiv>\n    (localState \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) \\<div>\\<^bsub>il\\<^esub> k\""], ["", "definition f_Exec_Comp_Stream_Acc_Output_Init ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'output message_af) \\<Rightarrow> \\<comment> \\<open>Output extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    'input fstream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'output fstream_af\"\n  where \"f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<equiv>\n    (output_fun c) # f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c\""], ["", "definition f_Exec_Comp_Stream_Acc_LocalState_Init ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'state) \\<Rightarrow> \\<comment> \\<open>Local state extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow> 'input fstream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'state list\"\n  where \"f_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun xs c \\<equiv>\n    (localState c) # f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c\""], ["", "definition i_Exec_Comp_Stream_Acc_Output_Init ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'output message_af) \\<Rightarrow> \\<comment> \\<open>Output extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    'input istream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'output istream_af\"\n  where \"i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c \\<equiv>\n    [output_fun c] \\<frown> (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c)\""], ["", "definition i_Exec_Comp_Stream_Acc_LocalState_Init ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp \\<Rightarrow> 'state) \\<Rightarrow> \\<comment> \\<open>Local state extraction function\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    'input istream_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'state ilist\"\n  where \"i_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun input c \\<equiv>\n    [localState c] \\<frown> (i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c)\""], ["", "lemma f_Exec_Stream_Acc_Output_length[simp]: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    length (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c) =\n    length xs", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def f_shrink_length)"], ["", "lemma f_Exec_Stream_Acc_LocalState_length[simp]: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    length (f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c) =\n    length xs", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_def f_shrink_last_length)"], ["", "lemmas f_Exec_Stream_Acc_length =\n  f_Exec_Stream_Acc_LocalState_length\n  f_Exec_Stream_Acc_Output_length"], ["", "subsubsection \\<open>Basic results for accelerated execution\\<close>"], ["", "lemma f_Exec_Stream_Acc_Output_Nil[simp]: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun [] c = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun [] c = []", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def)"], ["", "lemma f_Exec_Stream_Acc_LocalState_Nil[simp]: \"\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun [] c = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun [] c = []", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_def)"], ["", "lemmas f_Exec_Stream_Acc_Nil =\n  f_Exec_Stream_Acc_LocalState_Nil\n  f_Exec_Stream_Acc_Output_Nil"], ["", "lemma f_Exec_Stream_Acc_Output_0[simp]: \"\n  f_Exec_Comp_Stream_Acc_Output 0 output_fun trans_fun xs c = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output 0 output_fun trans_fun xs c = []", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def)"], ["", "lemma f_Exec_Stream_Acc_LocalState_0[simp]: \"\n  f_Exec_Comp_Stream_Acc_LocalState 0 localState trans_fun xs c = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_LocalState 0 localState trans_fun xs c = []", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_def)"], ["", "lemmas f_Exec_Stream_Acc_0 =\n  f_Exec_Stream_Acc_LocalState_0\n  f_Exec_Stream_Acc_Output_0"], ["", "lemma f_Exec_Stream_Acc_Output_1[simp]: \"\n  f_Exec_Comp_Stream_Acc_Output (Suc 0) output_fun trans_fun xs c =\n  map output_fun (f_Exec_Comp_Stream trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output (Suc 0) output_fun trans_fun xs c =\n    map output_fun (f_Exec_Comp_Stream trans_fun xs c)", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def)"], ["", "lemma f_Exec_Stream_Acc_LocalState_1[simp]: \"\n  f_Exec_Comp_Stream_Acc_LocalState (Suc 0) localState trans_fun xs c =\n  map localState (f_Exec_Comp_Stream trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_LocalState (Suc 0) localState trans_fun xs c =\n    map localState (f_Exec_Comp_Stream trans_fun xs c)", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_def)"], ["", "lemma i_Exec_Stream_Acc_Output_1[simp]: \"\n  i_Exec_Comp_Stream_Acc_Output (Suc 0) output_fun trans_fun input c =\n  output_fun \\<circ> (i_Exec_Comp_Stream trans_fun input c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_Output (Suc 0) output_fun trans_fun input c =\n    output_fun \\<circ> i_Exec_Comp_Stream trans_fun input c", "by (simp add: i_Exec_Comp_Stream_Acc_Output_def)"], ["", "lemma i_Exec_Stream_Acc_LocalState_1[simp]: \"\n  i_Exec_Comp_Stream_Acc_LocalState (Suc 0) localState trans_fun input c =\n  localState \\<circ> (i_Exec_Comp_Stream trans_fun input c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_LocalState (Suc 0) localState trans_fun input c =\n    localState \\<circ> i_Exec_Comp_Stream trans_fun input c", "by (simp add: i_Exec_Comp_Stream_Acc_LocalState_def)"], ["", "lemma f_Exec_Stream_Acc_Output_eq_last_message_hold: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  (map output_fun (f_Exec_Comp_Stream trans_fun (xs \\<odot>\\<^sub>f k) c)) \\<longmapsto>\\<^sub>f k \\<div>\\<^bsub>fl\\<^esub> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n    map output_fun\n     (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c) \\<longmapsto>\n    k \\<div>\\<^sub>l\n    k", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def f_shrink_eq_f_last_message_hold_shrink_last)"], ["", "lemma i_Exec_Stream_Acc_Output_eq_last_message_hold: \"0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  (output_fun \\<circ> (i_Exec_Comp_Stream trans_fun (input \\<odot>\\<^sub>i k) c)) \\<longmapsto>\\<^sub>i k \\<div>\\<^bsub>il\\<^esub> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n    (output_fun \\<circ>\n     i_Exec_Comp_Stream trans_fun (input \\<odot> k) c) \\<longmapsto>\n    k \\<div>\\<^sub>l\n    k", "by (simp add: i_Exec_Comp_Stream_Acc_Output_def i_shrink_eq_i_last_message_hold_shrink_last)"], ["", "lemma f_Exec_Stream_Acc_Output_take: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<down> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<down> n =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<down> n) c", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def f_shrink_def f_Exec_Stream_expand_aggregate_map_take)"], ["", "lemma f_Exec_Stream_Acc_Output_drop: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<up> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<up> n) (\n    f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<up> n =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<up> n)\n     (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k) c)", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def f_shrink_def f_Exec_Stream_expand_aggregate_map_drop)"], ["", "lemma i_Exec_Stream_Acc_Output_take: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c \\<Down> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c \\<Down> n =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Down> n) c", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def i_Exec_Comp_Stream_Acc_Output_def\n  f_shrink_def i_shrink_def i_Exec_Stream_expand_aggregate_map_take)"], ["", "lemma i_Exec_Stream_Acc_Output_drop: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c \\<Up> n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Up> n) (\n    f_Exec_Comp trans_fun (input \\<Down> n \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c \\<Up> n =\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Up> n)\n     (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c)", "by (simp add: i_Exec_Comp_Stream_Acc_Output_def i_shrink_def i_Exec_Stream_expand_aggregate_map_drop)"], ["", "lemma i_Exec_Stream_Acc_LocalState_take: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c \\<Down> n =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c \\<Down>\n    n =\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun\n     (input \\<Down> n) c", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_def i_Exec_Comp_Stream_Acc_LocalState_def\n  f_shrink_last_def i_shrink_last_def i_Exec_Stream_expand_aggregate_map_take)"], ["", "lemma i_Exec_Stream_Acc_LocalState_drop: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c \\<Up> n =\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Up> n) (\n    f_Exec_Comp trans_fun (input \\<Down> n \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c \\<Up>\n    n =\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Up> n)\n     (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c)", "by (simp add: i_Exec_Comp_Stream_Acc_LocalState_def i_shrink_last_def i_Exec_Stream_expand_aggregate_map_drop)"], ["", "lemma f_Exec_Stream_Acc_Output_append: \"\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs @ ys) c =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c @\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c @\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys\n     (f_Exec_Comp trans_fun (xs \\<odot> k) c)", "by (simp only: f_Exec_Comp_Stream_Acc_Output_def f_shrink_def f_Exec_Stream_expand_map_aggregate_append)"], ["", "lemma f_Exec_Stream_Acc_Output_Cons: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (x # xs) c =\n  last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)) #\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (x # xs) c =\n    last_message\n     (map output_fun\n       (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         c)) #\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs\n     (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)", "by (simp only: f_Exec_Comp_Stream_Acc_Output_def f_shrink_def f_Exec_Stream_expand_map_aggregate_Cons)"], ["", "lemma f_Exec_Stream_Acc_Output_one: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun [x] c =\n  [last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun [x] c =\n    [last_message\n      (map output_fun\n        (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n          c))]", "by (simp add: f_Exec_Stream_Acc_Output_Cons)"], ["", "lemma f_Exec_Stream_Acc_Output_snoc: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs @ [x]) c =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c @\n  [last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs @ [x]) c =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c @\n    [last_message\n      (map output_fun\n        (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n          (f_Exec_Comp trans_fun (xs \\<odot> k) c)))]", "by (simp add: f_Exec_Stream_Acc_Output_append f_Exec_Stream_Acc_Output_one)"], ["", "lemma i_Exec_Stream_Acc_Output_append: \"\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (xs \\<frown> input)\n     c =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<frown>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input\n     (f_Exec_Comp trans_fun (xs \\<odot> k) c)", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def i_Exec_Comp_Stream_Acc_Output_def f_shrink_def i_shrink_def i_Exec_Stream_expand_map_aggregate_append)"], ["", "lemma i_Exec_Stream_Acc_Output_Cons: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ([x] \\<frown> input) c =\n  [last_message (map output_fun (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c))] \\<frown>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n     ([x] \\<frown> input) c =\n    [last_message\n      (map output_fun\n        (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n          c))] \\<frown>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input\n     (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)", "by (simp add: i_Exec_Stream_Acc_Output_append f_Exec_Stream_Acc_Output_one)"], ["", "lemma f_Exec_Stream_Acc_LocalState_append: \"\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs @ ys) c =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c @\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun ys (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs @ ys) c =\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c @\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun ys\n     (f_Exec_Comp trans_fun (xs \\<odot> k) c)", "by (simp only: f_Exec_Comp_Stream_Acc_LocalState_def f_shrink_last_def f_Exec_Stream_expand_map_aggregate_append)"], ["", "lemma f_Exec_Stream_Acc_LocalState_Cons: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (x # xs) c =\n  localState (f_Exec_Comp trans_fun (x #  \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c) #\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (x # xs) c =\n    localState\n     (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) #\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs\n     (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)", "apply (unfold f_Exec_Comp_Stream_Acc_LocalState_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    map localState\n     (f_Exec_Comp_Stream trans_fun ((x # xs) \\<odot> k) c) \\<div>\\<^sub>l\n    k =\n    localState\n     (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) #\n    map localState\n     (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n       (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         c)) \\<div>\\<^sub>l\n    k", "apply (simp only: f_shrink_last_map f_expand_Cons append_Cons[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    map localState\n     (f_Exec_Comp_Stream trans_fun\n       ((x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) @ xs \\<odot> k)\n       c \\<div>\\<^sub>l\n      k) =\n    localState\n     (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) #\n    map localState\n     (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n       (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         c) \\<div>\\<^sub>l\n      k)", "apply (simp add: f_Exec_Stream_append replicate_pred_Cons_length f_shrink_last_Cons del: f_Exec_Stream_Cons append_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    localState\n     (last\n       (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         c)) =\n    localState\n     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup> (trans_fun x c))", "apply (simp add: f_Exec_eq_f_Exec_Stream_last2[symmetric] f_Exec_Stream_empty_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_LocalState_one: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun [x] c =\n  [localState (f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun [x] c =\n    [localState\n      (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)]", "by (simp add: f_Exec_Stream_Acc_LocalState_Cons)"], ["", "lemma f_Exec_Stream_Acc_LocalState_snoc: \"\n  0 < k \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs @ [x]) c =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c @\n  [localState (f_Exec_Comp trans_fun ((xs @ [x]) \\<odot>\\<^sub>f k) c)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs @ [x]) c =\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c @\n    [localState (f_Exec_Comp trans_fun ((xs @ [x]) \\<odot> k) c)]", "by (simp add: f_Exec_Stream_Acc_LocalState_append f_Exec_Stream_Acc_LocalState_Cons f_Exec_append)"], ["", "lemma i_Exec_Stream_Acc_LocalState_append: \"\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (xs \\<frown> input) c =\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c \\<frown>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input (\n    f_Exec_Comp trans_fun (xs \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun\n     (xs \\<frown> input) c =\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c \\<frown>\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input\n     (f_Exec_Comp trans_fun (xs \\<odot> k) c)", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_def i_Exec_Comp_Stream_Acc_LocalState_def f_shrink_last_def i_shrink_last_def i_Exec_Stream_expand_map_aggregate_append)"], ["", "lemma i_Exec_Stream_Acc_LocalState_Cons: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun ([x] \\<frown> input) c =\n  [localState (f_Exec_Comp trans_fun (x #  \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)] \\<frown>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input (\n    f_Exec_Comp trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun\n     ([x] \\<frown> input) c =\n    [localState\n      (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n        c)] \\<frown>\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input\n     (f_Exec_Comp trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)", "by (simp add: i_Exec_Stream_Acc_LocalState_append f_Exec_Stream_Acc_LocalState_one f_expand_one)"], ["", "lemma f_Exec_Stream_Acc_Output_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c ! n =\n  last_message (map output_fun (\n    f_Exec_Comp_Stream trans_fun (xs ! n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n      f_Exec_Comp trans_fun (xs \\<down> n \\<odot>\\<^sub>f k) c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      n =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                             c)))", "by (unfold f_Exec_Comp_Stream_Acc_Output_def f_shrink_def, rule f_Exec_Stream_expand_aggregate_map_nth)"], ["", "lemma f_Exec_Stream_Acc_Output_nth_eq_i_nth: \"\n  \\<lbrakk> 0 < k; n < n' \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Down> n') c ! n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < n'\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       (input \\<Down> n') c !\n                      n =\n                      i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input c n", "by (unfold f_Exec_Comp_Stream_Acc_Output_def i_Exec_Comp_Stream_Acc_Output_def f_shrink_def i_shrink_def, rule f_Exec_Stream_expand_aggregate_map_nth_eq_i_nth)"], ["", "lemma i_Exec_Stream_Acc_Output_nth: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n =\n  last_message (map output_fun (\n    f_Exec_Comp_Stream trans_fun (input n # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) (\n      f_Exec_Comp trans_fun (input \\<Down> n \\<odot>\\<^sub>f k) c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n =\n    last_message\n     (map output_fun\n       (f_Exec_Comp_Stream trans_fun\n         (input n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         (f_Exec_Comp trans_fun (input \\<Down> n \\<odot> k) c)))", "by (unfold i_Exec_Comp_Stream_Acc_Output_def i_shrink_def, rule i_Exec_Stream_expand_aggregate_map_nth)"], ["", "corollary i_Exec_Stream_Acc_Output_nth_f_nth: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Down> Suc n) c ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n     (input \\<Down> Suc n) c !\n    n", "by (simp add: f_Exec_Stream_Acc_Output_nth_eq_i_nth)"], ["", "corollary i_Exec_Stream_Acc_Output_nth_f_last: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n =\n  last (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun (input \\<Down> Suc n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c n =\n    last\n     (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n       (input \\<Down> Suc n) c)", "by (simp add: i_Exec_Stream_Acc_Output_nth_f_nth last_nth length_greater_0_conv[THEN iffD1])"], ["", "lemma f_Exec_Stream_Acc_LocalState_nth: \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! n =\n  localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun xs c !\n                      n =\n                      localState\n                       (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                         c)", "apply (simp add: f_Exec_Comp_Stream_Acc_LocalState_def f_shrink_last_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> map localState\n                       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k)\n                         c \\<div>\\<^sub>l\n                        k) !\n                      n =\n                      localState\n                       (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                         c)", "apply (simp add: f_shrink_last_nth' f_shrink_last_length del: mult_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> localState\n                       (f_Exec_Comp_Stream trans_fun (xs \\<odot> k) c !\n                        (Suc n * k - Suc 0)) =\n                      localState\n                       (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k)\n                         c)", "apply (simp add: f_Exec_Stream_nth less_imp_Suc_mult_pred_less f_expand_take_mod del: mult_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_LocalState_nth_eq_i_nth: \"\n  \\<lbrakk> 0 < k; n < n' \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Down> n') c ! n =\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < n'\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun (input \\<Down> n') c !\n                      n =\n                      i_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun input c n", "by (unfold f_Exec_Comp_Stream_Acc_LocalState_def i_Exec_Comp_Stream_Acc_LocalState_def f_shrink_last_def i_shrink_last_def, rule f_Exec_Stream_expand_aggregate_map_nth_eq_i_nth)"], ["", "corollary i_Exec_Stream_Acc_LocalState_nth_f_nth: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k output_fun trans_fun input c n =\n  f_Exec_Comp_Stream_Acc_LocalState k output_fun trans_fun (input \\<Down> Suc n) c ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_LocalState k output_fun trans_fun input c n =\n    f_Exec_Comp_Stream_Acc_LocalState k output_fun trans_fun\n     (input \\<Down> Suc n) c !\n    n", "by (simp add: f_Exec_Stream_Acc_LocalState_nth_eq_i_nth)"], ["", "corollary i_Exec_Stream_Acc_LocalState_nth_f_last: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c n =\n  last (f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun (input \\<Down> Suc n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c n =\n    last\n     (f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun\n       (input \\<Down> Suc n) c)", "by (simp add: i_Exec_Stream_Acc_LocalState_nth_f_nth last_nth length_greater_0_conv[THEN iffD1])"], ["", "lemma i_Exec_Stream_Acc_LocalState_nth: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c n =\n  localState (f_Exec_Comp trans_fun (input \\<Down> Suc n \\<odot>\\<^sub>f k) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c n =\n    localState (f_Exec_Comp trans_fun (input \\<Down> Suc n \\<odot> k) c)", "by (simp add: i_Exec_Stream_Acc_LocalState_nth_f_nth f_Exec_Stream_Acc_LocalState_nth)"], ["", "lemma f_Exec_Stream_Acc_Output_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<down> n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys c \\<down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<down> n =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys c \\<down> n", "by (simp add: f_Exec_Stream_Acc_Output_take)"], ["", "lemma i_Exec_Stream_Acc_Output_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c \\<Down> n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c \\<Down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c \\<Down>\n    n =\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c \\<Down> n", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n; k = 0\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input1 c \\<Down>\n                      n =\n                      i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input2 c \\<Down>\n                      n\n 2. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input1 c \\<Down>\n                      n =\n                      i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input2 c \\<Down>\n                      n", "apply (simp add: i_Exec_Comp_Stream_Acc_Output_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input1 c \\<Down>\n                      n =\n                      i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input2 c \\<Down>\n                      n", "apply (simp add: i_Exec_Stream_Acc_Output_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_Output_Connected_strictly_causal: \"\n  \\<lbrakk> xs \\<down> n = ys \\<down> n;\n    f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c)\n      channel1;\n    f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys c)\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<down> Suc n = channel2 \\<down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<down> n = ys \\<down> n;\n     f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c) channel1;\n     f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun ys c)\n      channel2\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<down> Suc n = channel2 \\<down> Suc n", "by (simp add: f_Streams_Connected_def f_Exec_Stream_Acc_Output_take)"], ["", "lemma i_Exec_Stream_Acc_Output_Connected_strictly_causal: \"\n  \\<lbrakk> input1 \\<Down> n = input2 \\<Down> n;\n    i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c)\n      channel1;\n    i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c)\n      channel2 \\<rbrakk> \\<Longrightarrow>\n  channel1 \\<Down> Suc n = channel2 \\<Down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c)\n      channel1;\n     i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c)\n      channel2\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<Down> Suc n = channel2 \\<Down> Suc n", "apply (unfold i_Streams_Connected_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     channel1 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c;\n     channel2 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<Down> Suc n = channel2 \\<Down> Suc n", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     channel1 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c;\n     channel2 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<Down> Suc n = channel2 \\<Down> Suc n\n 2. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     channel1 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c;\n     channel2 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<Down> Suc n = channel2 \\<Down> Suc n", "apply (simp add: i_Exec_Comp_Stream_Acc_Output_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input1 \\<Down> n = input2 \\<Down> n;\n     channel1 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input1 c;\n     channel2 =\n     [NoMsg] \\<frown>\n     i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input2 c;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> channel1 \\<Down> Suc n = channel2 \\<Down> Suc n", "apply (simp add: i_Exec_Stream_Acc_Output_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Complete execution cycles/steps of accelrated execution\\<close>"], ["", "definition Acc_Trans_Fun_Step ::\n  \"nat \\<Rightarrow> \\<comment> \\<open>Acceleration factor\\<close>\n    ('comp, 'input message_af) Comp_Trans_Fun \\<Rightarrow>\n    ('comp list \\<Rightarrow> 'comp) \\<Rightarrow> \\<comment> \\<open>Pointwise output shrink function\\<close>\n    'input message_af \\<Rightarrow> 'comp \\<Rightarrow>\n    'comp\"\n  where \"Acc_Trans_Fun_Step k trans_fun pointwise_shrink x c \\<equiv>\n    pointwise_shrink (f_Exec_Comp_Stream trans_fun (x # \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>) c)\""], ["", "definition is_Pointwise_Output_Shrink ::\n  \"('comp list \\<Rightarrow> 'comp) \\<Rightarrow> \\<comment> \\<open>Pointwise output shrink function\\<close>\n    ('comp \\<Rightarrow> 'output message_af) \\<Rightarrow> \\<comment> \\<open>Output extraction function for consideration\\<close>\n    bool\"\n  where \"is_Pointwise_Output_Shrink pointwise_shrink output_fun \\<equiv>\n    \\<forall>cs. output_fun (pointwise_shrink cs) = last_message (map output_fun cs)\""], ["", "primrec is_Pointwise_Output_Shrink_list ::\n  \"('comp list \\<Rightarrow> 'comp) \\<Rightarrow> \\<comment> \\<open>Pointwise output shrink function\\<close>\n    ('comp \\<Rightarrow> 'output message_af) list \\<Rightarrow> \\<comment> \\<open>List of output extraction functions for consideration\\<close>\n    bool\"\nwhere\n  \"is_Pointwise_Output_Shrink_list pointwise_shrink [] = True\"\n| \"is_Pointwise_Output_Shrink_list pointwise_shrink (f # fs) =\n    (is_Pointwise_Output_Shrink pointwise_shrink f \\<and>\n     is_Pointwise_Output_Shrink_list pointwise_shrink fs)\""], ["", "definition is_correct_localState_Pointwise_Output_Shrink ::\n  \"('comp list \\<Rightarrow> 'comp) \\<Rightarrow> \\<comment> \\<open>Pointwise output shrink function\\<close>\n    ('comp \\<Rightarrow> 'state) \\<Rightarrow> \\<comment> \\<open>Local state extraction function\\<close>\n    bool\"\n  where \"is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState \\<equiv>\n    \\<forall>cs. cs \\<noteq> [] \\<longrightarrow> localState (pointwise_shrink cs) = localState (last cs)\""], ["", "lemma Deterministic_trans_fun_imp_acc_trans_fun:\n  \"Deterministic_Trans_Fun trans_fun localState \\<Longrightarrow>\n    Deterministic_Trans_Fun (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Deterministic_Trans_Fun trans_fun localState \\<Longrightarrow>\n    Deterministic_Trans_Fun\n     (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState", "apply (simp (no_asm) only: Deterministic_Trans_Fun_def Acc_Trans_Fun_Step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Deterministic_Trans_Fun trans_fun localState \\<Longrightarrow>\n    \\<forall>c1 c2 x.\n       localState c1 = localState c2 \\<longrightarrow>\n       pointwise_shrink\n        (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n          c1) =\n       pointwise_shrink\n        (f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n          c2)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2 x.\n       \\<lbrakk>Deterministic_Trans_Fun trans_fun localState;\n        localState c1 = localState c2\\<rbrakk>\n       \\<Longrightarrow> pointwise_shrink\n                          (f_Exec_Comp_Stream trans_fun\n                            (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c1) =\n                         pointwise_shrink\n                          (f_Exec_Comp_Stream trans_fun\n                            (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c2)", "apply (subst Deterministic_f_Exec_Stream, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_Pointwise_Output_Shrink_list_imp_is_Pointwise_Output_Shrink:\n  \"\\<lbrakk> is_Pointwise_Output_Shrink_list pointwise_shrink fs; output_fun \\<in> set fs \\<rbrakk> \\<Longrightarrow>\n    is_Pointwise_Output_Shrink pointwise_shrink output_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Pointwise_Output_Shrink_list pointwise_shrink fs;\n     output_fun \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> is_Pointwise_Output_Shrink pointwise_shrink output_fun", "apply (induct fs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>is_Pointwise_Output_Shrink_list pointwise_shrink\n                          fs;\n                 output_fun \\<in> set fs\\<rbrakk>\n                \\<Longrightarrow> is_Pointwise_Output_Shrink\n                                   pointwise_shrink output_fun;\n        is_Pointwise_Output_Shrink_list pointwise_shrink (a # fs);\n        output_fun \\<in> set (a # fs)\\<rbrakk>\n       \\<Longrightarrow> is_Pointwise_Output_Shrink pointwise_shrink\n                          output_fun", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_Pointwise_Output_Shrink_list_eq_is_Pointwise_Output_Shrink_all:\n  \"(is_Pointwise_Output_Shrink_list pointwise_shrink fs) =\n    (\\<forall>output_fun \\<in> set fs. is_Pointwise_Output_Shrink pointwise_shrink output_fun)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Pointwise_Output_Shrink_list pointwise_shrink fs =\n    (\\<forall>output_fun\\<in>set fs.\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_Pointwise_Output_Shrink_list pointwise_shrink fs \\<Longrightarrow>\n    \\<forall>output_fun\\<in>set fs.\n       is_Pointwise_Output_Shrink pointwise_shrink output_fun\n 2. \\<forall>output_fun\\<in>set fs.\n       is_Pointwise_Output_Shrink pointwise_shrink\n        output_fun \\<Longrightarrow>\n    is_Pointwise_Output_Shrink_list pointwise_shrink fs", "apply (rule ballI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>output_fun.\n       \\<lbrakk>is_Pointwise_Output_Shrink_list pointwise_shrink fs;\n        output_fun \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> is_Pointwise_Output_Shrink pointwise_shrink\n                          output_fun\n 2. \\<forall>output_fun\\<in>set fs.\n       is_Pointwise_Output_Shrink pointwise_shrink\n        output_fun \\<Longrightarrow>\n    is_Pointwise_Output_Shrink_list pointwise_shrink fs", "apply (rule is_Pointwise_Output_Shrink_list_imp_is_Pointwise_Output_Shrink)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>output_fun.\n       \\<lbrakk>is_Pointwise_Output_Shrink_list pointwise_shrink fs;\n        output_fun \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> is_Pointwise_Output_Shrink_list pointwise_shrink\n                          (?fs5 output_fun)\n 2. \\<And>output_fun.\n       \\<lbrakk>is_Pointwise_Output_Shrink_list pointwise_shrink fs;\n        output_fun \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> output_fun \\<in> set (?fs5 output_fun)\n 3. \\<forall>output_fun\\<in>set fs.\n       is_Pointwise_Output_Shrink pointwise_shrink\n        output_fun \\<Longrightarrow>\n    is_Pointwise_Output_Shrink_list pointwise_shrink fs", "apply (simp add: member_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>output_fun\\<in>set fs.\n       is_Pointwise_Output_Shrink pointwise_shrink\n        output_fun \\<Longrightarrow>\n    is_Pointwise_Output_Shrink_list pointwise_shrink fs", "apply (induct fs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>Ball (set fs)\n                 (is_Pointwise_Output_Shrink\n                   pointwise_shrink) \\<Longrightarrow>\n                is_Pointwise_Output_Shrink_list pointwise_shrink fs;\n        Ball (set (a # fs))\n         (is_Pointwise_Output_Shrink pointwise_shrink)\\<rbrakk>\n       \\<Longrightarrow> is_Pointwise_Output_Shrink_list pointwise_shrink\n                          (a # fs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_Pointwise_Output_Shrink_subset:\n  \"\\<lbrakk> is_Pointwise_Output_Shrink_list pointwise_shrink fs; set fs' \\<subseteq> set fs \\<rbrakk> \\<Longrightarrow>\n    is_Pointwise_Output_Shrink_list pointwise_shrink fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Pointwise_Output_Shrink_list pointwise_shrink fs;\n     set fs' \\<subseteq> set fs\\<rbrakk>\n    \\<Longrightarrow> is_Pointwise_Output_Shrink_list pointwise_shrink fs'", "by (fastforce simp: is_Pointwise_Output_Shrink_list_eq_is_Pointwise_Output_Shrink_all)"], ["", "lemma f_Exec_Stream_Acc_LocalState_eq_Acc_Trans_Fun_Step_LocalState: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c =\n  map localState (f_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < k; Deterministic_Trans_Fun trans_fun localState;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun xs c =\n                         map localState\n                          (f_Exec_Comp_Stream\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            xs c)", "apply (drule Deterministic_trans_fun_imp_acc_trans_fun[of trans_fun localState k pointwise_shrink])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n         localState\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun xs c =\n                         map localState\n                          (f_Exec_Comp_Stream\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            xs c)", "apply (clarsimp simp: list_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun xs c !\n                         i =\n                         localState\n                          (f_Exec_Comp_Stream\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            xs c !\n                           i)", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth f_Exec_Stream_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc i \\<odot> k) c) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i) c)", "apply (induct xs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < k;\n                    is_correct_localState_Pointwise_Output_Shrink\n                     pointwise_shrink localState;\n                    Deterministic_Trans_Fun\n                     (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                     localState;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> localState\n(f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                                     localState\n(f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n  (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) \\<down> Suc i \\<odot> k) c) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            ((a # xs) \\<down> Suc i) c)", "apply (rename_tac x xs c i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < k;\n                    is_correct_localState_Pointwise_Output_Shrink\n                     pointwise_shrink localState;\n                    Deterministic_Trans_Fun\n                     (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                     localState;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> localState\n(f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                                     localState\n(f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n  (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            ((x # xs) \\<down> Suc i \\<odot> k) c) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            ((x # xs) \\<down> Suc i) c)", "apply (simp add: Acc_Trans_Fun_Step_def f_expand_Cons f_Exec_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))\n 2. \\<And>x xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         localState\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))\n 2. \\<And>x xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (simp only: is_correct_localState_Pointwise_Output_Shrink_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        \\<forall>cs.\n           cs \\<noteq> [] \\<longrightarrow>\n           localState (pointwise_shrink cs) = localState (last cs);\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         localState\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))\n 2. \\<And>x xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (drule_tac x=\"f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i = 0;\n        f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         c \\<noteq>\n        [] \\<longrightarrow>\n        localState\n         (pointwise_shrink\n           (f_Exec_Comp_Stream trans_fun\n             (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)) =\n        localState\n         (last\n           (f_Exec_Comp_Stream trans_fun\n             (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         localState\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))\n 2. \\<And>x xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (simp add: f_Exec_Stream_not_empty_conv f_Exec_eq_f_Exec_Stream_last)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (rename_tac i2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   localState\n                    (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k) c) =\n                   localState\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc i2\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (drule_tac x=\"f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup> (trans_fun x c)\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc i2;\n        \\<And>i.\n           i < length xs \\<Longrightarrow>\n           localState\n            (f_Exec_Comp trans_fun (xs \\<down> Suc i \\<odot> k)\n              (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                (trans_fun x c))) =\n           localState\n            (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n              (xs \\<down> Suc i)\n              (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (drule_tac x=i2 in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc i2;\n        i2 < length xs \\<Longrightarrow>\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (simp add: is_correct_localState_Pointwise_Output_Shrink_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        \\<forall>cs.\n           cs \\<noteq> [] \\<longrightarrow>\n           localState (pointwise_shrink cs) = localState (last cs);\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (drule_tac x=\"f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         c \\<noteq>\n        [] \\<longrightarrow>\n        localState\n         (pointwise_shrink\n           (f_Exec_Comp_Stream trans_fun\n             (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)) =\n        localState\n         (last\n           (f_Exec_Comp_Stream trans_fun\n             (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (simp add: f_Exec_Stream_not_empty_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         localState\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (rule arg_cong[where f=localState])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          (xs \\<down> Suc i2)\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         f_Exec_Comp\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          (xs \\<down> Suc i2)\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))", "apply (rule Deterministic_f_Exec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> Deterministic_Trans_Fun\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          (?localState13 x xs c i i2)\n 2. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> ?localState13 x xs c i i2\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         ?localState13 x xs c i i2\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))\n 3. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i2 \\<noteq> []", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         localState\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))\n 2. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i2 \\<noteq> []", "apply (simp add: f_Exec_eq_f_Exec_Stream_last)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc i2 \\<odot> k)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i2 \\<noteq> []", "apply (simp add: length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_Output_eq_Acc_Trans_Fun_Step_Output: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState;\n    is_Pointwise_Output_Shrink pointwise_shrink output_fun \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  map output_fun (f_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < k; Deterministic_Trans_Fun trans_fun localState;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun\n                          trans_fun xs c =\n                         map output_fun\n                          (f_Exec_Comp_Stream\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            xs c)", "apply (drule Deterministic_trans_fun_imp_acc_trans_fun[of trans_fun localState k pointwise_shrink])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n         localState\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun\n                          trans_fun xs c =\n                         map output_fun\n                          (f_Exec_Comp_Stream\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            xs c)", "apply (clarsimp simp: list_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun\n                          trans_fun xs c !\n                         i =\n                         output_fun\n                          (f_Exec_Comp_Stream\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            xs c !\n                           i)", "apply (simp add: f_Exec_Stream_Acc_Output_nth f_Exec_Stream_nth del: f_Exec_Stream_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i) c)", "apply (induct xs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < k;\n                    is_correct_localState_Pointwise_Output_Shrink\n                     pointwise_shrink localState;\n                    is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n                    Deterministic_Trans_Fun\n                     (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                     localState;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> last_message\n(map output_fun\n  (f_Exec_Comp_Stream trans_fun (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k) c))) =\n                                     output_fun\n(f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n  (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((a # xs) ! i #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                ((a # xs) \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            ((a # xs) \\<down> Suc i) c)", "apply (rename_tac x xs c i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < k;\n                    is_correct_localState_Pointwise_Output_Shrink\n                     pointwise_shrink localState;\n                    is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n                    Deterministic_Trans_Fun\n                     (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                     localState;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> last_message\n(map output_fun\n  (f_Exec_Comp_Stream trans_fun (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n    (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k) c))) =\n                                     output_fun\n(f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n  (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((x # xs) ! i #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                ((x # xs) \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            ((x # xs) \\<down> Suc i) c)", "apply (simp add: Acc_Trans_Fun_Step_def del: f_Exec_Stream_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   last_message\n                    (map output_fun\n                      (f_Exec_Comp_Stream trans_fun\n                        (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                        (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                          c))) =\n                   output_fun\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((x # xs) ! i #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                ((x # xs) \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (f_Exec_Comp_Stream trans_fun\n                                (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs c i.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   last_message\n                    (map output_fun\n                      (f_Exec_Comp_Stream trans_fun\n                        (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                        (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                          c))) =\n                   output_fun\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = 0\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((x # xs) ! i #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                ((x # xs) \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (f_Exec_Comp_Stream trans_fun\n                                (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\n 2. \\<And>x xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   last_message\n                    (map output_fun\n                      (f_Exec_Comp_Stream trans_fun\n                        (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                        (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                          c))) =\n                   output_fun\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((x # xs) ! i #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                ((x # xs) \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (f_Exec_Comp_Stream trans_fun\n                                (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))", "apply (simp add: is_Pointwise_Output_Shrink_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   last_message\n                    (map output_fun\n                      (f_Exec_Comp_Stream trans_fun\n                        (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                        (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                          c))) =\n                   output_fun\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((x # xs) ! i #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                ((x # xs) \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (f_Exec_Comp_Stream trans_fun\n                                (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))", "apply (rename_tac i2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   last_message\n                    (map output_fun\n                      (f_Exec_Comp_Stream trans_fun\n                        (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                        (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                          c))) =\n                   output_fun\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i < Suc (length xs); i = Suc i2\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((x # xs) ! i #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                ((x # xs) \\<down> i \\<odot> k) c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> i)\n                            (pointwise_shrink\n                              (f_Exec_Comp_Stream trans_fun\n                                (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))", "apply (simp add: f_Exec_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>\\<And>c i.\n                   i < length xs \\<Longrightarrow>\n                   (if last_message\n                        (map output_fun\n                          (f_Exec_Comp_Stream trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun (xs ! i)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c)))) =\n                       NoMsg\n                    then output_fun\n                          (trans_fun (xs ! i)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                              c))\n                    else last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun (xs ! i)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> i \\<odot> k) c))))) =\n                   output_fun\n                    (f_Exec_Comp\n                      (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                      (xs \\<down> Suc i) c);\n        0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (drule_tac x=\"f_Exec_Comp trans_fun \\<NoMsg>\\<^bsup>k - Suc 0\\<^esup> (trans_fun x c)\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        \\<And>i.\n           i < length xs \\<Longrightarrow>\n           (if last_message\n                (map output_fun\n                  (f_Exec_Comp_Stream trans_fun\n                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                    (trans_fun (xs ! i)\n                      (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                        (f_Exec_Comp trans_fun\n                          NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                          (trans_fun x c)))))) =\n               NoMsg\n            then output_fun\n                  (trans_fun (xs ! i)\n                    (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                      (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                        (trans_fun x c))))\n            else last_message\n                  (map output_fun\n                    (f_Exec_Comp_Stream trans_fun\n                      NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                      (trans_fun (xs ! i)\n                        (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c))))))) =\n           output_fun\n            (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n              (xs \\<down> Suc i)\n              (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (drule_tac x=i2 in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        i2 < length xs \\<Longrightarrow>\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (simp add: is_correct_localState_Pointwise_Output_Shrink_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        \\<forall>cs.\n           cs \\<noteq> [] \\<longrightarrow>\n           localState (pointwise_shrink cs) = localState (last cs);\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (drule_tac x=\"f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        f_Exec_Comp_Stream trans_fun (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n         c \\<noteq>\n        [] \\<longrightarrow>\n        localState\n         (pointwise_shrink\n           (f_Exec_Comp_Stream trans_fun\n             (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)) =\n        localState\n         (last\n           (f_Exec_Comp_Stream trans_fun\n             (x # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (simp add: f_Exec_Stream_not_empty_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c))) =\n                         output_fun\n                          (f_Exec_Comp\n                            (Acc_Trans_Fun_Step k trans_fun\n                              pointwise_shrink)\n                            (xs \\<down> Suc i2)\n                            (pointwise_shrink\n                              (trans_fun x c #\n                               f_Exec_Comp_Stream trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun x c))))", "apply (rule arg_cong[where f=output_fun])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          (xs \\<down> Suc i2)\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         f_Exec_Comp\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          (xs \\<down> Suc i2)\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))", "apply (rule Deterministic_f_Exec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> Deterministic_Trans_Fun\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          (?localState11 x xs c i i2)\n 2. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> ?localState11 x xs c i i2\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         ?localState11 x xs c i i2\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))\n 3. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i2 \\<noteq> []", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun x c)) =\n                         localState\n                          (pointwise_shrink\n                            (trans_fun x c #\n                             f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun x c)))\n 2. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i2 \\<noteq> []", "apply (simp add: f_Exec_eq_f_Exec_Stream_last)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs c i i2.\n       \\<lbrakk>0 < k;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun;\n        Deterministic_Trans_Fun\n         (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) localState;\n        i2 < length xs; i = Suc i2;\n        (if last_message\n             (map output_fun\n               (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (xs ! i2)\n                   (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                     (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                       (trans_fun x c)))))) =\n            NoMsg\n         then output_fun\n               (trans_fun (xs ! i2)\n                 (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                   (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                     (trans_fun x c))))\n         else last_message\n               (map output_fun\n                 (f_Exec_Comp_Stream trans_fun\n                   NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                   (trans_fun (xs ! i2)\n                     (f_Exec_Comp trans_fun (xs \\<down> i2 \\<odot> k)\n                       (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                         (trans_fun x c))))))) =\n        output_fun\n         (f_Exec_Comp (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n           (xs \\<down> Suc i2)\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c)));\n        localState\n         (pointwise_shrink\n           (trans_fun x c #\n            f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun x c))) =\n        localState\n         (if f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n              (trans_fun x c) =\n             []\n          then trans_fun x c\n          else last\n                (f_Exec_Comp_Stream trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                  (trans_fun x c)))\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> Suc i2 \\<noteq> []", "apply (simp add: length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_LocalState_eq_Acc_Trans_Fun_Step_LocalState: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c =\n  localState \\<circ> (i_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) input c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < k; Deterministic_Trans_Fun trans_fun localState;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState\\<rbrakk>\n       \\<Longrightarrow> i_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun input c =\n                         localState \\<circ>\n                         i_Exec_Comp_Stream\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          input c", "apply (rule ilist_i_take_eq_conv[THEN iffD2], rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>0 < k; Deterministic_Trans_Fun trans_fun localState;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState\\<rbrakk>\n       \\<Longrightarrow> i_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun input c \\<Down>\n                         n =\n                         (localState \\<circ>\n                          i_Exec_Comp_Stream\n                           (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                           input c) \\<Down>\n                         n", "apply (simp add: i_Exec_Stream_Acc_LocalState_take i_Exec_Stream_take f_Exec_Stream_Acc_LocalState_eq_Acc_Trans_Fun_Step_LocalState)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_Output_eq_Acc_Trans_Fun_Step_Output: \"\\<And>c.\n  \\<lbrakk> 0 < k;\n    Deterministic_Trans_Fun trans_fun localState;\n    is_correct_localState_Pointwise_Output_Shrink pointwise_shrink localState;\n    is_Pointwise_Output_Shrink pointwise_shrink output_fun \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  output_fun \\<circ> (i_Exec_Comp_Stream (Acc_Trans_Fun_Step k trans_fun pointwise_shrink) input c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < k; Deterministic_Trans_Fun trans_fun localState;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun\\<rbrakk>\n       \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun\n                          trans_fun input c =\n                         output_fun \\<circ>\n                         i_Exec_Comp_Stream\n                          (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                          input c", "apply (rule ilist_i_take_eq_conv[THEN iffD2], rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>0 < k; Deterministic_Trans_Fun trans_fun localState;\n        is_correct_localState_Pointwise_Output_Shrink pointwise_shrink\n         localState;\n        is_Pointwise_Output_Shrink pointwise_shrink output_fun\\<rbrakk>\n       \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun\n                          trans_fun input c \\<Down>\n                         n =\n                         (output_fun \\<circ>\n                          i_Exec_Comp_Stream\n                           (Acc_Trans_Fun_Step k trans_fun pointwise_shrink)\n                           input c) \\<Down>\n                         n", "apply (simp add: i_Exec_Stream_Acc_Output_take i_Exec_Stream_take f_Exec_Stream_Acc_Output_eq_Acc_Trans_Fun_Step_Output)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Basic results for accelerated execution with initial state in the resulting stream\\<close>"], ["", "lemma f_Exec_Stream_Acc_Output_Init_length: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    length\n     (f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c) =\n    Suc (length xs)", "by (simp add: f_Exec_Comp_Stream_Acc_Output_Init_def)"], ["", "lemma f_Exec_Stream_Acc_LocalState_Init_length: \"\n  0 < k \\<Longrightarrow>\n  length (f_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun xs c) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    length\n     (f_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun xs c) =\n    Suc (length xs)", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_Init_def)"], ["", "lemma f_Exec_Stream_Acc_Output_Init_Nil: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun [] c = [output_fun c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun [] c =\n    [output_fun c]", "by (simp add: f_Exec_Comp_Stream_Acc_Output_Init_def)"], ["", "lemma f_Exec_Stream_Acc_LocalState_Init_Nil: \"\n  f_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun [] c = [localState c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_LocalState_Init k localState trans_fun [] c =\n    [localState c]", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_Init_def)"], ["", "lemma f_Exec_Stream_Acc_Output_Init_1: \"\n  f_Exec_Comp_Stream_Acc_Output_Init (Suc 0) output_fun trans_fun xs c =\n  map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output_Init (Suc 0) output_fun trans_fun xs c =\n    map output_fun (f_Exec_Comp_Stream_Init trans_fun xs c)", "by (simp add: f_Exec_Comp_Stream_Acc_Output_Init_def f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["", "lemma f_Exec_Stream_Acc_LocalState_Init_1: \"\n  f_Exec_Comp_Stream_Acc_LocalState_Init (Suc 0) localState trans_fun xs c =\n  map localState (f_Exec_Comp_Stream_Init trans_fun xs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_LocalState_Init (Suc 0) localState trans_fun xs\n     c =\n    map localState (f_Exec_Comp_Stream_Init trans_fun xs c)", "by (simp add: f_Exec_Comp_Stream_Acc_LocalState_Init_def f_Exec_Stream_Init_eq_f_Exec_Stream_Cons)"], ["", "lemma i_Exec_Stream_Acc_Output_Init_1: \"\n  i_Exec_Comp_Stream_Acc_Output_Init (Suc 0) output_fun trans_fun input c =\n  output_fun \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_Output_Init (Suc 0) output_fun trans_fun input\n     c =\n    output_fun \\<circ> i_Exec_Comp_Stream_Init trans_fun input c", "by (simp add: i_Exec_Comp_Stream_Acc_Output_Init_def i_Exec_Stream_Init_eq_i_Exec_Stream_Cons)"], ["", "lemma i_Exec_Stream_Acc_LocalState_Init_1: \"\n  i_Exec_Comp_Stream_Acc_LocalState_Init (Suc 0) localState trans_fun input c =\n  localState \\<circ> (i_Exec_Comp_Stream_Init trans_fun input c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_LocalState_Init (Suc 0) localState trans_fun\n     input c =\n    localState \\<circ> i_Exec_Comp_Stream_Init trans_fun input c", "by (simp add: i_Exec_Comp_Stream_Acc_LocalState_Init_def i_Exec_Stream_Init_eq_i_Exec_Stream_Cons)"], ["", "lemma f_Exec_Stream_Acc_Output_Init_take: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<down> (Suc n) =\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun (xs \\<down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<down>\n    Suc n =\n    f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun (xs \\<down> n)\n     c", "by (simp add: f_Exec_Comp_Stream_Acc_Output_Init_def f_Exec_Stream_Acc_Output_take)"], ["", "lemma f_Exec_Stream_Acc_Output_Init_drop': \"\n  \\<lbrakk> 0 < k; n < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<up> Suc n =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<up> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n < length xs\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output_Init k output_fun\n                       trans_fun xs c \\<up>\n                      Suc n =\n                      f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c \\<up>\n                      n", "by (simp add: f_Exec_Comp_Stream_Acc_Output_Init_def)"], ["", "lemma i_Exec_Stream_Acc_Output_Init_take: \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c \\<Down> (Suc n) =\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun (input \\<Down> n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input\n     c \\<Down>\n    Suc n =\n    f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun\n     (input \\<Down> n) c", "by (simp add: f_Exec_Comp_Stream_Acc_Output_Init_def i_Exec_Comp_Stream_Acc_Output_Init_def i_Exec_Stream_Acc_Output_take)"], ["", "lemma i_Exec_Stream_Acc_Output_Init_drop': \"\n  0 < k \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<Up> Suc n =\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<Up> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<Up>\n    Suc n =\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c \\<Up> n", "by (simp add: i_Exec_Comp_Stream_Acc_Output_Init_def)"], ["", "lemma f_Exec_Stream_Acc_Output_Init_strictly_causal: \"\n  xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<down> Suc n =\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun ys c \\<down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<down> n = ys \\<down> n \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c \\<down>\n    Suc n =\n    f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun ys c \\<down>\n    Suc n", "by (simp add: f_Exec_Comp_Stream_Acc_Output_Init_def, rule f_Exec_Stream_Acc_Output_causal)"], ["", "lemma i_Exec_Stream_Acc_Output_Init_strictly_causal: \"\n  input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input1 c \\<Down> Suc n =\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input2 c \\<Down> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input1 \\<Down> n = input2 \\<Down> n \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input1\n     c \\<Down>\n    Suc n =\n    i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input2\n     c \\<Down>\n    Suc n", "by (simp add: i_Exec_Comp_Stream_Acc_Output_Init_def, rule i_Exec_Stream_Acc_Output_causal)"], ["", "lemma f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c =\n  output_fun c # f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c =\n    output_fun c # f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c", "by (simp add: f_Exec_Comp_Stream_Acc_Output_def f_Exec_Comp_Stream_Acc_Output_Init_def)"], ["", "lemma f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons_output: \"\n  output_fun c = \\<NoMsg> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c =\n  \\<NoMsg> # f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_fun c = NoMsg \\<Longrightarrow>\n    f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c =\n    NoMsg # f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c", "by (simp add: f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons)"], ["", "lemma f_Exec_Stream__Acc_OutputInit_tl_eq_f_Exec_Stream_Acc_Output: \"\n  tl (f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c) =\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c) =\n    f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c", "by (simp add: f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons)"], ["", "lemma f_Exec_Stream_Previous_f_Exec_Stream_Acc_Output_Init: \"\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c ! n =\n  (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c)\\<^bsup>\\<leftarrow>' output_fun c\\<^esup> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c ! n =\n    (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs\n      c)\\<^bsup>\\<leftarrow>' output_fun c\\<^esup> n", "by (simp add: f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons list_Previous_nth_if nth_Cons')"], ["", "lemma f_Exec_Stream_Acc_Output_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c)\n      channel \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun xs c = channel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>output_fun c = NoMsg;\n     f_Streams_Connected\n      (f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c)\n      channel\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output_Init k output_fun\n                       trans_fun xs c =\n                      channel", "by (simp add: f_Streams_Connected_def f_Exec_Stream_Acc_Output_Init_eq_f_Exec_Stream_Acc_Output_Cons_output)"], ["", "lemma i_Exec_Stream_Acc_Output_Init_eq_i_Exec_Stream_Acc_Output_Cons: \"\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c =\n  [output_fun c] \\<frown> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c =\n    [output_fun c] \\<frown>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c", "by (simp add: i_Exec_Comp_Stream_Acc_Output_def i_Exec_Comp_Stream_Acc_Output_Init_def)"], ["", "lemma i_Exec_Stream_Acc_Output_Init_eq_i_Exec_Stream_Acc_Output_Cons_output: \"\n  output_fun c = \\<NoMsg> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c =\n  [\\<NoMsg> ] \\<frown> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_fun c = NoMsg \\<Longrightarrow>\n    i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c =\n    [NoMsg] \\<frown>\n    i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c", "by (simp add: i_Exec_Stream_Acc_Output_Init_eq_i_Exec_Stream_Acc_Output_Cons)"], ["", "lemma i_Exec_Stream_Previous_i_Exec_Stream_Acc_Output_Init: \"\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c n =\n  (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c)\\<^bsup>\\<leftarrow> output_fun c\\<^esup> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c n =\n    (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input\n      c)\\<^bsup>\\<leftarrow> output_fun c\\<^esup> n", "by (simp add: i_Exec_Stream_Acc_Output_Init_eq_i_Exec_Stream_Acc_Output_Cons ilist_Previous_nth_if)"], ["", "lemma i_Exec_Stream_Acc_Output_Init_eq_output_channel: \"\n  \\<lbrakk> output_fun c = \\<NoMsg>;\n    i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c)\n      channel \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output_Init k output_fun trans_fun input c = channel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>output_fun c = NoMsg;\n     i_Streams_Connected\n      (i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c)\n      channel\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output_Init k output_fun\n                       trans_fun input c =\n                      channel", "by (simp add: i_Streams_Connected_def i_Exec_Stream_Acc_Output_Init_eq_i_Exec_Stream_Acc_Output_Cons_output)"], ["", "subsubsection \\<open>Rules for proving execution equivalence\\<close>"], ["", "text \\<open>\n  A required precondition is that the @{term equiv_states} relation,\n  which indicates whether the local states of @{term c1} and @{term c2}\n  are equivalent with respect to observable behaviour,\n  is preserved also after executing an input stream,\n  because the @{term equiv_states} relation\n  should deliver valid results not only at the time point @{term 0}\n  but at every time point.\\<close>"], ["", "lemma f_Equiv_Exec_Stream_expand_shrink_equiv_state_set[rule_format]: \"\n  \\<And>c1 c2 i. \\<lbrakk>\n   0 < k1; 0 < k2;\n   equiv_states (localState1 c1) (localState2 c2);\n   \\<forall>input0. set input0 \\<subseteq> A \\<longrightarrow> (\\<forall>m\\<in>A.\n      Equiv_Exec m equiv_states\n      localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2\n      (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n      (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2));\n      \\<comment> \\<open>\\<open>equiv_states\\<close> relation implies equivalent executions\\<close>\n      \\<comment> \\<open>not only at the beginning but also after processing an input\\<close>\n   set input \\<subseteq> A; i < length input \\<rbrakk> \\<Longrightarrow>\n   equiv_states\n     (localState1 ((f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1) \\<div>\\<^bsub>fl\\<^esub> k1 ! i))\n     (localState2 ((f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2) \\<div>\\<^bsub>fl\\<^esub> k2 ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2 i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              c1 \\<div>\\<^sub>l\n                             k1 !\n                             i))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              c2 \\<div>\\<^sub>l\n                             k2 !\n                             i))", "apply (induct input, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>0 < k1; 0 < k2;\n                    equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    set input \\<subseteq> A; i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set (a # input) \\<subseteq> A; i < length (a # input)\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 (a # input) \\<odot> k1)\n                              c1 \\<div>\\<^sub>l\n                             k1 !\n                             i))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 (a # input) \\<odot> k2)\n                              c2 \\<div>\\<^sub>l\n                             k2 !\n                             i))", "apply (clarsimp simp: append_Cons[symmetric] f_Exec_Stream_append_if f_shrink_last_Cons nth_Cons simp del: last.simps f_Exec_Stream_Cons append_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))\n 2. \\<And>a input c1 c2 i nat.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (drule_tac x=\"[]\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A; i = 0;\n        set [] \\<subseteq> A \\<longrightarrow>\n        (\\<forall>m\\<in>A.\n            Equiv_Exec m equiv_states localState1 localState2 input_fun1\n             input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n             (f_Exec_Comp trans_fun1 (map input_fun1 [] \\<odot> k1) c1)\n             (f_Exec_Comp trans_fun2 (map input_fun2 [] \\<odot> k2)\n               c2))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))\n 2. \\<And>a input c1 c2 i nat.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (drule mp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A; i = 0;\n        \\<forall>m\\<in>A.\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 [] \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 [] \\<odot> k2)\n              c2)\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))\n 2. \\<And>a input c1 c2 i nat.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (drule_tac x=a in bspec, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A; i = 0;\n        Equiv_Exec a equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 [] \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 [] \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))\n 2. \\<And>a input c1 c2 i nat.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (simp del: last.simps f_Exec_Stream_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        a \\<in> A; set input \\<subseteq> A; i = 0;\n        Equiv_Exec a equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n         c2\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (last\n                              (f_Exec_Comp_Stream trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1)))\n                          (localState2\n                            (last\n                              (f_Exec_Comp_Stream trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2)))\n 2. \\<And>a input c1 c2 i nat.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (subst f_Exec_eq_f_Exec_Stream_last2[symmetric], simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        a \\<in> A; set input \\<subseteq> A; i = 0;\n        Equiv_Exec a equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n         c2\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp trans_fun1\n                              (input_fun1 a #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              c1))\n                          (localState2\n                            (f_Exec_Comp trans_fun2\n                              (input_fun2 a #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              c2))\n 2. \\<And>a input c1 c2 i nat.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (rule Equiv_Exec_equiv_statesI[of equiv_states localState1 _ localState2 _ _ input_fun1], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i nat.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (rename_tac i')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i'\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (input_fun1 a #\n                                   NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                  c1)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun1\n(input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1)) \\<div>\\<^sub>l\n                                 k1 !\n                                 k))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               last\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (input_fun2 a #\n                                   NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                  c2)\n                             | Suc k \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (last\n                                    (f_Exec_Comp_Stream trans_fun2\n(input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)) \\<div>\\<^sub>l\n                                 k2 !\n                                 k))", "apply (subst f_Exec_eq_f_Exec_Stream_last2[symmetric], simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>\\<And>c1 c2 i.\n                   \\<lbrakk>equiv_states (localState1 c1) (localState2 c2);\n                    \\<forall>input0.\n                       set input0 \\<subseteq> A \\<longrightarrow>\n                       (\\<forall>m\\<in>A.\n                           Equiv_Exec m equiv_states localState1 localState2\n                            input_fun1 input_fun2 output_fun1 output_fun2\n                            trans_fun1 trans_fun2 k1 k2\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 input0 \\<odot> k1) c1)\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 input0 \\<odot> k2) c2));\n                    i < length input\\<rbrakk>\n                   \\<Longrightarrow> equiv_states\n(localState1\n  (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n    c1 \\<div>\\<^sub>l\n   k1 !\n   i))\n(localState2\n  (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n    c2 \\<div>\\<^sub>l\n   k2 !\n   i));\n        0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i'\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 x))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 x))", "apply (drule_tac x=\"f_Exec_Comp trans_fun1 (input_fun1 a # \\<NoMsg>\\<^bsup>k1 - Suc 0\\<^esup>) c1\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i';\n        \\<And>c2 i.\n           \\<lbrakk>equiv_states\n                     (localState1\n                       (f_Exec_Comp trans_fun1\n                         (input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                         c1))\n                     (localState2 c2);\n            \\<forall>input0.\n               set input0 \\<subseteq> A \\<longrightarrow>\n               (\\<forall>m\\<in>A.\n                   Equiv_Exec m equiv_states localState1 localState2\n                    input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1\n                    trans_fun2 k1 k2\n                    (f_Exec_Comp trans_fun1\n                      (map input_fun1 input0 \\<odot> k1)\n                      (f_Exec_Comp trans_fun1\n                        (input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                        c1))\n                    (f_Exec_Comp trans_fun2\n                      (map input_fun2 input0 \\<odot> k2) c2));\n            i < length input\\<rbrakk>\n           \\<Longrightarrow> equiv_states\n                              (localState1\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 i))\n                              (localState2\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  c2 \\<div>\\<^sub>l\n                                 k2 !\n                                 i))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 x))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 x))", "apply (drule_tac x=\"f_Exec_Comp trans_fun2 (input_fun2 a # \\<NoMsg>\\<^bsup>k2 - Suc 0\\<^esup>) c2\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i';\n        \\<And>i.\n           \\<lbrakk>equiv_states\n                     (localState1\n                       (f_Exec_Comp trans_fun1\n                         (input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                         c1))\n                     (localState2\n                       (f_Exec_Comp trans_fun2\n                         (input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                         c2));\n            \\<forall>input0.\n               set input0 \\<subseteq> A \\<longrightarrow>\n               (\\<forall>m\\<in>A.\n                   Equiv_Exec m equiv_states localState1 localState2\n                    input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1\n                    trans_fun2 k1 k2\n                    (f_Exec_Comp trans_fun1\n                      (map input_fun1 input0 \\<odot> k1)\n                      (f_Exec_Comp trans_fun1\n                        (input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                        c1))\n                    (f_Exec_Comp trans_fun2\n                      (map input_fun2 input0 \\<odot> k2)\n                      (f_Exec_Comp trans_fun2\n                        (input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                        c2)));\n            i < length input\\<rbrakk>\n           \\<Longrightarrow> equiv_states\n                              (localState1\n                                (f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 i))\n                              (localState2\n                                (f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 i))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 x))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 x))", "apply (drule_tac x=i' in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i';\n        \\<lbrakk>equiv_states\n                  (localState1\n                    (f_Exec_Comp trans_fun1\n                      (input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>) c1))\n                  (localState2\n                    (f_Exec_Comp trans_fun2\n                      (input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2));\n         \\<forall>input0.\n            set input0 \\<subseteq> A \\<longrightarrow>\n            (\\<forall>m\\<in>A.\n                Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                 k2 (f_Exec_Comp trans_fun1\n                      (map input_fun1 input0 \\<odot> k1)\n                      (f_Exec_Comp trans_fun1\n                        (input_fun1 a # NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                        c1))\n                 (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                   (f_Exec_Comp trans_fun2\n                     (input_fun2 a # NoMsg\\<^bsup>k2 - Suc 0\\<^esup>) c2)));\n         i' < length input\\<rbrakk>\n        \\<Longrightarrow> equiv_states\n                           (localState1\n                             (f_Exec_Comp_Stream trans_fun1\n                               (map input_fun1 input \\<odot> k1)\n                               (f_Exec_Comp trans_fun1\n                                 (input_fun1 a #\n                                  NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                 c1) \\<div>\\<^sub>l\n                              k1 !\n                              i'))\n                           (localState2\n                             (f_Exec_Comp_Stream trans_fun2\n                               (map input_fun2 input \\<odot> k2)\n                               (f_Exec_Comp trans_fun2\n                                 (input_fun2 a #\n                                  NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                 c2) \\<div>\\<^sub>l\n                              k2 !\n                              i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 x))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 x))", "apply (drule meta_mp, simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A;\n        i = Suc i'\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp trans_fun1\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                              (trans_fun1 (input_fun1 a) c1)))\n                          (localState2\n                            (f_Exec_Comp trans_fun2\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                              (trans_fun2 (input_fun2 a) c2)))\n 2. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i';\n        \\<lbrakk>\\<forall>input0.\n                    set input0 \\<subseteq> A \\<longrightarrow>\n                    (\\<forall>m\\<in>A.\n                        Equiv_Exec m equiv_states localState1 localState2\n                         input_fun1 input_fun2 output_fun1 output_fun2\n                         trans_fun1 trans_fun2 k1 k2\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input0 \\<odot> k1)\n                           (f_Exec_Comp trans_fun1\n                             (input_fun1 a #\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                             c1))\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input0 \\<odot> k2)\n                           (f_Exec_Comp trans_fun2\n                             (input_fun2 a #\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                             c2)));\n         i' < length input\\<rbrakk>\n        \\<Longrightarrow> equiv_states\n                           (localState1\n                             (f_Exec_Comp_Stream trans_fun1\n                               (map input_fun1 input \\<odot> k1)\n                               (f_Exec_Comp trans_fun1\n                                 (input_fun1 a #\n                                  NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                 c1) \\<div>\\<^sub>l\n                              k1 !\n                              i'))\n                           (localState2\n                             (f_Exec_Comp_Stream trans_fun2\n                               (map input_fun2 input \\<odot> k2)\n                               (f_Exec_Comp trans_fun2\n                                 (input_fun2 a #\n                                  NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                 c2) \\<div>\\<^sub>l\n                              k2 !\n                              i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 x))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 x))", "apply (drule_tac x=\"[]\" in spec, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2); i' < length input;\n        a \\<in> A; set input \\<subseteq> A; i = Suc i';\n        \\<forall>m\\<in>A.\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            c1 c2\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp trans_fun1\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                              (trans_fun1 (input_fun1 a) c1)))\n                          (localState2\n                            (f_Exec_Comp trans_fun2\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                              (trans_fun2 (input_fun2 a) c2)))\n 2. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i';\n        \\<lbrakk>\\<forall>input0.\n                    set input0 \\<subseteq> A \\<longrightarrow>\n                    (\\<forall>m\\<in>A.\n                        Equiv_Exec m equiv_states localState1 localState2\n                         input_fun1 input_fun2 output_fun1 output_fun2\n                         trans_fun1 trans_fun2 k1 k2\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input0 \\<odot> k1)\n                           (f_Exec_Comp trans_fun1\n                             (input_fun1 a #\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                             c1))\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input0 \\<odot> k2)\n                           (f_Exec_Comp trans_fun2\n                             (input_fun2 a #\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                             c2)));\n         i' < length input\\<rbrakk>\n        \\<Longrightarrow> equiv_states\n                           (localState1\n                             (f_Exec_Comp_Stream trans_fun1\n                               (map input_fun1 input \\<odot> k1)\n                               (f_Exec_Comp trans_fun1\n                                 (input_fun1 a #\n                                  NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                 c1) \\<div>\\<^sub>l\n                              k1 !\n                              i'))\n                           (localState2\n                             (f_Exec_Comp_Stream trans_fun2\n                               (map input_fun2 input \\<odot> k2)\n                               (f_Exec_Comp trans_fun2\n                                 (input_fun2 a #\n                                  NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                 c2) \\<div>\\<^sub>l\n                              k2 !\n                              i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 x))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 x))", "apply (drule_tac x=a in bspec, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2); i' < length input;\n        a \\<in> A; set input \\<subseteq> A; i = Suc i';\n        Equiv_Exec a equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n         c2\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp trans_fun1\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                              (trans_fun1 (input_fun1 a) c1)))\n                          (localState2\n                            (f_Exec_Comp trans_fun2\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                              (trans_fun2 (input_fun2 a) c2)))\n 2. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i < Suc (length input); a \\<in> A; set input \\<subseteq> A;\n        i = Suc i';\n        \\<lbrakk>\\<forall>input0.\n                    set input0 \\<subseteq> A \\<longrightarrow>\n                    (\\<forall>m\\<in>A.\n                        Equiv_Exec m equiv_states localState1 localState2\n                         input_fun1 input_fun2 output_fun1 output_fun2\n                         trans_fun1 trans_fun2 k1 k2\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input0 \\<odot> k1)\n                           (f_Exec_Comp trans_fun1\n                             (input_fun1 a #\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                             c1))\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input0 \\<odot> k2)\n                           (f_Exec_Comp trans_fun2\n                             (input_fun2 a #\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                             c2)));\n         i' < length input\\<rbrakk>\n        \\<Longrightarrow> equiv_states\n                           (localState1\n                             (f_Exec_Comp_Stream trans_fun1\n                               (map input_fun1 input \\<odot> k1)\n                               (f_Exec_Comp trans_fun1\n                                 (input_fun1 a #\n                                  NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                 c1) \\<div>\\<^sub>l\n                              k1 !\n                              i'))\n                           (localState2\n                             (f_Exec_Comp_Stream trans_fun2\n                               (map input_fun2 input \\<odot> k2)\n                               (f_Exec_Comp trans_fun2\n                                 (input_fun2 a #\n                                  NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                 c2) \\<div>\\<^sub>l\n                              k2 !\n                              i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun1\n                                (input_fun1 a #\n                                 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                c1\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun1\n                                  (map input_fun1 input \\<odot> k1)\n                                  (f_Exec_Comp trans_fun1\n                                    (input_fun1 a #\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                                    c1) \\<div>\\<^sub>l\n                                 k1 !\n                                 x))\n                          (localState2\n                            (case i of\n                             0 \\<Rightarrow>\n                               f_Exec_Comp trans_fun2\n                                (input_fun2 a #\n                                 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                c2\n                             | Suc x \\<Rightarrow>\n                                 f_Exec_Comp_Stream trans_fun2\n                                  (map input_fun2 input \\<odot> k2)\n                                  (f_Exec_Comp trans_fun2\n                                    (input_fun2 a #\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                                    c2) \\<div>\\<^sub>l\n                                 k2 !\n                                 x))", "apply (rule Equiv_Exec_equiv_statesI'[of equiv_states localState1 _ localState2 _ _ input_fun1], simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A; i = Suc i';\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1)\n                     (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                       (trans_fun1 (input_fun1 a) c1)))\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                    (trans_fun2 (input_fun2 a) c2)))) \\<Longrightarrow>\n        equiv_states\n         (localState1\n           (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n             (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n               (trans_fun1 (input_fun1 a) c1)) \\<div>\\<^sub>l\n            k1 !\n            i'))\n         (localState2\n           (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n             (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n               (trans_fun2 (input_fun2 a) c2)) \\<div>\\<^sub>l\n            k2 !\n            i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              (f_Exec_Comp trans_fun1\n                                NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                                (trans_fun1 (input_fun1 a)\n                                  c1)) \\<div>\\<^sub>l\n                             k1 !\n                             i'))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              (f_Exec_Comp trans_fun2\n                                NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                                (trans_fun2 (input_fun2 a)\n                                  c2)) \\<div>\\<^sub>l\n                             k2 !\n                             i'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A;\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1)\n                     (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                       (trans_fun1 (input_fun1 a) c1)))\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                    (trans_fun2 (input_fun2 a) c2)))) \\<Longrightarrow>\n        equiv_states\n         (localState1\n           (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n             (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n               (trans_fun1 (input_fun1 a) c1)) \\<div>\\<^sub>l\n            k1 !\n            i'))\n         (localState2\n           (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n             (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n               (trans_fun2 (input_fun2 a) c2)) \\<div>\\<^sub>l\n            k2 !\n            i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              (f_Exec_Comp trans_fun1\n                                NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                                (trans_fun1 (input_fun1 a)\n                                  c1)) \\<div>\\<^sub>l\n                             k1 !\n                             i'))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              (f_Exec_Comp trans_fun2\n                                NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                                (trans_fun2 (input_fun2 a)\n                                  c2)) \\<div>\\<^sub>l\n                             k2 !\n                             i'))", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>input0.\n                            set input0 \\<subseteq> A \\<longrightarrow>\n                            (\\<forall>m\\<in>A.\n                                Equiv_Exec m equiv_states localState1\n                                 localState2 input_fun1 input_fun2\n                                 output_fun1 output_fun2 trans_fun1\n                                 trans_fun2 k1 k2\n                                 (f_Exec_Comp trans_fun1\n                                   (map input_fun1 input0 \\<odot> k1)\n                                   (f_Exec_Comp trans_fun1\n                                     NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                                     (trans_fun1 (input_fun1 a) c1)))\n                                 (f_Exec_Comp trans_fun2\n                                   (map input_fun2 input0 \\<odot> k2)\n                                   (f_Exec_Comp trans_fun2\n                                     NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                                     (trans_fun2 (input_fun2 a) c2))))\n 2. \\<And>a input c1 c2 i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A;\n        equiv_states\n         (localState1\n           (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n             (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n               (trans_fun1 (input_fun1 a) c1)) \\<div>\\<^sub>l\n            k1 !\n            i'))\n         (localState2\n           (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n             (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n               (trans_fun2 (input_fun2 a) c2)) \\<div>\\<^sub>l\n            k2 !\n            i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              (f_Exec_Comp trans_fun1\n                                NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                                (trans_fun1 (input_fun1 a)\n                                  c1)) \\<div>\\<^sub>l\n                             k1 !\n                             i'))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              (f_Exec_Comp trans_fun2\n                                NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                                (trans_fun2 (input_fun2 a)\n                                  c2)) \\<div>\\<^sub>l\n                             k2 !\n                             i'))", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i' input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A;\n        set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1)\n                            (f_Exec_Comp trans_fun1\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                              (trans_fun1 (input_fun1 a) c1)))\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2)\n                            (f_Exec_Comp trans_fun2\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                              (trans_fun2 (input_fun2 a) c2)))\n 2. \\<And>a input c1 c2 i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A;\n        equiv_states\n         (localState1\n           (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n             (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n               (trans_fun1 (input_fun1 a) c1)) \\<div>\\<^sub>l\n            k1 !\n            i'))\n         (localState2\n           (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n             (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n               (trans_fun2 (input_fun2 a) c2)) \\<div>\\<^sub>l\n            k2 !\n            i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              (f_Exec_Comp trans_fun1\n                                NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                                (trans_fun1 (input_fun1 a)\n                                  c1)) \\<div>\\<^sub>l\n                             k1 !\n                             i'))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              (f_Exec_Comp trans_fun2\n                                NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                                (trans_fun2 (input_fun2 a)\n                                  c2)) \\<div>\\<^sub>l\n                             k2 !\n                             i'))", "apply (drule_tac x=\"a # input0\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a input c1 c2 i' input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2); i' < length input;\n        a \\<in> A; set input \\<subseteq> A; set input0 \\<subseteq> A;\n        m \\<in> A;\n        set (a # input0) \\<subseteq> A \\<longrightarrow>\n        (\\<forall>m\\<in>A.\n            Equiv_Exec m equiv_states localState1 localState2 input_fun1\n             input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n             (f_Exec_Comp trans_fun1\n               (map input_fun1 (a # input0) \\<odot> k1) c1)\n             (f_Exec_Comp trans_fun2\n               (map input_fun2 (a # input0) \\<odot> k2) c2))\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1)\n                            (f_Exec_Comp trans_fun1\n                              NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                              (trans_fun1 (input_fun1 a) c1)))\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2)\n                            (f_Exec_Comp trans_fun2\n                              NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                              (trans_fun2 (input_fun2 a) c2)))\n 2. \\<And>a input c1 c2 i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A;\n        equiv_states\n         (localState1\n           (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n             (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n               (trans_fun1 (input_fun1 a) c1)) \\<div>\\<^sub>l\n            k1 !\n            i'))\n         (localState2\n           (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n             (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n               (trans_fun2 (input_fun2 a) c2)) \\<div>\\<^sub>l\n            k2 !\n            i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              (f_Exec_Comp trans_fun1\n                                NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                                (trans_fun1 (input_fun1 a)\n                                  c1)) \\<div>\\<^sub>l\n                             k1 !\n                             i'))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              (f_Exec_Comp trans_fun2\n                                NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                                (trans_fun2 (input_fun2 a)\n                                  c2)) \\<div>\\<^sub>l\n                             k2 !\n                             i'))", "apply (simp add: f_Exec_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a input c1 c2 i'.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m\\<in>A.\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        i' < length input; a \\<in> A; set input \\<subseteq> A;\n        equiv_states\n         (localState1\n           (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n             (f_Exec_Comp trans_fun1 NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n               (trans_fun1 (input_fun1 a) c1)) \\<div>\\<^sub>l\n            k1 !\n            i'))\n         (localState2\n           (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n             (f_Exec_Comp trans_fun2 NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n               (trans_fun2 (input_fun2 a) c2)) \\<div>\\<^sub>l\n            k2 !\n            i'))\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              (f_Exec_Comp trans_fun1\n                                NoMsg\\<^bsup>k1 - Suc 0\\<^esup>\n                                (trans_fun1 (input_fun1 a)\n                                  c1)) \\<div>\\<^sub>l\n                             k1 !\n                             i'))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              (f_Exec_Comp trans_fun2\n                                NoMsg\\<^bsup>k2 - Suc 0\\<^esup>\n                                (trans_fun2 (input_fun2 a)\n                                  c2)) \\<div>\\<^sub>l\n                             k2 !\n                             i'))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Equiv_Exec_Stream_expand_shrink_equiv_state: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. Equiv_Exec m\n       equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n       trans_fun1 trans_fun2 k1 k2\n       (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n       (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    i<length input \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 ((f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1) \\<div>\\<^bsub>fl\\<^esub> k1 ! i))\n    (localState2 ((f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2) \\<div>\\<^bsub>fl\\<^esub> k2 ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1)\n                           c1 \\<div>\\<^sub>l\n                          k1 !\n                          i))\n                       (localState2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2)\n                           c2 \\<div>\\<^sub>l\n                          k2 !\n                          i))", "by (rule f_Equiv_Exec_Stream_expand_shrink_equiv_state_set[of k1 k2 equiv_states localState1 c1 localState2 c2 UNIV input_fun1 input_fun2 output_fun1 output_fun2], simp+)"], ["", "lemma f_Equiv_Exec_expand_shrink_equiv_state_set:\"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    set input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1))\n    (localState2 (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2))", "apply (case_tac \"input = []\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2))", "apply (subgoal_tac \"map input_fun1 input \\<odot>\\<^sub>f k1 \\<noteq> [] \\<and> map input_fun2 input \\<odot>\\<^sub>f k2 \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2))\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n                      map input_fun2 input \\<odot> k2 \\<noteq> []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n                      map input_fun2 input \\<odot> k2 \\<noteq> []\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2))", "apply (simp add: length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2))", "apply (simp add: f_Exec_eq_f_Exec_Stream_last2 last_nth f_Exec_Stream_not_empty_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1 !\n                          (length input * k1 - Suc 0)))\n                       (localState2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2 !\n                          (length input * k2 - Suc 0)))", "apply (insert f_shrink_last_nth[of \"length input - Suc 0\" \"f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1\" k1, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     length input - Suc 0\n     < length\n        (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n          c1) div\n       k1 \\<Longrightarrow>\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     ((length input - Suc 0) * k1 + k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1 !\n                          (length input * k1 - Suc 0)))\n                       (localState2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2 !\n                          (length input * k2 - Suc 0)))", "apply (insert f_shrink_last_nth[of \"length input - Suc 0\" \"f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2\" k2, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     length input - Suc 0\n     < length\n        (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n          c1) div\n       k1 \\<Longrightarrow>\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     ((length input - Suc 0) * k1 + k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0);\n     length input - Suc 0\n     < length\n        (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n          c2) div\n       k2 \\<Longrightarrow>\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n     ((length input - Suc 0) * k2 + k2 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n      c2 \\<div>\\<^sub>l\n     k2 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1 !\n                          (length input * k1 - Suc 0)))\n                       (localState2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2 !\n                          (length input * k2 - Suc 0)))", "apply (simp add: diff_mult_distrib gr0_imp_self_le_mult2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     (length input * k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0);\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n     (length input * k2 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n      c2 \\<div>\\<^sub>l\n     k2 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1)\n                           c1 \\<div>\\<^sub>l\n                          k1 !\n                          (length input - Suc 0)))\n                       (localState2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2)\n                           c2 \\<div>\\<^sub>l\n                          k2 !\n                          (length input - Suc 0)))", "apply (rule f_Equiv_Exec_Stream_expand_shrink_equiv_state_set[of k1 k2 equiv_states localState1 _ localState2 _ A input_fun1 input_fun2 output_fun1 output_fun2])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     (length input * k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0);\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n     (length input * k2 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n      c2 \\<div>\\<^sub>l\n     k2 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     (length input * k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0);\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n     (length input * k2 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n      c2 \\<div>\\<^sub>l\n     k2 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     (length input * k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0);\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n     (length input * k2 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n      c2 \\<div>\\<^sub>l\n     k2 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<And>input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; input \\<noteq> [];\n        map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n        map input_fun2 input \\<odot> k2 \\<noteq> [];\n        f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n        (length input * k1 - Suc 0) =\n        f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n         c1 \\<div>\\<^sub>l\n        k1 !\n        (length input - Suc 0);\n        f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n        (length input * k2 - Suc 0) =\n        f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n         c2 \\<div>\\<^sub>l\n        k2 !\n        (length input - Suc 0);\n        set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1) c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2) c2)\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     (length input * k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0);\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n     (length input * k2 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n      c2 \\<div>\\<^sub>l\n     k2 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> set input \\<subseteq> A\n 6. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A; input \\<noteq> [];\n     map input_fun1 input \\<odot> k1 \\<noteq> [] \\<and>\n     map input_fun2 input \\<odot> k2 \\<noteq> [];\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1) c1 !\n     (length input * k1 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n      c1 \\<div>\\<^sub>l\n     k1 !\n     (length input - Suc 0);\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2) c2 !\n     (length input * k2 - Suc 0) =\n     f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n      c2 \\<div>\\<^sub>l\n     k2 !\n     (length input - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> length input - Suc 0 < length input", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Equiv_Exec_expand_shrink_equiv_state:\"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1))\n    (localState2 (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2))", "by (rule f_Equiv_Exec_expand_shrink_equiv_state_set[of k1 k2 equiv_states localState1 _ localState2 _ UNIV input_fun1 input_fun2 output_fun1 output_fun2], simp+)"], ["", "lemma i_Equiv_Exec_Stream_expand_shrink_equiv_state_set[rule_format]: \"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n        m equiv_states localState1 localState2\n        input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n       (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n       (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 ((i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1 \\<div>\\<^bsub>il\\<^esub> k1) i))\n    (localState2 ((i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2 \\<div>\\<^bsub>il\\<^esub> k2) i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         ((i_Exec_Comp_Stream trans_fun1\n                            ((input_fun1 \\<circ> input) \\<odot> k1)\n                            c1 \\<div>\\<^sub>l\n                           k1)\n                           i))\n                       (localState2\n                         ((i_Exec_Comp_Stream trans_fun2\n                            ((input_fun2 \\<circ> input) \\<odot> k2)\n                            c2 \\<div>\\<^sub>l\n                           k2)\n                           i))", "apply (simp add: i_shrink_last_nth i_Exec_Stream_nth i_expand_i_take_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp trans_fun1\n                           (map input_fun1 (input \\<Down> Suc i) \\<odot> k1)\n                           c1))\n                       (localState2\n                         (f_Exec_Comp trans_fun2\n                           (map input_fun2 (input \\<Down> Suc i) \\<odot> k2)\n                           c2))", "apply (rule f_Equiv_Exec_expand_shrink_equiv_state_set[of\n  k1 k2 equiv_states localState1 c1 localState2 c2 A input_fun1 input_fun2 output_fun1 output_fun2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<And>input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A; set input0 \\<subseteq> A;\n        m \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1) c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2) c2)\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> set (input \\<Down> Suc i) \\<subseteq> A", "apply (simp add: subset_trans[OF set_i_take_subset])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Equiv_Exec_Stream_expand_shrink_equiv_state: \"\n  \\<lbrakk> 0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n        m equiv_states localState1 localState2\n        input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n       (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n       (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (localState1 ((i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1 \\<div>\\<^bsub>il\\<^esub> k1) i))\n    (localState2 ((i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2 \\<div>\\<^bsub>il\\<^esub> k2) i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         ((i_Exec_Comp_Stream trans_fun1\n                            ((input_fun1 \\<circ> input) \\<odot> k1)\n                            c1 \\<div>\\<^sub>l\n                           k1)\n                           i))\n                       (localState2\n                         ((i_Exec_Comp_Stream trans_fun2\n                            ((input_fun2 \\<circ> input) \\<odot> k2)\n                            c2 \\<div>\\<^sub>l\n                           k2)\n                           i))", "by (rule i_Equiv_Exec_Stream_expand_shrink_equiv_state_set[of k1 k2 equiv_states localState1 c1 localState2 c2 UNIV input_fun1 input_fun2 output_fun1 output_fun2], simp+)"], ["", "lemma f_Equiv_Exec_Stream_expand_shrink_output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk> set input0 \\<subseteq> A; m \\<in> A \\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    set input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  (map output_fun1 (\n    f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)) \\<div>\\<^sub>f k1 =\n  (map output_fun2 (\n    f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)) \\<div>\\<^sub>f k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> map output_fun1\n                       (f_Exec_Comp_Stream trans_fun1\n                         (map input_fun1 input \\<odot> k1) c1) \\<div>\n                      k1 =\n                      map output_fun2\n                       (f_Exec_Comp_Stream trans_fun2\n                         (map input_fun2 input \\<odot> k2) c2) \\<div>\n                      k2", "apply (subst list_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> length\n                       (map output_fun1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1) c1) \\<div>\n                        k1) =\n                      length\n                       (map output_fun2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2) c2) \\<div>\n                        k2) \\<and>\n                      (\\<forall>i<length\n                                   (map output_fun1\n                                     (f_Exec_Comp_Stream trans_fun1\n (map input_fun1 input \\<odot> k1) c1) \\<div>\n                                    k1).\n                          map output_fun1\n                           (f_Exec_Comp_Stream trans_fun1\n                             (map input_fun1 input \\<odot> k1) c1) \\<div>\n                          k1 !\n                          i =\n                          map output_fun2\n                           (f_Exec_Comp_Stream trans_fun2\n                             (map input_fun2 input \\<odot> k2) c2) \\<div>\n                          k2 !\n                          i)", "apply (clarsimp simp: f_shrink_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input\\<rbrakk>\n       \\<Longrightarrow> map output_fun1\n                          (f_Exec_Comp_Stream trans_fun1\n                            (map input_fun1 input \\<odot> k1) c1) \\<div>\n                         k1 !\n                         i =\n                         map output_fun2\n                          (f_Exec_Comp_Stream trans_fun2\n                            (map input_fun2 input \\<odot> k2) c2) \\<div>\n                         k2 !\n                         i", "apply (simp del: last.simps f_Exec_Stream_Cons add: f_shrink_nth take_map drop_map f_Exec_Stream_take f_Exec_Stream_drop f_expand_take_mod f_expand_drop_mod take_first)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (frule_tac n=i in subset_trans[OF set_take_subset, rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (unfold atomize_all atomize_imp, intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0 m.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (frule_tac x=\"take i input\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0 m.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        \\<forall>m.\n           set (input \\<down> i) \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1\n              (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2\n              (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (drule_tac x=\"input ! i\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0 m.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        set (input \\<down> i) \\<subseteq> A \\<longrightarrow>\n        input ! i \\<in> A \\<longrightarrow>\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0 m.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        input ! i \\<in> A \\<longrightarrow>\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0 m.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> input ! i \\<in> A\n 2. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0 m.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (blast intro: nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0 m.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (simp del: last.simps f_Exec_Stream_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input ! i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input ! i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (rule Equiv_Exec_output_eqI[of equiv_states localState1 _ localState2 _ _ input_fun1 input_fun2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 (input \\<down> i) \\<odot> k1)\n                              c1))\n                          (localState2\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 (input \\<down> i) \\<odot> k2)\n                              c2))\n 2. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec (input ! i) equiv_states localState1\n                          localState2 input_fun1 input_fun2 output_fun1\n                          output_fun2 trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 (input \\<down> i) \\<odot> k1)\n                            c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 (input \\<down> i) \\<odot> k2)\n                            c2)", "apply (case_tac i, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i nat.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2);\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 (input \\<down> i) \\<odot> k1)\n                              c1))\n                          (localState2\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 (input \\<down> i) \\<odot> k2)\n                              c2))\n 2. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec (input ! i) equiv_states localState1\n                          localState2 input_fun1 input_fun2 output_fun1\n                          output_fun2 trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 (input \\<down> i) \\<odot> k1)\n                            c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 (input \\<down> i) \\<odot> k2)\n                            c2)", "apply (simp add: take_map[symmetric] f_Exec_Stream_expand_shrink_last_nth_eq_f_Exec_Comp[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i nat.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; Suc nat < length input;\n        set (input \\<down> Suc nat) \\<subseteq> A;\n        Equiv_Exec (input ! Suc nat) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n           c1 \\<div>\\<^sub>l\n          k1 !\n          nat)\n         (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n           c2 \\<div>\\<^sub>l\n          k2 !\n          nat);\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              c1 \\<div>\\<^sub>l\n                             k1 !\n                             nat))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              c2 \\<div>\\<^sub>l\n                             k2 !\n                             nat))\n 2. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec (input ! i) equiv_states localState1\n                          localState2 input_fun1 input_fun2 output_fun1\n                          output_fun2 trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 (input \\<down> i) \\<odot> k1)\n                            c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 (input \\<down> i) \\<odot> k2)\n                            c2)", "apply (frule Suc_lessD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i nat.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; Suc nat < length input;\n        set (input \\<down> Suc nat) \\<subseteq> A;\n        Equiv_Exec (input ! Suc nat) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot> k1)\n           c1 \\<div>\\<^sub>l\n          k1 !\n          nat)\n         (f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot> k2)\n           c2 \\<div>\\<^sub>l\n          k2 !\n          nat);\n        i = Suc nat; nat < length input\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (map input_fun1 input \\<odot> k1)\n                              c1 \\<div>\\<^sub>l\n                             k1 !\n                             nat))\n                          (localState2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (map input_fun2 input \\<odot> k2)\n                              c2 \\<div>\\<^sub>l\n                             k2 !\n                             nat))\n 2. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec (input ! i) equiv_states localState1\n                          localState2 input_fun1 input_fun2 output_fun1\n                          output_fun2 trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 (input \\<down> i) \\<odot> k1)\n                            c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 (input \\<down> i) \\<odot> k2)\n                            c2)", "apply (simp add: f_Equiv_Exec_Stream_expand_shrink_equiv_state_set[of k1 k2 equiv_states localState1 _ localState2 _ A input_fun1 input_fun2 output_fun1 output_fun2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input0.\n           set input0 \\<subseteq> A \\<longrightarrow>\n           (\\<forall>m.\n               m \\<in> A \\<longrightarrow>\n               Equiv_Exec m equiv_states localState1 localState2 input_fun1\n                input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1\n                k2 (f_Exec_Comp trans_fun1\n                     (map input_fun1 input0 \\<odot> k1) c1)\n                (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n                  c2));\n        set input \\<subseteq> A; i < length input;\n        set (input \\<down> i) \\<subseteq> A;\n        Equiv_Exec (input ! i) equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2\n         (f_Exec_Comp trans_fun1\n           (map input_fun1 (input \\<down> i) \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2\n           (map input_fun2 (input \\<down> i) \\<odot> k2) c2)\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec (input ! i) equiv_states localState1\n                          localState2 input_fun1 input_fun2 output_fun1\n                          output_fun2 trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 (input \\<down> i) \\<odot> k1)\n                            c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 (input \\<down> i) \\<odot> k2)\n                            c2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Equiv_Exec_Stream_expand_shrink_output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2\n         trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  (map output_fun1 (\n    f_Exec_Comp_Stream trans_fun1 (map input_fun1 input \\<odot>\\<^sub>f k1) c1)) \\<div>\\<^sub>f k1 =\n  (map output_fun2 (\n    f_Exec_Comp_Stream trans_fun2 (map input_fun2 input \\<odot>\\<^sub>f k2) c2)) \\<div>\\<^sub>f k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> map output_fun1\n                       (f_Exec_Comp_Stream trans_fun1\n                         (map input_fun1 input \\<odot> k1) c1) \\<div>\n                      k1 =\n                      map output_fun2\n                       (f_Exec_Comp_Stream trans_fun2\n                         (map input_fun2 input \\<odot> k2) c2) \\<div>\n                      k2", "by (rule f_Equiv_Exec_Stream_expand_shrink_output_set_eq[of k1 k2 equiv_states localState1 _ localState2 _ UNIV], simp+)"], ["", "lemma i_Equiv_Exec_Stream_expand_shrink_output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m. \\<lbrakk> set input0 \\<subseteq> A; m \\<in> A \\<rbrakk> \\<Longrightarrow>\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2\n         trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2);\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  (output_fun1 \\<circ>\n    i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1) \\<div>\\<^sub>i k1 =\n  (output_fun2 \\<circ>\n    i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2) \\<div>\\<^sub>i k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n        \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                           input_fun1 input_fun2 output_fun1 output_fun2\n                           trans_fun1 trans_fun2 k1 k2\n                           (f_Exec_Comp trans_fun1\n                             (map input_fun1 input0 \\<odot> k1) c1)\n                           (f_Exec_Comp trans_fun2\n                             (map input_fun2 input0 \\<odot> k2) c2);\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> (output_fun1 \\<circ>\n                       i_Exec_Comp_Stream trans_fun1\n                        ((input_fun1 \\<circ> input) \\<odot> k1) c1) \\<div>\n                      k1 =\n                      (output_fun2 \\<circ>\n                       i_Exec_Comp_Stream trans_fun2\n                        ((input_fun2 \\<circ> input) \\<odot> k2) c2) \\<div>\n                      k2", "apply (clarsimp simp: ilist_eq_iff, rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> ((output_fun1 \\<circ>\n                           i_Exec_Comp_Stream trans_fun1\n                            ((input_fun1 \\<circ> input) \\<odot> k1)\n                            c1) \\<div>\n                          k1)\n                          i =\n                         ((output_fun2 \\<circ>\n                           i_Exec_Comp_Stream trans_fun2\n                            ((input_fun2 \\<circ> input) \\<odot> k2)\n                            c2) \\<div>\n                          k2)\n                          i", "apply (simp del: last.simps f_Exec_Stream_Cons add: i_shrink_nth i_Exec_Stream_take i_Exec_Stream_drop i_expand_i_take_mod i_expand_i_drop_mod i_take_first map_one f_expand_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun1\n                            (f_Exec_Comp_Stream trans_fun1\n                              (input_fun1 (input i) #\n                               NoMsg\\<^bsup>k1 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 (input \\<Down> i) \\<odot>\n                                 k1)\n                                c1))) =\n                         last_message\n                          (map output_fun2\n                            (f_Exec_Comp_Stream trans_fun2\n                              (input_fun2 (input i) #\n                               NoMsg\\<^bsup>k2 - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 (input \\<Down> i) \\<odot>\n                                 k2)\n                                c2)))", "apply (rule Equiv_Exec_output_eqI[of\n  equiv_states localState1 _ localState2 _ _\n  input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> equiv_states\n                          (localState1\n                            (f_Exec_Comp trans_fun1\n                              (map input_fun1 (input \\<Down> i) \\<odot> k1)\n                              c1))\n                          (localState2\n                            (f_Exec_Comp trans_fun2\n                              (map input_fun2 (input \\<Down> i) \\<odot> k2)\n                              c2))\n 2. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec (input i) equiv_states localState1\n                          localState2 input_fun1 input_fun2 output_fun1\n                          output_fun2 trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 (input \\<Down> i) \\<odot> k1)\n                            c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 (input \\<Down> i) \\<odot> k2)\n                            c2)", "apply (rule f_Equiv_Exec_expand_shrink_equiv_state_set[of\n  k1 k2 equiv_states localState1 _ localState2 _ A\n  input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> 0 < k1\n 2. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> 0 < k2\n 3. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<And>i input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A; set input0 \\<subseteq> A;\n        m \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1) c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2) c2)\n 5. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> set (input \\<Down> i) \\<subseteq> A\n 6. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           \\<lbrakk>set input0 \\<subseteq> A; m \\<in> A\\<rbrakk>\n           \\<Longrightarrow> Equiv_Exec m equiv_states localState1\n                              localState2 input_fun1 input_fun2 output_fun1\n                              output_fun2 trans_fun1 trans_fun2 k1 k2\n                              (f_Exec_Comp trans_fun1\n                                (map input_fun1 input0 \\<odot> k1) c1)\n                              (f_Exec_Comp trans_fun2\n                                (map input_fun2 input0 \\<odot> k2) c2);\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec (input i) equiv_states localState1\n                          localState2 input_fun1 input_fun2 output_fun1\n                          output_fun2 trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 (input \\<Down> i) \\<odot> k1)\n                            c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 (input \\<Down> i) \\<odot> k2)\n                            c2)", "apply (simp add: subset_trans[OF set_i_take_subset] subsetD[OF _ rangeI])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Equiv_Exec_Stream_expand_shrink_output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    \\<And>input0 m.\n       Equiv_Exec\n         m equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot>\\<^sub>f k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot>\\<^sub>f k2) c2) \\<rbrakk> \\<Longrightarrow>\n  (output_fun1 \\<circ>\n    i_Exec_Comp_Stream trans_fun1 ((input_fun1 \\<circ> input) \\<odot>\\<^sub>i k1) c1) \\<div>\\<^sub>i k1 =\n  (output_fun2 \\<circ>\n    i_Exec_Comp_Stream trans_fun2 ((input_fun2 \\<circ> input) \\<odot>\\<^sub>i k2) c2) \\<div>\\<^sub>i k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> (output_fun1 \\<circ>\n                       i_Exec_Comp_Stream trans_fun1\n                        ((input_fun1 \\<circ> input) \\<odot> k1) c1) \\<div>\n                      k1 =\n                      (output_fun2 \\<circ>\n                       i_Exec_Comp_Stream trans_fun2\n                        ((input_fun2 \\<circ> input) \\<odot> k2) c2) \\<div>\n                      k2", "apply (rule i_Equiv_Exec_Stream_expand_shrink_output_set_eq[of\n  k1 k2 equiv_states localState1 c1 localState2 c2 UNIV\n  input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<And>input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<And>input0 m.\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2) c2);\n        set input0 \\<subseteq> UNIV; m \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1) c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2) c2)\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<And>input0 m.\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input0 \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input0 \\<odot> k2)\n           c2)\\<rbrakk>\n    \\<Longrightarrow> range input \\<subseteq> UNIV", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Equiv_Exec_Stream_Acc_LocalState_set: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n      \\<comment> \\<open>\\<open>equiv_states\\<close> relation implies equivalent executions\\<close>\n      \\<comment> \\<open>not only at the beginning but also after processing an input\\<close>\n    set input \\<subseteq> A;\n    i < length input \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (f_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (map input_fun1 input) c1 ! i)\n    (f_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (map input_fun2 input) c2 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (f_Exec_Comp_Stream_Acc_LocalState k1 localState1\n                         trans_fun1 (map input_fun1 input) c1 !\n                        i)\n                       (f_Exec_Comp_Stream_Acc_LocalState k2 localState2\n                         trans_fun2 (map input_fun2 input) c2 !\n                        i)", "apply (unfold f_Exec_Comp_Stream_Acc_LocalState_def Equiv_Exec_stable_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (map localState1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1)\n                           c1) \\<div>\\<^sub>l\n                        k1 !\n                        i)\n                       (map localState2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2)\n                           c2) \\<div>\\<^sub>l\n                        k2 !\n                        i)", "apply (simp add: f_shrink_last_map f_shrink_last_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (localState1\n                         (f_Exec_Comp_Stream trans_fun1\n                           (map input_fun1 input \\<odot> k1)\n                           c1 \\<div>\\<^sub>l\n                          k1 !\n                          i))\n                       (localState2\n                         (f_Exec_Comp_Stream trans_fun2\n                           (map input_fun2 input \\<odot> k2)\n                           c2 \\<div>\\<^sub>l\n                          k2 !\n                          i))", "apply (rule f_Equiv_Exec_Stream_expand_shrink_equiv_state_set[of\n  k1 k2 equiv_states localState1 c1 localState2 c2 A\n  input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 input, rule_format])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<And>input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input m.\n           set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n        set input \\<subseteq> A; i < length input; set input0 \\<subseteq> A;\n        m \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1) c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2) c2)\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> set input \\<subseteq> A\n 6. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A; i < length input\\<rbrakk>\n    \\<Longrightarrow> i < length input", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Equiv_Exec_Stream_Acc_LocalState: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n      \\<comment> \\<open>\\<open>equiv_states\\<close> relation implies equivalent executions\\<close>\n      \\<comment> \\<open>not only at the beginning but also after processing an input\\<close>\n    i < length input \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (f_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (map input_fun1 input) c1 ! i)\n    (f_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (map input_fun2 input) c2 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (f_Exec_Comp_Stream_Acc_LocalState k1 localState1\n                         trans_fun1 (map input_fun1 input) c1 !\n                        i)\n                       (f_Exec_Comp_Stream_Acc_LocalState k2 localState2\n                         trans_fun2 (map input_fun2 input) c2 !\n                        i)", "apply (rule f_Equiv_Exec_Stream_Acc_LocalState_set[where A=UNIV])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> Equiv_Exec_stable_set UNIV equiv_states localState1\n                       localState2 input_fun1 input_fun2 ?output_fun1.0\n                       ?output_fun2.0 trans_fun1 trans_fun2 k1 k2 c1 c2\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> set input \\<subseteq> UNIV\n 6. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     i < length input\\<rbrakk>\n    \\<Longrightarrow> i < length input", "apply (simp add: Equiv_Exec_stable_set_UNIV)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Equiv_Exec_Stream_Acc_Output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n    set input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (map input_fun1 input) c1 =\n  f_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (map input_fun2 input) c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k1 output_fun1\n                       trans_fun1 (map input_fun1 input) c1 =\n                      f_Exec_Comp_Stream_Acc_Output k2 output_fun2\n                       trans_fun2 (map input_fun2 input) c2", "apply (unfold f_Exec_Comp_Stream_Acc_Output_def Equiv_Exec_stable_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> map output_fun1\n                       (f_Exec_Comp_Stream trans_fun1\n                         (map input_fun1 input \\<odot> k1) c1) \\<div>\n                      k1 =\n                      map output_fun2\n                       (f_Exec_Comp_Stream trans_fun2\n                         (map input_fun2 input \\<odot> k2) c2) \\<div>\n                      k2", "apply (rule f_Equiv_Exec_Stream_expand_shrink_output_set_eq[of\n  k1 k2 equiv_states localState1 c1 localState2 c2\n  A input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 input])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<And>input0 m.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        \\<forall>input m.\n           set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n           Equiv_Exec m equiv_states localState1 localState2 input_fun1\n            input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n            (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n            (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n        set input \\<subseteq> A; set input0 \\<subseteq> A;\n        m \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Equiv_Exec m equiv_states localState1 localState2\n                          input_fun1 input_fun2 output_fun1 output_fun2\n                          trans_fun1 trans_fun2 k1 k2\n                          (f_Exec_Comp trans_fun1\n                            (map input_fun1 input0 \\<odot> k1) c1)\n                          (f_Exec_Comp trans_fun2\n                            (map input_fun2 input0 \\<odot> k2) c2)\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     \\<forall>input m.\n        set input \\<subseteq> A \\<and> m \\<in> A \\<longrightarrow>\n        Equiv_Exec m equiv_states localState1 localState2 input_fun1\n         input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2\n         (f_Exec_Comp trans_fun1 (map input_fun1 input \\<odot> k1) c1)\n         (f_Exec_Comp trans_fun2 (map input_fun2 input \\<odot> k2) c2);\n     set input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> set input \\<subseteq> A", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Equiv_Exec_Stream_Acc_Output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (map input_fun1 input) c1 =\n  f_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (map input_fun2 input) c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k1 output_fun1\n                       trans_fun1 (map input_fun1 input) c1 =\n                      f_Exec_Comp_Stream_Acc_Output k2 output_fun2\n                       trans_fun2 (map input_fun2 input) c2", "apply (rule f_Equiv_Exec_Stream_Acc_Output_set_eq[of k1 k2 equiv_states localState1 c1 localState2 c2 UNIV])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> Equiv_Exec_stable_set UNIV equiv_states localState1\n                       localState2 input_fun1 input_fun2 output_fun1\n                       output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> set input \\<subseteq> UNIV", "apply (simp add: Equiv_Exec_stable_set_UNIV)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Equiv_Exec_Stream_Acc_LocalState_set: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2 input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2;\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (i_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (input_fun1 \\<circ> input) c1 i)\n    (i_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (input_fun2 \\<circ> input) c2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (i_Exec_Comp_Stream_Acc_LocalState k1 localState1\n                         trans_fun1 (input_fun1 \\<circ> input) c1 i)\n                       (i_Exec_Comp_Stream_Acc_LocalState k2 localState2\n                         trans_fun2 (input_fun2 \\<circ> input) c2 i)", "apply (simp add: i_Exec_Stream_Acc_LocalState_nth_f_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (f_Exec_Comp_Stream_Acc_LocalState k1 localState1\n                         trans_fun1 (map input_fun1 (input \\<Down> Suc i))\n                         c1 !\n                        i)\n                       (f_Exec_Comp_Stream_Acc_LocalState k2 localState2\n                         trans_fun2 (map input_fun2 (input \\<Down> Suc i))\n                         c2 !\n                        i)", "apply (rule f_Equiv_Exec_Stream_Acc_LocalState_set)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> Equiv_Exec_stable_set ?A6 equiv_states localState1\n                       localState2 input_fun1 input_fun2 ?output_fun1.6\n                       ?output_fun2.6 trans_fun1 trans_fun2 k1 k2 c1 c2\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> set (input \\<Down> Suc i) \\<subseteq> ?A6\n 6. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> i < length (input \\<Down> Suc i)", "apply (simp add:  subset_trans[OF set_i_take_subset])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Equiv_Exec_Stream_Acc_LocalState: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2\n      trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  equiv_states\n    (i_Exec_Comp_Stream_Acc_LocalState k1 localState1 trans_fun1 (input_fun1 \\<circ> input) c1 i)\n    (i_Exec_Comp_Stream_Acc_LocalState k2 localState2 trans_fun2 (input_fun2 \\<circ> input) c2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> equiv_states\n                       (i_Exec_Comp_Stream_Acc_LocalState k1 localState1\n                         trans_fun1 (input_fun1 \\<circ> input) c1 i)\n                       (i_Exec_Comp_Stream_Acc_LocalState k2 localState2\n                         trans_fun2 (input_fun2 \\<circ> input) c2 i)", "apply (rule i_Equiv_Exec_Stream_Acc_LocalState_set[where A=UNIV])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> Equiv_Exec_stable_set UNIV equiv_states localState1\n                       localState2 input_fun1 input_fun2 ?output_fun1.0\n                       ?output_fun2.0 trans_fun1 trans_fun2 k1 k2 c1 c2\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> range input \\<subseteq> UNIV", "apply (simp add: Equiv_Exec_stable_set_UNIV)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Equiv_Exec_Stream_Acc_Output_set_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable_set A\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n    range input \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (input_fun1 \\<circ> input) c1 =\n  i_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (input_fun2 \\<circ> input) c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable_set A equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2;\n     range input \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k1 output_fun1\n                       trans_fun1 (input_fun1 \\<circ> input) c1 =\n                      i_Exec_Comp_Stream_Acc_Output k2 output_fun2\n                       trans_fun2 (input_fun2 \\<circ> input) c2", "apply (clarsimp simp: ilist_eq_iff i_Exec_Stream_Acc_Output_nth_f_nth, rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        Equiv_Exec_stable_set A equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2 c1 c2;\n        range input \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k1 output_fun1\n                          trans_fun1 (map input_fun1 (input \\<Down> Suc i))\n                          c1 !\n                         i =\n                         f_Exec_Comp_Stream_Acc_Output k2 output_fun2\n                          trans_fun2 (map input_fun2 (input \\<Down> Suc i))\n                          c2 !\n                         i", "apply (drule_tac n=\"Suc i\" in subset_trans[OF set_i_take_subset, rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < k1; 0 < k2;\n        equiv_states (localState1 c1) (localState2 c2);\n        Equiv_Exec_stable_set A equiv_states localState1 localState2\n         input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2\n         k1 k2 c1 c2;\n        set (input \\<Down> Suc i) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k1 output_fun1\n                          trans_fun1 (map input_fun1 (input \\<Down> Suc i))\n                          c1 !\n                         i =\n                         f_Exec_Comp_Stream_Acc_Output k2 output_fun2\n                          trans_fun2 (map input_fun2 (input \\<Down> Suc i))\n                          c2 !\n                         i", "apply (simp add: f_Equiv_Exec_Stream_Acc_Output_set_eq[where equiv_states=equiv_states])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Equiv_Exec_Stream_Acc_Output_eq: \"\n  \\<lbrakk> 0 < k1; 0 < k2;\n    equiv_states (localState1 c1) (localState2 c2);\n    Equiv_Exec_stable\n      equiv_states localState1 localState2\n      input_fun1 input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2 \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k1 output_fun1 trans_fun1 (input_fun1 \\<circ> input) c1 =\n  i_Exec_Comp_Stream_Acc_Output k2 output_fun2 trans_fun2 (input_fun2 \\<circ> input) c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k1 output_fun1\n                       trans_fun1 (input_fun1 \\<circ> input) c1 =\n                      i_Exec_Comp_Stream_Acc_Output k2 output_fun2\n                       trans_fun2 (input_fun2 \\<circ> input) c2", "apply (rule i_Equiv_Exec_Stream_Acc_Output_set_eq[of k1 k2 equiv_states localState1 c1 localState2 c2 UNIV])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> 0 < k1\n 2. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> 0 < k2\n 3. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> equiv_states (localState1 c1) (localState2 c2)\n 4. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> Equiv_Exec_stable_set UNIV equiv_states localState1\n                       localState2 input_fun1 input_fun2 output_fun1\n                       output_fun2 trans_fun1 trans_fun2 k1 k2 c1 c2\n 5. \\<lbrakk>0 < k1; 0 < k2; equiv_states (localState1 c1) (localState2 c2);\n     Equiv_Exec_stable equiv_states localState1 localState2 input_fun1\n      input_fun2 output_fun1 output_fun2 trans_fun1 trans_fun2 k1 k2 c1\n      c2\\<rbrakk>\n    \\<Longrightarrow> range input \\<subseteq> UNIV", "apply (simp add: Equiv_Exec_stable_set_UNIV)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Idle states and accelerated execution\\<close>"], ["", "lemma f_Exec_Stream_Acc_LocalState__State_Idle_nth[rule_format]: \"\n  \\<And>c i.\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! n);\n    i < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! i =\n  f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun xs c !\n                         i =\n                         f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         i", "apply (frule length_greater_0_conv[THEN iffD1, OF gr_implies_gr0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun xs c !\n                         i =\n                         f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         i", "apply (simp only: f_Exec_Stream_Acc_LocalState_nth take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            ((xs \\<down> i @ [xs ! i]) \\<odot> k) c) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((xs \\<down> i @ [xs ! i]) \\<odot> l) c)", "apply (simp only: f_expand_snoc f_Exec_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                              c))", "apply (rule_tac s=\"\\<NoMsg>\\<^bsup>l - Suc 0\\<^esup> @ \\<NoMsg>\\<^bsup>k-l\\<^esup>\" and t=\"\\<NoMsg>\\<^bsup>k - Suc 0\\<^esup>\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                         NoMsg\\<^bsup>k - l\\<^esup> =\n                         NoMsg\\<^bsup>k - Suc 0\\<^esup>\n 2. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! i #\n                             NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                              c))", "apply (simp add: replicate_le_diff2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! i #\n                             NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                              c))", "apply (subst append_Cons[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                              c))", "apply (induct xs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < l; l \\<le> k;\n                    Exec_Equal_State localState trans_fun;\n                    \\<forall>n\\<le>i.\n                       State_Idle localState output_fun trans_fun\n                        (f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         n);\n                    i < length xs; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> localState\n(f_Exec_Comp trans_fun\n  ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @ NoMsg\\<^bsup>k - l\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k) c)) =\n                                     localState\n(f_Exec_Comp trans_fun (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l) c));\n        0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             n);\n        i < length (a # xs); a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (((a # xs) ! i #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> k) c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> l) c))", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < l; l \\<le> k;\n                    Exec_Equal_State localState trans_fun;\n                    \\<forall>n\\<le>i.\n                       State_Idle localState output_fun trans_fun\n                        (f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         n);\n                    i < length xs; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> localState\n(f_Exec_Comp trans_fun\n  ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @ NoMsg\\<^bsup>k - l\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k) c)) =\n                                     localState\n(f_Exec_Comp trans_fun (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l) c));\n        0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             n);\n        i < length (a # xs); a # xs \\<noteq> []; i = 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (((a # xs) ! i #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> k) c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> l) c))\n 2. \\<And>a xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < l; l \\<le> k;\n                    Exec_Equal_State localState trans_fun;\n                    \\<forall>n\\<le>i.\n                       State_Idle localState output_fun trans_fun\n                        (f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         n);\n                    i < length xs; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> localState\n(f_Exec_Comp trans_fun\n  ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @ NoMsg\\<^bsup>k - l\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k) c)) =\n                                     localState\n(f_Exec_Comp trans_fun (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l) c));\n        0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             n);\n        i < length (a # xs); a # xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (((a # xs) ! i #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> k) c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> l) c))", "apply (simp add: f_Exec_Stream_Acc_LocalState_Cons f_Exec_State_Idle_append_replicate_NoMsg_state)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i nat.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < l; l \\<le> k;\n                    Exec_Equal_State localState trans_fun;\n                    \\<forall>n\\<le>i.\n                       State_Idle localState output_fun trans_fun\n                        (f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         n);\n                    i < length xs; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> localState\n(f_Exec_Comp trans_fun\n  ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @ NoMsg\\<^bsup>k - l\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k) c)) =\n                                     localState\n(f_Exec_Comp trans_fun (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l) c));\n        0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             n);\n        i < length (a # xs); a # xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (((a # xs) ! i #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> k) c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> l) c))", "apply (rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>\\<And>c i.\n                   \\<lbrakk>0 < l; l \\<le> k;\n                    Exec_Equal_State localState trans_fun;\n                    \\<forall>n\\<le>i.\n                       State_Idle localState output_fun trans_fun\n                        (f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         n);\n                    i < length xs; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> localState\n(f_Exec_Comp trans_fun\n  ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @ NoMsg\\<^bsup>k - l\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k) c)) =\n                                     localState\n(f_Exec_Comp trans_fun (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n  (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l) c));\n        0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             n);\n        i < length (a # xs); a # xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (((a # xs) ! i #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> k) c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> l) c))", "apply (drule_tac x=\"f_Exec_Comp trans_fun (a # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             n);\n        i < length (a # xs); a # xs \\<noteq> []; i = Suc n;\n        \\<And>i.\n           \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n            \\<forall>n\\<le>i.\n               State_Idle localState output_fun trans_fun\n                (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs\n                  (f_Exec_Comp trans_fun\n                    (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c) !\n                 n);\n            i < length xs; xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> localState\n                              (f_Exec_Comp trans_fun\n                                ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                                 NoMsg\\<^bsup>k - l\\<^esup>)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> i \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    c))) =\n                             localState\n                              (f_Exec_Comp trans_fun\n                                (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> i \\<odot> l)\n                                  (f_Exec_Comp trans_fun\n                                    (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (((a # xs) ! i #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> k) c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> l) c))", "apply (drule_tac x=n in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             n);\n        i < length (a # xs); a # xs \\<noteq> []; i = Suc n;\n        \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n         \\<forall>na\\<le>n.\n            State_Idle localState output_fun trans_fun\n             (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs\n               (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                 c) !\n              na);\n         n < length xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> localState\n                           (f_Exec_Comp trans_fun\n                             ((xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                              NoMsg\\<^bsup>k - l\\<^esup>)\n                             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                               (f_Exec_Comp trans_fun\n                                 (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))) =\n                          localState\n                           (f_Exec_Comp trans_fun\n                             (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n                               (f_Exec_Comp trans_fun\n                                 (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                 c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (((a # xs) ! i #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> k) c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            ((a # xs) ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              ((a # xs) \\<down> i \\<odot> l) c))", "apply (simp del: f_Exec_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n;\n        \\<lbrakk>\\<forall>na\\<le>n.\n                    State_Idle localState output_fun trans_fun\n                     (f_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun xs\n                       (f_Exec_Comp trans_fun\n                         (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c) !\n                      na);\n         xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> localState\n                           (f_Exec_Comp trans_fun\n                             (xs ! n #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                              NoMsg\\<^bsup>k - l\\<^esup>)\n                             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                               (f_Exec_Comp trans_fun\n                                 (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))) =\n                          localState\n                           (f_Exec_Comp trans_fun\n                             (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n                               (f_Exec_Comp trans_fun\n                                 (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                 c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n #\n                             NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> l)\n                              c))", "apply (frule length_greater_imp_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n;\n        \\<lbrakk>\\<forall>na\\<le>n.\n                    State_Idle localState output_fun trans_fun\n                     (f_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun xs\n                       (f_Exec_Comp trans_fun\n                         (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c) !\n                      na);\n         xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> localState\n                           (f_Exec_Comp trans_fun\n                             (xs ! n #\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                              NoMsg\\<^bsup>k - l\\<^esup>)\n                             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                               (f_Exec_Comp trans_fun\n                                 (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))) =\n                          localState\n                           (f_Exec_Comp trans_fun\n                             (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n                               (f_Exec_Comp trans_fun\n                                 (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)));\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n #\n                             NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> l)\n                              c))", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>na\\<le>n.\n                            State_Idle localState output_fun trans_fun\n                             (f_Exec_Comp_Stream_Acc_LocalState l localState\n                               trans_fun xs\n                               (f_Exec_Comp trans_fun\n                                 (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c) !\n                              na)\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        xs \\<noteq> [] \\<Longrightarrow>\n        localState\n         (f_Exec_Comp trans_fun\n           (xs ! n #\n            NoMsg\\<^bsup>l - Suc 0\\<^esup> @ NoMsg\\<^bsup>k - l\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n             (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n               c))) =\n        localState\n         (f_Exec_Comp trans_fun (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n             (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n               c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n #\n                             NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> l)\n                              c))", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth f_Exec_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        xs \\<noteq> [] \\<Longrightarrow>\n        localState\n         (f_Exec_Comp trans_fun\n           (xs ! n #\n            NoMsg\\<^bsup>l - Suc 0\\<^esup> @ NoMsg\\<^bsup>k - l\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n             (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n               c))) =\n        localState\n         (f_Exec_Comp trans_fun (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n             (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n               c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n #\n                             NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>k - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> k)\n                              c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                            (f_Exec_Comp trans_fun\n                              (a #\n                               NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                               xs \\<down> n \\<odot> l)\n                              c))", "apply (simp add: append_Cons[symmetric] f_expand_Cons f_Exec_append del: append_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (subgoal_tac \"\n  localState (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n  localState (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (drule_tac x=0 in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        0 \\<le> Suc n \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun (a # xs)\n           c !\n          0)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (simp add: f_Exec_Stream_Acc_LocalState_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun a c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                            (trans_fun a c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup> (trans_fun a c))\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (subst replicate_le_diff2[OF Suc_leI, symmetric], assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun a c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                             NoMsg\\<^bsup>k - l\\<^esup>)\n                            (trans_fun a c)) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup> (trans_fun a c))\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (simp add: append_Cons[symmetric] f_Exec_append del: append_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun a c)))\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun a c))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup> (trans_fun a c))\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (rule f_Exec_State_Idle_replicate_NoMsg_state, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           c)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (case_tac \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c);\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c);\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (frule_tac\n   ?c1.0=\"f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c\" and\n   xs = \"xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>\" in f_Exec_Equal_State)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c);\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n                         localState (?c2.28 a xs c i n)\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c);\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup> \\<noteq> []\n 3. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c);\n        n = 0;\n        f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n         (?c2.28 a xs c i n)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))\n 4. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        localState\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c);\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n           (trans_fun a c)) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun a c));\n        0 < n\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (frule_tac\n  ?c1.0=\"f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c\" and\n  xs = \"xs \\<down> n \\<odot>\\<^sub>f k\" in f_Exec_Equal_State)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n           (trans_fun a c)) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun a c));\n        0 < n\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n                         localState (?c2.33 a xs c i n)\n 2. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n           (trans_fun a c)) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun a c));\n        0 < n\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> n \\<odot> k \\<noteq> []\n 3. \\<And>a xs c i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun\n              (a # xs) c !\n             na);\n        n < length xs; i = Suc n; xs \\<noteq> [];\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (xs ! n)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n                 (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                   (trans_fun a c)))))) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun (xs ! n)\n             (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun a c)))));\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n           (trans_fun a c)) =\n        localState\n         (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n           (trans_fun a c));\n        0 < n;\n        f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n         (f_Exec_Comp trans_fun (a # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) =\n        f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k)\n         (?c2.33 a xs c i n)\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - l\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun (xs ! n)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> k)\n                                  (f_Exec_Comp trans_fun\n                                    NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                    (trans_fun a c)))))) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                            (trans_fun (xs ! n)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> n \\<odot> l)\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                                  (trans_fun a c)))))", "apply (simp add: f_expand_not_empty_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary f_Exec_Stream_Acc_LocalState__State_Idle_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n<length xs. State_Idle localState output_fun trans_fun (\n      f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! n) \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c =\n  f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n<length xs.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n)\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun xs c =\n                      f_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun xs c", "apply (clarsimp simp: list_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun xs c !\n                         i =\n                         f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         i", "apply (rule f_Exec_Stream_Acc_LocalState__State_Idle_nth)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> 0 < l\n 2. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> l \\<le> k\n 3. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State localState trans_fun\n 4. \\<And>i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun12 i) trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           n)\n 5. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> i < length xs", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun12 i) trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           n)", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        i < length xs; n \\<le> i;\n        n < length xs \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun12 i) trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_LocalState__State_Idle_nth[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c n) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c i =\n  i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun input c i =\n                      i_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun input c i", "apply (simp only: f_Exec_Stream_Acc_LocalState_nth_eq_i_nth[of _ _ \"Suc i\", symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun (input \\<Down> Suc i) c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun (input \\<Down> Suc i) c !\n                      i", "apply (rule f_Exec_Stream_Acc_LocalState__State_Idle_nth)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> 0 < l\n 2. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> k\n 3. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> Exec_Equal_State localState trans_fun\n 4. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun16 trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun (input \\<Down> Suc i) c !\n                           n)\n 5. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> i < length (input \\<Down> Suc i)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun16 trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun (input \\<Down> Suc i) c !\n                           n)", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n \\<le> i;\n        n \\<le> i \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun16 trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun (input \\<Down> Suc i) c !\n                           n)", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth_eq_i_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary i_Exec_Stream_Acc_LocalState__State_Idle_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n. State_Idle localState output_fun trans_fun (\n      i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c n) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun input c =\n  i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun input c =\n                      i_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun input c", "apply (clarsimp simp: ilist_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> i_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun input c x =\n                         i_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun input c x", "apply (rule i_Exec_Stream_Acc_LocalState__State_Idle_nth)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> 0 < l\n 2. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> k\n 3. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State localState trans_fun\n 4. \\<And>x n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> x\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun1 x) trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun input c n)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> x\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun1 x) trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun input c n)", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n \\<le> x;\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun1 x) trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun input c n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_Output__State_Idle_nth[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! n);\n    i < length xs \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c ! i =\n  f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun xs c ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i", "apply (drule order_le_less[THEN iffD1], erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i\n 2. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l = k\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l = k\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i\n 2. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i", "apply (frule zero_less_diff[of k l, THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; 0 < k - l\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i", "apply (frule length_greater_imp_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; 0 < k - l; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c !\n                      i", "apply (simp add: f_Exec_Stream_Acc_Output_nth del: f_Exec_Stream_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                             c))) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                             c)))", "apply (subst replicate_le_diff2[OF Suc_leI, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < ?m9\n 2. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ?m9 \\<le> k\n 3. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i #\n                            NoMsg\\<^bsup>?m9 - Suc 0\\<^esup> @\n                            NoMsg\\<^bsup>k - ?m9\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                             c))) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                             c)))", "apply (simp del: f_Exec_Stream_Cons)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i #\n                            NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                            NoMsg\\<^bsup>k - l\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                             c))) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                             c)))", "apply (subst append_Cons[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                            NoMsg\\<^bsup>k - l\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                             c))) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                             c)))", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n);\n     i < length xs; l < k; xs \\<noteq> []; i = 0\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                            NoMsg\\<^bsup>k - l\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                             c))) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                             c)))\n 2. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> l) c)))", "apply (drule_tac x=0 in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; i < length xs;\n     l < k; xs \\<noteq> []; i = 0;\n     0 \\<le> i \\<longrightarrow>\n     State_Idle localState output_fun trans_fun\n      (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n       0)\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                            NoMsg\\<^bsup>k - l\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> k)\n                             c))) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                           (f_Exec_Comp trans_fun (xs \\<down> i \\<odot> l)\n                             c)))\n 2. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> l) c)))", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth take_first f_expand_one del: last.simps f_Exec_Cons f_Exec_Stream_Cons append_Cons replicate.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n     xs \\<noteq> []; i = 0;\n     State_Idle localState output_fun trans_fun\n      (localState\n        (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n          c))\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           ((xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                            NoMsg\\<^bsup>k - l\\<^esup>)\n                           c)) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))\n 2. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> l) c)))", "apply (simp only: f_Exec_Stream_append map_append last_message_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n     xs \\<noteq> []; i = 0;\n     State_Idle localState output_fun trans_fun\n      (localState\n        (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n          c))\\<rbrakk>\n    \\<Longrightarrow> (if last_message\n                           (map output_fun\n                             (f_Exec_Comp_Stream trans_fun\n                               NoMsg\\<^bsup>k - l\\<^esup>\n                               (f_Exec_Comp trans_fun\n                                 (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                 c))) =\n                          NoMsg\n                       then last_message\n                             (map output_fun\n                               (f_Exec_Comp_Stream trans_fun\n                                 (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                 c))\n                       else last_message\n                             (map output_fun\n                               (f_Exec_Comp_Stream trans_fun\n                                 NoMsg\\<^bsup>k - l\\<^esup>\n                                 (f_Exec_Comp trans_fun\n                                   (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                   c)))) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))\n 2. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> l) c)))", "apply (rule if_P')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n     xs \\<noteq> []; i = 0;\n     State_Idle localState output_fun trans_fun\n      (localState\n        (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n          c))\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           NoMsg\\<^bsup>k - l\\<^esup>\n                           (f_Exec_Comp trans_fun\n                             (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                             c))) =\n                      NoMsg\n 2. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n     xs \\<noteq> []; i = 0;\n     State_Idle localState output_fun trans_fun\n      (localState\n        (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n          c))\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))\n 3. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> l) c)))", "apply (clarsimp simp: last_message_NoMsg_conv f_Exec_Stream_nth min_eqL simp del: last.simps f_Exec_Comp.simps append_Cons replicate.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n        xs \\<noteq> []; i = 0;\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c));\n        ia < k - l\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc ia\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              c)) =\n                         NoMsg\n 2. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n     xs \\<noteq> []; i = 0;\n     State_Idle localState output_fun trans_fun\n      (localState\n        (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n          c))\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))\n 3. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> l) c)))", "apply (rule f_Exec_State_Idle_replicate_NoMsg_gr0_output)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n        xs \\<noteq> []; i = 0;\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c));\n        ia < k - l\\<rbrakk>\n       \\<Longrightarrow> State_Idle (?localState21 ia) output_fun trans_fun\n                          (?localState21 ia\n                            (f_Exec_Comp trans_fun\n                              (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))\n 2. \\<And>ia.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n        xs \\<noteq> []; i = 0;\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c));\n        ia < k - l\\<rbrakk>\n       \\<Longrightarrow> 0 < Suc ia\n 3. \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun; l < k;\n     xs \\<noteq> []; i = 0;\n     State_Idle localState output_fun trans_fun\n      (localState\n        (f_Exec_Comp trans_fun (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n          c))\\<rbrakk>\n    \\<Longrightarrow> last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c)) =\n                      last_message\n                       (map output_fun\n                         (f_Exec_Comp_Stream trans_fun\n                           (xs ! 0 # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c))\n 4. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! i # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> i \\<odot> l) c)))", "apply (simp del: last.simps f_Exec_Comp_Stream.simps append_Cons)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>Suc nat.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        Suc nat < length xs; l < k; xs \\<noteq> []; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! Suc nat #\n                                NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc nat \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc nat #\n                               NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc nat \\<odot> l) c)))", "apply (rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              ((xs ! Suc n #\n                                NoMsg\\<^bsup>l - Suc 0\\<^esup>) @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (simp only: f_Exec_Stream_append map_append last_message_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (subgoal_tac \"\n  localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot>\\<^sub>f k) c) =\n  localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot>\\<^sub>f l) c)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> k) c) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> l) c)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> localState\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> k) c) =\n                         localState\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> l) c)\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                          trans_fun xs c !\n                         n =\n                         f_Exec_Comp_Stream_Acc_LocalState l localState\n                          trans_fun xs c !\n                         n\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (rule f_Exec_Stream_Acc_LocalState__State_Idle_nth)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> 0 < l\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> l \\<le> k\n 3. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State localState trans_fun\n 4. \\<And>n na.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        na \\<le> n\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun25 n) trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           na)\n 5. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> n < length xs\n 6. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply simp+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        na \\<le> n\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState (?output_fun25 n) trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           na)\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> n < length xs\n 3. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (rename_tac n, drule_tac x=n in spec, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n\\<rbrakk>\n       \\<Longrightarrow> n < length xs\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> (if last_message\n                              (map output_fun\n                                (f_Exec_Comp_Stream trans_fun\n                                  NoMsg\\<^bsup>k - l\\<^esup>\n                                  (f_Exec_Comp trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))) =\n                             NoMsg\n                          then last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    (xs ! Suc n #\n                                     NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                    (f_Exec_Comp trans_fun\n(xs \\<down> Suc n \\<odot> k) c)))\n                          else last_message\n                                (map output_fun\n                                  (f_Exec_Comp_Stream trans_fun\n                                    NoMsg\\<^bsup>k - l\\<^esup>\n                                    (f_Exec_Comp trans_fun\n(xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n(f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c))))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (rule if_P')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              NoMsg\\<^bsup>k - l\\<^esup>\n                              (f_Exec_Comp trans_fun\n                                (xs ! Suc n #\n                                 NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> Suc n \\<odot> k) c)))) =\n                         NoMsg\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (simp add: last_message_NoMsg_conv f_Exec_Stream_nth min_eqL del: f_Exec_Comp.simps replicate.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<k - l.\n                            output_fun\n                             (f_Exec_Comp trans_fun\n                               NoMsg\\<^bsup>Suc i\\<^esup>\n                               (f_Exec_Comp trans_fun\n                                 (xs ! Suc n #\n                                  NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                 (f_Exec_Comp trans_fun\n                                   (xs \\<down> Suc n \\<odot> k) c))) =\n                            NoMsg\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (clarify, rename_tac j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc j\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         NoMsg\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (frule_tac x=\"Suc n\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l;\n        Suc n \\<le> Suc n \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          Suc n)\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc j\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         NoMsg\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (simp only: f_Exec_Stream_Acc_LocalState_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l;\n        Suc n \\<le> Suc n \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs \\<down> Suc (Suc n) \\<odot> l)\n             c))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc j\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         NoMsg\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (rule_tac\n   ?c1.0=\"f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot>\\<^sub>f l) c\"\n   and ?c2.0=\"f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot>\\<^sub>f k) c\"\n   in subst[OF f_Exec_Equal_State, rule_format])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l;\n        Suc n \\<le> Suc n \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs \\<down> Suc (Suc n) \\<odot> l)\n             c))\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State (?localState42 n j) trans_fun\n 2. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l;\n        Suc n \\<le> Suc n \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs \\<down> Suc (Suc n) \\<odot> l)\n             c))\\<rbrakk>\n       \\<Longrightarrow> ?localState42 n j\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> l) c) =\n                         ?localState42 n j\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> k) c)\n 3. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l;\n        Suc n \\<le> Suc n \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs \\<down> Suc (Suc n) \\<odot> l)\n             c))\\<rbrakk>\n       \\<Longrightarrow> xs ! Suc n #\n                         NoMsg\\<^bsup>l - Suc 0\\<^esup> \\<noteq>\n                         []\n 4. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l;\n        Suc n \\<le> Suc n \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs \\<down> Suc (Suc n) \\<odot> l)\n             c))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc j\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c))) =\n                         NoMsg\n 5. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (simp del: f_Exec_Comp.simps replicate.simps)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c);\n        j < k - l;\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (xs \\<down> Suc (Suc n) \\<odot> l)\n             c))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc j\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c))) =\n                         NoMsg\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (simp only: take_Suc_conv_app_nth f_expand_snoc f_Exec_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState\n         (f_Exec_Comp trans_fun (xs ! n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k) c)) =\n        localState\n         (f_Exec_Comp trans_fun (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l) c));\n        j < k - l;\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun\n             (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             (f_Exec_Comp trans_fun\n               (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n                 c))))\\<rbrakk>\n       \\<Longrightarrow> output_fun\n                          (f_Exec_Comp trans_fun NoMsg\\<^bsup>Suc j\\<^esup>\n                            (f_Exec_Comp trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                                (f_Exec_Comp trans_fun\n                                  (xs \\<down> n \\<odot> l) c)))) =\n                         NoMsg\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (rule f_Exec_State_Idle_replicate_NoMsg_gr0_output, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n j.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState\n         (f_Exec_Comp trans_fun (xs ! n # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> k) c)) =\n        localState\n         (f_Exec_Comp trans_fun (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n           (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l) c));\n        j < k - l;\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun\n             (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             (f_Exec_Comp trans_fun\n               (xs ! n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n               (f_Exec_Comp trans_fun (xs \\<down> n \\<odot> l)\n                 c))))\\<rbrakk>\n       \\<Longrightarrow> 0 < Suc j\n 2. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> k) c))) =\n                         last_message\n                          (map output_fun\n                            (f_Exec_Comp_Stream trans_fun\n                              (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                              (f_Exec_Comp trans_fun\n                                (xs \\<down> Suc n \\<odot> l) c)))", "apply (rule arg_cong[where f=\"\\<lambda>x. last_message (map output_fun x)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; Exec_Equal_State localState trans_fun;\n        \\<forall>na\\<le>Suc n.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             na);\n        Suc n < length xs; l < k; xs \\<noteq> []; i = Suc n;\n        localState (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> k) c) =\n        localState\n         (f_Exec_Comp trans_fun (xs \\<down> Suc n \\<odot> l) c)\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream trans_fun\n                          (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> k) c) =\n                         f_Exec_Comp_Stream trans_fun\n                          (xs ! Suc n # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                          (f_Exec_Comp trans_fun\n                            (xs \\<down> Suc n \\<odot> l) c)", "apply (rule f_Exec_Stream_Equal_State, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_Output__State_Idle_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n<length xs. State_Idle localState output_fun trans_fun (\n      f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c ! n) \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n<length xs.\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n)\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c", "apply (clarsimp simp: list_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun\n                          trans_fun xs c !\n                         i =\n                         f_Exec_Comp_Stream_Acc_Output l output_fun\n                          trans_fun xs c !\n                         i", "apply (rule f_Exec_Stream_Acc_Output__State_Idle_nth)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> 0 < l\n 2. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> l \\<le> k\n 3. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State (?localState12 i) trans_fun\n 4. \\<And>i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle (?localState12 i) output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l\n                            (?localState12 i) trans_fun xs c !\n                           n)\n 5. \\<And>i.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> i < length xs", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n<length xs.\n           State_Idle localState output_fun trans_fun\n            (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n             n);\n        i < length xs; n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           n)", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        i < length xs; n \\<le> i;\n        n < length xs \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c !\n          n)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_Output__State_Idle_nth[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n\\<le>i. State_Idle localState output_fun trans_fun (\n      i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c n) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c i =\n  i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun input c i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input c i =\n                      i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       input c i", "apply (simp only: i_Exec_Stream_Acc_Output_nth_f_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       (input \\<Down> Suc i) c !\n                      i =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       (input \\<Down> Suc i) c !\n                      i", "apply (rule f_Exec_Stream_Acc_Output__State_Idle_nth)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> 0 < l\n 2. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> k\n 3. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> Exec_Equal_State ?localState8 trans_fun\n 4. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle ?localState8 output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l ?localState8\n                            trans_fun (input \\<Down> Suc i) c !\n                           n)\n 5. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n\\<le>i.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> i < length (input \\<Down> Suc i)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n\\<le>i.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun (input \\<Down> Suc i) c !\n                           n)", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n \\<le> i;\n        n \\<le> i \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun (input \\<Down> Suc i) c !\n                           n)", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth_eq_i_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_Output__State_Idle_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    \\<forall>n. State_Idle localState output_fun trans_fun (\n      i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c n) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     \\<forall>n.\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input c =\n                      i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       input c", "apply (clarsimp simp: ilist_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun\n                          trans_fun input c x =\n                         i_Exec_Comp_Stream_Acc_Output l output_fun\n                          trans_fun input c x", "apply (rule i_Exec_Stream_Acc_Output__State_Idle_nth)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> 0 < l\n 2. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> k\n 3. \\<And>x.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n)\\<rbrakk>\n       \\<Longrightarrow> Exec_Equal_State (?localState1 x) trans_fun\n 4. \\<And>x n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> x\\<rbrakk>\n       \\<Longrightarrow> State_Idle (?localState1 x) output_fun trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l\n                            (?localState1 x) trans_fun input c n)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        \\<forall>n.\n           State_Idle localState output_fun trans_fun\n            (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input\n              c n);\n        n \\<le> x\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun input c n)", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        n \\<le> x;\n        State_Idle localState output_fun trans_fun\n         (i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun input c\n           n)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun input c n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  When a certain number @{term l} of steps suffices to reach\n  an idle state from any other idle state,\n  than for any acceleration factor @{term \"k \\<ge> l\"}\n  the accelerated processing of every input message\n  will be finished in an idle state.\\<close>"], ["", "lemma f_Exec_Stream_Acc_LocalState__State_Idle_all[rule_format]: \"\n  \\<And>c xs. \\<lbrakk> 0 < l; l \\<le> k;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c));\n    i < length xs \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun (\n    f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           i)", "apply (frule length_greater_imp_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           i)", "apply (subgoal_tac \"\n  State_Idle localState output_fun trans_fun (\n    localState (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           i)\n 2. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\n 2. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           i)", "apply (drule_tac x=c in spec, drule_tac x=\"hd xs\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))\n 2. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           i)", "apply (rule subst[OF replicate_le_diff2[OF Suc_leI], of 0 l k], assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (hd xs #\n                               NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              c))\n 2. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           i)", "apply (simp add: f_Exec_append f_Exec_State_Idle_replicate_NoMsg_state)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           i)", "apply (induct i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        0 < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           0)\n 2. \\<And>i c xs.\n       \\<lbrakk>\\<And>c xs.\n                   \\<lbrakk>0 < l; l \\<le> k;\n                    State_Idle localState output_fun trans_fun\n                     (localState c);\n                    \\<forall>c m.\n                       State_Idle localState output_fun trans_fun\n                        (localState c) \\<longrightarrow>\n                       State_Idle localState output_fun trans_fun\n                        (localState\n                          (f_Exec_Comp trans_fun\n                            (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c));\n                    i < length xs; xs \\<noteq> [];\n                    State_Idle localState output_fun trans_fun\n                     (localState\n                       (f_Exec_Comp trans_fun\n                         (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                         c))\\<rbrakk>\n                   \\<Longrightarrow> State_Idle localState output_fun\ntrans_fun\n(f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! i);\n        0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           Suc i)", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth take_first hd_eq_first)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>\\<And>c xs.\n                   \\<lbrakk>0 < l; l \\<le> k;\n                    State_Idle localState output_fun trans_fun\n                     (localState c);\n                    \\<forall>c m.\n                       State_Idle localState output_fun trans_fun\n                        (localState c) \\<longrightarrow>\n                       State_Idle localState output_fun trans_fun\n                        (localState\n                          (f_Exec_Comp trans_fun\n                            (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c));\n                    i < length xs; xs \\<noteq> [];\n                    State_Idle localState output_fun trans_fun\n                     (localState\n                       (f_Exec_Comp trans_fun\n                         (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                         c))\\<rbrakk>\n                   \\<Longrightarrow> State_Idle localState output_fun\ntrans_fun\n(f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c ! i);\n        0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           Suc i)", "apply (drule_tac x=\"f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c));\n        \\<And>xsa.\n           \\<lbrakk>0 < l; l \\<le> k;\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun\n                 (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c));\n            \\<forall>c m.\n               State_Idle localState output_fun trans_fun\n                (localState c) \\<longrightarrow>\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun\n                    (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>) c));\n            i < length xsa; xsa \\<noteq> [];\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun\n                 (hd xsa # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                 (f_Exec_Comp trans_fun\n                   (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\\<rbrakk>\n           \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                              (f_Exec_Comp_Stream_Acc_LocalState k\n                                localState trans_fun xsa\n                                (f_Exec_Comp trans_fun\n                                  (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                                  c) !\n                               i)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           Suc i)", "apply (drule_tac x=\"tl xs\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c));\n        \\<lbrakk>0 < l; l \\<le> k;\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              c));\n         \\<forall>c m.\n            State_Idle localState output_fun trans_fun\n             (localState c) \\<longrightarrow>\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                 c));\n         i < length (tl xs); tl xs \\<noteq> [];\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun\n              (hd (tl xs) # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              (f_Exec_Comp trans_fun\n                (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\\<rbrakk>\n        \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                           (f_Exec_Comp_Stream_Acc_LocalState k localState\n                             trans_fun (tl xs)\n                             (f_Exec_Comp trans_fun\n                               (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) !\n                            i)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           Suc i)", "apply (subgoal_tac \"i < length (tl xs) \\<and> tl xs \\<noteq> []\", elim conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c));\n        \\<lbrakk>0 < l; l \\<le> k;\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              c));\n         \\<forall>c m.\n            State_Idle localState output_fun trans_fun\n             (localState c) \\<longrightarrow>\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                 c));\n         i < length (tl xs); tl xs \\<noteq> [];\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun\n              (hd (tl xs) # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              (f_Exec_Comp trans_fun\n                (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\\<rbrakk>\n        \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                           (f_Exec_Comp_Stream_Acc_LocalState k localState\n                             trans_fun (tl xs)\n                             (f_Exec_Comp trans_fun\n                               (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) !\n                            i);\n        i < length (tl xs); tl xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           Suc i)\n 2. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c));\n        \\<lbrakk>0 < l; l \\<le> k;\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              c));\n         \\<forall>c m.\n            State_Idle localState output_fun trans_fun\n             (localState c) \\<longrightarrow>\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                 c));\n         i < length (tl xs); tl xs \\<noteq> [];\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun\n              (hd (tl xs) # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              (f_Exec_Comp trans_fun\n                (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\\<rbrakk>\n        \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                           (f_Exec_Comp_Stream_Acc_LocalState k localState\n                             trans_fun (tl xs)\n                             (f_Exec_Comp trans_fun\n                               (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) !\n                            i)\\<rbrakk>\n       \\<Longrightarrow> i < length (tl xs) \\<and> tl xs \\<noteq> []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c));\n        \\<lbrakk>0 < l; l \\<le> k;\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              c));\n         \\<forall>c m.\n            State_Idle localState output_fun trans_fun\n             (localState c) \\<longrightarrow>\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                 c));\n         i < length (tl xs); tl xs \\<noteq> [];\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun\n              (hd (tl xs) # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              (f_Exec_Comp trans_fun\n                (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\\<rbrakk>\n        \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                           (f_Exec_Comp_Stream_Acc_LocalState k localState\n                             trans_fun (tl xs)\n                             (f_Exec_Comp trans_fun\n                               (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) !\n                            i)\\<rbrakk>\n       \\<Longrightarrow> i < length (tl xs) \\<and> tl xs \\<noteq> []\n 2. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c));\n        \\<lbrakk>0 < l; l \\<le> k;\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              c));\n         \\<forall>c m.\n            State_Idle localState output_fun trans_fun\n             (localState c) \\<longrightarrow>\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                 c));\n         i < length (tl xs); tl xs \\<noteq> [];\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun\n              (hd (tl xs) # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              (f_Exec_Comp trans_fun\n                (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\\<rbrakk>\n        \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                           (f_Exec_Comp_Stream_Acc_LocalState k localState\n                             trans_fun (tl xs)\n                             (f_Exec_Comp trans_fun\n                               (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) !\n                            i);\n        i < length (tl xs); tl xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           Suc i)", "apply (simp add: length_greater_0_conv[symmetric] del: length_greater_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c));\n        \\<lbrakk>0 < l; l \\<le> k;\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              c));\n         \\<forall>c m.\n            State_Idle localState output_fun trans_fun\n             (localState c) \\<longrightarrow>\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                 c));\n         i < length (tl xs); tl xs \\<noteq> [];\n         State_Idle localState output_fun trans_fun\n          (localState\n            (f_Exec_Comp trans_fun\n              (hd (tl xs) # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n              (f_Exec_Comp trans_fun\n                (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c)))\\<rbrakk>\n        \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                           (f_Exec_Comp_Stream_Acc_LocalState k localState\n                             trans_fun (tl xs)\n                             (f_Exec_Comp trans_fun\n                               (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c) !\n                            i);\n        i < length (tl xs); tl xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState k localState\n                            trans_fun xs c !\n                           Suc i)", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd (tl xs))\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (hd xs) c))))) \\<Longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))));\n        i < length xs - Suc 0; tl xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (xs \\<down> Suc (Suc i) \\<odot> k) c))", "apply (rule_tac n=\"Suc i\" in ssubst[OF take_Suc, rule_format], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd (tl xs))\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (hd xs) c))))) \\<Longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))));\n        i < length xs - Suc 0; tl xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              ((hd xs # tl xs \\<down> Suc i) \\<odot> k) c))", "apply (simp add: append_Cons[symmetric] f_Exec_append del: append_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd (tl xs))\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (hd xs) c))))) \\<Longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))));\n        i < length xs - Suc 0; tl xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (tl xs \\<down> Suc i \\<odot> k)\n                              (f_Exec_Comp trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun (hd xs) c))))", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun (hd (tl xs))\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                  (trans_fun (hd xs) c)))))\n 2. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (tl xs \\<down> Suc i \\<odot> k)\n                              (f_Exec_Comp trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun (hd xs) c))))", "apply (drule_tac x=\"f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n             c)) \\<longrightarrow>\n        (\\<forall>m.\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun m\n                   (f_Exec_Comp trans_fun\n                     (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>)\n                     c)))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun (hd (tl xs))\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                  (trans_fun (hd xs) c)))))\n 2. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (tl xs \\<down> Suc i \\<odot> k)\n                              (f_Exec_Comp trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun (hd xs) c))))", "apply (drule mp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        \\<forall>m.\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                (trans_fun m\n                  (f_Exec_Comp trans_fun\n                    (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun (hd (tl xs))\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                  (trans_fun (hd xs) c)))))\n 2. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (tl xs \\<down> Suc i \\<odot> k)\n                              (f_Exec_Comp trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun (hd xs) c))))", "apply (drule_tac x=\"hd (tl xs)\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (hd (tl xs))\n               (f_Exec_Comp trans_fun\n                 (hd xs # NoMsg\\<^bsup>k - Suc 0\\<^esup>) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                              (trans_fun (hd (tl xs))\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                  (trans_fun (hd xs) c)))))\n 2. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (tl xs \\<down> Suc i \\<odot> k)\n                              (f_Exec_Comp trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun (hd xs) c))))", "apply (subst replicate_le_diff2[OF Suc_leI, of 0 l k, symmetric], simp+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n             (trans_fun (hd (tl xs))\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                 (trans_fun (hd xs) c)))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (NoMsg\\<^bsup>l - Suc 0\\<^esup> @\n                               NoMsg\\<^bsup>k - l\\<^esup>)\n                              (trans_fun (hd (tl xs))\n                                (f_Exec_Comp trans_fun\n                                  NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                  (trans_fun (hd xs) c)))))\n 2. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (tl xs \\<down> Suc i \\<odot> k)\n                              (f_Exec_Comp trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun (hd xs) c))))", "apply (simp add: f_Exec_append f_Exec_State_Idle_replicate_NoMsg_state)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i c xs.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        Suc i < length xs; xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n             (trans_fun (hd xs) c)));\n        i < length xs - Suc 0; tl xs \\<noteq> [];\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (tl xs \\<down> Suc i \\<odot> k)\n             (f_Exec_Comp trans_fun NoMsg\\<^bsup>k - Suc 0\\<^esup>\n               (trans_fun (hd xs) c))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (tl xs \\<down> Suc i \\<odot> k)\n                              (f_Exec_Comp trans_fun\n                                NoMsg\\<^bsup>k - Suc 0\\<^esup>\n                                (trans_fun (hd xs) c))))", "apply (simp add: f_Exec_Stream_Acc_LocalState_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_LocalState__State_Idle_all[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  State_Idle localState output_fun trans_fun (\n    i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                       (i_Exec_Comp_Stream_Acc_LocalState k localState\n                         trans_fun xs c i)", "apply (simp only: i_Exec_Stream_Acc_LocalState_nth_f_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                       (f_Exec_Comp_Stream_Acc_LocalState k localState\n                         trans_fun (xs \\<Down> Suc i) c !\n                        i)", "apply (rule f_Exec_Stream_Acc_LocalState__State_Idle_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < l; l \\<le> k;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> 0 < ?l8\n 2. \\<lbrakk>0 < l; l \\<le> k;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> ?l8 \\<le> k\n 3. \\<lbrakk>0 < l; l \\<le> k;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                       (localState c)\n 4. \\<And>ca m.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        State_Idle localState output_fun trans_fun (localState ca)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (m # NoMsg\\<^bsup>?l8 - Suc 0\\<^esup>) ca))\n 5. \\<lbrakk>0 < l; l \\<le> k;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> i < length (xs \\<Down> Suc i)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca m.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           (\\<forall>m.\n               State_Idle localState output_fun trans_fun\n                (localState\n                  (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                    (trans_fun m c))));\n        State_Idle localState output_fun trans_fun (localState ca)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun m ca)))", "apply (rename_tac c' m, drule_tac x=c' in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c' m.\n       \\<lbrakk>0 < l; l \\<le> k;\n        State_Idle localState output_fun trans_fun (localState c);\n        State_Idle localState output_fun trans_fun (localState c');\n        State_Idle localState output_fun trans_fun\n         (localState c') \\<longrightarrow>\n        (\\<forall>m.\n            State_Idle localState output_fun trans_fun\n             (localState\n               (f_Exec_Comp trans_fun NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                 (trans_fun m c'))))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              NoMsg\\<^bsup>l - Suc 0\\<^esup>\n                              (trans_fun m c')))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_Output__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun xs c =\n  f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       xs c =\n                      f_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       xs c", "apply (rule f_Exec_Stream_Acc_Output__State_Idle_eq, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           n)", "apply (simp add: f_Exec_Stream_Acc_LocalState__State_Idle_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_Output__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun input c =\n  i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_Output k output_fun trans_fun\n                       input c =\n                      i_Exec_Comp_Stream_Acc_Output l output_fun trans_fun\n                       input c", "apply (rule i_Exec_Stream_Acc_Output__State_Idle_eq, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState output_fun trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun input c n)", "apply (simp add: i_Exec_Stream_Acc_LocalState__State_Idle_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_Exec_Stream_Acc_LocalState__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  f_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c =\n  f_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> f_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun xs c =\n                      f_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun xs c", "apply (rule f_Exec_Stream_Acc_LocalState__State_Idle_eq, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun trans_fun\n                          (f_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c !\n                           n)", "apply (rule f_Exec_Stream_Acc_LocalState__State_Idle_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> 0 < ?l5 n\n 2. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> ?l5 n \\<le> l\n 3. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun trans_fun\n                          (localState c)\n 4. \\<And>n ca m.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        n < length xs;\n        State_Idle localState ?output_fun trans_fun (localState ca)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (m # NoMsg\\<^bsup>?l5 n - Suc 0\\<^esup>) ca))\n 5. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> n < length xs", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_Exec_Stream_Acc_LocalState__State_Idle_all_imp_eq[rule_format]: \"\n  \\<lbrakk> 0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n    State_Idle localState output_fun trans_fun (localState c);\n    \\<forall>c m. State_Idle localState output_fun trans_fun (localState c) \\<longrightarrow>\n      State_Idle localState output_fun trans_fun (\n        localState (f_Exec_Comp trans_fun (m # \\<NoMsg>\\<^bsup>l - Suc 0\\<^esup>) c)) \\<rbrakk> \\<Longrightarrow>\n  i_Exec_Comp_Stream_Acc_LocalState k localState trans_fun xs c =\n  i_Exec_Comp_Stream_Acc_LocalState l localState trans_fun xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n     State_Idle localState output_fun trans_fun (localState c);\n     \\<forall>c m.\n        State_Idle localState output_fun trans_fun\n         (localState c) \\<longrightarrow>\n        State_Idle localState output_fun trans_fun\n         (localState\n           (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n             c))\\<rbrakk>\n    \\<Longrightarrow> i_Exec_Comp_Stream_Acc_LocalState k localState\n                       trans_fun xs c =\n                      i_Exec_Comp_Stream_Acc_LocalState l localState\n                       trans_fun xs c", "apply (rule i_Exec_Stream_Acc_LocalState__State_Idle_eq, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun trans_fun\n                          (i_Exec_Comp_Stream_Acc_LocalState l localState\n                            trans_fun xs c n)", "apply (rule i_Exec_Stream_Acc_LocalState__State_Idle_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c))\\<rbrakk>\n       \\<Longrightarrow> 0 < ?l5 n\n 2. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c))\\<rbrakk>\n       \\<Longrightarrow> ?l5 n \\<le> l\n 3. \\<And>n.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c))\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun trans_fun\n                          (localState c)\n 4. \\<And>n ca m.\n       \\<lbrakk>0 < l; l \\<le> k; Exec_Equal_State localState trans_fun;\n        State_Idle localState output_fun trans_fun (localState c);\n        \\<forall>c m.\n           State_Idle localState output_fun trans_fun\n            (localState c) \\<longrightarrow>\n           State_Idle localState output_fun trans_fun\n            (localState\n              (f_Exec_Comp trans_fun (m # NoMsg\\<^bsup>l - Suc 0\\<^esup>)\n                c));\n        State_Idle localState ?output_fun trans_fun (localState ca)\\<rbrakk>\n       \\<Longrightarrow> State_Idle localState ?output_fun trans_fun\n                          (localState\n                            (f_Exec_Comp trans_fun\n                              (m # NoMsg\\<^bsup>?l5 n - Suc 0\\<^esup>) ca))", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Converting inputs\\<close>"], ["", "lemma f_Exec_input_map: \"\\<And>c.\n  f_Exec_Comp trans_fun (map f xs) c = f_Exec_Comp (trans_fun \\<circ> f) xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       f_Exec_Comp trans_fun (map f xs) c =\n       f_Exec_Comp (trans_fun \\<circ> f) xs c", "by (induct xs, simp+)"], ["", "lemma f_Exec_Stream_input_map: \"\n  f_Exec_Comp_Stream trans_fun (map f xs) c =\n  f_Exec_Comp_Stream (trans_fun \\<circ> f) xs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_Exec_Comp_Stream trans_fun (map f xs) c =\n    f_Exec_Comp_Stream (trans_fun \\<circ> f) xs c", "by (simp add: list_eq_iff f_Exec_Stream_nth take_map f_Exec_input_map)"], ["", "lemma i_Exec_Stream_input_map: \"\n  i_Exec_Comp_Stream trans_fun (f \\<circ> input) c =\n  i_Exec_Comp_Stream (trans_fun \\<circ> f) input c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_Exec_Comp_Stream trans_fun (f \\<circ> input) c =\n    i_Exec_Comp_Stream (trans_fun \\<circ> f) input c", "by (simp add: ilist_eq_iff i_Exec_Stream_nth f_Exec_input_map)"], ["", "end"]]}