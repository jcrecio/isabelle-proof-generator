{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Search_Trees/Prio_Map_Specs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Priority_Search_Trees", "problem_names": ["lemma sorted_Cons_iff:\n  \"sorted(x # xs) = ((\\<forall>y \\<in> set xs. x < y) \\<and> sorted xs)\"", "lemma sorted_map_of_Some_eq: \n  \"sorted1 xs \\<Longrightarrow> map_of xs k = Some v \\<longleftrightarrow> (k,v)\\<in>set xs\"", "lemmas prio_map_specs = map_specs map_is_empty", "lemma map_getminE:\n  assumes \"getmin m = (k,p)\" \"invar m\" \"lookup m \\<noteq> Map.empty\" \n  obtains \"lookup m k = Some p\" \"\\<forall>k' p'. lookup m k' = Some p' \\<longrightarrow> p\\<le>p'\"", "lemma \n  inorder_isempty: \"invar t \\<Longrightarrow> is_empty t \\<longleftrightarrow> inorder t = []\"\n  and inorder_getmin: \"\\<lbrakk>invar t; inorder t \\<noteq> []; getmin t = (a,b)\\<rbrakk> \n        \\<Longrightarrow> is_min2 (a,b) (set (inorder t))\"", "lemma inorder_lookup_empty_iff: \n  \"invar m \\<Longrightarrow> lookup m = Map.empty \\<longleftrightarrow> inorder m = []\"", "lemma inorder_lookup_ran_eq: \n  \"\\<lbrakk>inv m; sorted1 (inorder m)\\<rbrakk> \\<Longrightarrow> ran (lookup m) = snd ` set (inorder m)\""], "translations": [["", "lemma sorted_Cons_iff:\n  \"sorted(x # xs) = ((\\<forall>y \\<in> set xs. x < y) \\<and> sorted xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (x # xs) = ((\\<forall>y\\<in>set xs. x < y) \\<and> sorted xs)", "by(simp add: sorted_wrt_Cons)"], ["", "(** TODO: Belongs into AList_Upd_Del *)"], ["", "lemma sorted_map_of_Some_eq: \n  \"sorted1 xs \\<Longrightarrow> map_of xs k = Some v \\<longleftrightarrow> (k,v)\\<in>set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted1 xs \\<Longrightarrow>\n    (map_of xs k = Some v) = ((k, v) \\<in> set xs)", "by (induction xs arbitrary: k v) (auto split: if_splits simp: sorted_Cons_iff)"], ["", "(*>*)"], ["", "subsection \\<open>Abstract Data Type\\<close>"], ["", "locale PrioMap = Map where lookup = lookup \n  for lookup :: \"'m \\<Rightarrow> 'a \\<Rightarrow> 'b::linorder option\" +\n  fixes is_empty :: \"'m \\<Rightarrow> bool\"\n  fixes getmin :: \"'m \\<Rightarrow> 'a \\<times> 'b\"\n  assumes map_is_empty: \"invar m \\<Longrightarrow> is_empty m \\<longleftrightarrow> lookup m = Map.empty\"\n  and map_getmin: \"getmin m = (k,p) \\<Longrightarrow> invar m \\<Longrightarrow> lookup m \\<noteq> Map.empty \n  \\<Longrightarrow> lookup m k = Some p \\<and> (\\<forall>p'\\<in>ran (lookup m). p\\<le>p')\"\nbegin"], ["", "lemmas prio_map_specs = map_specs map_is_empty"], ["", "lemma map_getminE:\n  assumes \"getmin m = (k,p)\" \"invar m\" \"lookup m \\<noteq> Map.empty\" \n  obtains \"lookup m k = Some p\" \"\\<forall>k' p'. lookup m k' = Some p' \\<longrightarrow> p\\<le>p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>lookup m k = Some p;\n      \\<forall>k' p'.\n         lookup m k' = Some p' \\<longrightarrow> p \\<le> p'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using map_getmin[OF assms]"], ["proof (prove)\nusing this:\n  lookup m k = Some p \\<and> (\\<forall>p'\\<in>ran (lookup m). p \\<le> p')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>lookup m k = Some p;\n      \\<forall>k' p'.\n         lookup m k' = Some p' \\<longrightarrow> p \\<le> p'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ran_def)"], ["", "end"], ["", "definition is_min2 :: \"(_\\<times>'a::linorder) \\<Rightarrow> (_\\<times>'a) set \\<Rightarrow> bool\" where\n\"is_min2 x xs \\<equiv> x\\<in>xs \\<and> (\\<forall>y\\<in>xs. snd x \\<le> snd y)\""], ["", "subsection \\<open>Inorder-Based Specification\\<close>"], ["", "locale PrioMap_by_Ordered = Map_by_Ordered \n  where lookup=lookup for lookup :: \"'t \\<Rightarrow> 'a::linorder \\<Rightarrow> 'b::linorder option\" +\n  fixes is_empty :: \"'t \\<Rightarrow> bool\"\n  fixes getmin :: \"'t \\<Rightarrow> 'a\\<times>'b\"\n  assumes inorder_isempty': \"\\<lbrakk>inv t; sorted1 (inorder t)\\<rbrakk> \n      \\<Longrightarrow> is_empty t \\<longleftrightarrow> inorder t = []\"\n  and inorder_getmin': \n      \"\\<lbrakk>inv t; sorted1 (inorder t); inorder t \\<noteq> []; getmin t = (a,b)\\<rbrakk> \n        \\<Longrightarrow> is_min2 (a,b) (set (inorder t))\"\nbegin"], ["", "lemma \n  inorder_isempty: \"invar t \\<Longrightarrow> is_empty t \\<longleftrightarrow> inorder t = []\"\n  and inorder_getmin: \"\\<lbrakk>invar t; inorder t \\<noteq> []; getmin t = (a,b)\\<rbrakk> \n        \\<Longrightarrow> is_min2 (a,b) (set (inorder t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invar t \\<Longrightarrow> is_empty t = (inorder t = [])) &&&\n    (\\<lbrakk>invar t; inorder t \\<noteq> []; getmin t = (a, b)\\<rbrakk>\n     \\<Longrightarrow> is_min2 (a, b) (set (inorder t)))", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv t \\<and> sorted1 (inorder t) \\<Longrightarrow>\n     is_empty t = (inorder t = [])) &&&\n    (\\<lbrakk>inv t \\<and> sorted1 (inorder t); inorder t \\<noteq> [];\n      getmin t = (a, b)\\<rbrakk>\n     \\<Longrightarrow> is_min2 (a, b) (set (inorder t)))", "by (auto simp: inorder_isempty' inorder_getmin')"], ["", "lemma inorder_lookup_empty_iff: \n  \"invar m \\<Longrightarrow> lookup m = Map.empty \\<longleftrightarrow> inorder m = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar m \\<Longrightarrow> (lookup m = Map.empty) = (inorder m = [])", "using inorder_lookup[of m]"], ["proof (prove)\nusing this:\n  inv m \\<and> sorted1 (inorder m) \\<Longrightarrow>\n  lookup m ?a = map_of (inorder m) ?a\n\ngoal (1 subgoal):\n 1. invar m \\<Longrightarrow> (lookup m = Map.empty) = (inorder m = [])", "apply (auto split: if_splits simp: invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. None = map_of (inorder m) a; inv m;\n     sorted1 (inorder m); lookup m = Map.empty\\<rbrakk>\n    \\<Longrightarrow> inorder m = []", "by (metis map_of.elims option.discI)"], ["", "lemma inorder_lookup_ran_eq: \n  \"\\<lbrakk>inv m; sorted1 (inorder m)\\<rbrakk> \\<Longrightarrow> ran (lookup m) = snd ` set (inorder m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv m; sorted1 (inorder m)\\<rbrakk>\n    \\<Longrightarrow> ran (lookup m) = snd ` set (inorder m)", "using inorder_lookup[of m]"], ["proof (prove)\nusing this:\n  inv m \\<and> sorted1 (inorder m) \\<Longrightarrow>\n  lookup m ?a = map_of (inorder m) ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inv m; sorted1 (inorder m)\\<rbrakk>\n    \\<Longrightarrow> ran (lookup m) = snd ` set (inorder m)", "unfolding ran_def"], ["proof (prove)\nusing this:\n  inv m \\<and> sorted1 (inorder m) \\<Longrightarrow>\n  lookup m ?a = map_of (inorder m) ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inv m; sorted1 (inorder m)\\<rbrakk>\n    \\<Longrightarrow> {b. \\<exists>a. lookup m a = Some b} =\n                      snd ` set (inorder m)", "by (force simp: sorted_map_of_Some_eq)"], ["", "sublocale PrioMap empty update delete invar lookup is_empty getmin"], ["proof (prove)\ngoal (1 subgoal):\n 1. PrioMap empty update delete invar lookup is_empty getmin", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> is_empty m = (lookup m = Map.empty)\n 2. \\<And>m k p.\n       \\<lbrakk>getmin m = (k, p); invar m;\n        lookup m \\<noteq> Map.empty\\<rbrakk>\n       \\<Longrightarrow> lookup m k = Some p \\<and>\n                         (\\<forall>p'\\<in>ran (lookup m). p \\<le> p')", "apply (auto simp: inorder_isempty inorder_lookup_empty_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k p.\n       \\<lbrakk>getmin m = (k, p); invar m; inorder m \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> lookup m k = Some p\n 2. \\<And>m k p p'.\n       \\<lbrakk>getmin m = (k, p); invar m; inorder m \\<noteq> [];\n        p' \\<in> ran (lookup m)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> p'", "apply (frule (2) inorder_getmin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k p.\n       \\<lbrakk>getmin m = (k, p); invar m; inorder m \\<noteq> [];\n        is_min2 (k, p) (set (inorder m))\\<rbrakk>\n       \\<Longrightarrow> lookup m k = Some p\n 2. \\<And>m k p p'.\n       \\<lbrakk>getmin m = (k, p); invar m; inorder m \\<noteq> [];\n        p' \\<in> ran (lookup m)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> p'", "apply (auto simp: is_min2_def sorted_map_of_Some_eq invar_def inorder_lookup) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k p p'.\n       \\<lbrakk>getmin m = (k, p); invar m; inorder m \\<noteq> [];\n        p' \\<in> ran (lookup m)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> p'", "apply (frule (2) inorder_getmin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k p p'.\n       \\<lbrakk>getmin m = (k, p); invar m; inorder m \\<noteq> [];\n        p' \\<in> ran (lookup m); is_min2 (k, p) (set (inorder m))\\<rbrakk>\n       \\<Longrightarrow> p \\<le> p'", "apply (force simp: is_min2_def sorted_map_of_Some_eq inorder_lookup_ran_eq \n                   eq_Min_iff invar_def inorder_lookup) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}