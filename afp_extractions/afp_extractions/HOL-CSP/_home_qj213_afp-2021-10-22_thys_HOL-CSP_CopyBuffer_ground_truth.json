{"file_name": "/home/qj213/afp-2021-10-22/thys/HOL-CSP/CopyBuffer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOL-CSP", "problem_names": ["lemma [simp]: \"left x  \\<notin>  SYN\"", "lemma [simp]: \"right x  \\<notin>  SYN\"", "lemma [simp]: \"ack \\<in> SYN\"", "lemma [simp]: \"mid x \\<in> SYN\"", "lemma [simp]: \"inj mid\"", "lemma \"finite (SYN:: 'a channel set) \\<Longrightarrow> finite {(t::'a). True}\"", "lemma COPY_rec:\n  \"COPY = (left`?`x \\<rightarrow> (right`!`x \\<rightarrow> COPY))\"", "lemma SEND_rec: \n  \"SEND = (left`?`x \\<rightarrow> (mid`!`x \\<rightarrow> (ack \\<rightarrow> SEND)))\"", "lemma REC_rec:\n  \"REC = (mid`?`x \\<rightarrow> (right`!`x \\<rightarrow> (ack \\<rightarrow> REC)))\"", "lemma impl_refines_spec : \"COPY \\<sqsubseteq> SYSTEM\"", "lemma spec_refines_impl : \n  assumes fin: \"finite (SYN:: 'a channel set)\"\n  shows        \"SYSTEM \\<sqsubseteq> (COPY :: 'a channel process)\"", "lemma spec_equal_impl : \nassumes fin:  \"finite (SYN::('a channel)set)\"\nshows         \"SYSTEM = (COPY::'a channel process)\"", "lemma \"(DF (range left \\<union> range right)) \\<sqsubseteq>\\<^sub>F\\<^sub>D COPY\"", "lemma impl_refines_spec' : \"(COPY'::'a channel process) \\<sqsubseteq> SYSTEM'\"", "lemma spec_refines_impl' : \nassumes fin:  \"finite (SYN::('a channel)set)\"\nshows         \"SYSTEM' \\<sqsubseteq> (COPY'::'a channel process)\"", "lemma spec_equal_impl' : \nassumes fin:  \"finite (SYN::('a channel)set)\"\nshows         \"SYSTEM' = (COPY'::'a channel process)\""], "translations": [["", "lemma [simp]: \"left x  \\<notin>  SYN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left x \\<notin> SYN", "by(auto simp: SYN_def)"], ["", "lemma [simp]: \"right x  \\<notin>  SYN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right x \\<notin> SYN", "by(auto simp: SYN_def)"], ["", "lemma [simp]: \"ack \\<in> SYN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ack \\<in> SYN", "by(auto simp: SYN_def)"], ["", "lemma [simp]: \"mid x \\<in> SYN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mid x \\<in> SYN", "by(auto simp: SYN_def)"], ["", "lemma [simp]: \"inj mid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj mid", "by(auto simp: inj_on_def)"], ["", "lemma \"finite (SYN:: 'a channel set) \\<Longrightarrow> finite {(t::'a). True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite SYN \\<Longrightarrow> finite {t. True}", "by (metis (no_types) SYN_def UNIV_def channel.inject(3) finite_Un finite_imageD inj_on_def)"], ["", "subsection\\<open> Definitions by Recursors \\<close>"], ["", "text\\<open> Second part: Derive recursive process equations, which\n       are easier to handle in proofs. This part IS actually\n       automated if we could reuse the fixrec-syntax below. \\<close>"], ["", "lemma COPY_rec:\n  \"COPY = (left`?`x \\<rightarrow> (right`!`x \\<rightarrow> COPY))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COPY = (left`?`x \\<rightarrow> right`!`x \\<rightarrow> COPY)", "by(simp add: COPY_def,rule trans, rule fix_eq, simp)"], ["", "lemma SEND_rec: \n  \"SEND = (left`?`x \\<rightarrow> (mid`!`x \\<rightarrow> (ack \\<rightarrow> SEND)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SEND =\n    (left`?`x \\<rightarrow> mid`!`x \\<rightarrow> ack \\<rightarrow> SEND)", "by(simp add: SEND_def,rule trans, rule fix_eq, simp)"], ["", "lemma REC_rec:\n  \"REC = (mid`?`x \\<rightarrow> (right`!`x \\<rightarrow> (ack \\<rightarrow> REC)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC =\n    (mid`?`x \\<rightarrow> right`!`x \\<rightarrow> ack \\<rightarrow> REC)", "by(simp add: REC_def,rule trans, rule fix_eq, simp)"], ["", "subsection\\<open> A Refinement Proof \\<close>"], ["", "text\\<open> Third part: No comes the proof by fixpoint induction. \n       Not too bad in automation considering what is inferred,\n       but wouldn't scale for large examples. \\<close>"], ["", "lemma impl_refines_spec : \"COPY \\<sqsubseteq> SYSTEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COPY \\<sqsubseteq> SYSTEM", "apply(simp add: SYSTEM_def COPY_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> x.\n        left`?`xa \\<rightarrow> right`!`xa \\<rightarrow> x) \\<sqsubseteq>\n    (SEND \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN", "apply(rule fix_ind, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq>\n       (SEND \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<Longrightarrow>\n       (left`?`xa \\<rightarrow> right`!`xa \\<rightarrow> x) \\<sqsubseteq>\n       (SEND \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN", "by (subst SEND_rec, subst REC_rec, simp add: sync_rules hide_rules mono_rules)"], ["", "lemma spec_refines_impl : \n  assumes fin: \"finite (SYN:: 'a channel set)\"\n  shows        \"SYSTEM \\<sqsubseteq> (COPY :: 'a channel process)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SYSTEM \\<sqsubseteq> COPY", "apply(simp add: SYSTEM_def SEND_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<mu> x.\n         left`?`xa \n            \\<rightarrow> mid`!`xa \n                             \\<rightarrow> ack \n        \\<rightarrow> x) \\<lbrakk>SYN\\<rbrakk>\n        REC) \\ SYN \\<sqsubseteq>\n    COPY", "apply(rule fix_ind, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. (a \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq> COPY)\n 2. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq> COPY\n 3. \\<And>x.\n       (x \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq>\n       COPY \\<Longrightarrow>\n       (left`?`xa \n           \\<rightarrow> mid`!`xa \n                            \\<rightarrow> ack \n       \\<rightarrow> x \\<lbrakk>SYN\\<rbrakk>\n           REC) \\ SYN \\<sqsubseteq>\n       COPY", "using adm_below hiding_cont[of SYN \"\\<lambda>(a:: 'a channel process). (a \\<lbrakk>SYN\\<rbrakk> REC)\", OF fin]"], ["proof (prove)\nusing this:\n  \\<lbrakk>cont ?u; cont ?v\\<rbrakk>\n  \\<Longrightarrow> adm (\\<lambda>x. ?u x \\<sqsubseteq> ?v x)\n  cont (\\<lambda>a. a \\<lbrakk>SYN\\<rbrakk> REC) \\<Longrightarrow>\n  cont (\\<lambda>x. (x \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. (a \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq> COPY)\n 2. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq> COPY\n 3. \\<And>x.\n       (x \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq>\n       COPY \\<Longrightarrow>\n       (left`?`xa \n           \\<rightarrow> mid`!`xa \n                            \\<rightarrow> ack \n       \\<rightarrow> x \\<lbrakk>SYN\\<rbrakk>\n           REC) \\ SYN \\<sqsubseteq>\n       COPY", "apply (simp add: contI cont_left_sync chain_Sync1 thelubE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq> COPY\n 2. \\<And>x.\n       (x \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq>\n       COPY \\<Longrightarrow>\n       (left`?`xa \n           \\<rightarrow> mid`!`xa \n                            \\<rightarrow> ack \n       \\<rightarrow> x \\<lbrakk>SYN\\<rbrakk>\n           REC) \\ SYN \\<sqsubseteq>\n       COPY", "apply (simp add: hide_set_bot par_Int_bot sync_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<lbrakk>SYN\\<rbrakk> REC) \\ SYN \\<sqsubseteq>\n       COPY \\<Longrightarrow>\n       (left`?`xa \n           \\<rightarrow> mid`!`xa \n                            \\<rightarrow> ack \n       \\<rightarrow> x \\<lbrakk>SYN\\<rbrakk>\n           REC) \\ SYN \\<sqsubseteq>\n       COPY", "by (subst COPY_rec, subst REC_rec, simp add:sync_rules hide_rules mono_rules)"], ["", "text\\<open> Note that this was actually proven for the\n       Process ordering, not the refinement ordering. \n       But the former implies the latter.\n       And due to anti-symmetry, equality follows\n       for the case of finite alphabets \\ldots \\<close>"], ["", "lemma spec_equal_impl : \nassumes fin:  \"finite (SYN::('a channel)set)\"\nshows         \"SYSTEM = (COPY::'a channel process)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SYSTEM = COPY", "by (simp add: below_antisym fin impl_refines_spec spec_refines_impl)"], ["", "subsection\\<open>Deadlock Freeness Proof \\<close>"], ["", "text\\<open>HOL-CSP can be used to prove deadlock-freeness of processes with infinite alphabet. In the\ncase of the @{term COPY} - process, this can be formulated as the following refinement problem:\\<close>"], ["", "lemma \"(DF (range left \\<union> range right)) \\<sqsubseteq>\\<^sub>F\\<^sub>D COPY\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DF (range left \\<union> range right) \\<sqsubseteq>\\<^sub>F\\<^sub>D COPY", "apply(simp add:DF_def,rule fix_ind2,simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. a \\<sqsubseteq>\\<^sub>F\\<^sub>D COPY)\n 2. \\<bottom> \\<sqsubseteq>\\<^sub>F\\<^sub>D COPY\n 3. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>) \\<sqsubseteq>\\<^sub>F\\<^sub>D\n    COPY\n 4. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq>\\<^sub>F\\<^sub>D COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n            x) \\<sqsubseteq>\\<^sub>F\\<^sub>D\n        COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x) \\<sqsubseteq>\\<^sub>F\\<^sub>D\n                         COPY", "unfolding failure_divergence_refine_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. a \\<le> COPY)\n 2. \\<bottom> \\<le> COPY\n 3. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 4. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. a \\<le> COPY)\n 2. \\<bottom> \\<le> COPY\n 3. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 4. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "show \"adm (\\<lambda>a. a \\<le> COPY)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>a. a \\<le> COPY)", "by(rule le_adm, simp_all add:monofunI)"], ["proof (state)\nthis:\n  adm (\\<lambda>a. a \\<le> COPY)\n\ngoal (3 subgoals):\n 1. \\<bottom> \\<le> COPY\n 2. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 3. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<bottom> \\<le> COPY\n 2. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 3. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "show \"\\<bottom> \\<le> COPY\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<le> COPY", "by(simp_all)"], ["proof (state)\nthis:\n  \\<bottom> \\<le> COPY\n\ngoal (2 subgoals):\n 1. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "have 1:\"(\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow> \\<bottom>) \\<le> (\\<sqinter>xa\\<in> range left \\<rightarrow>  \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow>  \\<bottom>)", "using mndet_subset_FD"], ["proof (prove)\nusing this:\n  ?A \\<noteq> {} \\<Longrightarrow>\n  (\\<sqinter>xa\\<in>?A \\<union> ?B \\<rightarrow>  ?P)\n  \\<le> (\\<sqinter>xa\\<in>?A \\<rightarrow>  ?P)\n\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow>  \\<bottom>)", "by (metis UNIV_I empty_iff imageI)"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n      \\<bottom>)\n  \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow>  \\<bottom>)\n\ngoal (2 subgoals):\n 1. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "have 2:\"(\\<sqinter>xa\\<in> range left \\<rightarrow>  \\<bottom>) \\<le> (left`?`x \\<rightarrow>  \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<rightarrow>  \\<bottom>)\n    \\<le> (left`?`x \\<rightarrow> \\<bottom>)", "unfolding read_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<rightarrow>  \\<bottom>)\n    \\<le> Mprefix (range left) ((\\<lambda>x. \\<bottom>) \\<circ> inv left)", "by (metis Mprefix_refines_Mndet comp_apply dual_order.antisym mono_mprefix_FD order_refl)"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range left \\<rightarrow>  \\<bottom>)\n  \\<le> (left`?`x \\<rightarrow> \\<bottom>)\n\ngoal (2 subgoals):\n 1. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "show \"(\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  \\<bottom>) \\<le> COPY\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<bottom>)\n    \\<le> COPY", "by (metis (mono_tags, lifting)  1 2 COPY_rec bot_less1 mono_read_FD order.trans)"], ["proof (state)\nthis:\n  (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  \\<bottom>)\n  \\<le> COPY\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "fix P::\"'a channel process\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "assume  *: \"P \\<le> COPY\" and ** : \"(\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  P) \\<le> COPY\""], ["proof (state)\nthis:\n  P \\<le> COPY\n  (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> COPY\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "have 1:\"(\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow>  P) \\<le> (\\<sqinter>xa\\<in> range right \\<rightarrow>  P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n    \\<le> (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)", "using mndet_subset_FD"], ["proof (prove)\nusing this:\n  ?A \\<noteq> {} \\<Longrightarrow>\n  (\\<sqinter>xa\\<in>?A \\<union> ?B \\<rightarrow>  ?P)\n  \\<le> (\\<sqinter>xa\\<in>?A \\<rightarrow>  ?P)\n\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n    \\<le> (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)", "by (metis UNIV_I Un_commute empty_iff imageI)"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "have 2:\"(\\<sqinter>xa\\<in> range right \\<rightarrow>  P) \\<le> (right`!`x \\<rightarrow>  P)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n    \\<le> (right`!`x \\<rightarrow> P)", "using mndet_subset_FD[of \"{right x}\" \"range right\"]"], ["proof (prove)\nusing this:\n  {right x} \\<noteq> {} \\<Longrightarrow>\n  (\\<sqinter>xa\\<in>{right x} \\<union> range right \\<rightarrow>  ?P)\n  \\<le> (\\<sqinter>xa\\<in>{right x} \\<rightarrow>  ?P)\n\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n    \\<le> (right`!`x \\<rightarrow> P)", "by(simp add:write_def write0_def mndet_unit)"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n  \\<le> (right`!`?x \\<rightarrow> P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "from 1 2"], ["proof (chain)\npicking this:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n  (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n  \\<le> (right`!`?x \\<rightarrow> P)", "have ab:\"(\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow>  P) \\<le> (right`!`x \\<rightarrow>  P)\" for x"], ["proof (prove)\nusing this:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n  (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n  \\<le> (right`!`?x \\<rightarrow> P)\n\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n    \\<le> (right`!`x \\<rightarrow> P)", "using dual_order.trans"], ["proof (prove)\nusing this:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n  (\\<sqinter>xa\\<in>range right \\<rightarrow>  P)\n  \\<le> (right`!`?x \\<rightarrow> P)\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n    \\<le> (right`!`x \\<rightarrow> P)", "by blast"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (right`!`?x \\<rightarrow> P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "hence 3:\"(left`?`x \\<rightarrow> (\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow>  P)) \\<le> (left`?`x \\<rightarrow>(right`!`x \\<rightarrow>  P))\""], ["proof (prove)\nusing this:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (right`!`?x \\<rightarrow> P)\n\ngoal (1 subgoal):\n 1. (left`?`x \n        \\<rightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n  range right \\<rightarrow> \n                          P))\n    \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)", "by (simp add: mono_read_FD)"], ["proof (state)\nthis:\n  (left`?`x \n      \\<rightarrow> (\\<sqinter>xa\\<in>range left \\<union>\nrange right \\<rightarrow> \n                        P))\n  \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "have 4:\"\\<And>X. (\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow> X) \\<le> (\\<sqinter>xa\\<in> range left \\<rightarrow> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  X)\n       \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow>  X)", "using mndet_subset_FD"], ["proof (prove)\nusing this:\n  ?A \\<noteq> {} \\<Longrightarrow>\n  (\\<sqinter>xa\\<in>?A \\<union> ?B \\<rightarrow>  ?P)\n  \\<le> (\\<sqinter>xa\\<in>?A \\<rightarrow>  ?P)\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  X)\n       \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow>  X)", "by (metis UNIV_I empty_iff imageI)"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  ?X)\n  \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow>  ?X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "have 5:\"\\<And>X. (\\<sqinter>xa\\<in> range left \\<rightarrow> X) \\<le> (left`?`x \\<rightarrow> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       (\\<sqinter>xa\\<in>range left \\<rightarrow>  X)\n       \\<le> (left`?`x \\<rightarrow> X)", "unfolding read_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       (\\<sqinter>xa\\<in>range left \\<rightarrow>  X)\n       \\<le> Mprefix (range left) ((\\<lambda>x. X) \\<circ> inv left)", "by (metis Mprefix_refines_Mndet comp_apply dual_order.antisym mono_mprefix_FD order_refl)"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range left \\<rightarrow>  ?X1)\n  \\<le> (left`?`x \\<rightarrow> ?X1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "from 3 4[of \"(\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow>  P)\"] \n         5  [of \"(\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow>  P)\"]"], ["proof (chain)\npicking this:\n  (left`?`x \n      \\<rightarrow> (\\<sqinter>xa\\<in>range left \\<union>\nrange right \\<rightarrow> \n                        P))\n  \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n      \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow> \n            \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n               P)\n  (\\<sqinter>xa\\<in>range left \\<rightarrow> \n      \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (left`?`x \n            \\<rightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n      range right \\<rightarrow> \n                              P))", "have 6:\"(\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow> \n                    (\\<sqinter>xa\\<in> range left \\<union> range right \\<rightarrow>  P)) \\<le> (left`?`x \\<rightarrow> (right`!`x \\<rightarrow>  P))\""], ["proof (prove)\nusing this:\n  (left`?`x \n      \\<rightarrow> (\\<sqinter>xa\\<in>range left \\<union>\nrange right \\<rightarrow> \n                        P))\n  \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n      \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (\\<sqinter>xa\\<in>range left \\<rightarrow> \n            \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n               P)\n  (\\<sqinter>xa\\<in>range left \\<rightarrow> \n      \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (left`?`x \n            \\<rightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n      range right \\<rightarrow> \n                              P))\n\ngoal (1 subgoal):\n 1. (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n        \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n    \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)", "by (meson dual_order.trans)"], ["proof (state)\nthis:\n  (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow> \n      \\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "from * **"], ["proof (chain)\npicking this:\n  P \\<le> COPY\n  (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> COPY", "have 7:\"(left`?`x \\<rightarrow> (right`!`x \\<rightarrow>  P)) \\<le> (left`?`x \\<rightarrow> (right`!`x \\<rightarrow>  COPY))\""], ["proof (prove)\nusing this:\n  P \\<le> COPY\n  (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> COPY\n\ngoal (1 subgoal):\n 1. (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)\n    \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> COPY)", "by (simp add: mono_read_FD mono_write_FD)"], ["proof (state)\nthis:\n  (left`?`x \\<rightarrow> right`!`x \\<rightarrow> P)\n  \\<le> (left`?`x \\<rightarrow> right`!`x \\<rightarrow> COPY)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> COPY;\n        (\\<sqinter>xa\\<in>range left \\<union> range right \\<rightarrow>  x)\n        \\<le> COPY\\<rbrakk>\n       \\<Longrightarrow> (\\<sqinter>xa\\<in>range left \\<union>\n     range right \\<rightarrow> \n                             \\<sqinter>xa\\<in>range left \\<union>\n        range right \\<rightarrow> \n                                x)\n                         \\<le> COPY", "show \"(\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  \\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  P) \\<le> COPY\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n        \\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  P)\n    \\<le> COPY", "by (metis (mono_tags, lifting) 6 7  COPY_rec dual_order.trans)"], ["proof (state)\nthis:\n  (\\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow> \n      \\<sqinter>x\\<in>range left \\<union> range right \\<rightarrow>  P)\n  \\<le> COPY\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open> An Alternative Approach: Using the fixrec-Package \\<close>"], ["", "subsection\\<open> Channels and Synchronisation Sets \\<close>"], ["", "text\\<open> As before. \\<close>"], ["", "subsection\\<open> Process Definitions via fixrec-Package  \\<close>"], ["", "fixrec\n  COPY' :: \"('a channel) process\"\nand\n  SEND' :: \"('a channel) process\"\nand\n  REC' :: \"('a channel) process\"\nwhere\n   COPY'_rec[simp del]:  \"COPY' = (left`?`x \\<rightarrow> (right`!`x \\<rightarrow> COPY'))\"\n|  SEND'_rec[simp del]:  \"SEND' = (left`?`x \\<rightarrow> (mid`!`x \\<rightarrow> (ack \\<rightarrow> SEND')))\"\n|  REC'_rec[simp del] :  \"REC'  = (mid`?`x \\<rightarrow> (right`!`x \\<rightarrow> (ack \\<rightarrow> REC')))\""], ["", "definition SYSTEM' :: \"('a channel) process\"\nwhere     \"SYSTEM' \\<equiv> ((SEND' \\<lbrakk> SYN \\<rbrakk> REC') \\\\ SYN)\""], ["", "subsection\\<open> Another Refinement Proof on fixrec-infrastructure \\<close>"], ["", "text\\<open> Third part: No comes the proof by fixpoint induction. \n       Not too bad in automation considering what is inferred,\n       but wouldn't scale for large examples. \\<close>"], ["", "lemma impl_refines_spec' : \"(COPY'::'a channel process) \\<sqsubseteq> SYSTEM'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COPY' \\<sqsubseteq> SYSTEM'", "apply(unfold SYSTEM'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. COPY' \\<sqsubseteq> (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN", "apply(rule_tac P=\"\\<lambda> a b c. a \\<sqsubseteq> (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\\\ SYN\" in COPY'_SEND'_REC'.induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<sqsubseteq>\n       (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<Longrightarrow>\n       (left`?`x \\<rightarrow> right`!`x \\<rightarrow> a) \\<sqsubseteq>\n       (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN", "by (subst SEND'_rec, subst REC'_rec, simp add: sync_rules hide_rules mono_rules)"], ["", "lemma spec_refines_impl' : \nassumes fin:  \"finite (SYN::('a channel)set)\"\nshows         \"SYSTEM' \\<sqsubseteq> (COPY'::'a channel process)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SYSTEM' \\<sqsubseteq> COPY'", "proof(unfold SYSTEM'_def, rule_tac P=\"\\<lambda> a b c. ((b \\<lbrakk>SYN\\<rbrakk> REC') \\\\ SYN) \\<sqsubseteq> COPY'\" in COPY'_SEND'_REC'.induct, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>(COPY'a, SEND', REC'a).\n            (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')\n 2. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n 3. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. adm (\\<lambda>(COPY'a, SEND', REC'a).\n            (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')\n 2. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n 3. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "have aa:\"adm (\\<lambda>(a::'a channel process). ((a \\<lbrakk>SYN\\<rbrakk> REC') \\\\ SYN) \\<sqsubseteq> COPY')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>a.\n            (a \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')", "by (simp add: contI cont_left_sync chain_Sync1 thelubE fin)"], ["proof (state)\nthis:\n  adm (\\<lambda>a. (a \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>(COPY'a, SEND', REC'a).\n            (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')\n 2. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n 3. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "thus ?case"], ["proof (prove)\nusing this:\n  adm (\\<lambda>a. (a \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>(COPY'a, SEND', REC'a).\n            (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')", "using adm_subst[of \"\\<lambda>(a,b,c). b\", simplified, OF aa]"], ["proof (prove)\nusing this:\n  adm (\\<lambda>a. (a \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')\n  adm (\\<lambda>x.\n          ((case x of (a, b, c) \\<Rightarrow> b) \\<lbrakk>SYN\\<rbrakk>\n              REC') \\ SYN \\<sqsubseteq>\n          COPY')\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>(COPY'a, SEND', REC'a).\n            (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')", "by (simp add:split_def)"], ["proof (state)\nthis:\n  adm (\\<lambda>(COPY'a, SEND', REC'a).\n          (SEND' \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY')\n\ngoal (2 subgoals):\n 1. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n 2. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n 2. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n 2. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'", "by (simp add: hide_set_bot par_Int_bot sync_commute)"], ["proof (state)\nthis:\n  (\\<bottom> \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "case (3 a aa b)"], ["proof (state)\nthis:\n  (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq>\n       COPY' \\<Longrightarrow>\n       (left`?`x \n           \\<rightarrow> mid`!`x \n                            \\<rightarrow> ack \n       \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n           REC') \\ SYN \\<sqsubseteq>\n       COPY'", "then"], ["proof (chain)\npicking this:\n  (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'", "show ?case"], ["proof (prove)\nusing this:\n  (aa \\<lbrakk>SYN\\<rbrakk> REC') \\ SYN \\<sqsubseteq> COPY'\n\ngoal (1 subgoal):\n 1. (left`?`x \n        \\<rightarrow> mid`!`x \n                         \\<rightarrow> ack \n    \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n        REC') \\ SYN \\<sqsubseteq>\n    COPY'", "by (subst COPY'_rec, subst REC'_rec, simp add:sync_rules hide_rules mono_rules)"], ["proof (state)\nthis:\n  (left`?`x \n      \\<rightarrow> mid`!`x \n                       \\<rightarrow> ack \n  \\<rightarrow> aa \\<lbrakk>SYN\\<rbrakk>\n      REC') \\ SYN \\<sqsubseteq>\n  COPY'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_equal_impl' : \nassumes fin:  \"finite (SYN::('a channel)set)\"\nshows         \"SYSTEM' = (COPY'::'a channel process)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SYSTEM' = COPY'", "apply(rule Porder.po_class.below_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. SYSTEM' \\<sqsubseteq> COPY'\n 2. COPY' \\<sqsubseteq> SYSTEM'", "apply(rule spec_refines_impl'[OF fin])"], ["proof (prove)\ngoal (1 subgoal):\n 1. COPY' \\<sqsubseteq> SYSTEM'", "apply(rule impl_refines_spec')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}