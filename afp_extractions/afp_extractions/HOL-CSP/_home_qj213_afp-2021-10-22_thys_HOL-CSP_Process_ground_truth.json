{"file_name": "/home/qj213/afp-2021-10-22/thys/HOL-CSP/Process.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOL-CSP", "problem_names": ["lemma A : \"((x::'a list) < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\"", "lemma nil_le[simp]: \"[] \\<le> s\"", "lemma nil_le2[simp]: \"s \\<le> [] = (s = [])\"", "lemma nil_less[simp]: \"\\<not> t < []\"", "lemma nil_less2[simp]: \"[] < t @ [a]\"", "lemma less_self[simp]: \"t < t@[a]\"", "lemma le_length_mono: \"s \\<le> t \\<Longrightarrow> length s \\<le> length t\"", "lemma less_length_mono: \"s < t \\<Longrightarrow> length s < length t\"", "lemma less_cons: \"s < t \\<Longrightarrow> a # s < a # t\"", "lemma less_append: \"s < t \\<Longrightarrow> a @ s < a @ t\"", "lemma less_tail: \"s \\<noteq> [] \\<Longrightarrow> s < t \\<Longrightarrow> tl s < tl t\"", "lemma list_nonMt_append: \"s \\<noteq> [] \\<Longrightarrow> \\<exists> a t. s = t @ [a]\"", "lemma append_eq_first_pref_spec[rule_format]: \"s @ t = r @ [x] \\<and> t \\<noteq> [] \\<longrightarrow> s \\<le> r\"", "lemma prefixes_fin: \"let prefixes = {t. \\<exists>t2. x = t @ t2} in finite prefixes \\<and> card prefixes = length x + 1\"", "lemma sublists_fin: \"finite {t. \\<exists>t1 t2. x = t1 @ t @ t2}\"", "lemma suffixes_fin: \"finite {t. \\<exists>t1. x = t1 @ t}\"", "lemma tickFree_Nil [simp]: \"tickFree []\"", "lemma tickFree_Cons [simp]: \"tickFree (a # t) = (a \\<noteq> tick \\<and> tickFree t)\"", "lemma tickFree_tl : \"[|s ~= [] ; tickFree s|] ==> tickFree(tl s)\"", "lemma tickFree_append[simp]: \"tickFree(s@t) = (tickFree s \\<and> tickFree t)\"", "lemma non_tickFree_tick [simp]: \"\\<not> tickFree [tick]\"", "lemma non_tickFree_implies_nonMt: \"\\<not> tickFree s \\<Longrightarrow> s \\<noteq> []\"", "lemma  tickFree_rev : \"tickFree(rev t) = (tickFree t)\"", "lemma front_tickFree_Nil[simp]: \"front_tickFree []\"", "lemma front_tickFree_single[simp]: \"front_tickFree [a]\"", "lemma tickFree_implies_front_tickFree: \"tickFree s \\<Longrightarrow> front_tickFree s\"", "lemma front_tickFree_charn: \"front_tickFree s = (s = [] \\<or> (\\<exists>a t. s = t @ [a] \\<and> tickFree t))\"", "lemma front_tickFree_implies_tickFree: \"front_tickFree (t @ [a]) \\<Longrightarrow> tickFree t\"", "lemma tickFree_implies_front_tickFree_single: \"tickFree t \\<Longrightarrow> front_tickFree (t @ [a])\"", "lemma nonTickFree_n_frontTickFree: \"\\<lbrakk>\\<not> tickFree s; front_tickFree s \\<rbrakk> \\<Longrightarrow> \\<exists>t. s = t @ [tick]\"", "lemma front_tickFree_dw_closed : \"front_tickFree (s @ t) \\<Longrightarrow>  front_tickFree s\"", "lemma front_tickFree_append: \"\\<lbrakk> tickFree s; front_tickFree t\\<rbrakk> \\<Longrightarrow> front_tickFree (s @ t)\"", "lemma front_tickFree_mono: \"front_tickFree (t @ r) \\<and> r \\<noteq> [] \\<longrightarrow> tickFree t \\<and> front_tickFree r\"", "lemma is_process_spec:\n \"is_process P = \n       (([],{}) \\<in>  FAILURES P \\<and>\n       (\\<forall> s X. (s,X) \\<in>  FAILURES P \\<longrightarrow> front_tickFree s) \\<and>\n       (\\<forall> s t . (s @ t,{}) \\<notin> FAILURES P \\<or>   (s,{}) \\<in> FAILURES P) \\<and>\n       (\\<forall> s X Y. (s,Y)  \\<notin>  FAILURES P \\<or> \\<not>(X\\<subseteq>Y) | (s,X) \\<in> FAILURES P) \\<and>\n       (\\<forall> s X Y.(s,X) \\<in> FAILURES P \\<and> \n       (\\<forall> c. c \\<in>  Y \\<longrightarrow> ((s@[c],{}) \\<notin>  FAILURES P)) \\<longrightarrow>(s,X \\<union> Y) \\<in>  FAILURES P) \\<and>\n       (\\<forall> s X. (s@[tick],{}) \\<in>  FAILURES P \\<longrightarrow> (s,X - {tick}) \\<in>  FAILURES P) \\<and>\n       (\\<forall> s t. s \\<notin> DIVERGENCES P \\<or> \\<not>tickFree s \\<or> \\<not>front_tickFree t \n                                 \\<or> s @ t \\<in> DIVERGENCES P) \\<and>\n       (\\<forall> s X. s \\<notin> DIVERGENCES P \\<or> (s,X) \\<in>  FAILURES P) \\<and>\n       (\\<forall> s. s @ [tick] \\<notin>  DIVERGENCES P \\<or> s \\<in>  DIVERGENCES P))\"", "lemma Process_eqI :\nassumes A: \"FAILURES P = FAILURES Q \"\nassumes B: \"DIVERGENCES P = DIVERGENCES Q\"\nshows      \"(P::'\\<alpha> process\\<^sub>0) = Q\"", "lemma process_eq_spec:\n\"((P::'a process\\<^sub>0) = Q) = (FAILURES P = FAILURES Q \\<and> DIVERGENCES P = DIVERGENCES Q)\"", "lemma process_surj_pair: \"(FAILURES P,DIVERGENCES P) = P\"", "lemma Fa_eq_imp_Tr_eq: \"FAILURES P = FAILURES Q \\<Longrightarrow> TRACES P = TRACES Q\"", "lemma is_process1:  \"is_process P \\<Longrightarrow> ([],{})\\<in> FAILURES P \"", "lemma is_process2: \"is_process P \\<Longrightarrow> \\<forall> s X. (s,X) \\<in> FAILURES P \\<longrightarrow> front_tickFree s \"", "lemma is_process3: \"is_process P \\<Longrightarrow> \\<forall> s t. (s @ t,{}) \\<in> FAILURES P \\<longrightarrow> (s, {}) \\<in> FAILURES P\"", "lemma is_process3_S_pref: \"\\<lbrakk>is_process P; (t, {}) \\<in> FAILURES P; s \\<le> t\\<rbrakk> \\<Longrightarrow> (s, {}) \\<in> FAILURES P\"", "lemma is_process4: \"is_process P \\<Longrightarrow> \\<forall>s X Y. (s, Y) \\<notin> FAILURES P \\<or> \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> FAILURES P\"", "lemma is_process4_S: \"\\<lbrakk>is_process P; (s, Y) \\<in> FAILURES P; X \\<subseteq> Y\\<rbrakk> \\<Longrightarrow> (s, X) \\<in> FAILURES P\"", "lemma is_process4_S1: \"\\<lbrakk>is_process P; x \\<in> FAILURES P; X \\<subseteq> snd x\\<rbrakk> \\<Longrightarrow> (fst x, X) \\<in> FAILURES P\"", "lemma is_process5:\n\"is_process P \\<Longrightarrow>\n    \\<forall>sa X Y. (sa, X) \\<in> FAILURES P \\<and> (\\<forall>c. c \\<in> Y \\<longrightarrow> (sa @ [c], {}) \\<notin> FAILURES P) \\<longrightarrow> (sa, X \\<union> Y) \\<in> FAILURES P\"", "lemma is_process5_S:\n\"\\<lbrakk>is_process P; (sa, X) \\<in> FAILURES P; \\<forall>c. c \\<in> Y \\<longrightarrow> (sa @ [c], {}) \\<notin> FAILURES P\\<rbrakk> \\<Longrightarrow> (sa, X \\<union> Y) \\<in> FAILURES P\"", "lemma is_process5_S1:\n\"\\<lbrakk>is_process P; (sa, X) \\<in> FAILURES P; (sa, X \\<union> Y) \\<notin> FAILURES P\\<rbrakk> \\<Longrightarrow> \\<exists>c. c \\<in> Y \\<and> (sa @ [c], {}) \\<in> FAILURES P\"", "lemma is_process6: \"is_process P \\<Longrightarrow>  \\<forall> s X. (s@[tick],{}) \\<in> FAILURES P \\<longrightarrow> (s,X-{tick}) \\<in> FAILURES P\"", "lemma is_process6_S: \"\\<lbrakk>is_process P ;(s@[tick],{}) \\<in> FAILURES P\\<rbrakk> \\<Longrightarrow>  (s,X-{tick}) \\<in> FAILURES P\"", "lemma is_process7:\n\"is_process P \\<Longrightarrow> \\<forall> s t. s \\<notin> DIVERGENCES P \\<or> \\<not> tickFree s \\<or> \\<not> front_tickFree t \\<or> s @ t \\<in> DIVERGENCES P\"", "lemma is_process7_S:\n\"\\<lbrakk> is_process P;s : DIVERGENCES P;tickFree s;front_tickFree t\\<rbrakk> \n \\<Longrightarrow>  s @ t \\<in> DIVERGENCES P\"", "lemma is_process8: \"is_process P \\<Longrightarrow> \\<forall>  s X. s \\<notin> DIVERGENCES P \\<or>  (s,X) \\<in> FAILURES P\"", "lemma is_process8_S: \"\\<lbrakk> is_process P; s \\<in> DIVERGENCES P \\<rbrakk> \\<Longrightarrow> (s,X)  \\<in> FAILURES P\"", "lemma is_process9: \"is_process P \\<Longrightarrow> \\<forall>  s. s@[tick] \\<notin> DIVERGENCES P \\<or>  s \\<in> DIVERGENCES P\"", "lemma is_process9_S: \"\\<lbrakk> is_process P;s@[tick] \\<in> DIVERGENCES P \\<rbrakk> \\<Longrightarrow> s \\<in> DIVERGENCES P\"", "lemma Failures_implies_Traces: \" \\<lbrakk>is_process P; (s, X) \\<in> FAILURES P\\<rbrakk> \\<Longrightarrow> s \\<in> TRACES P\"", "lemma is_process5_sing: \n\"\\<lbrakk> is_process P ; (s,{x}) \\<notin> FAILURES P;(s,{}) \\<in> FAILURES P\\<rbrakk> \\<Longrightarrow> (s @ [x],{}) \\<in> FAILURES P\"", "lemma is_process5_singT: \n\"\\<lbrakk> is_process P ; (s,{x}) \\<notin> FAILURES P;(s,{}) \\<in> FAILURES P\\<rbrakk>  \\<Longrightarrow> s @ [x]  \\<in> TRACES P\"", "lemma front_trace_is_tickfree:\nassumes A: \"is_process P\" and B: \"(t @ [tick],X) \\<in> FAILURES P\"\nshows     \"tickFree t\"", "lemma trace_with_Tick_implies_tickFree_front : \"\\<lbrakk>is_process P; t @ [tick] \\<in> TRACES P\\<rbrakk> \\<Longrightarrow> tickFree t\"", "lemma is_process_Rep : \"is_process (Rep_process P)\"", "lemma Process_spec: \"Abs_process((F P , D P)) = P\"", "lemma Process_eq_spec: \"(P = Q)=(F P = F Q \\<and> D P = D Q)\"", "lemma Process_eq_spec_optimized: \"(P = Q) = (D P = D Q \\<and> (D P = D Q \\<longrightarrow> F P = F Q))\"", "lemma is_processT:\n\"([],{}) \\<in> F P \\<and>\n (\\<forall> s X. (s,X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n (\\<forall> s t .(s@t,{}) \\<in> F P \\<longrightarrow> (s,{}) \\<in> F P) \\<and>\n (\\<forall> s X Y.(s,Y) \\<in> F P \\<and> (X\\<subseteq>Y) \\<longrightarrow> (s,X) \\<in> F P) \\<and>\n (\\<forall> s X Y.(s,X) \\<in> F P \\<and> (\\<forall>c. c \\<in> Y \\<longrightarrow>((s@[c],{})\\<notin>F P)) \\<longrightarrow> (s,X \\<union> Y) \\<in> F P) \\<and>\n (\\<forall> s X. (s@[tick],{}) \\<in> F P \\<longrightarrow> (s, X-{tick}) \\<in> F P) \\<and>\n (\\<forall> s t. s \\<in> D P \\<and> tickFree s \\<and> front_tickFree t \\<longrightarrow> s @ t \\<in> D P) \\<and>\n (\\<forall> s X. s \\<in> D P \\<longrightarrow> (s,X) \\<in> F P) \\<and>\n (\\<forall> s. s@[tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\"", "lemma process_charn:\n  \"([], {}) \\<in> F P \\<and>\n   (\\<forall>s X. (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n   (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n   (\\<forall>s X Y. (s, Y) \\<notin> F P \\<or> \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n   (\\<forall>s X Y. (s, X) \\<in> F P \\<and> (\\<forall>c. c \\<in> Y \\<longrightarrow> (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n             (s, X \\<union> Y) \\<in> F P) \\<and>\n   (\\<forall>s X. (s @ [tick], {}) \\<in> F P \\<longrightarrow> (s, X - {tick}) \\<in> F P) \\<and>\n   (\\<forall>s t. s \\<notin> D P \\<or> \\<not> tickFree s \\<or> \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n   (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and> (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)\"", "lemma is_processT1: \"([],{}) \\<in> F P\"", "lemma is_processT2: \"\\<forall>s X. (s, X) \\<in> F P \\<longrightarrow> front_tickFree s\"", "lemma  is_processT2_TR : \"\\<forall>s. s \\<in> T P \\<longrightarrow> front_tickFree s\"", "lemma is_proT2:\n  assumes A : \" (s, X) \\<in> F P\" and B : \" s \\<noteq> []\"\n  shows   \"tick \\<notin> set (tl (rev s))\"", "lemma is_processT3 : \"\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P\"", "lemma is_processT3_S_pref : \n\"\\<lbrakk>(t, {}) \\<in> F P; s \\<le> t\\<rbrakk> \\<Longrightarrow> (s, {}) \\<in> F P\"", "lemma  is_processT4 : \"\\<forall>s X Y. (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow> (s, X) \\<in> F P\"", "lemma is_processT4_S1 : \"\\<lbrakk>x \\<in> F P; X \\<subseteq> snd x\\<rbrakk> \\<Longrightarrow> (fst x, X) \\<in> F P\"", "lemma is_processT5: \"\\<forall>s X Y.(s,X) \\<in> F P \\<and> (\\<forall>c. c\\<in>Y \\<longrightarrow> (s@[c],{}) \\<notin> F P) \\<longrightarrow> (s,X\\<union>Y)\\<in>F P \"", "lemma is_processT5_S1: \"\\<lbrakk>(s, X) \\<in> F P; (s, X \\<union> Y) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<exists>c. c \\<in> Y \\<and> (s @ [c], {}) \\<in> F P\"", "lemma is_processT5_S2: \"\\<lbrakk>(s, X) \\<in> F P; (s @ [c], {}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> (s, X \\<union> {c}) \\<in> F P\"", "lemma is_processT5_S2a: \"\\<lbrakk>(s, X) \\<in> F P; (s, X \\<union> {c}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F P\"", "lemma  is_processT5_S3:\nassumes A: \"(s, {}) \\<in> F P\"\nand     B: \"(s @ [c], {}) \\<notin> F P\"\nshows      \"(s, {c}) \\<in> F P\"", "lemma is_processT5_S4: \"\\<lbrakk>(s, {}) \\<in> F P; (s, {c}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F P\"", "lemma is_processT5_S5:\n\"\\<lbrakk>(s, X) \\<in> F P; \\<forall>c. c \\<in> Y \\<longrightarrow> (s, X \\<union> {c}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<forall>c. c \\<in> Y \\<longrightarrow> (s @ [c], {}) \\<in> F P\"", "lemma is_processT5_S6: \"([], {c}) \\<notin> F P \\<Longrightarrow> ([c], {}) \\<in> F P\"", "lemma is_processT6: \"\\<forall>s X. (s @ [tick], {}) \\<in> F P \\<longrightarrow> (s, X - {tick}) \\<in> F P\"", "lemma is_processT7:  \"\\<forall>s t. s \\<in> D P \\<and> tickFree s \\<and> front_tickFree t \\<longrightarrow> s @ t \\<in> D P\"", "lemmas is_processT7_S =  is_processT7[rule_format,OF conjI[THEN conjI, THEN  conj_commute[THEN iffD1]]]", "lemma is_processT8: \"\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P \"", "lemmas is_processT8_S = is_processT8[rule_format]", "lemma is_processT8_Pair: \"fst s \\<in> D P \\<Longrightarrow> s \\<in> F P\"", "lemma is_processT9: \"\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P\"", "lemma is_processT9_S_swap: \"s \\<notin> D P \\<Longrightarrow> s @ [tick] \\<notin> D P\"", "lemma no_Trace_implies_no_Failure: \"s \\<notin> T P \\<Longrightarrow> (s, {}) \\<notin> F P\"", "lemmas  NT_NF = no_Trace_implies_no_Failure", "lemma T_def_spec: \"T P = {tr. \\<exists>a. a \\<in> F P \\<and> tr = fst a}\"", "lemma F_T: \"(s, X) \\<in> F P \\<Longrightarrow> s \\<in> T P\"", "lemma F_T1: \"a \\<in> F P \\<Longrightarrow> fst a \\<in> T P\"", "lemma T_F: \"s \\<in> T P \\<Longrightarrow> (s, {}) \\<in> F P\"", "lemmas is_processT4_empty [elim!]= F_T [THEN T_F]", "lemma NF_NT: \"(s, {}) \\<notin> F P \\<Longrightarrow> s \\<notin> T P\"", "lemma  is_processT6_S1: \"\\<lbrakk> tick \\<notin> X;(s @ [tick], {}) \\<in> F P \\<rbrakk> \\<Longrightarrow> (s::'a event list, X) \\<in> F P\"", "lemmas is_processT3_ST = T_F [THEN is_processT3[rule_format,THEN F_T]]", "lemmas is_processT3_ST_pref = T_F [THEN is_processT3_S_pref [THEN F_T]]", "lemmas is_processT3_SR = F_T [THEN T_F [THEN is_processT3[rule_format]]]", "lemmas D_T = is_processT8_S [THEN F_T]", "lemma D_T_subset : \"D P \\<subseteq> T P\"", "lemma NF_ND : \"(s, X) \\<notin> F P \\<Longrightarrow> s \\<notin> D P\"", "lemmas NT_ND = D_T_subset[THEN Set.contra_subsetD]", "lemma T_F_spec : \"((t, {}) \\<in> F P) = (t \\<in> T P)\"", "lemma is_processT5_S7:  \" \\<lbrakk>t \\<in> T P; (t, A) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> t @ [x] \\<in> T P\"", "lemma is_processT5_S7': \" \\<lbrakk>(t, X) \\<in> F P; (t, X \\<union> A) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> x \\<notin> X \\<and> t @ [x] \\<in> T P\"", "lemma Nil_subset_T: \" {[]} \\<subseteq> T P\"", "lemma Nil_elem_T: \"[] \\<in> T P\"", "lemmas D_imp_front_tickFree = is_processT8_S[THEN is_processT2[rule_format]]", "lemma D_front_tickFree_subset : \"D P \\<subseteq> Collect front_tickFree\"", "lemma F_D_part : \"F P = {(s, x). s \\<in> D P} \\<union> {(s, x). s \\<notin> D P \\<and> (s, x) \\<in> F P}\"", "lemma D_F : \"{(s, x). s \\<in> D P} \\<subseteq> F P\"", "lemma append_T_imp_tickFree:  \"\\<lbrakk>t @ s \\<in> T P; s \\<noteq> []\\<rbrakk> \\<Longrightarrow> tickFree t\"", "lemma F_subset_imp_T_subset: \"F P \\<subseteq> F Q \\<Longrightarrow> T P \\<subseteq> T Q\"", "lemma is_processT6_S2: \"\\<lbrakk>tick \\<notin> X; [tick] \\<in> T P\\<rbrakk> \\<Longrightarrow> ([], X) \\<in> F P\"", "lemma is_processT9_tick: \"\\<lbrakk>[tick] \\<in> D P; front_tickFree s\\<rbrakk> \\<Longrightarrow> s \\<in> D P\"", "lemma T_nonTickFree_imp_decomp: \"\\<lbrakk>t \\<in> T P; \\<not> tickFree t\\<rbrakk> \\<Longrightarrow> \\<exists>s. t = s @ [tick]\"", "lemma Nil_min_elems : \"[] \\<in> A \\<Longrightarrow> [] \\<in> min_elems A\"", "lemma min_elems_le_self[simp] : \"(min_elems A) \\<subseteq> A\"", "lemmas elem_min_elems = Set.set_mp[OF min_elems_le_self]", "lemma min_elems_Collect_ftF_is_Nil : \"min_elems (Collect front_tickFree) = {[]}\"", "lemma min_elems5 : \n  assumes A: \"(x::'a list) \\<in> A\"\n  shows      \"\\<exists>s\\<le>x. s \\<in> min_elems A\"", "lemma min_elems4: \"A \\<noteq> {} \\<Longrightarrow> \\<exists>s. (s :: 'a trace) \\<in> min_elems A\"", "lemma min_elems_charn: \"t \\<in> A \\<Longrightarrow> \\<exists> t' r. t = (t' @ r) \\<and> t' \\<in> min_elems A\"", "lemmas min_elems_ex = min_elems_charn", "lemma min_elems_no: \"(x::'a list) \\<in> min_elems A \\<Longrightarrow> t \\<in> A \\<Longrightarrow> t \\<le> x \\<Longrightarrow> x = t\"", "lemma le_approx1: \"P\\<sqsubseteq>Q \\<Longrightarrow> D Q \\<subseteq> D P\"", "lemma le_approx2: \"\\<lbrakk> P\\<sqsubseteq>Q; s \\<notin> D P\\<rbrakk> \\<Longrightarrow> (s,X) \\<in> F Q = ((s,X) \\<in> F P)\"", "lemma le_approx3: \"P \\<sqsubseteq> Q \\<Longrightarrow> min_elems(D P) \\<subseteq> T Q\"", "lemma le_approx2T: \"\\<lbrakk> P\\<sqsubseteq>Q; s \\<notin> D P\\<rbrakk> \\<Longrightarrow>  s \\<in> T Q = (s \\<in> T P)\"", "lemma le_approx_lemma_F : \"P\\<sqsubseteq>Q \\<Longrightarrow> F Q \\<subseteq> F P\"", "lemmas order_lemma = le_approx_lemma_F", "lemma le_approx_lemma_T: \"P\\<sqsubseteq>Q \\<Longrightarrow> T Q \\<subseteq> T P\"", "lemma proc_ord2a :  \"\\<lbrakk>P \\<sqsubseteq> Q; s \\<notin> D P\\<rbrakk> \\<Longrightarrow> ((s, X) \\<in> F P) = ((s, X) \\<in> F Q)\"", "lemma min_elems3: \"\\<lbrakk>s @ [c] \\<in> D P; s @ [c] \\<notin> min_elems (D P)\\<rbrakk> \\<Longrightarrow> s \\<in> D P\"", "lemma min_elems1: \"\\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P\\<rbrakk> \\<Longrightarrow> s @ [c] \\<in> min_elems (D P)\"", "lemma min_elems2: \"\\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S; Q \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F Q\"", "lemma min_elems6: \"\\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F S\"", "lemma ND_F_dir2: \"\\<lbrakk>s \\<notin> D P; (s, {}) \\<in> F P; P \\<sqsubseteq> S; Q \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> (s, {}) \\<in> F Q\"", "lemma ND_F_dir2': \"\\<lbrakk>s \\<notin> D P; s \\<in> T P; P \\<sqsubseteq> S; Q \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> s \\<in> T Q\"", "lemma chain_lemma: \"\\<lbrakk>chain S\\<rbrakk> \\<Longrightarrow> S i \\<sqsubseteq> S k \\<or> S k \\<sqsubseteq> S i\"", "lemma is_process_REP_LUB: \n  assumes chain: \"chain S\"\n  shows \"is_process (\\<Inter> (F ` range S), \\<Inter> (D ` range S))\"", "lemmas Rep_Abs_LUB = Abs_process_inverse[simplified Rep_process, \n                                         simplified, OF is_process_REP_LUB,\n                                         simplified]", "lemma F_LUB: \"chain S \\<Longrightarrow> F(lim_proc(range S)) = \\<Inter> (F ` range S)\"", "lemma D_LUB: \"chain S \\<Longrightarrow> D(lim_proc(range S)) = \\<Inter> (D ` range S)\"", "lemma T_LUB: \"chain S \\<Longrightarrow> T(lim_proc(range S)) = \\<Inter> (T ` range S)\"", "lemma le_approx_implies_le_ref:    \"(P::'\\<alpha> process) \\<sqsubseteq> Q \\<Longrightarrow> P \\<le> Q\"", "lemma le_ref1:                     \"P \\<le> Q \\<Longrightarrow> D Q \\<subseteq> D P\"", "lemma le_ref2:                     \"P\\<le>Q \\<Longrightarrow> F Q \\<subseteq> F P\"", "lemma le_ref2T :                    \"P\\<le>Q \\<Longrightarrow> T Q \\<subseteq> T P\"", "lemma lim_proc_is_ub:\"chain S \\<Longrightarrow> range S <| lim_proc (range S)\"", "lemma lim_proc_is_lub1: \"chain S \\<Longrightarrow> \\<forall> u . (range S <| u \\<longrightarrow>  D u \\<subseteq> D (lim_proc (range S)))\"", "lemma lim_proc_is_lub2: \n  \"chain S \\<Longrightarrow> \\<forall> u . range S <| u \\<longrightarrow> (\\<forall> s.  s \\<notin> D (lim_proc (range S))\n   \\<longrightarrow> Ra (lim_proc (range S)) s = Ra u s)\"", "lemma lim_proc_is_lub3a: \"front_tickFree s \\<Longrightarrow> s \\<notin> D P \\<longrightarrow> (\\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s @ [c])\"", "lemma lim_proc_is_lub3b:\nassumes 1 : \"\\<forall>x. x \\<in> X \\<longrightarrow> (\\<forall>xa. xa \\<in> D x \\<and> (\\<forall>t. t \\<in> D x \\<longrightarrow> \\<not> t < xa) \\<longrightarrow> xa \\<in> T u)\"\nand     2 : \"xa \\<in> X\"\nand     3 : \"\\<forall>xa. xa \\<in> X \\<longrightarrow> x \\<in> D xa\"\nand     4 : \"\\<forall>t. (\\<forall>x. x \\<in> X \\<longrightarrow> t \\<in> D x) \\<longrightarrow> \\<not> t < x\"\nshows       \"x \\<in> T u\"", "lemma lim_proc_is_lub3c: \nassumes *:\"chain S\"\nand     **:\"X = range S\"  \\<comment>\\<open>protection for range - otherwise auto unfolds and gets lost\\<close>\nshows   \"\\<forall> u. X <| u \\<longrightarrow>  min_elems(D(lim_proc X)) \\<subseteq> T u\"", "lemma limproc_is_lub: \"chain S \\<Longrightarrow> range S <<| lim_proc (range S)\"", "lemma limproc_is_thelub: \"chain S \\<Longrightarrow> Lub S = lim_proc (range S)\"", "lemma le_adm[simp]: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<le> v x)\"", "lemmas le_adm_cont[simp] = le_adm[OF _ cont2mono]", "lemma if_then_else_cont[simp]: \n  assumes *:\"(\\<And>x. P x \\<Longrightarrow> cont ((f::'c \\<Rightarrow> ('a::cpo) \\<Rightarrow> 'b process) x))\"\n  and     **:\"(\\<And>x. \\<not> P x \\<Longrightarrow> cont (g x))\"\n  shows \"\\<And>x. cont(\\<lambda>y. if P x then f x y else g x y)\""], "translations": [["", "lemma A : \"((x::'a list) < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by(auto simp: le_list_def less_list_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, order_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y z ::\"'a list\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by(auto simp: le_list_def less_list_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by(simp add: le_list_def)"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume A:\"x \\<le> y\" and B:\"y \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "thus \"x \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "apply(insert A B, simp add: le_list_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra.\n       \\<lbrakk>x \\<le> x @ r; x @ r \\<le> (x @ r) @ ra; y = x @ r;\n        z = (x @ r) @ ra\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rb. x @ rb = (x @ r) @ ra", "apply(rename_tac r ra, rule_tac x=\"r@ra\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume A:\"x \\<le> y\" and B:\"y \\<le> x\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by(insert A B, auto simp: le_list_def)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>Some facts on the prefix ordering.\\<close>"], ["", "lemma nil_le[simp]: \"[] \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<le> s", "by(induct \"s\", simp_all, auto simp: le_list_def)"], ["", "lemma nil_le2[simp]: \"s \\<le> [] = (s = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<le> []) = (s = [])", "by(induct \"s\", auto simp:le_list_def)"], ["", "lemma nil_less[simp]: \"\\<not> t < []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t < []", "by(simp add: less_list_def)"], ["", "lemma nil_less2[simp]: \"[] < t @ [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] < t @ [a]", "by(simp add: less_list_def)"], ["", "lemma less_self[simp]: \"t < t@[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < t @ [a]", "by(simp add:less_list_def le_list_def)"], ["", "lemma le_length_mono: \"s \\<le> t \\<Longrightarrow> length s \\<le> length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> t \\<Longrightarrow> length s \\<le> length t", "by(auto simp: le_list_def)"], ["", "lemma less_length_mono: \"s < t \\<Longrightarrow> length s < length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < t \\<Longrightarrow> length s < length t", "by(auto simp: less_list_def le_list_def)"], ["", "lemma less_cons: \"s < t \\<Longrightarrow> a # s < a # t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < t \\<Longrightarrow> a # s < a # t", "by (simp add: le_list_def less_list_def)"], ["", "lemma less_append: \"s < t \\<Longrightarrow> a @ s < a @ t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < t \\<Longrightarrow> a @ s < a @ t", "by (simp add: le_list_def less_list_def)"], ["", "lemma less_tail: \"s \\<noteq> [] \\<Longrightarrow> s < t \\<Longrightarrow> tl s < tl t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; s < t\\<rbrakk> \\<Longrightarrow> tl s < tl t", "by (auto simp add: le_list_def less_list_def)\n\n\\<comment>\\<open>should be in the List library\\<close>"], ["", "lemma list_nonMt_append: \"s \\<noteq> [] \\<Longrightarrow> \\<exists> a t. s = t @ [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> \\<exists>a t. s = t @ [a]", "by(erule rev_mp,induct \"s\",simp_all,case_tac \"s = []\",auto)"], ["", "lemma append_eq_first_pref_spec[rule_format]: \"s @ t = r @ [x] \\<and> t \\<noteq> [] \\<longrightarrow> s \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s @ t = r @ [x] \\<and> t \\<noteq> [] \\<longrightarrow> s \\<le> r", "apply(rule_tac x=s in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       xa @ t = r @ [x] \\<and> t \\<noteq> [] \\<longrightarrow> xa \\<le> r", "apply(induct r,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa @ t = [x]; t \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xa = []\n 2. \\<And>a r xa.\n       \\<lbrakk>\\<forall>xa. xa @ t = r @ [x] \\<longrightarrow> xa \\<le> r;\n        xa @ t = a # r @ [x]; t \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> a # r", "apply(erule rev_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       t \\<noteq> [] \\<Longrightarrow>\n       xa @ t = [x] \\<longrightarrow> xa = []\n 2. \\<And>a r xa.\n       \\<lbrakk>\\<forall>xa. xa @ t = r @ [x] \\<longrightarrow> xa \\<le> r;\n        xa @ t = a # r @ [x]; t \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> a # r", "apply(rename_tac xa, rule_tac list=xa in list.induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a r xa.\n       \\<lbrakk>\\<forall>xa. xa @ t = r @ [x] \\<longrightarrow> xa \\<le> r;\n        xa @ t = a # r @ [x]; t \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> a # r", "apply(simp add: le_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a r xa.\n       \\<lbrakk>\\<forall>xa.\n                   xa @ t = r @ [x] \\<longrightarrow>\n                   (\\<exists>ra. xa @ ra = r);\n        xa @ t = a # r @ [x]; t \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ra. xa @ ra = a # r", "apply(drule list_nonMt_append, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prefixes_fin: \"let prefixes = {t. \\<exists>t2. x = t @ t2} in finite prefixes \\<and> card prefixes = length x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let prefixes = {t. \\<exists>t2. x = t @ t2}\n    in finite prefixes \\<and> card prefixes = length x + 1", "proof(induct x, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       let prefixes = {t. \\<exists>t2. x = t @ t2}\n       in finite prefixes \\<and>\n          card prefixes = length x + 1 \\<Longrightarrow>\n       let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n       in finite prefixes \\<and> card prefixes = length (a # x) + 1", "case (Cons a x)"], ["proof (state)\nthis:\n  let prefixes = {t. \\<exists>t2. x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length x + 1\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       let prefixes = {t. \\<exists>t2. x = t @ t2}\n       in finite prefixes \\<and>\n          card prefixes = length x + 1 \\<Longrightarrow>\n       let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n       in finite prefixes \\<and> card prefixes = length (a # x) + 1", "hence A:\"finite {t. (\\<exists>t2. x = t @ t2)}\""], ["proof (prove)\nusing this:\n  let prefixes = {t. \\<exists>t2. x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length x + 1\n\ngoal (1 subgoal):\n 1. finite {t. \\<exists>t2. x = t @ t2}", "using not_add_less2"], ["proof (prove)\nusing this:\n  let prefixes = {t. \\<exists>t2. x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length x + 1\n  \\<not> ?j + ?i < ?i\n\ngoal (1 subgoal):\n 1. finite {t. \\<exists>t2. x = t @ t2}", "by fastforce"], ["proof (state)\nthis:\n  finite {t. \\<exists>t2. x = t @ t2}\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       let prefixes = {t. \\<exists>t2. x = t @ t2}\n       in finite prefixes \\<and>\n          card prefixes = length x + 1 \\<Longrightarrow>\n       let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n       in finite prefixes \\<and> card prefixes = length (a # x) + 1", "have B:\"inj_on Cons UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (#)", "by (metis injI list.inject)"], ["proof (state)\nthis:\n  inj (#)\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       let prefixes = {t. \\<exists>t2. x = t @ t2}\n       in finite prefixes \\<and>\n          card prefixes = length x + 1 \\<Longrightarrow>\n       let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n       in finite prefixes \\<and> card prefixes = length (a # x) + 1", "from Cons A B inj_on_iff_eq_card"], ["proof (chain)\npicking this:\n  let prefixes = {t. \\<exists>t2. x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length x + 1\n  finite {t. \\<exists>t2. x = t @ t2}\n  inj (#)\n  finite ?A \\<Longrightarrow> inj_on ?f ?A = (card (?f ` ?A) = card ?A)", "have  C:\"card ((\\<lambda>x. a#x)`{t. (\\<exists>t2. x = t @ t2)}) = length x + 1\""], ["proof (prove)\nusing this:\n  let prefixes = {t. \\<exists>t2. x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length x + 1\n  finite {t. \\<exists>t2. x = t @ t2}\n  inj (#)\n  finite ?A \\<Longrightarrow> inj_on ?f ?A = (card (?f ` ?A) = card ?A)\n\ngoal (1 subgoal):\n 1. card ((#) a ` {t. \\<exists>t2. x = t @ t2}) = length x + 1", "by fastforce"], ["proof (state)\nthis:\n  card ((#) a ` {t. \\<exists>t2. x = t @ t2}) = length x + 1\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       let prefixes = {t. \\<exists>t2. x = t @ t2}\n       in finite prefixes \\<and>\n          card prefixes = length x + 1 \\<Longrightarrow>\n       let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n       in finite prefixes \\<and> card prefixes = length (a # x) + 1", "have D:\"{t. \\<exists>t2. a # x = t @ t2} = {[]} \\<union> (\\<lambda>x. a#x)`{t. (\\<exists>t2. x = t @ t2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>t2. a # x = t @ t2} =\n    {[]} \\<union> (#) a ` {t. \\<exists>t2. x = t @ t2}", "by(intro set_eqI iffI, auto simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  {t. \\<exists>t2. a # x = t @ t2} =\n  {[]} \\<union> (#) a ` {t. \\<exists>t2. x = t @ t2}\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       let prefixes = {t. \\<exists>t2. x = t @ t2}\n       in finite prefixes \\<and>\n          card prefixes = length x + 1 \\<Longrightarrow>\n       let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n       in finite prefixes \\<and> card prefixes = length (a # x) + 1", "from C D card_insert_if[of \"(\\<lambda>x. a#x)`{t. (\\<exists>t2. x = t @ t2)}\"]"], ["proof (chain)\npicking this:\n  card ((#) a ` {t. \\<exists>t2. x = t @ t2}) = length x + 1\n  {t. \\<exists>t2. a # x = t @ t2} =\n  {[]} \\<union> (#) a ` {t. \\<exists>t2. x = t @ t2}\n  finite ((#) a ` {t. \\<exists>t2. x = t @ t2}) \\<Longrightarrow>\n  card (insert ?x ((#) a ` {t. \\<exists>t2. x = t @ t2})) =\n  (if ?x \\<in> (#) a ` {t. \\<exists>t2. x = t @ t2}\n   then card ((#) a ` {t. \\<exists>t2. x = t @ t2})\n   else Suc (card ((#) a ` {t. \\<exists>t2. x = t @ t2})))", "show ?case"], ["proof (prove)\nusing this:\n  card ((#) a ` {t. \\<exists>t2. x = t @ t2}) = length x + 1\n  {t. \\<exists>t2. a # x = t @ t2} =\n  {[]} \\<union> (#) a ` {t. \\<exists>t2. x = t @ t2}\n  finite ((#) a ` {t. \\<exists>t2. x = t @ t2}) \\<Longrightarrow>\n  card (insert ?x ((#) a ` {t. \\<exists>t2. x = t @ t2})) =\n  (if ?x \\<in> (#) a ` {t. \\<exists>t2. x = t @ t2}\n   then card ((#) a ` {t. \\<exists>t2. x = t @ t2})\n   else Suc (card ((#) a ` {t. \\<exists>t2. x = t @ t2})))\n\ngoal (1 subgoal):\n 1. let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n    in finite prefixes \\<and> card prefixes = length (a # x) + 1", "by (metis (no_types, lifting) One_nat_def Suc_eq_plus1 Un_insert_left finite.insertI \n        finite_imageI image_iff list.distinct(1) list.size(4) local.A sup_bot.left_neutral)"], ["proof (state)\nthis:\n  let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length (a # x) + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sublists_fin: \"finite {t. \\<exists>t1 t2. x = t1 @ t @ t2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. \\<exists>t1 t2. x = t1 @ t @ t2}", "proof(induct x, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       finite {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<Longrightarrow>\n       finite {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}", "case (Cons a x)"], ["proof (state)\nthis:\n  finite {t. \\<exists>t1 t2. x = t1 @ t @ t2}\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       finite {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<Longrightarrow>\n       finite {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}", "have \"{t. \\<exists>t1 t2. a # x = t1 @ t @ t2} \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<union> {t. \\<exists>t2. a#x = t @ t2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}\n    \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<union>\n                {t. \\<exists>t2. a # x = t @ t2}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t1 t2.\n       \\<lbrakk>\\<forall>t2a. t1 @ x @ t2 \\<noteq> x @ t2a;\n        a # x = t1 @ x @ t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t1 t2. x = t1 @ x @ t2", "by (metis Cons_eq_append_conv)"], ["proof (state)\nthis:\n  {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}\n  \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<union>\n              {t. \\<exists>t2. a # x = t @ t2}\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       finite {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<Longrightarrow>\n       finite {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}", "with Cons prefixes_fin[of \"a#x\"]"], ["proof (chain)\npicking this:\n  finite {t. \\<exists>t1 t2. x = t1 @ t @ t2}\n  let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length (a # x) + 1\n  {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}\n  \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<union>\n              {t. \\<exists>t2. a # x = t @ t2}", "show ?case"], ["proof (prove)\nusing this:\n  finite {t. \\<exists>t1 t2. x = t1 @ t @ t2}\n  let prefixes = {t. \\<exists>t2. a # x = t @ t2}\n  in finite prefixes \\<and> card prefixes = length (a # x) + 1\n  {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}\n  \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<union>\n              {t. \\<exists>t2. a # x = t @ t2}\n\ngoal (1 subgoal):\n 1. finite {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}", "by (meson finite_UnI finite_subset)"], ["proof (state)\nthis:\n  finite {t. \\<exists>t1 t2. a # x = t1 @ t @ t2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma suffixes_fin: \"finite {t. \\<exists>t1. x = t1 @ t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. \\<exists>t1. x = t1 @ t}", "apply(subgoal_tac \"{t. \\<exists>t1. x = t1 @ t} \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. {t. \\<exists>t1. x = t1 @ t}\n    \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<Longrightarrow>\n    finite {t. \\<exists>t1. x = t1 @ t}\n 2. {t. \\<exists>t1. x = t1 @ t}\n    \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2}", "using infinite_super sublists_fin"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n  finite {t. \\<exists>t1 t2. ?x = t1 @ t @ t2}\n\ngoal (2 subgoals):\n 1. {t. \\<exists>t1. x = t1 @ t}\n    \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2} \\<Longrightarrow>\n    finite {t. \\<exists>t1. x = t1 @ t}\n 2. {t. \\<exists>t1. x = t1 @ t}\n    \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>t1. x = t1 @ t}\n    \\<subseteq> {t. \\<exists>t1 t2. x = t1 @ t @ t2}", "by blast"], ["", "text\\<open>For the process invariant, it is a key element to\nreduce the notion of traces to traces that may only contain\none tick event at the very end. This is captured by the definition\nof the predicate \\verb+front_tickFree+ and its stronger version\n\\verb+tickFree+. Here is the theory of this concept.\\<close>"], ["", "definition tickFree :: \"'\\<alpha> trace \\<Rightarrow> bool\"\n  where \"tickFree s = (tick \\<notin> set s)\""], ["", "definition front_tickFree :: \"'\\<alpha> trace \\<Rightarrow> bool\"\n  where \"front_tickFree s = (s =[] \\<or> tickFree(tl(rev s)))\""], ["", "lemma tickFree_Nil [simp]: \"tickFree []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree []", "by(simp add: tickFree_def)"], ["", "lemma tickFree_Cons [simp]: \"tickFree (a # t) = (a \\<noteq> tick \\<and> tickFree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree (a # t) = (a \\<noteq> tick \\<and> tickFree t)", "by(auto simp add: tickFree_def)"], ["", "lemma tickFree_tl : \"[|s ~= [] ; tickFree s|] ==> tickFree(tl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; tickFree s\\<rbrakk>\n    \\<Longrightarrow> tickFree (tl s)", "by(case_tac s, simp_all)"], ["", "lemma tickFree_append[simp]: \"tickFree(s@t) = (tickFree s \\<and> tickFree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree (s @ t) = (tickFree s \\<and> tickFree t)", "by(simp add: tickFree_def member_def)"], ["", "lemma non_tickFree_tick [simp]: \"\\<not> tickFree [tick]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tickFree [tick]", "by(simp add: tickFree_def)"], ["", "lemma non_tickFree_implies_nonMt: \"\\<not> tickFree s \\<Longrightarrow> s \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tickFree s \\<Longrightarrow> s \\<noteq> []", "by(simp add:tickFree_def,erule rev_mp, induct s, simp_all)"], ["", "lemma  tickFree_rev : \"tickFree(rev t) = (tickFree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree (rev t) = tickFree t", "by(simp  add: tickFree_def member_def)"], ["", "lemma front_tickFree_Nil[simp]: \"front_tickFree []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree []", "by(simp add: front_tickFree_def)"], ["", "lemma front_tickFree_single[simp]: \"front_tickFree [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree [a]", "by(simp add: front_tickFree_def)"], ["", "lemma tickFree_implies_front_tickFree: \"tickFree s \\<Longrightarrow> front_tickFree s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree s \\<Longrightarrow> front_tickFree s", "apply(simp add: tickFree_def front_tickFree_def member_def,safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tick \\<notin> set s; s \\<noteq> [];\n     tick \\<in> set (tl (rev s))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule contrapos_np, simp,(erule rev_mp)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tick \\<in> set (tl (rev s)) \\<longrightarrow>\n    s \\<noteq> [] \\<longrightarrow> tick \\<in> set s", "apply(rule_tac xs=s in List.rev_induct,simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma front_tickFree_charn: \"front_tickFree s = (s = [] \\<or> (\\<exists>a t. s = t @ [a] \\<and> tickFree t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree s =\n    (s = [] \\<or> (\\<exists>a t. s = t @ [a] \\<and> tickFree t))", "apply(simp add: front_tickFree_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s = [] \\<or> tickFree (tl (rev s))) =\n    (s = [] \\<or> (\\<exists>a t. s = t @ [a] \\<and> tickFree t))", "apply(cases \"s=[]\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    tickFree (tl (rev s)) = (\\<exists>a t. s = t @ [a] \\<and> tickFree t)", "apply(drule list_nonMt_append, auto simp: tickFree_rev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma front_tickFree_implies_tickFree: \"front_tickFree (t @ [a]) \\<Longrightarrow> tickFree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree (t @ [a]) \\<Longrightarrow> tickFree t", "by(simp add: tickFree_def front_tickFree_def member_def)"], ["", "lemma tickFree_implies_front_tickFree_single: \"tickFree t \\<Longrightarrow> front_tickFree (t @ [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree t \\<Longrightarrow> front_tickFree (t @ [a])", "by(simp add:front_tickFree_charn)"], ["", "lemma nonTickFree_n_frontTickFree: \"\\<lbrakk>\\<not> tickFree s; front_tickFree s \\<rbrakk> \\<Longrightarrow> \\<exists>t. s = t @ [tick]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> tickFree s; front_tickFree s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t. s = t @ [tick]", "apply(frule non_tickFree_implies_nonMt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> tickFree s; front_tickFree s; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t. s = t @ [tick]", "apply(drule front_tickFree_charn[THEN iffD1], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma front_tickFree_dw_closed : \"front_tickFree (s @ t) \\<Longrightarrow>  front_tickFree s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree (s @ t) \\<Longrightarrow> front_tickFree s", "apply(erule rev_mp, rule_tac x= s in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. front_tickFree (x @ t) \\<longrightarrow> front_tickFree x", "apply(rule_tac xs=t in List.rev_induct, simp, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<forall>x.\n                   front_tickFree (x @ xs) \\<longrightarrow>\n                   front_tickFree x;\n        front_tickFree (xa @ xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> front_tickFree xa", "apply(rename_tac x xs xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<forall>x.\n                   front_tickFree (x @ xs) \\<longrightarrow>\n                   front_tickFree x;\n        front_tickFree (xa @ xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> front_tickFree xa", "apply(simp only: append_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<forall>x.\n                   front_tickFree (x @ xs) \\<longrightarrow>\n                   front_tickFree x;\n        front_tickFree ((xa @ xs) @ [x])\\<rbrakk>\n       \\<Longrightarrow> front_tickFree xa", "apply(rename_tac x xs xa, erule_tac x=\"xa @ xs\" in all_dupE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>front_tickFree ((xa @ xs) @ [x]);\n        front_tickFree ((xa @ xs) @ xs) \\<longrightarrow>\n        front_tickFree (xa @ xs);\n        \\<forall>x.\n           front_tickFree (x @ xs) \\<longrightarrow>\n           front_tickFree x\\<rbrakk>\n       \\<Longrightarrow> front_tickFree xa", "apply(drule front_tickFree_implies_tickFree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>front_tickFree ((xa @ xs) @ xs) \\<longrightarrow>\n                front_tickFree (xa @ xs);\n        \\<forall>x.\n           front_tickFree (x @ xs) \\<longrightarrow> front_tickFree x;\n        tickFree (xa @ xs)\\<rbrakk>\n       \\<Longrightarrow> front_tickFree xa", "apply(erule_tac x=\"xa\" in allE, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xa.\n       \\<lbrakk>tickFree xa; tickFree xs;\n        \\<not> front_tickFree (xa @ xs @ xs);\n        \\<not> front_tickFree (xa @ xs)\\<rbrakk>\n       \\<Longrightarrow> front_tickFree xa", "apply(auto dest!:tickFree_implies_front_tickFree)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma front_tickFree_append: \"\\<lbrakk> tickFree s; front_tickFree t\\<rbrakk> \\<Longrightarrow> front_tickFree (s @ t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tickFree s; front_tickFree t\\<rbrakk>\n    \\<Longrightarrow> front_tickFree (s @ t)", "apply(drule front_tickFree_charn[THEN iffD1], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tickFree s; t = []\\<rbrakk> \\<Longrightarrow> front_tickFree s\n 2. \\<And>a ta.\n       \\<lbrakk>tickFree s; tickFree ta; t = ta @ [a]\\<rbrakk>\n       \\<Longrightarrow> front_tickFree (s @ ta @ [a])", "apply(erule tickFree_implies_front_tickFree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ta.\n       \\<lbrakk>tickFree s; tickFree ta; t = ta @ [a]\\<rbrakk>\n       \\<Longrightarrow> front_tickFree (s @ ta @ [a])", "apply(subst append_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ta.\n       \\<lbrakk>tickFree s; tickFree ta; t = ta @ [a]\\<rbrakk>\n       \\<Longrightarrow> front_tickFree ((s @ ta) @ [a])", "apply(rule tickFree_implies_front_tickFree_single)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ta.\n       \\<lbrakk>tickFree s; tickFree ta; t = ta @ [a]\\<rbrakk>\n       \\<Longrightarrow> tickFree (s @ ta)", "apply(auto intro: tickFree_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma front_tickFree_mono: \"front_tickFree (t @ r) \\<and> r \\<noteq> [] \\<longrightarrow> tickFree t \\<and> front_tickFree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree (t @ r) \\<and> r \\<noteq> [] \\<longrightarrow>\n    tickFree t \\<and> front_tickFree r", "by(metis append_assoc append_butlast_last_id front_tickFree_charn \n         front_tickFree_implies_tickFree tickFree_append)"], ["", "subsection\\<open> Basic Types, Traces, Failures and Divergences \\<close>"], ["", "type_synonym '\\<alpha> refusal = \"('\\<alpha> event) set\""], ["", "type_synonym '\\<alpha> failure = \"'\\<alpha> trace \\<times> '\\<alpha> refusal\""], ["", "type_synonym '\\<alpha> divergence = \"'\\<alpha> trace set\""], ["", "type_synonym '\\<alpha> process\\<^sub>0 = \"'\\<alpha> failure set \\<times> '\\<alpha> divergence\""], ["", "definition FAILURES :: \"'\\<alpha> process\\<^sub>0 \\<Rightarrow> ('\\<alpha> failure set)\"\n  where \"FAILURES P = fst P\""], ["", "definition TRACES :: \"'\\<alpha> process\\<^sub>0 \\<Rightarrow> ('\\<alpha> trace set)\"\n  where \"TRACES P = {tr. \\<exists> a. a \\<in> FAILURES P \\<and> tr = fst a}\""], ["", "definition DIVERGENCES :: \"'\\<alpha> process\\<^sub>0 \\<Rightarrow> '\\<alpha> divergence\"\n  where \"DIVERGENCES P = snd P\""], ["", "definition REFUSALS :: \"'\\<alpha> process\\<^sub>0 \\<Rightarrow> ('\\<alpha> refusal set)\"\n  where \"REFUSALS P = {ref.  \\<exists> F. F \\<in> FAILURES P \\<and> F = ([],ref)}\""], ["", "subsection\\<open> The Process Type Invariant \\<close>"], ["", "definition is_process :: \"'\\<alpha> process\\<^sub>0 \\<Rightarrow> bool\" where\n  \"is_process P =\n      (([],{}) \\<in> FAILURES P \\<and>\n       (\\<forall> s X.  (s,X) \\<in> FAILURES P \\<longrightarrow> front_tickFree s) \\<and>\n       (\\<forall> s t . (s@t,{}) \\<in> FAILURES P \\<longrightarrow> (s,{}) \\<in> FAILURES P) \\<and>\n       (\\<forall> s X Y. (s,Y) \\<in> FAILURES P & X <= Y \\<longrightarrow> (s,X) \\<in> FAILURES P) \\<and> \n       (\\<forall> s X Y. (s,X) \\<in> FAILURES P \\<and>\n       (\\<forall> c.      c \\<in> Y \\<longrightarrow> ((s@[c],{})\\<notin>FAILURES P)) \\<longrightarrow> \n                                         (s,X \\<union> Y)\\<in>FAILURES P) \\<and>\n       (\\<forall> s X.  (s@[tick],{}) : FAILURES P \\<longrightarrow> (s,X-{tick}) \\<in> FAILURES P) \\<and>\n       (\\<forall> s t.  s \\<in> DIVERGENCES P \\<and> tickFree s \\<and> front_tickFree t \n                                      \\<longrightarrow> s@t \\<in> DIVERGENCES P)  \\<and>\n       (\\<forall> s X. s \\<in> DIVERGENCES P \\<longrightarrow> (s,X) \\<in> FAILURES P) \\<and>\n       (\\<forall> s. s @ [tick] : DIVERGENCES P \\<longrightarrow> s \\<in> DIVERGENCES P))\""], ["", "lemma is_process_spec:\n \"is_process P = \n       (([],{}) \\<in>  FAILURES P \\<and>\n       (\\<forall> s X. (s,X) \\<in>  FAILURES P \\<longrightarrow> front_tickFree s) \\<and>\n       (\\<forall> s t . (s @ t,{}) \\<notin> FAILURES P \\<or>   (s,{}) \\<in> FAILURES P) \\<and>\n       (\\<forall> s X Y. (s,Y)  \\<notin>  FAILURES P \\<or> \\<not>(X\\<subseteq>Y) | (s,X) \\<in> FAILURES P) \\<and>\n       (\\<forall> s X Y.(s,X) \\<in> FAILURES P \\<and> \n       (\\<forall> c. c \\<in>  Y \\<longrightarrow> ((s@[c],{}) \\<notin>  FAILURES P)) \\<longrightarrow>(s,X \\<union> Y) \\<in>  FAILURES P) \\<and>\n       (\\<forall> s X. (s@[tick],{}) \\<in>  FAILURES P \\<longrightarrow> (s,X - {tick}) \\<in>  FAILURES P) \\<and>\n       (\\<forall> s t. s \\<notin> DIVERGENCES P \\<or> \\<not>tickFree s \\<or> \\<not>front_tickFree t \n                                 \\<or> s @ t \\<in> DIVERGENCES P) \\<and>\n       (\\<forall> s X. s \\<notin> DIVERGENCES P \\<or> (s,X) \\<in>  FAILURES P) \\<and>\n       (\\<forall> s. s @ [tick] \\<notin>  DIVERGENCES P \\<or> s \\<in>  DIVERGENCES P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P =\n    (([], {}) \\<in> FAILURES P \\<and>\n     (\\<forall>s X.\n         (s, X) \\<in> FAILURES P \\<longrightarrow> front_tickFree s) \\<and>\n     (\\<forall>s t.\n         (s @ t, {}) \\<notin> FAILURES P \\<or>\n         (s, {}) \\<in> FAILURES P) \\<and>\n     (\\<forall>s X Y.\n         (s, Y) \\<notin> FAILURES P \\<or>\n         \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> FAILURES P) \\<and>\n     (\\<forall>s X Y.\n         (s, X) \\<in> FAILURES P \\<and>\n         (\\<forall>c.\n             c \\<in> Y \\<longrightarrow>\n             (s @ [c], {}) \\<notin> FAILURES P) \\<longrightarrow>\n         (s, X \\<union> Y) \\<in> FAILURES P) \\<and>\n     (\\<forall>s X.\n         (s @ [tick], {}) \\<in> FAILURES P \\<longrightarrow>\n         (s, X - {tick}) \\<in> FAILURES P) \\<and>\n     (\\<forall>s t.\n         s \\<notin> DIVERGENCES P \\<or>\n         \\<not> tickFree s \\<or>\n         \\<not> front_tickFree t \\<or> s @ t \\<in> DIVERGENCES P) \\<and>\n     (\\<forall>s X.\n         s \\<notin> DIVERGENCES P \\<or> (s, X) \\<in> FAILURES P) \\<and>\n     (\\<forall>s.\n         s @ [tick] \\<notin> DIVERGENCES P \\<or> s \\<in> DIVERGENCES P))", "by(simp  only: is_process_def  HOL.nnf_simps(1)  HOL.nnf_simps(3) [symmetric]  \n                      HOL.imp_conjL[symmetric])"], ["", "lemma Process_eqI :\nassumes A: \"FAILURES P = FAILURES Q \"\nassumes B: \"DIVERGENCES P = DIVERGENCES Q\"\nshows      \"(P::'\\<alpha> process\\<^sub>0) = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "apply(insert A B, unfold FAILURES_def DIVERGENCES_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst P = fst Q; snd P = snd Q\\<rbrakk> \\<Longrightarrow> P = Q", "apply(rule_tac t=P in surjective_pairing[symmetric,THEN subst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst P = fst Q; snd P = snd Q\\<rbrakk>\n    \\<Longrightarrow> (fst P, snd P) = Q", "apply(rule_tac t=Q in surjective_pairing[symmetric,THEN subst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst P = fst Q; snd P = snd Q\\<rbrakk>\n    \\<Longrightarrow> (fst P, snd P) = (fst Q, snd Q)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma process_eq_spec:\n\"((P::'a process\\<^sub>0) = Q) = (FAILURES P = FAILURES Q \\<and> DIVERGENCES P = DIVERGENCES Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = Q) = (FAILURES P = FAILURES Q \\<and> DIVERGENCES P = DIVERGENCES Q)", "apply(auto simp: FAILURES_def DIVERGENCES_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst P = fst Q; snd P = snd Q\\<rbrakk> \\<Longrightarrow> P = Q", "apply(rule_tac t=P in surjective_pairing[symmetric,THEN subst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst P = fst Q; snd P = snd Q\\<rbrakk>\n    \\<Longrightarrow> (fst P, snd P) = Q", "apply(rule_tac t=Q in surjective_pairing[symmetric,THEN subst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst P = fst Q; snd P = snd Q\\<rbrakk>\n    \\<Longrightarrow> (fst P, snd P) = (fst Q, snd Q)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma process_surj_pair: \"(FAILURES P,DIVERGENCES P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FAILURES P, DIVERGENCES P) = P", "by(auto simp:FAILURES_def DIVERGENCES_def)"], ["", "lemma Fa_eq_imp_Tr_eq: \"FAILURES P = FAILURES Q \\<Longrightarrow> TRACES P = TRACES Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAILURES P = FAILURES Q \\<Longrightarrow> TRACES P = TRACES Q", "by(auto simp:FAILURES_def DIVERGENCES_def TRACES_def)"], ["", "lemma is_process1:  \"is_process P \\<Longrightarrow> ([],{})\\<in> FAILURES P \""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow> ([], {}) \\<in> FAILURES P", "by(auto simp: is_process_def)"], ["", "lemma is_process2: \"is_process P \\<Longrightarrow> \\<forall> s X. (s,X) \\<in> FAILURES P \\<longrightarrow> front_tickFree s \""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>s X. (s, X) \\<in> FAILURES P \\<longrightarrow> front_tickFree s", "by(simp only: is_process_spec, metis)"], ["", "lemma is_process3: \"is_process P \\<Longrightarrow> \\<forall> s t. (s @ t,{}) \\<in> FAILURES P \\<longrightarrow> (s, {}) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>s t.\n       (s @ t, {}) \\<in> FAILURES P \\<longrightarrow>\n       (s, {}) \\<in> FAILURES P", "by(simp only: is_process_spec, metis)"], ["", "lemma is_process3_S_pref: \"\\<lbrakk>is_process P; (t, {}) \\<in> FAILURES P; s \\<le> t\\<rbrakk> \\<Longrightarrow> (s, {}) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (t, {}) \\<in> FAILURES P; s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> (s, {}) \\<in> FAILURES P", "by(auto simp: le_list_def intro: is_process3 [rule_format])"], ["", "lemma is_process4: \"is_process P \\<Longrightarrow> \\<forall>s X Y. (s, Y) \\<notin> FAILURES P \\<or> \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>s X Y.\n       (s, Y) \\<notin> FAILURES P \\<or>\n       \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> FAILURES P", "by(simp only: is_process_spec, simp)"], ["", "lemma is_process4_S: \"\\<lbrakk>is_process P; (s, Y) \\<in> FAILURES P; X \\<subseteq> Y\\<rbrakk> \\<Longrightarrow> (s, X) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (s, Y) \\<in> FAILURES P; X \\<subseteq> Y\\<rbrakk>\n    \\<Longrightarrow> (s, X) \\<in> FAILURES P", "by(drule is_process4, auto)"], ["", "lemma is_process4_S1: \"\\<lbrakk>is_process P; x \\<in> FAILURES P; X \\<subseteq> snd x\\<rbrakk> \\<Longrightarrow> (fst x, X) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; x \\<in> FAILURES P; X \\<subseteq> snd x\\<rbrakk>\n    \\<Longrightarrow> (fst x, X) \\<in> FAILURES P", "by(drule is_process4_S, auto)"], ["", "lemma is_process5:\n\"is_process P \\<Longrightarrow>\n    \\<forall>sa X Y. (sa, X) \\<in> FAILURES P \\<and> (\\<forall>c. c \\<in> Y \\<longrightarrow> (sa @ [c], {}) \\<notin> FAILURES P) \\<longrightarrow> (sa, X \\<union> Y) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>sa X Y.\n       (sa, X) \\<in> FAILURES P \\<and>\n       (\\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (sa @ [c], {}) \\<notin> FAILURES P) \\<longrightarrow>\n       (sa, X \\<union> Y) \\<in> FAILURES P", "by(drule is_process_spec[THEN iffD1],metis)"], ["", "lemma is_process5_S:\n\"\\<lbrakk>is_process P; (sa, X) \\<in> FAILURES P; \\<forall>c. c \\<in> Y \\<longrightarrow> (sa @ [c], {}) \\<notin> FAILURES P\\<rbrakk> \\<Longrightarrow> (sa, X \\<union> Y) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (sa, X) \\<in> FAILURES P;\n     \\<forall>c.\n        c \\<in> Y \\<longrightarrow>\n        (sa @ [c], {}) \\<notin> FAILURES P\\<rbrakk>\n    \\<Longrightarrow> (sa, X \\<union> Y) \\<in> FAILURES P", "by(drule is_process5, metis)"], ["", "lemma is_process5_S1:\n\"\\<lbrakk>is_process P; (sa, X) \\<in> FAILURES P; (sa, X \\<union> Y) \\<notin> FAILURES P\\<rbrakk> \\<Longrightarrow> \\<exists>c. c \\<in> Y \\<and> (sa @ [c], {}) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (sa, X) \\<in> FAILURES P;\n     (sa, X \\<union> Y) \\<notin> FAILURES P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         c \\<in> Y \\<and> (sa @ [c], {}) \\<in> FAILURES P", "by(erule contrapos_np, drule is_process5_S, simp_all)"], ["", "lemma is_process6: \"is_process P \\<Longrightarrow>  \\<forall> s X. (s@[tick],{}) \\<in> FAILURES P \\<longrightarrow> (s,X-{tick}) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>s X.\n       (s @ [tick], {}) \\<in> FAILURES P \\<longrightarrow>\n       (s, X - {tick}) \\<in> FAILURES P", "by(drule is_process_spec[THEN iffD1], metis)"], ["", "lemma is_process6_S: \"\\<lbrakk>is_process P ;(s@[tick],{}) \\<in> FAILURES P\\<rbrakk> \\<Longrightarrow>  (s,X-{tick}) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (s @ [tick], {}) \\<in> FAILURES P\\<rbrakk>\n    \\<Longrightarrow> (s, X - {tick}) \\<in> FAILURES P", "by(drule is_process6, metis)"], ["", "lemma is_process7:\n\"is_process P \\<Longrightarrow> \\<forall> s t. s \\<notin> DIVERGENCES P \\<or> \\<not> tickFree s \\<or> \\<not> front_tickFree t \\<or> s @ t \\<in> DIVERGENCES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>s t.\n       s \\<notin> DIVERGENCES P \\<or>\n       \\<not> tickFree s \\<or>\n       \\<not> front_tickFree t \\<or> s @ t \\<in> DIVERGENCES P", "by(drule is_process_spec[THEN iffD1], metis)"], ["", "lemma is_process7_S:\n\"\\<lbrakk> is_process P;s : DIVERGENCES P;tickFree s;front_tickFree t\\<rbrakk> \n \\<Longrightarrow>  s @ t \\<in> DIVERGENCES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; s \\<in> DIVERGENCES P; tickFree s;\n     front_tickFree t\\<rbrakk>\n    \\<Longrightarrow> s @ t \\<in> DIVERGENCES P", "by(drule is_process7, metis)"], ["", "lemma is_process8: \"is_process P \\<Longrightarrow> \\<forall>  s X. s \\<notin> DIVERGENCES P \\<or>  (s,X) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>s X. s \\<notin> DIVERGENCES P \\<or> (s, X) \\<in> FAILURES P", "by(drule is_process_spec[THEN iffD1], metis)"], ["", "lemma is_process8_S: \"\\<lbrakk> is_process P; s \\<in> DIVERGENCES P \\<rbrakk> \\<Longrightarrow> (s,X)  \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; s \\<in> DIVERGENCES P\\<rbrakk>\n    \\<Longrightarrow> (s, X) \\<in> FAILURES P", "by(drule is_process8, metis)"], ["", "lemma is_process9: \"is_process P \\<Longrightarrow> \\<forall>  s. s@[tick] \\<notin> DIVERGENCES P \\<or>  s \\<in> DIVERGENCES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process P \\<Longrightarrow>\n    \\<forall>s.\n       s @ [tick] \\<notin> DIVERGENCES P \\<or> s \\<in> DIVERGENCES P", "by(drule is_process_spec[THEN iffD1], metis)"], ["", "lemma is_process9_S: \"\\<lbrakk> is_process P;s@[tick] \\<in> DIVERGENCES P \\<rbrakk> \\<Longrightarrow> s \\<in> DIVERGENCES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; s @ [tick] \\<in> DIVERGENCES P\\<rbrakk>\n    \\<Longrightarrow> s \\<in> DIVERGENCES P", "by(drule is_process9, metis)"], ["", "lemma Failures_implies_Traces: \" \\<lbrakk>is_process P; (s, X) \\<in> FAILURES P\\<rbrakk> \\<Longrightarrow> s \\<in> TRACES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (s, X) \\<in> FAILURES P\\<rbrakk>\n    \\<Longrightarrow> s \\<in> TRACES P", "by(simp add: TRACES_def, metis)"], ["", "lemma is_process5_sing: \n\"\\<lbrakk> is_process P ; (s,{x}) \\<notin> FAILURES P;(s,{}) \\<in> FAILURES P\\<rbrakk> \\<Longrightarrow> (s @ [x],{}) \\<in> FAILURES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (s, {x}) \\<notin> FAILURES P;\n     (s, {}) \\<in> FAILURES P\\<rbrakk>\n    \\<Longrightarrow> (s @ [x], {}) \\<in> FAILURES P", "by(drule_tac X=\"{}\" in is_process5_S1, auto)"], ["", "lemma is_process5_singT: \n\"\\<lbrakk> is_process P ; (s,{x}) \\<notin> FAILURES P;(s,{}) \\<in> FAILURES P\\<rbrakk>  \\<Longrightarrow> s @ [x]  \\<in> TRACES P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; (s, {x}) \\<notin> FAILURES P;\n     (s, {}) \\<in> FAILURES P\\<rbrakk>\n    \\<Longrightarrow> s @ [x] \\<in> TRACES P", "apply(drule is_process5_sing, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, {x}) \\<notin> FAILURES P; (s, {}) \\<in> FAILURES P;\n     (s @ [x], {}) \\<in> FAILURES P\\<rbrakk>\n    \\<Longrightarrow> s @ [x] \\<in> TRACES P", "by(simp add: TRACES_def, auto)"], ["", "lemma front_trace_is_tickfree:\nassumes A: \"is_process P\" and B: \"(t @ [tick],X) \\<in> FAILURES P\"\nshows     \"tickFree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tickFree t", "have C: \"front_tickFree(t @ [tick])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree (t @ [tick])", "by(insert A B, drule is_process2, metis)"], ["proof (state)\nthis:\n  front_tickFree (t @ [tick])\n\ngoal (1 subgoal):\n 1. tickFree t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tickFree t", "by(rule front_tickFree_implies_tickFree[OF C])"], ["proof (state)\nthis:\n  tickFree t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_with_Tick_implies_tickFree_front : \"\\<lbrakk>is_process P; t @ [tick] \\<in> TRACES P\\<rbrakk> \\<Longrightarrow> tickFree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_process P; t @ [tick] \\<in> TRACES P\\<rbrakk>\n    \\<Longrightarrow> tickFree t", "by(auto simp: TRACES_def intro: front_trace_is_tickfree)"], ["", "subsection \\<open> The Abstraction to the process-Type \\<close>"], ["", "typedef \n  '\\<alpha> process = \"{p :: '\\<alpha> process\\<^sub>0 . is_process p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {p. is_process p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {p. is_process p}", "have \"({(s, X). s = []},{}) \\<in> {p::'\\<alpha> process\\<^sub>0. is_process p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({(s, X). s = []}, {}) \\<in> {p. is_process p}", "by(simp add: is_process_def  front_tickFree_def\n                     FAILURES_def TRACES_def DIVERGENCES_def )"], ["proof (state)\nthis:\n  ({(s, X). s = []}, {}) \\<in> {p. is_process p}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {p. is_process p}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ({(s, X). s = []}, {}) \\<in> {p. is_process p}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {p. is_process p}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> {p. is_process p}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition F :: \"'\\<alpha> process \\<Rightarrow>  ('\\<alpha> failure set)\"\n  where   \"F P = FAILURES (Rep_process P)\""], ["", "definition T :: \"'\\<alpha> process \\<Rightarrow>  ('\\<alpha> trace set)\"\n  where   \"T P = TRACES (Rep_process P)\""], ["", "definition D :: \"'\\<alpha> process \\<Rightarrow> '\\<alpha> divergence\"\n  where   \"D P = DIVERGENCES (Rep_process P)\""], ["", "definition R :: \"'\\<alpha> process \\<Rightarrow> ('\\<alpha> refusal set)\"\n  where   \"R P = REFUSALS (Rep_process P)\""], ["", "lemma is_process_Rep : \"is_process (Rep_process P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process (Rep_process P)", "by(rule_tac P=is_process in CollectD, rule Rep_process)"], ["", "lemma Process_spec: \"Abs_process((F P , D P)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_process (F P, D P) = P", "by(simp add: F_def FAILURES_def D_def \n             DIVERGENCES_def Rep_process_inverse)"], ["", "lemma Process_eq_spec: \"(P = Q)=(F P = F Q \\<and> D P = D Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = Q) = (F P = F Q \\<and> D P = D Q)", "apply(rule iffI,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. F P = F Q \\<and> D P = D Q \\<Longrightarrow> P = Q", "apply(rule_tac t=P in Process_spec[THEN subst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. F P = F Q \\<and> D P = D Q \\<Longrightarrow> Abs_process (F P, D P) = Q", "apply(rule_tac t=Q in Process_spec[THEN subst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. F P = F Q \\<and> D P = D Q \\<Longrightarrow>\n    Abs_process (F P, D P) = Abs_process (F Q, D Q)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Process_eq_spec_optimized: \"(P = Q) = (D P = D Q \\<and> (D P = D Q \\<longrightarrow> F P = F Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = Q) = (D P = D Q \\<and> (D P = D Q \\<longrightarrow> F P = F Q))", "using Process_eq_spec"], ["proof (prove)\nusing this:\n  (?P = ?Q) = (F ?P = F ?Q \\<and> D ?P = D ?Q)\n\ngoal (1 subgoal):\n 1. (P = Q) = (D P = D Q \\<and> (D P = D Q \\<longrightarrow> F P = F Q))", "by auto"], ["", "lemma is_processT:\n\"([],{}) \\<in> F P \\<and>\n (\\<forall> s X. (s,X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n (\\<forall> s t .(s@t,{}) \\<in> F P \\<longrightarrow> (s,{}) \\<in> F P) \\<and>\n (\\<forall> s X Y.(s,Y) \\<in> F P \\<and> (X\\<subseteq>Y) \\<longrightarrow> (s,X) \\<in> F P) \\<and>\n (\\<forall> s X Y.(s,X) \\<in> F P \\<and> (\\<forall>c. c \\<in> Y \\<longrightarrow>((s@[c],{})\\<notin>F P)) \\<longrightarrow> (s,X \\<union> Y) \\<in> F P) \\<and>\n (\\<forall> s X. (s@[tick],{}) \\<in> F P \\<longrightarrow> (s, X-{tick}) \\<in> F P) \\<and>\n (\\<forall> s t. s \\<in> D P \\<and> tickFree s \\<and> front_tickFree t \\<longrightarrow> s @ t \\<in> D P) \\<and>\n (\\<forall> s X. s \\<in> D P \\<longrightarrow> (s,X) \\<in> F P) \\<and>\n (\\<forall> s. s@[tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t.\n        (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n        (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<in> D P \\<and>\n        tickFree s \\<and> front_tickFree t \\<longrightarrow>\n        s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)", "apply(simp only: F_def D_def T_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> FAILURES (Rep_process P) \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> FAILURES (Rep_process P) \\<longrightarrow>\n        front_tickFree s) \\<and>\n    (\\<forall>s t.\n        (s @ t, {}) \\<in> FAILURES (Rep_process P) \\<longrightarrow>\n        (s, {}) \\<in> FAILURES (Rep_process P)) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<in> FAILURES (Rep_process P) \\<and>\n        X \\<subseteq> Y \\<longrightarrow>\n        (s, X) \\<in> FAILURES (Rep_process P)) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> FAILURES (Rep_process P) \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {})\n            \\<notin> FAILURES (Rep_process P)) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> FAILURES (Rep_process P)) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> FAILURES (Rep_process P) \\<longrightarrow>\n        (s, X - {tick}) \\<in> FAILURES (Rep_process P)) \\<and>\n    (\\<forall>s t.\n        s \\<in> DIVERGENCES (Rep_process P) \\<and>\n        tickFree s \\<and> front_tickFree t \\<longrightarrow>\n        s @ t \\<in> DIVERGENCES (Rep_process P)) \\<and>\n    (\\<forall>s X.\n        s \\<in> DIVERGENCES (Rep_process P) \\<longrightarrow>\n        (s, X) \\<in> FAILURES (Rep_process P)) \\<and>\n    (\\<forall>s.\n        s @ [tick] \\<in> DIVERGENCES (Rep_process P) \\<longrightarrow>\n        s \\<in> DIVERGENCES (Rep_process P))", "apply(rule is_process_def[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process (Rep_process P)", "apply(rule is_process_Rep)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma process_charn:\n  \"([], {}) \\<in> F P \\<and>\n   (\\<forall>s X. (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n   (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n   (\\<forall>s X Y. (s, Y) \\<notin> F P \\<or> \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n   (\\<forall>s X Y. (s, X) \\<in> F P \\<and> (\\<forall>c. c \\<in> Y \\<longrightarrow> (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n             (s, X \\<union> Y) \\<in> F P) \\<and>\n   (\\<forall>s X. (s @ [tick], {}) \\<in> F P \\<longrightarrow> (s, X - {tick}) \\<in> F P) \\<and>\n   (\\<forall>s t. s \\<notin> D P \\<or> \\<not> tickFree s \\<or> \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n   (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and> (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "have A: \"(\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or>  (s, {}) \\<in> F P) = \n      (\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) =\n    (\\<forall>s t.\n        (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) =\n  (\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "have B : \"(\\<forall>s X Y. (s, Y) \\<notin> F P \\<or> \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P)  =\n      (\\<forall>s X Y. (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow> (s, X) \\<in> F P) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) =\n    (\\<forall>s X Y.\n        (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n        (s, X) \\<in> F P)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>s X Y.\n      (s, Y) \\<notin> F P \\<or>\n      \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X Y.\n      (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n      (s, X) \\<in> F P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "have C : \"(\\<forall>s t. s \\<notin> D P \\<or> \\<not> tickFree s \\<or> \n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P)  =\n      (\\<forall>s t. s \\<in> D P \\<and> tickFree s \\<and> front_tickFree t \\<longrightarrow> s @ t \\<in> D P) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) =\n    (\\<forall>s t.\n        s \\<in> D P \\<and>\n        tickFree s \\<and> front_tickFree t \\<longrightarrow>\n        s @ t \\<in> D P)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>s t.\n      s \\<notin> D P \\<or>\n      \\<not> tickFree s \\<or>\n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P) =\n  (\\<forall>s t.\n      s \\<in> D P \\<and>\n      tickFree s \\<and> front_tickFree t \\<longrightarrow>\n      s @ t \\<in> D P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "have D:\"(\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) = (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) =\n    (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "have E:\"(\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) = \n      (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) =\n    (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) =\n  (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "note A B C D E"], ["proof (state)\nthis:\n  (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) =\n  (\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)\n  (\\<forall>s X Y.\n      (s, Y) \\<notin> F P \\<or>\n      \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X Y.\n      (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n      (s, X) \\<in> F P)\n  (\\<forall>s t.\n      s \\<notin> D P \\<or>\n      \\<not> tickFree s \\<or>\n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P) =\n  (\\<forall>s t.\n      s \\<in> D P \\<and>\n      tickFree s \\<and> front_tickFree t \\<longrightarrow>\n      s @ t \\<in> D P)\n  (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)\n  (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) =\n  (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "}"], ["proof (state)\nthis:\n  (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) =\n  (\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)\n  (\\<forall>s X Y.\n      (s, Y) \\<notin> F P \\<or>\n      \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X Y.\n      (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n      (s, X) \\<in> F P)\n  (\\<forall>s t.\n      s \\<notin> D P \\<or>\n      \\<not> tickFree s \\<or>\n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P) =\n  (\\<forall>s t.\n      s \\<in> D P \\<and>\n      tickFree s \\<and> front_tickFree t \\<longrightarrow>\n      s @ t \\<in> D P)\n  (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)\n  (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) =\n  (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "note a = this"], ["proof (state)\nthis:\n  (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) =\n  (\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)\n  (\\<forall>s X Y.\n      (s, Y) \\<notin> F P \\<or>\n      \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X Y.\n      (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n      (s, X) \\<in> F P)\n  (\\<forall>s t.\n      s \\<notin> D P \\<or>\n      \\<not> tickFree s \\<or>\n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P) =\n  (\\<forall>s t.\n      s \\<in> D P \\<and>\n      tickFree s \\<and> front_tickFree t \\<longrightarrow>\n      s @ t \\<in> D P)\n  (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)\n  (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) =\n  (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) =\n  (\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)\n  (\\<forall>s X Y.\n      (s, Y) \\<notin> F P \\<or>\n      \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X Y.\n      (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n      (s, X) \\<in> F P)\n  (\\<forall>s t.\n      s \\<notin> D P \\<or>\n      \\<not> tickFree s \\<or>\n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P) =\n  (\\<forall>s t.\n      s \\<in> D P \\<and>\n      tickFree s \\<and> front_tickFree t \\<longrightarrow>\n      s @ t \\<in> D P)\n  (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)\n  (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) =\n  (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) =\n  (\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P)\n  (\\<forall>s X Y.\n      (s, Y) \\<notin> F P \\<or>\n      \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X Y.\n      (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n      (s, X) \\<in> F P)\n  (\\<forall>s t.\n      s \\<notin> D P \\<or>\n      \\<not> tickFree s \\<or>\n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P) =\n  (\\<forall>s t.\n      s \\<in> D P \\<and>\n      tickFree s \\<and> front_tickFree t \\<longrightarrow>\n      s @ t \\<in> D P)\n  (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) =\n  (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P)\n  (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P) =\n  (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P \\<and>\n    (\\<forall>s X.\n        (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n    (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, Y) \\<notin> F P \\<or>\n        \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s X Y.\n        (s, X) \\<in> F P \\<and>\n        (\\<forall>c.\n            c \\<in> Y \\<longrightarrow>\n            (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n        (s, X \\<union> Y) \\<in> F P) \\<and>\n    (\\<forall>s X.\n        (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n        (s, X - {tick}) \\<in> F P) \\<and>\n    (\\<forall>s t.\n        s \\<notin> D P \\<or>\n        \\<not> tickFree s \\<or>\n        \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n    (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n    (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)", "apply(simp only: a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>s t.\n                 (s @ t, {}) \\<in> F P \\<longrightarrow>\n                 (s, {}) \\<in> F P) =\n             (\\<forall>s t.\n                 (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P);\n     (\\<forall>s X Y.\n         (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n         (s, X) \\<in> F P) =\n     (\\<forall>s X Y.\n         (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n         (s, X) \\<in> F P);\n     (\\<forall>s t.\n         s \\<in> D P \\<and>\n         tickFree s \\<and> front_tickFree t \\<longrightarrow>\n         s @ t \\<in> D P) =\n     (\\<forall>s t.\n         s \\<in> D P \\<and>\n         tickFree s \\<and> front_tickFree t \\<longrightarrow>\n         s @ t \\<in> D P);\n     (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P) =\n     (\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P);\n     (\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P) =\n     (\\<forall>s.\n         s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P)\\<rbrakk>\n    \\<Longrightarrow> ([], {}) \\<in> F P \\<and>\n                      (\\<forall>s X.\n                          (s, X) \\<in> F P \\<longrightarrow>\n                          front_tickFree s) \\<and>\n                      (\\<forall>s t.\n                          (s @ t, {}) \\<in> F P \\<longrightarrow>\n                          (s, {}) \\<in> F P) \\<and>\n                      (\\<forall>s X Y.\n                          (s, Y) \\<in> F P \\<and>\n                          X \\<subseteq> Y \\<longrightarrow>\n                          (s, X) \\<in> F P) \\<and>\n                      (\\<forall>s X Y.\n                          (s, X) \\<in> F P \\<and>\n                          (\\<forall>c.\n                              c \\<in> Y \\<longrightarrow>\n                              (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n                          (s, X \\<union> Y) \\<in> F P) \\<and>\n                      (\\<forall>s X.\n                          (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n                          (s, X - {tick}) \\<in> F P) \\<and>\n                      (\\<forall>s t.\n                          s \\<in> D P \\<and>\n                          tickFree s \\<and>\n                          front_tickFree t \\<longrightarrow>\n                          s @ t \\<in> D P) \\<and>\n                      (\\<forall>s X.\n                          s \\<in> D P \\<longrightarrow>\n                          (s, X) \\<in> F P) \\<and>\n                      (\\<forall>s.\n                          s @ [tick] \\<in> D P \\<longrightarrow>\n                          s \\<in> D P)", "apply(rule is_processT)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ([], {}) \\<in> F P \\<and>\n  (\\<forall>s X. (s, X) \\<in> F P \\<longrightarrow> front_tickFree s) \\<and>\n  (\\<forall>s t. (s @ t, {}) \\<notin> F P \\<or> (s, {}) \\<in> F P) \\<and>\n  (\\<forall>s X Y.\n      (s, Y) \\<notin> F P \\<or>\n      \\<not> X \\<subseteq> Y \\<or> (s, X) \\<in> F P) \\<and>\n  (\\<forall>s X Y.\n      (s, X) \\<in> F P \\<and>\n      (\\<forall>c.\n          c \\<in> Y \\<longrightarrow>\n          (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n      (s, X \\<union> Y) \\<in> F P) \\<and>\n  (\\<forall>s X.\n      (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n      (s, X - {tick}) \\<in> F P) \\<and>\n  (\\<forall>s t.\n      s \\<notin> D P \\<or>\n      \\<not> tickFree s \\<or>\n      \\<not> front_tickFree t \\<or> s @ t \\<in> D P) \\<and>\n  (\\<forall>s X. s \\<notin> D P \\<or> (s, X) \\<in> F P) \\<and>\n  (\\<forall>s. s @ [tick] \\<notin> D P \\<or> s \\<in> D P)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open> split of \\verb+is_processT+: \\<close>"], ["", "lemma is_processT1: \"([],{}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> F P", "by(simp add:process_charn)"], ["", "lemma is_processT2: \"\\<forall>s X. (s, X) \\<in> F P \\<longrightarrow> front_tickFree s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s X. (s, X) \\<in> F P \\<longrightarrow> front_tickFree s", "by(simp add:process_charn)"], ["", "lemma  is_processT2_TR : \"\\<forall>s. s \\<in> T P \\<longrightarrow> front_tickFree s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. s \\<in> T P \\<longrightarrow> front_tickFree s", "apply(simp add: F_def [symmetric] T_def TRACES_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s b. (s, b) \\<in> F P \\<Longrightarrow> front_tickFree s", "apply (drule is_processT2[rule_format], assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_proT2:\n  assumes A : \" (s, X) \\<in> F P\" and B : \" s \\<noteq> []\"\n  shows   \"tick \\<notin> set (tl (rev s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tick \\<notin> set (tl (rev s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tick \\<notin> set (tl (rev s))", "have C: \"front_tickFree s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree s", "by(insert A B, simp add: is_processT2)"], ["proof (state)\nthis:\n  front_tickFree s\n\ngoal (1 subgoal):\n 1. tick \\<notin> set (tl (rev s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tick \\<notin> set (tl (rev s))", "by(insert C,simp add: B  tickFree_def front_tickFree_def)"], ["proof (state)\nthis:\n  tick \\<notin> set (tl (rev s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_processT3 : \"\\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t. (s @ t, {}) \\<in> F P \\<longrightarrow> (s, {}) \\<in> F P", "by(simp only: process_charn  HOL.nnf_simps(3), simp)"], ["", "lemma is_processT3_S_pref : \n\"\\<lbrakk>(t, {}) \\<in> F P; s \\<le> t\\<rbrakk> \\<Longrightarrow> (s, {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(t, {}) \\<in> F P; s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> (s, {}) \\<in> F P", "apply(simp only: le_list_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>(s @ r, {}) \\<in> F P; t = s @ r\\<rbrakk>\n       \\<Longrightarrow> (s, {}) \\<in> F P", "apply(erule is_processT3[rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  is_processT4 : \"\\<forall>s X Y. (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow> (s, X) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s X Y.\n       (s, Y) \\<in> F P \\<and> X \\<subseteq> Y \\<longrightarrow>\n       (s, X) \\<in> F P", "by(insert  process_charn [of P], metis)"], ["", "lemma is_processT4_S1 : \"\\<lbrakk>x \\<in> F P; X \\<subseteq> snd x\\<rbrakk> \\<Longrightarrow> (fst x, X) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> F P; X \\<subseteq> snd x\\<rbrakk>\n    \\<Longrightarrow> (fst x, X) \\<in> F P", "apply(rule_tac Y = \"snd x\" in is_processT4[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> F P; X \\<subseteq> snd x\\<rbrakk>\n    \\<Longrightarrow> (fst x, snd x) \\<in> F P \\<and> X \\<subseteq> snd x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_processT5: \"\\<forall>s X Y.(s,X) \\<in> F P \\<and> (\\<forall>c. c\\<in>Y \\<longrightarrow> (s@[c],{}) \\<notin> F P) \\<longrightarrow> (s,X\\<union>Y)\\<in>F P \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s X Y.\n       (s, X) \\<in> F P \\<and>\n       (\\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {}) \\<notin> F P) \\<longrightarrow>\n       (s, X \\<union> Y) \\<in> F P", "by(simp add: process_charn)"], ["", "lemma is_processT5_S1: \"\\<lbrakk>(s, X) \\<in> F P; (s, X \\<union> Y) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<exists>c. c \\<in> Y \\<and> (s @ [c], {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, X) \\<in> F P; (s, X \\<union> Y) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. c \\<in> Y \\<and> (s @ [c], {}) \\<in> F P", "by(erule contrapos_np, simp add: is_processT5[rule_format])"], ["", "lemma is_processT5_S2: \"\\<lbrakk>(s, X) \\<in> F P; (s @ [c], {}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> (s, X \\<union> {c}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, X) \\<in> F P; (s @ [c], {}) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> (s, X \\<union> {c}) \\<in> F P", "by(rule is_processT5[rule_format,OF conjI], metis, safe)"], ["", "lemma is_processT5_S2a: \"\\<lbrakk>(s, X) \\<in> F P; (s, X \\<union> {c}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, X) \\<in> F P; (s, X \\<union> {c}) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> (s @ [c], {}) \\<in> F P", "apply(erule contrapos_np)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, X) \\<in> F P; (s @ [c], {}) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> (s, X \\<union> {c}) \\<in> F P", "apply(rule is_processT5_S2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(s, X) \\<in> F P; (s @ [c], {}) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> (s, X) \\<in> F P\n 2. \\<lbrakk>(s, X) \\<in> F P; (s @ [c], {}) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> (s @ [c], {}) \\<notin> F P", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  is_processT5_S3:\nassumes A: \"(s, {}) \\<in> F P\"\nand     B: \"(s @ [c], {}) \\<notin> F P\"\nshows      \"(s, {c}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, {c}) \\<in> F P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s, {c}) \\<in> F P", "have C : \" {c} = ({} Un {c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {c} = {} \\<union> {c}", "by simp"], ["proof (state)\nthis:\n  {c} = {} \\<union> {c}\n\ngoal (1 subgoal):\n 1. (s, {c}) \\<in> F P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, {c}) \\<in> F P", "by(subst C, rule is_processT5_S2, simp_all add: A B)"], ["proof (state)\nthis:\n  (s, {c}) \\<in> F P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_processT5_S4: \"\\<lbrakk>(s, {}) \\<in> F P; (s, {c}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, {}) \\<in> F P; (s, {c}) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> (s @ [c], {}) \\<in> F P", "by(erule contrapos_np, simp add: is_processT5_S3)"], ["", "lemma is_processT5_S5:\n\"\\<lbrakk>(s, X) \\<in> F P; \\<forall>c. c \\<in> Y \\<longrightarrow> (s, X \\<union> {c}) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<forall>c. c \\<in> Y \\<longrightarrow> (s @ [c], {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, X) \\<in> F P;\n     \\<forall>c.\n        c \\<in> Y \\<longrightarrow>\n        (s, X \\<union> {c}) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c.\n                         c \\<in> Y \\<longrightarrow> (s @ [c], {}) \\<in> F P", "by(erule_tac Q = \"\\<forall>c. c \\<in> Y \\<longrightarrow> (s, X \\<union> {c}) \\<notin> F P\" in contrapos_pp, metis is_processT5_S2)"], ["", "lemma is_processT5_S6: \"([], {c}) \\<notin> F P \\<Longrightarrow> ([c], {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {c}) \\<notin> F P \\<Longrightarrow> ([c], {}) \\<in> F P", "apply(rule_tac t=\"[c]\" and s=\"[]@[c]\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {c}) \\<notin> F P \\<Longrightarrow> ([] @ [c], {}) \\<in> F P", "apply(rule is_processT5_S4, simp_all add: is_processT1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_processT6: \"\\<forall>s X. (s @ [tick], {}) \\<in> F P \\<longrightarrow> (s, X - {tick}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s X.\n       (s @ [tick], {}) \\<in> F P \\<longrightarrow>\n       (s, X - {tick}) \\<in> F P", "by(simp add: process_charn)"], ["", "lemma is_processT7:  \"\\<forall>s t. s \\<in> D P \\<and> tickFree s \\<and> front_tickFree t \\<longrightarrow> s @ t \\<in> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       s \\<in> D P \\<and>\n       tickFree s \\<and> front_tickFree t \\<longrightarrow>\n       s @ t \\<in> D P", "by(insert process_charn[of P], metis)"], ["", "lemmas is_processT7_S =  is_processT7[rule_format,OF conjI[THEN conjI, THEN  conj_commute[THEN iffD1]]]"], ["", "lemma is_processT8: \"\\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s X. s \\<in> D P \\<longrightarrow> (s, X) \\<in> F P", "by(insert process_charn[of P], metis)"], ["", "lemmas is_processT8_S = is_processT8[rule_format]"], ["", "lemma is_processT8_Pair: \"fst s \\<in> D P \\<Longrightarrow> s \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst s \\<in> D P \\<Longrightarrow> s \\<in> F P", "apply(subst surjective_pairing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst s \\<in> D P \\<Longrightarrow> (fst s, snd s) \\<in> F P", "apply(rule is_processT8_S, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_processT9: \"\\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. s @ [tick] \\<in> D P \\<longrightarrow> s \\<in> D P", "by(insert process_charn[of P], metis)"], ["", "lemma is_processT9_S_swap: \"s \\<notin> D P \\<Longrightarrow> s @ [tick] \\<notin> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> D P \\<Longrightarrow> s @ [tick] \\<notin> D P", "by(erule contrapos_nn,simp add: is_processT9[rule_format])"], ["", "subsection\\<open> Some Consequences of the Process Characterization\\<close>"], ["", "lemma no_Trace_implies_no_Failure: \"s \\<notin> T P \\<Longrightarrow> (s, {}) \\<notin> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> T P \\<Longrightarrow> (s, {}) \\<notin> F P", "by(simp add: T_def TRACES_def F_def)"], ["", "lemmas  NT_NF = no_Trace_implies_no_Failure"], ["", "lemma T_def_spec: \"T P = {tr. \\<exists>a. a \\<in> F P \\<and> tr = fst a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T P = {tr. \\<exists>a. a \\<in> F P \\<and> tr = fst a}", "by(simp add: T_def TRACES_def F_def)"], ["", "lemma F_T: \"(s, X) \\<in> F P \\<Longrightarrow> s \\<in> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, X) \\<in> F P \\<Longrightarrow> s \\<in> T P", "by(simp add: T_def_spec split_def, metis)"], ["", "lemma F_T1: \"a \\<in> F P \\<Longrightarrow> fst a \\<in> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> F P \\<Longrightarrow> fst a \\<in> T P", "by(rule_tac X=\"snd a\" in F_T,simp)"], ["", "lemma T_F: \"s \\<in> T P \\<Longrightarrow> (s, {}) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> T P \\<Longrightarrow> (s, {}) \\<in> F P", "apply(auto simp: T_def_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. (s, b) \\<in> F P \\<Longrightarrow> (s, {}) \\<in> F P", "apply(drule is_processT4_S1, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas is_processT4_empty [elim!]= F_T [THEN T_F]"], ["", "lemma NF_NT: \"(s, {}) \\<notin> F P \\<Longrightarrow> s \\<notin> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, {}) \\<notin> F P \\<Longrightarrow> s \\<notin> T P", "by(erule contrapos_nn, simp only: T_F)"], ["", "lemma  is_processT6_S1: \"\\<lbrakk> tick \\<notin> X;(s @ [tick], {}) \\<in> F P \\<rbrakk> \\<Longrightarrow> (s::'a event list, X) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tick \\<notin> X; (s @ [tick], {}) \\<in> F P\\<rbrakk>\n    \\<Longrightarrow> (s, X) \\<in> F P", "by(subst Diff_triv[of X \"{tick}\", symmetric],\n   simp, erule is_processT6[rule_format])"], ["", "lemmas is_processT3_ST = T_F [THEN is_processT3[rule_format,THEN F_T]]"], ["", "lemmas is_processT3_ST_pref = T_F [THEN is_processT3_S_pref [THEN F_T]]"], ["", "lemmas is_processT3_SR = F_T [THEN T_F [THEN is_processT3[rule_format]]]"], ["", "lemmas D_T = is_processT8_S [THEN F_T]"], ["", "lemma D_T_subset : \"D P \\<subseteq> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D P \\<subseteq> T P", "by(auto intro!:D_T)"], ["", "lemma NF_ND : \"(s, X) \\<notin> F P \\<Longrightarrow> s \\<notin> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, X) \\<notin> F P \\<Longrightarrow> s \\<notin> D P", "by(erule contrapos_nn, simp add: is_processT8_S)"], ["", "lemmas NT_ND = D_T_subset[THEN Set.contra_subsetD]"], ["", "lemma T_F_spec : \"((t, {}) \\<in> F P) = (t \\<in> T P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((t, {}) \\<in> F P) = (t \\<in> T P)", "by(auto simp:T_F F_T)"], ["", "lemma is_processT5_S7:  \" \\<lbrakk>t \\<in> T P; (t, A) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> t @ [x] \\<in> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T P; (t, A) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> t @ [x] \\<in> T P", "apply(erule contrapos_np, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T P;\n     \\<forall>x. x \\<in> A \\<longrightarrow> t @ [x] \\<notin> T P\\<rbrakk>\n    \\<Longrightarrow> (t, A) \\<in> F P", "apply(rule is_processT5[rule_format, OF conjI,of _ \"{}\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<in> T P;\n     \\<forall>x. x \\<in> A \\<longrightarrow> t @ [x] \\<notin> T P\\<rbrakk>\n    \\<Longrightarrow> (t, {}) \\<in> F P\n 2. \\<lbrakk>t \\<in> T P;\n     \\<forall>x. x \\<in> A \\<longrightarrow> t @ [x] \\<notin> T P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c.\n                         c \\<in> A \\<longrightarrow>\n                         (t @ [c], {}) \\<notin> F P", "apply(auto simp: T_F_spec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_processT5_S7': \" \\<lbrakk>(t, X) \\<in> F P; (t, X \\<union> A) \\<notin> F P\\<rbrakk> \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> x \\<notin> X \\<and> t @ [x] \\<in> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(t, X) \\<in> F P; (t, X \\<union> A) \\<notin> F P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> A \\<and>\n                         x \\<notin> X \\<and> t @ [x] \\<in> T P", "apply(erule contrapos_np, simp, subst Un_Diff_cancel[of X A, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(t, X) \\<in> F P;\n     \\<forall>x.\n        x \\<in> A \\<longrightarrow>\n        x \\<in> X \\<or> t @ [x] \\<notin> T P\\<rbrakk>\n    \\<Longrightarrow> (t, X \\<union> (A - X)) \\<in> F P", "apply(rule is_processT5[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(t, X) \\<in> F P;\n     \\<forall>x.\n        x \\<in> A \\<longrightarrow>\n        x \\<in> X \\<or> t @ [x] \\<notin> T P\\<rbrakk>\n    \\<Longrightarrow> (t, X) \\<in> F P \\<and>\n                      (\\<forall>c.\n                          c \\<in> A - X \\<longrightarrow>\n                          (t @ [c], {}) \\<notin> F P)", "apply(auto simp: T_F_spec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Nil_subset_T: \" {[]} \\<subseteq> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {[]} \\<subseteq> T P", "by(auto simp: T_F_spec[symmetric] is_processT1)"], ["", "lemma Nil_elem_T: \"[] \\<in> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> T P", "by(simp add: Nil_subset_T[THEN subsetD])"], ["", "lemmas D_imp_front_tickFree = is_processT8_S[THEN is_processT2[rule_format]]"], ["", "lemma D_front_tickFree_subset : \"D P \\<subseteq> Collect front_tickFree\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D P \\<subseteq> Collect front_tickFree", "by(auto simp: D_imp_front_tickFree)"], ["", "lemma F_D_part : \"F P = {(s, x). s \\<in> D P} \\<union> {(s, x). s \\<notin> D P \\<and> (s, x) \\<in> F P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F P =\n    {(s, x). s \\<in> D P} \\<union>\n    {(s, x). s \\<notin> D P \\<and> (s, x) \\<in> F P}", "by(auto intro:is_processT8_Pair)"], ["", "lemma D_F : \"{(s, x). s \\<in> D P} \\<subseteq> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, x). s \\<in> D P} \\<subseteq> F P", "by(auto intro:is_processT8_Pair)"], ["", "lemma append_T_imp_tickFree:  \"\\<lbrakk>t @ s \\<in> T P; s \\<noteq> []\\<rbrakk> \\<Longrightarrow> tickFree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t @ s \\<in> T P; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> tickFree t", "by(frule is_processT2_TR[rule_format], \n   simp add: front_tickFree_def tickFree_rev)"], ["", "corollary append_single_T_imp_tickFree : \"t @ [a] \\<in> T P \\<Longrightarrow> tickFree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t @ [a] \\<in> T P \\<Longrightarrow> tickFree t", "by (simp add: append_T_imp_tickFree)"], ["", "lemma F_subset_imp_T_subset: \"F P \\<subseteq> F Q \\<Longrightarrow> T P \\<subseteq> T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F P \\<subseteq> F Q \\<Longrightarrow> T P \\<subseteq> T Q", "by(auto simp: subsetD T_F_spec[symmetric])"], ["", "lemma is_processT6_S2: \"\\<lbrakk>tick \\<notin> X; [tick] \\<in> T P\\<rbrakk> \\<Longrightarrow> ([], X) \\<in> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tick \\<notin> X; [tick] \\<in> T P\\<rbrakk>\n    \\<Longrightarrow> ([], X) \\<in> F P", "by(erule is_processT6_S1, simp add: T_F_spec)"], ["", "lemma is_processT9_tick: \"\\<lbrakk>[tick] \\<in> D P; front_tickFree s\\<rbrakk> \\<Longrightarrow> s \\<in> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[tick] \\<in> D P; front_tickFree s\\<rbrakk>\n    \\<Longrightarrow> s \\<in> D P", "apply(rule append.simps(1) [THEN subst, of _ s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[tick] \\<in> D P; front_tickFree s\\<rbrakk>\n    \\<Longrightarrow> [] @ s \\<in> D P", "apply(rule is_processT7_S, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[tick] \\<in> D P; front_tickFree s\\<rbrakk>\n    \\<Longrightarrow> [] \\<in> D P", "apply(rule is_processT9 [rule_format], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma T_nonTickFree_imp_decomp: \"\\<lbrakk>t \\<in> T P; \\<not> tickFree t\\<rbrakk> \\<Longrightarrow> \\<exists>s. t = s @ [tick]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> T P; \\<not> tickFree t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s. t = s @ [tick]", "by(auto elim: is_processT2_TR[rule_format] nonTickFree_n_frontTickFree)"], ["", "subsection\\<open> Process Approximation is a Partial Ordering, a Cpo, and a Pcpo \\<close>"], ["", "text\\<open>The Failure/Divergence Model of CSP Semantics provides two orderings:\nThe \\emph{approximation ordering} (also called \\emph{process ordering})\nwill be used for giving semantics to recursion (fixpoints) over processes,\nthe \\emph{refinement ordering} captures our intuition that a more concrete\nprocess is more deterministic and more defined than an abstract one.\n\nWe start with the key-concepts of the approximation ordering, namely\nthe predicates $min\\_elems$ and $Ra$ (abbreviating \\emph{refusals after}).\nThe former provides just a set of minimal elements from a given set\nof elements of type-class $ord$ \\ldots \\<close>"], ["", "definition min_elems :: \"('s::ord) set \\<Rightarrow> 's set\"\n  where   \"min_elems X = {s \\<in> X. \\<forall>t. t \\<in> X \\<longrightarrow> \\<not> (t < s)}\""], ["", "lemma Nil_min_elems : \"[] \\<in> A \\<Longrightarrow> [] \\<in> min_elems A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> A \\<Longrightarrow> [] \\<in> min_elems A", "by(simp add: min_elems_def)"], ["", "lemma min_elems_le_self[simp] : \"(min_elems A) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_elems A \\<subseteq> A", "by(auto simp: min_elems_def)"], ["", "lemmas elem_min_elems = Set.set_mp[OF min_elems_le_self]"], ["", "lemma min_elems_Collect_ftF_is_Nil : \"min_elems (Collect front_tickFree) = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_elems (Collect front_tickFree) = {[]}", "apply(auto simp: min_elems_def le_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>front_tickFree x;\n        \\<forall>t. front_tickFree t \\<longrightarrow> \\<not> t < x\\<rbrakk>\n       \\<Longrightarrow> x = []", "apply(drule front_tickFree_charn[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>t. front_tickFree t \\<longrightarrow> \\<not> t < x;\n        x = [] \\<or> (\\<exists>a t. x = t @ [a] \\<and> tickFree t)\\<rbrakk>\n       \\<Longrightarrow> x = []", "apply(auto dest!: tickFree_implies_front_tickFree)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_elems5 : \n  assumes A: \"(x::'a list) \\<in> A\"\n  shows      \"\\<exists>s\\<le>x. s \\<in> min_elems A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>x. s \\<in> min_elems A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>x. s \\<in> min_elems A", "have * : \"!! (x::'a list) (A::'a list set) (n::nat).\n                x \\<in> A \\<and> length x \\<le> n \\<longrightarrow> (\\<exists>s\\<le>x. s \\<in> min_elems A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A n.\n       x \\<in> A \\<and> length x \\<le> n \\<longrightarrow>\n       (\\<exists>s\\<le>x. s \\<in> min_elems A)", "apply(rule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A n.\n       \\<forall>x.\n          x \\<in> A \\<and> length x \\<le> n \\<longrightarrow>\n          (\\<exists>s\\<le>x. s \\<in> min_elems A)", "apply(rule_tac n=n in nat_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A n.\n       \\<forall>x.\n          x \\<in> A \\<and> length x \\<le> 0 \\<longrightarrow>\n          (\\<exists>s\\<le>x. s \\<in> min_elems A)\n 2. \\<And>x A n na.\n       \\<forall>x.\n          x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n          (\\<exists>s\\<le>x. s \\<in> min_elems A) \\<Longrightarrow>\n       \\<forall>x.\n          x \\<in> A \\<and> length x \\<le> Suc na \\<longrightarrow>\n          (\\<exists>s\\<le>x. s \\<in> min_elems A)", "(* quirk in induct *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A n.\n       \\<forall>x.\n          x \\<in> A \\<and> length x \\<le> 0 \\<longrightarrow>\n          (\\<exists>s\\<le>x. s \\<in> min_elems A)\n 2. \\<And>x A n na.\n       \\<forall>x.\n          x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n          (\\<exists>s\\<le>x. s \\<in> min_elems A) \\<Longrightarrow>\n       \\<forall>x.\n          x \\<in> A \\<and> length x \\<le> Suc na \\<longrightarrow>\n          (\\<exists>s\\<le>x. s \\<in> min_elems A)", "apply(auto simp: Nil_min_elems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A na x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n                   (\\<exists>s\\<le>x. s \\<in> min_elems A);\n        x \\<in> A; length x \\<le> Suc na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A", "apply(case_tac \"\\<exists> y.  y \\<in> A \\<and> y < x\",auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A na x y.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n                   (\\<exists>s\\<le>x. s \\<in> min_elems A);\n        x \\<in> A; length x \\<le> Suc na; y \\<in> A; y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A\n 2. \\<And>A na x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n                   (\\<exists>s\\<le>x. s \\<in> min_elems A);\n        x \\<in> A; length x \\<le> Suc na;\n        \\<forall>y. y \\<in> A \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A", "apply(rename_tac A na x y, erule_tac x=y in allE, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A na x y.\n       \\<lbrakk>x \\<in> A; length x \\<le> Suc na; y \\<in> A; y < x;\n        length y \\<le> na \\<longrightarrow>\n        (\\<exists>s\\<le>y. s \\<in> min_elems A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A\n 2. \\<And>A na x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n                   (\\<exists>s\\<le>x. s \\<in> min_elems A);\n        x \\<in> A; length x \\<le> Suc na;\n        \\<forall>y. y \\<in> A \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A", "apply(erule impE,drule less_length_mono, arith)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A na x y.\n       \\<lbrakk>x \\<in> A; length x \\<le> Suc na; y \\<in> A; y < x;\n        \\<exists>s\\<le>y. s \\<in> min_elems A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A\n 2. \\<And>A na x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n                   (\\<exists>s\\<le>x. s \\<in> min_elems A);\n        x \\<in> A; length x \\<le> Suc na;\n        \\<forall>y. y \\<in> A \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A", "apply(safe, rename_tac s, rule_tac x=s in exI,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A na x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<and> length x \\<le> na \\<longrightarrow>\n                   (\\<exists>s\\<le>x. s \\<in> min_elems A);\n        x \\<in> A; length x \\<le> Suc na;\n        \\<forall>y. y \\<in> A \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>x. s \\<in> min_elems A", "apply(rule_tac x=x in exI, simp add:min_elems_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> ?A \\<and> length ?x \\<le> ?n \\<longrightarrow>\n  (\\<exists>s\\<le>?x. s \\<in> min_elems ?A)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>x. s \\<in> min_elems A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>x. s \\<in> min_elems A", "by(rule_tac n=\"length x\" in *[rule_format],simp add:A)"], ["proof (state)\nthis:\n  \\<exists>s\\<le>x. s \\<in> min_elems A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_elems4: \"A \\<noteq> {} \\<Longrightarrow> \\<exists>s. (s :: 'a trace) \\<in> min_elems A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> \\<exists>s. s \\<in> min_elems A", "by(auto dest: min_elems5)"], ["", "lemma min_elems_charn: \"t \\<in> A \\<Longrightarrow> \\<exists> t' r. t = (t' @ r) \\<and> t' \\<in> min_elems A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> A \\<Longrightarrow>\n    \\<exists>t' r. t = t' @ r \\<and> t' \\<in> min_elems A", "by(drule min_elems5[simplified le_list_def], auto)"], ["", "lemmas min_elems_ex = min_elems_charn"], ["", "(* Legacy *)"], ["", "lemma min_elems_no: \"(x::'a list) \\<in> min_elems A \\<Longrightarrow> t \\<in> A \\<Longrightarrow> t \\<le> x \\<Longrightarrow> x = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> min_elems A; t \\<in> A; t \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x = t", "by (metis (no_types, lifting) less_list_def mem_Collect_eq min_elems_def)"], ["", "text\\<open> \\ldots while the second returns the set of possible\nrefusal sets after a given trace $s$ and a given process\n$P$: \\<close>"], ["", "definition Ra :: \"['\\<alpha> process, '\\<alpha> trace] \\<Rightarrow> ('\\<alpha> refusal set)\"\n  where   \"Ra P s = {X. (s, X) \\<in> F P}\""], ["", "text\\<open> In the following, we link the process theory to the underlying \nfixpoint/domain theory of HOLCF by identifying the approximation ordering \nwith HOLCF's pcpo's. \\<close>"], ["", "instantiation \n   process  ::  (\"type\") below     \nbegin"], ["", "text\\<open> declares approximation ordering $\\_ \\sqsubseteq \\_$ also written \n        \\verb+_ << _+. \\<close>"], ["", "definition le_approx_def : \"P \\<sqsubseteq> Q \\<equiv> D Q \\<subseteq> D P \\<and>\n                                    (\\<forall>s. s \\<notin> D P \\<longrightarrow> Ra P s = Ra Q s) \\<and> \n                                     min_elems (D P) \\<subseteq> T Q\""], ["", "text\\<open> The approximation ordering captures the fact that more concrete\nprocesses should be more defined by ordering the divergence sets\nappropriately. For defined positions in a process, the failure\nsets must coincide pointwise; moreover, the minimal elements\n(wrt.~prefix ordering on traces, i.e.~lists) must be contained in\nthe trace set of the more concrete process.\\<close>"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a process, below_class)", ".."], ["", "end"], ["", "lemma le_approx1: \"P\\<sqsubseteq>Q \\<Longrightarrow> D Q \\<subseteq> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow> D Q \\<subseteq> D P", "by(simp add: le_approx_def)"], ["", "lemma le_approx2: \"\\<lbrakk> P\\<sqsubseteq>Q; s \\<notin> D P\\<rbrakk> \\<Longrightarrow> (s,X) \\<in> F Q = ((s,X) \\<in> F P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq> Q; s \\<notin> D P\\<rbrakk>\n    \\<Longrightarrow> ((s, X) \\<in> F Q) = ((s, X) \\<in> F P)", "by(auto simp: Ra_def le_approx_def)"], ["", "lemma le_approx3: \"P \\<sqsubseteq> Q \\<Longrightarrow> min_elems(D P) \\<subseteq> T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow> min_elems (D P) \\<subseteq> T Q", "by(simp add: le_approx_def)"], ["", "lemma le_approx2T: \"\\<lbrakk> P\\<sqsubseteq>Q; s \\<notin> D P\\<rbrakk> \\<Longrightarrow>  s \\<in> T Q = (s \\<in> T P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq> Q; s \\<notin> D P\\<rbrakk>\n    \\<Longrightarrow> (s \\<in> T Q) = (s \\<in> T P)", "by(auto simp: le_approx2 T_F_spec[symmetric])"], ["", "lemma le_approx_lemma_F : \"P\\<sqsubseteq>Q \\<Longrightarrow> F Q \\<subseteq> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow> F Q \\<subseteq> F P", "apply(subst F_D_part[of Q], subst F_D_part[of P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow>\n    {(s, x). s \\<in> D Q} \\<union>\n    {(s, x). s \\<notin> D Q \\<and> (s, x) \\<in> F Q}\n    \\<subseteq> {(s, x). s \\<in> D P} \\<union>\n                {(s, x). s \\<notin> D P \\<and> (s, x) \\<in> F P}", "apply(auto simp:le_approx_def Ra_def min_elems_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas order_lemma = le_approx_lemma_F"], ["", "lemma le_approx_lemma_T: \"P\\<sqsubseteq>Q \\<Longrightarrow> T Q \\<subseteq> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow> T Q \\<subseteq> T P", "by(auto dest!:le_approx_lemma_F simp: T_F_spec[symmetric])"], ["", "lemma proc_ord2a :  \"\\<lbrakk>P \\<sqsubseteq> Q; s \\<notin> D P\\<rbrakk> \\<Longrightarrow> ((s, X) \\<in> F P) = ((s, X) \\<in> F Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq> Q; s \\<notin> D P\\<rbrakk>\n    \\<Longrightarrow> ((s, X) \\<in> F P) = ((s, X) \\<in> F Q)", "by(auto simp: le_approx_def Ra_def)"], ["", "instance\n   process :: (\"type\") po"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a process, po_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix P::\"'\\<alpha> process\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"P \\<sqsubseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> P", "by(auto simp: le_approx_def min_elems_def elim: Process.D_T)"], ["proof (state)\nthis:\n  P \\<sqsubseteq> P\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix P Q ::\"'\\<alpha> process\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume A:\"P \\<sqsubseteq> Q\" and B:\"Q \\<sqsubseteq> P\""], ["proof (state)\nthis:\n  P \\<sqsubseteq> Q\n  Q \\<sqsubseteq> P\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"P = Q\""], ["proof (prove)\nusing this:\n  P \\<sqsubseteq> Q\n  Q \\<sqsubseteq> P\n\ngoal (1 subgoal):\n 1. P = Q", "apply(insert A[THEN le_approx1] B[THEN le_approx1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D Q \\<subseteq> D P; D P \\<subseteq> D Q\\<rbrakk>\n    \\<Longrightarrow> P = Q", "apply(insert A[THEN le_approx_lemma_F] B[THEN le_approx_lemma_F])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D Q \\<subseteq> D P; D P \\<subseteq> D Q; F Q \\<subseteq> F P;\n     F P \\<subseteq> F Q\\<rbrakk>\n    \\<Longrightarrow> P = Q", "by(auto simp: Process_eq_spec)"], ["proof (state)\nthis:\n  P = Q\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z", "fix P Q R ::\"'\\<alpha> process\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z", "assume A: \"P \\<sqsubseteq> Q\" and B: \"Q \\<sqsubseteq> R\""], ["proof (state)\nthis:\n  P \\<sqsubseteq> Q\n  Q \\<sqsubseteq> R\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z", "thus \"P \\<sqsubseteq> R\""], ["proof (prove)\nusing this:\n  P \\<sqsubseteq> Q\n  Q \\<sqsubseteq> R\n\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq> Q; Q \\<sqsubseteq> R\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> R", "have C : \"D R \\<subseteq> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D R \\<subseteq> D P", "by(insert A[THEN le_approx1] B[THEN le_approx1], auto)"], ["proof (state)\nthis:\n  D R \\<subseteq> D P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq> Q; Q \\<sqsubseteq> R\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> R", "have D : \"\\<forall> s. s \\<notin> D P \\<longrightarrow> {X. (s, X) \\<in> F P} = {X. (s, X) \\<in>  F R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<notin> D P \\<longrightarrow>\n       {X. (s, X) \\<in> F P} = {X. (s, X) \\<in> F R}", "apply(rule allI, rule impI, rule set_eqI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x.\n       s \\<notin> D P \\<Longrightarrow>\n       ((s, x) \\<in> F P) = ((s, x) \\<in> F R)", "apply(frule A[THEN le_approx1, THEN Set.contra_subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x.\n       \\<lbrakk>s \\<notin> D P; s \\<notin> D Q\\<rbrakk>\n       \\<Longrightarrow> ((s, x) \\<in> F P) = ((s, x) \\<in> F R)", "apply(frule B[THEN le_approx1, THEN Set.contra_subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x.\n       \\<lbrakk>s \\<notin> D P; s \\<notin> D Q; s \\<notin> D R\\<rbrakk>\n       \\<Longrightarrow> ((s, x) \\<in> F P) = ((s, x) \\<in> F R)", "apply(drule A[THEN le_approx2], drule B[THEN le_approx2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x.\n       \\<lbrakk>s \\<notin> D R;\n        ((s, ?X10 s x) \\<in> F Q) = ((s, ?X10 s x) \\<in> F P);\n        ((s, ?X12 s x) \\<in> F R) = ((s, ?X12 s x) \\<in> F Q)\\<rbrakk>\n       \\<Longrightarrow> ((s, x) \\<in> F P) = ((s, x) \\<in> F R)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>s.\n     s \\<notin> D P \\<longrightarrow>\n     {X. (s, X) \\<in> F P} = {X. (s, X) \\<in> F R}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq> Q; Q \\<sqsubseteq> R\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> R", "have E : \"min_elems (D P) \\<subseteq> T R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_elems (D P) \\<subseteq> T R", "apply(insert B[THEN le_approx3] A[THEN le_approx3] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min_elems (D Q) \\<subseteq> T R;\n     min_elems (D P) \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> min_elems (D P) \\<subseteq> T R", "apply(insert B[THEN le_approx_lemma_T] A[THEN le_approx1] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min_elems (D Q) \\<subseteq> T R;\n     min_elems (D P) \\<subseteq> T Q; T R \\<subseteq> T Q;\n     D Q \\<subseteq> D P\\<rbrakk>\n    \\<Longrightarrow> min_elems (D P) \\<subseteq> T R", "apply(rule subsetI, simp add: min_elems_def, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>{s \\<in> D Q.\n                 \\<forall>t. t \\<in> D Q \\<longrightarrow> \\<not> t < s}\n                \\<subseteq> T R;\n        {s \\<in> D P.\n         \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s}\n        \\<subseteq> T Q;\n        T R \\<subseteq> T Q; D Q \\<subseteq> D P; x \\<in> D P;\n        \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T R", "apply(rename_tac x, case_tac \"x \\<in> D Q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>{s \\<in> D Q.\n                 \\<forall>t. t \\<in> D Q \\<longrightarrow> \\<not> t < s}\n                \\<subseteq> T R;\n        {s \\<in> D P.\n         \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s}\n        \\<subseteq> T Q;\n        T R \\<subseteq> T Q; D Q \\<subseteq> D P; x \\<in> D P;\n        \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < x;\n        x \\<in> D Q\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T R\n 2. \\<And>x.\n       \\<lbrakk>{s \\<in> D Q.\n                 \\<forall>t. t \\<in> D Q \\<longrightarrow> \\<not> t < s}\n                \\<subseteq> T R;\n        {s \\<in> D P.\n         \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s}\n        \\<subseteq> T Q;\n        T R \\<subseteq> T Q; D Q \\<subseteq> D P; x \\<in> D P;\n        \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < x;\n        x \\<notin> D Q\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T R", "apply(drule_tac B = \"T R\" and t=x \n                     in subset_iff[THEN iffD1,rule_format], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>{s \\<in> D Q.\n                 \\<forall>t. t \\<in> D Q \\<longrightarrow> \\<not> t < s}\n                \\<subseteq> T R;\n        {s \\<in> D P.\n         \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s}\n        \\<subseteq> T Q;\n        T R \\<subseteq> T Q; D Q \\<subseteq> D P; x \\<in> D P;\n        \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < x;\n        x \\<notin> D Q\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T R", "apply(subst B [THEN le_approx2T],simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>{s \\<in> D Q.\n                 \\<forall>t. t \\<in> D Q \\<longrightarrow> \\<not> t < s}\n                \\<subseteq> T R;\n        {s \\<in> D P.\n         \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s}\n        \\<subseteq> T Q;\n        T R \\<subseteq> T Q; D Q \\<subseteq> D P; x \\<in> D P;\n        \\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < x;\n        x \\<notin> D Q\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T Q", "apply(rename_tac x, drule_tac B = \"T Q\" and t=x \n                     in subset_iff[THEN iffD1,rule_format],auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  min_elems (D P) \\<subseteq> T R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<sqsubseteq> Q; Q \\<sqsubseteq> R\\<rbrakk>\n    \\<Longrightarrow> P \\<sqsubseteq> R", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> R", "by(insert C D E, simp add: le_approx_def Ra_def)"], ["proof (state)\nthis:\n  P \\<sqsubseteq> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<sqsubseteq> R\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open> At this point, we inherit quite a number of facts from the underlying\nHOLCF theory, which comprises a library of facts such as \\verb+chain+,\n\\verb+directed+(sets), upper bounds and least upper bounds, etc. \\<close>"], ["", "text\\<open>\nSome facts from the theory of complete partial orders:\n\\begin{itemize}\n\\item \\verb+Porder.chainE+ : @{thm \"Porder.chainE\"}\n\\item \\verb+Porder.chain_mono+ : @{thm \"Porder.chain_mono\"}\n\\item \\verb+Porder.is_ubD+ : @{thm \"Porder.is_ubD\"}\n\\item \\verb+Porder.ub_rangeI+ : \\\\ @{thm \"Porder.ub_rangeI\"}\n\\item \\verb+Porder.ub_imageD+ : @{thm \"Porder.ub_imageD\"}\n\\item \\verb+Porder.is_ub_upward+ : @{thm \"Porder.is_ub_upward\"}\n\\item \\verb+Porder.is_lubD1+ : @{thm \"Porder.is_lubD1\"}\n\\item \\verb+Porder.is_lubI+ : @{thm \"Porder.is_lubI\"}\n\\item \\verb+Porder.is_lub_maximal+ : @{thm \"Porder.is_lub_maximal\"}\n\\item \\verb+Porder.is_lub_lub+ : @{thm \"Porder.is_lub_lub\"}\n\\item \\verb+Porder.is_lub_range_shift+: \\\\ @{thm \"Porder.is_lub_range_shift\"}\n\\item \\verb+Porder.is_lub_rangeD1+: @{thm \"Porder.is_lub_rangeD1\"}\n\\item \\verb+Porder.lub_eqI+: @{thm \"Porder.lub_eqI\"}\n\\item \\verb+Porder.is_lub_unique+:@{thm \"Porder.is_lub_unique\"}\n\\end{itemize}\n\\<close>"], ["", "definition lim_proc :: \"('\\<alpha> process) set \\<Rightarrow> '\\<alpha> process\"\n  where   \"lim_proc (X) = Abs_process (\\<Inter> (F ` X), \\<Inter> (D ` X))\""], ["", "lemma min_elems3: \"\\<lbrakk>s @ [c] \\<in> D P; s @ [c] \\<notin> min_elems (D P)\\<rbrakk> \\<Longrightarrow> s \\<in> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s @ [c] \\<in> D P; s @ [c] \\<notin> min_elems (D P)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> D P", "apply(auto simp: min_elems_def le_list_def less_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]\\<rbrakk>\n       \\<Longrightarrow> s \\<in> D P", "apply(rename_tac t r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]\\<rbrakk>\n       \\<Longrightarrow> s \\<in> D P", "apply(subgoal_tac \"t \\<le> s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]; t \\<le> s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> D P\n 2. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]\\<rbrakk>\n       \\<Longrightarrow> t \\<le> s", "apply(subgoal_tac \"r \\<noteq> []\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]; t \\<le> s; r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> s \\<in> D P\n 2. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]; t \\<le> s\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> []\n 3. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]\\<rbrakk>\n       \\<Longrightarrow> t \\<le> s", "apply(simp add: le_list_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]; \\<exists>r. t @ r = s; r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> s \\<in> D P\n 2. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]; t \\<le> s\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> []\n 3. \\<And>t r.\n       \\<lbrakk>s @ [c] \\<in> D P; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]\\<rbrakk>\n       \\<Longrightarrow> t \\<le> s", "apply(auto intro!: is_processT7_S append_eq_first_pref_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t ra.\n       \\<lbrakk>t @ ra @ [c] \\<in> D P; t \\<in> D P; s = t @ ra\\<rbrakk>\n       \\<Longrightarrow> tickFree t\n 2. \\<And>t ra.\n       \\<lbrakk>t @ ra @ [c] \\<in> D P; t \\<in> D P; s = t @ ra\\<rbrakk>\n       \\<Longrightarrow> front_tickFree ra", "apply(auto dest!: D_T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t ra.\n       \\<lbrakk>s = t @ ra; t @ ra @ [c] \\<in> T P; t \\<in> T P\\<rbrakk>\n       \\<Longrightarrow> tickFree t\n 2. \\<And>t ra.\n       \\<lbrakk>s = t @ ra; t @ ra @ [c] \\<in> T P; t \\<in> T P\\<rbrakk>\n       \\<Longrightarrow> front_tickFree ra", "apply(simp_all only: append_assoc[symmetric],\n      drule append_T_imp_tickFree,\n      simp_all add: tickFree_implies_front_tickFree)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_elems1: \"\\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P\\<rbrakk> \\<Longrightarrow> s @ [c] \\<in> min_elems (D P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P\\<rbrakk>\n    \\<Longrightarrow> s @ [c] \\<in> min_elems (D P)", "by(erule contrapos_np, auto elim!: min_elems3)"], ["", "lemma min_elems2: \"\\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S; Q \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S\\<rbrakk>\n    \\<Longrightarrow> (s @ [c], {}) \\<in> F Q", "apply(frule_tac P=Q and Q=S in le_approx_lemma_T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S; T S \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> (s @ [c], {}) \\<in> F Q", "apply(simp add: T_F_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S; T S \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> s @ [c] \\<in> T Q", "apply(rule_tac A=\"T S\" in subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S; T S \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> s @ [c] \\<in> T S", "apply(rule_tac A=\"min_elems(D P)\" in subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S; T S \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> min_elems (D P) \\<subseteq> T S\n 2. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S; T S \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> s @ [c] \\<in> min_elems (D P)", "apply(simp_all add: le_approx_def min_elems1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_elems6: \"\\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> (s @ [c], {}) \\<in> F S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s @ [c] \\<in> D P; P \\<sqsubseteq> S\\<rbrakk>\n    \\<Longrightarrow> (s @ [c], {}) \\<in> F S", "by(auto intro!: min_elems2)"], ["", "lemma ND_F_dir2: \"\\<lbrakk>s \\<notin> D P; (s, {}) \\<in> F P; P \\<sqsubseteq> S; Q \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> (s, {}) \\<in> F Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; (s, {}) \\<in> F P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S\\<rbrakk>\n    \\<Longrightarrow> (s, {}) \\<in> F Q", "apply(frule_tac P=Q and Q=S in le_approx_lemma_T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; (s, {}) \\<in> F P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S; T S \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> (s, {}) \\<in> F Q", "apply(simp add: le_approx_def Ra_def T_F_spec, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s \\<in> T P; T S \\<subseteq> T Q;\n     D S \\<subseteq> D P; D S \\<subseteq> D Q;\n     \\<forall>s.\n        s \\<notin> D P \\<longrightarrow>\n        {X. (s, X) \\<in> F P} = {X. (s, X) \\<in> F S};\n     min_elems (D P) \\<subseteq> T S;\n     \\<forall>s.\n        s \\<notin> D Q \\<longrightarrow>\n        {X. (s, X) \\<in> F Q} = {X. (s, X) \\<in> F S};\n     min_elems (D Q) \\<subseteq> T S\\<rbrakk>\n    \\<Longrightarrow> s \\<in> T Q", "apply((erule_tac x=s in allE)+,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s \\<in> T P; T S \\<subseteq> T Q;\n     D S \\<subseteq> D P; D S \\<subseteq> D Q;\n     min_elems (D P) \\<subseteq> T S; min_elems (D Q) \\<subseteq> T S;\n     {X. (s, X) \\<in> F P} = {X. (s, X) \\<in> F S};\n     s \\<notin> D Q \\<longrightarrow>\n     {X. (s, X) \\<in> F Q} = {X. (s, X) \\<in> F S}\\<rbrakk>\n    \\<Longrightarrow> s \\<in> T Q", "apply(drule_tac x=\"{}\" in eqset_imp_iff, auto simp: T_F_spec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done \\<comment>\\<open>orig version\\<close>"], ["", "lemma ND_F_dir2': \"\\<lbrakk>s \\<notin> D P; s \\<in> T P; P \\<sqsubseteq> S; Q \\<sqsubseteq> S\\<rbrakk> \\<Longrightarrow> s \\<in> T Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s \\<in> T P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S\\<rbrakk>\n    \\<Longrightarrow> s \\<in> T Q", "apply(frule_tac P=Q and Q=S in le_approx_lemma_T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s \\<in> T P; P \\<sqsubseteq> S;\n     Q \\<sqsubseteq> S; T S \\<subseteq> T Q\\<rbrakk>\n    \\<Longrightarrow> s \\<in> T Q", "apply(simp add: le_approx_def Ra_def T_F_spec, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s \\<in> T P; T S \\<subseteq> T Q;\n     D S \\<subseteq> D P; D S \\<subseteq> D Q;\n     \\<forall>s.\n        s \\<notin> D P \\<longrightarrow>\n        {X. (s, X) \\<in> F P} = {X. (s, X) \\<in> F S};\n     min_elems (D P) \\<subseteq> T S;\n     \\<forall>s.\n        s \\<notin> D Q \\<longrightarrow>\n        {X. (s, X) \\<in> F Q} = {X. (s, X) \\<in> F S};\n     min_elems (D Q) \\<subseteq> T S\\<rbrakk>\n    \\<Longrightarrow> s \\<in> T Q", "apply((erule_tac x=s in allE)+,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<notin> D P; s \\<in> T P; T S \\<subseteq> T Q;\n     D S \\<subseteq> D P; D S \\<subseteq> D Q;\n     min_elems (D P) \\<subseteq> T S; min_elems (D Q) \\<subseteq> T S;\n     {X. (s, X) \\<in> F P} = {X. (s, X) \\<in> F S};\n     s \\<notin> D Q \\<longrightarrow>\n     {X. (s, X) \\<in> F Q} = {X. (s, X) \\<in> F S}\\<rbrakk>\n    \\<Longrightarrow> s \\<in> T Q", "apply(drule_tac x=\"{}\" in eqset_imp_iff, auto simp: T_F_spec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chain_lemma: \"\\<lbrakk>chain S\\<rbrakk> \\<Longrightarrow> S i \\<sqsubseteq> S k \\<or> S k \\<sqsubseteq> S i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    S i \\<sqsubseteq> S k \\<or> S k \\<sqsubseteq> S i", "by(case_tac \"i \\<le> k\", auto intro:chain_mono chain_mono_less)"], ["", "lemma is_process_REP_LUB: \n  assumes chain: \"chain S\"\n  shows \"is_process (\\<Inter> (F ` range S), \\<Inter> (D ` range S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process (\\<Inter> (F ` range S), \\<Inter> (D ` range S))", "proof (auto simp: is_process_def)"], ["proof (state)\ngoal (9 subgoals):\n 1. ([], {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       (s, X)\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       front_tickFree s\n 3. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 8. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 9. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "show   \"([], {}) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "by(auto simp: FAILURES_def is_processT)"], ["proof (state)\nthis:\n  ([], {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (8 subgoals):\n 1. \\<And>s X.\n       (s, X)\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       front_tickFree s\n 2. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 8. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s X.\n       (s, X)\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       front_tickFree s\n 2. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 8. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s::\"'a trace\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s X.\n       (s, X)\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       front_tickFree s\n 2. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 8. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix X::\"'a event set\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s X.\n       (s, X)\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       front_tickFree s\n 2. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 8. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume A : \"(s, X) \\<in> (FAILURES (\\<Inter> a :: nat. F (S a), \\<Inter> a :: nat. D (S a)))\""], ["proof (state)\nthis:\n  (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (8 subgoals):\n 1. \\<And>s X.\n       (s, X)\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       front_tickFree s\n 2. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 8. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus   \"front_tickFree s\""], ["proof (prove)\nusing this:\n  (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. front_tickFree s", "by(auto simp:   DIVERGENCES_def FAILURES_def\n                  intro!: is_processT2[rule_format])"], ["proof (state)\nthis:\n  front_tickFree s\n\ngoal (7 subgoals):\n 1. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s  t::\"'a trace\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume \" (s @ t, {}) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a)) \""], ["proof (state)\nthis:\n  (s @ t, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (7 subgoals):\n 1. \\<And>s t.\n       (s @ t, {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 7. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus \"(s, {}) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\nusing this:\n  (s @ t, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "by(auto simp:  DIVERGENCES_def FAILURES_def\n                  intro: is_processT3[rule_format])"], ["proof (state)\nthis:\n  (s, {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (6 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s::\"'a trace\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix X Y ::\"'a event set\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume \"(s, Y) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\" and \"X \\<subseteq> Y\""], ["proof (state)\nthis:\n  (s, Y) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n  X \\<subseteq> Y\n\ngoal (6 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, Y)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (s, X)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 6. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus   \"(s, X) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\nusing this:\n  (s, Y) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n  X \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "by(auto simp:  DIVERGENCES_def FAILURES_def\n                  intro: is_processT4[rule_format])"], ["proof (state)\nthis:\n  (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (5 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s::\"'a trace\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix X Y ::\" 'a event set\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume A:\"(s, X) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (state)\nthis:\n  (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (5 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume B:\"\\<forall> c. c\\<in>Y \\<longrightarrow> (s@[c],{})\\<notin>FAILURES(\\<Inter> a::nat. F(S a),\\<Inter> a::nat. D(S a))\""], ["proof (state)\nthis:\n  \\<forall>c.\n     c \\<in> Y \\<longrightarrow>\n     (s @ [c], {})\n     \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (5 subgoals):\n 1. \\<And>s X Y.\n       \\<lbrakk>(s, X)\n                \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES\n                     (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y)\n                         \\<in> FAILURES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 5. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus   \"(s, X \\<union> Y) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c \\<in> Y \\<longrightarrow>\n     (s @ [c], {})\n     \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. (s, X \\<union> Y)\n    \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "txt\\<open> What does this mean: All trace prolongations $c$ in all $Y$, \n         which are blocking in the limit, will also occur in the refusal set \n         of the limit. \\<close>"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c \\<in> Y \\<longrightarrow>\n     (s @ [c], {})\n     \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. (s, X \\<union> Y)\n    \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "using A B chain"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c \\<in> Y \\<longrightarrow>\n     (s @ [c], {})\n     \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n  (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n  \\<forall>c.\n     c \\<in> Y \\<longrightarrow>\n     (s @ [c], {})\n     \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n  chain S\n\ngoal (1 subgoal):\n 1. (s, X \\<union> Y)\n    \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "proof (auto simp: DIVERGENCES_def FAILURES_def,\n          case_tac \"\\<forall> x. x \\<in> (range S) \\<longrightarrow> (s, X \\<union> Y) \\<in> F x\",\n          simp_all add:DIVERGENCES_def FAILURES_def,rename_tac a,\n          case_tac \"s \\<notin> D (S a)\",simp_all add: is_processT8)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>c.\n                   c \\<in> Y \\<longrightarrow>\n                   (\\<exists>x. (s @ [c], {}) \\<notin> F (S x));\n        \\<forall>x. (s, X) \\<in> F (S x);\n        \\<exists>x. (s, X \\<union> Y) \\<notin> F (S x); s \\<notin> D (S a);\n        (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        chain S\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y) \\<in> F (S a)", "fix a::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>c.\n                   c \\<in> Y \\<longrightarrow>\n                   (\\<exists>x. (s @ [c], {}) \\<notin> F (S x));\n        \\<forall>x. (s, X) \\<in> F (S x);\n        \\<exists>x. (s, X \\<union> Y) \\<notin> F (S x); s \\<notin> D (S a);\n        (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        chain S\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y) \\<in> F (S a)", "assume X: \"\\<forall>a. (s, X) \\<in> F (S a)\""], ["proof (state)\nthis:\n  \\<forall>a. (s, X) \\<in> F (S a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>c.\n                   c \\<in> Y \\<longrightarrow>\n                   (\\<exists>x. (s @ [c], {}) \\<notin> F (S x));\n        \\<forall>x. (s, X) \\<in> F (S x);\n        \\<exists>x. (s, X \\<union> Y) \\<notin> F (S x); s \\<notin> D (S a);\n        (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        chain S\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y) \\<in> F (S a)", "have X_ref_at_a: \"(s, X) \\<in> F (S a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, X) \\<in> F (S a)", "using X"], ["proof (prove)\nusing this:\n  \\<forall>a. (s, X) \\<in> F (S a)\n\ngoal (1 subgoal):\n 1. (s, X) \\<in> F (S a)", "by auto"], ["proof (state)\nthis:\n  (s, X) \\<in> F (S a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>c.\n                   c \\<in> Y \\<longrightarrow>\n                   (\\<exists>x. (s @ [c], {}) \\<notin> F (S x));\n        \\<forall>x. (s, X) \\<in> F (S x);\n        \\<exists>x. (s, X \\<union> Y) \\<notin> F (S x); s \\<notin> D (S a);\n        (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        chain S\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y) \\<in> F (S a)", "assume Y: \"\\<forall>c. c \\<in> Y \\<longrightarrow> (\\<exists>a. (s @ [c], {}) \\<notin> F (S a))\""], ["proof (state)\nthis:\n  \\<forall>c.\n     c \\<in> Y \\<longrightarrow>\n     (\\<exists>a. (s @ [c], {}) \\<notin> F (S a))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>c.\n                   c \\<in> Y \\<longrightarrow>\n                   (\\<exists>x. (s @ [c], {}) \\<notin> F (S x));\n        \\<forall>x. (s, X) \\<in> F (S x);\n        \\<exists>x. (s, X \\<union> Y) \\<notin> F (S x); s \\<notin> D (S a);\n        (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        chain S\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y) \\<in> F (S a)", "assume defined: \"s \\<notin> D (S a)\""], ["proof (state)\nthis:\n  s \\<notin> D (S a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>c.\n                   c \\<in> Y \\<longrightarrow>\n                   (\\<exists>x. (s @ [c], {}) \\<notin> F (S x));\n        \\<forall>x. (s, X) \\<in> F (S x);\n        \\<exists>x. (s, X \\<union> Y) \\<notin> F (S x); s \\<notin> D (S a);\n        (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        \\<forall>c.\n           c \\<in> Y \\<longrightarrow>\n           (s @ [c], {})\n           \\<notin> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        chain S\\<rbrakk>\n       \\<Longrightarrow> (s, X \\<union> Y) \\<in> F (S a)", "show   \"(s::'a trace, X \\<union> Y) \\<in> F (S a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, X \\<union> Y) \\<in> F (S a)", "proof(auto simp:X_ref_at_a\n                 intro!: is_processT5[rule_format],\n            frule Y[THEN spec, THEN mp], erule exE,\n            erule_tac Q=\"(s @ [c], {}) \\<in> F (S a)\" in contrapos_pp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c aa.\n       \\<lbrakk>c \\<in> Y; (s @ [c], {}) \\<notin> F (S aa);\n        \\<not> False\\<rbrakk>\n       \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "fix c::\"'a event\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c aa.\n       \\<lbrakk>c \\<in> Y; (s @ [c], {}) \\<notin> F (S aa);\n        \\<not> False\\<rbrakk>\n       \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "fix a' :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c aa.\n       \\<lbrakk>c \\<in> Y; (s @ [c], {}) \\<notin> F (S aa);\n        \\<not> False\\<rbrakk>\n       \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "assume s_c_trace_not_trace_somewhere: \"(s @ [c], {}) \\<notin> F (S a')\""], ["proof (state)\nthis:\n  (s @ [c], {}) \\<notin> F (S a')\n\ngoal (1 subgoal):\n 1. \\<And>c aa.\n       \\<lbrakk>c \\<in> Y; (s @ [c], {}) \\<notin> F (S aa);\n        \\<not> False\\<rbrakk>\n       \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "show \"(s @ [c], {}) \\<notin> F (S a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s @ [c], {}) \\<notin> F (S a)", "proof(insert chain_lemma[OF chain, of \"a\" \"a'\"],erule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. S a \\<sqsubseteq> S a' \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)\n 2. S a' \\<sqsubseteq> S a \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "assume before: \"S a \\<sqsubseteq> S a'\""], ["proof (state)\nthis:\n  S a \\<sqsubseteq> S a'\n\ngoal (2 subgoals):\n 1. S a \\<sqsubseteq> S a' \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)\n 2. S a' \\<sqsubseteq> S a \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "show \"(s @ [c], {}) \\<notin> F (S a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s @ [c], {}) \\<notin> F (S a)", "using s_c_trace_not_trace_somewhere  before"], ["proof (prove)\nusing this:\n  (s @ [c], {}) \\<notin> F (S a')\n  S a \\<sqsubseteq> S a'\n\ngoal (1 subgoal):\n 1. (s @ [c], {}) \\<notin> F (S a)", "apply(case_tac \"s @ [c] \\<notin> D (S a)\",\n                   simp_all add: T_F_spec before[THEN le_approx2T,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s @ [c] \\<notin> T (S a'); s @ [c] \\<in> D (S a);\n     S a \\<sqsubseteq> S a'\\<rbrakk>\n    \\<Longrightarrow> s @ [c] \\<notin> T (S a)", "apply(erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s @ [c] \\<in> D (S a); S a \\<sqsubseteq> S a';\n     s @ [c] \\<in> T (S a)\\<rbrakk>\n    \\<Longrightarrow> s @ [c] \\<in> T (S a')", "apply(simp only: T_F_spec[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s @ [c] \\<in> D (S a); S a \\<sqsubseteq> S a';\n     (s @ [c], {}) \\<in> F (S a)\\<rbrakk>\n    \\<Longrightarrow> (s @ [c], {}) \\<in> F (S a')", "apply(auto dest!:min_elems6[OF defined])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (s @ [c], {}) \\<notin> F (S a)\n\ngoal (1 subgoal):\n 1. S a' \\<sqsubseteq> S a \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S a' \\<sqsubseteq> S a \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "assume after:\"S a' \\<sqsubseteq> S a\""], ["proof (state)\nthis:\n  S a' \\<sqsubseteq> S a\n\ngoal (1 subgoal):\n 1. S a' \\<sqsubseteq> S a \\<Longrightarrow> (s @ [c], {}) \\<notin> F (S a)", "show \"(s @ [c], {}) \\<notin> F (S a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s @ [c], {}) \\<notin> F (S a)", "using s_c_trace_not_trace_somewhere"], ["proof (prove)\nusing this:\n  (s @ [c], {}) \\<notin> F (S a')\n\ngoal (1 subgoal):\n 1. (s @ [c], {}) \\<notin> F (S a)", "by(simp add:T_F_spec after[THEN le_approx2T]\n                         s_c_trace_not_trace_somewhere[THEN NF_ND])"], ["proof (state)\nthis:\n  (s @ [c], {}) \\<notin> F (S a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s @ [c], {}) \\<notin> F (S a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s, X \\<union> Y) \\<in> F (S a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s, X \\<union> Y) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (4 subgoals):\n 1. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s::\"'a trace\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix X::\"'a event set\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume \"(s @ [tick], {}) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (state)\nthis:\n  (s @ [tick], {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (4 subgoals):\n 1. \\<And>s X.\n       (s @ [tick], {})\n       \\<in> FAILURES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X - {tick})\n       \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 4. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus   \"(s, X - {tick}) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\nusing this:\n  (s @ [tick], {}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. (s, X - {tick}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "by(auto simp: DIVERGENCES_def FAILURES_def\n                  intro! : is_processT6[rule_format])"], ["proof (state)\nthis:\n  (s, X - {tick}) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (3 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s t ::\"'a trace\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume \"s : DIVERGENCES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\"\n   and    \"tickFree s\" and \" front_tickFree t\""], ["proof (state)\nthis:\n  s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n  tickFree s\n  front_tickFree t\n\ngoal (3 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> DIVERGENCES\n                         (\\<Inter>a. F (S a), \\<Inter>a. D (S a));\n        tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> s @ t\n                         \\<in> DIVERGENCES\n                                (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 3. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus   \"s @ t \\<in> DIVERGENCES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\nusing this:\n  s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n  tickFree s\n  front_tickFree t\n\ngoal (1 subgoal):\n 1. s @ t \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "by(auto simp: DIVERGENCES_def FAILURES_def\n                  intro: is_processT7[rule_format])"], ["proof (state)\nthis:\n  s @ t \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (2 subgoals):\n 1. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s::\"'a trace\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix X::\"'a event set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume \"s \\<in> DIVERGENCES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a)) \""], ["proof (state)\nthis:\n  s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (2 subgoals):\n 1. \\<And>s X.\n       s \\<in> DIVERGENCES\n                (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n 2. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus   \"(s, X) \\<in> FAILURES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\nusing this:\n  s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "by(auto simp: DIVERGENCES_def FAILURES_def\n                       intro: is_processT8[rule_format])"], ["proof (state)\nthis:\n  (s, X) \\<in> FAILURES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "fix s::\"'a trace\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "assume \"s @ [tick] \\<in> DIVERGENCES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a)) \""], ["proof (state)\nthis:\n  s @ [tick] \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s @ [tick]\n       \\<in> DIVERGENCES\n              (\\<Inter>a. F (S a), \\<Inter>a. D (S a)) \\<Longrightarrow>\n       s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "thus   \"s \\<in> DIVERGENCES (\\<Inter> a::nat. F (S a), \\<Inter> a::nat. D (S a))\""], ["proof (prove)\nusing this:\n  s @ [tick] \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal (1 subgoal):\n 1. s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))", "by(auto simp: DIVERGENCES_def FAILURES_def\n                  intro: is_processT9[rule_format])"], ["proof (state)\nthis:\n  s \\<in> DIVERGENCES (\\<Inter>a. F (S a), \\<Inter>a. D (S a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas Rep_Abs_LUB = Abs_process_inverse[simplified Rep_process, \n                                         simplified, OF is_process_REP_LUB,\n                                         simplified]"], ["", "lemma F_LUB: \"chain S \\<Longrightarrow> F(lim_proc(range S)) = \\<Inter> (F ` range S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    F (lim_proc (range S)) = \\<Inter> (F ` range S)", "by(simp add: lim_proc_def , subst F_def, auto simp: FAILURES_def Rep_Abs_LUB)"], ["", "lemma D_LUB: \"chain S \\<Longrightarrow> D(lim_proc(range S)) = \\<Inter> (D ` range S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    D (lim_proc (range S)) = \\<Inter> (D ` range S)", "by(simp add: lim_proc_def , subst D_def, auto simp: DIVERGENCES_def Rep_Abs_LUB)"], ["", "lemma T_LUB: \"chain S \\<Longrightarrow> T(lim_proc(range S)) = \\<Inter> (T ` range S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    T (lim_proc (range S)) = \\<Inter> (T ` range S)", "apply(simp add: lim_proc_def , subst T_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    TRACES\n     (Rep_process (Abs_process (\\<Inter>a. F (S a), \\<Inter>a. D (S a)))) =\n    (\\<Inter>a. T (S a))", "apply(simp add: TRACES_def FAILURES_def Rep_Abs_LUB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    {tr. \\<exists>b. \\<forall>x. (tr, b) \\<in> F (S x)} =\n    (\\<Inter>a. T (S a))", "apply(auto intro: F_T, rule_tac x=\"{}\" in exI, auto intro: T_F)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal D_LUB_2: \"chain S \\<Longrightarrow> t \\<in> D(lim_proc(range S)) =  ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> (t \\<in> D (lim_proc (range S))) = ?X", "apply(subst D_LUB, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> (t \\<in> \\<Inter> (D ` range S)) = ?X", "apply(rule trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> (\\<forall>x. t \\<in> D (S x)) = ?X", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal T_LUB_2: \"chain S \\<Longrightarrow> (t \\<in> T (lim_proc (range S))) = ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> (t \\<in> T (lim_proc (range S))) = ?X", "apply(subst T_LUB, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> (t \\<in> \\<Inter> (T ` range S)) = ?X", "apply(rule trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> (\\<forall>x. t \\<in> T (S x)) = ?X", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> Process Refinement is a Partial Ordering\\<close>"], ["", "text\\<open> The following type instantiation declares the refinement order\n$\\_ \\le \\_ $ written \\verb+_  <= _+. It captures the intuition that more\nconcrete processes should be more deterministic and more defined.\\<close>"], ["", "instantiation\n   process :: (type) ord          \nbegin"], ["", "definition  le_ref_def   : \"P \\<le> Q \\<equiv> D Q \\<subseteq> D P \\<and> F Q \\<subseteq> F P\""], ["", "definition  less_ref_def : \"(P::'a process) < Q \\<equiv> P \\<le> Q \\<and> P \\<noteq> Q\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a process, ord_class)", ".."], ["", "end"], ["", "lemma le_approx_implies_le_ref:    \"(P::'\\<alpha> process) \\<sqsubseteq> Q \\<Longrightarrow> P \\<le> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow> P \\<le> Q", "by(simp add: le_ref_def le_approx1 le_approx_lemma_F)"], ["", "lemma le_ref1:                     \"P \\<le> Q \\<Longrightarrow> D Q \\<subseteq> D P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le> Q \\<Longrightarrow> D Q \\<subseteq> D P", "by(simp add: le_ref_def)"], ["", "lemma le_ref2:                     \"P\\<le>Q \\<Longrightarrow> F Q \\<subseteq> F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le> Q \\<Longrightarrow> F Q \\<subseteq> F P", "by(simp add: le_ref_def)"], ["", "lemma le_ref2T :                    \"P\\<le>Q \\<Longrightarrow> T Q \\<subseteq> T P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le> Q \\<Longrightarrow> T Q \\<subseteq> T P", "by (rule subsetI) (simp add: T_F_spec[symmetric] le_ref2[THEN subsetD])"], ["", "instance  process :: (type) order"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a process, order_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix P Q R :: \"'\\<alpha> process\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"(P < Q) = (P \\<le> Q \\<and> \\<not> Q \\<le>  P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P < Q) = (P \\<le> Q \\<and> \\<not> Q \\<le> P)", "by(auto simp: le_ref_def less_ref_def Process_eq_spec)"], ["proof (state)\nthis:\n  (P < Q) = (P \\<le> Q \\<and> \\<not> Q \\<le> P)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"P \\<le> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le> P", "by(simp add: le_ref_def)"], ["proof (state)\nthis:\n  P \\<le> P\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume \"P \\<le> Q\" and \"Q \\<le> R\""], ["proof (state)\nthis:\n  P \\<le> Q\n  Q \\<le> R\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  P \\<le> Q\n  Q \\<le> R", "show \"P \\<le> R\""], ["proof (prove)\nusing this:\n  P \\<le> Q\n  Q \\<le> R\n\ngoal (1 subgoal):\n 1. P \\<le> R", "by (simp add: le_ref_def, auto)"], ["proof (state)\nthis:\n  P \\<le> R\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume \"P \\<le> Q\" and \"Q \\<le> P\""], ["proof (state)\nthis:\n  P \\<le> Q\n  Q \\<le> P\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  P \\<le> Q\n  Q \\<le> P", "show \"P = Q\""], ["proof (prove)\nusing this:\n  P \\<le> Q\n  Q \\<le> P\n\ngoal (1 subgoal):\n 1. P = Q", "by(auto simp: le_ref_def Process_eq_spec)"], ["proof (state)\nthis:\n  P = Q\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<le> Q; Q \\<le> P\\<rbrakk> \\<Longrightarrow> P = Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_proc_is_ub:\"chain S \\<Longrightarrow> range S <| lim_proc (range S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> range S <| lim_proc (range S)", "apply(auto simp: is_ub_def le_approx_def F_LUB D_LUB T_LUB Ra_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y s x xa.\n       \\<lbrakk>chain S; s \\<notin> D (S y); (s, x) \\<in> F (S y)\\<rbrakk>\n       \\<Longrightarrow> (s, x) \\<in> F (S xa)\n 2. \\<And>y x a.\n       \\<lbrakk>chain S; x \\<in> min_elems (D (S y))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (S a)", "using chain_lemma is_processT8 le_approx2"], ["proof (prove)\nusing this:\n  chain ?S \\<Longrightarrow>\n  ?S ?i \\<sqsubseteq> ?S ?k \\<or> ?S ?k \\<sqsubseteq> ?S ?i\n  \\<forall>s X. s \\<in> D ?P \\<longrightarrow> (s, X) \\<in> F ?P\n  \\<lbrakk>?P \\<sqsubseteq> ?Q; ?s \\<notin> D ?P\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?X) \\<in> F ?Q) = ((?s, ?X) \\<in> F ?P)\n\ngoal (2 subgoals):\n 1. \\<And>y s x xa.\n       \\<lbrakk>chain S; s \\<notin> D (S y); (s, x) \\<in> F (S y)\\<rbrakk>\n       \\<Longrightarrow> (s, x) \\<in> F (S xa)\n 2. \\<And>y x a.\n       \\<lbrakk>chain S; x \\<in> min_elems (D (S y))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (S a)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x a.\n       \\<lbrakk>chain S; x \\<in> min_elems (D (S y))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (S a)", "using D_T chain_lemma le_approx2T le_approx_def"], ["proof (prove)\nusing this:\n  ?s \\<in> D ?P \\<Longrightarrow> ?s \\<in> T ?P\n  chain ?S \\<Longrightarrow>\n  ?S ?i \\<sqsubseteq> ?S ?k \\<or> ?S ?k \\<sqsubseteq> ?S ?i\n  \\<lbrakk>?P \\<sqsubseteq> ?Q; ?s \\<notin> D ?P\\<rbrakk>\n  \\<Longrightarrow> (?s \\<in> T ?Q) = (?s \\<in> T ?P)\n  ?P \\<sqsubseteq> ?Q \\<equiv>\n  D ?Q \\<subseteq> D ?P \\<and>\n  (\\<forall>s. s \\<notin> D ?P \\<longrightarrow> Ra ?P s = Ra ?Q s) \\<and>\n  min_elems (D ?P) \\<subseteq> T ?Q\n\ngoal (1 subgoal):\n 1. \\<And>y x a.\n       \\<lbrakk>chain S; x \\<in> min_elems (D (S y))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T (S a)", "by blast"], ["", "lemma lim_proc_is_lub1: \"chain S \\<Longrightarrow> \\<forall> u . (range S <| u \\<longrightarrow>  D u \\<subseteq> D (lim_proc (range S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    \\<forall>u.\n       range S <| u \\<longrightarrow> D u \\<subseteq> D (lim_proc (range S))", "by(auto simp: D_LUB, frule_tac i=a in Porder.ub_rangeD, auto dest: le_approx1)"], ["", "lemma lim_proc_is_lub2: \n  \"chain S \\<Longrightarrow> \\<forall> u . range S <| u \\<longrightarrow> (\\<forall> s.  s \\<notin> D (lim_proc (range S))\n   \\<longrightarrow> Ra (lim_proc (range S)) s = Ra u s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow>\n    \\<forall>u.\n       range S <| u \\<longrightarrow>\n       (\\<forall>s.\n           s \\<notin> D (lim_proc (range S)) \\<longrightarrow>\n           Ra (lim_proc (range S)) s = Ra u s)", "apply(auto simp: is_ub_def D_LUB F_LUB Ra_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u s x xa.\n       \\<lbrakk>chain S; \\<forall>y. S y \\<sqsubseteq> u;\n        s \\<notin> D (S x); \\<forall>x. (s, xa) \\<in> F (S x)\\<rbrakk>\n       \\<Longrightarrow> (s, xa) \\<in> F u\n 2. \\<And>u s x xa xb.\n       \\<lbrakk>chain S; \\<forall>y. S y \\<sqsubseteq> u;\n        s \\<notin> D (S x); (s, xa) \\<in> F u\\<rbrakk>\n       \\<Longrightarrow> (s, xa) \\<in> F (S xb)", "using proc_ord2a"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P \\<sqsubseteq> ?Q; ?s \\<notin> D ?P\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?X) \\<in> F ?P) = ((?s, ?X) \\<in> F ?Q)\n\ngoal (2 subgoals):\n 1. \\<And>u s x xa.\n       \\<lbrakk>chain S; \\<forall>y. S y \\<sqsubseteq> u;\n        s \\<notin> D (S x); \\<forall>x. (s, xa) \\<in> F (S x)\\<rbrakk>\n       \\<Longrightarrow> (s, xa) \\<in> F u\n 2. \\<And>u s x xa xb.\n       \\<lbrakk>chain S; \\<forall>y. S y \\<sqsubseteq> u;\n        s \\<notin> D (S x); (s, xa) \\<in> F u\\<rbrakk>\n       \\<Longrightarrow> (s, xa) \\<in> F (S xb)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u s x xa xb.\n       \\<lbrakk>chain S; \\<forall>y. S y \\<sqsubseteq> u;\n        s \\<notin> D (S x); (s, xa) \\<in> F u\\<rbrakk>\n       \\<Longrightarrow> (s, xa) \\<in> F (S xb)", "using is_processT8_S proc_ord2a"], ["proof (prove)\nusing this:\n  ?s \\<in> D ?P \\<Longrightarrow> (?s, ?X) \\<in> F ?P\n  \\<lbrakk>?P \\<sqsubseteq> ?Q; ?s \\<notin> D ?P\\<rbrakk>\n  \\<Longrightarrow> ((?s, ?X) \\<in> F ?P) = ((?s, ?X) \\<in> F ?Q)\n\ngoal (1 subgoal):\n 1. \\<And>u s x xa xb.\n       \\<lbrakk>chain S; \\<forall>y. S y \\<sqsubseteq> u;\n        s \\<notin> D (S x); (s, xa) \\<in> F u\\<rbrakk>\n       \\<Longrightarrow> (s, xa) \\<in> F (S xb)", "by blast"], ["", "lemma lim_proc_is_lub3a: \"front_tickFree s \\<Longrightarrow> s \\<notin> D P \\<longrightarrow> (\\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s @ [c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_tickFree s \\<Longrightarrow>\n    s \\<notin> D P \\<longrightarrow>\n    (\\<forall>t. t \\<in> D P \\<longrightarrow> \\<not> t < s @ [c])", "apply(rule impI, erule contrapos_np, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>front_tickFree s; t \\<in> D P; t < s @ [c]\\<rbrakk>\n       \\<Longrightarrow> s \\<in> D P", "apply(auto simp: le_list_def  less_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t r.\n       \\<lbrakk>front_tickFree s; t \\<in> D P; t \\<noteq> s @ [c];\n        t @ r = s @ [c]\\<rbrakk>\n       \\<Longrightarrow> s \\<in> D P", "by (metis D_def butlast_append butlast_snoc \n          front_tickFree_mono is_process7 is_process_Rep self_append_conv)"], ["", "lemma lim_proc_is_lub3b:\nassumes 1 : \"\\<forall>x. x \\<in> X \\<longrightarrow> (\\<forall>xa. xa \\<in> D x \\<and> (\\<forall>t. t \\<in> D x \\<longrightarrow> \\<not> t < xa) \\<longrightarrow> xa \\<in> T u)\"\nand     2 : \"xa \\<in> X\"\nand     3 : \"\\<forall>xa. xa \\<in> X \\<longrightarrow> x \\<in> D xa\"\nand     4 : \"\\<forall>t. (\\<forall>x. x \\<in> X \\<longrightarrow> t \\<in> D x) \\<longrightarrow> \\<not> t < x\"\nshows       \"x \\<in> T u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> T u", "proof (cases \"\\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>t.\n       t \\<in> D xa \\<longrightarrow> \\<not> t < x \\<Longrightarrow>\n    x \\<in> T u\n 2. \\<not> (\\<forall>t.\n               t \\<in> D xa \\<longrightarrow>\n               \\<not> t < x) \\<Longrightarrow>\n    x \\<in> T u", "case True"], ["proof (state)\nthis:\n  \\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x\n\ngoal (2 subgoals):\n 1. \\<forall>t.\n       t \\<in> D xa \\<longrightarrow> \\<not> t < x \\<Longrightarrow>\n    x \\<in> T u\n 2. \\<not> (\\<forall>t.\n               t \\<in> D xa \\<longrightarrow>\n               \\<not> t < x) \\<Longrightarrow>\n    x \\<in> T u", "from \\<open>\\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x\n\ngoal (1 subgoal):\n 1. x \\<in> T u", "using 1 2 3"], ["proof (prove)\nusing this:\n  \\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x\n  \\<forall>x.\n     x \\<in> X \\<longrightarrow>\n     (\\<forall>xa.\n         xa \\<in> D x \\<and>\n         (\\<forall>t.\n             t \\<in> D x \\<longrightarrow> \\<not> t < xa) \\<longrightarrow>\n         xa \\<in> T u)\n  xa \\<in> X\n  \\<forall>xa. xa \\<in> X \\<longrightarrow> x \\<in> D xa\n\ngoal (1 subgoal):\n 1. x \\<in> T u", "by simp"], ["proof (state)\nthis:\n  x \\<in> T u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               t \\<in> D xa \\<longrightarrow>\n               \\<not> t < x) \\<Longrightarrow>\n    x \\<in> T u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               t \\<in> D xa \\<longrightarrow>\n               \\<not> t < x) \\<Longrightarrow>\n    x \\<in> T u", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               t \\<in> D xa \\<longrightarrow>\n               \\<not> t < x) \\<Longrightarrow>\n    x \\<in> T u", "from \\<open>\\<not>(\\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x)\\<close> and 3 4"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x)\n  \\<forall>xa. xa \\<in> X \\<longrightarrow> x \\<in> D xa\n  \\<forall>t.\n     (\\<forall>x. x \\<in> X \\<longrightarrow> t \\<in> D x) \\<longrightarrow>\n     \\<not> t < x", "have A: \"\\<exists>y r c. y \\<in> X \\<and> r \\<notin> D y \\<and> r \\<in> D xa \\<and> r @ [c] = x\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>t. t \\<in> D xa \\<longrightarrow> \\<not> t < x)\n  \\<forall>xa. xa \\<in> X \\<longrightarrow> x \\<in> D xa\n  \\<forall>t.\n     (\\<forall>x. x \\<in> X \\<longrightarrow> t \\<in> D x) \\<longrightarrow>\n     \\<not> t < x\n\ngoal (1 subgoal):\n 1. \\<exists>y r c.\n       y \\<in> X \\<and>\n       r \\<notin> D y \\<and> r \\<in> D xa \\<and> r @ [c] = x", "by (metis D_imp_front_tickFree front_tickFree_charn \n                                   less_self lim_proc_is_lub3a nil_less \n                                   tickFree_implies_front_tickFree)"], ["proof (state)\nthis:\n  \\<exists>y r c.\n     y \\<in> X \\<and> r \\<notin> D y \\<and> r \\<in> D xa \\<and> r @ [c] = x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               t \\<in> D xa \\<longrightarrow>\n               \\<not> t < x) \\<Longrightarrow>\n    x \\<in> T u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> T u", "apply(insert A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y r c.\n       y \\<in> X \\<and>\n       r \\<notin> D y \\<and>\n       r \\<in> D xa \\<and> r @ [c] = x \\<Longrightarrow>\n    x \\<in> T u", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y r c.\n       y \\<in> X \\<and>\n       r \\<notin> D y \\<and>\n       r \\<in> D xa \\<and> r @ [c] = x \\<Longrightarrow>\n       x \\<in> T u", "using \"1\" \"3\" D_imp_front_tickFree lim_proc_is_lub3a"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> X \\<longrightarrow>\n     (\\<forall>xa.\n         xa \\<in> D x \\<and>\n         (\\<forall>t.\n             t \\<in> D x \\<longrightarrow> \\<not> t < xa) \\<longrightarrow>\n         xa \\<in> T u)\n  \\<forall>xa. xa \\<in> X \\<longrightarrow> x \\<in> D xa\n  ?s \\<in> D ?P \\<Longrightarrow> front_tickFree ?s\n  front_tickFree ?s \\<Longrightarrow>\n  ?s \\<notin> D ?P \\<longrightarrow>\n  (\\<forall>t. t \\<in> D ?P \\<longrightarrow> \\<not> t < ?s @ [?c])\n\ngoal (1 subgoal):\n 1. \\<And>y r c.\n       y \\<in> X \\<and>\n       r \\<notin> D y \\<and>\n       r \\<in> D xa \\<and> r @ [c] = x \\<Longrightarrow>\n       x \\<in> T u", "by blast"], ["proof (state)\nthis:\n  x \\<in> T u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_proc_is_lub3c: \nassumes *:\"chain S\"\nand     **:\"X = range S\"  \\<comment>\\<open>protection for range - otherwise auto unfolds and gets lost\\<close>\nshows   \"\\<forall> u. X <| u \\<longrightarrow>  min_elems(D(lim_proc X)) \\<subseteq> T u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       X <| u \\<longrightarrow> min_elems (D (lim_proc X)) \\<subseteq> T u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       X <| u \\<longrightarrow> min_elems (D (lim_proc X)) \\<subseteq> T u", "have B : \"D (lim_proc X) = \\<Inter> (D ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (lim_proc X) = \\<Inter> (D ` X)", "by(simp add: * ** D_LUB)"], ["proof (state)\nthis:\n  D (lim_proc X) = \\<Inter> (D ` X)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       X <| u \\<longrightarrow> min_elems (D (lim_proc X)) \\<subseteq> T u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       X <| u \\<longrightarrow> min_elems (D (lim_proc X)) \\<subseteq> T u", "apply(auto simp: is_ub_def * **)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>y. S y \\<sqsubseteq> u;\n        x \\<in> min_elems (D (lim_proc (range S)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T u", "apply(auto simp: B min_elems_def le_approx_def HOL.imp_conjR HOL.all_conj_distrib Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>y. D u \\<subseteq> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y.\n           {s \\<in> D (S y).\n            \\<forall>t. t \\<in> D (S y) \\<longrightarrow> \\<not> t < s}\n           \\<subseteq> T u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T u", "apply(simp add: subset_iff imp_conjL[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T u", "apply(rule lim_proc_is_lub3b[of \"range S\", simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<in> range S \\<longrightarrow>\n                            (\\<forall>xa.\n                                xa \\<in> D x \\<and>\n                                (\\<forall>t.\n                                    t \\<in> D x \\<longrightarrow>\n                                    \\<not> t < xa) \\<longrightarrow>\n                                xa \\<in> T u)\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> ?xa22 u x \\<in> range S\n 3. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            xa \\<in> range S \\<longrightarrow> x \\<in> D xa\n 4. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t.\n                            (\\<forall>x.\n                                x \\<in> range S \\<longrightarrow>\n                                t \\<in> D x) \\<longrightarrow>\n                            \\<not> t < x", "using \"**\" B"], ["proof (prove)\nusing this:\n  X = range S\n  D (lim_proc X) = \\<Inter> (D ` X)\n\ngoal (4 subgoals):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<in> range S \\<longrightarrow>\n                            (\\<forall>xa.\n                                xa \\<in> D x \\<and>\n                                (\\<forall>t.\n                                    t \\<in> D x \\<longrightarrow>\n                                    \\<not> t < xa) \\<longrightarrow>\n                                xa \\<in> T u)\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> ?xa22 u x \\<in> range S\n 3. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            xa \\<in> range S \\<longrightarrow> x \\<in> D xa\n 4. \\<And>u x.\n       \\<lbrakk>\\<forall>y t. t \\<in> D u \\<longrightarrow> t \\<in> D (S y);\n        x \\<in> D (lim_proc (range S));\n        \\<forall>t.\n           t \\<in> D (lim_proc (range S)) \\<longrightarrow> \\<not> t < x;\n        \\<forall>y s.\n           s \\<notin> D (S y) \\<longrightarrow> Ra (S y) s = Ra u s;\n        \\<forall>y t.\n           t \\<in> D (S y) \\<and>\n           (\\<forall>ta.\n               ta \\<in> D (S y) \\<longrightarrow>\n               \\<not> ta < t) \\<longrightarrow>\n           t \\<in> T u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t.\n                            (\\<forall>x.\n                                x \\<in> range S \\<longrightarrow>\n                                t \\<in> D x) \\<longrightarrow>\n                            \\<not> t < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>u.\n     X <| u \\<longrightarrow> min_elems (D (lim_proc X)) \\<subseteq> T u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma limproc_is_lub: \"chain S \\<Longrightarrow> range S <<| lim_proc (range S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> range S <<| lim_proc (range S)", "apply (auto simp: is_lub_def lim_proc_is_ub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>chain S; range S <| u\\<rbrakk>\n       \\<Longrightarrow> lim_proc (range S) \\<sqsubseteq> u", "apply (simp add: le_approx_def is_lub_def lim_proc_is_ub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>chain S; range S <| u\\<rbrakk>\n       \\<Longrightarrow> D u \\<subseteq> D (lim_proc (range S)) \\<and>\n                         (\\<forall>s.\n                             s \\<notin> D\n   (lim_proc (range S)) \\<longrightarrow>\n                             Ra (lim_proc (range S)) s = Ra u s) \\<and>\n                         min_elems (D (lim_proc (range S))) \\<subseteq> T u", "by (simp add: lim_proc_is_lub1 lim_proc_is_lub2 lim_proc_is_lub3c)"], ["", "lemma limproc_is_thelub: \"chain S \\<Longrightarrow> Lub S = lim_proc (range S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> Lub S = lim_proc (range S)", "by (frule limproc_is_lub,frule Porder.po_class.lub_eqI, simp)"], ["", "instance\n   process :: (type) cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a process, cpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. chain S \\<Longrightarrow> \\<exists>x. range S <<| x", "fix S ::\"nat \\<Rightarrow> '\\<alpha> process\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. chain S \\<Longrightarrow> \\<exists>x. range S <<| x", "assume C:\"chain S\""], ["proof (state)\nthis:\n  chain S\n\ngoal (1 subgoal):\n 1. \\<And>S. chain S \\<Longrightarrow> \\<exists>x. range S <<| x", "thus \"\\<exists> x. range S <<| x\""], ["proof (prove)\nusing this:\n  chain S\n\ngoal (1 subgoal):\n 1. \\<exists>x. range S <<| x", "using limproc_is_lub"], ["proof (prove)\nusing this:\n  chain S\n  chain ?S \\<Longrightarrow> range ?S <<| lim_proc (range ?S)\n\ngoal (1 subgoal):\n 1. \\<exists>x. range S <<| x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. range S <<| x\n\ngoal:\nNo subgoals!", "qed"], ["", "instance\n   process :: (type) pcpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a process, pcpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "show \"\\<exists> x::'a process. \\<forall> y::'a process. x \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "have is_process_witness : \n           \"is_process({(s,X). front_tickFree s},{d. front_tickFree d})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_process ({(s, X). front_tickFree s}, {d. front_tickFree d})", "apply(auto simp:is_process_def FAILURES_def DIVERGENCES_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s t. front_tickFree (s @ t) \\<Longrightarrow> front_tickFree s\n 2. \\<And>s. front_tickFree (s @ [tick]) \\<Longrightarrow> front_tickFree s\n 3. \\<And>s t.\n       \\<lbrakk>front_tickFree s; tickFree s; front_tickFree t\\<rbrakk>\n       \\<Longrightarrow> front_tickFree (s @ t)\n 4. \\<And>s. front_tickFree (s @ [tick]) \\<Longrightarrow> front_tickFree s", "apply(auto elim!: tickFree_implies_front_tickFree front_tickFree_dw_closed\n                             front_tickFree_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_process ({(s, X). front_tickFree s}, {d. front_tickFree d})\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "have bot_inverse : \n           \"Rep_process(Abs_process({(s, X). front_tickFree s},Collect front_tickFree))=\n                          ({(s, X). front_tickFree s}, Collect front_tickFree)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_process\n     (Abs_process ({(s, X). front_tickFree s}, Collect front_tickFree)) =\n    ({(s, X). front_tickFree s}, Collect front_tickFree)", "by(subst Abs_process_inverse, simp_all add: Rep_process is_process_witness)"], ["proof (state)\nthis:\n  Rep_process\n   (Abs_process ({(s, X). front_tickFree s}, Collect front_tickFree)) =\n  ({(s, X). front_tickFree s}, Collect front_tickFree)\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "have divergences_frontTickFree:\n           \"\\<And>y x. x \\<in> snd (Rep_process y) \\<Longrightarrow> front_tickFree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       x \\<in> snd (Rep_process y) \\<Longrightarrow> front_tickFree x", "by(rule D_imp_front_tickFree, simp add: D_def DIVERGENCES_def)"], ["proof (state)\nthis:\n  ?x2 \\<in> snd (Rep_process ?y2) \\<Longrightarrow> front_tickFree ?x2\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "have failures_frontTickFree:\n           \"\\<And>y s x. (s, x) \\<in> fst (Rep_process y) \\<Longrightarrow> front_tickFree s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y s x.\n       (s, x) \\<in> fst (Rep_process y) \\<Longrightarrow> front_tickFree s", "by(rule is_processT2[rule_format], \n              simp add: F_def FAILURES_def)"], ["proof (state)\nthis:\n  (?s3, ?x3) \\<in> fst (Rep_process ?y3) \\<Longrightarrow>\n  front_tickFree ?s3\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "have minelems_contains_mt:\n           \"\\<And>y x. x \\<in> min_elems (Collect front_tickFree) \\<Longrightarrow> x = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       x \\<in> min_elems (Collect front_tickFree) \\<Longrightarrow> x = []", "by(simp add: min_elems_def front_tickFree_charn,safe, \n              auto simp: Nil_elem_T)"], ["proof (state)\nthis:\n  ?x4 \\<in> min_elems (Collect front_tickFree) \\<Longrightarrow> ?x4 = []\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "apply(rule_tac x=\"Abs_process ({(s,X). front_tickFree s},{d. front_tickFree d})\" \n            in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       Abs_process\n        ({(s, X). front_tickFree s}, {d. front_tickFree d}) \\<sqsubseteq>\n       y", "apply(auto simp: le_approx_def bot_inverse Ra_def \n                       F_def D_def FAILURES_def DIVERGENCES_def\n                       divergences_frontTickFree failures_frontTickFree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       x \\<in> min_elems (Collect front_tickFree) \\<Longrightarrow>\n       x \\<in> T y", "apply (metis minelems_contains_mt Nil_elem_T )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y. x \\<sqsubseteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y. x \\<sqsubseteq> y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open> Process Refinement is admissible \\<close>"], ["", "lemma le_adm[simp]: \"cont (u::('a::cpo) \\<Rightarrow> 'b process) \\<Longrightarrow> monofun v \\<Longrightarrow> adm(\\<lambda>x. u x \\<le> v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont u; monofun v\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x. u x \\<le> v x)", "proof(auto simp add:le_ref_def cont2contlubE adm_def, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))\n 2. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "case (1 Y x)"], ["proof (state)\nthis:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i.\n     D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n     F (v (Y i)) \\<subseteq> F (u (Y i))\n  x \\<in> D (v (\\<Squnion>i. Y i))\n\ngoal (2 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))\n 2. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "hence \"v (Y i)  \\<sqsubseteq> v (\\<Squnion>i. Y i)\" for i"], ["proof (prove)\nusing this:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i.\n     D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n     F (v (Y i)) \\<subseteq> F (u (Y i))\n  x \\<in> D (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. v (Y i) \\<sqsubseteq> v (\\<Squnion>i. Y i)", "by (simp add: is_ub_thelub monofunE)"], ["proof (state)\nthis:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (2 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))\n 2. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "hence \"D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y i))\" for i"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y i))", "using \"1\"(4) le_approx1"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n  \\<forall>i.\n     D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n     F (v (Y i)) \\<subseteq> F (u (Y i))\n  ?P \\<sqsubseteq> ?Q \\<Longrightarrow> D ?Q \\<subseteq> D ?P\n\ngoal (1 subgoal):\n 1. D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y i))", "by blast"], ["proof (state)\nthis:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))\n\ngoal (2 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        x \\<in> D (v (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D (\\<Squnion>i. u (Y i))\n 2. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "then"], ["proof (chain)\npicking this:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))", "show ?case"], ["proof (prove)\nusing this:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))\n\ngoal (1 subgoal):\n 1. x \\<in> D (\\<Squnion>i. u (Y i))", "using D_LUB[OF ch2ch_cont[OF 1(1) 1(3)]] limproc_is_thelub[OF ch2ch_cont[OF 1(1) 1(3)]] \"1\"(5)"], ["proof (prove)\nusing this:\n  D (v (\\<Squnion>i. Y i)) \\<subseteq> D (u (Y ?i))\n  D (lim_proc (range (\\<lambda>i. u (Y i)))) =\n  \\<Inter> (D ` range (\\<lambda>i. u (Y i)))\n  (\\<Squnion>i. u (Y i)) = lim_proc (range (\\<lambda>i. u (Y i)))\n  x \\<in> D (v (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. x \\<in> D (\\<Squnion>i. u (Y i))", "by force"], ["proof (state)\nthis:\n  x \\<in> D (\\<Squnion>i. u (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "case (2 Y a b)"], ["proof (state)\nthis:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i.\n     D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n     F (v (Y i)) \\<subseteq> F (u (Y i))\n  (a, b) \\<in> F (v (\\<Squnion>x. Y x))\n\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "hence \"v (Y i)  \\<sqsubseteq> v (\\<Squnion>i. Y i)\" for i"], ["proof (prove)\nusing this:\n  cont u\n  monofun v\n  chain Y\n  \\<forall>i.\n     D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n     F (v (Y i)) \\<subseteq> F (u (Y i))\n  (a, b) \\<in> F (v (\\<Squnion>x. Y x))\n\ngoal (1 subgoal):\n 1. v (Y i) \\<sqsubseteq> v (\\<Squnion>i. Y i)", "by (simp add: is_ub_thelub monofunE)"], ["proof (state)\nthis:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "hence \"F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y i))\" for i"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y i))", "using \"2\"(4) le_approx_lemma_F"], ["proof (prove)\nusing this:\n  v (Y ?i) \\<sqsubseteq> v (\\<Squnion>i. Y i)\n  \\<forall>i.\n     D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n     F (v (Y i)) \\<subseteq> F (u (Y i))\n  ?P \\<sqsubseteq> ?Q \\<Longrightarrow> F ?Q \\<subseteq> F ?P\n\ngoal (1 subgoal):\n 1. F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y i))", "by blast"], ["proof (state)\nthis:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))\n\ngoal (1 subgoal):\n 1. \\<And>Y a b.\n       \\<lbrakk>cont u; monofun v; chain Y;\n        \\<forall>i.\n           D (v (Y i)) \\<subseteq> D (u (Y i)) \\<and>\n           F (v (Y i)) \\<subseteq> F (u (Y i));\n        (a, b) \\<in> F (v (\\<Squnion>x. Y x))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "then"], ["proof (chain)\npicking this:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))", "show ?case"], ["proof (prove)\nusing this:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "using F_LUB[OF ch2ch_cont[OF 2(1) 2(3)]] limproc_is_thelub[OF ch2ch_cont[OF 2(1) 2(3)]] \"2\"(5)"], ["proof (prove)\nusing this:\n  F (v (\\<Squnion>i. Y i)) \\<subseteq> F (u (Y ?i))\n  F (lim_proc (range (\\<lambda>i. u (Y i)))) =\n  \\<Inter> (F ` range (\\<lambda>i. u (Y i)))\n  (\\<Squnion>i. u (Y i)) = lim_proc (range (\\<lambda>i. u (Y i)))\n  (a, b) \\<in> F (v (\\<Squnion>x. Y x))\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> F (\\<Squnion>i. u (Y i))", "by force"], ["proof (state)\nthis:\n  (a, b) \\<in> F (\\<Squnion>i. u (Y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas le_adm_cont[simp] = le_adm[OF _ cont2mono]"], ["", "subsection\\<open> Conditional statement is cont \\<close>"], ["", "text\\<open>The conditional operator of CSP is obtained by a direct shallow embedding. Here we prove it continuous\\<close>"], ["", "lemma if_then_else_cont[simp]: \n  assumes *:\"(\\<And>x. P x \\<Longrightarrow> cont ((f::'c \\<Rightarrow> ('a::cpo) \\<Rightarrow> 'b process) x))\"\n  and     **:\"(\\<And>x. \\<not> P x \\<Longrightarrow> cont (g x))\"\n  shows \"\\<And>x. cont(\\<lambda>y. if P x then f x y else g x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. cont (\\<lambda>y. if P x then f x y else g x y)", "using * **"], ["proof (prove)\nusing this:\n  P ?x \\<Longrightarrow> cont (f ?x)\n  \\<not> P ?x \\<Longrightarrow> cont (g ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x. cont (\\<lambda>y. if P x then f x y else g x y)", "by (auto simp:cont_def)"], ["", "end"]]}