{"file_name": "/home/qj213/afp-2021-10-22/thys/LocalLexing/TheoremD2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LocalLexing", "problem_names": ["lemma splits_at_combine: \"splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> \\<delta> = \\<alpha> @ [N] @ \\<beta>\"", "lemma splits_at_combine_dest: \"Derives1 a i r b \\<Longrightarrow> splits_at a i \\<alpha> N \\<beta> \\<Longrightarrow> b = \\<alpha> @ (snd r) @ \\<beta>\"", "lemma Derives1_nonterminal: \n  assumes \"Derives1 a i r b\"\n  assumes \"splits_at a i \\<alpha> N \\<beta>\"\n  shows \"fst r = N \\<and> is_nonterminal N\"", "lemma splits_at_ex: \"Derives1 \\<delta> i r s \\<Longrightarrow> \\<exists> \\<alpha> N \\<beta>. splits_at \\<delta> i \\<alpha> N \\<beta>\"", "lemma splits_at_\\<alpha>: \"Derives1 \\<delta> i r s \\<Longrightarrow> splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> \n  \\<alpha> = take i \\<delta> \\<and> \\<alpha> = take i s \\<and> length \\<alpha> = i\"", "lemma LeftDerives1_splits_at_is_word: \"LeftDerives1 \\<delta> i r s \\<Longrightarrow> splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> is_word \\<alpha>\"", "lemma splits_at_\\<beta>: \"Derives1 \\<delta> i r s \\<Longrightarrow> splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> \n  \\<beta> = drop (Suc i) \\<delta> \\<and> \\<beta> = drop (i + length (snd r)) s \\<and> length \\<beta> = length \\<delta> - i - 1\"", "lemma Derives1_prefix:\n  assumes ab: \"Derives1 \\<delta> i r (a@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  shows \"is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\"", "lemma Derives1_suffix:\n  assumes ab: \"Derives1 \\<delta> i r (a@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  shows \"is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\"", "lemma Derives1_skip_prefix:\n  \"length a \\<le> i \\<Longrightarrow> Derives1 (a@b) i r (a@c) \\<Longrightarrow> Derives1 b (i - length a) r c\"", "lemma cancel_suffix:\n  assumes \"a @ c = b @ d\"\n  assumes \"length c \\<le> length d\"\n  shows \"a = b @ (take (length d - length c) d)\"", "lemma is_sentence_take:\n  \"is_sentence y \\<Longrightarrow> is_sentence (take n y)\"", "lemma Derives1_skip_suffix:\n  assumes i: \"i < length a\"\n  assumes D: \"Derives1 (a@c) i r (b@c)\"\n  shows \"Derives1 a i r b\"", "lemma drop_cancel_suffix: \"a@c = drop n (b@c) \\<Longrightarrow> a = drop n b\"", "lemma drop_keep_last: \"u \\<noteq> [] \\<Longrightarrow> u = drop n (a@[X]) \\<Longrightarrow> u = drop n a @ [X]\"", "lemma Derives1_X_is_part_of_rule[consumes 2, case_names Suffix Prefix]:\n  assumes aXb: \"Derives1 \\<delta> i r (a@[X]@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  assumes prefix: \"\\<And> \\<beta>. \\<delta> = a @ [X] @ \\<beta> \\<Longrightarrow> length a < i \\<Longrightarrow> \n                     Derives1 \\<beta> (i - length a - 1) r b \\<Longrightarrow> False\"\n  assumes suffix: \"\\<And> \\<alpha>. \\<delta> = \\<alpha> @ [X] @ b \\<Longrightarrow> Derives1 \\<alpha> i r a \\<Longrightarrow> False\" \n  shows \"\\<exists> u v. a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> (snd r) = u@[X]@v\"", "lemma \\<L>\\<^sub>P_derives: \"a \\<in> \\<L>\\<^sub>P \\<Longrightarrow> \\<exists> b. derives [\\<SS>] (a@b)\"", "lemma \\<L>\\<^sub>P_leftderives: \"a \\<in> \\<L>\\<^sub>P \\<Longrightarrow> \\<exists> b. leftderives [\\<SS>] (a@b)\"", "lemma Derives1_rule: \"Derives1 a i r b \\<Longrightarrow> r \\<in> \\<RR>\"", "lemma is_prefix_empty[simp]: \"is_prefix [] a\"", "lemma is_prefix_cons: \"is_prefix (x # a) b = (\\<exists> c. b = x # c \\<and> is_prefix a c)\"", "lemma is_prefix_cancel[simp]: \"is_prefix (a@b) (a@c) = is_prefix b c\"", "lemma is_prefix_chars: \"is_prefix a b \\<Longrightarrow> is_prefix (chars a) (chars b)\"", "lemma is_prefix_length: \"is_prefix a b \\<Longrightarrow> length a \\<le> length b\"", "lemma is_prefix_take[simp]: \"is_prefix (take n a) a\"", "lemma doc_tokens_length: \"doc_tokens p \\<Longrightarrow> length (chars p) \\<le> length Doc\"", "lemma count_terminals_upper_bound: \"count_terminals p \\<le> length p\"", "lemma count_terminals_append[simp]: \"count_terminals (a@b) = count_terminals a + count_terminals b\"", "lemma Derives1_count_terminals:\n  assumes D: \"Derives1 a i r b\"\n  shows \"count_terminals b = count_terminals a + count_terminals (snd r)\"", "lemma Derives1_count_terminals_leq:\n  assumes D: \"Derives1 a i r b\"\n  shows \"count_terminals a \\<le> count_terminals b\"", "lemma Derivation_count_terminals_leq:\n  \"Derivation a E b \\<Longrightarrow> count_terminals a \\<le> count_terminals b\"", "lemma derives_count_terminals_leq: \"derives a b \\<Longrightarrow> count_terminals a \\<le> count_terminals b\"", "lemma is_word_cons[simp]: \"is_word (x#xs) = (is_terminal x \\<and> is_word xs)\"", "lemma count_terminals_of_word: \"is_word w \\<Longrightarrow> count_terminals w = length w\"", "lemma length_terminals[simp]: \"length (terminals p) = length p\"", "lemma path_length_is_upper_bound:\n  assumes p: \"wellformed_tokens p\"\n  assumes \\<alpha>: \"is_word \\<alpha>\"\n  assumes derives: \"derives (\\<alpha>@u) (terminals p)\"\n  shows \"length \\<alpha> \\<le> length p\"", "lemma is_word_Derives1_index:\n  assumes w: \"is_word w\"\n  assumes derives1: \"Derives1 (w@a) i r b\"\n  shows \"i \\<ge> length w\"", "lemma is_word_Derivation_derivation_ge:\n  assumes w: \"is_word w\"\n  assumes D: \"Derivation (w@a) D b\"\n  shows \"derivation_ge D (length w)\"", "lemma derives_word_is_prefix:\n  assumes w: \"is_word w\"\n  assumes derives: \"derives (w@a) b\"\n  shows \"is_prefix w b\"", "lemma terminals_take[simp]: \"terminals (take n p) = take n (terminals p)\"", "lemma terminals_drop[simp]: \"terminals (drop n p) = drop n (terminals p)\"", "lemma take_prefix[simp]: \"is_prefix a b \\<Longrightarrow> take (length a) b = a\"", "lemma Derives1_drop_prefixword: \n  assumes w: \"is_word w\"\n  assumes wa_b: \"Derives1 (w@a) i r b\"\n  shows \"Derives1 a (i - length w) r (drop (length w) b)\"", "lemma derives1_drop_prefixword: \n  assumes w: \"is_word w\"\n  assumes wa_b: \"derives1 (w@a) b\"\n  shows \"derives1 a (drop (length w) b)\"", "lemma derives1_is_word_is_prefix_drop: \n  assumes w: \"is_word w\"\n  assumes w_a: \"is_prefix w a\"\n  assumes ab: \"derives1 a b\"\n  shows \"derives1 (drop (length w) a) (drop (length w) b)\"", "lemma derives_drop_prefixword_helper: \n  \"derives a b \\<Longrightarrow> is_word w \\<Longrightarrow> is_prefix w a \\<Longrightarrow> derives (drop (length w) a) (drop (length w) b)\"", "lemma derive_drop_prefixword:\n  \"is_word w \\<Longrightarrow> derives (w@a) b \\<Longrightarrow> derives a (drop (length w) b)\"", "lemma thmD2':\n  assumes X: \"is_terminal X\"\n  assumes p: \"doc_tokens p\"\n  assumes pX: \"(terminals p)@[X] \\<in> \\<L>\\<^sub>P\"\n  shows \"\\<exists> x. pvalid p x \\<and> next_symbol x = Some X\"", "lemma admissible_wellformed_tokens: \"admissible p \\<Longrightarrow> wellformed_tokens p\"", "lemma chars_append[simp]: \"chars (a@b) = (chars a)@(chars b)\"", "lemma chars_of_token_simp[simp]: \"chars_of_token (a, b) = b\"", "lemma \\<X>_is_prefix: \"t \\<in> \\<X> k \\<Longrightarrow> is_prefix (snd t) (drop k Doc)\"", "lemma is_prefix_append: \"is_prefix (a@b) D = (is_prefix a D \\<and> is_prefix b (drop (length a) D))\"", "lemma \\<PP>_are_doc_tokens: \"p \\<in> \\<PP> \\<Longrightarrow> doc_tokens p\"", "theorem thmD2:\n  assumes X: \"is_terminal X\"\n  assumes p: \"p \\<in> \\<PP>\"\n  assumes pX: \"(terminals p)@[X] \\<in> \\<L>\\<^sub>P\"\n  shows \"\\<exists> x. pvalid p x \\<and> next_symbol x = Some X\""], "translations": [["", "lemma splits_at_combine: \"splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> \\<delta> = \\<alpha> @ [N] @ \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow>\n    \\<delta> = \\<alpha> @ [N] @ \\<beta>", "by (simp add: id_take_nth_drop splits_at_def)"], ["", "lemma splits_at_combine_dest: \"Derives1 a i r b \\<Longrightarrow> splits_at a i \\<alpha> N \\<beta> \\<Longrightarrow> b = \\<alpha> @ (snd r) @ \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Derives1 a i r b; splits_at a i \\<alpha> N \\<beta>\\<rbrakk>\n    \\<Longrightarrow> b = \\<alpha> @ snd r @ \\<beta>", "by (metis (no_types, lifting) Derives1_drop Derives1_split append_assoc append_eq_conv_conj \n      length_append splits_at_def)"], ["", "lemma Derives1_nonterminal: \n  assumes \"Derives1 a i r b\"\n  assumes \"splits_at a i \\<alpha> N \\<beta>\"\n  shows \"fst r = N \\<and> is_nonterminal N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst r = N \\<and> is_nonterminal N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst r = N \\<and> is_nonterminal N", "from assms"], ["proof (chain)\npicking this:\n  Derives1 a i r b\n  splits_at a i \\<alpha> N \\<beta>", "have fst: \"fst r = N\""], ["proof (prove)\nusing this:\n  Derives1 a i r b\n  splits_at a i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. fst r = N", "by (metis Derives1_split append_Cons nth_append_length splits_at_def)"], ["proof (state)\nthis:\n  fst r = N\n\ngoal (1 subgoal):\n 1. fst r = N \\<and> is_nonterminal N", "then"], ["proof (chain)\npicking this:\n  fst r = N", "have \"is_nonterminal N\""], ["proof (prove)\nusing this:\n  fst r = N\n\ngoal (1 subgoal):\n 1. is_nonterminal N", "by (metis Derives1_def assms(1) prod.collapse rule_nonterminal_type)"], ["proof (state)\nthis:\n  is_nonterminal N\n\ngoal (1 subgoal):\n 1. fst r = N \\<and> is_nonterminal N", "with fst"], ["proof (chain)\npicking this:\n  fst r = N\n  is_nonterminal N", "show ?thesis"], ["proof (prove)\nusing this:\n  fst r = N\n  is_nonterminal N\n\ngoal (1 subgoal):\n 1. fst r = N \\<and> is_nonterminal N", "by auto"], ["proof (state)\nthis:\n  fst r = N \\<and> is_nonterminal N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splits_at_ex: \"Derives1 \\<delta> i r s \\<Longrightarrow> \\<exists> \\<alpha> N \\<beta>. splits_at \\<delta> i \\<alpha> N \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 \\<delta> i r s \\<Longrightarrow>\n    \\<exists>\\<alpha> N \\<beta>. splits_at \\<delta> i \\<alpha> N \\<beta>", "by (simp add: Derives1_bound splits_at_def)"], ["", "lemma splits_at_\\<alpha>: \"Derives1 \\<delta> i r s \\<Longrightarrow> splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> \n  \\<alpha> = take i \\<delta> \\<and> \\<alpha> = take i s \\<and> length \\<alpha> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Derives1 \\<delta> i r s;\n     splits_at \\<delta> i \\<alpha> N \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> = take i \\<delta> \\<and>\n                      \\<alpha> = take i s \\<and> length \\<alpha> = i", "by (metis Derives1_split append_eq_conv_conj splits_at_def)"], ["", "lemma LeftDerives1_splits_at_is_word: \"LeftDerives1 \\<delta> i r s \\<Longrightarrow> splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> is_word \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 \\<delta> i r s;\n     splits_at \\<delta> i \\<alpha> N \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_word \\<alpha>", "by (metis LeftDerives1_def leftmost_def splits_at_def)"], ["", "lemma splits_at_\\<beta>: \"Derives1 \\<delta> i r s \\<Longrightarrow> splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow> \n  \\<beta> = drop (Suc i) \\<delta> \\<and> \\<beta> = drop (i + length (snd r)) s \\<and> length \\<beta> = length \\<delta> - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Derives1 \\<delta> i r s;\n     splits_at \\<delta> i \\<alpha> N \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<beta> = drop (Suc i) \\<delta> \\<and>\n                      \\<beta> = drop (i + length (snd r)) s \\<and>\n                      length \\<beta> = length \\<delta> - i - 1", "by (metis Derives1_drop Suc_eq_plus1 diff_diff_left length_drop splits_at_def)"], ["", "lemma Derives1_prefix:\n  assumes ab: \"Derives1 \\<delta> i r (a@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  shows \"is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "have take: \"\\<alpha> = take i (a@b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = take i (a @ b)", "using ab split splits_at_\\<alpha>"], ["proof (prove)\nusing this:\n  Derives1 \\<delta> i r (a @ b)\n  splits_at \\<delta> i \\<alpha> N \\<beta>\n  \\<lbrakk>Derives1 ?\\<delta> ?i ?r ?s;\n   splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> = take ?i ?\\<delta> \\<and>\n                    ?\\<alpha> = take ?i ?s \\<and> length ?\\<alpha> = ?i\n\ngoal (1 subgoal):\n 1. \\<alpha> = take i (a @ b)", "by blast"], ["proof (state)\nthis:\n  \\<alpha> = take i (a @ b)\n\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "proof (cases \"i \\<le> length a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\n 2. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "case True"], ["proof (state)\nthis:\n  i \\<le> length a\n\ngoal (2 subgoals):\n 1. i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\n 2. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "then"], ["proof (chain)\npicking this:\n  i \\<le> length a", "have \"\\<alpha> = take i a\""], ["proof (prove)\nusing this:\n  i \\<le> length a\n\ngoal (1 subgoal):\n 1. \\<alpha> = take i a", "by (simp add: take)"], ["proof (state)\nthis:\n  \\<alpha> = take i a\n\ngoal (2 subgoals):\n 1. i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\n 2. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = take i a", "have \"is_prefix \\<alpha> a\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i a\n\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a", "by (metis append_take_drop_id is_prefix_def)"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a\n\ngoal (2 subgoals):\n 1. i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\n 2. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "with True"], ["proof (chain)\npicking this:\n  i \\<le> length a\n  is_prefix \\<alpha> a", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> length a\n  is_prefix \\<alpha> a\n\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "by auto"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> length a\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<not> i \\<le> length a", "have \"is_prefix a \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> length a\n\ngoal (1 subgoal):\n 1. is_prefix a \\<alpha>", "by (simp add: is_prefix_def nat_le_linear take)"], ["proof (state)\nthis:\n  is_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> length a \\<Longrightarrow>\n    is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "with False"], ["proof (chain)\npicking this:\n  \\<not> i \\<le> length a\n  is_prefix a \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> length a\n  is_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>", "by auto"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a \\<or> is_prefix a \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Derives1_suffix:\n  assumes ab: \"Derives1 \\<delta> i r (a@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  shows \"is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "have drop1: \"\\<beta> = drop (i + length (snd r)) (a@b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> = drop (i + length (snd r)) (a @ b)", "using ab split splits_at_\\<beta>"], ["proof (prove)\nusing this:\n  Derives1 \\<delta> i r (a @ b)\n  splits_at \\<delta> i \\<alpha> N \\<beta>\n  \\<lbrakk>Derives1 ?\\<delta> ?i ?r ?s;\n   splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> = drop (Suc ?i) ?\\<delta> \\<and>\n                    ?\\<beta> = drop (?i + length (snd ?r)) ?s \\<and>\n                    length ?\\<beta> = length ?\\<delta> - ?i - 1\n\ngoal (1 subgoal):\n 1. \\<beta> = drop (i + length (snd r)) (a @ b)", "by blast"], ["proof (state)\nthis:\n  \\<beta> = drop (i + length (snd r)) (a @ b)\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "have drop2: \"b = drop (length a) (a@b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = drop (length a) (a @ b)", "by simp"], ["proof (state)\nthis:\n  b = drop (length a) (a @ b)\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "proof (cases \"(i + length (snd r)) \\<le> length a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n 2. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "case True"], ["proof (state)\nthis:\n  i + length (snd r) \\<le> length a\n\ngoal (2 subgoals):\n 1. i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n 2. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "with drop1 drop2"], ["proof (chain)\npicking this:\n  \\<beta> = drop (i + length (snd r)) (a @ b)\n  b = drop (length a) (a @ b)\n  i + length (snd r) \\<le> length a", "have \"is_suffix b \\<beta>\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (i + length (snd r)) (a @ b)\n  b = drop (length a) (a @ b)\n  i + length (snd r) \\<le> length a\n\ngoal (1 subgoal):\n 1. is_suffix b \\<beta>", "by (simp add: is_suffix_def)"], ["proof (state)\nthis:\n  is_suffix b \\<beta>\n\ngoal (2 subgoals):\n 1. i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n 2. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "then"], ["proof (chain)\npicking this:\n  is_suffix b \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "by auto"], ["proof (state)\nthis:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "case False"], ["proof (state)\nthis:\n  \\<not> i + length (snd r) \\<le> length a\n\ngoal (1 subgoal):\n 1. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<not> i + length (snd r) \\<le> length a", "have \"length a \\<le> (i + length (snd r))\""], ["proof (prove)\nusing this:\n  \\<not> i + length (snd r) \\<le> length a\n\ngoal (1 subgoal):\n 1. length a \\<le> i + length (snd r)", "by arith"], ["proof (state)\nthis:\n  length a \\<le> i + length (snd r)\n\ngoal (1 subgoal):\n 1. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "with drop1 drop2"], ["proof (chain)\npicking this:\n  \\<beta> = drop (i + length (snd r)) (a @ b)\n  b = drop (length a) (a @ b)\n  length a \\<le> i + length (snd r)", "have \"is_suffix \\<beta> b\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (i + length (snd r)) (a @ b)\n  b = drop (length a) (a @ b)\n  length a \\<le> i + length (snd r)\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b", "by (metis append_Nil append_take_drop_id drop_append drop_eq_Nil is_suffix_def)"], ["proof (state)\nthis:\n  is_suffix \\<beta> b\n\ngoal (1 subgoal):\n 1. \\<not> i + length (snd r) \\<le> length a \\<Longrightarrow>\n    is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "then"], ["proof (chain)\npicking this:\n  is_suffix \\<beta> b", "show ?thesis"], ["proof (prove)\nusing this:\n  is_suffix \\<beta> b\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "by auto"], ["proof (state)\nthis:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Derives1_skip_prefix:\n  \"length a \\<le> i \\<Longrightarrow> Derives1 (a@b) i r (a@c) \\<Longrightarrow> Derives1 b (i - length a) r c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a \\<le> i; Derives1 (a @ b) i r (a @ c)\\<rbrakk>\n    \\<Longrightarrow> Derives1 b (i - length a) r c", "apply (auto simp add: Derives1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y N \\<alpha>.\n       \\<lbrakk>length a \\<le> length x; a @ b = x @ N # y;\n        a @ c = x @ \\<alpha> @ y; is_sentence x; is_sentence y;\n        (N, \\<alpha>) \\<in> \\<RR>; i = length x; r = (N, \\<alpha>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa y.\n                            b = xa @ N # y \\<and>\n                            c = xa @ \\<alpha> @ y \\<and>\n                            is_sentence xa \\<and>\n                            is_sentence y \\<and>\n                            length x - length a = length xa", "by (metis append_eq_append_conv_if is_sentence_concat is_sentence_cons is_symbol_def \n    length_drop rule_nonterminal_type)"], ["", "lemma cancel_suffix:\n  assumes \"a @ c = b @ d\"\n  assumes \"length c \\<le> length d\"\n  shows \"a = b @ (take (length d - length c) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b @ take (length d - length c) d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b @ take (length d - length c) d", "have \"a @ c = (b @ take (length d - length c) d) @ drop (length d - length c) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ c =\n    (b @ take (length d - length c) d) @ drop (length d - length c) d", "by (metis append_assoc append_take_drop_id assms(1))"], ["proof (state)\nthis:\n  a @ c = (b @ take (length d - length c) d) @ drop (length d - length c) d\n\ngoal (1 subgoal):\n 1. a = b @ take (length d - length c) d", "then"], ["proof (chain)\npicking this:\n  a @ c = (b @ take (length d - length c) d) @ drop (length d - length c) d", "show ?thesis"], ["proof (prove)\nusing this:\n  a @ c = (b @ take (length d - length c) d) @ drop (length d - length c) d\n\ngoal (1 subgoal):\n 1. a = b @ take (length d - length c) d", "by (metis append_eq_append_conv assms(2) diff_diff_cancel length_drop)"], ["proof (state)\nthis:\n  a = b @ take (length d - length c) d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_sentence_take:\n  \"is_sentence y \\<Longrightarrow> is_sentence (take n y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence y \\<Longrightarrow> is_sentence (take n y)", "by (metis append_take_drop_id is_sentence_concat)"], ["", "lemma Derives1_skip_suffix:\n  assumes i: \"i < length a\"\n  assumes D: \"Derives1 (a@c) i r (b@c)\"\n  shows \"Derives1 a i r b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 a i r b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Derives1 a i r b", "note Derives1_def[where u=\"a@c\" and v=\"b@c\" and i=i and r=r]"], ["proof (state)\nthis:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "then"], ["proof (chain)\npicking this:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)", "have \"\\<exists>x y N \\<alpha>.\n    a @ c = x @ [N] @ y \\<and>\n    b @ c = x @ \\<alpha> @ y \\<and> is_sentence x \\<and> is_sentence y \\<and> (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\""], ["proof (prove)\nusing this:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)\n\ngoal (1 subgoal):\n 1. \\<exists>x y N \\<alpha>.\n       a @ c = x @ [N] @ y \\<and>\n       b @ c = x @ \\<alpha> @ y \\<and>\n       is_sentence x \\<and>\n       is_sentence y \\<and>\n       (N, \\<alpha>) \\<in> \\<RR> \\<and>\n       r = (N, \\<alpha>) \\<and> i = length x", "using D"], ["proof (prove)\nusing this:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)\n  Derives1 (a @ c) i r (b @ c)\n\ngoal (1 subgoal):\n 1. \\<exists>x y N \\<alpha>.\n       a @ c = x @ [N] @ y \\<and>\n       b @ c = x @ \\<alpha> @ y \\<and>\n       is_sentence x \\<and>\n       is_sentence y \\<and>\n       (N, \\<alpha>) \\<in> \\<RR> \\<and>\n       r = (N, \\<alpha>) \\<and> i = length x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x y N \\<alpha>.\n     a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and>\n     is_sentence x \\<and>\n     is_sentence y \\<and>\n     (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "then"], ["proof (chain)\npicking this:\n  \\<exists>x y N \\<alpha>.\n     a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and>\n     is_sentence x \\<and>\n     is_sentence y \\<and>\n     (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "obtain x y N \\<alpha> where split:\n    \"a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and> is_sentence x \\<and> is_sentence y \\<and> (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\""], ["proof (prove)\nusing this:\n  \\<exists>x y N \\<alpha>.\n     a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and>\n     is_sentence x \\<and>\n     is_sentence y \\<and>\n     (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. (\\<And>x N y \\<alpha>.\n        a @ c = x @ [N] @ y \\<and>\n        b @ c = x @ \\<alpha> @ y \\<and>\n        is_sentence x \\<and>\n        is_sentence y \\<and>\n        (N, \\<alpha>) \\<in> \\<RR> \\<and>\n        r = (N, \\<alpha>) \\<and> i = length x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "from split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "have \"length (a@c) = length (x @ [N] @ y)\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. length (a @ c) = length (x @ [N] @ y)", "by auto"], ["proof (state)\nthis:\n  length (a @ c) = length (x @ [N] @ y)\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "then"], ["proof (chain)\npicking this:\n  length (a @ c) = length (x @ [N] @ y)", "have \"length a + length c = length x + length y + 1\""], ["proof (prove)\nusing this:\n  length (a @ c) = length (x @ [N] @ y)\n\ngoal (1 subgoal):\n 1. length a + length c = length x + length y + 1", "by simp"], ["proof (state)\nthis:\n  length a + length c = length x + length y + 1\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "with split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length a + length c = length x + length y + 1", "have \"length a + length c = i + length y + 1\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length a + length c = length x + length y + 1\n\ngoal (1 subgoal):\n 1. length a + length c = i + length y + 1", "by simp"], ["proof (state)\nthis:\n  length a + length c = i + length y + 1\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "with i"], ["proof (chain)\npicking this:\n  i < length a\n  length a + length c = i + length y + 1", "have len_c_y: \"length c \\<le> length y\""], ["proof (prove)\nusing this:\n  i < length a\n  length a + length c = i + length y + 1\n\ngoal (1 subgoal):\n 1. length c \\<le> length y", "by arith"], ["proof (state)\nthis:\n  length c \\<le> length y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "let ?y = \"take (length y - length c) y\""], ["proof (state)\ngoal (1 subgoal):\n 1. Derives1 a i r b", "from split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "have ac: \"a @ c = (x @ [N]) @ y\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. a @ c = (x @ [N]) @ y", "by auto"], ["proof (state)\nthis:\n  a @ c = (x @ [N]) @ y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "note cancel_suffix[where a=a and c = c and b = \"x@[N]\" and d = \"y\", OF ac len_c_y]"], ["proof (state)\nthis:\n  a = (x @ [N]) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "then"], ["proof (chain)\npicking this:\n  a = (x @ [N]) @ take (length y - length c) y", "have a: \"a = x @ [N] @ ?y\""], ["proof (prove)\nusing this:\n  a = (x @ [N]) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. a = x @ [N] @ take (length y - length c) y", "by auto"], ["proof (state)\nthis:\n  a = x @ [N] @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "from split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "have bc: \"b @ c = (x @ \\<alpha>) @ y\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. b @ c = (x @ \\<alpha>) @ y", "by auto"], ["proof (state)\nthis:\n  b @ c = (x @ \\<alpha>) @ y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "note cancel_suffix[where a=b and c = c and b = \"x@\\<alpha>\" and d = \"y\", OF bc len_c_y]"], ["proof (state)\nthis:\n  b = (x @ \\<alpha>) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "then"], ["proof (chain)\npicking this:\n  b = (x @ \\<alpha>) @ take (length y - length c) y", "have b: \"b = x @ \\<alpha> @ ?y\""], ["proof (prove)\nusing this:\n  b = (x @ \\<alpha>) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. b = x @ \\<alpha> @ take (length y - length c) y", "by auto"], ["proof (state)\nthis:\n  b = x @ \\<alpha> @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "from split len_c_y a b"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length c \\<le> length y\n  a = x @ [N] @ take (length y - length c) y\n  b = x @ \\<alpha> @ take (length y - length c) y", "show ?thesis"], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length c \\<le> length y\n  a = x @ [N] @ take (length y - length c) y\n  b = x @ \\<alpha> @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. Derives1 a i r b", "apply (simp only: Derives1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa ya Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         xa @ [Na] @ ya \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         xa @ \\<alpha>' @ ya \\<and>\n                         is_sentence xa \\<and>\n                         is_sentence ya \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length xa", "apply (rule_tac x=x in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ya Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         x @ [Na] @ ya \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         x @ \\<alpha>' @ ya \\<and>\n                         is_sentence x \\<and>\n                         is_sentence ya \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length x", "apply (rule_tac x=\"?y\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         x @ [Na] @ take (length y - length c) y \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         x @ \\<alpha>' @ take (length y - length c) y \\<and>\n                         is_sentence x \\<and>\n                         is_sentence (take (length y - length c) y) \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length x", "apply (rule_tac x=\"N\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         x @ [N] @ take (length y - length c) y \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         x @ \\<alpha>' @ take (length y - length c) y \\<and>\n                         is_sentence x \\<and>\n                         is_sentence (take (length y - length c) y) \\<and>\n                         (N, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (N, \\<alpha>') \\<and>\n                         length x = length x", "apply (rule_tac x=\"\\<alpha>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> x @ [N] @ take (length y - length c) y =\n                      x @ [N] @ take (length y - length c) y \\<and>\n                      x @ \\<alpha> @ take (length y - length c) y =\n                      x @ \\<alpha> @ take (length y - length c) y \\<and>\n                      is_sentence x \\<and>\n                      is_sentence (take (length y - length c) y) \\<and>\n                      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n                      (N, \\<alpha>) = (N, \\<alpha>) \\<and>\n                      length x = length x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length c \\<le> length y;\n     a = x @ N # take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y;\n     take (length y - length c) y @ c = y; is_sentence x; is_sentence y;\n     (N, \\<alpha>) \\<in> \\<RR>; r = (N, \\<alpha>); i = length x\\<rbrakk>\n    \\<Longrightarrow> is_sentence (take (length y - length c) y)", "by (rule is_sentence_take)"], ["proof (state)\nthis:\n  Derives1 a i r b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_cancel_suffix: \"a@c = drop n (b@c) \\<Longrightarrow> a = drop n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ c = drop n (b @ c) \\<Longrightarrow> a = drop n b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a @ c = drop n (b @ c) \\<Longrightarrow> a = drop n b", "assume a1: \"a @ c = drop n (b @ c)\""], ["proof (state)\nthis:\n  a @ c = drop n (b @ c)\n\ngoal (1 subgoal):\n 1. a @ c = drop n (b @ c) \\<Longrightarrow> a = drop n b", "have \"length (drop n b) = length b + length c - n - length c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (drop n b) = length b + length c - n - length c", "by (metis add_diff_cancel_right' diff_commute length_drop)"], ["proof (state)\nthis:\n  length (drop n b) = length b + length c - n - length c\n\ngoal (1 subgoal):\n 1. a @ c = drop n (b @ c) \\<Longrightarrow> a = drop n b", "then"], ["proof (chain)\npicking this:\n  length (drop n b) = length b + length c - n - length c", "show ?thesis"], ["proof (prove)\nusing this:\n  length (drop n b) = length b + length c - n - length c\n\ngoal (1 subgoal):\n 1. a = drop n b", "using a1"], ["proof (prove)\nusing this:\n  length (drop n b) = length b + length c - n - length c\n  a @ c = drop n (b @ c)\n\ngoal (1 subgoal):\n 1. a = drop n b", "by (metis add_diff_cancel_right' append_eq_append_conv drop_append \n      length_append length_drop)"], ["proof (state)\nthis:\n  a = drop n b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_keep_last: \"u \\<noteq> [] \\<Longrightarrow> u = drop n (a@[X]) \\<Longrightarrow> u = drop n a @ [X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> []; u = drop n (a @ [X])\\<rbrakk>\n    \\<Longrightarrow> u = drop n a @ [X]", "by (metis append_take_drop_id drop_butlast last_appendR snoc_eq_iff_butlast)"], ["", "lemma Derives1_X_is_part_of_rule[consumes 2, case_names Suffix Prefix]:\n  assumes aXb: \"Derives1 \\<delta> i r (a@[X]@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  assumes prefix: \"\\<And> \\<beta>. \\<delta> = a @ [X] @ \\<beta> \\<Longrightarrow> length a < i \\<Longrightarrow> \n                     Derives1 \\<beta> (i - length a - 1) r b \\<Longrightarrow> False\"\n  assumes suffix: \"\\<And> \\<alpha>. \\<delta> = \\<alpha> @ [X] @ b \\<Longrightarrow> Derives1 \\<alpha> i r a \\<Longrightarrow> False\" \n  shows \"\\<exists> u v. a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> (snd r) = u@[X]@v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have prefix_or: \"is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>", "by (metis Derives1_prefix split aXb is_prefix_eq_proper_prefix)"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have \"is_proper_prefix a \\<alpha> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "assume proper:\"is_proper_prefix a \\<alpha>\""], ["proof (state)\nthis:\n  is_proper_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_proper_prefix a \\<alpha>", "have \"\\<exists> u. u \\<noteq> [] \\<and> \\<alpha> = a@u\""], ["proof (prove)\nusing this:\n  is_proper_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u", "by (metis is_proper_prefix_def)"], ["proof (state)\nthis:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u", "obtain u where u: \"u \\<noteq> [] \\<and> \\<alpha> = a@u\""], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<noteq> [] \\<and> \\<alpha> = a @ u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "note splits_at = splits_at_\\<alpha>[OF aXb split] splits_at_combine[OF split]"], ["proof (state)\nthis:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<alpha>1: \"\\<alpha> = take i \\<delta>\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> = take i \\<delta>", "by blast"], ["proof (state)\nthis:\n  \\<alpha> = take i \\<delta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<alpha>2: \"\\<alpha> = take i (a@[X]@b)\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> = take i (a @ [X] @ b)", "by blast"], ["proof (state)\nthis:\n  \\<alpha> = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have len\\<alpha>: \"length \\<alpha> = i\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. length \\<alpha> = i", "by blast"], ["proof (state)\nthis:\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with proper"], ["proof (chain)\npicking this:\n  is_proper_prefix a \\<alpha>\n  length \\<alpha> = i", "have lena: \"length a < i\""], ["proof (prove)\nusing this:\n  is_proper_prefix a \\<alpha>\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. length a < i", "using append_eq_conv_conj drop_eq_Nil leI u"], ["proof (prove)\nusing this:\n  is_proper_prefix a \\<alpha>\n  length \\<alpha> = i\n  (?xs @ ?ys = ?zs) =\n  (?xs = take (length ?xs) ?zs \\<and> ?ys = drop (length ?xs) ?zs)\n  (drop ?n ?xs = []) = (length ?xs \\<le> ?n)\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. length a < i", "by auto"], ["proof (state)\nthis:\n  length a < i\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from u \\<alpha>2"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  \\<alpha> = take i (a @ [X] @ b)", "have \"a@u = take i (a@[X]@b)\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  \\<alpha> = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. a @ u = take i (a @ [X] @ b)", "by auto"], ["proof (state)\nthis:\n  a @ u = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with lena"], ["proof (chain)\npicking this:\n  length a < i\n  a @ u = take i (a @ [X] @ b)", "have \"u = take (i - length a) ([X]@b)\""], ["proof (prove)\nusing this:\n  length a < i\n  a @ u = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. u = take (i - length a) ([X] @ b)", "by (simp add: less_or_eq_imp_le)"], ["proof (state)\nthis:\n  u = take (i - length a) ([X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with lena"], ["proof (chain)\npicking this:\n  length a < i\n  u = take (i - length a) ([X] @ b)", "have uX: \"u = [X]@(take (i - length a - 1) b)\""], ["proof (prove)\nusing this:\n  length a < i\n  u = take (i - length a) ([X] @ b)\n\ngoal (1 subgoal):\n 1. u = [X] @ take (i - length a - 1) b", "by (simp add: not_less take_Cons')"], ["proof (state)\nthis:\n  u = [X] @ take (i - length a - 1) b\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "let ?\\<beta> = \"(take (i - length a - 1) b) @ [N] @ \\<beta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f1: \"\\<delta> = \\<alpha> @ [N] @ \\<beta>\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = \\<alpha> @ [N] @ \\<beta>", "by blast"], ["proof (state)\nthis:\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with u uX"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  u = [X] @ take (i - length a - 1) b\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f2: \"\\<delta> = a @ [X] @ ?\\<beta>\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  u = [X] @ take (i - length a - 1) b\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = a @ [X] @ take (i - length a - 1) b @ [N] @ \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<delta> = a @ [X] @ take (i - length a - 1) b @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "note skip = Derives1_skip_prefix[where a = \"a @ [X]\" and b = \"?\\<beta>\" and \n      r = r and i = i and c = b]"], ["proof (state)\nthis:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   Derives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> Derives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   Derives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> Derives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b", "have D: \"Derives1 ?\\<beta> (i - length a - 1) r b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   Derives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> Derives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b\n\ngoal (1 subgoal):\n 1. Derives1 (take (i - length a - 1) b @ [N] @ \\<beta>) (i - length a - 1)\n     r b", "using One_nat_def Suc_leI aXb append_assoc diff_diff_left f2 lena length_Cons \n        length_append length_append_singleton list.size(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   Derives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> Derives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b\n  1 = Suc 0\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  Derives1 \\<delta> i r (a @ [X] @ b)\n  (?xs @ ?ys) @ ?zs = ?xs @ ?ys @ ?zs\n  ?i - ?j - ?k = ?i - (?j + ?k)\n  \\<delta> = a @ [X] @ take (i - length a - 1) b @ [N] @ \\<beta>\n  length a < i\n  length (?x # ?xs) = Suc (length ?xs)\n  length (?xs @ ?ys) = length ?xs + length ?ys\n  length (?xs @ [?x]) = Suc (length ?xs)\n  length [] = 0\n\ngoal (1 subgoal):\n 1. Derives1 (take (i - length a - 1) b @ [N] @ \\<beta>) (i - length a - 1)\n     r b", "by fastforce"], ["proof (state)\nthis:\n  Derives1 (take (i - length a - 1) b @ [N] @ \\<beta>) (i - length a - 1) r\n   b\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "note prefix[OF f2 lena D]"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  False", "show \"False\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_proper_prefix a \\<alpha> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "with prefix_or"], ["proof (chain)\npicking this:\n  is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\n  is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "have is_prefix: \"is_prefix \\<alpha> a\""], ["proof (prove)\nusing this:\n  is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\n  is_proper_prefix a \\<alpha> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a", "by blast"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from aXb"], ["proof (chain)\npicking this:\n  Derives1 \\<delta> i r (a @ [X] @ b)", "have aXb': \"Derives1 \\<delta> i r ((a@[X])@b)\""], ["proof (prove)\nusing this:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. Derives1 \\<delta> i r ((a @ [X]) @ b)", "by auto"], ["proof (state)\nthis:\n  Derives1 \\<delta> i r ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "note  Derives1_suffix[OF aXb' split]"], ["proof (state)\nthis:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "have suffix_or: \"is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\""], ["proof (prove)\nusing this:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>", "by (metis is_suffix_eq_proper_suffix)"], ["proof (state)\nthis:\n  is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have \"is_proper_suffix b \\<beta> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "assume proper: \"is_proper_suffix b \\<beta>\""], ["proof (state)\nthis:\n  is_proper_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_proper_suffix b \\<beta>", "have \"\\<exists> u. u \\<noteq> [] \\<and> \\<beta> = u@b\""], ["proof (prove)\nusing this:\n  is_proper_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b", "by (metis is_proper_suffix_def)"], ["proof (state)\nthis:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b", "obtain u where u: \"u \\<noteq> [] \\<and> \\<beta> = u@b\""], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<noteq> [] \\<and> \\<beta> = u @ b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note splits_at = splits_at_\\<beta>[OF aXb split] splits_at_combine[OF split]"], ["proof (state)\nthis:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<beta>1: \"\\<beta> = drop (Suc i) \\<delta>\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> = drop (Suc i) \\<delta>", "by blast"], ["proof (state)\nthis:\n  \\<beta> = drop (Suc i) \\<delta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<beta>2: \"\\<beta> = drop (i + length (snd r)) (a @ [X] @ b)\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)", "by blast"], ["proof (state)\nthis:\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have len\\<beta>: \"length \\<beta> = length \\<delta> - i - 1\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. length \\<beta> = length \\<delta> - i - 1", "by blast"], ["proof (state)\nthis:\n  length \\<beta> = length \\<delta> - i - 1\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "with proper"], ["proof (chain)\npicking this:\n  is_proper_suffix b \\<beta>\n  length \\<beta> = length \\<delta> - i - 1", "have lenb: \"length b < length \\<beta>\""], ["proof (prove)\nusing this:\n  is_proper_suffix b \\<beta>\n  length \\<beta> = length \\<delta> - i - 1\n\ngoal (1 subgoal):\n 1. length b < length \\<beta>", "by (metis is_proper_suffix_length_cmp)"], ["proof (state)\nthis:\n  length b < length \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from u \\<beta>2"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)", "have \"u@b = drop (i + length (snd r)) ((a @ [X]) @ b)\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. u @ b = drop (i + length (snd r)) ((a @ [X]) @ b)", "by auto"], ["proof (state)\nthis:\n  u @ b = drop (i + length (snd r)) ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "hence \"u = drop (i + length (snd r)) (a @ [X])\""], ["proof (prove)\nusing this:\n  u @ b = drop (i + length (snd r)) ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. u = drop (i + length (snd r)) (a @ [X])", "by (metis drop_cancel_suffix)"], ["proof (state)\nthis:\n  u = drop (i + length (snd r)) (a @ [X])\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "hence uX: \"u = drop (i + length (snd r)) a @ [X]\""], ["proof (prove)\nusing this:\n  u = drop (i + length (snd r)) (a @ [X])\n\ngoal (1 subgoal):\n 1. u = drop (i + length (snd r)) a @ [X]", "by (metis drop_keep_last u)"], ["proof (state)\nthis:\n  u = drop (i + length (snd r)) a @ [X]\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "let ?\\<alpha> = \"\\<alpha> @ [N] @ (drop (i + length (snd r)) a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f1: \"\\<delta> = \\<alpha> @ [N] @ \\<beta>\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = \\<alpha> @ [N] @ \\<beta>", "by blast"], ["proof (state)\nthis:\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "with u uX"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  u = drop (i + length (snd r)) a @ [X]\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f2: \"\\<delta> = ?\\<alpha> @ [X] @ b\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  u = drop (i + length (snd r)) a @ [X]\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b", "by simp"], ["proof (state)\nthis:\n  \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note skip = Derives1_skip_suffix[where a = \"?\\<alpha>\" and c = \"[X]@b\" and b=\"a\" and\n      r = r and i = i]"], ["proof (state)\nthis:\n  \\<lbrakk>i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a);\n   Derives1 ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) i r\n    (a @ [X] @ b)\\<rbrakk>\n  \\<Longrightarrow> Derives1 (\\<alpha> @ [N] @ drop (i + length (snd r)) a)\n                     i r a\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "have f3: \"i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "have f1: \"1 + i + length b = length [X] + length b + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + i + length b = length [X] + length b + i", "by (metis Groups.add_ac(2) Suc_eq_plus1_left length_Cons list.size(3) list.size(4) semiring_normalization_rules(22))"], ["proof (state)\nthis:\n  1 + i + length b = length [X] + length b + i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "have f2: \"length \\<delta> - i - 1 = length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) - Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<delta> - i - 1 =\n    length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) -\n    Suc i", "by (metis f2 length_drop splits_at(1))"], ["proof (state)\nthis:\n  length \\<delta> - i - 1 =\n  length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) - Suc i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "have \"length ([]::symbol list) \\<noteq> length \\<delta> - i - 1 - length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] \\<noteq> length \\<delta> - i - 1 - length b", "by (metis add_diff_cancel_right' append_Nil2 append_eq_append_conv len\\<beta> length_append u)"], ["proof (state)\nthis:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "then"], ["proof (chain)\npicking this:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b", "have \"length ([]::symbol list) \\<noteq> length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i\""], ["proof (prove)\nusing this:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b\n\ngoal (1 subgoal):\n 1. length [] \\<noteq>\n    length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i", "using f2 f1"], ["proof (prove)\nusing this:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b\n  length \\<delta> - i - 1 =\n  length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) - Suc i\n  1 + i + length b = length [X] + length b + i\n\ngoal (1 subgoal):\n 1. length [] \\<noteq>\n    length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i", "by (metis Suc_eq_plus1_left add_diff_cancel_right' diff_diff_left length_append)"], ["proof (state)\nthis:\n  length [] \\<noteq>\n  length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "then"], ["proof (chain)\npicking this:\n  length [] \\<noteq>\n  length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i", "show ?thesis"], ["proof (prove)\nusing this:\n  length [] \\<noteq>\n  length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "by auto"], ["proof (state)\nthis:\n  i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from aXb f2"], ["proof (chain)\npicking this:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n  \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b", "have D: \"Derives1 (?\\<alpha> @ [X] @ b) i r (a@[X]@b)\""], ["proof (prove)\nusing this:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n  \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b\n\ngoal (1 subgoal):\n 1. Derives1 ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) i r\n     (a @ [X] @ b)", "by auto"], ["proof (state)\nthis:\n  Derives1 ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) i r\n   (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note skip[OF f3 D]"], ["proof (state)\nthis:\n  Derives1 (\\<alpha> @ [N] @ drop (i + length (snd r)) a) i r a\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note suffix[OF f2  skip[OF f3 D]]"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  False", "show \"False\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_proper_suffix b \\<beta> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "with suffix_or"], ["proof (chain)\npicking this:\n  is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\n  is_proper_suffix b \\<beta> \\<Longrightarrow> False", "have is_suffix: \"is_suffix \\<beta> b\""], ["proof (prove)\nusing this:\n  is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\n  is_proper_suffix b \\<beta> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b", "by blast"], ["proof (state)\nthis:\n  is_suffix \\<beta> b\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from is_prefix"], ["proof (chain)\npicking this:\n  is_prefix \\<alpha> a", "have \"\\<exists> u. a = \\<alpha> @ u\""], ["proof (prove)\nusing this:\n  is_prefix \\<alpha> a\n\ngoal (1 subgoal):\n 1. \\<exists>u. a = \\<alpha> @ u", "by (auto simp add: is_prefix_def)"], ["proof (state)\nthis:\n  \\<exists>u. a = \\<alpha> @ u\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. a = \\<alpha> @ u", "obtain u where u: \"a = \\<alpha> @ u\""], ["proof (prove)\nusing this:\n  \\<exists>u. a = \\<alpha> @ u\n\ngoal (1 subgoal):\n 1. (\\<And>u. a = \\<alpha> @ u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = \\<alpha> @ u\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from is_suffix"], ["proof (chain)\npicking this:\n  is_suffix \\<beta> b", "have \"\\<exists> v. b = v @ \\<beta>\""], ["proof (prove)\nusing this:\n  is_suffix \\<beta> b\n\ngoal (1 subgoal):\n 1. \\<exists>v. b = v @ \\<beta>", "by (auto simp add: is_suffix_def)"], ["proof (state)\nthis:\n  \\<exists>v. b = v @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. b = v @ \\<beta>", "obtain v where v: \"b = v @ \\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>v. b = v @ \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>v. b = v @ \\<beta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b = v @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from u v splits_at_combine[OF split] aXb"], ["proof (chain)\npicking this:\n  a = \\<alpha> @ u\n  b = v @ \\<beta>\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n  Derives1 \\<delta> i r (a @ [X] @ b)", "have D:\"Derives1 (\\<alpha>@[N]@\\<beta>) i r (\\<alpha>@(u@[X]@v)@\\<beta>)\""], ["proof (prove)\nusing this:\n  a = \\<alpha> @ u\n  b = v @ \\<beta>\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n  Derives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. Derives1 (\\<alpha> @ [N] @ \\<beta>) i r\n     (\\<alpha> @ (u @ [X] @ v) @ \\<beta>)", "by simp"], ["proof (state)\nthis:\n  Derives1 (\\<alpha> @ [N] @ \\<beta>) i r\n   (\\<alpha> @ (u @ [X] @ v) @ \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from splits_at_\\<alpha>[OF aXb split]"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i", "have i: \"length \\<alpha> = i\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. length \\<alpha> = i", "by blast"], ["proof (state)\nthis:\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from i"], ["proof (chain)\npicking this:\n  length \\<alpha> = i", "have i1: \"length \\<alpha> \\<le> i\" and i2: \"i \\<le> length \\<alpha>\""], ["proof (prove)\nusing this:\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> i &&& i \\<le> length \\<alpha>", "by auto"], ["proof (state)\nthis:\n  length \\<alpha> \\<le> i\n  i \\<le> length \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "note Derives1_skip_suffix[OF _ Derives1_skip_prefix[OF i1 D], simplified, OF i2]"], ["proof (state)\nthis:\n  Derives1 [N] 0 r (u @ X # v)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  Derives1 [N] 0 r (u @ X # v)", "have \"Derives1 [N] 0 r (u @ [X] @ v)\""], ["proof (prove)\nusing this:\n  Derives1 [N] 0 r (u @ X # v)\n\ngoal (1 subgoal):\n 1. Derives1 [N] 0 r (u @ [X] @ v)", "by auto"], ["proof (state)\nthis:\n  Derives1 [N] 0 r (u @ [X] @ v)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  Derives1 [N] 0 r (u @ [X] @ v)", "have r: \"snd r = u @ [X] @ v\""], ["proof (prove)\nusing this:\n  Derives1 [N] 0 r (u @ [X] @ v)\n\ngoal (1 subgoal):\n 1. snd r = u @ [X] @ v", "by (metis Derives1_split append_Cons append_Nil length_0_conv list.inject self_append_conv)"], ["proof (state)\nthis:\n  snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "using u v r"], ["proof (prove)\nusing this:\n  a = \\<alpha> @ u\n  b = v @ \\<beta>\n  snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "by auto"], ["proof (state)\nthis:\n  \\<exists>u v.\n     a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<L>\\<^sub>P_derives: \"a \\<in> \\<L>\\<^sub>P \\<Longrightarrow> \\<exists> b. derives [\\<SS>] (a@b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<L>\\<^sub>P \\<Longrightarrow>\n    \\<exists>b. derives [\\<SS>] (a @ b)", "by (simp add: \\<L>\\<^sub>P_def is_derivation_def)"], ["", "lemma \\<L>\\<^sub>P_leftderives: \"a \\<in> \\<L>\\<^sub>P \\<Longrightarrow> \\<exists> b. leftderives [\\<SS>] (a@b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<L>\\<^sub>P \\<Longrightarrow>\n    \\<exists>b. leftderives [\\<SS>] (a @ b)", "by (metis \\<L>\\<^sub>P_derives \\<L>\\<^sub>P_is_word derives_implies_leftderives_gen)"], ["", "lemma Derives1_rule: \"Derives1 a i r b \\<Longrightarrow> r \\<in> \\<RR>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 a i r b \\<Longrightarrow> r \\<in> \\<RR>", "by (auto simp add: Derives1_def)"], ["", "lemma is_prefix_empty[simp]: \"is_prefix [] a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix [] a", "by (simp add: is_prefix_def)"], ["", "lemma is_prefix_cons: \"is_prefix (x # a) b = (\\<exists> c. b = x # c \\<and> is_prefix a c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix (x # a) b = (\\<exists>c. b = x # c \\<and> is_prefix a c)", "by (metis append_Cons is_prefix_def)"], ["", "lemma is_prefix_cancel[simp]: \"is_prefix (a@b) (a@c) = is_prefix b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix (a @ b) (a @ c) = is_prefix b c", "by (metis append_assoc is_prefix_def same_append_eq)"], ["", "lemma is_prefix_chars: \"is_prefix a b \\<Longrightarrow> is_prefix (chars a) (chars b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix a b \\<Longrightarrow> is_prefix (chars a) (chars b)", "proof (induct a arbitrary: b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b. is_prefix [] b \\<Longrightarrow> is_prefix (chars []) (chars b)\n 2. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   is_prefix a2 b \\<Longrightarrow>\n                   is_prefix (chars a2) (chars b);\n        is_prefix (a1 # a2) b\\<rbrakk>\n       \\<Longrightarrow> is_prefix (chars (a1 # a2)) (chars b)", "case Nil"], ["proof (state)\nthis:\n  is_prefix [] b\n\ngoal (2 subgoals):\n 1. \\<And>b. is_prefix [] b \\<Longrightarrow> is_prefix (chars []) (chars b)\n 2. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   is_prefix a2 b \\<Longrightarrow>\n                   is_prefix (chars a2) (chars b);\n        is_prefix (a1 # a2) b\\<rbrakk>\n       \\<Longrightarrow> is_prefix (chars (a1 # a2)) (chars b)", "thus ?case"], ["proof (prove)\nusing this:\n  is_prefix [] b\n\ngoal (1 subgoal):\n 1. is_prefix (chars []) (chars b)", "by simp"], ["proof (state)\nthis:\n  is_prefix (chars []) (chars b)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   is_prefix a2 b \\<Longrightarrow>\n                   is_prefix (chars a2) (chars b);\n        is_prefix (a1 # a2) b\\<rbrakk>\n       \\<Longrightarrow> is_prefix (chars (a1 # a2)) (chars b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   is_prefix a2 b \\<Longrightarrow>\n                   is_prefix (chars a2) (chars b);\n        is_prefix (a1 # a2) b\\<rbrakk>\n       \\<Longrightarrow> is_prefix (chars (a1 # a2)) (chars b)", "case (Cons x a)"], ["proof (state)\nthis:\n  is_prefix a ?b \\<Longrightarrow> is_prefix (chars a) (chars ?b)\n  is_prefix (x # a) b\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   is_prefix a2 b \\<Longrightarrow>\n                   is_prefix (chars a2) (chars b);\n        is_prefix (a1 # a2) b\\<rbrakk>\n       \\<Longrightarrow> is_prefix (chars (a1 # a2)) (chars b)", "from Cons(2)"], ["proof (chain)\npicking this:\n  is_prefix (x # a) b", "have \"\\<exists> c. b = x # c \\<and> is_prefix a c\""], ["proof (prove)\nusing this:\n  is_prefix (x # a) b\n\ngoal (1 subgoal):\n 1. \\<exists>c. b = x # c \\<and> is_prefix a c", "by (simp add: is_prefix_cons)"], ["proof (state)\nthis:\n  \\<exists>c. b = x # c \\<and> is_prefix a c\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   is_prefix a2 b \\<Longrightarrow>\n                   is_prefix (chars a2) (chars b);\n        is_prefix (a1 # a2) b\\<rbrakk>\n       \\<Longrightarrow> is_prefix (chars (a1 # a2)) (chars b)", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. b = x # c \\<and> is_prefix a c", "obtain c where c: \"b = x # c \\<and> is_prefix a c\""], ["proof (prove)\nusing this:\n  \\<exists>c. b = x # c \\<and> is_prefix a c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        b = x # c \\<and> is_prefix a c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b = x # c \\<and> is_prefix a c\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   is_prefix a2 b \\<Longrightarrow>\n                   is_prefix (chars a2) (chars b);\n        is_prefix (a1 # a2) b\\<rbrakk>\n       \\<Longrightarrow> is_prefix (chars (a1 # a2)) (chars b)", "from c Cons(1)"], ["proof (chain)\npicking this:\n  b = x # c \\<and> is_prefix a c\n  is_prefix a ?b \\<Longrightarrow> is_prefix (chars a) (chars ?b)", "show ?case"], ["proof (prove)\nusing this:\n  b = x # c \\<and> is_prefix a c\n  is_prefix a ?b \\<Longrightarrow> is_prefix (chars a) (chars ?b)\n\ngoal (1 subgoal):\n 1. is_prefix (chars (x # a)) (chars b)", "by simp"], ["proof (state)\nthis:\n  is_prefix (chars (x # a)) (chars b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_prefix_length: \"is_prefix a b \\<Longrightarrow> length a \\<le> length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix a b \\<Longrightarrow> length a \\<le> length b", "by (auto simp add: is_prefix_def)"], ["", "lemma is_prefix_take[simp]: \"is_prefix (take n a) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix (take n a) a", "apply (auto simp add: is_prefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. take n a @ w = a", "apply (rule_tac x=\"drop n a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take n a @ drop n a = a", "by simp"], ["", "lemma doc_tokens_length: \"doc_tokens p \\<Longrightarrow> length (chars p) \\<le> length Doc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doc_tokens p \\<Longrightarrow> length (chars p) \\<le> length Doc", "by (metis doc_tokens_def is_prefix_length)"], ["", "fun count_terminals :: \"sentence \\<Rightarrow> nat\" where\n  \"count_terminals [] = 0\"\n| \"count_terminals (x#xs) = (if (is_terminal x) then Suc (count_terminals xs) else (count_terminals xs))\""], ["", "lemma count_terminals_upper_bound: \"count_terminals p \\<le> length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_terminals p \\<le> length p", "by (induct p, auto)"], ["", "lemma count_terminals_append[simp]: \"count_terminals (a@b) = count_terminals a + count_terminals b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_terminals (a @ b) = count_terminals a + count_terminals b", "by (induct a arbitrary: b, auto)"], ["", "lemma Derives1_count_terminals:\n  assumes D: \"Derives1 a i r b\"\n  shows \"count_terminals b = count_terminals a + count_terminals (snd r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "have \"\\<exists> \\<alpha> N \\<beta>. splits_at a i \\<alpha> N \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha> N \\<beta>. splits_at a i \\<alpha> N \\<beta>", "using D splits_at_ex"], ["proof (prove)\nusing this:\n  Derives1 a i r b\n  Derives1 ?\\<delta> ?i ?r ?s \\<Longrightarrow>\n  \\<exists>\\<alpha> N \\<beta>. splits_at ?\\<delta> ?i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha> N \\<beta>. splits_at a i \\<alpha> N \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<exists>\\<alpha> N \\<beta>. splits_at a i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha> N \\<beta>. splits_at a i \\<alpha> N \\<beta>", "obtain \\<alpha> N \\<beta> where split: \"splits_at a i \\<alpha> N \\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha> N \\<beta>. splits_at a i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> N \\<beta>.\n        splits_at a i \\<alpha> N \\<beta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at a i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "from D split"], ["proof (chain)\npicking this:\n  Derives1 a i r b\n  splits_at a i \\<alpha> N \\<beta>", "have N: \"is_nonterminal N\""], ["proof (prove)\nusing this:\n  Derives1 a i r b\n  splits_at a i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. is_nonterminal N", "by (simp add: Derives1_nonterminal)"], ["proof (state)\nthis:\n  is_nonterminal N\n\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "have a: \"a = \\<alpha> @ [N] @ \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = \\<alpha> @ [N] @ \\<beta>", "by (metis split splits_at_combine)"], ["proof (state)\nthis:\n  a = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "from D split"], ["proof (chain)\npicking this:\n  Derives1 a i r b\n  splits_at a i \\<alpha> N \\<beta>", "have b: \"b = \\<alpha> @ (snd r) @ \\<beta>\""], ["proof (prove)\nusing this:\n  Derives1 a i r b\n  splits_at a i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. b = \\<alpha> @ snd r @ \\<beta>", "using splits_at_combine_dest"], ["proof (prove)\nusing this:\n  Derives1 a i r b\n  splits_at a i \\<alpha> N \\<beta>\n  \\<lbrakk>Derives1 ?a ?i ?r ?b;\n   splits_at ?a ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?b = ?\\<alpha> @ snd ?r @ ?\\<beta>\n\ngoal (1 subgoal):\n 1. b = \\<alpha> @ snd r @ \\<beta>", "by simp"], ["proof (state)\nthis:\n  b = \\<alpha> @ snd r @ \\<beta>\n\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_terminals b = count_terminals a + count_terminals (snd r)", "apply (simp add: a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_terminal N", "using N"], ["proof (prove)\nusing this:\n  is_nonterminal N\n\ngoal (1 subgoal):\n 1. \\<not> is_terminal N", "by (metis is_terminal_nonterminal)"], ["proof (state)\nthis:\n  count_terminals b = count_terminals a + count_terminals (snd r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Derives1_count_terminals_leq:\n  assumes D: \"Derives1 a i r b\"\n  shows \"count_terminals a \\<le> count_terminals b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_terminals a \\<le> count_terminals b", "by (metis Derives1_count_terminals assms le_less_linear not_add_less1)"], ["", "lemma Derivation_count_terminals_leq:\n  \"Derivation a E b \\<Longrightarrow> count_terminals a \\<le> count_terminals b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derivation a E b \\<Longrightarrow>\n    count_terminals a \\<le> count_terminals b", "proof (induct E arbitrary: a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       Derivation a [] b \\<Longrightarrow>\n       count_terminals a \\<le> count_terminals b\n 2. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "case Nil"], ["proof (state)\nthis:\n  Derivation a [] b\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       Derivation a [] b \\<Longrightarrow>\n       count_terminals a \\<le> count_terminals b\n 2. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "thus ?case"], ["proof (prove)\nusing this:\n  Derivation a [] b\n\ngoal (1 subgoal):\n 1. count_terminals a \\<le> count_terminals b", "by auto"], ["proof (state)\nthis:\n  count_terminals a \\<le> count_terminals b\n\ngoal (1 subgoal):\n 1. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "case (Cons e E)"], ["proof (state)\nthis:\n  Derivation ?a E b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals b\n  Derivation a (e # E) b\n\ngoal (1 subgoal):\n 1. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "then"], ["proof (chain)\npicking this:\n  Derivation ?a E b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals b\n  Derivation a (e # E) b", "have \"\\<exists> x i r. Derives1 a i r x \\<and> Derivation x E b\""], ["proof (prove)\nusing this:\n  Derivation ?a E b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals b\n  Derivation a (e # E) b\n\ngoal (1 subgoal):\n 1. \\<exists>x i r. Derives1 a i r x \\<and> Derivation x E b", "using Derivation.simps(2)"], ["proof (prove)\nusing this:\n  Derivation ?a E b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals b\n  Derivation a (e # E) b\n  Derivation ?a (?d # ?D) ?b =\n  (\\<exists>x. Derives1 ?a (fst ?d) (snd ?d) x \\<and> Derivation x ?D ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>x i r. Derives1 a i r x \\<and> Derivation x E b", "by blast"], ["proof (state)\nthis:\n  \\<exists>x i r. Derives1 a i r x \\<and> Derivation x E b\n\ngoal (1 subgoal):\n 1. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "then"], ["proof (chain)\npicking this:\n  \\<exists>x i r. Derives1 a i r x \\<and> Derivation x E b", "obtain x i r where axb: \"Derives1 a i r x \\<and> Derivation x E b\""], ["proof (prove)\nusing this:\n  \\<exists>x i r. Derives1 a i r x \\<and> Derivation x E b\n\ngoal (1 subgoal):\n 1. (\\<And>i r x.\n        Derives1 a i r x \\<and> Derivation x E b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Derives1 a i r x \\<and> Derivation x E b\n\ngoal (1 subgoal):\n 1. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "from axb"], ["proof (chain)\npicking this:\n  Derives1 a i r x \\<and> Derivation x E b", "have ax: \"count_terminals a \\<le> count_terminals x\""], ["proof (prove)\nusing this:\n  Derives1 a i r x \\<and> Derivation x E b\n\ngoal (1 subgoal):\n 1. count_terminals a \\<le> count_terminals x", "using Derives1_count_terminals_leq"], ["proof (prove)\nusing this:\n  Derives1 a i r x \\<and> Derivation x E b\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals ?b\n\ngoal (1 subgoal):\n 1. count_terminals a \\<le> count_terminals x", "by blast"], ["proof (state)\nthis:\n  count_terminals a \\<le> count_terminals x\n\ngoal (1 subgoal):\n 1. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "from axb"], ["proof (chain)\npicking this:\n  Derives1 a i r x \\<and> Derivation x E b", "have xb: \"count_terminals x \\<le> count_terminals b\""], ["proof (prove)\nusing this:\n  Derives1 a i r x \\<and> Derivation x E b\n\ngoal (1 subgoal):\n 1. count_terminals x \\<le> count_terminals b", "using Cons"], ["proof (prove)\nusing this:\n  Derives1 a i r x \\<and> Derivation x E b\n  Derivation ?a E b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals b\n  Derivation a (e # E) b\n\ngoal (1 subgoal):\n 1. count_terminals x \\<le> count_terminals b", "by simp"], ["proof (state)\nthis:\n  count_terminals x \\<le> count_terminals b\n\ngoal (1 subgoal):\n 1. \\<And>a E aa.\n       \\<lbrakk>\\<And>a.\n                   Derivation a E b \\<Longrightarrow>\n                   count_terminals a \\<le> count_terminals b;\n        Derivation aa (a # E) b\\<rbrakk>\n       \\<Longrightarrow> count_terminals aa \\<le> count_terminals b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_terminals a \\<le> count_terminals b", "using ax xb"], ["proof (prove)\nusing this:\n  count_terminals a \\<le> count_terminals x\n  count_terminals x \\<le> count_terminals b\n\ngoal (1 subgoal):\n 1. count_terminals a \\<le> count_terminals b", "by arith"], ["proof (state)\nthis:\n  count_terminals a \\<le> count_terminals b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derives_count_terminals_leq: \"derives a b \\<Longrightarrow> count_terminals a \\<le> count_terminals b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derives a b \\<Longrightarrow> count_terminals a \\<le> count_terminals b", "using Derivation_count_terminals_leq derives_implies_Derivation"], ["proof (prove)\nusing this:\n  Derivation ?a ?E ?b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals ?b\n  derives ?a ?b \\<Longrightarrow> \\<exists>D. Derivation ?a D ?b\n\ngoal (1 subgoal):\n 1. derives a b \\<Longrightarrow> count_terminals a \\<le> count_terminals b", "by force"], ["", "lemma is_word_cons[simp]: \"is_word (x#xs) = (is_terminal x \\<and> is_word xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_word (x # xs) = (is_terminal x \\<and> is_word xs)", "by (simp add: is_word_def)"], ["", "lemma count_terminals_of_word: \"is_word w \\<Longrightarrow> count_terminals w = length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_word w \\<Longrightarrow> count_terminals w = length w", "by (induct w, auto)"], ["", "lemma length_terminals[simp]: \"length (terminals p) = length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (terminals p) = length p", "by (auto simp add: terminals_def)"], ["", "lemma path_length_is_upper_bound:\n  assumes p: \"wellformed_tokens p\"\n  assumes \\<alpha>: \"is_word \\<alpha>\"\n  assumes derives: \"derives (\\<alpha>@u) (terminals p)\"\n  shows \"length \\<alpha> \\<le> length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "have counts: \"count_terminals \\<alpha> \\<le> count_terminals (terminals p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_terminals \\<alpha> \\<le> count_terminals (terminals p)", "using derives derives_count_terminals_leq"], ["proof (prove)\nusing this:\n  derives (\\<alpha> @ u) (terminals p)\n  derives ?a ?b \\<Longrightarrow>\n  count_terminals ?a \\<le> count_terminals ?b\n\ngoal (1 subgoal):\n 1. count_terminals \\<alpha> \\<le> count_terminals (terminals p)", "by fastforce"], ["proof (state)\nthis:\n  count_terminals \\<alpha> \\<le> count_terminals (terminals p)\n\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "have len1: \"length \\<alpha> = count_terminals \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<alpha> = count_terminals \\<alpha>", "by (simp add: \\<alpha> count_terminals_of_word)"], ["proof (state)\nthis:\n  length \\<alpha> = count_terminals \\<alpha>\n\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "have len2: \"length (terminals p) = count_terminals (terminals p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (terminals p) = count_terminals (terminals p)", "by (simp add: count_terminals_of_word is_word_terminals p)"], ["proof (state)\nthis:\n  length (terminals p) = count_terminals (terminals p)\n\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "using counts len1 len2"], ["proof (prove)\nusing this:\n  count_terminals \\<alpha> \\<le> count_terminals (terminals p)\n  length \\<alpha> = count_terminals \\<alpha>\n  length (terminals p) = count_terminals (terminals p)\n\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "by auto"], ["proof (state)\nthis:\n  length \\<alpha> \\<le> length p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_word_Derives1_index:\n  assumes w: \"is_word w\"\n  assumes derives1: \"Derives1 (w@a) i r b\"\n  shows \"i \\<ge> length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w \\<le> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length w \\<le> i", "from derives1"], ["proof (chain)\npicking this:\n  Derives1 (w @ a) i r b", "have n: \"is_nonterminal ((w@a) ! i)\""], ["proof (prove)\nusing this:\n  Derives1 (w @ a) i r b\n\ngoal (1 subgoal):\n 1. is_nonterminal ((w @ a) ! i)", "using Derives1_nonterminal splits_at_def splits_at_ex"], ["proof (prove)\nusing this:\n  Derives1 (w @ a) i r b\n  \\<lbrakk>Derives1 ?a ?i ?r ?b;\n   splits_at ?a ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> fst ?r = ?N \\<and> is_nonterminal ?N\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n  Derives1 ?\\<delta> ?i ?r ?s \\<Longrightarrow>\n  \\<exists>\\<alpha> N \\<beta>. splits_at ?\\<delta> ?i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. is_nonterminal ((w @ a) ! i)", "by auto"], ["proof (state)\nthis:\n  is_nonterminal ((w @ a) ! i)\n\ngoal (1 subgoal):\n 1. length w \\<le> i", "from w"], ["proof (chain)\npicking this:\n  is_word w", "have t: \"i < length w \\<Longrightarrow> is_terminal ((w@a) ! i)\""], ["proof (prove)\nusing this:\n  is_word w\n\ngoal (1 subgoal):\n 1. i < length w \\<Longrightarrow> is_terminal ((w @ a) ! i)", "by (simp add: is_word_is_terminal nth_append)"], ["proof (state)\nthis:\n  i < length w \\<Longrightarrow> is_terminal ((w @ a) ! i)\n\ngoal (1 subgoal):\n 1. length w \\<le> i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length w \\<le> i", "by (metis t n is_terminal_nonterminal less_le_not_le nat_le_linear)"], ["proof (state)\nthis:\n  length w \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_word_Derivation_derivation_ge:\n  assumes w: \"is_word w\"\n  assumes D: \"Derivation (w@a) D b\"\n  shows \"derivation_ge D (length w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge D (length w)", "by (metis D Derivation_leftmost derivation_ge_empty leftmost_Derivation leftmost_append w)"], ["", "lemma derives_word_is_prefix:\n  assumes w: \"is_word w\"\n  assumes derives: \"derives (w@a) b\"\n  shows \"is_prefix w b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix w b", "by (metis Derivation_take append_eq_conv_conj derives derives_implies_Derivation \n    is_prefix_take is_word_Derivation_derivation_ge w)"], ["", "lemma terminals_take[simp]: \"terminals (take n p) = take n (terminals p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminals (take n p) = take n (terminals p)", "by (simp add: take_map terminals_def)"], ["", "lemma terminals_drop[simp]: \"terminals (drop n p) = drop n (terminals p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminals (drop n p) = drop n (terminals p)", "by (simp add: drop_map terminals_def)"], ["", "lemma take_prefix[simp]: \"is_prefix a b \\<Longrightarrow> take (length a) b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix a b \\<Longrightarrow> take (length a) b = a", "by (metis append_eq_conv_conj is_prefix_unsplit)"], ["", "lemma Derives1_drop_prefixword: \n  assumes w: \"is_word w\"\n  assumes wa_b: \"Derives1 (w@a) i r b\"\n  shows \"Derives1 a (i - length w) r (drop (length w) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 a (i - length w) r (drop (length w) b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Derives1 a (i - length w) r (drop (length w) b)", "have i: \"length w \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w \\<le> i", "using wa_b is_word_Derives1_index w"], ["proof (prove)\nusing this:\n  Derives1 (w @ a) i r b\n  \\<lbrakk>is_word ?w; Derives1 (?w @ ?a) ?i ?r ?b\\<rbrakk>\n  \\<Longrightarrow> length ?w \\<le> ?i\n  is_word w\n\ngoal (1 subgoal):\n 1. length w \\<le> i", "by blast"], ["proof (state)\nthis:\n  length w \\<le> i\n\ngoal (1 subgoal):\n 1. Derives1 a (i - length w) r (drop (length w) b)", "have \"is_prefix w b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix w b", "by (metis append_eq_conv_conj i is_prefix_take le_Derives1_take wa_b)"], ["proof (state)\nthis:\n  is_prefix w b\n\ngoal (1 subgoal):\n 1. Derives1 a (i - length w) r (drop (length w) b)", "then"], ["proof (chain)\npicking this:\n  is_prefix w b", "have b: \"b = w @ (drop (length w) b)\""], ["proof (prove)\nusing this:\n  is_prefix w b\n\ngoal (1 subgoal):\n 1. b = w @ drop (length w) b", "by (simp add: is_prefix_unsplit)"], ["proof (state)\nthis:\n  b = w @ drop (length w) b\n\ngoal (1 subgoal):\n 1. Derives1 a (i - length w) r (drop (length w) b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 a (i - length w) r (drop (length w) b)", "apply (rule_tac Derives1_skip_prefix[OF i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 (w @ a) i r (w @ drop (length w) b)", "by (simp add: b[symmetric] wa_b)"], ["proof (state)\nthis:\n  Derives1 a (i - length w) r (drop (length w) b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derives1_drop_prefixword: \n  assumes w: \"is_word w\"\n  assumes wa_b: \"derives1 (w@a) b\"\n  shows \"derives1 a (drop (length w) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derives1 a (drop (length w) b)", "by (metis Derives1_drop_prefixword Derives1_implies_derives1 derives1_implies_Derives1 w wa_b)"], ["", "lemma derives1_is_word_is_prefix_drop: \n  assumes w: \"is_word w\"\n  assumes w_a: \"is_prefix w a\"\n  assumes ab: \"derives1 a b\"\n  shows \"derives1 (drop (length w) a) (drop (length w) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derives1 (drop (length w) a) (drop (length w) b)", "by (metis ab append_take_drop_id derives1_drop_prefixword take_prefix w w_a)"], ["", "lemma derives_drop_prefixword_helper: \n  \"derives a b \\<Longrightarrow> is_word w \\<Longrightarrow> is_prefix w a \\<Longrightarrow> derives (drop (length w) a) (drop (length w) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>derives a b; is_word w; is_prefix w a\\<rbrakk>\n    \\<Longrightarrow> derives (drop (length w) a) (drop (length w) b)", "proof (induct rule: derives_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n    \\<Longrightarrow> derives (drop (length w) a) (drop (length w) a)\n 2. \\<And>y z.\n       \\<lbrakk>derives a y; derives1 y z;\n        \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n        \\<Longrightarrow> derives (drop (length w) a) (drop (length w) y);\n        is_word w; is_prefix w a\\<rbrakk>\n       \\<Longrightarrow> derives (drop (length w) a) (drop (length w) z)", "case Base"], ["proof (state)\nthis:\n  is_word w\n  is_prefix w a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n    \\<Longrightarrow> derives (drop (length w) a) (drop (length w) a)\n 2. \\<And>y z.\n       \\<lbrakk>derives a y; derives1 y z;\n        \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n        \\<Longrightarrow> derives (drop (length w) a) (drop (length w) y);\n        is_word w; is_prefix w a\\<rbrakk>\n       \\<Longrightarrow> derives (drop (length w) a) (drop (length w) z)", "thus ?case"], ["proof (prove)\nusing this:\n  is_word w\n  is_prefix w a\n\ngoal (1 subgoal):\n 1. derives (drop (length w) a) (drop (length w) a)", "by auto"], ["proof (state)\nthis:\n  derives (drop (length w) a) (drop (length w) a)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>derives a y; derives1 y z;\n        \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n        \\<Longrightarrow> derives (drop (length w) a) (drop (length w) y);\n        is_word w; is_prefix w a\\<rbrakk>\n       \\<Longrightarrow> derives (drop (length w) a) (drop (length w) z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>derives a y; derives1 y z;\n        \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n        \\<Longrightarrow> derives (drop (length w) a) (drop (length w) y);\n        is_word w; is_prefix w a\\<rbrakk>\n       \\<Longrightarrow> derives (drop (length w) a) (drop (length w) z)", "case (Step y z)"], ["proof (state)\nthis:\n  derives a y\n  derives1 y z\n  \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n  \\<Longrightarrow> derives (drop (length w) a) (drop (length w) y)\n  is_word w\n  is_prefix w a\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>derives a y; derives1 y z;\n        \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n        \\<Longrightarrow> derives (drop (length w) a) (drop (length w) y);\n        is_word w; is_prefix w a\\<rbrakk>\n       \\<Longrightarrow> derives (drop (length w) a) (drop (length w) z)", "have is_prefix_w_y: \"is_prefix w y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix w y", "by (metis Step.hyps(1) Step.prems(1) Step.prems(2) derives_word_is_prefix is_prefix_def)"], ["proof (state)\nthis:\n  is_prefix w y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>derives a y; derives1 y z;\n        \\<lbrakk>is_word w; is_prefix w a\\<rbrakk>\n        \\<Longrightarrow> derives (drop (length w) a) (drop (length w) y);\n        is_word w; is_prefix w a\\<rbrakk>\n       \\<Longrightarrow> derives (drop (length w) a) (drop (length w) z)", "thus ?case"], ["proof (prove)\nusing this:\n  is_prefix w y\n\ngoal (1 subgoal):\n 1. derives (drop (length w) a) (drop (length w) z)", "by (metis Step.hyps(2) Step.hyps(3) Step.prems(1) Step.prems(2) derives1_implies_derives \n        derives1_is_word_is_prefix_drop derives_trans)"], ["proof (state)\nthis:\n  derives (drop (length w) a) (drop (length w) z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derive_drop_prefixword:\n  \"is_word w \\<Longrightarrow> derives (w@a) b \\<Longrightarrow> derives a (drop (length w) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_word w; derives (w @ a) b\\<rbrakk>\n    \\<Longrightarrow> derives a (drop (length w) b)", "by (metis append_eq_conv_conj derives_drop_prefixword_helper is_prefix_take)"], ["", "lemma thmD2':\n  assumes X: \"is_terminal X\"\n  assumes p: \"doc_tokens p\"\n  assumes pX: \"(terminals p)@[X] \\<in> \\<L>\\<^sub>P\"\n  shows \"\\<exists> x. pvalid p x \\<and> next_symbol x = Some X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "from p"], ["proof (chain)\npicking this:\n  doc_tokens p", "have wellformed_p: \"wellformed_tokens p\""], ["proof (prove)\nusing this:\n  doc_tokens p\n\ngoal (1 subgoal):\n 1. wellformed_tokens p", "by (simp add: doc_tokens_def)"], ["proof (state)\nthis:\n  wellformed_tokens p\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "have \"\\<exists> \\<omega>. leftderives [\\<SS>] (((terminals p)@[X]) @ \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>. leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)", "using \\<L>\\<^sub>P_leftderives pX"], ["proof (prove)\nusing this:\n  ?a \\<in> \\<L>\\<^sub>P \\<Longrightarrow>\n  \\<exists>b. leftderives [\\<SS>] (?a @ b)\n  terminals p @ [X] \\<in> \\<L>\\<^sub>P\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>. leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<omega>. leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<omega>. leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)", "obtain \\<omega> where \"leftderives [\\<SS>] (((terminals p)@[X]) @ \\<omega>)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<omega>. leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        leftderives [\\<SS>]\n         ((terminals p @ [X]) @ \\<omega>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)", "have \"\\<exists> D. LeftDerivation [\\<SS>] D (((terminals p)@[X]) @ \\<omega>)\""], ["proof (prove)\nusing this:\n  leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<exists>D. LeftDerivation [\\<SS>] D ((terminals p @ [X]) @ \\<omega>)", "using leftderives_implies_LeftDerivation"], ["proof (prove)\nusing this:\n  leftderives [\\<SS>] ((terminals p @ [X]) @ \\<omega>)\n  leftderives ?a ?b \\<Longrightarrow> \\<exists>D. LeftDerivation ?a D ?b\n\ngoal (1 subgoal):\n 1. \\<exists>D. LeftDerivation [\\<SS>] D ((terminals p @ [X]) @ \\<omega>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>D. LeftDerivation [\\<SS>] D ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  \\<exists>D. LeftDerivation [\\<SS>] D ((terminals p @ [X]) @ \\<omega>)", "obtain D where D: \"LeftDerivation [\\<SS>] D (((terminals p)@[X]) @ \\<omega>)\""], ["proof (prove)\nusing this:\n  \\<exists>D. LeftDerivation [\\<SS>] D ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        LeftDerivation [\\<SS>] D\n         ((terminals p @ [X]) @ \\<omega>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivation [\\<SS>] D ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "let ?P = \"\\<lambda> k. (\\<exists> a b. LeftDerivation [\\<SS>] (take k D) (a@[X]@b) \\<and> derives a (terminals p))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "have \"?P (length D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       LeftDerivation [\\<SS>] (take (length D) D) (a @ [X] @ b) \\<and>\n       derives a (terminals p)", "apply (rule_tac x=\"terminals p\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       LeftDerivation [\\<SS>] (take (length D) D)\n        (terminals p @ [X] @ b) \\<and>\n       derives (terminals p) (terminals p)", "apply (rule_tac x=\"\\<omega>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation [\\<SS>] (take (length D) D)\n     (terminals p @ [X] @ \\<omega>) \\<and>\n    derives (terminals p) (terminals p)", "using D"], ["proof (prove)\nusing this:\n  LeftDerivation [\\<SS>] D ((terminals p @ [X]) @ \\<omega>)\n\ngoal (1 subgoal):\n 1. LeftDerivation [\\<SS>] (take (length D) D)\n     (terminals p @ [X] @ \\<omega>) \\<and>\n    derives (terminals p) (terminals p)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a b.\n     LeftDerivation [\\<SS>] (take (length D) D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     LeftDerivation [\\<SS>] (take (length D) D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     LeftDerivation [\\<SS>] (take (length D) D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "proof (induct rule: minimal_witness[where P=\"?P\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "case (Minimal K)"], ["proof (state)\nthis:\n  K \\<le> length D\n  \\<exists>a b.\n     LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n  ?k < K \\<Longrightarrow>\n  \\<nexists>a b.\n     LeftDerivation [\\<SS>] (take ?k D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "from Minimal(2)"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)", "obtain a b where\n       aXb: \"LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b)\" and\n       a: \"derives a (terminals p)\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b);\n         derives a (terminals p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b)\n  derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have KD: \"K > 0 \\<and> length D > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < K \\<and> 0 < length D", "proof (cases \"K = 0 \\<or> length D = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. K = 0 \\<or> length D = 0 \\<Longrightarrow> 0 < K \\<and> 0 < length D\n 2. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "case True"], ["proof (state)\nthis:\n  K = 0 \\<or> length D = 0\n\ngoal (2 subgoals):\n 1. K = 0 \\<or> length D = 0 \\<Longrightarrow> 0 < K \\<and> 0 < length D\n 2. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "hence \"take K D = []\""], ["proof (prove)\nusing this:\n  K = 0 \\<or> length D = 0\n\ngoal (1 subgoal):\n 1. take K D = []", "by auto"], ["proof (state)\nthis:\n  take K D = []\n\ngoal (2 subgoals):\n 1. K = 0 \\<or> length D = 0 \\<Longrightarrow> 0 < K \\<and> 0 < length D\n 2. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "with True aXb"], ["proof (chain)\npicking this:\n  K = 0 \\<or> length D = 0\n  LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b)\n  take K D = []", "have \"[\\<SS>] = a @ [X] @ b\""], ["proof (prove)\nusing this:\n  K = 0 \\<or> length D = 0\n  LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b)\n  take K D = []\n\ngoal (1 subgoal):\n 1. [\\<SS>] = a @ [X] @ b", "by simp"], ["proof (state)\nthis:\n  [\\<SS>] = a @ [X] @ b\n\ngoal (2 subgoals):\n 1. K = 0 \\<or> length D = 0 \\<Longrightarrow> 0 < K \\<and> 0 < length D\n 2. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "hence \"\\<SS> = X\""], ["proof (prove)\nusing this:\n  [\\<SS>] = a @ [X] @ b\n\ngoal (1 subgoal):\n 1. \\<SS> = X", "by (metis Nil_is_append_conv append_self_conv2 butlast.simps(2) \n              butlast_append hd_append2 list.sel(1) not_Cons_self2)"], ["proof (state)\nthis:\n  \\<SS> = X\n\ngoal (2 subgoals):\n 1. K = 0 \\<or> length D = 0 \\<Longrightarrow> 0 < K \\<and> 0 < length D\n 2. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "then"], ["proof (chain)\npicking this:\n  \\<SS> = X", "have \"False\""], ["proof (prove)\nusing this:\n  \\<SS> = X\n\ngoal (1 subgoal):\n 1. False", "using X is_nonterminal_startsymbol is_terminal_nonterminal"], ["proof (prove)\nusing this:\n  \\<SS> = X\n  is_terminal X\n  is_nonterminal \\<SS>\n  \\<lbrakk>is_terminal ?x; is_nonterminal ?x\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. K = 0 \\<or> length D = 0 \\<Longrightarrow> 0 < K \\<and> 0 < length D\n 2. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. 0 < K \\<and> 0 < length D", "by blast"], ["proof (state)\nthis:\n  0 < K \\<and> 0 < length D\n\ngoal (1 subgoal):\n 1. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "case False"], ["proof (state)\nthis:\n  \\<not> (K = 0 \\<or> length D = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (K = 0 \\<or> length D = 0) \\<Longrightarrow>\n    0 < K \\<and> 0 < length D", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (K = 0 \\<or> length D = 0)\n\ngoal (1 subgoal):\n 1. 0 < K \\<and> 0 < length D", "by arith"], ["proof (state)\nthis:\n  0 < K \\<and> 0 < length D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < K \\<and> 0 < length D\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  0 < K \\<and> 0 < length D", "have \"take K D = take (K - 1) D @ [D ! (K - 1)]\""], ["proof (prove)\nusing this:\n  0 < K \\<and> 0 < length D\n\ngoal (1 subgoal):\n 1. take K D = take (K - 1) D @ [D ! (K - 1)]", "by (metis Minimal.hyps(1) One_nat_def Suc_less_eq Suc_pred hd_drop_conv_nth \n          le_imp_less_Suc take_hd_drop)"], ["proof (state)\nthis:\n  take K D = take (K - 1) D @ [D ! (K - 1)]\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  take K D = take (K - 1) D @ [D ! (K - 1)]", "have \"\\<exists> \\<delta>. LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta> \\<and> LeftDerivation \\<delta> [D ! (K - 1)] (a@[X]@b)\""], ["proof (prove)\nusing this:\n  take K D = take (K - 1) D @ [D ! (K - 1)]\n\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>.\n       LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta> \\<and>\n       LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)", "by (metis LeftDerivation_append aXb)"], ["proof (state)\nthis:\n  \\<exists>\\<delta>.\n     LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta> \\<and>\n     LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<delta>.\n     LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta> \\<and>\n     LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)", "obtain \\<delta> where \n      \\<delta>1: \"LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta>\"  \n      and \\<delta>2: \"LeftDerivation \\<delta> [D ! (K - 1)] (a@[X]@b)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<delta>.\n     LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta> \\<and>\n     LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        \\<lbrakk>LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta>;\n         LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta>\n  LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "from \\<delta>2"], ["proof (chain)\npicking this:\n  LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)", "have \"\\<exists> i r. LeftDerives1 \\<delta> i r (a@[X]@b)\""], ["proof (prove)\nusing this:\n  LeftDerivation \\<delta> [D ! (K - 1)] (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<exists>i r. LeftDerives1 \\<delta> i r (a @ [X] @ b)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>i r. LeftDerives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  \\<exists>i r. LeftDerives1 \\<delta> i r (a @ [X] @ b)", "obtain i r where LeftDerives1_\\<delta>: \"LeftDerives1 \\<delta> i r (a@[X]@b)\""], ["proof (prove)\nusing this:\n  \\<exists>i r. LeftDerives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. (\\<And>i r.\n        LeftDerives1 \\<delta> i r (a @ [X] @ b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)", "have Derives1_\\<delta>: \"Derives1 \\<delta> i r (a@[X]@b)\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. Derives1 \\<delta> i r (a @ [X] @ b)", "by (metis LeftDerives1_implies_Derives1)"], ["proof (state)\nthis:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  Derives1 \\<delta> i r (a @ [X] @ b)", "have \"\\<exists> \\<alpha> N \\<beta> . splits_at \\<delta> i \\<alpha> N \\<beta>\""], ["proof (prove)\nusing this:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha> N \\<beta>. splits_at \\<delta> i \\<alpha> N \\<beta>", "by (simp add: splits_at_ex)"], ["proof (state)\nthis:\n  \\<exists>\\<alpha> N \\<beta>. splits_at \\<delta> i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha> N \\<beta>. splits_at \\<delta> i \\<alpha> N \\<beta>", "obtain \\<alpha> N \\<beta> where split_\\<delta>: \"splits_at \\<delta> i \\<alpha> N \\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha> N \\<beta>. splits_at \\<delta> i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> N \\<beta>.\n        splits_at \\<delta> i \\<alpha> N \\<beta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at \\<delta> i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have is_word_\\<alpha>: \"is_word \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_word \\<alpha>", "by (metis LeftDerives1_\\<delta> LeftDerives1_splits_at_is_word split_\\<delta>)"], ["proof (state)\nthis:\n  is_word \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have \"\\<not> (?P (K - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>a b.\n       LeftDerivation [\\<SS>] (take (K - 1) D) (a @ [X] @ b) \\<and>\n       derives a (terminals p)", "using KD Minimal(3)"], ["proof (prove)\nusing this:\n  0 < K \\<and> 0 < length D\n  ?k < K \\<Longrightarrow>\n  \\<nexists>a b.\n     LeftDerivation [\\<SS>] (take ?k D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<nexists>a b.\n       LeftDerivation [\\<SS>] (take (K - 1) D) (a @ [X] @ b) \\<and>\n       derives a (terminals p)", "by auto"], ["proof (state)\nthis:\n  \\<nexists>a b.\n     LeftDerivation [\\<SS>] (take (K - 1) D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "with \\<delta>1"], ["proof (chain)\npicking this:\n  LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta>\n  \\<nexists>a b.\n     LeftDerivation [\\<SS>] (take (K - 1) D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)", "have min_\\<delta>: \"\\<not> (\\<exists> a b. \\<delta> = a@[X]@b \\<and> derives a (terminals p))\""], ["proof (prove)\nusing this:\n  LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta>\n  \\<nexists>a b.\n     LeftDerivation [\\<SS>] (take (K - 1) D) (a @ [X] @ b) \\<and>\n     derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<nexists>a b. \\<delta> = a @ [X] @ b \\<and> derives a (terminals p)", "by blast"], ["proof (state)\nthis:\n  \\<nexists>a b. \\<delta> = a @ [X] @ b \\<and> derives a (terminals p)\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "from Derives1_\\<delta> split_\\<delta>"], ["proof (chain)\npicking this:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n  splits_at \\<delta> i \\<alpha> N \\<beta>", "have \"\\<exists> u v. a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> (snd r) = u@[X]@v\""], ["proof (prove)\nusing this:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n  splits_at \\<delta> i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "proof (induction rule: Derives1_X_is_part_of_rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>\\<delta> = a @ [X] @ \\<beta>; length a < i;\n        Derives1 \\<beta> (i - length a - 1) r b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>\\<delta> = \\<alpha> @ [X] @ b;\n        Derives1 \\<alpha> i r a\\<rbrakk>\n       \\<Longrightarrow> False", "case (Suffix \\<gamma>)"], ["proof (state)\nthis:\n  \\<delta> = a @ [X] @ \\<gamma>\n  length a < i\n  Derives1 \\<gamma> (i - length a - 1) r b\n\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>\\<delta> = a @ [X] @ \\<beta>; length a < i;\n        Derives1 \\<beta> (i - length a - 1) r b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>\\<delta> = \\<alpha> @ [X] @ b;\n        Derives1 \\<alpha> i r a\\<rbrakk>\n       \\<Longrightarrow> False", "from min_\\<delta> Suffix(1) a"], ["proof (chain)\npicking this:\n  \\<nexists>a b. \\<delta> = a @ [X] @ b \\<and> derives a (terminals p)\n  \\<delta> = a @ [X] @ \\<gamma>\n  derives a (terminals p)", "show ?case"], ["proof (prove)\nusing this:\n  \\<nexists>a b. \\<delta> = a @ [X] @ b \\<and> derives a (terminals p)\n  \\<delta> = a @ [X] @ \\<gamma>\n  derives a (terminals p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>\\<delta> = \\<alpha> @ [X] @ b;\n        Derives1 \\<alpha> i r a\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>\\<delta> = \\<alpha> @ [X] @ b;\n        Derives1 \\<alpha> i r a\\<rbrakk>\n       \\<Longrightarrow> False", "case (Prefix \\<gamma>)"], ["proof (state)\nthis:\n  \\<delta> = \\<gamma> @ [X] @ b\n  Derives1 \\<gamma> i r a\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>\\<delta> = \\<alpha> @ [X] @ b;\n        Derives1 \\<alpha> i r a\\<rbrakk>\n       \\<Longrightarrow> False", "have \"derives \\<gamma> (terminals p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derives \\<gamma> (terminals p)", "by (metis Derives1_implies_derives1 Prefix(2) a \n              derives1_implies_derives derives_trans)"], ["proof (state)\nthis:\n  derives \\<gamma> (terminals p)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>\\<delta> = \\<alpha> @ [X] @ b;\n        Derives1 \\<alpha> i r a\\<rbrakk>\n       \\<Longrightarrow> False", "with min_\\<delta> Prefix(1)"], ["proof (chain)\npicking this:\n  \\<nexists>a b. \\<delta> = a @ [X] @ b \\<and> derives a (terminals p)\n  \\<delta> = \\<gamma> @ [X] @ b\n  derives \\<gamma> (terminals p)", "show ?case"], ["proof (prove)\nusing this:\n  \\<nexists>a b. \\<delta> = a @ [X] @ b \\<and> derives a (terminals p)\n  \\<delta> = \\<gamma> @ [X] @ b\n  derives \\<gamma> (terminals p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u v.\n     a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  \\<exists>u v.\n     a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "obtain u v where uXv: \"a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> (snd r) = u@[X]@v\""], ["proof (prove)\nusing this:\n  \\<exists>u v.\n     a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        a = \\<alpha> @ u \\<and>\n        b = v @ \\<beta> \\<and> snd r = u @ [X] @ v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "let ?l = \"length \\<alpha>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "let ?q = \"take ?l p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "let ?x = \"Item r (length u) (charslength ?q) (charslength p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have \"item_rhs ?x = snd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. item_rhs\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p)) =\n    snd r", "by (simp add: item_rhs_def)"], ["proof (state)\nthis:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  snd r\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "then"], ["proof (chain)\npicking this:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  snd r", "have item_rhs_x: \"item_rhs ?x = u@[X]@v\""], ["proof (prove)\nusing this:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  snd r\n\ngoal (1 subgoal):\n 1. item_rhs\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p)) =\n    u @ [X] @ v", "using uXv"], ["proof (prove)\nusing this:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  snd r\n  a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. item_rhs\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p)) =\n    u @ [X] @ v", "by simp"], ["proof (state)\nthis:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  u @ [X] @ v\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have wellformed_x: \"wellformed_item ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_item\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p))", "apply (auto simp add: wellformed_item_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. r \\<in> \\<RR>\n 2. length (chars (take (length \\<alpha>) p)) \\<le> length (chars p)\n 3. length (chars p) \\<le> length Doc\n 4. length u\n    \\<le> length\n           (item_rhs\n             (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n               (length (chars p))))", "apply (metis Derives1_\\<delta> Derives1_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (chars (take (length \\<alpha>) p)) \\<le> length (chars p)\n 2. length (chars p) \\<le> length Doc\n 3. length u\n    \\<le> length\n           (item_rhs\n             (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n               (length (chars p))))", "apply (rule is_prefix_length)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_prefix (chars (take (length \\<alpha>) p)) (chars p)\n 2. length (chars p) \\<le> length Doc\n 3. length u\n    \\<le> length\n           (item_rhs\n             (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n               (length (chars p))))", "apply (rule is_prefix_chars)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_prefix (take (length \\<alpha>) p) p\n 2. length (chars p) \\<le> length Doc\n 3. length u\n    \\<le> length\n           (item_rhs\n             (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n               (length (chars p))))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (chars p) \\<le> length Doc\n 2. length u\n    \\<le> length\n           (item_rhs\n             (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n               (length (chars p))))", "apply (simp add: doc_tokens_length[OF p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length u\n    \\<le> length\n           (item_rhs\n             (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n               (length (chars p))))", "using item_rhs_x"], ["proof (prove)\nusing this:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  u @ [X] @ v\n\ngoal (1 subgoal):\n 1. length u\n    \\<le> length\n           (item_rhs\n             (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n               (length (chars p))))", "by simp"], ["proof (state)\nthis:\n  wellformed_item\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p))\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "from item_rhs_x"], ["proof (chain)\npicking this:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  u @ [X] @ v", "have next_symbol_x: \"next_symbol ?x = Some X\""], ["proof (prove)\nusing this:\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  u @ [X] @ v\n\ngoal (1 subgoal):\n 1. next_symbol\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p)) =\n    Some X", "by (auto simp add: next_symbol_def is_complete_def)"], ["proof (state)\nthis:\n  next_symbol\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  Some X\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have len_\\<alpha>_p: \"length \\<alpha> \\<le> length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> length p", "apply (rule_tac path_length_is_upper_bound[where u=u])"], ["proof (prove)\ngoal (3 subgoals):\n 1. wellformed_tokens p\n 2. is_word \\<alpha>\n 3. derives (\\<alpha> @ u) (terminals p)", "apply (simp add: wellformed_p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_word \\<alpha>\n 2. derives (\\<alpha> @ u) (terminals p)", "apply (simp add: is_word_\\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. derives (\\<alpha> @ u) (terminals p)", "using a uXv"], ["proof (prove)\nusing this:\n  derives a (terminals p)\n  a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. derives (\\<alpha> @ u) (terminals p)", "by blast"], ["proof (state)\nthis:\n  length \\<alpha> \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have item_nonterminal_x: \"item_nonterminal ?x = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. item_nonterminal\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p)) =\n    N", "apply (simp add: item_nonterminal_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst r = N", "using Derives1_\\<delta> Derives1_nonterminal split_\\<delta>"], ["proof (prove)\nusing this:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n  \\<lbrakk>Derives1 ?a ?i ?r ?b;\n   splits_at ?a ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> fst ?r = ?N \\<and> is_nonterminal ?N\n  splits_at \\<delta> i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. fst r = N", "by blast"], ["proof (state)\nthis:\n  item_nonterminal\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  N\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have take_terminals: \"take (length \\<alpha>) (terminals p) = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length \\<alpha>) (terminals p) = \\<alpha>", "apply (rule_tac take_prefix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> (terminals p)", "using a derives_word_is_prefix is_word_\\<alpha> uXv"], ["proof (prove)\nusing this:\n  derives a (terminals p)\n  \\<lbrakk>is_word ?w; derives (?w @ ?a) ?b\\<rbrakk>\n  \\<Longrightarrow> is_prefix ?w ?b\n  is_word \\<alpha>\n  a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> (terminals p)", "by blast"], ["proof (state)\nthis:\n  take (length \\<alpha>) (terminals p) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "have item_\\<alpha>_x: \"item_\\<alpha> ?x = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. item_\\<alpha>\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p)) =\n    u", "using item_\\<alpha>_def item_rhs_x"], ["proof (prove)\nusing this:\n  item_\\<alpha> ?x = take (item_dot ?x) (item_rhs ?x)\n  item_rhs\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  u @ [X] @ v\n\ngoal (1 subgoal):\n 1. item_\\<alpha>\n     (Item r (length u) (charslength (take (length \\<alpha>) p))\n       (charslength p)) =\n    u", "by auto"], ["proof (state)\nthis:\n  item_\\<alpha>\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  u\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>K \\<le> length D;\n        \\<exists>a b.\n           LeftDerivation [\\<SS>] (take K D) (a @ [X] @ b) \\<and>\n           derives a (terminals p);\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>a b.\n              LeftDerivation [\\<SS>] (take k D) (a @ [X] @ b) \\<and>\n              derives a (terminals p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            pvalid p x \\<and> next_symbol x = Some X", "from wellformed_x next_symbol_x len_\\<alpha>_p"], ["proof (chain)\npicking this:\n  wellformed_item\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p))\n  next_symbol\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  Some X\n  length \\<alpha> \\<le> length p", "show ?thesis"], ["proof (prove)\nusing this:\n  wellformed_item\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p))\n  next_symbol\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  Some X\n  length \\<alpha> \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "apply (rule_tac x=\"?x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (charslength (take (length \\<alpha>) p))\n                (charslength p));\n     next_symbol\n      (Item r (length u) (charslength (take (length \\<alpha>) p))\n        (charslength p)) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> pvalid p\n                       (Item r (length u)\n                         (charslength (take (length \\<alpha>) p))\n                         (charslength p)) \\<and>\n                      next_symbol\n                       (Item r (length u)\n                         (charslength (take (length \\<alpha>) p))\n                         (charslength p)) =\n                      Some X", "apply (auto simp add: pvalid_def wellformed_p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ua\\<le>length p.\n                         length (chars (take ua p)) =\n                         length (chars (take (length \\<alpha>) p)) \\<and>\n                         (\\<exists>\\<gamma>.\n                             is_derivation\n                              (take ua (terminals p) @\n                               item_nonterminal\n                                (Item r (length u)\n                                  (length\n                                    (chars (take (length \\<alpha>) p)))\n                                  (length (chars p))) #\n                               \\<gamma>)) \\<and>\n                         derives\n                          (item_\\<alpha>\n                            (Item r (length u)\n                              (length (chars (take (length \\<alpha>) p)))\n                              (length (chars p))))\n                          (drop ua (terminals p))", "apply (rule_tac x=\"length \\<alpha>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> length \\<alpha> \\<le> length p \\<and>\n                      length (chars (take (length \\<alpha>) p)) =\n                      length (chars (take (length \\<alpha>) p)) \\<and>\n                      (\\<exists>\\<gamma>.\n                          is_derivation\n                           (take (length \\<alpha>) (terminals p) @\n                            item_nonterminal\n                             (Item r (length u)\n                               (length (chars (take (length \\<alpha>) p)))\n                               (length (chars p))) #\n                            \\<gamma>)) \\<and>\n                      derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<gamma>.\n                         is_derivation\n                          (take (length \\<alpha>) (terminals p) @\n                           item_nonterminal\n                            (Item r (length u)\n                              (length (chars (take (length \\<alpha>) p)))\n                              (length (chars p))) #\n                           \\<gamma>)\n 2. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "using item_nonterminal_x"], ["proof (prove)\nusing this:\n  item_nonterminal\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  N\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<gamma>.\n                         is_derivation\n                          (take (length \\<alpha>) (terminals p) @\n                           item_nonterminal\n                            (Item r (length u)\n                              (length (chars (take (length \\<alpha>) p)))\n                              (length (chars p))) #\n                           \\<gamma>)\n 2. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p;\n     item_nonterminal\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     N\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<gamma>.\n                         is_derivation\n                          (take (length \\<alpha>) (terminals p) @\n                           N # \\<gamma>)\n 2. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "apply (simp add: take_terminals)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p;\n     item_nonterminal\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     N\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<gamma>.\n                         is_derivation (\\<alpha> @ N # \\<gamma>)\n 2. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "apply (rule_tac x=\"\\<beta>\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p;\n     item_nonterminal\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     N\\<rbrakk>\n    \\<Longrightarrow> is_derivation (\\<alpha> @ N # \\<beta>)\n 2. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "using LeftDerivation_implies_leftderives \\<delta>1 is_leftderivation_def split_\\<delta> splits_at_combine"], ["proof (prove)\nusing this:\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> leftderives ?a ?b\n  LeftDerivation [\\<SS>] (take (K - 1) D) \\<delta>\n  is_leftderivation ?u = leftderives [\\<SS>] ?u\n  splits_at \\<delta> i \\<alpha> N \\<beta>\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> \\<Longrightarrow>\n  ?\\<delta> = ?\\<alpha> @ [?N] @ ?\\<beta>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p;\n     item_nonterminal\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     N\\<rbrakk>\n    \\<Longrightarrow> is_derivation (\\<alpha> @ N # \\<beta>)\n 2. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "using item_\\<alpha>_x"], ["proof (prove)\nusing this:\n  item_\\<alpha>\n   (Item r (length u) (charslength (take (length \\<alpha>) p))\n     (charslength p)) =\n  u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p\\<rbrakk>\n    \\<Longrightarrow> derives\n                       (item_\\<alpha>\n                         (Item r (length u)\n                           (length (chars (take (length \\<alpha>) p)))\n                           (length (chars p))))\n                       (drop (length \\<alpha>) (terminals p))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_item\n              (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n                (length (chars p)));\n     next_symbol\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     Some X;\n     length \\<alpha> \\<le> length p;\n     item_\\<alpha>\n      (Item r (length u) (length (chars (take (length \\<alpha>) p)))\n        (length (chars p))) =\n     u\\<rbrakk>\n    \\<Longrightarrow> derives u (drop (length \\<alpha>) (terminals p))", "by (metis a derive_drop_prefixword is_word_\\<alpha> uXv)"], ["proof (state)\nthis:\n  \\<exists>x. pvalid p x \\<and> next_symbol x = Some X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. pvalid p x \\<and> next_symbol x = Some X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admissible_wellformed_tokens: \"admissible p \\<Longrightarrow> wellformed_tokens p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. admissible p \\<Longrightarrow> wellformed_tokens p", "by (auto simp add: admissible_def \\<L>\\<^sub>P_wellformed_tokens)"], ["", "lemma chars_append[simp]: \"chars (a@b) = (chars a)@(chars b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chars (a @ b) = chars a @ chars b", "by (induct a arbitrary: b, auto)"], ["", "lemma chars_of_token_simp[simp]: \"chars_of_token (a, b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chars_of_token (a, b) = b", "by (simp add: chars_of_token_def)"], ["", "lemma \\<X>_is_prefix: \"t \\<in> \\<X> k \\<Longrightarrow> is_prefix (snd t) (drop k Doc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> \\<X> k \\<Longrightarrow> is_prefix (snd t) (drop k Doc)", "by (auto simp add: \\<X>_def)"], ["", "lemma is_prefix_append: \"is_prefix (a@b) D = (is_prefix a D \\<and> is_prefix b (drop (length a) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix (a @ b) D =\n    (is_prefix a D \\<and> is_prefix b (drop (length a) D))", "by (metis append_assoc is_prefix_cancel is_prefix_def is_prefix_unsplit)"], ["", "lemma \\<PP>_are_doc_tokens: \"p \\<in> \\<PP> \\<Longrightarrow> doc_tokens p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> \\<PP> \\<Longrightarrow> doc_tokens p", "proof (induct rule: \\<PP>_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. doc_tokens []\n 2. \\<And>p k u.\n       \\<lbrakk>\\<And>q. q \\<in> \\<P> k u \\<Longrightarrow> doc_tokens q;\n        p \\<in> \\<P> k (Suc u)\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "case Base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. doc_tokens []\n 2. \\<And>p k u.\n       \\<lbrakk>\\<And>q. q \\<in> \\<P> k u \\<Longrightarrow> doc_tokens q;\n        p \\<in> \\<P> k (Suc u)\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. doc_tokens []", "by (simp add: doc_tokens_def wellformed_tokens_def)"], ["proof (state)\nthis:\n  doc_tokens []\n\ngoal (1 subgoal):\n 1. \\<And>p k u.\n       \\<lbrakk>\\<And>q. q \\<in> \\<P> k u \\<Longrightarrow> doc_tokens q;\n        p \\<in> \\<P> k (Suc u)\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k u.\n       \\<lbrakk>\\<And>q. q \\<in> \\<P> k u \\<Longrightarrow> doc_tokens q;\n        p \\<in> \\<P> k (Suc u)\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "case (Induct p k u)"], ["proof (state)\nthis:\n  ?q \\<in> \\<P> k u \\<Longrightarrow> doc_tokens ?q\n  p \\<in> \\<P> k (Suc u)\n\ngoal (1 subgoal):\n 1. \\<And>p k u.\n       \\<lbrakk>\\<And>q. q \\<in> \\<P> k u \\<Longrightarrow> doc_tokens q;\n        p \\<in> \\<P> k (Suc u)\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "from Induct(2)[simplified]"], ["proof (chain)\npicking this:\n  p \\<in> limit (Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k) (\\<P> k u)", "show ?case"], ["proof (prove)\nusing this:\n  p \\<in> limit (Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k) (\\<P> k u)\n\ngoal (1 subgoal):\n 1. doc_tokens p", "proof (induct rule: limit_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> \\<P> k u \\<Longrightarrow> doc_tokens p\n 2. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "case (Init p)"], ["proof (state)\nthis:\n  p \\<in> \\<P> k u\n\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> \\<P> k u \\<Longrightarrow> doc_tokens p\n 2. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "from Induct(1)[OF Init]"], ["proof (chain)\npicking this:\n  doc_tokens p", "show ?case"], ["proof (prove)\nusing this:\n  doc_tokens p\n\ngoal (1 subgoal):\n 1. doc_tokens p", "."], ["proof (state)\nthis:\n  doc_tokens p\n\ngoal (1 subgoal):\n 1. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "case (Iterate p Y)"], ["proof (state)\nthis:\n  ?q \\<in> Y \\<Longrightarrow> doc_tokens ?q\n  p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\n\ngoal (1 subgoal):\n 1. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "have Y_is_prefix: \"\\<And> p. p \\<in> Y \\<Longrightarrow> is_prefix (chars p) Doc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> Y \\<Longrightarrow> is_prefix (chars p) Doc", "apply (drule Iterate(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. doc_tokens p \\<Longrightarrow> is_prefix (chars p) Doc", "by (simp add: doc_tokens_def)"], ["proof (state)\nthis:\n  ?p \\<in> Y \\<Longrightarrow> is_prefix (chars ?p) Doc\n\ngoal (1 subgoal):\n 1. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "have \"\\<Y> (\\<Z> k u) (\\<P> k u) k \\<subseteq> \\<X> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Y> (\\<Z> k u) (\\<P> k u) k \\<subseteq> \\<X> k", "by (metis \\<Z>.simps(2) \\<Z>_subset_\\<X>)"], ["proof (state)\nthis:\n  \\<Y> (\\<Z> k u) (\\<P> k u) k \\<subseteq> \\<X> k\n\ngoal (1 subgoal):\n 1. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "then"], ["proof (chain)\npicking this:\n  \\<Y> (\\<Z> k u) (\\<P> k u) k \\<subseteq> \\<X> k", "have 1: \"Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y \\<subseteq> Append (\\<X> k) k Y\""], ["proof (prove)\nusing this:\n  \\<Y> (\\<Z> k u) (\\<P> k u) k \\<subseteq> \\<X> k\n\ngoal (1 subgoal):\n 1. Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\n    \\<subseteq> Append (\\<X> k) k Y", "by (rule Append_mono, simp)"], ["proof (state)\nthis:\n  Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y \\<subseteq> Append (\\<X> k) k Y\n\ngoal (1 subgoal):\n 1. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "have 2: \"p \\<in> Append (\\<X> k) k Y \\<Longrightarrow> doc_tokens p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> Append (\\<X> k) k Y \\<Longrightarrow> doc_tokens p", "apply (auto simp add: Append_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<in> Y \\<Longrightarrow> doc_tokens p\n 2. \\<And>p a b.\n       \\<lbrakk>p = p @ [(a, b)]; p \\<in> Y; k = length (chars p);\n        (a, b) \\<in> \\<X> (length (chars p));\n        admissible (p @ [(a, b)])\\<rbrakk>\n       \\<Longrightarrow> doc_tokens (p @ [(a, b)])", "apply (simp add: Iterate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p = p @ [(a, b)]; p \\<in> Y; k = length (chars p);\n        (a, b) \\<in> \\<X> (length (chars p));\n        admissible (p @ [(a, b)])\\<rbrakk>\n       \\<Longrightarrow> doc_tokens (p @ [(a, b)])", "apply (auto simp add: doc_tokens_def admissible_wellformed_tokens \n             is_prefix_append Y_is_prefix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p = p @ [(a, b)]; p \\<in> Y; k = length (chars p);\n        (a, b) \\<in> \\<X> (length (chars p));\n        admissible (p @ [(a, b)])\\<rbrakk>\n       \\<Longrightarrow> is_prefix b (drop (length (chars p)) Doc)", "by (metis \\<X>_is_prefix snd_conv)"], ["proof (state)\nthis:\n  p \\<in> Append (\\<X> k) k Y \\<Longrightarrow> doc_tokens p\n\ngoal (1 subgoal):\n 1. \\<And>p Y.\n       \\<lbrakk>\\<And>q. q \\<in> Y \\<Longrightarrow> doc_tokens q;\n        p \\<in> Append (\\<Y> (\\<Z> k u) (\\<P> k u) k) k Y\\<rbrakk>\n       \\<Longrightarrow> doc_tokens p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. doc_tokens p", "apply (rule 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> Append (\\<X> k) k Y", "by (metis (mono_tags, lifting) \"1\" Iterate(2) subsetCE)"], ["proof (state)\nthis:\n  doc_tokens p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  doc_tokens p\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem thmD2:\n  assumes X: \"is_terminal X\"\n  assumes p: \"p \\<in> \\<PP>\"\n  assumes pX: \"(terminals p)@[X] \\<in> \\<L>\\<^sub>P\"\n  shows \"\\<exists> x. pvalid p x \\<and> next_symbol x = Some X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. pvalid p x \\<and> next_symbol x = Some X", "by (metis X \\<PP>_are_doc_tokens p pX thmD2')"], ["", "end"], ["", "end"]]}