{"file_name": "/home/qj213/afp-2021-10-22/thys/LocalLexing/Limit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LocalLexing", "problem_names": ["lemma setmonotone_funpower: \"setmonotone f \\<Longrightarrow> setmonotone (funpower f n)\"", "lemma subset_setmonotone: \"setmonotone f \\<Longrightarrow> X \\<subseteq> f X\"", "lemma elem_setmonotone: \"setmonotone f \\<Longrightarrow> x \\<in> X \\<Longrightarrow> x \\<in> f X\"", "lemma elem_natUnion: \"(\\<forall> n. x \\<in> f n) \\<Longrightarrow> x \\<in> natUnion f\"", "lemma subset_natUnion: \"(\\<forall> n. X \\<subseteq> f n) \\<Longrightarrow> X \\<subseteq> natUnion f\"", "lemma setmonotone_limit:\n  assumes fmono: \"setmonotone f\"\n  shows \"setmonotone (limit f)\"", "lemma[simp]: \"funpower id n = id\"", "lemma[simp]: \"limit id = id\"", "lemma natUnion_decompose[consumes 1, case_names Decompose]:\n  assumes p: \"p \\<in> natUnion S\"\n  assumes decompose: \"\\<And> n p. p \\<in> S n \\<Longrightarrow> P p\" \n  shows \"P p\"", "lemma limit_induct[consumes 1, case_names Init Iterate]:\n  assumes p: \"(p :: 'a) \\<in> limit f X\"\n  assumes init: \"\\<And> p. p \\<in> X \\<Longrightarrow> P p\"\n  assumes iterate: \"\\<And> p Y. (\\<And> q . q \\<in> Y \\<Longrightarrow> P q) \\<Longrightarrow> p \\<in> f Y \\<Longrightarrow> P p\"\n  shows \"P p\"", "lemma continuous_apply:\n  \"continuous f \\<Longrightarrow> chain C \\<Longrightarrow> f (natUnion C) = natUnion (f o C)\"", "lemma continuous_imp_mono:\n  assumes continuous: \"continuous f\"\n  shows \"mono f\"", "lemma mono_maps_chain_to_chain: \n  assumes f: \"mono f\"\n  assumes C: \"chain C\"\n  shows \"chain (f o C)\"", "lemma natUnion_upperbound: \n  \"(\\<And> n. f n \\<subseteq> G) \\<Longrightarrow> (natUnion f) \\<subseteq> G\"", "lemma funpower_upperbound:\n  \"(\\<And> I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G) \\<Longrightarrow> I \\<subseteq> G \\<Longrightarrow> funpower f n I \\<subseteq> G\"", "lemma limit_upperbound:\n  \"(\\<And> I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G) \\<Longrightarrow> I \\<subseteq> G \\<Longrightarrow> limit f I \\<subseteq> G\"", "lemma elem_limit_simp: \"x \\<in> limit f X = (\\<exists> n. x \\<in> funpower f n X)\"", "lemma pointwise_simp: \n  assumes f: \"pointwise f\"\n  shows \"f X =  \\<Union> { f {x} | x. x \\<in> X}\"", "lemma natUnion_elem: \"x \\<in> f n \\<Longrightarrow> x \\<in> natUnion f\"", "lemma limit_elem: \"x \\<in> funpower f n X \\<Longrightarrow> x \\<in> limit f X\"", "lemma limit_step_pointwise:\n  assumes x: \"x \\<in> limit f X\"\n  assumes f: \"pointwise f\"\n  assumes y: \"y \\<in> f {x}\"\n  shows \"y \\<in> limit f X\"", "lemma pointwise_implies_pointbased:\n  assumes pointwise: \"pointwise f\"\n  shows \"pointbased f\"", "lemma pointbase_is_mono:\n  \"mono (pointbase f)\"", "lemma chain_implies_mono: \"chain C \\<Longrightarrow> mono C\"", "lemma chain_cover_witness: \"finite X \\<Longrightarrow> chain C \\<Longrightarrow> X \\<subseteq> natUnion C \\<Longrightarrow> \\<exists> n. X \\<subseteq> C n\"", "lemma pointbase_is_continuous:\n  \"continuous (pointbase f)\"", "lemma pointbased_implies_continuous:\n  \"pointbased f \\<Longrightarrow> continuous f\"", "lemma setmonotone_implies_chain_funpower:\n  assumes setmonotone: \"setmonotone f\"\n  shows \"chain (\\<lambda> n. funpower f n I)\"", "lemma natUnion_subset: \"(\\<And> n. \\<exists> m. f n \\<subseteq> g m) \\<Longrightarrow> natUnion f \\<subseteq> natUnion g\"", "lemma natUnion_eq[case_names Subset Superset]: \n  \"(\\<And> n. \\<exists> m. f n \\<subseteq> g m) \\<Longrightarrow> (\\<And> n. \\<exists> m. g n \\<subseteq> f m) \\<Longrightarrow> natUnion f = natUnion g\"", "lemma natUnion_shift[symmetric]: \n  assumes chain: \"chain C\"\n  shows \"natUnion C = natUnion (\\<lambda> n. C (n + m))\"", "lemma regular_fixpoint:\n  assumes regular: \"regular f\"\n  shows \"f (limit f I) = limit f I\"", "lemma fix_is_fix_of_limit:\n  assumes fixpoint: \"f I = I\"   \n  shows \"limit f I = I\"", "lemma limit_is_idempotent: \"regular f \\<Longrightarrow> limit f (limit f I) = limit f I\"", "lemma setmonotone_mk_regular1: \"setmonotone (mk_regular1 P F)\"", "lemma setmonotone_mk_regular2: \"setmonotone (mk_regular2 P F)\"", "lemma pointbased_mk_regular1: \"pointbased (mk_regular1 P F)\"", "lemma pointbased_mk_regular2: \"pointbased (mk_regular2 P F)\"", "lemma regular1:\"regular (mk_regular1 P F)\"", "lemma regular2: \"regular (mk_regular2 P F)\"", "lemma continuous_comp: \n  assumes f: \"continuous f\"\n  assumes g: \"continuous g\"\n  shows \"continuous (g o f)\"", "lemma setmonotone_comp:\n  assumes f: \"setmonotone f\"\n  assumes g: \"setmonotone g\"\n  shows \"setmonotone (g o f)\"", "lemma regular_comp:\n  assumes f: \"regular f\"\n  assumes g: \"regular g\"\n  shows \"regular (g o f)\"", "lemma setmonotone_id[simp]: \"setmonotone id\"", "lemma continuous_id[simp]: \"continuous id\"", "lemma regular_id[simp]: \"regular id\"", "lemma regular_funpower: \"regular f \\<Longrightarrow> regular (funpower f n)\"", "lemma mono_id[simp]: \"mono id\"", "lemma mono_funpower:\n  assumes mono: \"mono f\"\n  shows \"mono (funpower f n)\"", "lemma mono_limit:\n  assumes mono: \"mono f\"\n  shows \"mono (limit f)\"", "lemma continuous_funpower:\n  assumes continuous: \"continuous f\"\n  shows \"continuous (funpower f n)\"", "lemma natUnion_swap:\n  \"natUnion (\\<lambda> i. natUnion (\\<lambda> j. f i j)) = natUnion (\\<lambda> j. natUnion (\\<lambda> i. f i j))\"", "lemma continuous_limit:\n  assumes continuous: \"continuous f\"\n  shows \"continuous (limit f)\"", "lemma regular_limit: \"regular f \\<Longrightarrow> regular (limit f)\"", "lemma regular_implies_mono: \"regular f \\<Longrightarrow> mono f\"", "lemma regular_implies_setmonotone: \"regular f \\<Longrightarrow> setmonotone f\"", "lemma regular_implies_continuous: \"regular f \\<Longrightarrow> continuous f\""], "translations": [["", "lemma setmonotone_funpower: \"setmonotone f \\<Longrightarrow> setmonotone (funpower f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone f \\<Longrightarrow> setmonotone (funpower f n)", "by (induct n, auto simp add: setmonotone_def)"], ["", "lemma subset_setmonotone: \"setmonotone f \\<Longrightarrow> X \\<subseteq> f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone f \\<Longrightarrow> X \\<subseteq> f X", "by (simp add: setmonotone_def)"], ["", "lemma elem_setmonotone: \"setmonotone f \\<Longrightarrow> x \\<in> X \\<Longrightarrow> x \\<in> f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>setmonotone f; x \\<in> X\\<rbrakk> \\<Longrightarrow> x \\<in> f X", "by (auto simp add: setmonotone_def)"], ["", "lemma elem_natUnion: \"(\\<forall> n. x \\<in> f n) \\<Longrightarrow> x \\<in> natUnion f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. x \\<in> f n \\<Longrightarrow> x \\<in> natUnion f", "by (auto simp add: natUnion_def)"], ["", "lemma subset_natUnion: \"(\\<forall> n. X \\<subseteq> f n) \\<Longrightarrow> X \\<subseteq> natUnion f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. X \\<subseteq> f n \\<Longrightarrow> X \\<subseteq> natUnion f", "by (auto simp add: natUnion_def)"], ["", "lemma setmonotone_limit:\n  assumes fmono: \"setmonotone f\"\n  shows \"setmonotone (limit f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone (limit f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. setmonotone (limit f)", "show \"setmonotone (limit f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone (limit f)", "apply (auto simp add: setmonotone_def limit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> natUnion (\\<lambda>n. funpower f n X)", "apply (rule elem_natUnion, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x n. x \\<in> X \\<Longrightarrow> x \\<in> funpower f n X", "apply (rule elem_setmonotone[OF setmonotone_funpower])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X x n. x \\<in> X \\<Longrightarrow> setmonotone f\n 2. \\<And>X x n. x \\<in> X \\<Longrightarrow> x \\<in> X", "by (auto simp add: fmono)"], ["proof (state)\nthis:\n  setmonotone (limit f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma[simp]: \"funpower id n = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. funpower id n = id", "by (rule ext, induct n, simp_all)"], ["", "lemma[simp]: \"limit id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit id = id", "by (rule ext, auto simp add: limit_def natUnion_def)"], ["", "lemma natUnion_decompose[consumes 1, case_names Decompose]:\n  assumes p: \"p \\<in> natUnion S\"\n  assumes decompose: \"\\<And> n p. p \\<in> S n \\<Longrightarrow> P p\" \n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "from p"], ["proof (chain)\npicking this:\n  p \\<in> natUnion S", "have \"\\<exists> n. p \\<in> S n\""], ["proof (prove)\nusing this:\n  p \\<in> natUnion S\n\ngoal (1 subgoal):\n 1. \\<exists>n. p \\<in> S n", "by (auto simp add: natUnion_def)"], ["proof (state)\nthis:\n  \\<exists>n. p \\<in> S n\n\ngoal (1 subgoal):\n 1. P p", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. p \\<in> S n", "obtain n where \"p \\<in> S n\""], ["proof (prove)\nusing this:\n  \\<exists>n. p \\<in> S n\n\ngoal (1 subgoal):\n 1. (\\<And>n. p \\<in> S n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> S n\n\ngoal (1 subgoal):\n 1. P p", "from decompose[OF this]"], ["proof (chain)\npicking this:\n  P p", "show ?thesis"], ["proof (prove)\nusing this:\n  P p\n\ngoal (1 subgoal):\n 1. P p", "."], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma limit_induct[consumes 1, case_names Init Iterate]:\n  assumes p: \"(p :: 'a) \\<in> limit f X\"\n  assumes init: \"\\<And> p. p \\<in> X \\<Longrightarrow> P p\"\n  assumes iterate: \"\\<And> p Y. (\\<And> q . q \\<in> Y \\<Longrightarrow> P q) \\<Longrightarrow> p \\<in> f Y \\<Longrightarrow> P p\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "from p"], ["proof (chain)\npicking this:\n  p \\<in> limit f X", "have p_in_natUnion: \"p \\<in> natUnion (\\<lambda> n. funpower f n X)\""], ["proof (prove)\nusing this:\n  p \\<in> limit f X\n\ngoal (1 subgoal):\n 1. p \\<in> natUnion (\\<lambda>n. funpower f n X)", "by (simp add: limit_def)"], ["proof (state)\nthis:\n  p \\<in> natUnion (\\<lambda>n. funpower f n X)\n\ngoal (1 subgoal):\n 1. P p", "{"], ["proof (state)\nthis:\n  p \\<in> natUnion (\\<lambda>n. funpower f n X)\n\ngoal (1 subgoal):\n 1. P p", "fix p :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "have \"p \\<in> funpower f n X \\<Longrightarrow> P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> funpower f n X \\<Longrightarrow> P p", "proof (induct n arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> funpower f 0 X \\<Longrightarrow> P p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p. p \\<in> funpower f n X \\<Longrightarrow> P p;\n        p \\<in> funpower f (Suc n) X\\<rbrakk>\n       \\<Longrightarrow> P p", "case 0"], ["proof (state)\nthis:\n  p \\<in> funpower f 0 X\n\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> funpower f 0 X \\<Longrightarrow> P p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p. p \\<in> funpower f n X \\<Longrightarrow> P p;\n        p \\<in> funpower f (Suc n) X\\<rbrakk>\n       \\<Longrightarrow> P p", "thus ?case"], ["proof (prove)\nusing this:\n  p \\<in> funpower f 0 X\n\ngoal (1 subgoal):\n 1. P p", "using init[OF 0[simplified]]"], ["proof (prove)\nusing this:\n  p \\<in> funpower f 0 X\n  P p\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p. p \\<in> funpower f n X \\<Longrightarrow> P p;\n        p \\<in> funpower f (Suc n) X\\<rbrakk>\n       \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p. p \\<in> funpower f n X \\<Longrightarrow> P p;\n        p \\<in> funpower f (Suc n) X\\<rbrakk>\n       \\<Longrightarrow> P p", "case (Suc n)"], ["proof (state)\nthis:\n  ?p \\<in> funpower f n X \\<Longrightarrow> P ?p\n  p \\<in> funpower f (Suc n) X\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p. p \\<in> funpower f n X \\<Longrightarrow> P p;\n        p \\<in> funpower f (Suc n) X\\<rbrakk>\n       \\<Longrightarrow> P p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using iterate[OF Suc(1) Suc(2)[simplified], simplified]"], ["proof (prove)\nusing this:\n  P p\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> funpower f n X \\<Longrightarrow> P p\n\ngoal (1 subgoal):\n 1. P p", "}"], ["proof (state)\nthis:\n  ?pa2 \\<in> funpower f ?n2 X \\<Longrightarrow> P ?pa2\n\ngoal (1 subgoal):\n 1. P p", "with p_in_natUnion"], ["proof (chain)\npicking this:\n  p \\<in> natUnion (\\<lambda>n. funpower f n X)\n  ?pa2 \\<in> funpower f ?n2 X \\<Longrightarrow> P ?pa2", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> natUnion (\\<lambda>n. funpower f n X)\n  ?pa2 \\<in> funpower f ?n2 X \\<Longrightarrow> P ?pa2\n\ngoal (1 subgoal):\n 1. P p", "by (induct rule: natUnion_decompose)"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "definition chain :: \"(nat \\<Rightarrow> 'a set) \\<Rightarrow> bool\"\nwhere\n  \"chain C = (\\<forall> i. C i \\<subseteq> C (i + 1))\""], ["", "definition continuous :: \"('a set \\<Rightarrow> 'b set) \\<Rightarrow> bool\"\nwhere\n  \"continuous f = (\\<forall> C. chain C \\<longrightarrow> (chain (f o C) \\<and> f (natUnion C) = natUnion (f o C)))\""], ["", "lemma continuous_apply:\n  \"continuous f \\<Longrightarrow> chain C \\<Longrightarrow> f (natUnion C) = natUnion (f o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>continuous f; chain C\\<rbrakk>\n    \\<Longrightarrow> f (natUnion C) = natUnion (f \\<circ> C)", "by (simp add: continuous_def)"], ["", "lemma continuous_imp_mono:\n  assumes continuous: \"continuous f\"\n  shows \"mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "fix A :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "fix B :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "assume sub: \"A \\<subseteq> B\""], ["proof (state)\nthis:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. mono f", "let ?C = \"\\<lambda> (i::nat). if (i = 0) then A else B\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "have \"chain ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>i. if i = 0 then A else B)", "by (simp add: chain_def sub)"], ["proof (state)\nthis:\n  chain (\\<lambda>i. if i = 0 then A else B)\n\ngoal (1 subgoal):\n 1. mono f", "then"], ["proof (chain)\npicking this:\n  chain (\\<lambda>i. if i = 0 then A else B)", "have fC: \"chain (f o ?C)\""], ["proof (prove)\nusing this:\n  chain (\\<lambda>i. if i = 0 then A else B)\n\ngoal (1 subgoal):\n 1. chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B))", "using continuous continuous_def"], ["proof (prove)\nusing this:\n  chain (\\<lambda>i. if i = 0 then A else B)\n  continuous f\n  continuous ?f =\n  (\\<forall>C.\n      chain C \\<longrightarrow>\n      chain (?f \\<circ> C) \\<and> ?f (natUnion C) = natUnion (?f \\<circ> C))\n\ngoal (1 subgoal):\n 1. chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B))", "by blast"], ["proof (state)\nthis:\n  chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B))\n\ngoal (1 subgoal):\n 1. mono f", "then"], ["proof (chain)\npicking this:\n  chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B))", "have \"f (?C 0) \\<subseteq> f (?C (0 + 1))\""], ["proof (prove)\nusing this:\n  chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B))\n\ngoal (1 subgoal):\n 1. f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B)) \\<Longrightarrow>\n    f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)", "have \"\\<And>f n. \\<not> chain f \\<or> (f n::'b set) \\<subseteq> f (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f n. \\<not> chain f \\<or> f n \\<subseteq> f (Suc n)", "by (metis Suc_eq_plus1 chain_def)"], ["proof (state)\nthis:\n  \\<not> chain ?f \\<or> ?f ?n \\<subseteq> ?f (Suc ?n)\n\ngoal (1 subgoal):\n 1. chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B)) \\<Longrightarrow>\n    f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)", "then"], ["proof (chain)\npicking this:\n  \\<not> chain ?f \\<or> ?f ?n \\<subseteq> ?f (Suc ?n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> chain ?f \\<or> ?f ?n \\<subseteq> ?f (Suc ?n)\n\ngoal (1 subgoal):\n 1. f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)", "using fC"], ["proof (prove)\nusing this:\n  \\<not> chain ?f \\<or> ?f ?n \\<subseteq> ?f (Suc ?n)\n  chain (f \\<circ> (\\<lambda>i. if i = 0 then A else B))\n\ngoal (1 subgoal):\n 1. f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)", "by fastforce"], ["proof (state)\nthis:\n  f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)\n\ngoal (1 subgoal):\n 1. mono f", "then"], ["proof (chain)\npicking this:\n  f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)", "have \"f A \\<subseteq> f B\""], ["proof (prove)\nusing this:\n  f (if 0 = 0 then A else B) \\<subseteq> f (if 0 + 1 = 0 then A else B)\n\ngoal (1 subgoal):\n 1. f A \\<subseteq> f B", "by auto"], ["proof (state)\nthis:\n  f A \\<subseteq> f B\n\ngoal (1 subgoal):\n 1. mono f", "}"], ["proof (state)\nthis:\n  ?A2 \\<subseteq> ?B2 \\<Longrightarrow> f ?A2 \\<subseteq> f ?B2\n\ngoal (1 subgoal):\n 1. mono f", "then"], ["proof (chain)\npicking this:\n  ?A2 \\<subseteq> ?B2 \\<Longrightarrow> f ?A2 \\<subseteq> f ?B2", "show \"mono f\""], ["proof (prove)\nusing this:\n  ?A2 \\<subseteq> ?B2 \\<Longrightarrow> f ?A2 \\<subseteq> f ?B2\n\ngoal (1 subgoal):\n 1. mono f", "by (simp add: monoI)"], ["proof (state)\nthis:\n  mono f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_maps_chain_to_chain: \n  assumes f: \"mono f\"\n  assumes C: \"chain C\"\n  shows \"chain (f o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (f \\<circ> C)", "by (metis C comp_def f chain_def mono_def)"], ["", "lemma natUnion_upperbound: \n  \"(\\<And> n. f n \\<subseteq> G) \\<Longrightarrow> (natUnion f) \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. f n \\<subseteq> G) \\<Longrightarrow> natUnion f \\<subseteq> G", "by (auto simp add: natUnion_def)"], ["", "lemma funpower_upperbound:\n  \"(\\<And> I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G) \\<Longrightarrow> I \\<subseteq> G \\<Longrightarrow> funpower f n I \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n     I \\<subseteq> G\\<rbrakk>\n    \\<Longrightarrow> funpower f n I \\<subseteq> G", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n     I \\<subseteq> G\\<rbrakk>\n    \\<Longrightarrow> funpower f 0 I \\<subseteq> G\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>\\<And>I.\n                            I \\<subseteq> G \\<Longrightarrow>\n                            f I \\<subseteq> G;\n                 I \\<subseteq> G\\<rbrakk>\n                \\<Longrightarrow> funpower f n I \\<subseteq> G;\n        \\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n        I \\<subseteq> G\\<rbrakk>\n       \\<Longrightarrow> funpower f (Suc n) I \\<subseteq> G", "case 0"], ["proof (state)\nthis:\n  ?I \\<subseteq> G \\<Longrightarrow> f ?I \\<subseteq> G\n  I \\<subseteq> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n     I \\<subseteq> G\\<rbrakk>\n    \\<Longrightarrow> funpower f 0 I \\<subseteq> G\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>\\<And>I.\n                            I \\<subseteq> G \\<Longrightarrow>\n                            f I \\<subseteq> G;\n                 I \\<subseteq> G\\<rbrakk>\n                \\<Longrightarrow> funpower f n I \\<subseteq> G;\n        \\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n        I \\<subseteq> G\\<rbrakk>\n       \\<Longrightarrow> funpower f (Suc n) I \\<subseteq> G", "thus ?case"], ["proof (prove)\nusing this:\n  ?I \\<subseteq> G \\<Longrightarrow> f ?I \\<subseteq> G\n  I \\<subseteq> G\n\ngoal (1 subgoal):\n 1. funpower f 0 I \\<subseteq> G", "by simp"], ["proof (state)\nthis:\n  funpower f 0 I \\<subseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>\\<And>I.\n                            I \\<subseteq> G \\<Longrightarrow>\n                            f I \\<subseteq> G;\n                 I \\<subseteq> G\\<rbrakk>\n                \\<Longrightarrow> funpower f n I \\<subseteq> G;\n        \\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n        I \\<subseteq> G\\<rbrakk>\n       \\<Longrightarrow> funpower f (Suc n) I \\<subseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>\\<And>I.\n                            I \\<subseteq> G \\<Longrightarrow>\n                            f I \\<subseteq> G;\n                 I \\<subseteq> G\\<rbrakk>\n                \\<Longrightarrow> funpower f n I \\<subseteq> G;\n        \\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n        I \\<subseteq> G\\<rbrakk>\n       \\<Longrightarrow> funpower f (Suc n) I \\<subseteq> G", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n   I \\<subseteq> G\\<rbrakk>\n  \\<Longrightarrow> funpower f n I \\<subseteq> G\n  ?I \\<subseteq> G \\<Longrightarrow> f ?I \\<subseteq> G\n  I \\<subseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>\\<And>I.\n                            I \\<subseteq> G \\<Longrightarrow>\n                            f I \\<subseteq> G;\n                 I \\<subseteq> G\\<rbrakk>\n                \\<Longrightarrow> funpower f n I \\<subseteq> G;\n        \\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n        I \\<subseteq> G\\<rbrakk>\n       \\<Longrightarrow> funpower f (Suc n) I \\<subseteq> G", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n   I \\<subseteq> G\\<rbrakk>\n  \\<Longrightarrow> funpower f n I \\<subseteq> G\n  ?I \\<subseteq> G \\<Longrightarrow> f ?I \\<subseteq> G\n  I \\<subseteq> G\n\ngoal (1 subgoal):\n 1. funpower f (Suc n) I \\<subseteq> G", "by simp"], ["proof (state)\nthis:\n  funpower f (Suc n) I \\<subseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma limit_upperbound:\n  \"(\\<And> I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G) \\<Longrightarrow> I \\<subseteq> G \\<Longrightarrow> limit f I \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I. I \\<subseteq> G \\<Longrightarrow> f I \\<subseteq> G;\n     I \\<subseteq> G\\<rbrakk>\n    \\<Longrightarrow> limit f I \\<subseteq> G", "by (simp add: funpower_upperbound limit_def natUnion_upperbound)"], ["", "lemma elem_limit_simp: \"x \\<in> limit f X = (\\<exists> n. x \\<in> funpower f n X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> limit f X) = (\\<exists>n. x \\<in> funpower f n X)", "by (auto simp add: limit_def natUnion_def)"], ["", "definition pointwise :: \"('a set \\<Rightarrow> 'b set) \\<Rightarrow> bool\" where\n  \"pointwise f = (\\<forall> X. f X = \\<Union> { f {x} | x. x \\<in> X})\""], ["", "lemma pointwise_simp: \n  assumes f: \"pointwise f\"\n  shows \"f X =  \\<Union> { f {x} | x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f X = \\<Union> {f {x} |x. x \\<in> X}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f X = \\<Union> {f {x} |x. x \\<in> X}", "from f"], ["proof (chain)\npicking this:\n  pointwise f", "have \"\\<forall> X. f X = \\<Union> { f {x} | x. x \\<in> X}\""], ["proof (prove)\nusing this:\n  pointwise f\n\ngoal (1 subgoal):\n 1. \\<forall>X. f X = \\<Union> {f {x} |x. x \\<in> X}", "by (rule iffD1[OF pointwise_def[where f=f]])"], ["proof (state)\nthis:\n  \\<forall>X. f X = \\<Union> {f {x} |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. f X = \\<Union> {f {x} |x. x \\<in> X}", "then"], ["proof (chain)\npicking this:\n  \\<forall>X. f X = \\<Union> {f {x} |x. x \\<in> X}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>X. f X = \\<Union> {f {x} |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. f X = \\<Union> {f {x} |x. x \\<in> X}", "by blast"], ["proof (state)\nthis:\n  f X = \\<Union> {f {x} |x. x \\<in> X}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma natUnion_elem: \"x \\<in> f n \\<Longrightarrow> x \\<in> natUnion f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f n \\<Longrightarrow> x \\<in> natUnion f", "using natUnion_def"], ["proof (prove)\nusing this:\n  natUnion ?f = \\<Union> {?f n |n. True}\n\ngoal (1 subgoal):\n 1. x \\<in> f n \\<Longrightarrow> x \\<in> natUnion f", "by fastforce"], ["", "lemma limit_elem: \"x \\<in> funpower f n X \\<Longrightarrow> x \\<in> limit f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> funpower f n X \\<Longrightarrow> x \\<in> limit f X", "by (simp add: limit_def natUnion_elem)"], ["", "lemma limit_step_pointwise:\n  assumes x: \"x \\<in> limit f X\"\n  assumes f: \"pointwise f\"\n  assumes y: \"y \\<in> f {x}\"\n  shows \"y \\<in> limit f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> limit f X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> limit f X", "from x"], ["proof (chain)\npicking this:\n  x \\<in> limit f X", "have \"\\<exists> n. x \\<in> funpower f n X\""], ["proof (prove)\nusing this:\n  x \\<in> limit f X\n\ngoal (1 subgoal):\n 1. \\<exists>n. x \\<in> funpower f n X", "by (simp add: elem_limit_simp)"], ["proof (state)\nthis:\n  \\<exists>n. x \\<in> funpower f n X\n\ngoal (1 subgoal):\n 1. y \\<in> limit f X", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. x \\<in> funpower f n X", "obtain n where n: \"x \\<in> funpower f n X\""], ["proof (prove)\nusing this:\n  \\<exists>n. x \\<in> funpower f n X\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x \\<in> funpower f n X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> funpower f n X\n\ngoal (1 subgoal):\n 1. y \\<in> limit f X", "have \"y \\<in> funpower f (Suc n) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> funpower f (Suc n) X", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> f (funpower f n X)", "apply (subst pointwise_simp[OF f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> \\<Union> {f {x} |x. x \\<in> funpower f n X}", "using y n"], ["proof (prove)\nusing this:\n  y \\<in> f {x}\n  x \\<in> funpower f n X\n\ngoal (1 subgoal):\n 1. y \\<in> \\<Union> {f {x} |x. x \\<in> funpower f n X}", "by auto"], ["proof (state)\nthis:\n  y \\<in> funpower f (Suc n) X\n\ngoal (1 subgoal):\n 1. y \\<in> limit f X", "then"], ["proof (chain)\npicking this:\n  y \\<in> funpower f (Suc n) X", "show \"y \\<in> limit f X\""], ["proof (prove)\nusing this:\n  y \\<in> funpower f (Suc n) X\n\ngoal (1 subgoal):\n 1. y \\<in> limit f X", "by (meson limit_elem)"], ["proof (state)\nthis:\n  y \\<in> limit f X\n\ngoal:\nNo subgoals!", "qed"], ["", "definition pointbase :: \"('a set \\<Rightarrow> 'b set) \\<Rightarrow> 'a set \\<Rightarrow> 'b set\" where\n  \"pointbase F I = \\<Union> { F X | X. finite X \\<and> X \\<subseteq> I }\""], ["", "definition pointbased :: \"('a set \\<Rightarrow> 'b set) \\<Rightarrow> bool\" where\n  \"pointbased f = (\\<exists> F. f = pointbase F)\""], ["", "lemma pointwise_implies_pointbased:\n  assumes pointwise: \"pointwise f\"\n  shows \"pointbased f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbased f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased f", "let ?F = \"\\<lambda> X. f X\""], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased f", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased f", "fix I :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased f", "fix x :: \"'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased f", "have lr: \"x \\<in> pointbase ?F I \\<Longrightarrow> x \\<in> f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I", "assume x: \"x \\<in> pointbase ?F I\""], ["proof (state)\nthis:\n  x \\<in> pointbase f I\n\ngoal (1 subgoal):\n 1. x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I", "have \"\\<exists> X. x \\<in> f X \\<and> X \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I", "have \"x \\<in> \\<Union>{f A |A. finite A \\<and> A \\<subseteq> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> I}", "by (metis pointbase_def x)"], ["proof (state)\nthis:\n  x \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> I}\n\ngoal (1 subgoal):\n 1. \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> I}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> I}\n\ngoal (1 subgoal):\n 1. \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I", "by blast"], ["proof (state)\nthis:\n  \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I\n\ngoal (1 subgoal):\n 1. x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I", "then"], ["proof (chain)\npicking this:\n  \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I", "obtain X where X:\"x \\<in> f X \\<and> X \\<subseteq> I\""], ["proof (prove)\nusing this:\n  \\<exists>X. x \\<in> f X \\<and> X \\<subseteq> I\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        x \\<in> f X \\<and> X \\<subseteq> I \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> f X \\<and> X \\<subseteq> I\n\ngoal (1 subgoal):\n 1. x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I", "have \"\\<exists> y. y \\<in> I \\<and> x \\<in> f {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "using X"], ["proof (prove)\nusing this:\n  x \\<in> f X \\<and> X \\<subseteq> I\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "apply (simp add: pointwise_simp[OF pointwise, where X=X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xa.\n        (\\<exists>x. xa = f {x} \\<and> x \\<in> X) \\<and> x \\<in> xa) \\<and>\n    X \\<subseteq> I \\<Longrightarrow>\n    \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}\n\ngoal (1 subgoal):\n 1. x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "show \"x \\<in> f I\""], ["proof (prove)\nusing this:\n  \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}\n\ngoal (1 subgoal):\n 1. x \\<in> f I", "apply (simp add: pointwise_simp[OF pointwise, where X=I])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in> I \\<and> x \\<in> f {y} \\<Longrightarrow>\n    \\<exists>xa. (\\<exists>x. xa = f {x} \\<and> x \\<in> I) \\<and> x \\<in> xa", "by blast"], ["proof (state)\nthis:\n  x \\<in> f I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I\n\ngoal (1 subgoal):\n 1. pointbased f", "have rl: \"x \\<in> f I \\<Longrightarrow> x \\<in> pointbase ?F I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I", "assume x: \"x \\<in> f I\""], ["proof (state)\nthis:\n  x \\<in> f I\n\ngoal (1 subgoal):\n 1. x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I", "have \"\\<exists> y. y \\<in> I \\<and> x \\<in> f {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "using x"], ["proof (prove)\nusing this:\n  x \\<in> f I\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "apply (simp add: pointwise_simp[OF pointwise, where X=I])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       (\\<exists>x. xa = f {x} \\<and> x \\<in> I) \\<and>\n       x \\<in> xa \\<Longrightarrow>\n    \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}\n\ngoal (1 subgoal):\n 1. x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}", "obtain y where \"y \\<in> I \\<and> x \\<in> f {y}\""], ["proof (prove)\nusing this:\n  \\<exists>y. y \\<in> I \\<and> x \\<in> f {y}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<in> I \\<and> x \\<in> f {y} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> I \\<and> x \\<in> f {y}\n\ngoal (1 subgoal):\n 1. x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I", "then"], ["proof (chain)\npicking this:\n  y \\<in> I \\<and> x \\<in> f {y}", "have \"\\<exists> X. x \\<in> f X \\<and> finite X \\<and> X \\<subseteq> I\""], ["proof (prove)\nusing this:\n  y \\<in> I \\<and> x \\<in> f {y}\n\ngoal (1 subgoal):\n 1. \\<exists>X. x \\<in> f X \\<and> finite X \\<and> X \\<subseteq> I", "by blast"], ["proof (state)\nthis:\n  \\<exists>X. x \\<in> f X \\<and> finite X \\<and> X \\<subseteq> I\n\ngoal (1 subgoal):\n 1. x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I", "then"], ["proof (chain)\npicking this:\n  \\<exists>X. x \\<in> f X \\<and> finite X \\<and> X \\<subseteq> I", "show \"x \\<in> pointbase f I\""], ["proof (prove)\nusing this:\n  \\<exists>X. x \\<in> f X \\<and> finite X \\<and> X \\<subseteq> I\n\ngoal (1 subgoal):\n 1. x \\<in> pointbase f I", "apply (simp add: pointbase_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X.\n       x \\<in> f X \\<and> finite X \\<and> X \\<subseteq> I \\<Longrightarrow>\n    \\<exists>xa.\n       (\\<exists>X. xa = f X \\<and> finite X \\<and> X \\<subseteq> I) \\<and>\n       x \\<in> xa", "by blast"], ["proof (state)\nthis:\n  x \\<in> pointbase f I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I\n\ngoal (1 subgoal):\n 1. pointbased f", "note lr rl"], ["proof (state)\nthis:\n  x \\<in> pointbase f I \\<Longrightarrow> x \\<in> f I\n  x \\<in> f I \\<Longrightarrow> x \\<in> pointbase f I\n\ngoal (1 subgoal):\n 1. pointbased f", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> pointbase f ?I2 \\<Longrightarrow> ?x2 \\<in> f ?I2\n  ?x2 \\<in> f ?I2 \\<Longrightarrow> ?x2 \\<in> pointbase f ?I2\n\ngoal (1 subgoal):\n 1. pointbased f", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> pointbase f ?I2 \\<Longrightarrow> ?x2 \\<in> f ?I2\n  ?x2 \\<in> f ?I2 \\<Longrightarrow> ?x2 \\<in> pointbase f ?I2", "have \"\\<And> I. pointbase f I = f I\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> pointbase f ?I2 \\<Longrightarrow> ?x2 \\<in> f ?I2\n  ?x2 \\<in> f ?I2 \\<Longrightarrow> ?x2 \\<in> pointbase f ?I2\n\ngoal (1 subgoal):\n 1. \\<And>I. pointbase f I = f I", "by blast"], ["proof (state)\nthis:\n  pointbase f ?I = f ?I\n\ngoal (1 subgoal):\n 1. pointbased f", "then"], ["proof (chain)\npicking this:\n  pointbase f ?I = f ?I", "have \"pointbase f = f\""], ["proof (prove)\nusing this:\n  pointbase f ?I = f ?I\n\ngoal (1 subgoal):\n 1. pointbase f = f", "by blast"], ["proof (state)\nthis:\n  pointbase f = f\n\ngoal (1 subgoal):\n 1. pointbased f", "then"], ["proof (chain)\npicking this:\n  pointbase f = f", "show ?thesis"], ["proof (prove)\nusing this:\n  pointbase f = f\n\ngoal (1 subgoal):\n 1. pointbased f", "by (metis pointbased_def)"], ["proof (state)\nthis:\n  pointbased f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pointbase_is_mono:\n  \"mono (pointbase f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (pointbase f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mono (pointbase f)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mono (pointbase f)", "fix A :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono (pointbase f)", "fix B :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono (pointbase f)", "assume subset: \"A \\<subseteq> B\""], ["proof (state)\nthis:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. mono (pointbase f)", "have \"(pointbase f) A \\<subseteq> (pointbase f) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbase f A \\<subseteq> pointbase f B", "apply (simp add: pointbase_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {f X |X. finite X \\<and> X \\<subseteq> A}\n    \\<subseteq> \\<Union> {f X |X. finite X \\<and> X \\<subseteq> B}", "using subset"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<Union> {f X |X. finite X \\<and> X \\<subseteq> A}\n    \\<subseteq> \\<Union> {f X |X. finite X \\<and> X \\<subseteq> B}", "by fastforce"], ["proof (state)\nthis:\n  pointbase f A \\<subseteq> pointbase f B\n\ngoal (1 subgoal):\n 1. mono (pointbase f)", "}"], ["proof (state)\nthis:\n  ?A2 \\<subseteq> ?B2 \\<Longrightarrow>\n  pointbase f ?A2 \\<subseteq> pointbase f ?B2\n\ngoal (1 subgoal):\n 1. mono (pointbase f)", "then"], ["proof (chain)\npicking this:\n  ?A2 \\<subseteq> ?B2 \\<Longrightarrow>\n  pointbase f ?A2 \\<subseteq> pointbase f ?B2", "show ?thesis"], ["proof (prove)\nusing this:\n  ?A2 \\<subseteq> ?B2 \\<Longrightarrow>\n  pointbase f ?A2 \\<subseteq> pointbase f ?B2\n\ngoal (1 subgoal):\n 1. mono (pointbase f)", "by (simp add: mono_def)"], ["proof (state)\nthis:\n  mono (pointbase f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_implies_mono: \"chain C \\<Longrightarrow> mono C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain C \\<Longrightarrow> mono C", "by (simp add: chain_def mono_iff_le_Suc)"], ["", "lemma chain_cover_witness: \"finite X \\<Longrightarrow> chain C \\<Longrightarrow> X \\<subseteq> natUnion C \\<Longrightarrow> \\<exists> n. X \\<subseteq> C n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; chain C; X \\<subseteq> natUnion C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. X \\<subseteq> C n", "proof (induct rule: finite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>chain C; {} \\<subseteq> natUnion C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. {} \\<subseteq> C n\n 2. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "case emptyI"], ["proof (state)\nthis:\n  chain C\n  {} \\<subseteq> natUnion C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>chain C; {} \\<subseteq> natUnion C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. {} \\<subseteq> C n\n 2. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "thus ?case"], ["proof (prove)\nusing this:\n  chain C\n  {} \\<subseteq> natUnion C\n\ngoal (1 subgoal):\n 1. \\<exists>n. {} \\<subseteq> C n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. {} \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "case (insertI X x)"], ["proof (state)\nthis:\n  finite X\n  \\<lbrakk>chain C; X \\<subseteq> natUnion C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. X \\<subseteq> C n\n  chain C\n  insert x X \\<subseteq> natUnion C\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "then"], ["proof (chain)\npicking this:\n  finite X\n  \\<lbrakk>chain C; X \\<subseteq> natUnion C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. X \\<subseteq> C n\n  chain C\n  insert x X \\<subseteq> natUnion C", "have \"X \\<subseteq> natUnion C\""], ["proof (prove)\nusing this:\n  finite X\n  \\<lbrakk>chain C; X \\<subseteq> natUnion C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. X \\<subseteq> C n\n  chain C\n  insert x X \\<subseteq> natUnion C\n\ngoal (1 subgoal):\n 1. X \\<subseteq> natUnion C", "by simp"], ["proof (state)\nthis:\n  X \\<subseteq> natUnion C\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "with insertI"], ["proof (chain)\npicking this:\n  finite X\n  \\<lbrakk>chain C; X \\<subseteq> natUnion C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. X \\<subseteq> C n\n  chain C\n  insert x X \\<subseteq> natUnion C\n  X \\<subseteq> natUnion C", "have \"\\<exists> n. X \\<subseteq> C n\""], ["proof (prove)\nusing this:\n  finite X\n  \\<lbrakk>chain C; X \\<subseteq> natUnion C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. X \\<subseteq> C n\n  chain C\n  insert x X \\<subseteq> natUnion C\n  X \\<subseteq> natUnion C\n\ngoal (1 subgoal):\n 1. \\<exists>n. X \\<subseteq> C n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. X \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. X \\<subseteq> C n", "obtain n where n: \"X \\<subseteq> C n\""], ["proof (prove)\nusing this:\n  \\<exists>n. X \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. (\\<And>n. X \\<subseteq> C n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  X \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "have x: \"x \\<in> natUnion C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> natUnion C", "using insertI.prems(2)"], ["proof (prove)\nusing this:\n  insert x X \\<subseteq> natUnion C\n\ngoal (1 subgoal):\n 1. x \\<in> natUnion C", "by blast"], ["proof (state)\nthis:\n  x \\<in> natUnion C\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "then"], ["proof (chain)\npicking this:\n  x \\<in> natUnion C", "have \"\\<exists> m. x \\<in> C m\""], ["proof (prove)\nusing this:\n  x \\<in> natUnion C\n\ngoal (1 subgoal):\n 1. \\<exists>m. x \\<in> C m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> natUnion C \\<Longrightarrow> \\<exists>m. x \\<in> C m", "have \"x \\<in> \\<Union>{A. \\<exists>n. A = C n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> {A. \\<exists>n. A = C n}", "by (metis x natUnion_def)"], ["proof (state)\nthis:\n  x \\<in> \\<Union> {A. \\<exists>n. A = C n}\n\ngoal (1 subgoal):\n 1. x \\<in> natUnion C \\<Longrightarrow> \\<exists>m. x \\<in> C m", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> {A. \\<exists>n. A = C n}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> {A. \\<exists>n. A = C n}\n\ngoal (1 subgoal):\n 1. \\<exists>m. x \\<in> C m", "by blast"], ["proof (state)\nthis:\n  \\<exists>m. x \\<in> C m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m. x \\<in> C m\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. x \\<in> C m", "obtain m where m: \"x \\<in> C m\""], ["proof (prove)\nusing this:\n  \\<exists>m. x \\<in> C m\n\ngoal (1 subgoal):\n 1. (\\<And>m. x \\<in> C m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> C m\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "have mono_C: \"\\<And> i j. i \\<le> j \\<Longrightarrow> C i \\<subseteq> C j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j. i \\<le> j \\<Longrightarrow> C i \\<subseteq> C j", "using chain_implies_mono insertI(3) mono_def"], ["proof (prove)\nusing this:\n  chain ?C \\<Longrightarrow> mono ?C\n  chain C\n  mono ?f = (\\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y)\n\ngoal (1 subgoal):\n 1. \\<And>i j. i \\<le> j \\<Longrightarrow> C i \\<subseteq> C j", "by blast"], ["proof (state)\nthis:\n  ?i \\<le> ?j \\<Longrightarrow> C ?i \\<subseteq> C ?j\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        \\<lbrakk>chain C; A \\<subseteq> natUnion C\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n. A \\<subseteq> C n;\n        chain C; insert a A \\<subseteq> natUnion C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert a A \\<subseteq> C n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. insert x X \\<subseteq> C n", "apply (rule_tac x=\"max n m\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x X \\<subseteq> C (max n m)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> C (max n m)\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> C (max n m)", "apply (meson contra_subsetD m max.cobounded2 mono_C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> C (max n m)", "by (metis max_def mono_C n subsetCE)"], ["proof (state)\nthis:\n  \\<exists>n. insert x X \\<subseteq> C n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pointbase_is_continuous:\n  \"continuous (pointbase f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "fix C :: \"nat \\<Rightarrow> 'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "assume C: \"chain C\""], ["proof (state)\nthis:\n  chain C\n\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "have mono: \"chain ((pointbase f) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (pointbase f \\<circ> C)", "by (simp add: C mono_maps_chain_to_chain pointbase_is_mono)"], ["proof (state)\nthis:\n  chain (pointbase f \\<circ> C)\n\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "have subset1: \"natUnion ((pointbase f) o C) \\<subseteq> (pointbase f) (natUnion C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (pointbase f \\<circ> C) \\<subseteq> pointbase f (natUnion C)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> natUnion (pointbase f \\<circ> C) \\<Longrightarrow>\n       x \\<in> pointbase f (natUnion C)", "fix y :: \"'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> natUnion (pointbase f \\<circ> C) \\<Longrightarrow>\n       x \\<in> pointbase f (natUnion C)", "assume \"y \\<in> natUnion ((pointbase f) o C)\""], ["proof (state)\nthis:\n  y \\<in> natUnion (pointbase f \\<circ> C)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> natUnion (pointbase f \\<circ> C) \\<Longrightarrow>\n       x \\<in> pointbase f (natUnion C)", "then"], ["proof (chain)\npicking this:\n  y \\<in> natUnion (pointbase f \\<circ> C)", "show \"y \\<in> (pointbase f) (natUnion C)\""], ["proof (prove)\nusing this:\n  y \\<in> natUnion (pointbase f \\<circ> C)\n\ngoal (1 subgoal):\n 1. y \\<in> pointbase f (natUnion C)", "proof (induct rule: natUnion_decompose)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p.\n       p \\<in> (pointbase f \\<circ> C) n \\<Longrightarrow>\n       p \\<in> pointbase f (natUnion C)", "case (Decompose n p)"], ["proof (state)\nthis:\n  p \\<in> (pointbase f \\<circ> C) n\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       p \\<in> (pointbase f \\<circ> C) n \\<Longrightarrow>\n       p \\<in> pointbase f (natUnion C)", "thus ?case"], ["proof (prove)\nusing this:\n  p \\<in> (pointbase f \\<circ> C) n\n\ngoal (1 subgoal):\n 1. p \\<in> pointbase f (natUnion C)", "by (metis comp_apply contra_subsetD mono_def natUnion_elem \n            pointbase_is_mono subsetI)"], ["proof (state)\nthis:\n  p \\<in> pointbase f (natUnion C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> pointbase f (natUnion C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  natUnion (pointbase f \\<circ> C) \\<subseteq> pointbase f (natUnion C)\n\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "have subset2: \"(pointbase f) (natUnion C) \\<subseteq> natUnion ((pointbase f) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbase f (natUnion C) \\<subseteq> natUnion (pointbase f \\<circ> C)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pointbase f (natUnion C) \\<Longrightarrow>\n       x \\<in> natUnion (pointbase f \\<circ> C)", "fix y :: \"'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pointbase f (natUnion C) \\<Longrightarrow>\n       x \\<in> natUnion (pointbase f \\<circ> C)", "assume y: \"y \\<in> (pointbase f) (natUnion C)\""], ["proof (state)\nthis:\n  y \\<in> pointbase f (natUnion C)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pointbase f (natUnion C) \\<Longrightarrow>\n       x \\<in> natUnion (pointbase f \\<circ> C)", "have \"\\<exists> X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X", "have \"y \\<in> \\<Union>{f A |A. finite A \\<and> A \\<subseteq> natUnion C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> natUnion C}", "by (metis y pointbase_def)"], ["proof (state)\nthis:\n  y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> natUnion C}\n\ngoal (1 subgoal):\n 1. \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X", "then"], ["proof (chain)\npicking this:\n  y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> natUnion C}", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> natUnion C}\n\ngoal (1 subgoal):\n 1. \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X", "by blast"], ["proof (state)\nthis:\n  \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pointbase f (natUnion C) \\<Longrightarrow>\n       x \\<in> natUnion (pointbase f \\<circ> C)", "then"], ["proof (chain)\npicking this:\n  \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X", "obtain X where X: \"finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\""], ["proof (prove)\nusing this:\n  \\<exists>X. finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        finite X \\<and>\n        X \\<subseteq> natUnion C \\<and> y \\<in> f X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pointbase f (natUnion C) \\<Longrightarrow>\n       x \\<in> natUnion (pointbase f \\<circ> C)", "then"], ["proof (chain)\npicking this:\n  finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X", "have \"\\<exists> n. X \\<subseteq> C n\""], ["proof (prove)\nusing this:\n  finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\n\ngoal (1 subgoal):\n 1. \\<exists>n. X \\<subseteq> C n", "using chain_cover_witness C"], ["proof (prove)\nusing this:\n  finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\n  \\<lbrakk>finite ?X; chain ?C; ?X \\<subseteq> natUnion ?C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. ?X \\<subseteq> ?C n\n  chain C\n\ngoal (1 subgoal):\n 1. \\<exists>n. X \\<subseteq> C n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. X \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pointbase f (natUnion C) \\<Longrightarrow>\n       x \\<in> natUnion (pointbase f \\<circ> C)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. X \\<subseteq> C n", "obtain n where X_sub_C: \"X \\<subseteq> C n\""], ["proof (prove)\nusing this:\n  \\<exists>n. X \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. (\\<And>n. X \\<subseteq> C n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  X \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pointbase f (natUnion C) \\<Longrightarrow>\n       x \\<in> natUnion (pointbase f \\<circ> C)", "show \"y \\<in> natUnion ((pointbase f) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> natUnion (pointbase f \\<circ> C)", "apply (rule_tac natUnion_elem[where n=n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> (pointbase f \\<circ> C) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> (pointbase f \\<circ> C) n", "have \"y \\<in> \\<Union>{f A |A. finite A \\<and> A \\<subseteq> C n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> C n}", "using X X_sub_C"], ["proof (prove)\nusing this:\n  finite X \\<and> X \\<subseteq> natUnion C \\<and> y \\<in> f X\n  X \\<subseteq> C n\n\ngoal (1 subgoal):\n 1. y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> C n}", "by blast"], ["proof (state)\nthis:\n  y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> C n}\n\ngoal (1 subgoal):\n 1. y \\<in> (pointbase f \\<circ> C) n", "then"], ["proof (chain)\npicking this:\n  y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> C n}", "show \"y \\<in> (pointbase f \\<circ> C) n\""], ["proof (prove)\nusing this:\n  y \\<in> \\<Union> {f A |A. finite A \\<and> A \\<subseteq> C n}\n\ngoal (1 subgoal):\n 1. y \\<in> (pointbase f \\<circ> C) n", "by (simp add: pointbase_def)"], ["proof (state)\nthis:\n  y \\<in> (pointbase f \\<circ> C) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> natUnion (pointbase f \\<circ> C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pointbase f (natUnion C) \\<subseteq> natUnion (pointbase f \\<circ> C)\n\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "note mono subset1 subset2"], ["proof (state)\nthis:\n  chain (pointbase f \\<circ> C)\n  natUnion (pointbase f \\<circ> C) \\<subseteq> pointbase f (natUnion C)\n  pointbase f (natUnion C) \\<subseteq> natUnion (pointbase f \\<circ> C)\n\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "}"], ["proof (state)\nthis:\n  chain ?C2 \\<Longrightarrow> chain (pointbase f \\<circ> ?C2)\n  chain ?C2 \\<Longrightarrow>\n  natUnion (pointbase f \\<circ> ?C2) \\<subseteq> pointbase f (natUnion ?C2)\n  chain ?C2 \\<Longrightarrow>\n  pointbase f (natUnion ?C2) \\<subseteq> natUnion (pointbase f \\<circ> ?C2)\n\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "then"], ["proof (chain)\npicking this:\n  chain ?C2 \\<Longrightarrow> chain (pointbase f \\<circ> ?C2)\n  chain ?C2 \\<Longrightarrow>\n  natUnion (pointbase f \\<circ> ?C2) \\<subseteq> pointbase f (natUnion ?C2)\n  chain ?C2 \\<Longrightarrow>\n  pointbase f (natUnion ?C2) \\<subseteq> natUnion (pointbase f \\<circ> ?C2)", "show ?thesis"], ["proof (prove)\nusing this:\n  chain ?C2 \\<Longrightarrow> chain (pointbase f \\<circ> ?C2)\n  chain ?C2 \\<Longrightarrow>\n  natUnion (pointbase f \\<circ> ?C2) \\<subseteq> pointbase f (natUnion ?C2)\n  chain ?C2 \\<Longrightarrow>\n  pointbase f (natUnion ?C2) \\<subseteq> natUnion (pointbase f \\<circ> ?C2)\n\ngoal (1 subgoal):\n 1. continuous (pointbase f)", "by (simp add: continuous_def subset_antisym)"], ["proof (state)\nthis:\n  continuous (pointbase f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pointbased_implies_continuous:\n  \"pointbased f \\<Longrightarrow> continuous f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbased f \\<Longrightarrow> continuous f", "using pointbase_is_continuous pointbased_def"], ["proof (prove)\nusing this:\n  continuous (pointbase ?f)\n  pointbased ?f = (\\<exists>F. ?f = pointbase F)\n\ngoal (1 subgoal):\n 1. pointbased f \\<Longrightarrow> continuous f", "by force"], ["", "lemma setmonotone_implies_chain_funpower:\n  assumes setmonotone: \"setmonotone f\"\n  shows \"chain (\\<lambda> n. funpower f n I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. funpower f n I)", "by (simp add: chain_def setmonotone subset_setmonotone)"], ["", "lemma natUnion_subset: \"(\\<And> n. \\<exists> m. f n \\<subseteq> g m) \\<Longrightarrow> natUnion f \\<subseteq> natUnion g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. \\<exists>m. f n \\<subseteq> g m) \\<Longrightarrow>\n    natUnion f \\<subseteq> natUnion g", "by (meson natUnion_elem natUnion_upperbound subset_iff)"], ["", "lemma natUnion_eq[case_names Subset Superset]: \n  \"(\\<And> n. \\<exists> m. f n \\<subseteq> g m) \\<Longrightarrow> (\\<And> n. \\<exists> m. g n \\<subseteq> f m) \\<Longrightarrow> natUnion f = natUnion g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n. \\<exists>m. f n \\<subseteq> g m;\n     \\<And>n. \\<exists>m. g n \\<subseteq> f m\\<rbrakk>\n    \\<Longrightarrow> natUnion f = natUnion g", "by (simp add: natUnion_subset subset_antisym)"], ["", "lemma natUnion_shift[symmetric]: \n  assumes chain: \"chain C\"\n  shows \"natUnion C = natUnion (\\<lambda> n. C (n + m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion C = natUnion (\\<lambda>n. C (n + m))", "proof (induct rule: natUnion_eq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. \\<exists>ma. C n \\<subseteq> C (ma + m)\n 2. \\<And>n. \\<exists>ma. C (n + m) \\<subseteq> C ma", "case (Subset n)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. \\<exists>ma. C n \\<subseteq> C (ma + m)\n 2. \\<And>n. \\<exists>ma. C (n + m) \\<subseteq> C ma", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ma. C n \\<subseteq> C (ma + m)", "using chain chain_implies_mono le_add1 mono_def"], ["proof (prove)\nusing this:\n  chain C\n  chain ?C \\<Longrightarrow> mono ?C\n  ?n \\<le> ?n + ?m\n  mono ?f = (\\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y)\n\ngoal (1 subgoal):\n 1. \\<exists>ma. C n \\<subseteq> C (ma + m)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ma. C n \\<subseteq> C (ma + m)\n\ngoal (1 subgoal):\n 1. \\<And>n. \\<exists>ma. C (n + m) \\<subseteq> C ma", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. \\<exists>ma. C (n + m) \\<subseteq> C ma", "case (Superset n)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>n. \\<exists>ma. C (n + m) \\<subseteq> C ma", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ma. C (n + m) \\<subseteq> C ma", "by blast"], ["proof (state)\nthis:\n  \\<exists>ma. C (n + m) \\<subseteq> C ma\n\ngoal:\nNo subgoals!", "qed"], ["", "definition regular :: \"('a set \\<Rightarrow> 'a set) \\<Rightarrow> bool\"\nwhere\n  \"regular f = (setmonotone f \\<and> continuous f)\""], ["", "lemma regular_fixpoint:\n  assumes regular: \"regular f\"\n  shows \"f (limit f I) = limit f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have setmonotone: \"setmonotone f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone f", "using regular regular_def"], ["proof (prove)\nusing this:\n  regular f\n  regular ?f = (setmonotone ?f \\<and> continuous ?f)\n\ngoal (1 subgoal):\n 1. setmonotone f", "by blast"], ["proof (state)\nthis:\n  setmonotone f\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have continuous: \"continuous f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous f", "using regular regular_def"], ["proof (prove)\nusing this:\n  regular f\n  regular ?f = (setmonotone ?f \\<and> continuous ?f)\n\ngoal (1 subgoal):\n 1. continuous f", "by blast"], ["proof (state)\nthis:\n  continuous f\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "let ?C = \"\\<lambda> n. funpower f n I\""], ["proof (state)\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have chain: \"chain ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. funpower f n I)", "by (simp add: setmonotone setmonotone_implies_chain_funpower)"], ["proof (state)\nthis:\n  chain (\\<lambda>n. funpower f n I)\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have \"f (limit f I) = f (natUnion ?C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (limit f I) = f (natUnion (\\<lambda>n. funpower f n I))", "using limit_def"], ["proof (prove)\nusing this:\n  limit ?f ?x = natUnion (\\<lambda>n. funpower ?f n ?x)\n\ngoal (1 subgoal):\n 1. f (limit f I) = f (natUnion (\\<lambda>n. funpower f n I))", "by metis"], ["proof (state)\nthis:\n  f (limit f I) = f (natUnion (\\<lambda>n. funpower f n I))\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "also"], ["proof (state)\nthis:\n  f (limit f I) = f (natUnion (\\<lambda>n. funpower f n I))\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have \"f (natUnion ?C) = natUnion (f o ?C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (natUnion (\\<lambda>n. funpower f n I)) =\n    natUnion (f \\<circ> (\\<lambda>n. funpower f n I))", "by (metis continuous continuous_def chain)"], ["proof (state)\nthis:\n  f (natUnion (\\<lambda>n. funpower f n I)) =\n  natUnion (f \\<circ> (\\<lambda>n. funpower f n I))\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "also"], ["proof (state)\nthis:\n  f (natUnion (\\<lambda>n. funpower f n I)) =\n  natUnion (f \\<circ> (\\<lambda>n. funpower f n I))\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have \"natUnion (f o ?C) = natUnion (\\<lambda> n. f(funpower f n I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (f \\<circ> (\\<lambda>n. funpower f n I)) =\n    natUnion (\\<lambda>n. f (funpower f n I))", "by (meson comp_apply)"], ["proof (state)\nthis:\n  natUnion (f \\<circ> (\\<lambda>n. funpower f n I)) =\n  natUnion (\\<lambda>n. f (funpower f n I))\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "also"], ["proof (state)\nthis:\n  natUnion (f \\<circ> (\\<lambda>n. funpower f n I)) =\n  natUnion (\\<lambda>n. f (funpower f n I))\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have \"natUnion (\\<lambda> n. f(funpower f n I)) = natUnion (\\<lambda> n. ?C (n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>n. f (funpower f n I)) =\n    natUnion (\\<lambda>n. funpower f (n + 1) I)", "by simp"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. f (funpower f n I)) =\n  natUnion (\\<lambda>n. funpower f (n + 1) I)\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "also"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. f (funpower f n I)) =\n  natUnion (\\<lambda>n. funpower f (n + 1) I)\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "have \"natUnion (\\<lambda> n. ?C(n + 1)) = natUnion ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>n. funpower f (n + 1) I) =\n    natUnion (\\<lambda>n. funpower f n I)", "apply (subst natUnion_shift)"], ["proof (prove)\ngoal (2 subgoals):\n 1. chain (\\<lambda>a. funpower f a I)\n 2. natUnion (\\<lambda>a. funpower f a I) =\n    natUnion (\\<lambda>n. funpower f n I)", "using chain"], ["proof (prove)\nusing this:\n  chain (\\<lambda>n. funpower f n I)\n\ngoal (2 subgoals):\n 1. chain (\\<lambda>a. funpower f a I)\n 2. natUnion (\\<lambda>a. funpower f a I) =\n    natUnion (\\<lambda>n. funpower f n I)", "by (blast+)"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. funpower f (n + 1) I) =\n  natUnion (\\<lambda>n. funpower f n I)\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "finally"], ["proof (chain)\npicking this:\n  f (limit f I) = natUnion (\\<lambda>n. funpower f n I)", "show ?thesis"], ["proof (prove)\nusing this:\n  f (limit f I) = natUnion (\\<lambda>n. funpower f n I)\n\ngoal (1 subgoal):\n 1. f (limit f I) = limit f I", "by (simp add: limit_def)"], ["proof (state)\nthis:\n  f (limit f I) = limit f I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fix_is_fix_of_limit:\n  assumes fixpoint: \"f I = I\"   \n  shows \"limit f I = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit f I = I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. limit f I = I", "have funpower: \"\\<And> n. funpower f n I = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. funpower f n I = I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. funpower f n I = I", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. funpower f n I = I", "from fixpoint"], ["proof (chain)\npicking this:\n  f I = I", "show \"funpower f n I = I\""], ["proof (prove)\nusing this:\n  f I = I\n\ngoal (1 subgoal):\n 1. funpower f n I = I", "by (induct n, auto)"], ["proof (state)\nthis:\n  funpower f n I = I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  funpower f ?n I = I\n\ngoal (1 subgoal):\n 1. limit f I = I", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. limit f I = I", "by (simp add: limit_def funpower natUnion_def)"], ["proof (state)\nthis:\n  limit f I = I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma limit_is_idempotent: \"regular f \\<Longrightarrow> limit f (limit f I) = limit f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular f \\<Longrightarrow> limit f (limit f I) = limit f I", "by (simp add: fix_is_fix_of_limit regular_fixpoint)"], ["", "definition mk_regular1 :: \"('b \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n  \"mk_regular1 P F I = I \\<union> { F q x | q x. x \\<in> I \\<and> P q x }\""], ["", "definition mk_regular2 :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n  \"mk_regular2 P F I = I \\<union> { F q x y | q x y. x \\<in> I \\<and> y \\<in> I \\<and> P q x y }\""], ["", "lemma setmonotone_mk_regular1: \"setmonotone (mk_regular1 P F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone (mk_regular1 P F)", "by (simp add: mk_regular1_def setmonotone_def)"], ["", "lemma setmonotone_mk_regular2: \"setmonotone (mk_regular2 P F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone (mk_regular2 P F)", "by (simp add: mk_regular2_def setmonotone_def)"], ["", "lemma pointbased_mk_regular1: \"pointbased (mk_regular1 P F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "let ?f = \"\\<lambda> X. X \\<union> { F q x | q x. x \\<in> X \\<and> P q x }\""], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "fix I :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "have 1: \"pointbase ?f I \\<subseteq> mk_regular1 P F I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n     I\n    \\<subseteq> mk_regular1 P F I", "by (auto simp add: pointbase_def mk_regular1_def)"], ["proof (state)\nthis:\n  pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x}) I\n  \\<subseteq> mk_regular1 P F I\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "have 2: \"mk_regular1 P F I \\<subseteq> pointbase ?f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_regular1 P F I\n    \\<subseteq> pointbase\n                 (\\<lambda>X.\n                     X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n                 I", "apply (simp add: pointbase_def mk_regular1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> \\<Union>\n                   {X \\<union> {F q x |q x. x \\<in> X \\<and> P q x} |X.\n                    finite X \\<and> X \\<subseteq> I} \\<and>\n    {F q x |q x. x \\<in> I \\<and> P q x}\n    \\<subseteq> \\<Union>\n                 {X \\<union> {F q x |q x. x \\<in> X \\<and> P q x} |X.\n                  finite X \\<and> X \\<subseteq> I}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mk_regular1 P F I\n  \\<subseteq> pointbase\n               (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n               I\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "from 1 2"], ["proof (chain)\npicking this:\n  pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x}) I\n  \\<subseteq> mk_regular1 P F I\n  mk_regular1 P F I\n  \\<subseteq> pointbase\n               (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n               I", "have \"pointbase ?f I = mk_regular1 P F I\""], ["proof (prove)\nusing this:\n  pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x}) I\n  \\<subseteq> mk_regular1 P F I\n  mk_regular1 P F I\n  \\<subseteq> pointbase\n               (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n               I\n\ngoal (1 subgoal):\n 1. pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n     I =\n    mk_regular1 P F I", "by blast"], ["proof (state)\nthis:\n  pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n   I =\n  mk_regular1 P F I\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "}"], ["proof (state)\nthis:\n  pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n   ?I2 =\n  mk_regular1 P F ?I2\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "then"], ["proof (chain)\npicking this:\n  pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n   ?I2 =\n  mk_regular1 P F ?I2", "show ?thesis"], ["proof (prove)\nusing this:\n  pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})\n   ?I2 =\n  mk_regular1 P F ?I2\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular1 P F)", "apply (subst pointbased_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        pointbase\n         (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x}) I =\n        mk_regular1 P F I) \\<Longrightarrow>\n    \\<exists>Fa. mk_regular1 P F = pointbase Fa", "apply (rule_tac x=\"?f\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        pointbase\n         (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x}) I =\n        mk_regular1 P F I) \\<Longrightarrow>\n    mk_regular1 P F =\n    pointbase (\\<lambda>X. X \\<union> {F q x |q x. x \\<in> X \\<and> P q x})", "by blast"], ["proof (state)\nthis:\n  pointbased (mk_regular1 P F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pointbased_mk_regular2: \"pointbased (mk_regular2 P F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "let ?f = \"\\<lambda> X. X \\<union> { F q x y | q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y }\""], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "fix I :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "have 1: \"pointbase ?f I \\<subseteq> mk_regular2 P F I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointbase\n     (\\<lambda>X.\n         X \\<union>\n         {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n     I\n    \\<subseteq> mk_regular2 P F I", "by (auto simp add: pointbase_def mk_regular2_def)"], ["proof (state)\nthis:\n  pointbase\n   (\\<lambda>X.\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n   I\n  \\<subseteq> mk_regular2 P F I\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "have 2: \"mk_regular2 P F I \\<subseteq> pointbase ?f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_regular2 P F I\n    \\<subseteq> pointbase\n                 (\\<lambda>X.\n                     X \\<union>\n                     {F q x y |q x y.\n                      x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n                 I", "apply (auto simp add: pointbase_def mk_regular2_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X.\n              xa =\n              X \\<union>\n              {F q x y |q x y.\n               x \\<in> X \\<and> y \\<in> X \\<and> P q x y} \\<and>\n              finite X \\<and> X \\<subseteq> I) \\<and>\n          x \\<in> xa\n 2. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "fix q x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "assume x: \"x \\<in> I\""], ["proof (state)\nthis:\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "assume y: \"y \\<in> I\""], ["proof (state)\nthis:\n  y \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "assume P: \"P q x y\""], ["proof (state)\nthis:\n  P q x y\n\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "let ?X = \"{x, y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "let ?A = \"?X \\<union> {F q x y |q x y. x \\<in> ?X \\<and> y \\<in> ?X \\<and> P q x y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q xa y.\n       \\<lbrakk>xa \\<in> I; y \\<in> I; P q xa y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>X.\n                                x =\n                                X \\<union>\n                                {F q x y |q x y.\n                                 x \\<in> X \\<and>\n                                 y \\<in> X \\<and> P q x y} \\<and>\n                                finite X \\<and> X \\<subseteq> I) \\<and>\n                            F q xa y \\<in> x", "show \"\\<exists>A. (\\<exists>X. A = X \\<union> {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y} \\<and> \n          finite X \\<and> X \\<subseteq> I) \\<and> F q x y \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       (\\<exists>X.\n           A =\n           X \\<union>\n           {F q x y |q x y.\n            x \\<in> X \\<and> y \\<in> X \\<and> P q x y} \\<and>\n           finite X \\<and> X \\<subseteq> I) \\<and>\n       F q x y \\<in> A", "apply (rule_tac x=\"?A\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X.\n        {x, y} \\<union>\n        {F q xa ya |q xa ya.\n         xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya} =\n        X \\<union>\n        {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y} \\<and>\n        finite X \\<and> X \\<subseteq> I) \\<and>\n    F q x y\n    \\<in> {x, y} \\<union>\n          {F q xa ya |q xa ya.\n           xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya}", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>X.\n       {x, y} \\<union>\n       {F q xa ya |q xa ya.\n        xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya} =\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y} \\<and>\n       finite X \\<and> X \\<subseteq> I\n 2. F q x y\n    \\<in> {x, y} \\<union>\n          {F q xa ya |q xa ya.\n           xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya}", "apply (rule_tac x=\"?X\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x, y} \\<union>\n    {F q xa ya |q xa ya.\n     xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya} =\n    {x, y} \\<union>\n    {F q xa ya |q xa ya.\n     xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya} \\<and>\n    finite {x, y} \\<and> {x, y} \\<subseteq> I\n 2. F q x y\n    \\<in> {x, y} \\<union>\n          {F q xa ya |q xa ya.\n           xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya}", "apply (auto simp add: x y)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. F q x y\n    \\<in> {x, y} \\<union>\n          {F q xa ya |q xa ya.\n           xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya}", "using x y P"], ["proof (prove)\nusing this:\n  x \\<in> I\n  y \\<in> I\n  P q x y\n\ngoal (1 subgoal):\n 1. F q x y\n    \\<in> {x, y} \\<union>\n          {F q xa ya |q xa ya.\n           xa \\<in> {x, y} \\<and> ya \\<in> {x, y} \\<and> P q xa ya}", "by blast"], ["proof (state)\nthis:\n  \\<exists>A.\n     (\\<exists>X.\n         A =\n         X \\<union>\n         {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y} \\<and>\n         finite X \\<and> X \\<subseteq> I) \\<and>\n     F q x y \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mk_regular2 P F I\n  \\<subseteq> pointbase\n               (\\<lambda>X.\n                   X \\<union>\n                   {F q x y |q x y.\n                    x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n               I\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "from 1 2"], ["proof (chain)\npicking this:\n  pointbase\n   (\\<lambda>X.\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n   I\n  \\<subseteq> mk_regular2 P F I\n  mk_regular2 P F I\n  \\<subseteq> pointbase\n               (\\<lambda>X.\n                   X \\<union>\n                   {F q x y |q x y.\n                    x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n               I", "have \"pointbase ?f I = mk_regular2 P F I\""], ["proof (prove)\nusing this:\n  pointbase\n   (\\<lambda>X.\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n   I\n  \\<subseteq> mk_regular2 P F I\n  mk_regular2 P F I\n  \\<subseteq> pointbase\n               (\\<lambda>X.\n                   X \\<union>\n                   {F q x y |q x y.\n                    x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n               I\n\ngoal (1 subgoal):\n 1. pointbase\n     (\\<lambda>X.\n         X \\<union>\n         {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n     I =\n    mk_regular2 P F I", "by blast"], ["proof (state)\nthis:\n  pointbase\n   (\\<lambda>X.\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n   I =\n  mk_regular2 P F I\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "}"], ["proof (state)\nthis:\n  pointbase\n   (\\<lambda>X.\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n   ?I2 =\n  mk_regular2 P F ?I2\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "then"], ["proof (chain)\npicking this:\n  pointbase\n   (\\<lambda>X.\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n   ?I2 =\n  mk_regular2 P F ?I2", "show ?thesis"], ["proof (prove)\nusing this:\n  pointbase\n   (\\<lambda>X.\n       X \\<union>\n       {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n   ?I2 =\n  mk_regular2 P F ?I2\n\ngoal (1 subgoal):\n 1. pointbased (mk_regular2 P F)", "apply (subst pointbased_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        pointbase\n         (\\<lambda>X.\n             X \\<union>\n             {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n         I =\n        mk_regular2 P F I) \\<Longrightarrow>\n    \\<exists>Fa. mk_regular2 P F = pointbase Fa", "apply (rule_tac x=\"?f\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        pointbase\n         (\\<lambda>X.\n             X \\<union>\n             {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})\n         I =\n        mk_regular2 P F I) \\<Longrightarrow>\n    mk_regular2 P F =\n    pointbase\n     (\\<lambda>X.\n         X \\<union>\n         {F q x y |q x y. x \\<in> X \\<and> y \\<in> X \\<and> P q x y})", "by blast"], ["proof (state)\nthis:\n  pointbased (mk_regular2 P F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma regular1:\"regular (mk_regular1 P F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (mk_regular1 P F)", "by (simp add: pointbased_implies_continuous pointbased_mk_regular1 regular_def \n  setmonotone_mk_regular1)"], ["", "lemma regular2: \"regular (mk_regular2 P F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (mk_regular2 P F)", "by (simp add: pointbased_implies_continuous pointbased_mk_regular2 regular_def \n  setmonotone_mk_regular2)"], ["", "lemma continuous_comp: \n  assumes f: \"continuous f\"\n  assumes g: \"continuous g\"\n  shows \"continuous (g o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (g \\<circ> f)", "by (metis (no_types, lifting) comp_assoc comp_def continuous_def f g)"], ["", "lemma setmonotone_comp:\n  assumes f: \"setmonotone f\"\n  assumes g: \"setmonotone g\"\n  shows \"setmonotone (g o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone (g \\<circ> f)", "by (metis (mono_tags, lifting) comp_def f g rev_subsetD setmonotone_def subsetI)"], ["", "lemma regular_comp:\n  assumes f: \"regular f\"\n  assumes g: \"regular g\"\n  shows \"regular (g o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (g \\<circ> f)", "using continuous_comp f g regular_def setmonotone_comp"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous ?f; continuous ?g\\<rbrakk>\n  \\<Longrightarrow> continuous (?g \\<circ> ?f)\n  regular f\n  regular g\n  regular ?f = (setmonotone ?f \\<and> continuous ?f)\n  \\<lbrakk>setmonotone ?f; setmonotone ?g\\<rbrakk>\n  \\<Longrightarrow> setmonotone (?g \\<circ> ?f)\n\ngoal (1 subgoal):\n 1. regular (g \\<circ> f)", "by blast"], ["", "lemma setmonotone_id[simp]: \"setmonotone id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setmonotone id", "by (simp add: id_def setmonotone_def)"], ["", "lemma continuous_id[simp]: \"continuous id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous id", "by (simp add: continuous_def)"], ["", "lemma regular_id[simp]: \"regular id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular id", "by (simp add: regular_def)"], ["", "lemma regular_funpower: \"regular f \\<Longrightarrow> regular (funpower f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular f \\<Longrightarrow> regular (funpower f n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. regular f \\<Longrightarrow> regular (funpower f 0)\n 2. \\<And>n.\n       \\<lbrakk>regular f \\<Longrightarrow> regular (funpower f n);\n        regular f\\<rbrakk>\n       \\<Longrightarrow> regular (funpower f (Suc n))", "case 0"], ["proof (state)\nthis:\n  regular f\n\ngoal (2 subgoals):\n 1. regular f \\<Longrightarrow> regular (funpower f 0)\n 2. \\<And>n.\n       \\<lbrakk>regular f \\<Longrightarrow> regular (funpower f n);\n        regular f\\<rbrakk>\n       \\<Longrightarrow> regular (funpower f (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  regular f\n\ngoal (1 subgoal):\n 1. regular (funpower f 0)", "by (simp add: id_def[symmetric])"], ["proof (state)\nthis:\n  regular (funpower f 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>regular f \\<Longrightarrow> regular (funpower f n);\n        regular f\\<rbrakk>\n       \\<Longrightarrow> regular (funpower f (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>regular f \\<Longrightarrow> regular (funpower f n);\n        regular f\\<rbrakk>\n       \\<Longrightarrow> regular (funpower f (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  regular f \\<Longrightarrow> regular (funpower f n)\n  regular f\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>regular f \\<Longrightarrow> regular (funpower f n);\n        regular f\\<rbrakk>\n       \\<Longrightarrow> regular (funpower f (Suc n))", "have funpower: \"funpower f (Suc n) = f o (funpower f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. funpower f (Suc n) = f \\<circ> funpower f n", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. funpower f (Suc n) x = (f \\<circ> funpower f n) x", "by simp"], ["proof (state)\nthis:\n  funpower f (Suc n) = f \\<circ> funpower f n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>regular f \\<Longrightarrow> regular (funpower f n);\n        regular f\\<rbrakk>\n       \\<Longrightarrow> regular (funpower f (Suc n))", "with Suc"], ["proof (chain)\npicking this:\n  regular f \\<Longrightarrow> regular (funpower f n)\n  regular f\n  funpower f (Suc n) = f \\<circ> funpower f n", "show ?case"], ["proof (prove)\nusing this:\n  regular f \\<Longrightarrow> regular (funpower f n)\n  regular f\n  funpower f (Suc n) = f \\<circ> funpower f n\n\ngoal (1 subgoal):\n 1. regular (funpower f (Suc n))", "by (auto simp only: funpower regular_comp)"], ["proof (state)\nthis:\n  regular (funpower f (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_id[simp]: \"mono id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono id", "by (simp add: mono_def id_def)"], ["", "lemma mono_funpower:\n  assumes mono: \"mono f\"\n  shows \"mono (funpower f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (funpower f n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. mono (funpower f 0)\n 2. \\<And>n. mono (funpower f n) \\<Longrightarrow> mono (funpower f (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. mono (funpower f 0)\n 2. \\<And>n. mono (funpower f n) \\<Longrightarrow> mono (funpower f (Suc n))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (funpower f 0)", "by (simp add: id_def[symmetric])"], ["proof (state)\nthis:\n  mono (funpower f 0)\n\ngoal (1 subgoal):\n 1. \\<And>n. mono (funpower f n) \\<Longrightarrow> mono (funpower f (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. mono (funpower f n) \\<Longrightarrow> mono (funpower f (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  mono (funpower f n)\n\ngoal (1 subgoal):\n 1. \\<And>n. mono (funpower f n) \\<Longrightarrow> mono (funpower f (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (funpower f (Suc n))", "by (simp add: Suc.hyps mono monoD monoI)"], ["proof (state)\nthis:\n  mono (funpower f (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_limit:\n  assumes mono: \"mono f\"\n  shows \"mono (limit f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (limit f)", "proof(auto simp add: mono_def limit_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "fix A :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "fix B :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "assume subset: \"A \\<subseteq> B\""], ["proof (state)\nthis:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "assume \"x \\<in> natUnion (\\<lambda>n. funpower f n A)\""], ["proof (state)\nthis:\n  x \\<in> natUnion (\\<lambda>n. funpower f n A)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "then"], ["proof (chain)\npicking this:\n  x \\<in> natUnion (\\<lambda>n. funpower f n A)", "have \"\\<exists> n. x \\<in> funpower f n A\""], ["proof (prove)\nusing this:\n  x \\<in> natUnion (\\<lambda>n. funpower f n A)\n\ngoal (1 subgoal):\n 1. \\<exists>n. x \\<in> funpower f n A", "using elem_limit_simp limit_def"], ["proof (prove)\nusing this:\n  x \\<in> natUnion (\\<lambda>n. funpower f n A)\n  (?x \\<in> limit ?f ?X) = (\\<exists>n. ?x \\<in> funpower ?f n ?X)\n  limit ?f ?x = natUnion (\\<lambda>n. funpower ?f n ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>n. x \\<in> funpower f n A", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>n. x \\<in> funpower f n A\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. x \\<in> funpower f n A", "obtain n where n: \"x \\<in> funpower f n A\""], ["proof (prove)\nusing this:\n  \\<exists>n. x \\<in> funpower f n A\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x \\<in> funpower f n A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> funpower f n A\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "then"], ["proof (chain)\npicking this:\n  x \\<in> funpower f n A", "have mono: \"mono (funpower f n)\""], ["proof (prove)\nusing this:\n  x \\<in> funpower f n A\n\ngoal (1 subgoal):\n 1. mono (funpower f n)", "by (simp add: mono mono_funpower)"], ["proof (state)\nthis:\n  mono (funpower f n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "then"], ["proof (chain)\npicking this:\n  mono (funpower f n)", "have \"x \\<in> funpower f n B\""], ["proof (prove)\nusing this:\n  mono (funpower f n)\n\ngoal (1 subgoal):\n 1. x \\<in> funpower f n B", "by (meson contra_subsetD monoD n subset)"], ["proof (state)\nthis:\n  x \\<in> funpower f n B\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y;\n        xa \\<in> natUnion (\\<lambda>n. funpower f n x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> natUnion (\\<lambda>n. funpower f n y)", "then"], ["proof (chain)\npicking this:\n  x \\<in> funpower f n B", "show \"x \\<in> natUnion (\\<lambda>n. funpower f n B)\""], ["proof (prove)\nusing this:\n  x \\<in> funpower f n B\n\ngoal (1 subgoal):\n 1. x \\<in> natUnion (\\<lambda>n. funpower f n B)", "by (simp add: natUnion_elem)"], ["proof (state)\nthis:\n  x \\<in> natUnion (\\<lambda>n. funpower f n B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_funpower:\n  assumes continuous: \"continuous f\"\n  shows \"continuous (funpower f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (funpower f n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. continuous (funpower f 0)\n 2. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. continuous (funpower f 0)\n 2. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (funpower f 0)", "by (simp add: id_def[symmetric])"], ["proof (state)\nthis:\n  continuous (funpower f 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  continuous (funpower f n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "have mono: \"mono (funpower f (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (funpower f (Suc n))", "by (simp add: continuous continuous_imp_mono mono_funpower)"], ["proof (state)\nthis:\n  mono (funpower f (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "have chain: \"\\<forall> C. chain C \\<longrightarrow> chain ((funpower f (Suc n)) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow> chain (funpower f (Suc n) \\<circ> C)", "by (simp del: funpower.simps add: mono mono_maps_chain_to_chain)"], ["proof (state)\nthis:\n  \\<forall>C. chain C \\<longrightarrow> chain (funpower f (Suc n) \\<circ> C)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "have limit: \"\\<And> C. chain C \\<Longrightarrow> (funpower f (Suc n)) (natUnion C) = \n      natUnion ((funpower f (Suc n)) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       funpower f (Suc n) (natUnion C) =\n       natUnion (funpower f (Suc n) \\<circ> C)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       f (funpower f n (natUnion C)) =\n       natUnion (funpower f (Suc n) \\<circ> C)", "apply (subst continuous_apply[OF Suc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C. chain C \\<Longrightarrow> chain C\n 2. \\<And>C.\n       chain C \\<Longrightarrow>\n       f (natUnion (funpower f n \\<circ> C)) =\n       natUnion (funpower f (Suc n) \\<circ> C)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       f (natUnion (funpower f n \\<circ> C)) =\n       natUnion (funpower f (Suc n) \\<circ> C)", "apply (subst continuous_apply[OF continuous])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C. chain C \\<Longrightarrow> chain (funpower f n \\<circ> C)\n 2. \\<And>C.\n       chain C \\<Longrightarrow>\n       natUnion (f \\<circ> (funpower f n \\<circ> C)) =\n       natUnion (funpower f (Suc n) \\<circ> C)", "apply (simp add: Suc.hyps continuous_imp_mono mono_maps_chain_to_chain)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       natUnion (f \\<circ> (funpower f n \\<circ> C)) =\n       natUnion (funpower f (Suc n) \\<circ> C)", "apply (rule arg_cong[where f=\"natUnion\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       f \\<circ> (funpower f n \\<circ> C) = funpower f (Suc n) \\<circ> C", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C x.\n       chain C \\<Longrightarrow>\n       (f \\<circ> (funpower f n \\<circ> C)) x =\n       (funpower f (Suc n) \\<circ> C) x", "by simp"], ["proof (state)\nthis:\n  chain ?C \\<Longrightarrow>\n  funpower f (Suc n) (natUnion ?C) =\n  natUnion (funpower f (Suc n) \\<circ> ?C)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       continuous (funpower f n) \\<Longrightarrow>\n       continuous (funpower f (Suc n))", "from chain limit"], ["proof (chain)\npicking this:\n  \\<forall>C. chain C \\<longrightarrow> chain (funpower f (Suc n) \\<circ> C)\n  chain ?C \\<Longrightarrow>\n  funpower f (Suc n) (natUnion ?C) =\n  natUnion (funpower f (Suc n) \\<circ> ?C)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>C. chain C \\<longrightarrow> chain (funpower f (Suc n) \\<circ> C)\n  chain ?C \\<Longrightarrow>\n  funpower f (Suc n) (natUnion ?C) =\n  natUnion (funpower f (Suc n) \\<circ> ?C)\n\ngoal (1 subgoal):\n 1. continuous (funpower f (Suc n))", "using continuous_def"], ["proof (prove)\nusing this:\n  \\<forall>C. chain C \\<longrightarrow> chain (funpower f (Suc n) \\<circ> C)\n  chain ?C \\<Longrightarrow>\n  funpower f (Suc n) (natUnion ?C) =\n  natUnion (funpower f (Suc n) \\<circ> ?C)\n  continuous ?f =\n  (\\<forall>C.\n      chain C \\<longrightarrow>\n      chain (?f \\<circ> C) \\<and> ?f (natUnion C) = natUnion (?f \\<circ> C))\n\ngoal (1 subgoal):\n 1. continuous (funpower f (Suc n))", "by blast"], ["proof (state)\nthis:\n  continuous (funpower f (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma natUnion_swap:\n  \"natUnion (\\<lambda> i. natUnion (\\<lambda> j. f i j)) = natUnion (\\<lambda> j. natUnion (\\<lambda> i. f i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>i. natUnion (f i)) =\n    natUnion (\\<lambda>j. natUnion (\\<lambda>i. f i j))", "by (metis (no_types, lifting) natUnion_elem natUnion_upperbound subsetI subset_antisym)"], ["", "lemma continuous_limit:\n  assumes continuous: \"continuous f\"\n  shows \"continuous (limit f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (limit f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous (limit f)", "have mono: \"mono (limit f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (limit f)", "by (simp add: continuous continuous_imp_mono mono_limit)"], ["proof (state)\nthis:\n  mono (limit f)\n\ngoal (1 subgoal):\n 1. continuous (limit f)", "have chain: \"\\<And> C. chain C \\<Longrightarrow> chain ((limit f) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C. chain C \\<Longrightarrow> chain (limit f \\<circ> C)", "by (simp add: mono mono_maps_chain_to_chain)"], ["proof (state)\nthis:\n  chain ?C \\<Longrightarrow> chain (limit f \\<circ> ?C)\n\ngoal (1 subgoal):\n 1. continuous (limit f)", "have \"\\<And> C. chain C \\<Longrightarrow> (limit f) (natUnion C) = natUnion ((limit f) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "fix C :: \"nat \\<Rightarrow> 'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "assume chain_C: \"chain C\""], ["proof (state)\nthis:\n  chain C\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have contpower: \"\\<And> n. continuous (funpower f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. continuous (funpower f n)", "by (simp add: continuous continuous_funpower)"], ["proof (state)\nthis:\n  continuous (funpower f ?n)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have comp: \"\\<And> n F. F o C = (\\<lambda> i. F (C i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n F. F \\<circ> C = (\\<lambda>i. F (C i))", "by auto"], ["proof (state)\nthis:\n  ?F \\<circ> C = (\\<lambda>i. ?F (C i))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have \"(limit f) (natUnion C) = natUnion (\\<lambda> n. funpower f n (natUnion C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit f (natUnion C) = natUnion (\\<lambda>n. funpower f n (natUnion C))", "by (simp add: limit_def)"], ["proof (state)\nthis:\n  limit f (natUnion C) = natUnion (\\<lambda>n. funpower f n (natUnion C))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "also"], ["proof (state)\nthis:\n  limit f (natUnion C) = natUnion (\\<lambda>n. funpower f n (natUnion C))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have \"natUnion (\\<lambda> n. funpower f n (natUnion C)) = \n          natUnion (\\<lambda> n. natUnion ((funpower f n) o C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>n. funpower f n (natUnion C)) =\n    natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C))", "apply (subst continuous_apply[OF contpower])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. chain C\n 2. natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C)) =\n    natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C))", "apply (simp add: chain_C)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. funpower f n (natUnion C)) =\n  natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "also"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. funpower f n (natUnion C)) =\n  natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have \"natUnion (\\<lambda> n. natUnion ((funpower f n) o C)) = \n      natUnion (\\<lambda> n. natUnion (\\<lambda> i. funpower f n (C i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C)) =\n    natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i)))", "apply (subst comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i))) =\n    natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i)))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C)) =\n  natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i)))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "also"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. natUnion (funpower f n \\<circ> C)) =\n  natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i)))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have \"natUnion (\\<lambda> n. natUnion (\\<lambda> i. funpower f n (C i))) =\n      natUnion (\\<lambda> i. natUnion (\\<lambda> n. funpower f n (C i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i))) =\n    natUnion (\\<lambda>i. natUnion (\\<lambda>n. funpower f n (C i)))", "apply (subst natUnion_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>j. natUnion (\\<lambda>i. funpower f i (C j))) =\n    natUnion (\\<lambda>i. natUnion (\\<lambda>n. funpower f n (C i)))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i))) =\n  natUnion (\\<lambda>i. natUnion (\\<lambda>n. funpower f n (C i)))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "also"], ["proof (state)\nthis:\n  natUnion (\\<lambda>n. natUnion (\\<lambda>i. funpower f n (C i))) =\n  natUnion (\\<lambda>i. natUnion (\\<lambda>n. funpower f n (C i)))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have \"natUnion (\\<lambda> i. natUnion (\\<lambda> n. funpower f n (C i))) = \n      (natUnion (\\<lambda> i. limit f (C i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>i. natUnion (\\<lambda>n. funpower f n (C i))) =\n    natUnion (\\<lambda>i. limit f (C i))", "apply (simp add: limit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  natUnion (\\<lambda>i. natUnion (\\<lambda>n. funpower f n (C i))) =\n  natUnion (\\<lambda>i. limit f (C i))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "also"], ["proof (state)\nthis:\n  natUnion (\\<lambda>i. natUnion (\\<lambda>n. funpower f n (C i))) =\n  natUnion (\\<lambda>i. limit f (C i))\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "have \"natUnion (\\<lambda> i. limit f (C i)) = natUnion ((limit f) o C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>i. limit f (C i)) = natUnion (limit f \\<circ> C)", "apply (subst comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. natUnion (\\<lambda>i. limit f (C i)) =\n    natUnion (\\<lambda>i. limit f (C i))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  natUnion (\\<lambda>i. limit f (C i)) = natUnion (limit f \\<circ> C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       chain C \\<Longrightarrow>\n       limit f (natUnion C) = natUnion (limit f \\<circ> C)", "finally"], ["proof (chain)\npicking this:\n  limit f (natUnion C) = natUnion (limit f \\<circ> C)", "show \"(limit f) (natUnion C) = natUnion ((limit f) o C)\""], ["proof (prove)\nusing this:\n  limit f (natUnion C) = natUnion (limit f \\<circ> C)\n\ngoal (1 subgoal):\n 1. limit f (natUnion C) = natUnion (limit f \\<circ> C)", "by blast"], ["proof (state)\nthis:\n  limit f (natUnion C) = natUnion (limit f \\<circ> C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain ?C \\<Longrightarrow>\n  limit f (natUnion ?C) = natUnion (limit f \\<circ> ?C)\n\ngoal (1 subgoal):\n 1. continuous (limit f)", "with chain"], ["proof (chain)\npicking this:\n  chain ?C \\<Longrightarrow> chain (limit f \\<circ> ?C)\n  chain ?C \\<Longrightarrow>\n  limit f (natUnion ?C) = natUnion (limit f \\<circ> ?C)", "show ?thesis"], ["proof (prove)\nusing this:\n  chain ?C \\<Longrightarrow> chain (limit f \\<circ> ?C)\n  chain ?C \\<Longrightarrow>\n  limit f (natUnion ?C) = natUnion (limit f \\<circ> ?C)\n\ngoal (1 subgoal):\n 1. continuous (limit f)", "by (simp add: continuous_def)"], ["proof (state)\nthis:\n  continuous (limit f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma regular_limit: \"regular f \\<Longrightarrow> regular (limit f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular f \\<Longrightarrow> regular (limit f)", "by (simp add: continuous_limit regular_def setmonotone_limit)"], ["", "lemma regular_implies_mono: \"regular f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular f \\<Longrightarrow> mono f", "by (simp add: continuous_imp_mono regular_def)"], ["", "lemma regular_implies_setmonotone: \"regular f \\<Longrightarrow> setmonotone f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular f \\<Longrightarrow> setmonotone f", "by (simp add: regular_def)"], ["", "lemma regular_implies_continuous: \"regular f \\<Longrightarrow> continuous f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular f \\<Longrightarrow> continuous f", "by (simp add: regular_def)"], ["", "end"]]}