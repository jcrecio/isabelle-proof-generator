{"file_name": "/home/qj213/afp-2021-10-22/thys/LocalLexing/Ladder.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LocalLexing", "problem_names": ["lemma LeftDerivationFix_empty[simp]: \"is_sentence \\<alpha> \\<Longrightarrow> i < length \\<alpha> \\<Longrightarrow> LeftDerivationFix \\<alpha> i [] i \\<alpha>\"", "lemma Derive_empty[simp]: \"Derive a [] = a\"", "lemma LeftDerivation_append1: \"LeftDerivation a (D@[(i, r)]) c \\<Longrightarrow> \\<exists> b. LeftDerivation a D b \n  \\<and> LeftDerives1 b i r c\"", "lemma Derivation_append1: \"Derivation a (D@[(i, r)]) c \\<Longrightarrow> \\<exists> b. Derivation a D b \n  \\<and> Derives1 b i r c\"", "lemma  Derivation_take_derive:\n  assumes \"Derivation a D b\"\n  shows \"Derivation a (take n D) (Derive a (take n D))\"", "lemma  LeftDerivation_take_derive:\n  assumes \"LeftDerivation a D b\"\n  shows \"LeftDerivation a (take n D) (Derive a (take n D))\"", "lemma Derivation_Derive_take_Derives1:\n  assumes \"N \\<noteq> 0\"\n  assumes \"N \\<le> length D\"\n  assumes \"Derivation a D b\"\n  assumes \\<alpha>: \"\\<alpha> = Derive a (take (N - 1) D)\"\n  assumes \"\\<beta> = Derive a (take N D)\"\n  shows \"Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\"", "lemma LeftDerivation_Derive_take_LeftDerives1:\n  assumes \"N \\<noteq> 0\"\n  assumes \"N \\<le> length D\"\n  assumes \"LeftDerivation a D b\"\n  assumes \\<alpha>: \"\\<alpha> = Derive a (take (N - 1) D)\"\n  assumes \"\\<beta> = Derive a (take N D)\"\n  shows \"LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\"", "lemma LeftDerives1_skip_prefix:\n  \"length a \\<le> i \\<Longrightarrow> LeftDerives1 (a@b) i r (a@c) \\<Longrightarrow> LeftDerives1 b (i - length a) r c\"", "lemma LeftDerives1_skip_suffix:\n  assumes i: \"i < length a\"\n  assumes D: \"LeftDerives1 (a@c) i r (b@c)\"\n  shows \"LeftDerives1 a i r b\"", "lemma LeftDerives1_X_is_part_of_rule[consumes 2, case_names Suffix Prefix]:\n  assumes aXb: \"LeftDerives1 \\<delta> i r (a@[X]@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  assumes prefix: \"\\<And> \\<beta>. \\<delta> = a @ [X] @ \\<beta> \\<Longrightarrow> length a < i \\<Longrightarrow> is_word (a @ [X]) \\<Longrightarrow>\n                     LeftDerives1 \\<beta> (i - length a - 1) r b \\<Longrightarrow> False\"\n  assumes suffix: \"\\<And> \\<alpha>. \\<delta> = \\<alpha> @ [X] @ b \\<Longrightarrow> LeftDerives1 \\<alpha> i r a \\<Longrightarrow> False\" \n  shows \"\\<exists> u v. a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> (snd r) = u@[X]@v\"", "lemma LeftDerivationFix_grow_suffix:\n  assumes LDF: \"LeftDerivationFix (b1@[X]@b2) (length b1) D j c\"\n  assumes suffix_b2: \"LeftDerives1 suffix e r b2\"\n  assumes is_word_b1X: \"is_word (b1@[X])\"\n  shows \"LeftDerivationFix (b1@[X]@suffix) (length b1) ((e + length (b1@[X]), r)#D) j c\"", "lemma Derives1_append_suffix: \n  assumes Derives1: \"Derives1 v i r w\"\n  assumes u: \"is_sentence u\"\n  shows \"Derives1 (v@u) i r (w@u)\"", "lemma leftmost_append_suffix: \"leftmost i v \\<Longrightarrow> leftmost i (v@u)\"", "lemma LeftDerives1_append_suffix: \n  assumes Derives1: \"LeftDerives1 v i r w\"\n  assumes u: \"is_sentence u\"\n  shows \"LeftDerives1 (v@u) i r (w@u)\"", "lemma LeftDerivationFix_is_sentence: \n  \"LeftDerivationFix a i D j b \\<Longrightarrow> is_sentence a \\<and> is_sentence b\"", "lemma LeftDerivationIntro_is_sentence:\n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow> is_sentence \\<alpha> \\<and> is_sentence \\<gamma>\"", "lemma LeftDerivationFix_grow_prefix:\n  assumes LDF: \"LeftDerivationFix (b1@[X]@b2) (length b1) D j c\"\n  assumes prefix_b1: \"LeftDerives1 prefix e r b1\"\n  shows \"LeftDerivationFix (prefix@[X]@b2) (length prefix) ((e, r)#D) j c\"", "lemma LeftDerivationFixOrIntro: \n  \"LeftDerivation a D \\<gamma> \\<Longrightarrow> is_sentence \\<gamma> \\<Longrightarrow> j < length \\<gamma> \\<Longrightarrow>\n  (\\<exists> i. LeftDerivationFix a i D j \\<gamma>) \\<or> \n  (\\<exists> d \\<alpha> ix. d < length D \\<and> LeftDerivation a (take d D) \\<alpha> \\<and> \n    LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)\"", "lemma mk_deriv_fix_i[simp]: \"deriv_i (mk_deriv_fix i n j) = i\"", "lemma mk_deriv_fix_j[simp]: \"deriv_j (mk_deriv_fix i n j) = j\"", "lemma mk_deriv_fix_n[simp]: \"deriv_n (mk_deriv_fix i n j) = n\"", "lemma mk_deriv_intro_i[simp]: \"deriv_i (mk_deriv_intro i n j) = i\"", "lemma mk_deriv_intro_ix[simp]: \"deriv_ix (mk_deriv_intro ix n j) = ix\"", "lemma mk_deriv_intro_j[simp]: \"deriv_j (mk_deriv_intro i n j) = j\"", "lemma mk_deriv_intro_n[simp]: \"deriv_n (mk_deriv_intro i n j) = n\"", "lemma LeftDerivationFix_implies_ex_ladder:\n  \"LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow> \\<exists> L. LeftDerivationLadder a D L \\<gamma> \\<and> \n    ladder_last_j L = j \\<and> ladder_last_n L = length D\"", "lemma trivP[case_names prems]: \"P \\<Longrightarrow> P\"", "lemma LeftDerivationLadder_ladder_n_bound:\n  assumes \"LeftDerivationLadder a D L b\"\n  assumes \"index < length L\"\n  shows \"ladder_n L index \\<le> length D\"", "lemma LeftDerivationLadder_deriv_n_bound:\n  assumes \"LeftDerivationLadder a D L b\"\n  assumes \"index < length L\"\n  shows \"deriv_n (L ! index) \\<le> length D\"", "lemma ladder_n_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_n (L@L') u = ladder_n L u\"", "lemma ladder_n_simp2[simp]: \"ladder_n (L@[d]) (length L) = deriv_n d\"", "lemma ladder_j_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_j (L@L') u = ladder_j L u\"", "lemma ladder_j_simp2[simp]: \"ladder_j (L@[d]) (length L) = deriv_j d\"", "lemma ladder_i_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_i (L@L') u = ladder_i L u\"", "lemma ladder_ix_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_ix (L@L') u = ladder_ix L u\"", "lemma ladder_ix_simp2[simp]: \"L \\<noteq> [] \\<Longrightarrow> ladder_ix (L@[d]) (length L) = deriv_ix d\"", "lemma ladder_\\<gamma>_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_\\<gamma> a D (L@L') u = ladder_\\<gamma> a D L u\"", "lemma ladder_\\<gamma>_simp2[simp]: \"u < length L \\<Longrightarrow> is_ladder D L \\<Longrightarrow> \n  ladder_\\<gamma> a (D@D') L u = ladder_\\<gamma> a D L u\"", "lemma ladder_\\<alpha>_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_\\<alpha> a D (L@L') u = ladder_\\<alpha> a D L u\"", "lemma ladder_\\<alpha>_simp2[simp]: \"u < length L \\<Longrightarrow> is_ladder D L \\<Longrightarrow> \n  ladder_\\<alpha> a (D@D') L u = ladder_\\<alpha> a D L u\"", "lemma ladder_n_minus_1_bound: \"is_ladder D L \\<Longrightarrow> index \\<ge> 1 \\<Longrightarrow> index < length L \\<Longrightarrow> \n  ladder_n L (index - Suc 0) < length D\"", "lemma LeftDerivationIntrosAt_ignore_appendix:\n  assumes is_ladder: \"is_ladder D L\"\n  assumes hyp: \"LeftDerivationIntrosAt a D L index\"\n  assumes index_ge: \"index \\<ge> 1\"\n  assumes index_less: \"index < length L\"\n  shows \"LeftDerivationIntrosAt a (D @ D') (L @ L') index\"", "lemma ladder_i_eq_last_j: \"L \\<noteq> [] \\<Longrightarrow> ladder_i (L @ L') (length L) = ladder_last_j L\"", "lemma ladder_last_n_intro: \"L \\<noteq> [] \\<Longrightarrow> ladder_n L (length L - Suc 0) = ladder_last_n L\"", "lemma is_ladder_not_empty: \"is_ladder D L \\<Longrightarrow> L \\<noteq> []\"", "lemma last_ladder_\\<gamma>:\n  assumes is_ladder: \"is_ladder D L\"\n  assumes ladder_last_n: \"ladder_last_n L = length D\"\n  shows \"ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D\"", "lemma ladder_\\<alpha>_full:\n  assumes is_ladder: \"is_ladder D L\"\n  assumes ladder_last_n: \"ladder_last_n L = length D\"\n  shows \"ladder_\\<alpha> a (D @ D') (L @ L') (length L) = Derive a D\"", "lemma LeftDerivationIntro_implies_LeftDerivation:\n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow> LeftDerivation \\<alpha> ((i,r)#D) \\<gamma>\"", "lemma LeftDerivationLadder_grow: \n  \"LeftDerivationLadder a D L \\<alpha> \\<Longrightarrow> ladder_last_j L = i \\<Longrightarrow>\n   LeftDerivationIntro \\<alpha> i r ix E j \\<gamma> \\<Longrightarrow>\n   LeftDerivationLadder a (D@[(i, r)]@E) (L@[mk_deriv_intro ix (Suc(length D + length E)) j]) \\<gamma>\"", "lemma LeftDerivationIntro_bounds_ij: \n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<beta> \\<Longrightarrow> i < length \\<alpha> \\<and> j < length \\<beta>\"", "theorem LeftDerivationLadder_exists: \"LeftDerivation a D \\<gamma> \\<Longrightarrow> is_sentence \\<gamma> \\<Longrightarrow> j < length \\<gamma> \\<Longrightarrow> \n  \\<exists> L. LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\"", "lemma LeftDerivationLadder_L_0: \n  assumes \"LeftDerivationLadder \\<alpha> D L \\<beta>\"\n  assumes \"length L = 1\"\n  shows \"\\<exists> i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>\"", "lemma LeftDerivationFix_splits_at_derives:\n  assumes \"LeftDerivationFix a i D j b\"\n  shows \"\\<exists> U a1 a2 b1 b2. splits_at a i a1 U a2 \\<and> splits_at b j b1 U b2 \\<and> \n    derives a1 b1 \\<and> derives a2 b2\"", "lemma  LeftDerivation_append_suffix:\n  \"LeftDerivation a D b \\<Longrightarrow> is_sentence c \\<Longrightarrow> LeftDerivation (a@c) D (b@c)\"", "lemma LeftDerivation_impossible: \"LeftDerivation a D b \\<Longrightarrow> i < length a \\<Longrightarrow> \n  is_nonterminal (a ! i) \\<Longrightarrow> derivation_ge D (Suc i) \\<Longrightarrow> D = []\"", "lemma derivation_ge_shift: \"derivation_ge (derivation_shift F 0 j) j\"", "lemma LeftDerivationFix_splits_at_nonterminal:\n  assumes \"LeftDerivationFix a i D j b\"\n  assumes \"is_nonterminal (a ! i)\"\n  shows \"\\<exists> U a1 a2 b1. splits_at a i a1 U a2 \\<and> splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1\"", "lemma LeftDerivationIntro_implies_nonterminal: \n  \"LeftDerivationIntro \\<alpha> i (snd e) ix E j \\<gamma> \\<Longrightarrow> is_nonterminal (\\<alpha> ! i)\"", "lemma LeftDerivationIntrosAt_implies_nonterminal:\n  \"LeftDerivationIntrosAt a D L index \\<Longrightarrow> is_nonterminal((ladder_\\<alpha> a D L index) ! (ladder_i L index))\"", "lemma LeftDerivationIntro_examine_rule: \n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow> splits_at \\<alpha> i \\<alpha>1 M \\<alpha>2 \\<Longrightarrow> \n    \\<exists> \\<eta>. M = fst r \\<and> \\<eta> = snd r \\<and> (M, \\<eta>) \\<in> \\<RR>\"", "lemma LeftDerivation_skip_prefixword_ex:\n  assumes \"LeftDerivation (u@v) D w\"\n  assumes \"is_word u\"\n  shows \"\\<exists> w'. w = u@w' \\<and> LeftDerivation v (derivation_shift D (length u) 0) w'\"", "lemma splits_at_append_suffix_prevails: \n  assumes \"splits_at (a@b) i u N v\"\n  assumes \"i < length a\"\n  shows \"\\<exists> v'. v = v'@b \\<and> a=u@[N]@v'\"", "lemma derivation_shift_right_left_cancel:\n  \"derivation_shift (derivation_shift D 0 r) r 0 = D\"", "lemma derivation_shift_left_right_cancel:\n  assumes \"derivation_ge D r\"\n  shows \"derivation_shift (derivation_shift D r 0) 0 r = D\"", "lemma LeftDerivation_ge_take:\n  assumes \"derivation_ge D k\"\n  assumes \"LeftDerivation a D b\"\n  assumes \"D \\<noteq> []\"\n  shows \"take k a = take k b \\<and> is_word (take k a)\"", "lemma LeftDerivationFix_splits_at_symbol:\n  assumes \"LeftDerivationFix a i D j b\"\n  shows \"\\<exists> U a1 a2 b1 b2 n. splits_at a i a1 U a2 \\<and> splits_at b j b1 U b2 \\<and> \n    n \\<le> length D \\<and> LeftDerivation a1 (take n D) b1 \\<and> derivation_ge (drop n D) (Suc(length b1)) \\<and>\n    LeftDerivation a2 (derivation_shift (drop n D) (Suc(length b1)) 0) b2 \\<and>\n    (n = length D \\<or> (n < length D \\<and> is_word (b1@[U])))\"", "lemma LeftDerivation_breakdown': \"LeftDerivation (u @ v) D w \\<Longrightarrow>\n  \\<exists>n w1 w2.\n    n \\<le> length D \\<and>\n    w = w1 @ w2 \\<and>\n    LeftDerivation u (take n D) w1 \\<and>\n    derivation_ge (drop n D) (length w1) \\<and>\n    LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2\"", "lemma LeftDerives1_append_replace_in_left: \n  assumes ld1: \"LeftDerives1 (\\<alpha>@\\<delta>) i r \\<beta>\"\n  assumes i_bound: \"i < length \\<alpha>\"\n  shows \"\\<exists> \\<alpha>'. \\<beta> = \\<alpha>'@\\<delta> \\<and> LeftDerives1 \\<alpha> i r \\<alpha>' \\<and> i + length (snd r) \\<le> length \\<alpha>'\"", "lemma LeftDerivationIntro_propagate:\n  assumes intro: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j \\<gamma>\"\n  assumes i_\\<alpha>: \"i < length \\<alpha>\"\n  assumes non: \"is_nonterminal (\\<gamma> ! j)\"\n  shows \"\\<exists> \\<omega>. LeftDerivation \\<alpha> ((i,r)#D) \\<omega> \\<and> \\<gamma> = \\<omega>@\\<delta> \\<and> j < length \\<omega>\"", "lemma LeftDerivationIntro_finish:\n  assumes intro: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j \\<gamma>\"\n  assumes i_\\<alpha>: \"i < length \\<alpha>\"\n  shows \"\\<exists> k \\<omega> \\<delta>'.\n    k \\<le> length D \\<and>\n    LeftDerivation \\<alpha> ((i, r)#(take k D)) \\<omega> \\<and>\n    LeftDerivation (\\<alpha> @ \\<delta>) ((i, r)#(take k D)) (\\<omega> @ \\<delta>) \\<and>\n    derivation_ge (drop k D) (length \\<omega>) \\<and>\n    LeftDerivation \\<delta> (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n    \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\"", "lemma LeftDerivationLadder_propagate:\n  \"LeftDerivationLadder (\\<alpha>@\\<delta>) D L \\<gamma> \\<Longrightarrow> ladder_i L 0 < length \\<alpha> \\<Longrightarrow> n = ladder_n L index\n   \\<Longrightarrow> index < length L \\<Longrightarrow> \n     if (index + 1 < length L) then\n       (\\<exists> \\<beta>. LeftDerivation \\<alpha> (take n D) \\<beta> \\<and> ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index = \\<beta>@\\<delta> \\<and> \n         ladder_j L index < length \\<beta>)\n     else \n       (\\<exists> n' \\<beta> \\<delta>'. (index = 0 \\<or> ladder_prev_n L index < n') \\<and> n' \\<le> n \\<and> LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n         LeftDerivation (\\<alpha>@\\<delta>) (take n' D) (\\<beta>@\\<delta>) \\<and>\n         derivation_ge (drop n' D) (length \\<beta>) \\<and> \n         LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n         ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index = \\<beta>@\\<delta>' \\<and> ladder_j L index < length \\<beta>)\"", "lemma ladder_i_of_cut_at_0: \n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"ladder_i (ladder_cut L n) 0 = ladder_i L 0\"", "lemma ladder_last_j_of_cut: \n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"ladder_last_j (ladder_cut L n) = ladder_last_j L\"", "lemma length_ladder_cut:\n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"length (ladder_cut L n) = length L\"", "lemma ladder_last_n_of_cut:\n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"ladder_last_n (ladder_cut L n) = n\"", "lemma ladder_n_of_cut:\n  assumes L_non_empty: \"L \\<noteq> []\"\n  assumes \"index < length L - 1\"\n  shows \"ladder_n (ladder_cut L n) index = ladder_n L index\"", "lemma ladder_n_prev_bound:\n  assumes ladder: \"is_ladder D L\"\n  assumes u_bound: \"u < length L - 1\"\n  shows \"ladder_n L u \\<le> ladder_prev_n L (length L - 1)\"", "lemma ladder_n_last_is_length:\n  assumes \"is_ladder D L\"\n  shows \"ladder_n L (length L - 1) = length D\"", "lemma derivation_ge_shift_implies_derivation_ge:\n  assumes dge: \"derivation_ge (derivation_shift F 0 j) k\"\n  shows \"derivation_ge F (k - j)\"", "lemma Derives1_bound': \"Derives1 a i r b \\<Longrightarrow> i \\<le> length b\"", "lemma LeftDerivation_Derives1_last:\n  assumes \"LeftDerivation a D b\"\n  assumes \"D \\<noteq> []\"\n  shows \"Derives1 (Derive a (take (length D - 1) D)) (fst (last D)) (snd (last D)) b\"", "lemma last_of_prefix_in_set:\n  assumes \"n < length E\"\n  assumes \"D = E@F\"\n  shows \"last E \\<in> set (drop n D)\"", "lemma LeftDerivationFix_cut_appendix:\n  assumes ldfix: \"LeftDerivationFix (\\<alpha>@\\<delta>) i D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> (take n D) \\<beta>\"\n  assumes n_bound: \"n \\<le> length D\"\n  assumes dge: \"derivation_ge (drop n D) (length \\<beta>)\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationFix \\<alpha> i (take n D) j \\<beta>\"", "lemma LeftDerivationFix_cut_appendix':\n  assumes ldfix: \"LeftDerivationFix (\\<alpha>@\\<delta>) i D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> D \\<beta>\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationFix \\<alpha> i D j \\<beta>\"", "lemma LeftDerivationIntro_cut_appendix:\n  assumes ldfix: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> ((i,r)#(take n D)) \\<beta>\"\n  assumes n_bound: \"n \\<le> length D\"\n  assumes dge: \"derivation_ge (drop n D) (length \\<beta>)\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>\"", "lemma LeftDerivationIntro_cut_appendix':\n  assumes ldfix: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> ((i,r)#D) \\<beta>\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationIntro \\<alpha> i r ix D j \\<beta>\"", "lemma ladder_n_monotone: \"is_ladder D L \\<Longrightarrow> u \\<le> v \\<Longrightarrow> v < length L \\<Longrightarrow> ladder_n L u \\<le> ladder_n L v\"", "lemma ladder_i_cut: \n  assumes index_bound: \"index < length L\"\n  shows \"ladder_i (ladder_cut L n) index = ladder_i L index\"", "lemma ladder_j_cut: \n  assumes index_bound: \"index < length L\"\n  shows \"ladder_j (ladder_cut L n) index = ladder_j L index\"", "lemma ladder_ix_cut: \n  assumes index_lower_bound: \"index > 0\"\n  assumes index_upper_bound: \"index < length L\"\n  shows \"ladder_ix (ladder_cut L n) index = ladder_ix L index\"", "lemma LeftDerivation_from_in_between:\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> (take u D) \\<beta>\"\n  assumes \\<alpha>_\\<gamma>: \"LeftDerivation \\<alpha> (take v D) \\<gamma>\"\n  assumes u_le_v: \"u \\<le> v\"\n  shows \"LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>\"", "lemma LeftDerivationLadder_cut_appendix_helper: \n  assumes LDLadder: \"LeftDerivationLadder (\\<alpha>@\\<delta>) D L \\<gamma>\"\n  assumes ladder_i_in_\\<alpha>: \"ladder_i L 0 < length \\<alpha>\"\n  shows \"\\<exists> E F \\<gamma>1 \\<gamma>2 L'. D = E@F \\<and> \n    \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and> \n    LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and> \n    derivation_ge F (length \\<gamma>1) \\<and>\n    LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0) \\<gamma>2 \\<and>\n    L' = ladder_cut L (length E)\"", "theorem LeftDerivationLadder_cut_appendix: \n  assumes LDLadder: \"LeftDerivationLadder (\\<alpha>@\\<delta>) D L \\<gamma>\"\n  assumes ladder_i_in_\\<alpha>: \"ladder_i L 0 < length \\<alpha>\"\n  shows \"\\<exists> E F \\<gamma>1 \\<gamma>2 L'. D = E@F \\<and> \n    \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and> \n    LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and> \n    derivation_ge F (length \\<gamma>1) \\<and>\n    LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0) \\<gamma>2 \\<and>\n    length L' = length L \\<and> ladder_i L' 0 = ladder_i L 0 \\<and>\n    ladder_last_j L' = ladder_last_j L\"", "lemma LeftDerivationIntro_LeftDerives1:\n  assumes \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma>\"\n  assumes \"splits_at \\<alpha> i a1 A a2\"\n  shows \"LeftDerives1 \\<alpha> i r (a1@(snd r)@a2)\"", "lemma LeftDerives1_Derive:\n  assumes \"LeftDerives1 \\<alpha> i r \\<gamma>\"\n  shows \"Derive \\<alpha> [(i, r)] = \\<gamma>\"", "lemma ladder_stepdown_\\<alpha>_0_altdef:\n  assumes ladder: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes length_L: \"length L > 1\"\n  assumes split: \"splits_at (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) a1 A a2\"\n  shows \"ladder_stepdown_\\<alpha>_0 \\<alpha> D L = a1 @ (snd (snd (D ! (ladder_n L 0)))) @ a2\"", "lemma ladder_i_0_bound:\n  assumes ld: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  shows \"ladder_i L 0 < length \\<alpha>\"", "lemma ladder_j_bound:\n  assumes ld: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes index_bound: \"index < length L\"\n  shows \"ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\"", "lemma ladder_last_j_bound:\n  assumes ld: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  shows \"ladder_last_j L < length \\<gamma>\"", "lemma ladder_shift_n_length: \n  \"length (ladder_shift_n N L) = length L\"", "lemma ladder_stepdown_prepare:\n  assumes \"length L > 1\"\n  shows \"L = (ladder_n L 0, ladder_j L 0, ladder_i L 0)#\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1)#(drop 2 L)\"", "lemma ladder_stepdown_length:\n  assumes \"length L > 1\"\n  shows \"length (ladder_stepdown L) = length L - 1\"", "lemma ladder_stepdown_i_0:\n  assumes \"length L > 1\"\n  shows \"ladder_i (ladder_stepdown L) 0 = ladder_i L 1 + ladder_ix L 1\"", "lemma ladder_shift_n_cons: \"ladder_shift_n N (x#L) = (fst x - N, snd x)#(ladder_shift_n N L)\"", "lemma ladder_shift_n_drop: \"ladder_shift_n N (drop n L) = drop n (ladder_shift_n N L)\"", "lemma drop_2_shift:\n  assumes \"index > 0\"\n  assumes \"length L > 1\"\n  shows \"drop 2 L ! (index - Suc 0) = L ! Suc index\"", "lemma ladder_shift_n_at:\n  \"index < length L \\<Longrightarrow> (ladder_shift_n N L) ! index = (fst (L ! index) - N, snd (L ! index))\"", "lemma ladder_stepdown_j:\n  assumes length_L_greater_1: \"length L > 1\"\n  assumes L': \"L' = ladder_stepdown L\"\n  assumes index_bound: \"index < length L'\"\n  shows \"ladder_j L' index = ladder_j L (Suc index)\"", "lemma ladder_stepdown_last_j:\n  assumes length_L_greater_1: \"length L > 1\"\n  shows \"ladder_last_j (ladder_stepdown L) = ladder_last_j L\"", "lemma ladder_stepdown_n:\n  assumes length_L_greater_1: \"length L > 1\"\n  assumes L': \"L' = ladder_stepdown L\"\n  assumes index_bound: \"index < length L'\"\n  shows \"ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\"", "lemma ladder_stepdown_ix:\n  assumes length_L_greater_1: \"length L > 1\"\n  assumes L': \"L' = ladder_stepdown L\"\n  assumes index_lower_bound: \"0 < index\"\n  assumes index_upper_bound: \"index < length L'\"\n  shows \"ladder_ix L' index = ladder_ix L (Suc index)\"", "lemma Derive_Derive:\n  assumes \"Derivation \\<alpha> (D@E) \\<gamma>\"\n  shows \"Derive (Derive \\<alpha> D) E = Derive \\<alpha> (D@E)\"", "lemma drop_at_shift:\n  assumes \"n \\<le> index\"\n  assumes \"index < length D\"\n  shows \"drop n D ! (index - n) = D ! index\"", "theorem LeftDerivationLadder_stepdown:\n  assumes ldl: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\" \n  assumes length_L: \"length L > 1\"\n  shows \"\\<exists> L'. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (drop (ladder_stepdown_diff L) D)\n           L' \\<gamma> \\<and> length L' = length L - 1 \\<and> ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n           ladder_last_j L' = ladder_last_j L\"", "lemma ladder_shift_j_length: \n  \"length (ladder_shift_j d L) = length L\"", "lemma ladder_cut_prefix_length:\n  shows \"length (ladder_cut_prefix d L) = length L\"", "lemma ladder_shift_j_cons: \"ladder_shift_j d (x#L) = (fst x, fst (snd x) - d, snd(snd x))#\n  (ladder_shift_j d L)\"", "lemma deriv_j_ladder_shift_j: \n  \"index < length L \\<Longrightarrow> deriv_j (ladder_shift_j d L ! index) = deriv_j (L ! index) - d\"", "lemma deriv_n_ladder_shift_j: \n  \"index < length L \\<Longrightarrow> deriv_n (ladder_shift_j d L ! index) = deriv_n (L ! index)\"", "lemma deriv_ix_ladder_shift_j: \n  \"index < length L \\<Longrightarrow> deriv_ix (ladder_shift_j d L ! index) = deriv_ix (L ! index)\"", "lemma ladder_cut_prefix_j: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_j (ladder_cut_prefix d L) index = ladder_j L index - d\"", "lemma hd_0_subst: \"length L > 0 \\<Longrightarrow> hd (L [0 := x]) = x\"", "lemma ladder_cut_prefix_i: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_i (ladder_cut_prefix d L) index = ladder_i L index - d\"", "lemma ladder_cut_prefix_n: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_n (ladder_cut_prefix d L) index = ladder_n L index\"", "lemma ladder_cut_prefix_ix: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_ix (ladder_cut_prefix d L) index = ladder_ix L index\"", "lemma LeftDerivationFix_derivation_ge_is_nonterminal:\n  assumes ldfix: \"LeftDerivationFix \\<alpha> i D j \\<gamma>\"\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  assumes is_nonterminal: \"is_nonterminal (\\<gamma> ! j)\"\n  shows \"(D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j) \\<or> (i > d \\<and> j \\<ge> d)\"", "lemma LeftDerivationFix_derivation_ge:\n  assumes ldfix: \"LeftDerivationFix \\<alpha> i D j \\<gamma>\"\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  shows \"i = j \\<or> (i > d \\<and> j \\<ge> d)\"", "lemma LeftDerivationIntro_derivation_ge:\n  assumes ldintro: \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma>\"\n  assumes i_ge_d: \"i \\<ge> d\"\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  shows \"j \\<ge> d\"", "lemma derivation_ge_LeftDerivationLadder:\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  assumes ladder: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes ladder_i_0: \"ladder_i L 0 \\<ge> d\"\n  shows \"index < length L \\<Longrightarrow> ladder_i L index \\<ge> d \\<and> ladder_j L index \\<ge> d\"", "lemma derivation_shift_append:\n  \"derivation_shift (A@B) left right = \n    (derivation_shift A left right) @ (derivation_shift B left right)\"", "lemma derivation_shift_right_left_subtract: \n  \"right \\<ge> left \\<Longrightarrow> derivation_shift (derivation_shift L 0 right) left 0 = \n  derivation_shift L 0 (right - left)\"", "lemma LeftDerivationFix_cut_prefix:\n  assumes \"LeftDerivationFix (\\<delta>@\\<alpha>) i D j \\<gamma>\"\n  assumes \"derivation_ge D (length \\<delta>)\"\n  assumes \"i \\<ge> length \\<delta>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  shows \"\\<exists> \\<gamma>'. \\<gamma> = \\<delta> @ \\<gamma>' \\<and> \n    LeftDerivationFix \\<alpha> (i - length \\<delta>) (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\"", "lemma LeftDerives1_propagate_prefix:\n  \"LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<Longrightarrow> i \\<ge> length \\<delta> \\<Longrightarrow> is_prefix \\<delta> \\<beta>\"", "lemma LeftDerivationIntro_cut_prefix:\n  assumes \"LeftDerivationIntro (\\<delta>@\\<alpha>) i r ix D j \\<gamma>\"\n  assumes \"derivation_ge D (length \\<delta>)\"\n  assumes \"i \\<ge> length \\<delta>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  shows \"\\<exists> \\<gamma>'. \\<gamma> = \\<delta> @ \\<gamma>' \\<and> \n    LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\"", "lemma LeftDerivationLadder_implies_LeftDerivation_at_index:\n  assumes \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes \"index < length L\"\n  shows \"LeftDerivation \\<alpha> (take (ladder_n L index) D) (ladder_\\<gamma> \\<alpha> D L index)\"", "lemma LeftDerivationLadder_cut_prefix_propagate:\n  assumes ladder: \"LeftDerivationLadder (\\<delta>@\\<alpha>) D L \\<gamma>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  assumes derivation_ge_\\<delta>: \"derivation_ge D (length \\<delta>)\"\n  assumes ladder_i_0: \"ladder_i L 0 \\<ge> length \\<delta>\"\n  assumes L': \"L' = ladder_cut_prefix (length \\<delta>) L\"\n  assumes D': \"D' = derivation_shift D (length \\<delta>) 0\"\n  shows \"index < length L \\<Longrightarrow> \n    LeftDerivation \\<alpha> (take (ladder_n L' index) D') (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n    ladder_\\<alpha> (\\<delta>@\\<alpha>) D L index = \\<delta>@(ladder_\\<alpha> \\<alpha> D' L' index) \\<and>\n    ladder_\\<gamma> (\\<delta>@\\<alpha>) D L index = \\<delta>@(ladder_\\<gamma> \\<alpha> D' L' index)\"", "theorem LeftDerivationLadder_cut_prefix:\n  assumes ladder: \"LeftDerivationLadder (\\<delta>@\\<alpha>) D L \\<gamma>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  assumes ladder_i_0: \"ladder_i L 0 \\<ge> length \\<delta>\"\n  shows \"\\<exists> D' L' \\<gamma>'. \\<gamma> = \\<delta> @ \\<gamma>' \\<and> \n    LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n    D' = derivation_shift D (length \\<delta>) 0 \\<and>\n    length L' = length L \\<and> ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n    ladder_last_j L' + length \\<delta> = ladder_last_j L\""], "translations": [["", "lemma LeftDerivationFix_empty[simp]: \"is_sentence \\<alpha> \\<Longrightarrow> i < length \\<alpha> \\<Longrightarrow> LeftDerivationFix \\<alpha> i [] i \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_sentence \\<alpha>; i < length \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationFix \\<alpha> i [] i \\<alpha>", "apply (auto simp add: LeftDerivationFix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_sentence \\<alpha>; i < length \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F.\n                         derivation_shift F 0 (Suc i) = [] \\<and>\n                         LeftDerivation (drop (Suc i) \\<alpha>) F\n                          (drop (Suc i) \\<alpha>)", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_sentence \\<alpha>; i < length \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> derivation_shift [] 0 (Suc i) = [] \\<and>\n                      LeftDerivation (drop (Suc i) \\<alpha>) []\n                       (drop (Suc i) \\<alpha>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Derive_empty[simp]: \"Derive a [] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive a [] = a", "by (auto simp add: Derive_def)"], ["", "lemma LeftDerivation_append1: \"LeftDerivation a (D@[(i, r)]) c \\<Longrightarrow> \\<exists> b. LeftDerivation a D b \n  \\<and> LeftDerives1 b i r c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation a (D @ [(i, r)]) c \\<Longrightarrow>\n    \\<exists>b. LeftDerivation a D b \\<and> LeftDerives1 b i r c", "by (simp add: LeftDerivation_append)"], ["", "lemma Derivation_append1: \"Derivation a (D@[(i, r)]) c \\<Longrightarrow> \\<exists> b. Derivation a D b \n  \\<and> Derives1 b i r c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derivation a (D @ [(i, r)]) c \\<Longrightarrow>\n    \\<exists>b. Derivation a D b \\<and> Derives1 b i r c", "by (simp add: Derivation_append)"], ["", "lemma  Derivation_take_derive:\n  assumes \"Derivation a D b\"\n  shows \"Derivation a (take n D) (Derive a (take n D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derivation a (take n D) (Derive a (take n D))", "by (metis Derivation_append Derive append_take_drop_id assms)"], ["", "lemma  LeftDerivation_take_derive:\n  assumes \"LeftDerivation a D b\"\n  shows \"LeftDerivation a (take n D) (Derive a (take n D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation a (take n D) (Derive a (take n D))", "by (metis Derive LeftDerivation_append LeftDerivation_implies_Derivation append_take_drop_id assms)"], ["", "lemma Derivation_Derive_take_Derives1:\n  assumes \"N \\<noteq> 0\"\n  assumes \"N \\<le> length D\"\n  assumes \"Derivation a D b\"\n  assumes \\<alpha>: \"\\<alpha> = Derive a (take (N - 1) D)\"\n  assumes \"\\<beta> = Derive a (take N D)\"\n  shows \"Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "let ?D1 = \"take (N - 1) D\""], ["proof (state)\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "let ?D2 = \"take N D\""], ["proof (state)\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "from assms"], ["proof (chain)\npicking this:\n  N \\<noteq> 0\n  N \\<le> length D\n  Derivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)", "have app: \"?D2 = ?D1 @ [D ! (N - 1)]\""], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  N \\<le> length D\n  Derivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)\n\ngoal (1 subgoal):\n 1. take N D = take (N - 1) D @ [D ! (N - 1)]", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < N; N \\<le> length D; Derivation a D b;\n     \\<alpha> = Derive a (take (N - Suc 0) D);\n     \\<beta> = Derive a (take N D)\\<rbrakk>\n    \\<Longrightarrow> take N D = take (N - Suc 0) D @ [D ! (N - Suc 0)]", "by (metis Suc_less_eq Suc_pred le_imp_less_Suc take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take N D = take (N - 1) D @ [D ! (N - 1)]\n\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "from assms"], ["proof (chain)\npicking this:\n  N \\<noteq> 0\n  N \\<le> length D\n  Derivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)", "have \"Derivation a ?D2 \\<beta>\""], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  N \\<le> length D\n  Derivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)\n\ngoal (1 subgoal):\n 1. Derivation a (take N D) \\<beta>", "using Derivation_take_derive"], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  N \\<le> length D\n  Derivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)\n  Derivation ?a ?D ?b \\<Longrightarrow>\n  Derivation ?a (take ?n ?D) (Derive ?a (take ?n ?D))\n\ngoal (1 subgoal):\n 1. Derivation a (take N D) \\<beta>", "by blast"], ["proof (state)\nthis:\n  Derivation a (take N D) \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "with app"], ["proof (chain)\npicking this:\n  take N D = take (N - 1) D @ [D ! (N - 1)]\n  Derivation a (take N D) \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  take N D = take (N - 1) D @ [D ! (N - 1)]\n  Derivation a (take N D) \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "using Derivation.simps Derivation_append Derive \\<alpha>"], ["proof (prove)\nusing this:\n  take N D = take (N - 1) D @ [D ! (N - 1)]\n  Derivation a (take N D) \\<beta>\n  Derivation ?a [] ?b = (?a = ?b)\n  Derivation ?a (?d # ?D) ?b =\n  (\\<exists>x. Derives1 ?a (fst ?d) (snd ?d) x \\<and> Derivation x ?D ?b)\n  Derivation ?a (?D @ ?E) ?c =\n  (\\<exists>b. Derivation ?a ?D b \\<and> Derivation b ?E ?c)\n  Derivation ?a ?D ?b \\<Longrightarrow> Derive ?a ?D = ?b\n  \\<alpha> = Derive a (take (N - 1) D)\n\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "by auto"], ["proof (state)\nthis:\n  Derives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivation_Derive_take_LeftDerives1:\n  assumes \"N \\<noteq> 0\"\n  assumes \"N \\<le> length D\"\n  assumes \"LeftDerivation a D b\"\n  assumes \\<alpha>: \"\\<alpha> = Derive a (take (N - 1) D)\"\n  assumes \"\\<beta> = Derive a (take N D)\"\n  shows \"LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "let ?D1 = \"take (N - 1) D\""], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "let ?D2 = \"take N D\""], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "from assms"], ["proof (chain)\npicking this:\n  N \\<noteq> 0\n  N \\<le> length D\n  LeftDerivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)", "have app: \"?D2 = ?D1 @ [D ! (N - 1)]\""], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  N \\<le> length D\n  LeftDerivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)\n\ngoal (1 subgoal):\n 1. take N D = take (N - 1) D @ [D ! (N - 1)]", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < N; N \\<le> length D; LeftDerivation a D b;\n     \\<alpha> = Derive a (take (N - Suc 0) D);\n     \\<beta> = Derive a (take N D)\\<rbrakk>\n    \\<Longrightarrow> take N D = take (N - Suc 0) D @ [D ! (N - Suc 0)]", "by (metis Suc_less_eq Suc_pred le_imp_less_Suc take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take N D = take (N - 1) D @ [D ! (N - 1)]\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "from assms"], ["proof (chain)\npicking this:\n  N \\<noteq> 0\n  N \\<le> length D\n  LeftDerivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)", "have \"LeftDerivation a ?D2 \\<beta>\""], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  N \\<le> length D\n  LeftDerivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)\n\ngoal (1 subgoal):\n 1. LeftDerivation a (take N D) \\<beta>", "using LeftDerivation_take_derive"], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  N \\<le> length D\n  LeftDerivation a D b\n  \\<alpha> = Derive a (take (N - 1) D)\n  \\<beta> = Derive a (take N D)\n  LeftDerivation ?a ?D ?b \\<Longrightarrow>\n  LeftDerivation ?a (take ?n ?D) (Derive ?a (take ?n ?D))\n\ngoal (1 subgoal):\n 1. LeftDerivation a (take N D) \\<beta>", "by blast"], ["proof (state)\nthis:\n  LeftDerivation a (take N D) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "with app"], ["proof (chain)\npicking this:\n  take N D = take (N - 1) D @ [D ! (N - 1)]\n  LeftDerivation a (take N D) \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  take N D = take (N - 1) D @ [D ! (N - 1)]\n  LeftDerivation a (take N D) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>", "by (metis Derive LeftDerivation_append1 LeftDerivation_implies_Derivation \\<alpha> prod.collapse)"], ["proof (state)\nthis:\n  LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerives1_skip_prefix:\n  \"length a \\<le> i \\<Longrightarrow> LeftDerives1 (a@b) i r (a@c) \\<Longrightarrow> LeftDerives1 b (i - length a) r c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a \\<le> i; LeftDerives1 (a @ b) i r (a @ c)\\<rbrakk>\n    \\<Longrightarrow> LeftDerives1 b (i - length a) r c", "apply (auto simp add: LeftDerives1_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length a \\<le> i; leftmost i (a @ b);\n     Derives1 (a @ b) i r (a @ c)\\<rbrakk>\n    \\<Longrightarrow> leftmost (i - length a) b\n 2. \\<lbrakk>length a \\<le> i; leftmost i (a @ b);\n     Derives1 (a @ b) i r (a @ c)\\<rbrakk>\n    \\<Longrightarrow> Derives1 b (i - length a) r c", "using leftmost_skip_prefix"], ["proof (prove)\nusing this:\n  \\<lbrakk>leftmost ?i (?u @ ?v); length ?u \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> leftmost (?i - length ?u) ?v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length a \\<le> i; leftmost i (a @ b);\n     Derives1 (a @ b) i r (a @ c)\\<rbrakk>\n    \\<Longrightarrow> leftmost (i - length a) b\n 2. \\<lbrakk>length a \\<le> i; leftmost i (a @ b);\n     Derives1 (a @ b) i r (a @ c)\\<rbrakk>\n    \\<Longrightarrow> Derives1 b (i - length a) r c", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a \\<le> i; leftmost i (a @ b);\n     Derives1 (a @ b) i r (a @ c)\\<rbrakk>\n    \\<Longrightarrow> Derives1 b (i - length a) r c", "by (simp add: Derives1_skip_prefix)"], ["", "lemma LeftDerives1_skip_suffix:\n  assumes i: \"i < length a\"\n  assumes D: \"LeftDerives1 (a@c) i r (b@c)\"\n  shows \"LeftDerives1 a i r b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "note Derives1_def[where u=\"a@c\" and v=\"b@c\" and i=i and r=r]"], ["proof (state)\nthis:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "then"], ["proof (chain)\npicking this:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)", "have \"\\<exists>x y N \\<alpha>.\n    a @ c = x @ [N] @ y \\<and>\n    b @ c = x @ \\<alpha> @ y \\<and> is_sentence x \\<and> is_sentence y \\<and> (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\""], ["proof (prove)\nusing this:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)\n\ngoal (1 subgoal):\n 1. \\<exists>x y N \\<alpha>.\n       a @ c = x @ [N] @ y \\<and>\n       b @ c = x @ \\<alpha> @ y \\<and>\n       is_sentence x \\<and>\n       is_sentence y \\<and>\n       (N, \\<alpha>) \\<in> \\<RR> \\<and>\n       r = (N, \\<alpha>) \\<and> i = length x", "using D LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  Derives1 (a @ c) i r (b @ c) =\n  (\\<exists>x y N \\<alpha>.\n      a @ c = x @ [N] @ y \\<and>\n      b @ c = x @ \\<alpha> @ y \\<and>\n      is_sentence x \\<and>\n      is_sentence y \\<and>\n      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n      r = (N, \\<alpha>) \\<and> i = length x)\n  LeftDerives1 (a @ c) i r (b @ c)\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. \\<exists>x y N \\<alpha>.\n       a @ c = x @ [N] @ y \\<and>\n       b @ c = x @ \\<alpha> @ y \\<and>\n       is_sentence x \\<and>\n       is_sentence y \\<and>\n       (N, \\<alpha>) \\<in> \\<RR> \\<and>\n       r = (N, \\<alpha>) \\<and> i = length x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x y N \\<alpha>.\n     a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and>\n     is_sentence x \\<and>\n     is_sentence y \\<and>\n     (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "then"], ["proof (chain)\npicking this:\n  \\<exists>x y N \\<alpha>.\n     a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and>\n     is_sentence x \\<and>\n     is_sentence y \\<and>\n     (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "obtain x y N \\<alpha> where split:\n    \"a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and> is_sentence x \\<and> is_sentence y \\<and> (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\""], ["proof (prove)\nusing this:\n  \\<exists>x y N \\<alpha>.\n     a @ c = x @ [N] @ y \\<and>\n     b @ c = x @ \\<alpha> @ y \\<and>\n     is_sentence x \\<and>\n     is_sentence y \\<and>\n     (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. (\\<And>x N y \\<alpha>.\n        a @ c = x @ [N] @ y \\<and>\n        b @ c = x @ \\<alpha> @ y \\<and>\n        is_sentence x \\<and>\n        is_sentence y \\<and>\n        (N, \\<alpha>) \\<in> \\<RR> \\<and>\n        r = (N, \\<alpha>) \\<and> i = length x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "from split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "have \"length (a@c) = length (x @ [N] @ y)\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. length (a @ c) = length (x @ [N] @ y)", "by auto"], ["proof (state)\nthis:\n  length (a @ c) = length (x @ [N] @ y)\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "then"], ["proof (chain)\npicking this:\n  length (a @ c) = length (x @ [N] @ y)", "have \"length a + length c = length x + length y + 1\""], ["proof (prove)\nusing this:\n  length (a @ c) = length (x @ [N] @ y)\n\ngoal (1 subgoal):\n 1. length a + length c = length x + length y + 1", "by simp"], ["proof (state)\nthis:\n  length a + length c = length x + length y + 1\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "with split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length a + length c = length x + length y + 1", "have \"length a + length c = i + length y + 1\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length a + length c = length x + length y + 1\n\ngoal (1 subgoal):\n 1. length a + length c = i + length y + 1", "by simp"], ["proof (state)\nthis:\n  length a + length c = i + length y + 1\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "with i"], ["proof (chain)\npicking this:\n  i < length a\n  length a + length c = i + length y + 1", "have len_c_y: \"length c \\<le> length y\""], ["proof (prove)\nusing this:\n  i < length a\n  length a + length c = i + length y + 1\n\ngoal (1 subgoal):\n 1. length c \\<le> length y", "by arith"], ["proof (state)\nthis:\n  length c \\<le> length y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "let ?y = \"take (length y - length c) y\""], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "from split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "have ac: \"a @ c = (x @ [N]) @ y\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. a @ c = (x @ [N]) @ y", "by auto"], ["proof (state)\nthis:\n  a @ c = (x @ [N]) @ y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "note cancel_suffix[where a=a and c = c and b = \"x@[N]\" and d = \"y\", OF ac len_c_y]"], ["proof (state)\nthis:\n  a = (x @ [N]) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "then"], ["proof (chain)\npicking this:\n  a = (x @ [N]) @ take (length y - length c) y", "have a: \"a = x @ [N] @ ?y\""], ["proof (prove)\nusing this:\n  a = (x @ [N]) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. a = x @ [N] @ take (length y - length c) y", "by auto"], ["proof (state)\nthis:\n  a = x @ [N] @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "from split"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x", "have bc: \"b @ c = (x @ \\<alpha>) @ y\""], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n\ngoal (1 subgoal):\n 1. b @ c = (x @ \\<alpha>) @ y", "by auto"], ["proof (state)\nthis:\n  b @ c = (x @ \\<alpha>) @ y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "note cancel_suffix[where a=b and c = c and b = \"x@\\<alpha>\" and d = \"y\", OF bc len_c_y]"], ["proof (state)\nthis:\n  b = (x @ \\<alpha>) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "then"], ["proof (chain)\npicking this:\n  b = (x @ \\<alpha>) @ take (length y - length c) y", "have b: \"b = x @ \\<alpha> @ ?y\""], ["proof (prove)\nusing this:\n  b = (x @ \\<alpha>) @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. b = x @ \\<alpha> @ take (length y - length c) y", "by auto"], ["proof (state)\nthis:\n  b = x @ \\<alpha> @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "from split len_c_y a b"], ["proof (chain)\npicking this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length c \\<le> length y\n  a = x @ [N] @ take (length y - length c) y\n  b = x @ \\<alpha> @ take (length y - length c) y", "show ?thesis"], ["proof (prove)\nusing this:\n  a @ c = x @ [N] @ y \\<and>\n  b @ c = x @ \\<alpha> @ y \\<and>\n  is_sentence x \\<and>\n  is_sentence y \\<and>\n  (N, \\<alpha>) \\<in> \\<RR> \\<and> r = (N, \\<alpha>) \\<and> i = length x\n  length c \\<le> length y\n  a = x @ [N] @ take (length y - length c) y\n  b = x @ \\<alpha> @ take (length y - length c) y\n\ngoal (1 subgoal):\n 1. LeftDerives1 a i r b", "apply (simp only: LeftDerives1_def Derives1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> leftmost (length x)\n                       (x @ [N] @ take (length y - length c) y) \\<and>\n                      (\\<exists>xa ya Na \\<alpha>'.\n                          x @ [N] @ take (length y - length c) y =\n                          xa @ [Na] @ ya \\<and>\n                          x @ \\<alpha> @ take (length y - length c) y =\n                          xa @ \\<alpha>' @ ya \\<and>\n                          is_sentence xa \\<and>\n                          is_sentence ya \\<and>\n                          (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                          (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                          length x = length xa)", "apply (rule_tac conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> leftmost (length x)\n                       (x @ [N] @ take (length y - length c) y)\n 2. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa ya Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         xa @ [Na] @ ya \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         xa @ \\<alpha>' @ ya \\<and>\n                         is_sentence xa \\<and>\n                         is_sentence ya \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length xa", "using D LeftDerives1_def i leftmost_cons_less"], ["proof (prove)\nusing this:\n  LeftDerives1 (a @ c) i r (b @ c)\n  LeftDerives1 ?u ?i ?r ?v = (leftmost ?i ?u \\<and> Derives1 ?u ?i ?r ?v)\n  i < length a\n  ?i < length ?u \\<Longrightarrow> leftmost ?i (?u @ ?v) = leftmost ?i ?u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> leftmost (length x)\n                       (x @ [N] @ take (length y - length c) y)\n 2. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa ya Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         xa @ [Na] @ ya \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         xa @ \\<alpha>' @ ya \\<and>\n                         is_sentence xa \\<and>\n                         is_sentence ya \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length xa", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa ya Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         xa @ [Na] @ ya \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         xa @ \\<alpha>' @ ya \\<and>\n                         is_sentence xa \\<and>\n                         is_sentence ya \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length xa", "apply (rule_tac x=x in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ya Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         x @ [Na] @ ya \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         x @ \\<alpha>' @ ya \\<and>\n                         is_sentence x \\<and>\n                         is_sentence ya \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length x", "apply (rule_tac x=\"?y\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Na \\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         x @ [Na] @ take (length y - length c) y \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         x @ \\<alpha>' @ take (length y - length c) y \\<and>\n                         is_sentence x \\<and>\n                         is_sentence (take (length y - length c) y) \\<and>\n                         (Na, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (Na, \\<alpha>') \\<and>\n                         length x = length x", "apply (rule_tac x=\"N\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<alpha>'.\n                         x @ [N] @ take (length y - length c) y =\n                         x @ [N] @ take (length y - length c) y \\<and>\n                         x @ \\<alpha> @ take (length y - length c) y =\n                         x @ \\<alpha>' @ take (length y - length c) y \\<and>\n                         is_sentence x \\<and>\n                         is_sentence (take (length y - length c) y) \\<and>\n                         (N, \\<alpha>') \\<in> \\<RR> \\<and>\n                         (N, \\<alpha>) = (N, \\<alpha>') \\<and>\n                         length x = length x", "apply (rule_tac x=\"\\<alpha>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x @ [N] @ take (length y - length c) y) @ c =\n             x @ [N] @ y \\<and>\n             (x @ \\<alpha> @ take (length y - length c) y) @ c =\n             x @ \\<alpha> @ y \\<and>\n             is_sentence x \\<and>\n             is_sentence y \\<and>\n             (N, \\<alpha>) \\<in> \\<RR> \\<and>\n             r = (N, \\<alpha>) \\<and> i = length x;\n     length c \\<le> length y; a = x @ [N] @ take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y\\<rbrakk>\n    \\<Longrightarrow> x @ [N] @ take (length y - length c) y =\n                      x @ [N] @ take (length y - length c) y \\<and>\n                      x @ \\<alpha> @ take (length y - length c) y =\n                      x @ \\<alpha> @ take (length y - length c) y \\<and>\n                      is_sentence x \\<and>\n                      is_sentence (take (length y - length c) y) \\<and>\n                      (N, \\<alpha>) \\<in> \\<RR> \\<and>\n                      (N, \\<alpha>) = (N, \\<alpha>) \\<and>\n                      length x = length x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length c \\<le> length y;\n     a = x @ N # take (length y - length c) y;\n     b = x @ \\<alpha> @ take (length y - length c) y;\n     take (length y - length c) y @ c = y; is_sentence x; is_sentence y;\n     (N, \\<alpha>) \\<in> \\<RR>; r = (N, \\<alpha>); i = length x\\<rbrakk>\n    \\<Longrightarrow> is_sentence (take (length y - length c) y)", "by (rule is_sentence_take)"], ["proof (state)\nthis:\n  LeftDerives1 a i r b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerives1_X_is_part_of_rule[consumes 2, case_names Suffix Prefix]:\n  assumes aXb: \"LeftDerives1 \\<delta> i r (a@[X]@b)\"\n  assumes split: \"splits_at \\<delta> i \\<alpha> N \\<beta>\"\n  assumes prefix: \"\\<And> \\<beta>. \\<delta> = a @ [X] @ \\<beta> \\<Longrightarrow> length a < i \\<Longrightarrow> is_word (a @ [X]) \\<Longrightarrow>\n                     LeftDerives1 \\<beta> (i - length a - 1) r b \\<Longrightarrow> False\"\n  assumes suffix: \"\\<And> \\<alpha>. \\<delta> = \\<alpha> @ [X] @ b \\<Longrightarrow> LeftDerives1 \\<alpha> i r a \\<Longrightarrow> False\" \n  shows \"\\<exists> u v. a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> (snd r) = u@[X]@v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have aXb_old: \"Derives1 \\<delta> i r (a@[X]@b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 \\<delta> i r (a @ [X] @ b)", "using LeftDerives1_implies_Derives1 aXb"], ["proof (prove)\nusing this:\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. Derives1 \\<delta> i r (a @ [X] @ b)", "by blast"], ["proof (state)\nthis:\n  Derives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have prefix_or: \"is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>", "by (metis Derives1_prefix split aXb_old is_prefix_eq_proper_prefix)"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have is_word_\\<alpha>: \"is_word \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_word \\<alpha>", "using LeftDerives1_splits_at_is_word aXb assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerives1 ?\\<delta> ?i ?r ?s;\n   splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> is_word ?\\<alpha>\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n  splits_at \\<delta> i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. is_word \\<alpha>", "by blast"], ["proof (state)\nthis:\n  is_word \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have \"is_proper_prefix a \\<alpha> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "assume proper:\"is_proper_prefix a \\<alpha>\""], ["proof (state)\nthis:\n  is_proper_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_proper_prefix a \\<alpha>", "have \"\\<exists> u. u \\<noteq> [] \\<and> \\<alpha> = a@u\""], ["proof (prove)\nusing this:\n  is_proper_prefix a \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u", "by (metis is_proper_prefix_def)"], ["proof (state)\nthis:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u", "obtain u where u: \"u \\<noteq> [] \\<and> \\<alpha> = a@u\""], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<noteq> [] \\<and> \\<alpha> = a @ u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "note splits_at = splits_at_\\<alpha>[OF aXb_old split] splits_at_combine[OF split]"], ["proof (state)\nthis:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<alpha>1: \"\\<alpha> = take i \\<delta>\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> = take i \\<delta>", "by blast"], ["proof (state)\nthis:\n  \\<alpha> = take i \\<delta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<alpha>2: \"\\<alpha> = take i (a@[X]@b)\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> = take i (a @ [X] @ b)", "by blast"], ["proof (state)\nthis:\n  \\<alpha> = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have len\\<alpha>: \"length \\<alpha> = i\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. length \\<alpha> = i", "by blast"], ["proof (state)\nthis:\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with proper"], ["proof (chain)\npicking this:\n  is_proper_prefix a \\<alpha>\n  length \\<alpha> = i", "have lena: \"length a < i\""], ["proof (prove)\nusing this:\n  is_proper_prefix a \\<alpha>\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. length a < i", "using append_eq_conv_conj drop_eq_Nil leI u"], ["proof (prove)\nusing this:\n  is_proper_prefix a \\<alpha>\n  length \\<alpha> = i\n  (?xs @ ?ys = ?zs) =\n  (?xs = take (length ?xs) ?zs \\<and> ?ys = drop (length ?xs) ?zs)\n  (drop ?n ?xs = []) = (length ?xs \\<le> ?n)\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n\ngoal (1 subgoal):\n 1. length a < i", "by auto"], ["proof (state)\nthis:\n  length a < i\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with is_word_\\<alpha> \\<alpha>2"], ["proof (chain)\npicking this:\n  is_word \\<alpha>\n  \\<alpha> = take i (a @ [X] @ b)\n  length a < i", "have is_word_aX: \"is_word (a@[X])\""], ["proof (prove)\nusing this:\n  is_word \\<alpha>\n  \\<alpha> = take i (a @ [X] @ b)\n  length a < i\n\ngoal (1 subgoal):\n 1. is_word (a @ [X])", "by (simp add: is_word_terminals not_less take_Cons' u)"], ["proof (state)\nthis:\n  is_word (a @ [X])\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from u \\<alpha>2"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  \\<alpha> = take i (a @ [X] @ b)", "have \"a@u = take i (a@[X]@b)\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  \\<alpha> = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. a @ u = take i (a @ [X] @ b)", "by auto"], ["proof (state)\nthis:\n  a @ u = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with lena"], ["proof (chain)\npicking this:\n  length a < i\n  a @ u = take i (a @ [X] @ b)", "have \"u = take (i - length a) ([X]@b)\""], ["proof (prove)\nusing this:\n  length a < i\n  a @ u = take i (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. u = take (i - length a) ([X] @ b)", "by (simp add: less_or_eq_imp_le)"], ["proof (state)\nthis:\n  u = take (i - length a) ([X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with lena"], ["proof (chain)\npicking this:\n  length a < i\n  u = take (i - length a) ([X] @ b)", "have uX: \"u = [X]@(take (i - length a - 1) b)\""], ["proof (prove)\nusing this:\n  length a < i\n  u = take (i - length a) ([X] @ b)\n\ngoal (1 subgoal):\n 1. u = [X] @ take (i - length a - 1) b", "by (simp add: not_less take_Cons')"], ["proof (state)\nthis:\n  u = [X] @ take (i - length a - 1) b\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "let ?\\<beta> = \"(take (i - length a - 1) b) @ [N] @ \\<beta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f1: \"\\<delta> = \\<alpha> @ [N] @ \\<beta>\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = \\<alpha> @ [N] @ \\<beta>", "by blast"], ["proof (state)\nthis:\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "with u uX"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  u = [X] @ take (i - length a - 1) b\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f2: \"\\<delta> = a @ [X] @ ?\\<beta>\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<alpha> = a @ u\n  u = [X] @ take (i - length a - 1) b\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = a @ [X] @ take (i - length a - 1) b @ [N] @ \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<delta> = a @ [X] @ take (i - length a - 1) b @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "note skip = LeftDerives1_skip_prefix[where a = \"a @ [X]\" and b = \"?\\<beta>\" and \n      r = r and i = i and c = b]"], ["proof (state)\nthis:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   LeftDerives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   LeftDerives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b", "have D: \"LeftDerives1 ?\\<beta> (i - length a - 1) r b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   LeftDerives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b\n\ngoal (1 subgoal):\n 1. LeftDerives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n     (i - length a - 1) r b", "using One_nat_def Suc_leI aXb append_assoc diff_diff_left f2 lena length_Cons \n        length_append length_append_singleton list.size(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>length (a @ [X]) \\<le> i;\n   LeftDerives1 ((a @ [X]) @ take (i - length a - 1) b @ [N] @ \\<beta>) i r\n    ((a @ [X]) @ b)\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n                     (i - length (a @ [X])) r b\n  1 = Suc 0\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n  (?xs @ ?ys) @ ?zs = ?xs @ ?ys @ ?zs\n  ?i - ?j - ?k = ?i - (?j + ?k)\n  \\<delta> = a @ [X] @ take (i - length a - 1) b @ [N] @ \\<beta>\n  length a < i\n  length (?x # ?xs) = Suc (length ?xs)\n  length (?xs @ ?ys) = length ?xs + length ?ys\n  length (?xs @ [?x]) = Suc (length ?xs)\n  length [] = 0\n\ngoal (1 subgoal):\n 1. LeftDerives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n     (i - length a - 1) r b", "by fastforce"], ["proof (state)\nthis:\n  LeftDerives1 (take (i - length a - 1) b @ [N] @ \\<beta>)\n   (i - length a - 1) r b\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "note prefix[OF f2 lena is_word_aX D]"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  False", "show \"False\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_proper_prefix a \\<alpha> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "with prefix_or"], ["proof (chain)\npicking this:\n  is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\n  is_proper_prefix a \\<alpha> \\<Longrightarrow> False", "have is_prefix: \"is_prefix \\<alpha> a\""], ["proof (prove)\nusing this:\n  is_prefix \\<alpha> a \\<or> is_proper_prefix a \\<alpha>\n  is_proper_prefix a \\<alpha> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. is_prefix \\<alpha> a", "by blast"], ["proof (state)\nthis:\n  is_prefix \\<alpha> a\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from aXb"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)", "have aXb': \"LeftDerives1 \\<delta> i r ((a@[X])@b)\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<delta> i r ((a @ [X]) @ b)", "by auto"], ["proof (state)\nthis:\n  LeftDerives1 \\<delta> i r ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<delta> i r ((a @ [X]) @ b)", "have aXb'_old: \"Derives1 \\<delta> i r ((a@[X])@b)\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<delta> i r ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. Derives1 \\<delta> i r ((a @ [X]) @ b)", "by (simp add: LeftDerives1_implies_Derives1)"], ["proof (state)\nthis:\n  Derives1 \\<delta> i r ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "note Derives1_suffix[OF aXb'_old split]"], ["proof (state)\nthis:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>", "have suffix_or: \"is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\""], ["proof (prove)\nusing this:\n  is_suffix \\<beta> b \\<or> is_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>", "by (metis is_suffix_eq_proper_suffix)"], ["proof (state)\nthis:\n  is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "have \"is_proper_suffix b \\<beta> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "assume proper: \"is_proper_suffix b \\<beta>\""], ["proof (state)\nthis:\n  is_proper_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_proper_suffix b \\<beta>", "have \"\\<exists> u. u \\<noteq> [] \\<and> \\<beta> = u@b\""], ["proof (prove)\nusing this:\n  is_proper_suffix b \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b", "by (metis is_proper_suffix_def)"], ["proof (state)\nthis:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b", "obtain u where u: \"u \\<noteq> [] \\<and> \\<beta> = u@b\""], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<noteq> [] \\<and> \\<beta> = u @ b\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<noteq> [] \\<and> \\<beta> = u @ b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note splits_at = splits_at_\\<beta>[OF aXb_old split] splits_at_combine[OF split]"], ["proof (state)\nthis:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<beta>1: \"\\<beta> = drop (Suc i) \\<delta>\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> = drop (Suc i) \\<delta>", "by blast"], ["proof (state)\nthis:\n  \\<beta> = drop (Suc i) \\<delta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have \\<beta>2: \"\\<beta> = drop (i + length (snd r)) (a @ [X] @ b)\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)", "by blast"], ["proof (state)\nthis:\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have len\\<beta>: \"length \\<beta> = length \\<delta> - i - 1\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. length \\<beta> = length \\<delta> - i - 1", "by blast"], ["proof (state)\nthis:\n  length \\<beta> = length \\<delta> - i - 1\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "with proper"], ["proof (chain)\npicking this:\n  is_proper_suffix b \\<beta>\n  length \\<beta> = length \\<delta> - i - 1", "have lenb: \"length b < length \\<beta>\""], ["proof (prove)\nusing this:\n  is_proper_suffix b \\<beta>\n  length \\<beta> = length \\<delta> - i - 1\n\ngoal (1 subgoal):\n 1. length b < length \\<beta>", "by (metis is_proper_suffix_length_cmp)"], ["proof (state)\nthis:\n  length b < length \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from u \\<beta>2"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)", "have \"u@b = drop (i + length (snd r)) ((a @ [X]) @ b)\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. u @ b = drop (i + length (snd r)) ((a @ [X]) @ b)", "by auto"], ["proof (state)\nthis:\n  u @ b = drop (i + length (snd r)) ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "hence \"u = drop (i + length (snd r)) (a @ [X])\""], ["proof (prove)\nusing this:\n  u @ b = drop (i + length (snd r)) ((a @ [X]) @ b)\n\ngoal (1 subgoal):\n 1. u = drop (i + length (snd r)) (a @ [X])", "by (metis drop_cancel_suffix)"], ["proof (state)\nthis:\n  u = drop (i + length (snd r)) (a @ [X])\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "hence uX: \"u = drop (i + length (snd r)) a @ [X]\""], ["proof (prove)\nusing this:\n  u = drop (i + length (snd r)) (a @ [X])\n\ngoal (1 subgoal):\n 1. u = drop (i + length (snd r)) a @ [X]", "by (metis drop_keep_last u)"], ["proof (state)\nthis:\n  u = drop (i + length (snd r)) a @ [X]\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "let ?\\<alpha> = \"\\<alpha> @ [N] @ (drop (i + length (snd r)) a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from splits_at"], ["proof (chain)\npicking this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f1: \"\\<delta> = \\<alpha> @ [N] @ \\<beta>\""], ["proof (prove)\nusing this:\n  \\<beta> = drop (Suc i) \\<delta> \\<and>\n  \\<beta> = drop (i + length (snd r)) (a @ [X] @ b) \\<and>\n  length \\<beta> = length \\<delta> - i - 1\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = \\<alpha> @ [N] @ \\<beta>", "by blast"], ["proof (state)\nthis:\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "with u uX"], ["proof (chain)\npicking this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  u = drop (i + length (snd r)) a @ [X]\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>", "have f2: \"\\<delta> = ?\\<alpha> @ [X] @ b\""], ["proof (prove)\nusing this:\n  u \\<noteq> [] \\<and> \\<beta> = u @ b\n  u = drop (i + length (snd r)) a @ [X]\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b", "by simp"], ["proof (state)\nthis:\n  \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note skip = LeftDerives1_skip_suffix[where a = \"?\\<alpha>\" and c = \"[X]@b\" and b=\"a\" and\n      r = r and i = i]"], ["proof (state)\nthis:\n  \\<lbrakk>i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a);\n   LeftDerives1 ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) i\n    r (a @ [X] @ b)\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1\n                     (\\<alpha> @ [N] @ drop (i + length (snd r)) a) i r a\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "have f3: \"i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "have f1: \"1 + i + length b = length [X] + length b + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + i + length b = length [X] + length b + i", "by (metis Groups.add_ac(2) Suc_eq_plus1_left length_Cons list.size(3) list.size(4) semiring_normalization_rules(22))"], ["proof (state)\nthis:\n  1 + i + length b = length [X] + length b + i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "have f2: \"length \\<delta> - i - 1 = length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) - Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<delta> - i - 1 =\n    length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) -\n    Suc i", "by (metis f2 length_drop splits_at(1))"], ["proof (state)\nthis:\n  length \\<delta> - i - 1 =\n  length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) - Suc i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "have \"length ([]::symbol list) \\<noteq> length \\<delta> - i - 1 - length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] \\<noteq> length \\<delta> - i - 1 - length b", "by (metis add_diff_cancel_right' append_Nil2 append_eq_append_conv len\\<beta> length_append u)"], ["proof (state)\nthis:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "then"], ["proof (chain)\npicking this:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b", "have \"length ([]::symbol list) \\<noteq> length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i\""], ["proof (prove)\nusing this:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b\n\ngoal (1 subgoal):\n 1. length [] \\<noteq>\n    length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i", "using f2 f1"], ["proof (prove)\nusing this:\n  length [] \\<noteq> length \\<delta> - i - 1 - length b\n  length \\<delta> - i - 1 =\n  length ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) - Suc i\n  1 + i + length b = length [X] + length b + i\n\ngoal (1 subgoal):\n 1. length [] \\<noteq>\n    length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i", "by (metis Suc_eq_plus1_left add_diff_cancel_right' diff_diff_left length_append)"], ["proof (state)\nthis:\n  length [] \\<noteq>\n  length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "then"], ["proof (chain)\npicking this:\n  length [] \\<noteq>\n  length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i", "show ?thesis"], ["proof (prove)\nusing this:\n  length [] \\<noteq>\n  length \\<alpha> + length ([N] @ drop (i + length (snd r)) a) - i\n\ngoal (1 subgoal):\n 1. i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)", "by auto"], ["proof (state)\nthis:\n  i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (\\<alpha> @ [N] @ drop (i + length (snd r)) a)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "from aXb f2"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n  \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b", "have D: \"LeftDerives1 (?\\<alpha> @ [X] @ b) i r (a@[X]@b)\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n  \\<delta> = (\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b\n\ngoal (1 subgoal):\n 1. LeftDerives1 ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b)\n     i r (a @ [X] @ b)", "by auto"], ["proof (state)\nthis:\n  LeftDerives1 ((\\<alpha> @ [N] @ drop (i + length (snd r)) a) @ [X] @ b) i\n   r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note skip[OF f3 D]"], ["proof (state)\nthis:\n  LeftDerives1 (\\<alpha> @ [N] @ drop (i + length (snd r)) a) i r a\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "note suffix[OF f2  skip[OF f3 D]]"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. is_proper_suffix b \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  False", "show \"False\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_proper_suffix b \\<beta> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "with suffix_or"], ["proof (chain)\npicking this:\n  is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\n  is_proper_suffix b \\<beta> \\<Longrightarrow> False", "have is_suffix: \"is_suffix \\<beta> b\""], ["proof (prove)\nusing this:\n  is_suffix \\<beta> b \\<or> is_proper_suffix b \\<beta>\n  is_proper_suffix b \\<beta> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. is_suffix \\<beta> b", "by blast"], ["proof (state)\nthis:\n  is_suffix \\<beta> b\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from is_prefix"], ["proof (chain)\npicking this:\n  is_prefix \\<alpha> a", "have \"\\<exists> u. a = \\<alpha> @ u\""], ["proof (prove)\nusing this:\n  is_prefix \\<alpha> a\n\ngoal (1 subgoal):\n 1. \\<exists>u. a = \\<alpha> @ u", "by (auto simp add: is_prefix_def)"], ["proof (state)\nthis:\n  \\<exists>u. a = \\<alpha> @ u\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. a = \\<alpha> @ u", "obtain u where u: \"a = \\<alpha> @ u\""], ["proof (prove)\nusing this:\n  \\<exists>u. a = \\<alpha> @ u\n\ngoal (1 subgoal):\n 1. (\\<And>u. a = \\<alpha> @ u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = \\<alpha> @ u\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from is_suffix"], ["proof (chain)\npicking this:\n  is_suffix \\<beta> b", "have \"\\<exists> v. b = v @ \\<beta>\""], ["proof (prove)\nusing this:\n  is_suffix \\<beta> b\n\ngoal (1 subgoal):\n 1. \\<exists>v. b = v @ \\<beta>", "by (auto simp add: is_suffix_def)"], ["proof (state)\nthis:\n  \\<exists>v. b = v @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. b = v @ \\<beta>", "obtain v where v: \"b = v @ \\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>v. b = v @ \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>v. b = v @ \\<beta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b = v @ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from u v splits_at_combine[OF split] aXb"], ["proof (chain)\npicking this:\n  a = \\<alpha> @ u\n  b = v @ \\<beta>\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)", "have D:\"LeftDerives1 (\\<alpha>@[N]@\\<beta>) i r (\\<alpha>@(u@[X]@v)@\\<beta>)\""], ["proof (prove)\nusing this:\n  a = \\<alpha> @ u\n  b = v @ \\<beta>\n  \\<delta> = \\<alpha> @ [N] @ \\<beta>\n  LeftDerives1 \\<delta> i r (a @ [X] @ b)\n\ngoal (1 subgoal):\n 1. LeftDerives1 (\\<alpha> @ [N] @ \\<beta>) i r\n     (\\<alpha> @ (u @ [X] @ v) @ \\<beta>)", "by simp"], ["proof (state)\nthis:\n  LeftDerives1 (\\<alpha> @ [N] @ \\<beta>) i r\n   (\\<alpha> @ (u @ [X] @ v) @ \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from splits_at_\\<alpha>[OF aXb_old split]"], ["proof (chain)\npicking this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i", "have i: \"length \\<alpha> = i\""], ["proof (prove)\nusing this:\n  \\<alpha> = take i \\<delta> \\<and>\n  \\<alpha> = take i (a @ [X] @ b) \\<and> length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. length \\<alpha> = i", "by blast"], ["proof (state)\nthis:\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "from i"], ["proof (chain)\npicking this:\n  length \\<alpha> = i", "have i1: \"length \\<alpha> \\<le> i\" and i2: \"i \\<le> length \\<alpha>\""], ["proof (prove)\nusing this:\n  length \\<alpha> = i\n\ngoal (1 subgoal):\n 1. length \\<alpha> \\<le> i &&& i \\<le> length \\<alpha>", "by auto"], ["proof (state)\nthis:\n  length \\<alpha> \\<le> i\n  i \\<le> length \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "note LeftDerives1_skip_suffix[OF _ LeftDerives1_skip_prefix[OF i1 D], simplified, OF i2]"], ["proof (state)\nthis:\n  LeftDerives1 [N] 0 r (u @ X # v)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 [N] 0 r (u @ X # v)", "have \"LeftDerives1 [N] 0 r (u @ [X] @ v)\""], ["proof (prove)\nusing this:\n  LeftDerives1 [N] 0 r (u @ X # v)\n\ngoal (1 subgoal):\n 1. LeftDerives1 [N] 0 r (u @ [X] @ v)", "by auto"], ["proof (state)\nthis:\n  LeftDerives1 [N] 0 r (u @ [X] @ v)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 [N] 0 r (u @ [X] @ v)", "have \"Derives1 [N] 0 r (u @ [X] @ v)\""], ["proof (prove)\nusing this:\n  LeftDerives1 [N] 0 r (u @ [X] @ v)\n\ngoal (1 subgoal):\n 1. Derives1 [N] 0 r (u @ [X] @ v)", "using LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 [N] 0 r (u @ [X] @ v)\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. Derives1 [N] 0 r (u @ [X] @ v)", "by auto"], ["proof (state)\nthis:\n  Derives1 [N] 0 r (u @ [X] @ v)\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "then"], ["proof (chain)\npicking this:\n  Derives1 [N] 0 r (u @ [X] @ v)", "have r: \"snd r = u @ [X] @ v\""], ["proof (prove)\nusing this:\n  Derives1 [N] 0 r (u @ [X] @ v)\n\ngoal (1 subgoal):\n 1. snd r = u @ [X] @ v", "by (metis Derives1_split append_Cons append_Nil length_0_conv list.inject self_append_conv)"], ["proof (state)\nthis:\n  snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "using u v r"], ["proof (prove)\nusing this:\n  a = \\<alpha> @ u\n  b = v @ \\<beta>\n  snd r = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v", "by auto"], ["proof (state)\nthis:\n  \\<exists>u v.\n     a = \\<alpha> @ u \\<and> b = v @ \\<beta> \\<and> snd r = u @ [X] @ v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFix_grow_suffix:\n  assumes LDF: \"LeftDerivationFix (b1@[X]@b2) (length b1) D j c\"\n  assumes suffix_b2: \"LeftDerives1 suffix e r b2\"\n  assumes is_word_b1X: \"is_word (b1@[X])\"\n  shows \"LeftDerivationFix (b1@[X]@suffix) (length b1) ((e + length (b1@[X]), r)#D) j c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "from LDF"], ["proof (chain)\npicking this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c", "have LDF': \"is_sentence (b1@[X]@b2) \\<and> is_sentence c \\<and> \n    LeftDerivation (b1 @ [X] @ b2) D c \\<and> length b1 < length (b1 @ [X] @ b2) \\<and>\n    j < length c \\<and>\n    (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n    (\\<exists>E F. D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c))\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c\n\ngoal (1 subgoal):\n 1. is_sentence (b1 @ [X] @ b2) \\<and>\n    is_sentence c \\<and>\n    LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n    length b1 < length (b1 @ [X] @ b2) \\<and>\n    j < length c \\<and>\n    (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n    (\\<exists>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E\n         (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n         (drop (Suc j) c))", "using LeftDerivationFix_def"], ["proof (prove)\nusing this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n\ngoal (1 subgoal):\n 1. is_sentence (b1 @ [X] @ b2) \\<and>\n    is_sentence c \\<and>\n    LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n    length b1 < length (b1 @ [X] @ b2) \\<and>\n    j < length c \\<and>\n    (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n    (\\<exists>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E\n         (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n         (drop (Suc j) c))", "by blast"], ["proof (state)\nthis:\n  is_sentence (b1 @ [X] @ b2) \\<and>\n  is_sentence c \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "then"], ["proof (chain)\npicking this:\n  is_sentence (b1 @ [X] @ b2) \\<and>\n  is_sentence c \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))", "obtain E F where EF: \"D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\""], ["proof (prove)\nusing this:\n  is_sentence (b1 @ [X] @ b2) \\<and>\n  is_sentence c \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E\n         (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n         (drop (Suc j) c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "then"], ["proof (chain)\npicking this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)", "have LD_b1_c: \"LeftDerivation b1 E (take j c)\""], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n\ngoal (1 subgoal):\n 1. LeftDerivation b1 E (take j c)", "by simp"], ["proof (state)\nthis:\n  LeftDerivation b1 E (take j c)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "with is_word_b1X"], ["proof (chain)\npicking this:\n  is_word (b1 @ [X])\n  LeftDerivation b1 E (take j c)", "have E: \"E = []\""], ["proof (prove)\nusing this:\n  is_word (b1 @ [X])\n  LeftDerivation b1 E (take j c)\n\ngoal (1 subgoal):\n 1. E = []", "using LeftDerivation_implies_Derivation is_word_Derivation is_word_append"], ["proof (prove)\nusing this:\n  is_word (b1 @ [X])\n  LeftDerivation b1 E (take j c)\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  \\<lbrakk>is_word ?a; Derivation ?a ?D ?b\\<rbrakk>\n  \\<Longrightarrow> ?D = []\n  is_word (?a @ ?b) = (is_word ?a \\<and> is_word ?b)\n\ngoal (1 subgoal):\n 1. E = []", "by blast"], ["proof (state)\nthis:\n  E = []\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "then"], ["proof (chain)\npicking this:\n  E = []", "have b1_def: \"b1 = take j c\""], ["proof (prove)\nusing this:\n  E = []\n\ngoal (1 subgoal):\n 1. b1 = take j c", "using LD_b1_c"], ["proof (prove)\nusing this:\n  E = []\n  LeftDerivation b1 E (take j c)\n\ngoal (1 subgoal):\n 1. b1 = take j c", "by auto"], ["proof (state)\nthis:\n  b1 = take j c\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "then"], ["proof (chain)\npicking this:\n  b1 = take j c", "have b1_len: \"j = length b1\""], ["proof (prove)\nusing this:\n  b1 = take j c\n\ngoal (1 subgoal):\n 1. j = length b1", "by (simp add: LDF' dual_order.strict_implies_order min.absorb2)"], ["proof (state)\nthis:\n  j = length b1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "have D: \"D = derivation_shift F 0 (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = derivation_shift F 0 (Suc j)", "using EF E"], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n  E = []\n\ngoal (1 subgoal):\n 1. D = derivation_shift F 0 (Suc j)", "by simp"], ["proof (state)\nthis:\n  D = derivation_shift F 0 (Suc j)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "have step: \"LeftDerives1 (b1 @ [X] @ suffix) (Suc (e + length b1)) r (b1 @ [X] @ b2) \\<and> \n    LeftDerivation  (b1 @ [X] @ b2) D c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 (b1 @ [X] @ suffix) (Suc (e + length b1)) r\n     (b1 @ [X] @ b2) \\<and>\n    LeftDerivation (b1 @ [X] @ b2) D c", "by (metis LDF' LeftDerives1_append_prefix add_Suc_right append_assoc assms(2) is_word_b1X \n      length_append_singleton)"], ["proof (state)\nthis:\n  LeftDerives1 (b1 @ [X] @ suffix) (Suc (e + length b1)) r\n   (b1 @ [X] @ b2) \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 (b1 @ [X] @ suffix) (Suc (e + length b1)) r\n   (b1 @ [X] @ b2) \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c", "have is_sentence_b1Xsuffix: \"is_sentence (b1 @ [X] @ suffix)\""], ["proof (prove)\nusing this:\n  LeftDerives1 (b1 @ [X] @ suffix) (Suc (e + length b1)) r\n   (b1 @ [X] @ b2) \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c\n\ngoal (1 subgoal):\n 1. is_sentence (b1 @ [X] @ suffix)", "using Derives1_sentence1 LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 (b1 @ [X] @ suffix) (Suc (e + length b1)) r\n   (b1 @ [X] @ b2) \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> is_sentence ?a\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. is_sentence (b1 @ [X] @ suffix)", "by blast"], ["proof (state)\nthis:\n  is_sentence (b1 @ [X] @ suffix)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "have X_eq_cj: \"X = c ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = c ! j", "using LDF'"], ["proof (prove)\nusing this:\n  is_sentence (b1 @ [X] @ b2) \\<and>\n  is_sentence c \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (1 subgoal):\n 1. X = c ! j", "by auto"], ["proof (state)\nthis:\n  X = c ! j\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n     ((e + length (b1 @ [X]), r) # D) j c", "apply (simp add: LeftDerivationFix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence (b1 @ X # suffix) \\<and>\n    is_sentence c \\<and>\n    (\\<exists>x.\n        LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_sentence (b1 @ X # suffix)\n 2. is_sentence c \\<and>\n    (\\<exists>x.\n        LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "using is_sentence_b1Xsuffix"], ["proof (prove)\nusing this:\n  is_sentence (b1 @ [X] @ suffix)\n\ngoal (2 subgoals):\n 1. is_sentence (b1 @ X # suffix)\n 2. is_sentence c \\<and>\n    (\\<exists>x.\n        LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence c \\<and>\n    (\\<exists>x.\n        LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_sentence c\n 2. (\\<exists>x.\n        LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "using LDF'"], ["proof (prove)\nusing this:\n  is_sentence (b1 @ [X] @ b2) \\<and>\n  is_sentence c \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (2 subgoals):\n 1. is_sentence c\n 2. (\\<exists>x.\n        LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n       LeftDerivation x D c\n 2. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "using step"], ["proof (prove)\nusing this:\n  LeftDerives1 (b1 @ [X] @ suffix) (Suc (e + length b1)) r\n   (b1 @ [X] @ b2) \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 (b1 @ X # suffix) (Suc (e + length b1)) r x \\<and>\n       LeftDerivation x D c\n 2. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < length c\n 2. X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "using LDF'"], ["proof (prove)\nusing this:\n  is_sentence (b1 @ [X] @ b2) \\<and>\n  is_sentence c \\<and>\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (2 subgoals):\n 1. j < length c\n 2. X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. X = c ! j \\<and>\n    (\\<exists>E F.\n        (Suc (e + length b1), r) # D =\n        E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation b1 E (take j c) \\<and>\n        LeftDerivation suffix F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. X = c ! j\n 2. \\<exists>E F.\n       (Suc (e + length b1), r) # D =\n       E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation b1 E (take j c) \\<and>\n       LeftDerivation suffix F (drop (Suc j) c)", "apply (rule X_eq_cj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F.\n       (Suc (e + length b1), r) # D =\n       E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation b1 E (take j c) \\<and>\n       LeftDerivation suffix F (drop (Suc j) c)", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F.\n       (Suc (e + length b1), r) # D =\n       [] @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation b1 [] (take j c) \\<and>\n       LeftDerivation suffix F (drop (Suc j) c)", "apply (rule_tac x=\"(e, r)#F\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc (e + length b1), r) # D =\n    [] @ derivation_shift ((e, r) # F) 0 (Suc j) \\<and>\n    LeftDerivation b1 [] (take j c) \\<and>\n    LeftDerivation suffix ((e, r) # F) (drop (Suc j) c)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. length b1 = j\n 2. D = derivation_shift F 0 (Suc j)\n 3. b1 = take j c\n 4. \\<exists>x.\n       LeftDerives1 suffix e r x \\<and> LeftDerivation x F (drop (Suc j) c)", "apply (rule b1_len[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. D = derivation_shift F 0 (Suc j)\n 2. b1 = take j c\n 3. \\<exists>x.\n       LeftDerives1 suffix e r x \\<and> LeftDerivation x F (drop (Suc j) c)", "apply (rule D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b1 = take j c\n 2. \\<exists>x.\n       LeftDerives1 suffix e r x \\<and> LeftDerivation x F (drop (Suc j) c)", "apply (rule b1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       LeftDerives1 suffix e r x \\<and> LeftDerivation x F (drop (Suc j) c)", "apply (rule_tac x=\"b2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 suffix e r b2 \\<and> LeftDerivation b2 F (drop (Suc j) c)", "apply (simp add: suffix_b2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation b2 F (drop (Suc j) c)", "using EF"], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n\ngoal (1 subgoal):\n 1. LeftDerivation b2 F (drop (Suc j) c)", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix (b1 @ [X] @ suffix) (length b1)\n   ((e + length (b1 @ [X]), r) # D) j c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Derives1_append_suffix: \n  assumes Derives1: \"Derives1 v i r w\"\n  assumes u: \"is_sentence u\"\n  shows \"Derives1 (v@u) i r (w@u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "have \"\\<exists> \\<alpha> N \\<beta>. splits_at v i \\<alpha> N \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha> N \\<beta>. splits_at v i \\<alpha> N \\<beta>", "using assms splits_at_ex"], ["proof (prove)\nusing this:\n  Derives1 v i r w\n  is_sentence u\n  Derives1 ?\\<delta> ?i ?r ?s \\<Longrightarrow>\n  \\<exists>\\<alpha> N \\<beta>. splits_at ?\\<delta> ?i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha> N \\<beta>. splits_at v i \\<alpha> N \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<alpha> N \\<beta>. splits_at v i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha> N \\<beta>. splits_at v i \\<alpha> N \\<beta>", "obtain \\<alpha> N \\<beta> where split_v: \"splits_at v i \\<alpha> N \\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha> N \\<beta>. splits_at v i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> N \\<beta>.\n        splits_at v i \\<alpha> N \\<beta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at v i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "have split_w: \"w = \\<alpha>@(snd r)@\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = \\<alpha> @ snd r @ \\<beta>", "using assms split_v splits_at_combine_dest"], ["proof (prove)\nusing this:\n  Derives1 v i r w\n  is_sentence u\n  splits_at v i \\<alpha> N \\<beta>\n  \\<lbrakk>Derives1 ?a ?i ?r ?b;\n   splits_at ?a ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?b = ?\\<alpha> @ snd ?r @ ?\\<beta>\n\ngoal (1 subgoal):\n 1. w = \\<alpha> @ snd r @ \\<beta>", "by blast"], ["proof (state)\nthis:\n  w = \\<alpha> @ snd r @ \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "have split_uv: \"splits_at (v@u) i \\<alpha> N (\\<beta>@u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_at (v @ u) i \\<alpha> N (\\<beta> @ u)", "by (simp add: split_v splits_at_append)"], ["proof (state)\nthis:\n  splits_at (v @ u) i \\<alpha> N (\\<beta> @ u)\n\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "have is_sentence_uv: \"is_sentence (v@u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence (v @ u)", "using Derives1 Derives1_sentence1 is_sentence_concat u"], ["proof (prove)\nusing this:\n  Derives1 v i r w\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> is_sentence ?a\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  is_sentence u\n\ngoal (1 subgoal):\n 1. is_sentence (v @ u)", "by blast"], ["proof (state)\nthis:\n  is_sentence (v @ u)\n\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "by (metis Derives1 Derives1_nonterminal Derives1_rule append_assoc is_sentence_uv \n        split_uv split_v split_w splits_at_implies_Derives1)"], ["proof (state)\nthis:\n  Derives1 (v @ u) i r (w @ u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leftmost_append_suffix: \"leftmost i v \\<Longrightarrow> leftmost i (v@u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leftmost i v \\<Longrightarrow> leftmost i (v @ u)", "by (simp add: leftmost_def nth_append)"], ["", "lemma LeftDerives1_append_suffix: \n  assumes Derives1: \"LeftDerives1 v i r w\"\n  assumes u: \"is_sentence u\"\n  shows \"LeftDerives1 (v@u) i r (w@u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "have 1: \"Derives1 v i r w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 v i r w", "by (simp add: Derives1 LeftDerives1_implies_Derives1)"], ["proof (state)\nthis:\n  Derives1 v i r w\n\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "have 2: \"leftmost i v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leftmost i v", "using Derives1 LeftDerives1_def"], ["proof (prove)\nusing this:\n  LeftDerives1 v i r w\n  LeftDerives1 ?u ?i ?r ?v = (leftmost ?i ?u \\<and> Derives1 ?u ?i ?r ?v)\n\ngoal (1 subgoal):\n 1. leftmost i v", "by blast"], ["proof (state)\nthis:\n  leftmost i v\n\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "have 3: \"is_sentence u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence u", "using u"], ["proof (prove)\nusing this:\n  is_sentence u\n\ngoal (1 subgoal):\n 1. is_sentence u", "by fastforce"], ["proof (state)\nthis:\n  is_sentence u\n\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "have 4: \"Derives1 (v@u) i r (w@u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 (v @ u) i r (w @ u)", "by (simp add: \"1\" \"3\" Derives1_append_suffix)"], ["proof (state)\nthis:\n  Derives1 (v @ u) i r (w @ u)\n\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "have 5: \"leftmost i (v@u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leftmost i (v @ u)", "by (simp add: \"2\" leftmost_append_suffix u)"], ["proof (state)\nthis:\n  leftmost i (v @ u)\n\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 (v @ u) i r (w @ u)", "by (simp add: \"4\" \"5\" LeftDerives1_def)"], ["proof (state)\nthis:\n  LeftDerives1 (v @ u) i r (w @ u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFix_is_sentence: \n  \"LeftDerivationFix a i D j b \\<Longrightarrow> is_sentence a \\<and> is_sentence b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix a i D j b \\<Longrightarrow>\n    is_sentence a \\<and> is_sentence b", "using LeftDerivationFix_def"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n\ngoal (1 subgoal):\n 1. LeftDerivationFix a i D j b \\<Longrightarrow>\n    is_sentence a \\<and> is_sentence b", "by blast"], ["", "lemma LeftDerivationIntro_is_sentence:\n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow> is_sentence \\<alpha> \\<and> is_sentence \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow>\n    is_sentence \\<alpha> \\<and> is_sentence \\<gamma>", "by (meson Derives1_sentence1 LeftDerivationFix_is_sentence LeftDerivationIntro_def \n    LeftDerives1_implies_Derives1)"], ["", "lemma LeftDerivationFix_grow_prefix:\n  assumes LDF: \"LeftDerivationFix (b1@[X]@b2) (length b1) D j c\"\n  assumes prefix_b1: \"LeftDerives1 prefix e r b1\"\n  shows \"LeftDerivationFix (prefix@[X]@b2) (length prefix) ((e, r)#D) j c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "from LDF"], ["proof (chain)\npicking this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c", "have LDF': \"LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n    length b1 < length (b1 @ [X] @ b2) \\<and>\n    j < length c \\<and>\n    (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n    (\\<exists>E F. D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c))\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c\n\ngoal (1 subgoal):\n 1. LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n    length b1 < length (b1 @ [X] @ b2) \\<and>\n    j < length c \\<and>\n    (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n    (\\<exists>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E\n         (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n         (drop (Suc j) c))", "using LeftDerivationFix_def"], ["proof (prove)\nusing this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n\ngoal (1 subgoal):\n 1. LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n    length b1 < length (b1 @ [X] @ b2) \\<and>\n    j < length c \\<and>\n    (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n    (\\<exists>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E\n         (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n         (drop (Suc j) c))", "by blast"], ["proof (state)\nthis:\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))", "obtain E F where EF: \"D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\""], ["proof (prove)\nusing this:\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E\n         (take j c) \\<and>\n        LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n         (drop (Suc j) c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "then"], ["proof (chain)\npicking this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)", "have E_b1_c: \"LeftDerivation b1 E (take j c)\""], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n\ngoal (1 subgoal):\n 1. LeftDerivation b1 E (take j c)", "by simp"], ["proof (state)\nthis:\n  LeftDerivation b1 E (take j c)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "with EF"], ["proof (chain)\npicking this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n  LeftDerivation b1 E (take j c)", "have F_b2_c: \"LeftDerivation b2 F (drop (Suc j) c)\""], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n  LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F (drop (Suc j) c)\n  LeftDerivation b1 E (take j c)\n\ngoal (1 subgoal):\n 1. LeftDerivation b2 F (drop (Suc j) c)", "by simp"], ["proof (state)\nthis:\n  LeftDerivation b2 F (drop (Suc j) c)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "have step: \"LeftDerives1 (prefix @ [X] @ b2) e r (b1 @ [X] @ b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 (prefix @ [X] @ b2) e r (b1 @ [X] @ b2)", "using LDF LeftDerivationFix_is_sentence LeftDerives1_append_suffix \n      is_sentence_concat prefix_b1"], ["proof (prove)\nusing this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  \\<lbrakk>LeftDerives1 ?v ?i ?r ?w; is_sentence ?u\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 (?v @ ?u) ?i ?r (?w @ ?u)\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  LeftDerives1 prefix e r b1\n\ngoal (1 subgoal):\n 1. LeftDerives1 (prefix @ [X] @ b2) e r (b1 @ [X] @ b2)", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (prefix @ [X] @ b2) e r (b1 @ [X] @ b2)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c", "apply (simp add: LeftDerivationFix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence (prefix @ X # b2) \\<and>\n    is_sentence c \\<and>\n    (\\<exists>x.\n        LeftDerives1 (prefix @ X # b2) e r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_sentence (prefix @ X # b2)\n 2. is_sentence c \\<and>\n    (\\<exists>x.\n        LeftDerives1 (prefix @ X # b2) e r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply (metis Derives1_sentence1 LDF LeftDerivationFix_def LeftDerives1_implies_Derives1 \n      is_sentence_concat is_sentence_cons prefix_b1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence c \\<and>\n    (\\<exists>x.\n        LeftDerives1 (prefix @ X # b2) e r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_sentence c\n 2. (\\<exists>x.\n        LeftDerives1 (prefix @ X # b2) e r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "using LDF LeftDerivationFix_is_sentence"], ["proof (prove)\nusing this:\n  LeftDerivationFix (b1 @ [X] @ b2) (length b1) D j c\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n\ngoal (2 subgoals):\n 1. is_sentence c\n 2. (\\<exists>x.\n        LeftDerives1 (prefix @ X # b2) e r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        LeftDerives1 (prefix @ X # b2) e r x \\<and>\n        LeftDerivation x D c) \\<and>\n    j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 (prefix @ X # b2) e r x \\<and> LeftDerivation x D c\n 2. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply (rule_tac x=\"b1@[X]@b2\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerives1 (prefix @ X # b2) e r (b1 @ [X] @ b2) \\<and>\n    LeftDerivation (b1 @ [X] @ b2) D c\n 2. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "using step"], ["proof (prove)\nusing this:\n  LeftDerives1 (prefix @ [X] @ b2) e r (b1 @ [X] @ b2)\n\ngoal (2 subgoals):\n 1. LeftDerives1 (prefix @ X # b2) e r (b1 @ [X] @ b2) \\<and>\n    LeftDerivation (b1 @ [X] @ b2) D c\n 2. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerives1 (prefix @ X # b2) e r (b1 @ X # b2) \\<Longrightarrow>\n    LeftDerivation (b1 @ X # b2) D c\n 2. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "using LDF'"], ["proof (prove)\nusing this:\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (2 subgoals):\n 1. LeftDerives1 (prefix @ X # b2) e r (b1 @ X # b2) \\<Longrightarrow>\n    LeftDerivation (b1 @ X # b2) D c\n 2. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length c \\<and>\n    X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < length c\n 2. X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "using LDF'"], ["proof (prove)\nusing this:\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (2 subgoals):\n 1. j < length c\n 2. X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. X = c ! j \\<and>\n    (\\<exists>E F.\n        (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation prefix E (take j c) \\<and>\n        LeftDerivation b2 F (drop (Suc j) c))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. X = c ! j\n 2. \\<exists>E F.\n       (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation prefix E (take j c) \\<and>\n       LeftDerivation b2 F (drop (Suc j) c)", "using LDF'"], ["proof (prove)\nusing this:\n  LeftDerivation (b1 @ [X] @ b2) D c \\<and>\n  length b1 < length (b1 @ [X] @ b2) \\<and>\n  j < length c \\<and>\n  (b1 @ [X] @ b2) ! length b1 = c ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take (length b1) (b1 @ [X] @ b2)) E (take j c) \\<and>\n      LeftDerivation (drop (Suc (length b1)) (b1 @ [X] @ b2)) F\n       (drop (Suc j) c))\n\ngoal (2 subgoals):\n 1. X = c ! j\n 2. \\<exists>E F.\n       (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation prefix E (take j c) \\<and>\n       LeftDerivation b2 F (drop (Suc j) c)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F.\n       (e, r) # D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation prefix E (take j c) \\<and>\n       LeftDerivation b2 F (drop (Suc j) c)", "apply (rule_tac x=\"(e,r)#E\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F.\n       (e, r) # D = ((e, r) # E) @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation prefix ((e, r) # E) (take j c) \\<and>\n       LeftDerivation b2 F (drop (Suc j) c)", "apply (rule_tac x=\"F\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, r) # D = ((e, r) # E) @ derivation_shift F 0 (Suc j) \\<and>\n    LeftDerivation prefix ((e, r) # E) (take j c) \\<and>\n    LeftDerivation b2 F (drop (Suc j) c)", "apply (auto simp add: EF F_b2_c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       LeftDerives1 prefix e r x \\<and> LeftDerivation x E (take j c)", "apply (rule_tac x=\"b1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 prefix e r b1 \\<and> LeftDerivation b1 E (take j c)", "apply (simp add: prefix_b1 E_b1_c)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LeftDerivationFix (prefix @ [X] @ b2) (length prefix) ((e, r) # D) j c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFixOrIntro: \n  \"LeftDerivation a D \\<gamma> \\<Longrightarrow> is_sentence \\<gamma> \\<Longrightarrow> j < length \\<gamma> \\<Longrightarrow>\n  (\\<exists> i. LeftDerivationFix a i D j \\<gamma>) \\<or> \n  (\\<exists> d \\<alpha> ix. d < length D \\<and> LeftDerivation a (take d D) \\<alpha> \\<and> \n    LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n     j < length \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n                      (\\<exists>d \\<alpha> ix.\n                          d < length D \\<and>\n                          LeftDerivation a (take d D) \\<alpha> \\<and>\n                          LeftDerivationIntro \\<alpha> (fst (D ! d))\n                           (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "proof (induct \"length D\" arbitrary: a D \\<gamma> j rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D a \\<gamma> j.\n       \\<lbrakk>\\<And>Da a \\<gamma> j.\n                   \\<lbrakk>length Da < length D;\n                    LeftDerivation a Da \\<gamma>; is_sentence \\<gamma>;\n                    j < length \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>i.\n   LeftDerivationFix a i Da j \\<gamma>) \\<or>\n                                     (\\<exists>d \\<alpha> ix.\n   d < length Da \\<and>\n   LeftDerivation a (take d Da) \\<alpha> \\<and>\n   LeftDerivationIntro \\<alpha> (fst (Da ! d)) (snd (Da ! d)) ix\n    (drop (Suc d) Da) j \\<gamma>);\n        LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n        j < length \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "(* The induction here is unnecessary, but we use it anyway for context reasons *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D a \\<gamma> j.\n       \\<lbrakk>\\<And>Da a \\<gamma> j.\n                   \\<lbrakk>length Da < length D;\n                    LeftDerivation a Da \\<gamma>; is_sentence \\<gamma>;\n                    j < length \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>i.\n   LeftDerivationFix a i Da j \\<gamma>) \\<or>\n                                     (\\<exists>d \\<alpha> ix.\n   d < length Da \\<and>\n   LeftDerivation a (take d Da) \\<alpha> \\<and>\n   LeftDerivationIntro \\<alpha> (fst (Da ! d)) (snd (Da ! d)) ix\n    (drop (Suc d) Da) j \\<gamma>);\n        LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n        j < length \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>length ?D < length D; LeftDerivation ?a ?D ?\\<gamma>;\n   is_sentence ?\\<gamma>; ?j < length ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>i.\n                        LeftDerivationFix ?a i ?D ?j ?\\<gamma>) \\<or>\n                    (\\<exists>d \\<alpha> ix.\n                        d < length ?D \\<and>\n                        LeftDerivation ?a (take d ?D) \\<alpha> \\<and>\n                        LeftDerivationIntro \\<alpha> (fst (?D ! d))\n                         (snd (?D ! d)) ix (drop (Suc d) ?D) ?j ?\\<gamma>)\n  LeftDerivation a D \\<gamma>\n  is_sentence \\<gamma>\n  j < length \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>D a \\<gamma> j.\n       \\<lbrakk>\\<And>Da a \\<gamma> j.\n                   \\<lbrakk>length Da < length D;\n                    LeftDerivation a Da \\<gamma>; is_sentence \\<gamma>;\n                    j < length \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>i.\n   LeftDerivationFix a i Da j \\<gamma>) \\<or>\n                                     (\\<exists>d \\<alpha> ix.\n   d < length Da \\<and>\n   LeftDerivation a (take d Da) \\<alpha> \\<and>\n   LeftDerivationIntro \\<alpha> (fst (Da ! d)) (snd (Da ! d)) ix\n    (drop (Suc d) Da) j \\<gamma>);\n        LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n        j < length \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "have \"length D = 0 \\<or> length D \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length D = 0 \\<or> length D \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  length D = 0 \\<or> length D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>D a \\<gamma> j.\n       \\<lbrakk>\\<And>Da a \\<gamma> j.\n                   \\<lbrakk>length Da < length D;\n                    LeftDerivation a Da \\<gamma>; is_sentence \\<gamma>;\n                    j < length \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>i.\n   LeftDerivationFix a i Da j \\<gamma>) \\<or>\n                                     (\\<exists>d \\<alpha> ix.\n   d < length Da \\<and>\n   LeftDerivation a (take d Da) \\<alpha> \\<and>\n   LeftDerivationIntro \\<alpha> (fst (Da ! d)) (snd (Da ! d)) ix\n    (drop (Suc d) Da) j \\<gamma>);\n        LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n        j < length \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  length D = 0 \\<or> length D \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  length D = 0 \\<or> length D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. length D = 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)\n 2. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "case 1"], ["proof (state)\nthis:\n  length D = 0\n\ngoal (2 subgoals):\n 1. length D = 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)\n 2. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  length D = 0", "have D: \"D = []\""], ["proof (prove)\nusing this:\n  length D = 0\n\ngoal (1 subgoal):\n 1. D = []", "by auto"], ["proof (state)\nthis:\n  D = []\n\ngoal (2 subgoals):\n 1. length D = 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)\n 2. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?D < length D; LeftDerivation ?a ?D ?\\<gamma>;\n   is_sentence ?\\<gamma>; ?j < length ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>i.\n                        LeftDerivationFix ?a i ?D ?j ?\\<gamma>) \\<or>\n                    (\\<exists>d \\<alpha> ix.\n                        d < length ?D \\<and>\n                        LeftDerivation ?a (take d ?D) \\<alpha> \\<and>\n                        LeftDerivationIntro \\<alpha> (fst (?D ! d))\n                         (snd (?D ! d)) ix (drop (Suc d) ?D) ?j ?\\<gamma>)\n  LeftDerivation a D \\<gamma>\n  is_sentence \\<gamma>\n  j < length \\<gamma>\n  D = []", "have \"\\<exists>i. LeftDerivationFix a i D j \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?D < length D; LeftDerivation ?a ?D ?\\<gamma>;\n   is_sentence ?\\<gamma>; ?j < length ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>i.\n                        LeftDerivationFix ?a i ?D ?j ?\\<gamma>) \\<or>\n                    (\\<exists>d \\<alpha> ix.\n                        d < length ?D \\<and>\n                        LeftDerivation ?a (take d ?D) \\<alpha> \\<and>\n                        LeftDerivationIntro \\<alpha> (fst (?D ! d))\n                         (snd (?D ! d)) ix (drop (Suc d) ?D) ?j ?\\<gamma>)\n  LeftDerivation a D \\<gamma>\n  is_sentence \\<gamma>\n  j < length \\<gamma>\n  D = []\n\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix a i D j \\<gamma>", "apply (rule_tac x=j in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D a \\<gamma> j.\n                \\<lbrakk>length D < length D; LeftDerivation a D \\<gamma>;\n                 is_sentence \\<gamma>; j < length \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> (\\<exists>i.\nLeftDerivationFix a i D j \\<gamma>) \\<or>\n                                  (\\<exists>d \\<alpha> ix.\nd < length D \\<and>\nLeftDerivation a (take d D) \\<alpha> \\<and>\nLeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix (drop (Suc d) D)\n j \\<gamma>);\n     LeftDerivation a D \\<gamma>; is_sentence \\<gamma>; j < length \\<gamma>;\n     D = []\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationFix a j D j \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. LeftDerivationFix a i D j \\<gamma>\n\ngoal (2 subgoals):\n 1. length D = 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)\n 2. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. LeftDerivationFix a i D j \\<gamma>", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>i. LeftDerivationFix a i D j \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)\n\ngoal (1 subgoal):\n 1. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "case 2"], ["proof (state)\nthis:\n  length D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "note less2 = 2"], ["proof (state)\nthis:\n  length D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "have \"\\<exists> n \\<beta> i. n \\<le> length D \\<and> \\<beta> = Derive a (take n D) \\<and> LeftDerivationFix \\<beta> i (drop n D) j \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n \\<beta> i.\n       n \\<le> length D \\<and>\n       \\<beta> = Derive a (take n D) \\<and>\n       LeftDerivationFix \\<beta> i (drop n D) j \\<gamma>", "apply (rule_tac x=\"length D\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta> i.\n       length D \\<le> length D \\<and>\n       \\<beta> = Derive a (take (length D) D) \\<and>\n       LeftDerivationFix \\<beta> i (drop (length D) D) j \\<gamma>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix (Derive a D) i [] j \\<gamma>", "using Derive LeftDerivationFix_empty LeftDerivation_implies_Derivation less"], ["proof (prove)\nusing this:\n  Derivation ?a ?D ?b \\<Longrightarrow> Derive ?a ?D = ?b\n  \\<lbrakk>is_sentence ?\\<alpha>; ?i < length ?\\<alpha>\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationFix ?\\<alpha> ?i [] ?i ?\\<alpha>\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  \\<lbrakk>length ?D < length D; LeftDerivation ?a ?D ?\\<gamma>;\n   is_sentence ?\\<gamma>; ?j < length ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>i.\n                        LeftDerivationFix ?a i ?D ?j ?\\<gamma>) \\<or>\n                    (\\<exists>d \\<alpha> ix.\n                        d < length ?D \\<and>\n                        LeftDerivation ?a (take d ?D) \\<alpha> \\<and>\n                        LeftDerivationIntro \\<alpha> (fst (?D ! d))\n                         (snd (?D ! d)) ix (drop (Suc d) ?D) ?j ?\\<gamma>)\n  LeftDerivation a D \\<gamma>\n  is_sentence \\<gamma>\n  j < length \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix (Derive a D) i [] j \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<exists>n \\<beta> i.\n     n \\<le> length D \\<and>\n     \\<beta> = Derive a (take n D) \\<and>\n     LeftDerivationFix \\<beta> i (drop n D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. length D \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n \\<beta> i.\n     n \\<le> length D \\<and>\n     \\<beta> = Derive a (take n D) \\<and>\n     LeftDerivationFix \\<beta> i (drop n D) j \\<gamma>", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>n \\<beta> i.\n     n \\<le> length D \\<and>\n     \\<beta> = Derive a (take n D) \\<and>\n     LeftDerivationFix \\<beta> i (drop n D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "proof (induct rule: ex_minimal_witness)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>\\<exists>\\<beta> i.\n                   K \\<le> length D \\<and>\n                   \\<beta> = Derive a (take K D) \\<and>\n                   LeftDerivationFix \\<beta> i (drop K D) j \\<gamma>;\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>\\<beta> i.\n              k \\<le> length D \\<and>\n              \\<beta> = Derive a (take k D) \\<and>\n              LeftDerivationFix \\<beta> i (drop k D) j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "case (Minimal N)"], ["proof (state)\nthis:\n  \\<exists>\\<beta> i.\n     N \\<le> length D \\<and>\n     \\<beta> = Derive a (take N D) \\<and>\n     LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  ?k < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     ?k \\<le> length D \\<and>\n     \\<beta> = Derive a (take ?k D) \\<and>\n     LeftDerivationFix \\<beta> i (drop ?k D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>\\<exists>\\<beta> i.\n                   K \\<le> length D \\<and>\n                   \\<beta> = Derive a (take K D) \\<and>\n                   LeftDerivationFix \\<beta> i (drop K D) j \\<gamma>;\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>\\<beta> i.\n              k \\<le> length D \\<and>\n              \\<beta> = Derive a (take k D) \\<and>\n              LeftDerivationFix \\<beta> i (drop k D) j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta> i.\n     N \\<le> length D \\<and>\n     \\<beta> = Derive a (take N D) \\<and>\n     LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  ?k < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     ?k \\<le> length D \\<and>\n     \\<beta> = Derive a (take ?k D) \\<and>\n     LeftDerivationFix \\<beta> i (drop ?k D) j \\<gamma>", "obtain \\<beta> i where Minimal_N:\n        \"N \\<le> length D \\<and> \\<beta> = Derive a (take N D) \\<and> LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta> i.\n     N \\<le> length D \\<and>\n     \\<beta> = Derive a (take N D) \\<and>\n     LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  ?k < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     ?k \\<le> length D \\<and>\n     \\<beta> = Derive a (take ?k D) \\<and>\n     LeftDerivationFix \\<beta> i (drop ?k D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta> i.\n        N \\<le> length D \\<and>\n        \\<beta> = Derive a (take N D) \\<and>\n        LeftDerivationFix \\<beta> i (drop N D) j \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>\\<exists>\\<beta> i.\n                   K \\<le> length D \\<and>\n                   \\<beta> = Derive a (take K D) \\<and>\n                   LeftDerivationFix \\<beta> i (drop K D) j \\<gamma>;\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>\\<beta> i.\n              k \\<le> length D \\<and>\n              \\<beta> = Derive a (take k D) \\<and>\n              LeftDerivationFix \\<beta> i (drop k D) j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "have \"N = 0 \\<or> N \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = 0 \\<or> N \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  N = 0 \\<or> N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>K.\n       \\<lbrakk>\\<exists>\\<beta> i.\n                   K \\<le> length D \\<and>\n                   \\<beta> = Derive a (take K D) \\<and>\n                   LeftDerivationFix \\<beta> i (drop K D) j \\<gamma>;\n        \\<And>k.\n           k < K \\<Longrightarrow>\n           \\<nexists>\\<beta> i.\n              k \\<le> length D \\<and>\n              \\<beta> = Derive a (take k D) \\<and>\n              LeftDerivationFix \\<beta> i (drop k D) j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i.\n                             LeftDerivationFix a i D j \\<gamma>) \\<or>\n                         (\\<exists>d \\<alpha> ix.\n                             d < length D \\<and>\n                             LeftDerivation a (take d D) \\<alpha> \\<and>\n                             LeftDerivationIntro \\<alpha> (fst (D ! d))\n                              (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  N = 0 \\<or> N \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  N = 0 \\<or> N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. N = 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)\n 2. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "case 1"], ["proof (state)\nthis:\n  N = 0\n\ngoal (2 subgoals):\n 1. N = 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)\n 2. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "with Minimal_N"], ["proof (chain)\npicking this:\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  N = 0", "have \"\\<beta> = a\""], ["proof (prove)\nusing this:\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  N = 0\n\ngoal (1 subgoal):\n 1. \\<beta> = a", "by auto"], ["proof (state)\nthis:\n  \\<beta> = a\n\ngoal (2 subgoals):\n 1. N = 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)\n 2. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "with 1 Minimal_N"], ["proof (chain)\npicking this:\n  N = 0\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  \\<beta> = a", "show ?case"], ["proof (prove)\nusing this:\n  N = 0\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  \\<beta> = a\n\ngoal (1 subgoal):\n 1. (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "apply (rule_tac disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N = 0;\n     N \\<le> length D \\<and>\n     \\<beta> = Derive a (take N D) \\<and>\n     LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>;\n     \\<beta> = a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. LeftDerivationFix a i D j \\<gamma>", "by auto"], ["proof (state)\nthis:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "case 2"], ["proof (state)\nthis:\n  N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "let ?\\<delta> = \"Derive a (take (N - 1) D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "have LeftDerives1_\\<delta>: \"LeftDerives1 ?\\<delta> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) \\<beta>", "using \"2.hyps\" LeftDerivation_Derive_take_LeftDerives1 Minimal_N less.prems(1)"], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  \\<lbrakk>?N \\<noteq> 0; ?N \\<le> length ?D; LeftDerivation ?a ?D ?b;\n   ?\\<alpha> = Derive ?a (take (?N - 1) ?D);\n   ?\\<beta> = Derive ?a (take ?N ?D)\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 ?\\<alpha> (fst (?D ! (?N - 1)))\n                     (snd (?D ! (?N - 1))) ?\\<beta>\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  LeftDerivation a D \\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) \\<beta>", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>", "have Derives1_\\<delta>: \"Derives1 ?\\<delta> (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>\""], ["proof (prove)\nusing this:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) \\<beta>", "using LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. Derives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) \\<beta>", "by blast"], ["proof (state)\nthis:\n  Derives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "have i_len: \"i < length \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length \\<beta>", "using Minimal_N"], ["proof (prove)\nusing this:\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. i < length \\<beta>", "by (auto simp add: LeftDerivationFix_def)"], ["proof (state)\nthis:\n  i < length \\<beta>\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  i < length \\<beta>", "have \"\\<exists> X \\<beta>_1 \\<beta>_2. splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\""], ["proof (prove)\nusing this:\n  i < length \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>X \\<beta>_1 \\<beta>_2.\n       splits_at \\<beta> i \\<beta>_1 X \\<beta>_2", "using splits_at_def"], ["proof (prove)\nusing this:\n  i < length \\<beta>\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>X \\<beta>_1 \\<beta>_2.\n       splits_at \\<beta> i \\<beta>_1 X \\<beta>_2", "by blast"], ["proof (state)\nthis:\n  \\<exists>X \\<beta>_1 \\<beta>_2. splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>X \\<beta>_1 \\<beta>_2. splits_at \\<beta> i \\<beta>_1 X \\<beta>_2", "obtain X \\<beta>_1 \\<beta>_2 where \\<beta>_split: \"splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\""], ["proof (prove)\nusing this:\n  \\<exists>X \\<beta>_1 \\<beta>_2. splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>_1 X \\<beta>_2.\n        splits_at \\<beta> i \\<beta>_1 X \\<beta>_2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  splits_at \\<beta> i \\<beta>_1 X \\<beta>_2", "have \\<beta>_combine: \"\\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2\""], ["proof (prove)\nusing this:\n  splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\n\ngoal (1 subgoal):\n 1. \\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2", "using splits_at_combine"], ["proof (prove)\nusing this:\n  splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> \\<Longrightarrow>\n  ?\\<delta> = ?\\<alpha> @ [?N] @ ?\\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2", "by blast"], ["proof (state)\nthis:\n  \\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2", "have LeftDerives1_\\<delta>_hyp: \n          \"LeftDerives1 ?\\<delta> (fst (D ! (N - 1))) (snd (D ! (N - 1))) (\\<beta>_1 @ [X] @ \\<beta>_2)\""], ["proof (prove)\nusing this:\n  \\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2\n\ngoal (1 subgoal):\n 1. LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (\\<beta>_1 @ [X] @ \\<beta>_2)", "using LeftDerives1_\\<delta>"], ["proof (prove)\nusing this:\n  \\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (\\<beta>_1 @ [X] @ \\<beta>_2)", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) (\\<beta>_1 @ [X] @ \\<beta>_2)\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "from \\<beta>_split"], ["proof (chain)\npicking this:\n  splits_at \\<beta> i \\<beta>_1 X \\<beta>_2", "have i_def: \"i = length \\<beta>_1\""], ["proof (prove)\nusing this:\n  splits_at \\<beta> i \\<beta>_1 X \\<beta>_2\n\ngoal (1 subgoal):\n 1. i = length \\<beta>_1", "by (simp add: dual_order.strict_implies_order  min.absorb2 splits_at_def)"], ["proof (state)\nthis:\n  i = length \\<beta>_1\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "have \"\\<exists> Y \\<delta>_1 \\<delta>_2. splits_at ?\\<delta> (fst (D ! (N - 1))) \\<delta>_1 Y \\<delta>_2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Y \\<delta>_1 \\<delta>_2.\n       splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1\n        Y \\<delta>_2", "using Derives1_\\<delta> splits_at_ex"], ["proof (prove)\nusing this:\n  Derives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>\n  Derives1 ?\\<delta> ?i ?r ?s \\<Longrightarrow>\n  \\<exists>\\<alpha> N \\<beta>. splits_at ?\\<delta> ?i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>Y \\<delta>_1 \\<delta>_2.\n       splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1\n        Y \\<delta>_2", "by blast"], ["proof (state)\nthis:\n  \\<exists>Y \\<delta>_1 \\<delta>_2.\n     splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1 Y\n      \\<delta>_2\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Y \\<delta>_1 \\<delta>_2.\n     splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1 Y\n      \\<delta>_2", "obtain Y \\<delta>_1 \\<delta>_2 where \\<delta>_split: \"splits_at ?\\<delta> (fst (D ! (N - 1))) \\<delta>_1 Y \\<delta>_2\""], ["proof (prove)\nusing this:\n  \\<exists>Y \\<delta>_1 \\<delta>_2.\n     splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1 Y\n      \\<delta>_2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>_1 Y \\<delta>_2.\n        splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1\n         Y \\<delta>_2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1 Y\n   \\<delta>_2\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "have NFix: \"LeftDerivationFix (\\<beta>_1 @ [X] @ \\<beta>_2) (length \\<beta>_1) (drop N D) j \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<beta>_1 @ [X] @ \\<beta>_2) (length \\<beta>_1)\n     (drop N D) j \\<gamma>", "using Minimal_N \\<beta>_combine i_def"], ["proof (prove)\nusing this:\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  \\<beta> = \\<beta>_1 @ [X] @ \\<beta>_2\n  i = length \\<beta>_1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<beta>_1 @ [X] @ \\<beta>_2) (length \\<beta>_1)\n     (drop N D) j \\<gamma>", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<beta>_1 @ [X] @ \\<beta>_2) (length \\<beta>_1)\n   (drop N D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "from LeftDerives1_\\<delta>_hyp \\<delta>_split"], ["proof (chain)\npicking this:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) (\\<beta>_1 @ [X] @ \\<beta>_2)\n  splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1 Y\n   \\<delta>_2", "have \"\\<exists>u v. \\<beta>_1 = \\<delta>_1 @ u \\<and> \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v\""], ["proof (prove)\nusing this:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) (\\<beta>_1 @ [X] @ \\<beta>_2)\n  splits_at (Derive a (take (N - 1) D)) (fst (D ! (N - 1))) \\<delta>_1 Y\n   \\<delta>_2\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       \\<beta>_1 = \\<delta>_1 @ u \\<and>\n       \\<beta>_2 = v @ \\<delta>_2 \\<and>\n       snd (snd (D ! (N - 1))) = u @ [X] @ v", "proof (induct rule: LeftDerives1_X_is_part_of_rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "case (Suffix suffix)"], ["proof (state)\nthis:\n  Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ suffix\n  length \\<beta>_1 < fst (D ! (N - 1))\n  is_word (\\<beta>_1 @ [X])\n  LeftDerives1 suffix (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n   (snd (D ! (N - 1))) \\<beta>_2\n\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "let ?k = \"N - 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "let ?\\<beta> = \"Derive a (take ?k D)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "let ?i = \"length \\<beta>_1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "have k_less: \"?k < length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N - 1 < length D", "using \"2.hyps\" Minimal_N"], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. N - 1 < length D", "by linarith"], ["proof (state)\nthis:\n  N - 1 < length D\n\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  N - 1 < length D", "have k_leq: \"?k \\<le> length D\""], ["proof (prove)\nusing this:\n  N - 1 < length D\n\ngoal (1 subgoal):\n 1. N - 1 \\<le> length D", "by auto"], ["proof (state)\nthis:\n  N - 1 \\<le> length D\n\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "have drop_k_d: \"drop ?k D = (D ! (N - 1))#(drop N D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (N - 1) D = D ! (N - 1) # drop N D", "using \"2.hyps\" Cons_nth_drop_Suc k_less"], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs ! ?i # drop (Suc ?i) ?xs = drop ?i ?xs\n  N - 1 < length D\n\ngoal (1 subgoal):\n 1. drop (N - 1) D = D ! (N - 1) # drop N D", "by fastforce"], ["proof (state)\nthis:\n  drop (N - 1) D = D ! (N - 1) # drop N D\n\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "from LeftDerivationFix_grow_suffix[OF NFix Suffix(4) Suffix(3)] Suffix(1) Suffix(2) 2"], ["proof (chain)\npicking this:\n  LeftDerivationFix (\\<beta>_1 @ [X] @ suffix) (length \\<beta>_1)\n   ((fst (D ! (N - 1)) - length \\<beta>_1 - 1 + length (\\<beta>_1 @ [X]),\n     snd (D ! (N - 1))) #\n    drop N D)\n   j \\<gamma>\n  Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ suffix\n  length \\<beta>_1 < fst (D ! (N - 1))\n  N \\<noteq> 0", "have \"LeftDerivationFix ?\\<beta> ?i (drop ?k D) j \\<gamma>\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (\\<beta>_1 @ [X] @ suffix) (length \\<beta>_1)\n   ((fst (D ! (N - 1)) - length \\<beta>_1 - 1 + length (\\<beta>_1 @ [X]),\n     snd (D ! (N - 1))) #\n    drop N D)\n   j \\<gamma>\n  Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ suffix\n  length \\<beta>_1 < fst (D ! (N - 1))\n  N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (Derive a (take (N - 1) D)) (length \\<beta>_1)\n     (drop (N - 1) D) j \\<gamma>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivationFix (\\<beta>_1 @ X # suffix) (length \\<beta>_1)\n              (D ! (N - Suc 0) # drop N D) j \\<gamma>;\n     Derive a (take (N - Suc 0) D) = \\<beta>_1 @ X # suffix;\n     length \\<beta>_1 < fst (D ! (N - Suc 0)); 0 < N\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationFix (\\<beta>_1 @ X # suffix)\n                       (length \\<beta>_1) (drop (N - Suc 0) D) j \\<gamma>", "by (metis One_nat_def drop_k_d)"], ["proof (state)\nthis:\n  LeftDerivationFix (Derive a (take (N - 1) D)) (length \\<beta>_1)\n   (drop (N - 1) D) j \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<beta>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<beta>_1 @ [X] @ \\<beta>;\n        length \\<beta>_1 < fst (D ! (N - 1)); is_word (\\<beta>_1 @ [X]);\n        LeftDerives1 \\<beta> (fst (D ! (N - 1)) - length \\<beta>_1 - 1)\n         (snd (D ! (N - 1))) \\<beta>_2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "with Minimal(2)[where k=\"?k\"]"], ["proof (chain)\npicking this:\n  N - 1 < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     N - 1 \\<le> length D \\<and>\n     \\<beta> = Derive a (take (N - 1) D) \\<and>\n     LeftDerivationFix \\<beta> i (drop (N - 1) D) j \\<gamma>\n  LeftDerivationFix (Derive a (take (N - 1) D)) (length \\<beta>_1)\n   (drop (N - 1) D) j \\<gamma>", "show \"False\""], ["proof (prove)\nusing this:\n  N - 1 < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     N - 1 \\<le> length D \\<and>\n     \\<beta> = Derive a (take (N - 1) D) \\<and>\n     LeftDerivationFix \\<beta> i (drop (N - 1) D) j \\<gamma>\n  LeftDerivationFix (Derive a (take (N - 1) D)) (length \\<beta>_1)\n   (drop (N - 1) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. False", "using \"2.hyps\" k_leq"], ["proof (prove)\nusing this:\n  N - 1 < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     N - 1 \\<le> length D \\<and>\n     \\<beta> = Derive a (take (N - 1) D) \\<and>\n     LeftDerivationFix \\<beta> i (drop (N - 1) D) j \\<gamma>\n  LeftDerivationFix (Derive a (take (N - 1) D)) (length \\<beta>_1)\n   (drop (N - 1) D) j \\<gamma>\n  N \\<noteq> 0\n  N - 1 \\<le> length D\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "case (Prefix prefix)"], ["proof (state)\nthis:\n  Derive a (take (N - 1) D) = prefix @ [X] @ \\<beta>_2\n  LeftDerives1 prefix (fst (D ! (N - 1))) (snd (D ! (N - 1))) \\<beta>_1\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "have collapse: \"(fst (D ! (N - 1)), snd (D ! (N - 1))) # drop N D = drop (N - 1) D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (D ! (N - 1)), snd (D ! (N - 1))) # drop N D = drop (N - 1) D", "by (metis \"2.hyps\" Cons_nth_drop_Suc Minimal_N Suc_diff_1 neq0_conv not_less \n                not_less_eq prod.collapse)"], ["proof (state)\nthis:\n  (fst (D ! (N - 1)), snd (D ! (N - 1))) # drop N D = drop (N - 1) D\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "from LeftDerivationFix_grow_prefix[OF NFix Prefix(2)] Prefix(1) collapse"], ["proof (chain)\npicking this:\n  LeftDerivationFix (prefix @ [X] @ \\<beta>_2) (length prefix)\n   ((fst (D ! (N - 1)), snd (D ! (N - 1))) # drop N D) j \\<gamma>\n  Derive a (take (N - 1) D) = prefix @ [X] @ \\<beta>_2\n  (fst (D ! (N - 1)), snd (D ! (N - 1))) # drop N D = drop (N - 1) D", "have \"LeftDerivationFix ?\\<delta> (length prefix) (drop (N - 1) D) j \\<gamma>\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (prefix @ [X] @ \\<beta>_2) (length prefix)\n   ((fst (D ! (N - 1)), snd (D ! (N - 1))) # drop N D) j \\<gamma>\n  Derive a (take (N - 1) D) = prefix @ [X] @ \\<beta>_2\n  (fst (D ! (N - 1)), snd (D ! (N - 1))) # drop N D = drop (N - 1) D\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (Derive a (take (N - 1) D)) (length prefix)\n     (drop (N - 1) D) j \\<gamma>", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix (Derive a (take (N - 1) D)) (length prefix)\n   (drop (N - 1) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Derive a (take (N - 1) D) = \\<alpha> @ [X] @ \\<beta>_2;\n        LeftDerives1 \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n         \\<beta>_1\\<rbrakk>\n       \\<Longrightarrow> False", "with Minimal(2)[where k = \"N - 1\"]"], ["proof (chain)\npicking this:\n  N - 1 < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     N - 1 \\<le> length D \\<and>\n     \\<beta> = Derive a (take (N - 1) D) \\<and>\n     LeftDerivationFix \\<beta> i (drop (N - 1) D) j \\<gamma>\n  LeftDerivationFix (Derive a (take (N - 1) D)) (length prefix)\n   (drop (N - 1) D) j \\<gamma>", "show \"False\""], ["proof (prove)\nusing this:\n  N - 1 < N \\<Longrightarrow>\n  \\<nexists>\\<beta> i.\n     N - 1 \\<le> length D \\<and>\n     \\<beta> = Derive a (take (N - 1) D) \\<and>\n     LeftDerivationFix \\<beta> i (drop (N - 1) D) j \\<gamma>\n  LeftDerivationFix (Derive a (take (N - 1) D)) (length prefix)\n   (drop (N - 1) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. False", "by (metis Minimal_N collapse diff_le_self le_neq_implies_less less_imp_diff_less \n                less_or_eq_imp_le not_Cons_self2)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u v.\n     \\<beta>_1 = \\<delta>_1 @ u \\<and>\n     \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>u v.\n     \\<beta>_1 = \\<delta>_1 @ u \\<and>\n     \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v", "obtain u v where uv:\n          \"\\<beta>_1 = \\<delta>_1 @ u \\<and> \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v\""], ["proof (prove)\nusing this:\n  \\<exists>u v.\n     \\<beta>_1 = \\<delta>_1 @ u \\<and>\n     \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<beta>_1 = \\<delta>_1 @ u \\<and>\n        \\<beta>_2 = v @ \\<delta>_2 \\<and>\n        snd (snd (D ! (N - 1))) = u @ [X] @ v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta>_1 = \\<delta>_1 @ u \\<and>\n  \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "have X_1: \"snd (snd (D ! (N - Suc 0))) ! length u = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (D ! (N - Suc 0))) ! length u = X", "using uv"], ["proof (prove)\nusing this:\n  \\<beta>_1 = \\<delta>_1 @ u \\<and>\n  \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v\n\ngoal (1 subgoal):\n 1. snd (snd (D ! (N - Suc 0))) ! length u = X", "by auto"], ["proof (state)\nthis:\n  snd (snd (D ! (N - Suc 0))) ! length u = X\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "have X_2: \"\\<gamma> ! j = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> ! j = X", "using LeftDerivationFix_def NFix"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n  LeftDerivationFix (\\<beta>_1 @ [X] @ \\<beta>_2) (length \\<beta>_1)\n   (drop N D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<gamma> ! j = X", "by auto"], ["proof (state)\nthis:\n  \\<gamma> ! j = X\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n    (\\<exists>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma>)", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma>", "apply (rule_tac x=\"N - 1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha> ix.\n       N - 1 < length D \\<and>\n       LeftDerivation a (take (N - 1) D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! (N - 1))) (snd (D ! (N - 1)))\n        ix (drop (Suc (N - 1)) D) j \\<gamma>", "apply (rule_tac x=\"?\\<delta>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ix.\n       N - 1 < length D \\<and>\n       LeftDerivation a (take (N - 1) D) (Derive a (take (N - 1) D)) \\<and>\n       LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n        (snd (D ! (N - 1))) ix (drop (Suc (N - 1)) D) j \\<gamma>", "apply (rule_tac x=\"length u\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. N - 1 < length D \\<and>\n    LeftDerivation a (take (N - 1) D) (Derive a (take (N - 1) D)) \\<and>\n    LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (length u) (drop (Suc (N - 1)) D) j \\<gamma>", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. N - 1 < length D\n 2. LeftDerivation a (take (N - 1) D) (Derive a (take (N - 1) D)) \\<and>\n    LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (length u) (drop (Suc (N - 1)) D) j \\<gamma>", "using Minimal_N less2"], ["proof (prove)\nusing this:\n  N \\<le> length D \\<and>\n  \\<beta> = Derive a (take N D) \\<and>\n  LeftDerivationFix \\<beta> i (drop N D) j \\<gamma>\n  length D \\<noteq> 0\n\ngoal (2 subgoals):\n 1. N - 1 < length D\n 2. LeftDerivation a (take (N - 1) D) (Derive a (take (N - 1) D)) \\<and>\n    LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (length u) (drop (Suc (N - 1)) D) j \\<gamma>", "apply linarith"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation a (take (N - 1) D) (Derive a (take (N - 1) D)) \\<and>\n    LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (length u) (drop (Suc (N - 1)) D) j \\<gamma>", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivation a (take (N - 1) D) (Derive a (take (N - 1) D))\n 2. LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (length u) (drop (Suc (N - 1)) D) j \\<gamma>", "using LeftDerivation_take_derive less.prems(1)"], ["proof (prove)\nusing this:\n  LeftDerivation ?a ?D ?b \\<Longrightarrow>\n  LeftDerivation ?a (take ?n ?D) (Derive ?a (take ?n ?D))\n  LeftDerivation a D \\<gamma>\n\ngoal (2 subgoals):\n 1. LeftDerivation a (take (N - 1) D) (Derive a (take (N - 1) D))\n 2. LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (length u) (drop (Suc (N - 1)) D) j \\<gamma>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) (length u) (drop (Suc (N - 1)) D) j \\<gamma>", "apply (subst LeftDerivationIntro_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n        (snd (D ! (N - 1))) \\<beta> \\<and>\n       length u < length (snd (snd (D ! (N - 1)))) \\<and>\n       snd (snd (D ! (N - 1))) ! length u = \\<gamma> ! j \\<and>\n       LeftDerivationFix \\<beta> (fst (D ! (N - 1)) + length u)\n        (drop (Suc (N - 1)) D) j \\<gamma>", "apply (rule_tac x=\\<beta> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n     (snd (D ! (N - 1))) \\<beta> \\<and>\n    length u < length (snd (snd (D ! (N - 1)))) \\<and>\n    snd (snd (D ! (N - 1))) ! length u = \\<gamma> ! j \\<and>\n    LeftDerivationFix \\<beta> (fst (D ! (N - 1)) + length u)\n     (drop (Suc (N - 1)) D) j \\<gamma>", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerives1 (Derive a (take (N - Suc 0) D)) (fst (D ! (N - Suc 0)))\n     (snd (D ! (N - Suc 0))) \\<beta>\n 2. length u < length (snd (snd (D ! (N - Suc 0))))\n 3. snd (snd (D ! (N - Suc 0))) ! length u = \\<gamma> ! j\n 4. LeftDerivationFix \\<beta> (fst (D ! (N - Suc 0)) + length u)\n     (drop (Suc (N - Suc 0)) D) j \\<gamma>", "using LeftDerives1_\\<delta> One_nat_def"], ["proof (prove)\nusing this:\n  LeftDerives1 (Derive a (take (N - 1) D)) (fst (D ! (N - 1)))\n   (snd (D ! (N - 1))) \\<beta>\n  1 = Suc 0\n\ngoal (4 subgoals):\n 1. LeftDerives1 (Derive a (take (N - Suc 0) D)) (fst (D ! (N - Suc 0)))\n     (snd (D ! (N - Suc 0))) \\<beta>\n 2. length u < length (snd (snd (D ! (N - Suc 0))))\n 3. snd (snd (D ! (N - Suc 0))) ! length u = \\<gamma> ! j\n 4. LeftDerivationFix \\<beta> (fst (D ! (N - Suc 0)) + length u)\n     (drop (Suc (N - Suc 0)) D) j \\<gamma>", "apply presburger"], ["proof (prove)\ngoal (3 subgoals):\n 1. length u < length (snd (snd (D ! (N - Suc 0))))\n 2. snd (snd (D ! (N - Suc 0))) ! length u = \\<gamma> ! j\n 3. LeftDerivationFix \\<beta> (fst (D ! (N - Suc 0)) + length u)\n     (drop (Suc (N - Suc 0)) D) j \\<gamma>", "using uv"], ["proof (prove)\nusing this:\n  \\<beta>_1 = \\<delta>_1 @ u \\<and>\n  \\<beta>_2 = v @ \\<delta>_2 \\<and> snd (snd (D ! (N - 1))) = u @ [X] @ v\n\ngoal (3 subgoals):\n 1. length u < length (snd (snd (D ! (N - Suc 0))))\n 2. snd (snd (D ! (N - Suc 0))) ! length u = \\<gamma> ! j\n 3. LeftDerivationFix \\<beta> (fst (D ! (N - Suc 0)) + length u)\n     (drop (Suc (N - Suc 0)) D) j \\<gamma>", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (snd (D ! (N - Suc 0))) ! length u = \\<gamma> ! j\n 2. LeftDerivationFix \\<beta> (fst (D ! (N - Suc 0)) + length u)\n     (drop (Suc (N - Suc 0)) D) j \\<gamma>", "using X_1 X_2"], ["proof (prove)\nusing this:\n  snd (snd (D ! (N - Suc 0))) ! length u = X\n  \\<gamma> ! j = X\n\ngoal (2 subgoals):\n 1. snd (snd (D ! (N - Suc 0))) ! length u = \\<gamma> ! j\n 2. LeftDerivationFix \\<beta> (fst (D ! (N - Suc 0)) + length u)\n     (drop (Suc (N - Suc 0)) D) j \\<gamma>", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<beta> (fst (D ! (N - Suc 0)) + length u)\n     (drop (Suc (N - Suc 0)) D) j \\<gamma>", "by (metis (no_types, lifting) \"2.hyps\" Derives1_\\<delta> Derives1_split Minimal_N One_nat_def \n            Suc_diff_1 \\<delta>_split append_eq_conv_conj i_def length_append neq0_conv splits_at_def uv)"], ["proof (state)\nthis:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "type_synonym deriv = \"nat \\<times> nat \\<times> nat\""], ["", "type_synonym ladder = \"deriv list\""], ["", "definition deriv_n :: \"deriv \\<Rightarrow> nat\" where \n  \"deriv_n d = fst d\""], ["", "definition deriv_j :: \"deriv \\<Rightarrow> nat\" where\n  \"deriv_j d = fst (snd d)\""], ["", "definition deriv_ix :: \"deriv \\<Rightarrow> nat\" where\n  \"deriv_ix d = snd (snd d)\""], ["", "definition deriv_i :: \"deriv \\<Rightarrow> nat\" where\n  \"deriv_i d = snd (snd d)\""], ["", "definition ladder_j :: \"ladder \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"ladder_j L index = deriv_j (L ! index)\""], ["", "definition ladder_i :: \"ladder \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"ladder_i L index = (if index = 0 then deriv_i (hd L) else ladder_j L (index - 1))\""], ["", "definition ladder_n :: \"ladder \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"ladder_n L index = deriv_n (L ! index)\""], ["", "definition ladder_prev_n :: \"ladder \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"ladder_prev_n L index = (if index = 0 then 0 else (ladder_n L (index - 1)))\""], ["", "definition ladder_ix :: \"ladder \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"ladder_ix L index = (if index = 0 then undefined else deriv_ix (L ! index))\""], ["", "definition ladder_last_j :: \"ladder \\<Rightarrow> nat\" where\n  \"ladder_last_j L = ladder_j L (length L - 1)\""], ["", "definition ladder_last_n :: \"ladder \\<Rightarrow> nat\" where\n  \"ladder_last_n L = ladder_n L (length L - 1)\""], ["", "definition is_ladder :: \"derivation \\<Rightarrow> ladder \\<Rightarrow> bool\" where\n  \"is_ladder D L = (L \\<noteq> [] \\<and> \n    (\\<forall> u. u < length L \\<longrightarrow> ladder_n L u \\<le> length D) \\<and>\n    (\\<forall> u v. u < v \\<and> v < length L \\<longrightarrow> ladder_n L u < ladder_n L v) \\<and>\n    ladder_last_n L = length D)\""], ["", "definition ladder_\\<gamma> :: \"sentence \\<Rightarrow> derivation \\<Rightarrow> ladder \\<Rightarrow> nat \\<Rightarrow> sentence\" where\n  \"ladder_\\<gamma> a D L index = Derive a (take (ladder_n L index) D)\""], ["", "definition ladder_\\<alpha> :: \"sentence \\<Rightarrow> derivation \\<Rightarrow> ladder \\<Rightarrow> nat \\<Rightarrow> sentence\" where\n  \"ladder_\\<alpha> a D L index = (if index = 0 then a else ladder_\\<gamma> a D L (index - 1))\""], ["", "definition LeftDerivationIntrosAt :: \"sentence \\<Rightarrow> derivation \\<Rightarrow> ladder \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"LeftDerivationIntrosAt a D L index = (\n       let \\<alpha> = ladder_\\<alpha> a D L index in\n       let i = ladder_i L index in\n       let j = ladder_j L index in\n       let ix = ladder_ix L index in\n       let \\<gamma> = ladder_\\<gamma> a D L index in \n       let n = ladder_n L (index - 1) in\n       let m = ladder_n L index in\n       let e = D ! n in\n       let E = drop (Suc n) (take m D) in\n        i = fst e \\<and>\n        LeftDerivationIntro \\<alpha> i (snd e) ix E j \\<gamma>)\""], ["", "definition LeftDerivationIntros :: \"sentence \\<Rightarrow> derivation \\<Rightarrow> ladder \\<Rightarrow> bool\" where\n  \"LeftDerivationIntros a D L = (\n     \\<forall> index. 1 \\<le> index \\<and> index < length L \\<longrightarrow> LeftDerivationIntrosAt a D L index)\""], ["", "definition LeftDerivationLadder :: \"sentence \\<Rightarrow> derivation \\<Rightarrow> ladder \\<Rightarrow> sentence \\<Rightarrow> bool\" where \n  \"LeftDerivationLadder a D L b = (\n    LeftDerivation a D b \\<and> \n    is_ladder D L \\<and>\n    LeftDerivationFix a (ladder_i L 0) (take (ladder_n L 0) D) (ladder_j L 0) (ladder_\\<gamma> a D L 0) \\<and> \n    LeftDerivationIntros a D L)\""], ["", "definition mk_deriv_fix :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> deriv\" where\n  \"mk_deriv_fix i n j = (n, j, i)\""], ["", "definition mk_deriv_intro :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> deriv\" where\n  \"mk_deriv_intro ix n j = (n, j, ix)\""], ["", "lemma mk_deriv_fix_i[simp]: \"deriv_i (mk_deriv_fix i n j) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_i (mk_deriv_fix i n j) = i", "by (simp add: deriv_i_def mk_deriv_fix_def)"], ["", "lemma mk_deriv_fix_j[simp]: \"deriv_j (mk_deriv_fix i n j) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_j (mk_deriv_fix i n j) = j", "by (simp add: deriv_j_def mk_deriv_fix_def)"], ["", "lemma mk_deriv_fix_n[simp]: \"deriv_n (mk_deriv_fix i n j) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n (mk_deriv_fix i n j) = n", "by (simp add: deriv_n_def mk_deriv_fix_def)"], ["", "lemma mk_deriv_intro_i[simp]: \"deriv_i (mk_deriv_intro i n j) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_i (mk_deriv_intro i n j) = i", "by (simp add: deriv_i_def mk_deriv_intro_def)"], ["", "lemma mk_deriv_intro_ix[simp]: \"deriv_ix (mk_deriv_intro ix n j) = ix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_ix (mk_deriv_intro ix n j) = ix", "by (simp add: deriv_ix_def mk_deriv_intro_def)"], ["", "lemma mk_deriv_intro_j[simp]: \"deriv_j (mk_deriv_intro i n j) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_j (mk_deriv_intro i n j) = j", "by (simp add: deriv_j_def mk_deriv_intro_def)"], ["", "lemma mk_deriv_intro_n[simp]: \"deriv_n (mk_deriv_intro i n j) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n (mk_deriv_intro i n j) = n", "by (simp add: deriv_n_def mk_deriv_intro_def)"], ["", "lemma LeftDerivationFix_implies_ex_ladder:\n  \"LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow> \\<exists> L. LeftDerivationLadder a D L \\<gamma> \\<and> \n    ladder_last_j L = j \\<and> ladder_last_n L = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and>\n       ladder_last_j L = j \\<and> ladder_last_n L = length D", "apply (rule_tac x=\"[mk_deriv_fix i (length D) j]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationLadder a D [mk_deriv_fix i (length D) j] \\<gamma> \\<and>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j \\<and>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (auto simp add: LeftDerivationLadder_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivation a D \\<gamma>\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    is_ladder D [mk_deriv_fix i (length D) j]\n 3. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationFix a (ladder_i [mk_deriv_fix i (length D) j] 0)\n     (take (ladder_n [mk_deriv_fix i (length D) j] 0) D)\n     (ladder_j [mk_deriv_fix i (length D) j] 0)\n     (ladder_\\<gamma> a D [mk_deriv_fix i (length D) j] 0)\n 4. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationIntros a D [mk_deriv_fix i (length D) j]\n 5. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 6. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (simp add: LeftDerivationFix_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    is_ladder D [mk_deriv_fix i (length D) j]\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationFix a (ladder_i [mk_deriv_fix i (length D) j] 0)\n     (take (ladder_n [mk_deriv_fix i (length D) j] 0) D)\n     (ladder_j [mk_deriv_fix i (length D) j] 0)\n     (ladder_\\<gamma> a D [mk_deriv_fix i (length D) j] 0)\n 3. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationIntros a D [mk_deriv_fix i (length D) j]\n 4. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 5. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (simp add: is_ladder_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_n [mk_deriv_fix i (length D) j] 0 \\<le> length D \\<and>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationFix a (ladder_i [mk_deriv_fix i (length D) j] 0)\n     (take (ladder_n [mk_deriv_fix i (length D) j] 0) D)\n     (ladder_j [mk_deriv_fix i (length D) j] 0)\n     (ladder_\\<gamma> a D [mk_deriv_fix i (length D) j] 0)\n 3. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationIntros a D [mk_deriv_fix i (length D) j]\n 4. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 5. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (auto simp add: ladder_i_def ladder_j_def ladder_n_def ladder_\\<gamma>_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationFix a i D j (Derive a D)\n 3. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationIntros a D [mk_deriv_fix i (length D) j]\n 4. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 5. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (simp add: ladder_last_n_def ladder_n_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationFix a i D j (Derive a D)\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationIntros a D [mk_deriv_fix i (length D) j]\n 3. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 4. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "using Derive LeftDerivationFix_def LeftDerivation_implies_Derivation"], ["proof (prove)\nusing this:\n  Derivation ?a ?D ?b \\<Longrightarrow> Derive ?a ?D = ?b\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n\ngoal (4 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationFix a i D j (Derive a D)\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationIntros a D [mk_deriv_fix i (length D) j]\n 3. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 4. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    LeftDerivationIntros a D [mk_deriv_fix i (length D) j]\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 3. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (simp add: LeftDerivationIntros_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_j [mk_deriv_fix i (length D) j] = j\n 2. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (simp add: ladder_last_j_def ladder_j_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    ladder_last_n [mk_deriv_fix i (length D) j] = length D", "apply (simp add: ladder_last_n_def ladder_n_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trivP[case_names prems]: \"P \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> P", "by blast"], ["", "lemma LeftDerivationLadder_ladder_n_bound:\n  assumes \"LeftDerivationLadder a D L b\"\n  assumes \"index < length L\"\n  shows \"ladder_n L index \\<le> length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L index \\<le> length D", "using LeftDerivationLadder_def assms(1) assms(2) is_ladder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder a D L b\n  index < length L\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. ladder_n L index \\<le> length D", "by blast"], ["", "lemma LeftDerivationLadder_deriv_n_bound:\n  assumes \"LeftDerivationLadder a D L b\"\n  assumes \"index < length L\"\n  shows \"deriv_n (L ! index) \\<le> length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n (L ! index) \\<le> length D", "using LeftDerivationLadder_def assms(1) assms(2) is_ladder_def ladder_n_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder a D L b\n  index < length L\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  ladder_n ?L ?index = deriv_n (?L ! ?index)\n\ngoal (1 subgoal):\n 1. deriv_n (L ! index) \\<le> length D", "by auto"], ["", "lemma ladder_n_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_n (L@L') u = ladder_n L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L \\<Longrightarrow> ladder_n (L @ L') u = ladder_n L u", "by (simp add: ladder_n_def)"], ["", "lemma ladder_n_simp2[simp]: \"ladder_n (L@[d]) (length L) = deriv_n d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (L @ [d]) (length L) = deriv_n d", "by (simp add: ladder_n_def)"], ["", "lemma ladder_j_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_j (L@L') u = ladder_j L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L \\<Longrightarrow> ladder_j (L @ L') u = ladder_j L u", "by (simp add: ladder_j_def)"], ["", "lemma ladder_j_simp2[simp]: \"ladder_j (L@[d]) (length L) = deriv_j d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j (L @ [d]) (length L) = deriv_j d", "by (simp add: ladder_j_def)"], ["", "lemma ladder_i_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_i (L@L') u = ladder_i L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L \\<Longrightarrow> ladder_i (L @ L') u = ladder_i L u", "by (auto simp add: ladder_i_def)"], ["", "lemma ladder_ix_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_ix (L@L') u = ladder_ix L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L \\<Longrightarrow> ladder_ix (L @ L') u = ladder_ix L u", "by (auto simp add: ladder_ix_def)"], ["", "lemma ladder_ix_simp2[simp]: \"L \\<noteq> [] \\<Longrightarrow> ladder_ix (L@[d]) (length L) = deriv_ix d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<noteq> [] \\<Longrightarrow>\n    ladder_ix (L @ [d]) (length L) = deriv_ix d", "by (auto simp add: ladder_ix_def)"], ["", "lemma ladder_\\<gamma>_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_\\<gamma> a D (L@L') u = ladder_\\<gamma> a D L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L \\<Longrightarrow>\n    ladder_\\<gamma> a D (L @ L') u = ladder_\\<gamma> a D L u", "by (simp add: ladder_\\<gamma>_def)"], ["", "lemma ladder_\\<gamma>_simp2[simp]: \"u < length L \\<Longrightarrow> is_ladder D L \\<Longrightarrow> \n  ladder_\\<gamma> a (D@D') L u = ladder_\\<gamma> a D L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u < length L; is_ladder D L\\<rbrakk>\n    \\<Longrightarrow> ladder_\\<gamma> a (D @ D') L u =\n                      ladder_\\<gamma> a D L u", "by (simp add: is_ladder_def ladder_\\<gamma>_def)"], ["", "lemma ladder_\\<alpha>_simp1[simp]: \"u < length L \\<Longrightarrow> ladder_\\<alpha> a D (L@L') u = ladder_\\<alpha> a D L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L \\<Longrightarrow>\n    ladder_\\<alpha> a D (L @ L') u = ladder_\\<alpha> a D L u", "by (simp add: ladder_\\<alpha>_def)"], ["", "lemma ladder_\\<alpha>_simp2[simp]: \"u < length L \\<Longrightarrow> is_ladder D L \\<Longrightarrow> \n  ladder_\\<alpha> a (D@D') L u = ladder_\\<alpha> a D L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u < length L; is_ladder D L\\<rbrakk>\n    \\<Longrightarrow> ladder_\\<alpha> a (D @ D') L u =\n                      ladder_\\<alpha> a D L u", "by (simp add: is_ladder_def ladder_\\<alpha>_def)"], ["", "lemma ladder_n_minus_1_bound: \"is_ladder D L \\<Longrightarrow> index \\<ge> 1 \\<Longrightarrow> index < length L \\<Longrightarrow> \n  ladder_n L (index - Suc 0) < length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ladder D L; 1 \\<le> index; index < length L\\<rbrakk>\n    \\<Longrightarrow> ladder_n L (index - Suc 0) < length D", "by (metis (no_types, lifting) One_nat_def Suc_diff_1 Suc_le_lessD dual_order.strict_implies_order \n  is_ladder_def le_neq_implies_less not_less)"], ["", "lemma LeftDerivationIntrosAt_ignore_appendix:\n  assumes is_ladder: \"is_ladder D L\"\n  assumes hyp: \"LeftDerivationIntrosAt a D L index\"\n  assumes index_ge: \"index \\<ge> 1\"\n  assumes index_less: \"index < length L\"\n  shows \"LeftDerivationIntrosAt a (D @ D') (L @ L') index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ D') (L @ L') index", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ D') (L @ L') index", "have index_minus_1: \"index - Suc 0 < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index - Suc 0 < length L", "using index_less"], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (1 subgoal):\n 1. index - Suc 0 < length L", "by arith"], ["proof (state)\nthis:\n  index - Suc 0 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ D') (L @ L') index", "have is_0: \"ladder_n L index - length D = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L index - length D = 0", "using index_less is_ladder is_ladder_def"], ["proof (prove)\nusing this:\n  index < length L\n  is_ladder D L\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. ladder_n L index - length D = 0", "by auto"], ["proof (state)\nthis:\n  ladder_n L index - length D = 0\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ D') (L @ L') index", "from index_ge index_less"], ["proof (chain)\npicking this:\n  1 \\<le> index\n  index < length L", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> index\n  index < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ D') (L @ L') index", "apply (simp add: LeftDerivationIntrosAt_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 \\<le> index; index < length L\\<rbrakk>\n    \\<Longrightarrow> ladder_i L index =\n                      fst ((D @ D') ! ladder_n L (index - Suc 0)) \\<and>\n                      LeftDerivationIntro\n                       (ladder_\\<alpha> a (D @ D') L index)\n                       (ladder_i L index)\n                       (snd ((D @ D') ! ladder_n L (index - Suc 0)))\n                       (ladder_ix L index)\n                       (drop (Suc (ladder_n L (index - Suc 0)))\n                         (take (ladder_n L index) D) @\n                        drop\n                         (Suc (ladder_n L (index - Suc 0)) -\n                          min (length D) (ladder_n L index))\n                         (take (ladder_n L index - length D) D'))\n                       (ladder_j L index)\n                       (ladder_\\<gamma> a (D @ D') L index)", "apply (simp add: index_minus_1 is_ladder ladder_n_minus_1_bound is_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 \\<le> index; index < length L\\<rbrakk>\n    \\<Longrightarrow> ladder_i L index =\n                      fst (D ! ladder_n L (index - Suc 0)) \\<and>\n                      LeftDerivationIntro (ladder_\\<alpha> a D L index)\n                       (ladder_i L index)\n                       (snd (D ! ladder_n L (index - Suc 0)))\n                       (ladder_ix L index)\n                       (drop (Suc (ladder_n L (index - Suc 0)))\n                         (take (ladder_n L index) D))\n                       (ladder_j L index) (ladder_\\<gamma> a D L index)", "using hyp"], ["proof (prove)\nusing this:\n  LeftDerivationIntrosAt a D L index\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 \\<le> index; index < length L\\<rbrakk>\n    \\<Longrightarrow> ladder_i L index =\n                      fst (D ! ladder_n L (index - Suc 0)) \\<and>\n                      LeftDerivationIntro (ladder_\\<alpha> a D L index)\n                       (ladder_i L index)\n                       (snd (D ! ladder_n L (index - Suc 0)))\n                       (ladder_ix L index)\n                       (drop (Suc (ladder_n L (index - Suc 0)))\n                         (take (ladder_n L index) D))\n                       (ladder_j L index) (ladder_\\<gamma> a D L index)", "apply (auto simp add: LeftDerivationIntrosAt_def Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt a (D @ D') (L @ L') index\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_i_eq_last_j: \"L \\<noteq> [] \\<Longrightarrow> ladder_i (L @ L') (length L) = ladder_last_j L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<noteq> [] \\<Longrightarrow>\n    ladder_i (L @ L') (length L) = ladder_last_j L", "by (simp add: ladder_i_def ladder_last_j_def)"], ["", "lemma ladder_last_n_intro: \"L \\<noteq> [] \\<Longrightarrow> ladder_n L (length L - Suc 0) = ladder_last_n L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<noteq> [] \\<Longrightarrow>\n    ladder_n L (length L - Suc 0) = ladder_last_n L", "by (simp add: ladder_last_n_def)"], ["", "lemma is_ladder_not_empty: \"is_ladder D L \\<Longrightarrow> L \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder D L \\<Longrightarrow> L \\<noteq> []", "using is_ladder_def"], ["proof (prove)\nusing this:\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. is_ladder D L \\<Longrightarrow> L \\<noteq> []", "by blast"], ["", "lemma last_ladder_\\<gamma>:\n  assumes is_ladder: \"is_ladder D L\"\n  assumes ladder_last_n: \"ladder_last_n L = length D\"\n  shows \"ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D", "from is_ladder is_ladder_not_empty"], ["proof (chain)\npicking this:\n  is_ladder D L\n  is_ladder ?D ?L \\<Longrightarrow> ?L \\<noteq> []", "have \"L \\<noteq> []\""], ["proof (prove)\nusing this:\n  is_ladder D L\n  is_ladder ?D ?L \\<Longrightarrow> ?L \\<noteq> []\n\ngoal (1 subgoal):\n 1. L \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D", "then"], ["proof (chain)\npicking this:\n  L \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D", "by (simp add: ladder_\\<gamma>_def ladder_last_n_intro ladder_last_n)"], ["proof (state)\nthis:\n  ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_\\<alpha>_full:\n  assumes is_ladder: \"is_ladder D L\"\n  assumes ladder_last_n: \"ladder_last_n L = length D\"\n  shows \"ladder_\\<alpha> a (D @ D') (L @ L') (length L) = Derive a D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<alpha> a (D @ D') (L @ L') (length L) = Derive a D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_\\<alpha> a (D @ D') (L @ L') (length L) = Derive a D", "from is_ladder"], ["proof (chain)\npicking this:\n  is_ladder D L", "have L_not_empty: \"L \\<noteq> []\""], ["proof (prove)\nusing this:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. L \\<noteq> []", "by (simp add: is_ladder_def)"], ["proof (state)\nthis:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. ladder_\\<alpha> a (D @ D') (L @ L') (length L) = Derive a D", "with is_ladder ladder_last_n"], ["proof (chain)\npicking this:\n  is_ladder D L\n  ladder_last_n L = length D\n  L \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  is_ladder D L\n  ladder_last_n L = length D\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. ladder_\\<alpha> a (D @ D') (L @ L') (length L) = Derive a D", "apply (simp add: ladder_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ladder D L; ladder_last_n L = length D;\n     L \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ladder_\\<gamma> a D L (length L - Suc 0) = Derive a D", "apply (simp add: last_ladder_\\<gamma>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ladder_\\<alpha> a (D @ D') (L @ L') (length L) = Derive a D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_implies_LeftDerivation:\n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow> LeftDerivation \\<alpha> ((i,r)#D) \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow>\n    LeftDerivation \\<alpha> ((i, r) # D) \\<gamma>", "using LeftDerivationFix_def LeftDerivationIntro_def"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n  LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<gamma> =\n  (\\<exists>\\<beta>.\n      LeftDerives1 ?\\<alpha> ?i ?r \\<beta> \\<and>\n      ?ix < length (snd ?r) \\<and>\n      snd ?r ! ?ix = ?\\<gamma> ! ?j \\<and>\n      LeftDerivationFix \\<beta> (?i + ?ix) ?D ?j ?\\<gamma>)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow>\n    LeftDerivation \\<alpha> ((i, r) # D) \\<gamma>", "by auto"], ["", "lemma LeftDerivationLadder_grow: \n  \"LeftDerivationLadder a D L \\<alpha> \\<Longrightarrow> ladder_last_j L = i \\<Longrightarrow>\n   LeftDerivationIntro \\<alpha> i r ix E j \\<gamma> \\<Longrightarrow>\n   LeftDerivationLadder a (D@[(i, r)]@E) (L@[mk_deriv_intro ix (Suc(length D + length E)) j]) \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n     LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                       (L @\n                        [mk_deriv_intro ix (Suc (length D + length E)) j])\n                       \\<gamma>", "proof (induct arbitrary: a D L \\<alpha> i r ix E j \\<gamma> rule: trivP)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "case prems"], ["proof (state)\nthis:\n  LeftDerivationLadder a D L \\<alpha>\n  ladder_last_j L = i\n  LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "{"], ["proof (state)\nthis:\n  LeftDerivationLadder a D L \\<alpha>\n  ladder_last_j L = i\n  LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "assume \"u < Suc (length L)\""], ["proof (state)\nthis:\n  u < Suc (length L)\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "then"], ["proof (chain)\npicking this:\n  u < Suc (length L)", "have \"u < length L \\<or> u = length L\""], ["proof (prove)\nusing this:\n  u < Suc (length L)\n\ngoal (1 subgoal):\n 1. u < length L \\<or> u = length L", "by arith"], ["proof (state)\nthis:\n  u < length L \\<or> u = length L\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "then"], ["proof (chain)\npicking this:\n  u < length L \\<or> u = length L", "have \"ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u \\<le> \n      Suc (length D + length E)\""], ["proof (prove)\nusing this:\n  u < length L \\<or> u = length L\n\ngoal (1 subgoal):\n 1. ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. u < length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)\n 2. u = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "case 1"], ["proof (state)\nthis:\n  u < length L\n\ngoal (2 subgoals):\n 1. u < length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)\n 2. u = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "then"], ["proof (chain)\npicking this:\n  u < length L", "show ?case"], ["proof (prove)\nusing this:\n  u < length L\n\ngoal (1 subgoal):\n 1. ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L \\<Longrightarrow>\n    ladder_n L u \\<le> Suc (length D + length E)", "by (meson LeftDerivationLadder_ladder_n_bound le_Suc_eq le_add1 le_trans prems(1))"], ["proof (state)\nthis:\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n  \\<le> Suc (length D + length E)\n\ngoal (1 subgoal):\n 1. u = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "case 2"], ["proof (state)\nthis:\n  u = length L\n\ngoal (1 subgoal):\n 1. u = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "then"], ["proof (chain)\npicking this:\n  u = length L", "show ?case"], ["proof (prove)\nusing this:\n  u = length L\n\ngoal (1 subgoal):\n 1. ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    \\<le> Suc (length D + length E)", "by (simp add: ladder_n_def)"], ["proof (state)\nthis:\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n  \\<le> Suc (length D + length E)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n  \\<le> Suc (length D + length E)\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "}"], ["proof (state)\nthis:\n  ?u2 < Suc (length L) \\<Longrightarrow>\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) ?u2\n  \\<le> Suc (length D + length E)\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "note ladder_n_ineqs = this"], ["proof (state)\nthis:\n  ?u2 < Suc (length L) \\<Longrightarrow>\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) ?u2\n  \\<le> Suc (length D + length E)\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "{"], ["proof (state)\nthis:\n  ?u2 < Suc (length L) \\<Longrightarrow>\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) ?u2\n  \\<le> Suc (length D + length E)\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "fix v :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "assume u_less_v: \"u < v\""], ["proof (state)\nthis:\n  u < v\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "assume \"v < Suc (length L)\""], ["proof (state)\nthis:\n  v < Suc (length L)\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "then"], ["proof (chain)\npicking this:\n  v < Suc (length L)", "have \"v < length L \\<or> v = length L\""], ["proof (prove)\nusing this:\n  v < Suc (length L)\n\ngoal (1 subgoal):\n 1. v < length L \\<or> v = length L", "by arith"], ["proof (state)\nthis:\n  v < length L \\<or> v = length L\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "then"], ["proof (chain)\npicking this:\n  v < length L \\<or> v = length L", "have \"ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n           < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v\""], ["proof (prove)\nusing this:\n  v < length L \\<or> v = length L\n\ngoal (1 subgoal):\n 1. ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. v < length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v\n 2. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "case 1"], ["proof (state)\nthis:\n  v < length L\n\ngoal (2 subgoals):\n 1. v < length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v\n 2. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "with u_less_v"], ["proof (chain)\npicking this:\n  u < v\n  v < length L", "have u_bound: \"u < length L\""], ["proof (prove)\nusing this:\n  u < v\n  v < length L\n\ngoal (1 subgoal):\n 1. u < length L", "by arith"], ["proof (state)\nthis:\n  u < length L\n\ngoal (2 subgoals):\n 1. v < length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v\n 2. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "using 1 u_bound"], ["proof (prove)\nusing this:\n  v < length L\n  u < length L\n\ngoal (1 subgoal):\n 1. ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v < length L; u < length L\\<rbrakk>\n    \\<Longrightarrow> ladder_n L u < ladder_n L v", "using prems u_less_v LeftDerivationLadder_def is_ladder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder a D L \\<alpha>\n  ladder_last_j L = i\n  LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\n  u < v\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v < length L; u < length L\\<rbrakk>\n    \\<Longrightarrow> ladder_n L u < ladder_n L v", "by auto"], ["proof (state)\nthis:\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n  < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v\n\ngoal (1 subgoal):\n 1. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "case 2"], ["proof (state)\nthis:\n  v = length L\n\ngoal (1 subgoal):\n 1. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "with u_less_v"], ["proof (chain)\npicking this:\n  u < v\n  v = length L", "have u_bound: \"u < length L\""], ["proof (prove)\nusing this:\n  u < v\n  v = length L\n\ngoal (1 subgoal):\n 1. u < length L", "by arith"], ["proof (state)\nthis:\n  u < length L\n\ngoal (1 subgoal):\n 1. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "have \"deriv_n (L ! u) \\<le> length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n (L ! u) \\<le> length D", "using LeftDerivationLadder_deriv_n_bound prems(1) u_bound"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerivationLadder ?a ?D ?L ?b; ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> deriv_n (?L ! ?index) \\<le> length ?D\n  LeftDerivationLadder a D L \\<alpha>\n  u < length L\n\ngoal (1 subgoal):\n 1. deriv_n (L ! u) \\<le> length D", "by blast"], ["proof (state)\nthis:\n  deriv_n (L ! u) \\<le> length D\n\ngoal (1 subgoal):\n 1. v = length L \\<Longrightarrow>\n    ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "then"], ["proof (chain)\npicking this:\n  deriv_n (L ! u) \\<le> length D", "show ?case"], ["proof (prove)\nusing this:\n  deriv_n (L ! u) \\<le> length D\n\ngoal (1 subgoal):\n 1. ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "apply (simp add: u_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n (L ! u) \\<le> length D \\<Longrightarrow>\n    ladder_n L u\n    < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v", "apply (simp add: ladder_n_def 2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n  < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n  < ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) v\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 < ?v2; ?v2 < Suc (length L)\\<rbrakk>\n  \\<Longrightarrow> ladder_n\n                     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n                     ?u2\n                    < ladder_n\n                       (L @\n                        [mk_deriv_intro ix (Suc (length D + length E)) j])\n                       ?v2\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "note ladder_n_ineqs = ladder_n_ineqs this"], ["proof (state)\nthis:\n  ?u2 < Suc (length L) \\<Longrightarrow>\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) ?u2\n  \\<le> Suc (length D + length E)\n  \\<lbrakk>?u2 < ?v2; ?v2 < Suc (length L)\\<rbrakk>\n  \\<Longrightarrow> ladder_n\n                     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n                     ?u2\n                    < ladder_n\n                       (L @\n                        [mk_deriv_intro ix (Suc (length D + length E)) j])\n                       ?v2\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "have is_ladder: \n    \"is_ladder (D @ (i, r) # E) (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "apply (auto simp add: is_ladder_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u.\n       u < Suc (length L) \\<Longrightarrow>\n       ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n       \\<le> Suc (length D + length E)\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < Suc (length L)\\<rbrakk>\n       \\<Longrightarrow> ladder_n L u\n                         < ladder_n\n                            (L @\n                             [mk_deriv_intro ix (Suc (length D + length E))\n                               j])\n                            v\n 3. ladder_last_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) =\n    Suc (length D + length E)", "using ladder_n_ineqs"], ["proof (prove)\nusing this:\n  ?u2 < Suc (length L) \\<Longrightarrow>\n  ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) ?u2\n  \\<le> Suc (length D + length E)\n  \\<lbrakk>?u2 < ?v2; ?v2 < Suc (length L)\\<rbrakk>\n  \\<Longrightarrow> ladder_n\n                     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n                     ?u2\n                    < ladder_n\n                       (L @\n                        [mk_deriv_intro ix (Suc (length D + length E)) j])\n                       ?v2\n\ngoal (3 subgoals):\n 1. \\<And>u.\n       u < Suc (length L) \\<Longrightarrow>\n       ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n       \\<le> Suc (length D + length E)\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < Suc (length L)\\<rbrakk>\n       \\<Longrightarrow> ladder_n L u\n                         < ladder_n\n                            (L @\n                             [mk_deriv_intro ix (Suc (length D + length E))\n                               j])\n                            v\n 3. ladder_last_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) =\n    Suc (length D + length E)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                u < Suc (length L) \\<Longrightarrow>\n                ladder_n\n                 (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) u\n                \\<le> Suc (length D + length E);\n     \\<And>u v.\n        \\<lbrakk>u < v; v < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> ladder_n L u\n                          < ladder_n\n                             (L @\n                              [mk_deriv_intro ix (Suc (length D + length E))\n                                j])\n                             v\\<rbrakk>\n    \\<Longrightarrow> ladder_last_n\n                       (L @\n                        [mk_deriv_intro ix (Suc (length D + length E)) j]) =\n                      Suc (length D + length E)", "apply (simp add: ladder_last_n_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_ladder (D @ (i, r) # E)\n   (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "have is_ladder_L: \"is_ladder D L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder D L", "using LeftDerivationLadder_def prems.prems(1)"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder a D L \\<alpha>\n\ngoal (1 subgoal):\n 1. is_ladder D L", "by blast"], ["proof (state)\nthis:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "have ladder_last_n_eq_length: \"ladder_last_n L = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_n L = length D", "using is_ladder_L is_ladder_def"], ["proof (prove)\nusing this:\n  is_ladder D L\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. ladder_last_n L = length D", "by blast"], ["proof (state)\nthis:\n  ladder_last_n L = length D\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "have L_not_empty: \"L \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<noteq> []", "using LeftDerivationLadder_def is_ladder_def prems(1)"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  LeftDerivationLadder a D L \\<alpha>\n\ngoal (1 subgoal):\n 1. L \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "{"], ["proof (state)\nthis:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "assume index_ge: \"Suc 0 \\<le> index\""], ["proof (state)\nthis:\n  Suc 0 \\<le> index\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "assume \"index < Suc (length L)\""], ["proof (state)\nthis:\n  index < Suc (length L)\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "then"], ["proof (chain)\npicking this:\n  index < Suc (length L)", "have \"index < length L \\<or> index = length L\""], ["proof (prove)\nusing this:\n  index < Suc (length L)\n\ngoal (1 subgoal):\n 1. index < length L \\<or> index = length L", "by arith"], ["proof (state)\nthis:\n  index < length L \\<or> index = length L\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "then"], ["proof (chain)\npicking this:\n  index < length L \\<or> index = length L", "have \"LeftDerivationIntrosAt a (D @ (i, r) # E) \n      (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index\""], ["proof (prove)\nusing this:\n  index < length L \\<or> index = length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. index < length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index\n 2. index = length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "case 1"], ["proof (state)\nthis:\n  index < length L\n\ngoal (2 subgoals):\n 1. index < length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index\n 2. index = length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "then"], ["proof (chain)\npicking this:\n  index < length L", "show ?case"], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "using LeftDerivationIntrosAt_ignore_appendix\n          LeftDerivationIntros_def LeftDerivationLadder_def One_nat_def \n          index_ge prems.prems(1)"], ["proof (prove)\nusing this:\n  index < length L\n  \\<lbrakk>is_ladder ?D ?L; LeftDerivationIntrosAt ?a ?D ?L ?index;\n   1 \\<le> ?index; ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt ?a (?D @ ?D') (?L @ ?L') ?index\n  LeftDerivationIntros ?a ?D ?L =\n  (\\<forall>index.\n      1 \\<le> index \\<and> index < length ?L \\<longrightarrow>\n      LeftDerivationIntrosAt ?a ?D ?L index)\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  1 = Suc 0\n  Suc 0 \\<le> index\n  LeftDerivationLadder a D L \\<alpha>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "by presburger"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt a (D @ (i, r) # E)\n   (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index\n\ngoal (1 subgoal):\n 1. index = length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. index = length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "case 2"], ["proof (state)\nthis:\n  index = length L\n\ngoal (1 subgoal):\n 1. index = length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "have min_simp:  \"\\<And> n E. min n (Suc (n + length E)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n E. min n (Suc (n + length E)) = n", "by auto"], ["proof (state)\nthis:\n  min ?n (Suc (?n + length ?E)) = ?n\n\ngoal (1 subgoal):\n 1. index = length L \\<Longrightarrow>\n    LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "with 2 prems is_ladder_L ladder_last_n_eq_length"], ["proof (chain)\npicking this:\n  index = length L\n  LeftDerivationLadder a D L \\<alpha>\n  ladder_last_j L = i\n  LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\n  is_ladder D L\n  ladder_last_n L = length D\n  min ?n (Suc (?n + length ?E)) = ?n", "show ?case"], ["proof (prove)\nusing this:\n  index = length L\n  LeftDerivationLadder a D L \\<alpha>\n  ladder_last_j L = i\n  LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\n  is_ladder D L\n  ladder_last_n L = length D\n  min ?n (Suc (?n + length ?E)) = ?n\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "apply (simp add: LeftDerivationIntrosAt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index = length L; LeftDerivationLadder a D L \\<alpha>;\n     ladder_last_j L = i; LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>;\n     is_ladder D L; ladder_last_n L = length D;\n     \\<And>n E. min n (Suc (n + length E)) = n\\<rbrakk>\n    \\<Longrightarrow> let i = ladder_i\n                               (L @\n                                [mk_deriv_intro ix\n                                  (Suc (length D + length E)) j])\n                               (length L);\n                          n = ladder_n\n                               (L @\n                                [mk_deriv_intro ix\n                                  (Suc (length D + length E)) j])\n                               (length L - Suc 0);\n                          e = (D @ (i, r) # E) ! n\n                      in i = fst e \\<and>\n                         LeftDerivationIntro\n                          (ladder_\\<alpha> a (D @ (i, r) # E)\n                            (L @\n                             [mk_deriv_intro ix (Suc (length D + length E))\n                               j])\n                            (length L))\n                          i (snd e)\n                          (ladder_ix\n                            (L @\n                             [mk_deriv_intro ix (Suc (length D + length E))\n                               j])\n                            (length L))\n                          (drop (Suc n) D @\n                           drop\n                            (Suc n -\n                             min (length D) (Suc (length D + length E)))\n                            ((i, r) # E))\n                          j (ladder_\\<gamma> a (D @ (i, r) # E)\n                              (L @\n                               [mk_deriv_intro ix\n                                 (Suc (length D + length E)) j])\n                              (length L))", "apply (simp add: L_not_empty ladder_i_eq_last_j ladder_last_n_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index = length L; LeftDerivationLadder a D L \\<alpha>;\n     ladder_last_j L = i; LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>;\n     is_ladder D L; ladder_last_n L = length D;\n     \\<And>n E. min n (Suc (n + length E)) = n\\<rbrakk>\n    \\<Longrightarrow> let n = length D; e = (i, r)\n                      in LeftDerivationIntro\n                          (ladder_\\<alpha> a (D @ e # E)\n                            (L @ [mk_deriv_intro ix (Suc (n + length E)) j])\n                            (length L))\n                          i r ix\n                          (drop (Suc n - min n (Suc (n + length E)))\n                            (e # E))\n                          j (ladder_\\<gamma> a (D @ e # E)\n                              (L @\n                               [mk_deriv_intro ix (Suc (n + length E)) j])\n                              (length L))", "apply (simp add: ladder_\\<alpha>_full min_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index = length L; LeftDerivationLadder a D L \\<alpha>;\n     ladder_last_j L = i; LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>;\n     is_ladder D L; ladder_last_n L = length D\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationIntro (Derive a D) i r ix E j\n                       (ladder_\\<gamma> a (D @ (i, r) # E)\n                         (L @\n                          [mk_deriv_intro ix (Suc (length D + length E)) j])\n                         (length L))", "apply (simp add: ladder_\\<gamma>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index = length L; LeftDerivationLadder a D L \\<alpha>;\n     ladder_last_j L = i; LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>;\n     is_ladder D L; ladder_last_n L = length D\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationIntro (Derive a D) i r ix E j\n                       (Derive a (D @ (i, r) # E))", "by (metis Derive LeftDerivationIntro_implies_LeftDerivation LeftDerivationLadder_def \n          LeftDerivation_implies_Derivation LeftDerivation_implies_append)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt a (D @ (i, r) # E)\n   (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt a (D @ (i, r) # E)\n   (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Suc 0 \\<le> ?index2; ?index2 < Suc (length L)\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n                     ?index2\n\ngoal (1 subgoal):\n 1. \\<And>a D L \\<alpha> i r ix E j \\<gamma>.\n       \\<lbrakk>LeftDerivationLadder a D L \\<alpha>; ladder_last_j L = i;\n        LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationLadder a (D @ [(i, r)] @ E)\n                          (L @\n                           [mk_deriv_intro ix (Suc (length D + length E))\n                             j])\n                          \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc 0 \\<le> ?index2; ?index2 < Suc (length L)\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n                     ?index2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc 0 \\<le> ?index2; ?index2 < Suc (length L)\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n                     ?index2\n\ngoal (1 subgoal):\n 1. LeftDerivationLadder a (D @ [(i, r)] @ E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) \\<gamma>", "apply (auto simp add: LeftDerivationLadder_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivation a (D @ (i, r) # E) \\<gamma>\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    is_ladder (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n 3. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 4. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "using prems"], ["proof (prove)\nusing this:\n  LeftDerivationLadder a D L \\<alpha>\n  ladder_last_j L = i\n  LeftDerivationIntro \\<alpha> i r ix E j \\<gamma>\n\ngoal (4 subgoals):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivation a (D @ (i, r) # E) \\<gamma>\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    is_ladder (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n 3. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 4. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "apply (auto simp add: LeftDerivationLadder_def)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>index.\n                \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n                \\<Longrightarrow> LeftDerivationIntrosAt a\n                                   (D @ (ladder_last_j L, r) # E)\n                                   (L @\n                                    [mk_deriv_intro ix\n(Suc (length D + length E)) j])\n                                   index;\n     LeftDerivationIntro \\<alpha> (ladder_last_j L) r ix E j \\<gamma>;\n     i = ladder_last_j L; LeftDerivation a D \\<alpha>; is_ladder D L;\n     LeftDerivationFix a (ladder_i L 0) (take (ladder_n L 0) D)\n      (ladder_j L 0) (ladder_\\<gamma> a D L 0);\n     LeftDerivationIntros a D L\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation a (D @ (ladder_last_j L, r) # E)\n                       \\<gamma>\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    is_ladder (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n 3. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 4. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "using LeftDerivationFix_def LeftDerivationIntro_def LeftDerivation_append"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n  LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<gamma> =\n  (\\<exists>\\<beta>.\n      LeftDerives1 ?\\<alpha> ?i ?r \\<beta> \\<and>\n      ?ix < length (snd ?r) \\<and>\n      snd ?r ! ?ix = ?\\<gamma> ! ?j \\<and>\n      LeftDerivationFix \\<beta> (?i + ?ix) ?D ?j ?\\<gamma>)\n  LeftDerivation ?a (?D @ ?E) ?c =\n  (\\<exists>b. LeftDerivation ?a ?D b \\<and> LeftDerivation b ?E ?c)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>index.\n                \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n                \\<Longrightarrow> LeftDerivationIntrosAt a\n                                   (D @ (ladder_last_j L, r) # E)\n                                   (L @\n                                    [mk_deriv_intro ix\n(Suc (length D + length E)) j])\n                                   index;\n     LeftDerivationIntro \\<alpha> (ladder_last_j L) r ix E j \\<gamma>;\n     i = ladder_last_j L; LeftDerivation a D \\<alpha>; is_ladder D L;\n     LeftDerivationFix a (ladder_i L 0) (take (ladder_n L 0) D)\n      (ladder_j L 0) (ladder_\\<gamma> a D L 0);\n     LeftDerivationIntros a D L\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation a (D @ (ladder_last_j L, r) # E)\n                       \\<gamma>\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    is_ladder (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n 3. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 4. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    is_ladder (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 3. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "using is_ladder"], ["proof (prove)\nusing this:\n  is_ladder (D @ (i, r) # E)\n   (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n\ngoal (3 subgoals):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    is_ladder (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 3. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "using L_not_empty"], ["proof (prove)\nusing this:\n  L \\<noteq> []\n\ngoal (2 subgoals):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationFix a\n     (ladder_i (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n       D @\n      take\n       (ladder_n (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0 -\n        length D)\n       ((i, r) # E))\n     (ladder_j (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n     (ladder_\\<gamma> a (D @ (i, r) # E)\n       (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) 0)\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>index.\n                \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n                \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                                   (L @\n                                    [mk_deriv_intro ix\n(Suc (length D + length E)) j])\n                                   index;\n     L \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationFix a (ladder_i L 0)\n                       (take (ladder_n L 0) D @\n                        take (ladder_n L 0 - length D) ((i, r) # E))\n                       (ladder_j L 0)\n                       (ladder_\\<gamma> a (D @ (i, r) # E) L 0)\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "using LeftDerivationLadder_def LeftDerivationLadder_ladder_n_bound ladder_\\<gamma>_def \n      prems.prems(1)"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  \\<lbrakk>LeftDerivationLadder ?a ?D ?L ?b; ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_n ?L ?index \\<le> length ?D\n  ladder_\\<gamma> ?a ?D ?L ?index = Derive ?a (take (ladder_n ?L ?index) ?D)\n  LeftDerivationLadder a D L \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>index.\n                \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n                \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                                   (L @\n                                    [mk_deriv_intro ix\n(Suc (length D + length E)) j])\n                                   index;\n     L \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationFix a (ladder_i L 0)\n                       (take (ladder_n L 0) D @\n                        take (ladder_n L 0 - length D) ((i, r) # E))\n                       (ladder_j L 0)\n                       (ladder_\\<gamma> a (D @ (i, r) # E) L 0)\n 2. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    LeftDerivationIntros a (D @ (i, r) # E)\n     (L @ [mk_deriv_intro ix (Suc (length D + length E)) j])", "apply (subst LeftDerivationIntros_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>index.\n        \\<lbrakk>Suc 0 \\<le> index; index < Suc (length L)\\<rbrakk>\n        \\<Longrightarrow> LeftDerivationIntrosAt a (D @ (i, r) # E)\n                           (L @\n                            [mk_deriv_intro ix (Suc (length D + length E))\n                              j])\n                           index) \\<Longrightarrow>\n    \\<forall>index.\n       1 \\<le> index \\<and>\n       index\n       < length\n          (L @\n           [mk_deriv_intro ix (Suc (length D + length E))\n             j]) \\<longrightarrow>\n       LeftDerivationIntrosAt a (D @ (i, r) # E)\n        (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) index", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LeftDerivationLadder a (D @ [(i, r)] @ E)\n   (L @ [mk_deriv_intro ix (Suc (length D + length E)) j]) \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_bounds_ij: \n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<beta> \\<Longrightarrow> i < length \\<alpha> \\<and> j < length \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<beta> \\<Longrightarrow>\n    i < length \\<alpha> \\<and> j < length \\<beta>", "by (meson Derives1_bound LeftDerivationFix_def LeftDerivationIntro_def \n    LeftDerives1_implies_Derives1)"], ["", "theorem LeftDerivationLadder_exists: \"LeftDerivation a D \\<gamma> \\<Longrightarrow> is_sentence \\<gamma> \\<Longrightarrow> j < length \\<gamma> \\<Longrightarrow> \n  \\<exists> L. LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n     j < length \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L.\n                         LeftDerivationLadder a D L \\<gamma> \\<and>\n                         ladder_last_j L = j", "proof (induct \"length D\" arbitrary: a D \\<gamma> j rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D a \\<gamma> j.\n       \\<lbrakk>\\<And>Da a \\<gamma> j.\n                   \\<lbrakk>length Da < length D;\n                    LeftDerivation a Da \\<gamma>; is_sentence \\<gamma>;\n                    j < length \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>L.\n  LeftDerivationLadder a Da L \\<gamma> \\<and> ladder_last_j L = j;\n        LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n        j < length \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L.\n                            LeftDerivationLadder a D L \\<gamma> \\<and>\n                            ladder_last_j L = j", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>length ?D < length D; LeftDerivation ?a ?D ?\\<gamma>;\n   is_sentence ?\\<gamma>; ?j < length ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>L.\n                       LeftDerivationLadder ?a ?D L ?\\<gamma> \\<and>\n                       ladder_last_j L = ?j\n  LeftDerivation a D \\<gamma>\n  is_sentence \\<gamma>\n  j < length \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>D a \\<gamma> j.\n       \\<lbrakk>\\<And>Da a \\<gamma> j.\n                   \\<lbrakk>length Da < length D;\n                    LeftDerivation a Da \\<gamma>; is_sentence \\<gamma>;\n                    j < length \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>L.\n  LeftDerivationLadder a Da L \\<gamma> \\<and> ladder_last_j L = j;\n        LeftDerivation a D \\<gamma>; is_sentence \\<gamma>;\n        j < length \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L.\n                            LeftDerivationLadder a D L \\<gamma> \\<and>\n                            ladder_last_j L = j", "from LeftDerivationFixOrIntro[OF less(2,3,4)]"], ["proof (chain)\npicking this:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>i. LeftDerivationFix a i D j \\<gamma>) \\<or>\n  (\\<exists>d \\<alpha> ix.\n      d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n       (drop (Suc d) D) j \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\n 2. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "case 1"], ["proof (state)\nthis:\n  \\<exists>i. LeftDerivationFix a i D j \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<exists>i. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\n 2. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. LeftDerivationFix a i D j \\<gamma>", "obtain i where \"LeftDerivationFix a i D j \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<exists>i. LeftDerivationFix a i D j \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix a i D j \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<exists>i. LeftDerivationFix a i D j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\n 2. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "using \"1.hyps\" LeftDerivationFix_implies_ex_ladder"], ["proof (prove)\nusing this:\n  \\<exists>i. LeftDerivationFix a i D j \\<gamma>\n  LeftDerivationFix ?a ?i ?D ?j ?\\<gamma> \\<Longrightarrow>\n  \\<exists>L.\n     LeftDerivationLadder ?a ?D L ?\\<gamma> \\<and>\n     ladder_last_j L = ?j \\<and> ladder_last_n L = length ?D\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "by blast"], ["proof (state)\nthis:\n  \\<exists>L. LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "case 2"], ["proof (state)\nthis:\n  \\<exists>d \\<alpha> ix.\n     d < length D \\<and>\n     LeftDerivation a (take d D) \\<alpha> \\<and>\n     LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n      (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "then"], ["proof (chain)\npicking this:\n  \\<exists>d \\<alpha> ix.\n     d < length D \\<and>\n     LeftDerivation a (take d D) \\<alpha> \\<and>\n     LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n      (drop (Suc d) D) j \\<gamma>", "obtain d \\<alpha> ix where inductrule: \"d < length D \\<and>\n      LeftDerivation a (take d D) \\<alpha> \\<and>\n      LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<exists>d \\<alpha> ix.\n     d < length D \\<and>\n     LeftDerivation a (take d D) \\<alpha> \\<and>\n     LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n      (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>d \\<alpha> ix.\n        d < length D \\<and>\n        LeftDerivation a (take d D) \\<alpha> \\<and>\n        LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n         (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  d < length D \\<and>\n  LeftDerivation a (take d D) \\<alpha> \\<and>\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "then"], ["proof (chain)\npicking this:\n  d < length D \\<and>\n  LeftDerivation a (take d D) \\<alpha> \\<and>\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>", "have less_length_D: \"length (take d D) < length D\" \n      and LeftDerivation_\\<alpha>: \"LeftDerivation a (take d D) \\<alpha>\""], ["proof (prove)\nusing this:\n  d < length D \\<and>\n  LeftDerivation a (take d D) \\<alpha> \\<and>\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. length (take d D) < length D &&& LeftDerivation a (take d D) \\<alpha>", "by auto"], ["proof (state)\nthis:\n  length (take d D) < length D\n  LeftDerivation a (take d D) \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "have is_sentence_\\<alpha>: \"is_sentence \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "using LeftDerivationIntro_is_sentence inductrule"], ["proof (prove)\nusing this:\n  LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<gamma> \\<Longrightarrow>\n  is_sentence ?\\<alpha> \\<and> is_sentence ?\\<gamma>\n  d < length D \\<and>\n  LeftDerivation a (take d D) \\<alpha> \\<and>\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "have \"fst (D ! d) < length \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (D ! d) < length \\<alpha>", "using LeftDerivationIntro_bounds_ij inductrule"], ["proof (prove)\nusing this:\n  LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<beta> \\<Longrightarrow>\n  ?i < length ?\\<alpha> \\<and> ?j < length ?\\<beta>\n  d < length D \\<and>\n  LeftDerivation a (take d D) \\<alpha> \\<and>\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. fst (D ! d) < length \\<alpha>", "by blast"], ["proof (state)\nthis:\n  fst (D ! d) < length \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "from less(1)[OF less_length_D LeftDerivation_\\<alpha> is_sentence_\\<alpha>, where j=\" fst (D ! d)\", OF this]"], ["proof (chain)\npicking this:\n  \\<exists>L.\n     LeftDerivationLadder a (take d D) L \\<alpha> \\<and>\n     ladder_last_j L = fst (D ! d)", "obtain L where induct_Ladder:\n      \"LeftDerivationLadder a (take d D) L \\<alpha>\" and induct_last: \"ladder_last_j L = fst (D ! d)\""], ["proof (prove)\nusing this:\n  \\<exists>L.\n     LeftDerivationLadder a (take d D) L \\<alpha> \\<and>\n     ladder_last_j L = fst (D ! d)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>LeftDerivationLadder a (take d D) L \\<alpha>;\n         ladder_last_j L = fst (D ! d)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivationLadder a (take d D) L \\<alpha>\n  ladder_last_j L = fst (D ! d)\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "have induct_intro: \"LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix (drop (Suc d) D) j \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n     (drop (Suc d) D) j \\<gamma>", "using inductrule"], ["proof (prove)\nusing this:\n  d < length D \\<and>\n  LeftDerivation a (take d D) \\<alpha> \\<and>\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n     (drop (Suc d) D) j \\<gamma>", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "have \"d < length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length D", "using inductrule"], ["proof (prove)\nusing this:\n  d < length D \\<and>\n  LeftDerivation a (take d D) \\<alpha> \\<and>\n  LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n   (drop (Suc d) D) j \\<gamma>\n\ngoal (1 subgoal):\n 1. d < length D", "by blast"], ["proof (state)\nthis:\n  d < length D\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "then"], ["proof (chain)\npicking this:\n  d < length D", "have simp_to_D: \"take d D @ D ! d # drop (Suc d) D = D\""], ["proof (prove)\nusing this:\n  d < length D\n\ngoal (1 subgoal):\n 1. take d D @ D ! d # drop (Suc d) D = D", "using id_take_nth_drop"], ["proof (prove)\nusing this:\n  d < length D\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (1 subgoal):\n 1. take d D @ D ! d # drop (Suc d) D = D", "by force"], ["proof (state)\nthis:\n  take d D @ D ! d # drop (Suc d) D = D\n\ngoal (1 subgoal):\n 1. \\<exists>d \\<alpha> ix.\n       d < length D \\<and>\n       LeftDerivation a (take d D) \\<alpha> \\<and>\n       LeftDerivationIntro \\<alpha> (fst (D ! d)) (snd (D ! d)) ix\n        (drop (Suc d) D) j \\<gamma> \\<Longrightarrow>\n    \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "from LeftDerivationLadder_grow[OF induct_Ladder induct_last induct_intro] simp_to_D"], ["proof (chain)\npicking this:\n  LeftDerivationLadder a\n   (take d D @ [(fst (D ! d), snd (D ! d))] @ drop (Suc d) D)\n   (L @\n    [mk_deriv_intro ix (Suc (length (take d D) + length (drop (Suc d) D)))\n      j])\n   \\<gamma>\n  take d D @ D ! d # drop (Suc d) D = D", "show ?case"], ["proof (prove)\nusing this:\n  LeftDerivationLadder a\n   (take d D @ [(fst (D ! d), snd (D ! d))] @ drop (Suc d) D)\n   (L @\n    [mk_deriv_intro ix (Suc (length (take d D) + length (drop (Suc d) D)))\n      j])\n   \\<gamma>\n  take d D @ D ! d # drop (Suc d) D = D\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivationLadder a D\n              (L @\n               [mk_deriv_intro ix\n                 (Suc (min (length D) d + (length D - Suc d))) j])\n              \\<gamma>;\n     take d D @ D ! d # drop (Suc d) D = D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L.\n                         LeftDerivationLadder a D L \\<gamma> \\<and>\n                         ladder_last_j L = j", "apply (rule_tac x=\n        \"L @ [mk_deriv_intro ix (Suc (min (length D) d + (length D - Suc d))) j]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivationLadder a D\n              (L @\n               [mk_deriv_intro ix\n                 (Suc (min (length D) d + (length D - Suc d))) j])\n              \\<gamma>;\n     take d D @ D ! d # drop (Suc d) D = D\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationLadder a D\n                       (L @\n                        [mk_deriv_intro ix\n                          (Suc (min (length D) d + (length D - Suc d))) j])\n                       \\<gamma> \\<and>\n                      ladder_last_j\n                       (L @\n                        [mk_deriv_intro ix\n                          (Suc (min (length D) d + (length D - Suc d)))\n                          j]) =\n                      j", "apply (simp add: ladder_last_j_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>L. LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>L. LeftDerivationLadder a D L \\<gamma> \\<and> ladder_last_j L = j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationLadder_L_0: \n  assumes \"LeftDerivationLadder \\<alpha> D L \\<beta>\"\n  assumes \"length L = 1\"\n  shows \"\\<exists> i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>", "have \"is_ladder D L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder D L", "using assms"], ["proof (prove)\nusing this:\n  LeftDerivationLadder \\<alpha> D L \\<beta>\n  length L = 1\n\ngoal (1 subgoal):\n 1. is_ladder D L", "by (auto simp add: LeftDerivationLadder_def)"], ["proof (state)\nthis:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>", "then"], ["proof (chain)\npicking this:\n  is_ladder D L", "have ladder_n: \"ladder_n L 0 = length D\""], ["proof (prove)\nusing this:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. ladder_n L 0 = length D", "by (simp add: assms(2) is_ladder_def ladder_last_n_def)"], ["proof (state)\nthis:\n  ladder_n L 0 = length D\n\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>", "apply (rule_tac x = \"ladder_i L 0\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L 0) D (ladder_last_j L) \\<beta>", "using assms(1)"], ["proof (prove)\nusing this:\n  LeftDerivationLadder \\<alpha> D L \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L 0) D (ladder_last_j L) \\<beta>", "apply (auto simp add: LeftDerivationLadder_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivation \\<alpha> D \\<beta>; is_ladder D L;\n     LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n      (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0);\n     LeftDerivationIntros \\<alpha> D L\\<rbrakk>\n    \\<Longrightarrow> LeftDerivationFix \\<alpha> (ladder_i L 0) D\n                       (ladder_last_j L) \\<beta>", "by (metis Derive LeftDerivationFix_def LeftDerivation_implies_Derivation One_nat_def assms(2) \n      diff_Suc_1 ladder_last_j_def ladder_n order_refl take_all)"], ["proof (state)\nthis:\n  \\<exists>i. LeftDerivationFix \\<alpha> i D (ladder_last_j L) \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFix_splits_at_derives:\n  assumes \"LeftDerivationFix a i D j b\"\n  shows \"\\<exists> U a1 a2 b1 b2. splits_at a i a1 U a2 \\<and> splits_at b j b1 U b2 \\<and> \n    derives a1 b1 \\<and> derives a2 b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and> derives a1 b1 \\<and> derives a2 b2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and> derives a1 b1 \\<and> derives a2 b2", "note hyp = LeftDerivationFix_def[where \\<alpha>=a and \\<beta>=b and D=D and i=i and j=j]"], ["proof (state)\nthis:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and> derives a1 b1 \\<and> derives a2 b2", "from hyp"], ["proof (chain)\npicking this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))", "obtain E F where EF:\n    \"D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take i a) E (take j b) \\<and> LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\""], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i a) E (take j b) \\<and>\n        LeftDerivation (drop (Suc i) a) F (drop (Suc j) b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  LeftDerivationFix a i D j b\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i a) E (take j b) \\<and>\n        LeftDerivation (drop (Suc i) a) F (drop (Suc j) b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and> derives a1 b1 \\<and> derives a2 b2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and> derives a1 b1 \\<and> derives a2 b2", "apply (rule_tac x=\"a ! i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a1 a2 b1 b2.\n       splits_at a i a1 (a ! i) a2 \\<and>\n       splits_at b j b1 (a ! i) b2 \\<and> derives a1 b1 \\<and> derives a2 b2", "apply (rule_tac x=\"take i a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a2 b1 b2.\n       splits_at a i (take i a) (a ! i) a2 \\<and>\n       splits_at b j b1 (a ! i) b2 \\<and>\n       derives (take i a) b1 \\<and> derives a2 b2", "apply (rule_tac x=\"drop (Suc i) a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1 b2.\n       splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n       splits_at b j b1 (a ! i) b2 \\<and>\n       derives (take i a) b1 \\<and> derives (drop (Suc i) a) b2", "apply (rule_tac x=\"take j b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b2.\n       splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n       splits_at b j (take j b) (a ! i) b2 \\<and>\n       derives (take i a) (take j b) \\<and> derives (drop (Suc i) a) b2", "apply (rule_tac x=\"drop (Suc j) b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n    splits_at b j (take j b) (a ! i) (drop (Suc j) b) \\<and>\n    derives (take i a) (take j b) \\<and>\n    derives (drop (Suc i) a) (drop (Suc j) b)", "using Derivation_implies_derives LeftDerivation_implies_Derivation assms hyp \n      splits_at_def"], ["proof (prove)\nusing this:\n  Derivation ?a ?D ?b \\<Longrightarrow> derives ?a ?b\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n    splits_at b j (take j b) (a ! i) (drop (Suc j) b) \\<and>\n    derives (take i a) (take j b) \\<and>\n    derives (drop (Suc i) a) (drop (Suc j) b)", "by blast"], ["proof (state)\nthis:\n  \\<exists>U a1 a2 b1 b2.\n     splits_at a i a1 U a2 \\<and>\n     splits_at b j b1 U b2 \\<and> derives a1 b1 \\<and> derives a2 b2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  LeftDerivation_append_suffix:\n  \"LeftDerivation a D b \\<Longrightarrow> is_sentence c \\<Longrightarrow> LeftDerivation (a@c) D (b@c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c)", "proof (induct D arbitrary: a b c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>LeftDerivation a [] b; is_sentence c\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation (a @ c) [] (b @ c)\n 2. \\<And>a D aa b c.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        LeftDerivation aa (a # D) b; is_sentence c\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation (aa @ c) (a # D) (b @ c)", "case Nil"], ["proof (state)\nthis:\n  LeftDerivation a [] b\n  is_sentence c\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>LeftDerivation a [] b; is_sentence c\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation (a @ c) [] (b @ c)\n 2. \\<And>a D aa b c.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        LeftDerivation aa (a # D) b; is_sentence c\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation (aa @ c) (a # D) (b @ c)", "then"], ["proof (chain)\npicking this:\n  LeftDerivation a [] b\n  is_sentence c", "show ?case"], ["proof (prove)\nusing this:\n  LeftDerivation a [] b\n  is_sentence c\n\ngoal (1 subgoal):\n 1. LeftDerivation (a @ c) [] (b @ c)", "by auto"], ["proof (state)\nthis:\n  LeftDerivation (a @ c) [] (b @ c)\n\ngoal (1 subgoal):\n 1. \\<And>a D aa b c.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        LeftDerivation aa (a # D) b; is_sentence c\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation (aa @ c) (a # D) (b @ c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a D aa b c.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        LeftDerivation aa (a # D) b; is_sentence c\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation (aa @ c) (a # D) (b @ c)", "case (Cons d D)"], ["proof (state)\nthis:\n  \\<lbrakk>LeftDerivation ?a D ?b; is_sentence ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?a @ ?c) D (?b @ ?c)\n  LeftDerivation a (d # D) b\n  is_sentence c\n\ngoal (1 subgoal):\n 1. \\<And>a D aa b c.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        LeftDerivation aa (a # D) b; is_sentence c\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation (aa @ c) (a # D) (b @ c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>LeftDerivation ?a D ?b; is_sentence ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?a @ ?c) D (?b @ ?c)\n  LeftDerivation a (d # D) b\n  is_sentence c", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerivation ?a D ?b; is_sentence ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?a @ ?c) D (?b @ ?c)\n  LeftDerivation a (d # D) b\n  is_sentence c\n\ngoal (1 subgoal):\n 1. LeftDerivation (a @ c) (d # D) (b @ c)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        is_sentence c; LeftDerives1 a (fst d) (snd d) x;\n        LeftDerivation x D b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            LeftDerives1 (a @ c) (fst d) (snd d) x \\<and>\n                            LeftDerivation x D (b @ c)", "apply (rule_tac x=\"x@c\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        is_sentence c; LeftDerives1 a (fst d) (snd d) x;\n        LeftDerivation x D b\\<rbrakk>\n       \\<Longrightarrow> LeftDerives1 (a @ c) (fst d) (snd d) (x @ c) \\<and>\n                         LeftDerivation (x @ c) D (b @ c)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        is_sentence c; LeftDerives1 a (fst d) (snd d) x;\n        LeftDerivation x D b\\<rbrakk>\n       \\<Longrightarrow> LeftDerives1 (a @ c) (fst d) (snd d) (x @ c)", "using LeftDerives1_append_suffix"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerives1 ?v ?i ?r ?w; is_sentence ?u\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 (?v @ ?u) ?i ?r (?w @ ?u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>a b c.\n                   \\<lbrakk>LeftDerivation a D b; is_sentence c\\<rbrakk>\n                   \\<Longrightarrow> LeftDerivation (a @ c) D (b @ c);\n        is_sentence c; LeftDerives1 a (fst d) (snd d) x;\n        LeftDerivation x D b\\<rbrakk>\n       \\<Longrightarrow> LeftDerives1 (a @ c) (fst d) (snd d) (x @ c)", "by simp"], ["proof (state)\nthis:\n  LeftDerivation (a @ c) (d # D) (b @ c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivation_impossible: \"LeftDerivation a D b \\<Longrightarrow> i < length a \\<Longrightarrow> \n  is_nonterminal (a ! i) \\<Longrightarrow> derivation_ge D (Suc i) \\<Longrightarrow> D = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivation a D b; i < length a; is_nonterminal (a ! i);\n     derivation_ge D (Suc i)\\<rbrakk>\n    \\<Longrightarrow> D = []", "proof (induct D)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>LeftDerivation a [] b; i < length a; is_nonterminal (a ! i);\n     derivation_ge [] (Suc i)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>aa D.\n       \\<lbrakk>\\<lbrakk>LeftDerivation a D b; i < length a;\n                 is_nonterminal (a ! i); derivation_ge D (Suc i)\\<rbrakk>\n                \\<Longrightarrow> D = [];\n        LeftDerivation a (aa # D) b; i < length a; is_nonterminal (a ! i);\n        derivation_ge (aa # D) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> aa # D = []", "case Nil"], ["proof (state)\nthis:\n  LeftDerivation a [] b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge [] (Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>LeftDerivation a [] b; i < length a; is_nonterminal (a ! i);\n     derivation_ge [] (Suc i)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>aa D.\n       \\<lbrakk>\\<lbrakk>LeftDerivation a D b; i < length a;\n                 is_nonterminal (a ! i); derivation_ge D (Suc i)\\<rbrakk>\n                \\<Longrightarrow> D = [];\n        LeftDerivation a (aa # D) b; i < length a; is_nonterminal (a ! i);\n        derivation_ge (aa # D) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> aa # D = []", "then"], ["proof (chain)\npicking this:\n  LeftDerivation a [] b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge [] (Suc i)", "show ?case"], ["proof (prove)\nusing this:\n  LeftDerivation a [] b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge [] (Suc i)\n\ngoal (1 subgoal):\n 1. [] = []", "by auto"], ["proof (state)\nthis:\n  [] = []\n\ngoal (1 subgoal):\n 1. \\<And>aa D.\n       \\<lbrakk>\\<lbrakk>LeftDerivation a D b; i < length a;\n                 is_nonterminal (a ! i); derivation_ge D (Suc i)\\<rbrakk>\n                \\<Longrightarrow> D = [];\n        LeftDerivation a (aa # D) b; i < length a; is_nonterminal (a ! i);\n        derivation_ge (aa # D) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> aa # D = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa D.\n       \\<lbrakk>\\<lbrakk>LeftDerivation a D b; i < length a;\n                 is_nonterminal (a ! i); derivation_ge D (Suc i)\\<rbrakk>\n                \\<Longrightarrow> D = [];\n        LeftDerivation a (aa # D) b; i < length a; is_nonterminal (a ! i);\n        derivation_ge (aa # D) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> aa # D = []", "case (Cons d D)"], ["proof (state)\nthis:\n  \\<lbrakk>LeftDerivation a D b; i < length a; is_nonterminal (a ! i);\n   derivation_ge D (Suc i)\\<rbrakk>\n  \\<Longrightarrow> D = []\n  LeftDerivation a (d # D) b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge (d # D) (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>aa D.\n       \\<lbrakk>\\<lbrakk>LeftDerivation a D b; i < length a;\n                 is_nonterminal (a ! i); derivation_ge D (Suc i)\\<rbrakk>\n                \\<Longrightarrow> D = [];\n        LeftDerivation a (aa # D) b; i < length a; is_nonterminal (a ! i);\n        derivation_ge (aa # D) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> aa # D = []", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>LeftDerivation a D b; i < length a; is_nonterminal (a ! i);\n   derivation_ge D (Suc i)\\<rbrakk>\n  \\<Longrightarrow> D = []\n  LeftDerivation a (d # D) b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge (d # D) (Suc i)", "have lm: \"\\<And> j. leftmost j a \\<Longrightarrow> j \\<le> i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerivation a D b; i < length a; is_nonterminal (a ! i);\n   derivation_ge D (Suc i)\\<rbrakk>\n  \\<Longrightarrow> D = []\n  LeftDerivation a (d # D) b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge (d # D) (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>j. leftmost j a \\<Longrightarrow> j \\<le> i", "by (metis Derives1_sentence1 LeftDerivation.simps(2) LeftDerives1_implies_Derives1 \n      leftmost_exists leftmost_unique)"], ["proof (state)\nthis:\n  leftmost ?j a \\<Longrightarrow> ?j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>aa D.\n       \\<lbrakk>\\<lbrakk>LeftDerivation a D b; i < length a;\n                 is_nonterminal (a ! i); derivation_ge D (Suc i)\\<rbrakk>\n                \\<Longrightarrow> D = [];\n        LeftDerivation a (aa # D) b; i < length a; is_nonterminal (a ! i);\n        derivation_ge (aa # D) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> aa # D = []", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>LeftDerivation a D b; i < length a; is_nonterminal (a ! i);\n   derivation_ge D (Suc i)\\<rbrakk>\n  \\<Longrightarrow> D = []\n  LeftDerivation a (d # D) b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge (d # D) (Suc i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerivation a D b; i < length a; is_nonterminal (a ! i);\n   derivation_ge D (Suc i)\\<rbrakk>\n  \\<Longrightarrow> D = []\n  LeftDerivation a (d # D) b\n  i < length a\n  is_nonterminal (a ! i)\n  derivation_ge (d # D) (Suc i)\n\ngoal (1 subgoal):\n 1. d # D = []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>LeftDerivation a D b;\n                 derivation_ge D (Suc i)\\<rbrakk>\n                \\<Longrightarrow> D = [];\n        i < length a; is_nonterminal (a ! i); derivation_ge (d # D) (Suc i);\n        LeftDerives1 a (fst d) (snd d) x; LeftDerivation x D b\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: derivation_ge_def LeftDerives1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>LeftDerivation a D b \\<Longrightarrow> D = []; i < length a;\n        is_nonterminal (a ! i); LeftDerivation x D b; Suc i \\<le> fst d;\n        \\<forall>d\\<in>set D. Suc i \\<le> fst d; leftmost (fst d) a;\n        Derives1 a (fst d) (snd d) x\\<rbrakk>\n       \\<Longrightarrow> False", "using lm[where j=\"fst d\"]"], ["proof (prove)\nusing this:\n  leftmost (fst d) a \\<Longrightarrow> fst d \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>LeftDerivation a D b \\<Longrightarrow> D = []; i < length a;\n        is_nonterminal (a ! i); LeftDerivation x D b; Suc i \\<le> fst d;\n        \\<forall>d\\<in>set D. Suc i \\<le> fst d; leftmost (fst d) a;\n        Derives1 a (fst d) (snd d) x\\<rbrakk>\n       \\<Longrightarrow> False", "by arith"], ["proof (state)\nthis:\n  d # D = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivation_ge_shift: \"derivation_ge (derivation_shift F 0 j) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (derivation_shift F 0 j) j", "apply (induct F)"], ["proof (prove)\ngoal (2 subgoals):\n 1. derivation_ge (derivation_shift [] 0 j) j\n 2. \\<And>a F.\n       derivation_ge (derivation_shift F 0 j) j \\<Longrightarrow>\n       derivation_ge (derivation_shift (a # F) 0 j) j", "apply (auto simp add: derivation_ge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma LeftDerivationFix_splits_at_nonterminal:\n  assumes \"LeftDerivationFix a i D j b\"\n  assumes \"is_nonterminal (a ! i)\"\n  shows \"\\<exists> U a1 a2 b1. splits_at a i a1 U a2 \\<and> splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "note hyp = LeftDerivationFix_def[where \\<alpha>=a and \\<beta>=b and D=D and i=i and j=j]"], ["proof (state)\nthis:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "from hyp"], ["proof (chain)\npicking this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))", "obtain E F where EF:\n    \"D = E @ derivation_shift F 0 (Suc j) \\<and> LeftDerivation (take i a) E (take j b) \\<and> \n      LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\""], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i a) E (take j b) \\<and>\n        LeftDerivation (drop (Suc i) a) F (drop (Suc j) b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  LeftDerivationFix a i D j b\n  is_nonterminal (a ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i a) E (take j b) \\<and>\n        LeftDerivation (drop (Suc i) a) F (drop (Suc j) b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "have \"\\<exists> \\<beta>. LeftDerivation a E \\<beta> \\<and> LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerivation a E \\<beta> \\<and>\n       LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "using EF LeftDerivation_append assms(1) hyp"], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n  LeftDerivation ?a (?D @ ?E) ?c =\n  (\\<exists>b. LeftDerivation ?a ?D b \\<and> LeftDerivation b ?E ?c)\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerivation a E \\<beta> \\<and>\n       LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<beta>.\n     LeftDerivation a E \\<beta> \\<and>\n     LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     LeftDerivation a E \\<beta> \\<and>\n     LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "obtain \\<beta> where \\<beta>_intro: \n    \"LeftDerivation a E \\<beta> \\<and> LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     LeftDerivation a E \\<beta> \\<and>\n     LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        LeftDerivation a E \\<beta> \\<and>\n        LeftDerivation \\<beta> (derivation_shift F 0 (Suc j))\n         b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivation a E \\<beta> \\<and>\n  LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "have \"LeftDerivation ((take i a)@(drop i a)) E ((take j b)@(drop i a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)", "by (metis EF LeftDerivation_append_suffix append_take_drop_id assms(1) hyp is_sentence_concat)"], ["proof (state)\nthis:\n  LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)", "have \"LeftDerivation a E ((take j b)@(drop i a))\""], ["proof (prove)\nusing this:\n  LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. LeftDerivation a E (take j b @ drop i a)", "by simp"], ["proof (state)\nthis:\n  LeftDerivation a E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "then"], ["proof (chain)\npicking this:\n  LeftDerivation a E (take j b @ drop i a)", "have \\<beta>_decomposed: \"\\<beta> = (take j b)@(drop i a)\""], ["proof (prove)\nusing this:\n  LeftDerivation a E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. \\<beta> = take j b @ drop i a", "using Derivation_unique_dest LeftDerivation_implies_Derivation \\<beta>_intro"], ["proof (prove)\nusing this:\n  LeftDerivation a E (take j b @ drop i a)\n  \\<lbrakk>Derivation ?a ?D ?b; Derivation ?a ?D ?c\\<rbrakk>\n  \\<Longrightarrow> ?b = ?c\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  LeftDerivation a E \\<beta> \\<and>\n  LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<beta> = take j b @ drop i a", "by blast"], ["proof (state)\nthis:\n  \\<beta> = take j b @ drop i a\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "then"], ["proof (chain)\npicking this:\n  \\<beta> = take j b @ drop i a", "have \"\\<beta> ! j = a ! i\""], ["proof (prove)\nusing this:\n  \\<beta> = take j b @ drop i a\n\ngoal (1 subgoal):\n 1. \\<beta> ! j = a ! i", "by (metis Cons_nth_drop_Suc assms(1) hyp length_take min.absorb2 nth_append_length \n      order.strict_implies_order)"], ["proof (state)\nthis:\n  \\<beta> ! j = a ! i\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "then"], ["proof (chain)\npicking this:\n  \\<beta> ! j = a ! i", "have is_nt: \"is_nonterminal (\\<beta> ! j)\""], ["proof (prove)\nusing this:\n  \\<beta> ! j = a ! i\n\ngoal (1 subgoal):\n 1. is_nonterminal (\\<beta> ! j)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  is_nonterminal (\\<beta> ! j)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "have index_j: \"j < length \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length \\<beta>", "using \\<beta>_decomposed assms(1) hyp"], ["proof (prove)\nusing this:\n  \\<beta> = take j b @ drop i a\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. j < length \\<beta>", "by auto"], ["proof (state)\nthis:\n  j < length \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "have derivation: \"LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "by (simp add: \\<beta>_intro)"], ["proof (state)\nthis:\n  LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "from LeftDerivation_impossible[OF derivation index_j is_nt derivation_ge_shift]"], ["proof (chain)\npicking this:\n  derivation_shift F 0 (Suc j) = []", "have F: \"F = []\""], ["proof (prove)\nusing this:\n  derivation_shift F 0 (Suc j) = []\n\ngoal (1 subgoal):\n 1. F = []", "by (metis length_0_conv length_derivation_shift)"], ["proof (state)\nthis:\n  F = []\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "then"], ["proof (chain)\npicking this:\n  F = []", "have \\<beta>_is_b: \"\\<beta> = b\""], ["proof (prove)\nusing this:\n  F = []\n\ngoal (1 subgoal):\n 1. \\<beta> = b", "using \\<beta>_intro"], ["proof (prove)\nusing this:\n  F = []\n  LeftDerivation a E \\<beta> \\<and>\n  LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<beta> = b", "by auto"], ["proof (state)\nthis:\n  \\<beta> = b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1", "apply (rule_tac x=\"a ! i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a1 a2 b1.\n       splits_at a i a1 (a ! i) a2 \\<and>\n       splits_at b j b1 (a ! i) a2 \\<and> LeftDerivation a1 D b1", "apply (rule_tac x=\"take i a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a2 b1.\n       splits_at a i (take i a) (a ! i) a2 \\<and>\n       splits_at b j b1 (a ! i) a2 \\<and> LeftDerivation (take i a) D b1", "apply (rule_tac x=\"drop (Suc i) a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1.\n       splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n       splits_at b j b1 (a ! i) (drop (Suc i) a) \\<and>\n       LeftDerivation (take i a) D b1", "apply (rule_tac x=\"take j b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n    splits_at b j (take j b) (a ! i) (drop (Suc i) a) \\<and>\n    LeftDerivation (take i a) D (take j b)", "using EF F assms(1) hyp splits_at_def"], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n  F = []\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n    splits_at b j (take j b) (a ! i) (drop (Suc i) a) \\<and>\n    LeftDerivation (take i a) D (take j b)", "by auto"], ["proof (state)\nthis:\n  \\<exists>U a1 a2 b1.\n     splits_at a i a1 U a2 \\<and>\n     splits_at b j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_implies_nonterminal: \n  \"LeftDerivationIntro \\<alpha> i (snd e) ix E j \\<gamma> \\<Longrightarrow> is_nonterminal (\\<alpha> ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i (snd e) ix E j \\<gamma> \\<Longrightarrow>\n    is_nonterminal (\\<alpha> ! i)", "by (simp add: LeftDerivationIntro_def LeftDerives1_def leftmost_is_nonterminal)"], ["", "lemma LeftDerivationIntrosAt_implies_nonterminal:\n  \"LeftDerivationIntrosAt a D L index \\<Longrightarrow> is_nonterminal((ladder_\\<alpha> a D L index) ! (ladder_i L index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt a D L index \\<Longrightarrow>\n    is_nonterminal (ladder_\\<alpha> a D L index ! ladder_i L index)", "by (meson LeftDerivationIntro_implies_nonterminal LeftDerivationIntrosAt_def)"], ["", "lemma LeftDerivationIntro_examine_rule: \n  \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma> \\<Longrightarrow> splits_at \\<alpha> i \\<alpha>1 M \\<alpha>2 \\<Longrightarrow> \n    \\<exists> \\<eta>. M = fst r \\<and> \\<eta> = snd r \\<and> (M, \\<eta>) \\<in> \\<RR>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivationIntro \\<alpha> i r ix D j \\<gamma>;\n     splits_at \\<alpha> i \\<alpha>1 M \\<alpha>2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<eta>.\n                         M = fst r \\<and>\n                         \\<eta> = snd r \\<and> (M, \\<eta>) \\<in> \\<RR>", "by (metis Derives1_nonterminal Derives1_rule LeftDerivationIntro_def LeftDerives1_implies_Derives1 \n  prod.collapse)"], ["", "lemma LeftDerivation_skip_prefixword_ex:\n  assumes \"LeftDerivation (u@v) D w\"\n  assumes \"is_word u\"\n  shows \"\\<exists> w'. w = u@w' \\<and> LeftDerivation v (derivation_shift D (length u) 0) w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w'.\n       w = u @ w' \\<and>\n       LeftDerivation v (derivation_shift D (length u) 0) w'", "by (metis LeftDerivation.simps(1) LeftDerivation_breakdown LeftDerivation_implies_Derivation \n  LeftDerivation_skip_prefix append_eq_conv_conj assms(1) assms(2) is_word_Derivation \n  is_word_Derivation_derivation_ge)"], ["", "definition ladder_cut :: \"ladder \\<Rightarrow> nat \\<Rightarrow> ladder\"\nwhere \"ladder_cut L n = (let i = length L - 1 in L[i := (n, snd (L ! i))])\""], ["", "fun deriv_shift :: \"nat \\<Rightarrow> nat \\<Rightarrow> deriv \\<Rightarrow> deriv\"\nwhere \"deriv_shift dn dj (n, j, i) = (n - dn, j - dj, i)\""], ["", "definition ladder_shift :: \"ladder \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> ladder\"\nwhere \"ladder_shift L dn dj = map (deriv_shift dn dj) L\""], ["", "lemma splits_at_append_suffix_prevails: \n  assumes \"splits_at (a@b) i u N v\"\n  assumes \"i < length a\"\n  shows \"\\<exists> v'. v = v'@b \\<and> a=u@[N]@v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v'. v = v' @ b \\<and> a = u @ [N] @ v'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v'. v = v' @ b \\<and> a = u @ [N] @ v'", "have \"min (length a) (Suc i) = Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length a) (Suc i) = Suc i", "using Suc_leI assms(2) min.absorb2"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  i < length a\n  ?b \\<le> ?a \\<Longrightarrow> min ?a ?b = ?b\n\ngoal (1 subgoal):\n 1. min (length a) (Suc i) = Suc i", "by blast"], ["proof (state)\nthis:\n  min (length a) (Suc i) = Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>v'. v = v' @ b \\<and> a = u @ [N] @ v'", "then"], ["proof (chain)\npicking this:\n  min (length a) (Suc i) = Suc i", "show ?thesis"], ["proof (prove)\nusing this:\n  min (length a) (Suc i) = Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>v'. v = v' @ b \\<and> a = u @ [N] @ v'", "by (metis (no_types) append_assoc append_eq_conv_conj append_take_drop_id assms(1) \n      hd_drop_conv_nth length_take splits_at_def take_hd_drop)"], ["proof (state)\nthis:\n  \\<exists>v'. v = v' @ b \\<and> a = u @ [N] @ v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivation_shift_right_left_cancel:\n  \"derivation_shift (derivation_shift D 0 r) r 0 = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_shift (derivation_shift D 0 r) r 0 = D", "by (induct D, auto)"], ["", "lemma derivation_shift_left_right_cancel:\n  assumes \"derivation_ge D r\"\n  shows \"derivation_shift (derivation_shift D r 0) 0 r = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_shift (derivation_shift D r 0) 0 r = D", "using assms derivation_ge_shift_simp derivation_shift_0_shift"], ["proof (prove)\nusing this:\n  derivation_ge D r\n  \\<lbrakk>derivation_ge ?D ?i; ?l \\<le> ?i; ?l \\<le> ?r\\<rbrakk>\n  \\<Longrightarrow> derivation_shift ?D ?l ?r =\n                    derivation_shift ?D 0 (?r - ?l)\n  derivation_shift (derivation_shift ?D ?left1.0 0) ?left2.0 ?right2.0 =\n  derivation_shift ?D (?left1.0 + ?left2.0) ?right2.0\n\ngoal (1 subgoal):\n 1. derivation_shift (derivation_shift D r 0) 0 r = D", "by auto"], ["", "lemma LeftDerivation_ge_take:\n  assumes \"derivation_ge D k\"\n  assumes \"LeftDerivation a D b\"\n  assumes \"D \\<noteq> []\"\n  shows \"take k a = take k b \\<and> is_word (take k a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "obtain d D' where d: \"d#D' = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d D'. d # D' = D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3) list.exhaust"], ["proof (prove)\nusing this:\n  D \\<noteq> []\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>d D'. d # D' = D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  d # D' = D\n\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "then"], ["proof (chain)\npicking this:\n  d # D' = D", "have \"\\<exists> x. LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b\""], ["proof (prove)\nusing this:\n  d # D' = D\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b", "using LeftDerivation.simps(2) assms(2)"], ["proof (prove)\nusing this:\n  d # D' = D\n  LeftDerivation ?a (?d # ?D) ?b =\n  (\\<exists>x.\n      LeftDerives1 ?a (fst ?d) (snd ?d) x \\<and> LeftDerivation x ?D ?b)\n  LeftDerivation a D b\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b\n\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b", "obtain x where x: \"LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b\""], ["proof (prove)\nusing this:\n  \\<exists>x. LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        LeftDerives1 a (fst d) (snd d) x \\<and>\n        LeftDerivation x D' b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b\n\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "have fst_d_k: \"fst d \\<ge> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> fst d", "using d assms(1) derivation_ge_cons"], ["proof (prove)\nusing this:\n  d # D' = D\n  derivation_ge D k\n  derivation_ge (?d # ?D) ?i = (?i \\<le> fst ?d \\<and> derivation_ge ?D ?i)\n\ngoal (1 subgoal):\n 1. k \\<le> fst d", "by blast"], ["proof (state)\nthis:\n  k \\<le> fst d\n\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "from x fst_d_k"], ["proof (chain)\npicking this:\n  LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b\n  k \\<le> fst d", "have is_word: \"is_word (take k a)\""], ["proof (prove)\nusing this:\n  LeftDerives1 a (fst d) (snd d) x \\<and> LeftDerivation x D' b\n  k \\<le> fst d\n\ngoal (1 subgoal):\n 1. is_word (take k a)", "by (metis LeftDerives1_def append_take_drop_id is_word_append leftmost_def \n      min.absorb2 take_append take_take)"], ["proof (state)\nthis:\n  is_word (take k a)\n\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "have is_eq: \"take k a = take k b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k a = take k b", "using Derivation_take LeftDerivation_implies_Derivation assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>derivation_ge ?D ?i; Derivation ?a ?D ?b\\<rbrakk>\n  \\<Longrightarrow> take ?i ?a = take ?i ?b\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  derivation_ge D k\n  LeftDerivation a D b\n\ngoal (1 subgoal):\n 1. take k a = take k b", "by blast"], ["proof (state)\nthis:\n  take k a = take k b\n\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "using is_word is_eq"], ["proof (prove)\nusing this:\n  is_word (take k a)\n  take k a = take k b\n\ngoal (1 subgoal):\n 1. take k a = take k b \\<and> is_word (take k a)", "by blast"], ["proof (state)\nthis:\n  take k a = take k b \\<and> is_word (take k a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFix_splits_at_symbol:\n  assumes \"LeftDerivationFix a i D j b\"\n  shows \"\\<exists> U a1 a2 b1 b2 n. splits_at a i a1 U a2 \\<and> splits_at b j b1 U b2 \\<and> \n    n \\<le> length D \\<and> LeftDerivation a1 (take n D) b1 \\<and> derivation_ge (drop n D) (Suc(length b1)) \\<and>\n    LeftDerivation a2 (derivation_shift (drop n D) (Suc(length b1)) 0) b2 \\<and>\n    (n = length D \\<or> (n < length D \\<and> is_word (b1@[U])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "note hyp = LeftDerivationFix_def[where \\<alpha>=a and \\<beta>=b and D=D and i=i and j=j]"], ["proof (state)\nthis:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "from hyp"], ["proof (chain)\npicking this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))", "obtain E F where EF:\n    \"D = E @ derivation_shift F 0 (Suc j) \\<and> LeftDerivation (take i a) E (take j b) \\<and> \n      LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\""], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i a) E (take j b) \\<and>\n        LeftDerivation (drop (Suc i) a) F (drop (Suc j) b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  LeftDerivationFix a i D j b\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i a) E (take j b) \\<and>\n        LeftDerivation (drop (Suc i) a) F (drop (Suc j) b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have \"\\<exists> \\<beta>. LeftDerivation a E \\<beta> \\<and> LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerivation a E \\<beta> \\<and>\n       LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "using EF LeftDerivation_append assms(1) hyp"], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n  LeftDerivation ?a (?D @ ?E) ?c =\n  (\\<exists>b. LeftDerivation ?a ?D b \\<and> LeftDerivation b ?E ?c)\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerivation a E \\<beta> \\<and>\n       LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<beta>.\n     LeftDerivation a E \\<beta> \\<and>\n     LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     LeftDerivation a E \\<beta> \\<and>\n     LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "obtain \\<beta> where \\<beta>_intro: \n    \"LeftDerivation a E \\<beta> \\<and> LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     LeftDerivation a E \\<beta> \\<and>\n     LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        LeftDerivation a E \\<beta> \\<and>\n        LeftDerivation \\<beta> (derivation_shift F 0 (Suc j))\n         b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivation a E \\<beta> \\<and>\n  LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have \"LeftDerivation ((take i a)@(drop i a)) E ((take j b)@(drop i a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)", "by (metis EF LeftDerivation_append_suffix append_take_drop_id assms(1) hyp is_sentence_concat)"], ["proof (state)\nthis:\n  LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)", "have \"LeftDerivation a E ((take j b)@(drop i a))\""], ["proof (prove)\nusing this:\n  LeftDerivation (take i a @ drop i a) E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. LeftDerivation a E (take j b @ drop i a)", "by simp"], ["proof (state)\nthis:\n  LeftDerivation a E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "then"], ["proof (chain)\npicking this:\n  LeftDerivation a E (take j b @ drop i a)", "have \\<beta>_decomposed: \"\\<beta> = (take j b)@(drop i a)\""], ["proof (prove)\nusing this:\n  LeftDerivation a E (take j b @ drop i a)\n\ngoal (1 subgoal):\n 1. \\<beta> = take j b @ drop i a", "using Derivation_unique_dest LeftDerivation_implies_Derivation \\<beta>_intro"], ["proof (prove)\nusing this:\n  LeftDerivation a E (take j b @ drop i a)\n  \\<lbrakk>Derivation ?a ?D ?b; Derivation ?a ?D ?c\\<rbrakk>\n  \\<Longrightarrow> ?b = ?c\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  LeftDerivation a E \\<beta> \\<and>\n  LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<beta> = take j b @ drop i a", "by blast"], ["proof (state)\nthis:\n  \\<beta> = take j b @ drop i a\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have derivation: \"LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b", "by (simp add: \\<beta>_intro)"], ["proof (state)\nthis:\n  LeftDerivation \\<beta> (derivation_shift F 0 (Suc j)) b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have \"\\<exists> n. n \\<le> length D \\<and> E = take n D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>length D. E = take n D", "by (metis EF append_eq_conv_conj is_prefix_length is_prefix_take)"], ["proof (state)\nthis:\n  \\<exists>n\\<le>length D. E = take n D\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "then"], ["proof (chain)\npicking this:\n  \\<exists>n\\<le>length D. E = take n D", "obtain n where n: \"n \\<le> length D \\<and> E = take n D\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<le>length D. E = take n D\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n \\<le> length D \\<and> E = take n D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n \\<le> length D \\<and> E = take n D\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have F_def: \"drop n D = derivation_shift F 0 (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n D = derivation_shift F 0 (Suc j)", "by (metis EF append_eq_conv_conj length_take min.absorb2 n)"], ["proof (state)\nthis:\n  drop n D = derivation_shift F 0 (Suc j)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have min_j: \"min (length b) j = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length b) j = j", "using assms hyp"], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n\ngoal (1 subgoal):\n 1. min (length b) j = j", "by linarith"], ["proof (state)\nthis:\n  min (length b) j = j\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have derivation_ge_Suc_j: \"derivation_ge (drop n D) (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (drop n D) (Suc j)", "using F_def derivation_ge_shift"], ["proof (prove)\nusing this:\n  drop n D = derivation_shift F 0 (Suc j)\n  derivation_ge (derivation_shift ?F 0 ?j) ?j\n\ngoal (1 subgoal):\n 1. derivation_ge (drop n D) (Suc j)", "by simp"], ["proof (state)\nthis:\n  derivation_ge (drop n D) (Suc j)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have LeftDerivation_\\<beta>_b: \"LeftDerivation \\<beta> (drop n D) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (drop n D) b", "by (simp add: F_def \\<beta>_intro)"], ["proof (state)\nthis:\n  LeftDerivation \\<beta> (drop n D) b\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have is_word_Suc_j_b: \"n \\<noteq> length D \\<Longrightarrow> is_word (take (Suc j) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> length D \\<Longrightarrow> is_word (take (Suc j) b)", "by (metis EF F_def LeftDerivation_ge_take \\<beta>_intro append_Nil2 derivation_ge_Suc_j \n      length_take min.absorb2 n)"], ["proof (state)\nthis:\n  n \\<noteq> length D \\<Longrightarrow> is_word (take (Suc j) b)\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "have take_Suc_j_b_decompose: \"take (Suc j) b = take j b @ [a ! i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j) b = take j b @ [a ! i]", "using assms hyp take_Suc_conv_app_nth"], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  ?i < length ?xs \\<Longrightarrow>\n  take (Suc ?i) ?xs = take ?i ?xs @ [?xs ! ?i]\n\ngoal (1 subgoal):\n 1. take (Suc j) b = take j b @ [a ! i]", "by auto"], ["proof (state)\nthis:\n  take (Suc j) b = take j b @ [a ! i]\n\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U a1 a2 b1 b2 n.\n       splits_at a i a1 U a2 \\<and>\n       splits_at b j b1 U b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "apply (rule_tac x=\"a ! i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a1 a2 b1 b2 n.\n       splits_at a i a1 (a ! i) a2 \\<and>\n       splits_at b j b1 (a ! i) b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation a1 (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [a ! i]))", "apply (rule_tac x=\"take i a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a2 b1 b2 n.\n       splits_at a i (take i a) (a ! i) a2 \\<and>\n       splits_at b j b1 (a ! i) b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation (take i a) (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n        b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [a ! i]))", "apply (rule_tac x=\"drop (Suc i) a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1 b2 n.\n       splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n       splits_at b j b1 (a ! i) b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation (take i a) (take n D) b1 \\<and>\n       derivation_ge (drop n D) (Suc (length b1)) \\<and>\n       LeftDerivation (drop (Suc i) a)\n        (derivation_shift (drop n D) (Suc (length b1)) 0) b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (b1 @ [a ! i]))", "apply (rule_tac x=\"take j b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b2 n.\n       splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n       splits_at b j (take j b) (a ! i) b2 \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation (take i a) (take n D) (take j b) \\<and>\n       derivation_ge (drop n D) (Suc (length (take j b))) \\<and>\n       LeftDerivation (drop (Suc i) a)\n        (derivation_shift (drop n D) (Suc (length (take j b))) 0) b2 \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (take j b @ [a ! i]))", "apply (rule_tac x=\"drop (Suc j) b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n       splits_at b j (take j b) (a ! i) (drop (Suc j) b) \\<and>\n       n \\<le> length D \\<and>\n       LeftDerivation (take i a) (take n D) (take j b) \\<and>\n       derivation_ge (drop n D) (Suc (length (take j b))) \\<and>\n       LeftDerivation (drop (Suc i) a)\n        (derivation_shift (drop n D) (Suc (length (take j b))) 0)\n        (drop (Suc j) b) \\<and>\n       (n = length D \\<or> n < length D \\<and> is_word (take j b @ [a ! i]))", "apply (rule_tac x=\"n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_at a i (take i a) (a ! i) (drop (Suc i) a) \\<and>\n    splits_at b j (take j b) (a ! i) (drop (Suc j) b) \\<and>\n    n \\<le> length D \\<and>\n    LeftDerivation (take i a) (take n D) (take j b) \\<and>\n    derivation_ge (drop n D) (Suc (length (take j b))) \\<and>\n    LeftDerivation (drop (Suc i) a)\n     (derivation_shift (drop n D) (Suc (length (take j b))) 0)\n     (drop (Suc j) b) \\<and>\n    (n = length D \\<or> n < length D \\<and> is_word (take j b @ [a ! i]))", "apply (auto simp add: min_j)"], ["proof (prove)\ngoal (9 subgoals):\n 1. splits_at a i (take i a) (a ! i) (drop (Suc i) a)\n 2. splits_at b j (take j b) (a ! i) (drop (Suc j) b)\n 3. n \\<le> length D\n 4. LeftDerivation (take i a) (take n D) (take j b)\n 5. derivation_ge (drop n D) (Suc j)\n 6. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 7. n \\<noteq> length D \\<Longrightarrow> n < length D\n 8. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 9. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using assms hyp splits_at_def"], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (9 subgoals):\n 1. splits_at a i (take i a) (a ! i) (drop (Suc i) a)\n 2. splits_at b j (take j b) (a ! i) (drop (Suc j) b)\n 3. n \\<le> length D\n 4. LeftDerivation (take i a) (take n D) (take j b)\n 5. derivation_ge (drop n D) (Suc j)\n 6. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 7. n \\<noteq> length D \\<Longrightarrow> n < length D\n 8. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 9. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply blast"], ["proof (prove)\ngoal (8 subgoals):\n 1. splits_at b j (take j b) (a ! i) (drop (Suc j) b)\n 2. n \\<le> length D\n 3. LeftDerivation (take i a) (take n D) (take j b)\n 4. derivation_ge (drop n D) (Suc j)\n 5. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 6. n \\<noteq> length D \\<Longrightarrow> n < length D\n 7. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 8. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using assms hyp splits_at_def"], ["proof (prove)\nusing this:\n  LeftDerivationFix a i D j b\n  LeftDerivationFix a i D j b =\n  (is_sentence a \\<and>\n   is_sentence b \\<and>\n   LeftDerivation a D b \\<and>\n   i < length a \\<and>\n   j < length b \\<and>\n   a ! i = b ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i a) E (take j b) \\<and>\n       LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)))\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (8 subgoals):\n 1. splits_at b j (take j b) (a ! i) (drop (Suc j) b)\n 2. n \\<le> length D\n 3. LeftDerivation (take i a) (take n D) (take j b)\n 4. derivation_ge (drop n D) (Suc j)\n 5. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 6. n \\<noteq> length D \\<Longrightarrow> n < length D\n 7. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 8. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply blast"], ["proof (prove)\ngoal (7 subgoals):\n 1. n \\<le> length D\n 2. LeftDerivation (take i a) (take n D) (take j b)\n 3. derivation_ge (drop n D) (Suc j)\n 4. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 5. n \\<noteq> length D \\<Longrightarrow> n < length D\n 6. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 7. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using n"], ["proof (prove)\nusing this:\n  n \\<le> length D \\<and> E = take n D\n\ngoal (7 subgoals):\n 1. n \\<le> length D\n 2. LeftDerivation (take i a) (take n D) (take j b)\n 3. derivation_ge (drop n D) (Suc j)\n 4. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 5. n \\<noteq> length D \\<Longrightarrow> n < length D\n 6. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 7. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. LeftDerivation (take i a) (take n D) (take j b)\n 2. derivation_ge (drop n D) (Suc j)\n 3. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 4. n \\<noteq> length D \\<Longrightarrow> n < length D\n 5. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 6. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using EF n"], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n  n \\<le> length D \\<and> E = take n D\n\ngoal (6 subgoals):\n 1. LeftDerivation (take i a) (take n D) (take j b)\n 2. derivation_ge (drop n D) (Suc j)\n 3. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 4. n \\<noteq> length D \\<Longrightarrow> n < length D\n 5. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 6. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. derivation_ge (drop n D) (Suc j)\n 2. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 3. n \\<noteq> length D \\<Longrightarrow> n < length D\n 4. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 5. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using F_def"], ["proof (prove)\nusing this:\n  drop n D = derivation_shift F 0 (Suc j)\n\ngoal (5 subgoals):\n 1. derivation_ge (drop n D) (Suc j)\n 2. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 3. n \\<noteq> length D \\<Longrightarrow> n < length D\n 4. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 5. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. drop n D = derivation_shift F 0 (Suc j) \\<Longrightarrow>\n    derivation_ge (derivation_shift F 0 (Suc j)) (Suc j)\n 2. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 3. n \\<noteq> length D \\<Longrightarrow> n < length D\n 4. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 5. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using derivation_ge_shift"], ["proof (prove)\nusing this:\n  derivation_ge (derivation_shift ?F 0 ?j) ?j\n\ngoal (5 subgoals):\n 1. drop n D = derivation_shift F 0 (Suc j) \\<Longrightarrow>\n    derivation_ge (derivation_shift F 0 (Suc j)) (Suc j)\n 2. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 3. n \\<noteq> length D \\<Longrightarrow> n < length D\n 4. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 5. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 2. n \\<noteq> length D \\<Longrightarrow> n < length D\n 3. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 4. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using F_def  derivation_shift_right_left_cancel"], ["proof (prove)\nusing this:\n  drop n D = derivation_shift F 0 (Suc j)\n  derivation_shift (derivation_shift ?D 0 ?r) ?r 0 = ?D\n\ngoal (4 subgoals):\n 1. LeftDerivation (drop (Suc i) a) (derivation_shift (drop n D) (Suc j) 0)\n     (drop (Suc j) b)\n 2. n \\<noteq> length D \\<Longrightarrow> n < length D\n 3. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 4. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>drop n D = derivation_shift F 0 (Suc j);\n     \\<And>D r. derivation_shift (derivation_shift D 0 r) r 0 = D\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n 2. n \\<noteq> length D \\<Longrightarrow> n < length D\n 3. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 4. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using EF"], ["proof (prove)\nusing this:\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i a) E (take j b) \\<and>\n  LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>drop n D = derivation_shift F 0 (Suc j);\n     \\<And>D r. derivation_shift (derivation_shift D 0 r) r 0 = D\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation (drop (Suc i) a) F (drop (Suc j) b)\n 2. n \\<noteq> length D \\<Longrightarrow> n < length D\n 3. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 4. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. n \\<noteq> length D \\<Longrightarrow> n < length D\n 2. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 3. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using n"], ["proof (prove)\nusing this:\n  n \\<le> length D \\<and> E = take n D\n\ngoal (3 subgoals):\n 1. n \\<noteq> length D \\<Longrightarrow> n < length D\n 2. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 3. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply arith"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 2. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "using is_word_Suc_j_b  take_Suc_j_b_decompose is_word_append"], ["proof (prove)\nusing this:\n  n \\<noteq> length D \\<Longrightarrow> is_word (take (Suc j) b)\n  take (Suc j) b = take j b @ [a ! i]\n  is_word (?a @ ?b) = (is_word ?a \\<and> is_word ?b)\n\ngoal (2 subgoals):\n 1. n \\<noteq> length D \\<Longrightarrow> is_word (take j b)\n 2. n \\<noteq> length D \\<Longrightarrow> is_terminal (a ! i)", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>U a1 a2 b1 b2 n.\n     splits_at a i a1 U a2 \\<and>\n     splits_at b j b1 U b2 \\<and>\n     n \\<le> length D \\<and>\n     LeftDerivation a1 (take n D) b1 \\<and>\n     derivation_ge (drop n D) (Suc (length b1)) \\<and>\n     LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n      b2 \\<and>\n     (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivation_breakdown': \"LeftDerivation (u @ v) D w \\<Longrightarrow>\n  \\<exists>n w1 w2.\n    n \\<le> length D \\<and>\n    w = w1 @ w2 \\<and>\n    LeftDerivation u (take n D) w1 \\<and>\n    derivation_ge (drop n D) (length w1) \\<and>\n    LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "assume hyp: \"LeftDerivation (u @ v) D w\""], ["proof (state)\nthis:\n  LeftDerivation (u @ v) D w\n\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "from LeftDerivation_breakdown[OF hyp]"], ["proof (chain)\npicking this:\n  \\<exists>n w1 w2.\n     w = w1 @ w2 \\<and>\n     LeftDerivation u (take n D) w1 \\<and>\n     derivation_ge (drop n D) (length w1) \\<and>\n     LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "obtain n w1 w2 where breakdown:\n   \"w = w1 @ w2 \\<and>\n    LeftDerivation u (take n D) w1 \\<and>\n    derivation_ge (drop n D) (length w1) \\<and>\n    LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2\""], ["proof (prove)\nusing this:\n  \\<exists>n w1 w2.\n     w = w1 @ w2 \\<and>\n     LeftDerivation u (take n D) w1 \\<and>\n     derivation_ge (drop n D) (length w1) \\<and>\n     LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 n.\n        w = w1 @ w2 \\<and>\n        LeftDerivation u (take n D) w1 \\<and>\n        derivation_ge (drop n D) (length w1) \\<and>\n        LeftDerivation v (derivation_shift (drop n D) (length w1) 0)\n         w2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w = w1 @ w2 \\<and>\n  LeftDerivation u (take n D) w1 \\<and>\n  derivation_ge (drop n D) (length w1) \\<and>\n  LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "obtain m where m: \"m = min (length D) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m = min (length D) n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = min (length D) n\n\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "have take_m: \"take m D = take n D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take m D = take n D", "using m is_prefix_take take_prefix"], ["proof (prove)\nusing this:\n  m = min (length D) n\n  is_prefix (take ?n ?a) ?a\n  is_prefix ?a ?b \\<Longrightarrow> take (length ?a) ?b = ?a\n\ngoal (1 subgoal):\n 1. take m D = take n D", "by fastforce"], ["proof (state)\nthis:\n  take m D = take n D\n\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "have drop_m: \"drop m D = drop n D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop m D = drop n D", "by (metis append_eq_conv_conj append_take_drop_id length_take m)"], ["proof (state)\nthis:\n  drop m D = drop n D\n\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "have m_bound: \"m \\<le> length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> length D", "by (simp add: m)"], ["proof (state)\nthis:\n  m \\<le> length D\n\ngoal (1 subgoal):\n 1. LeftDerivation (u @ v) D w \\<Longrightarrow>\n    \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n w1 w2.\n       n \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take n D) w1 \\<and>\n       derivation_ge (drop n D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2", "apply (rule_tac x=\"m\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w1 w2.\n       m \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take m D) w1 \\<and>\n       derivation_ge (drop m D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop m D) (length w1) 0) w2", "apply (rule_tac x=\"w1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w2.\n       m \\<le> length D \\<and>\n       w = w1 @ w2 \\<and>\n       LeftDerivation u (take m D) w1 \\<and>\n       derivation_ge (drop m D) (length w1) \\<and>\n       LeftDerivation v (derivation_shift (drop m D) (length w1) 0) w2", "apply (rule_tac x=\"w2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> length D \\<and>\n    w = w1 @ w2 \\<and>\n    LeftDerivation u (take m D) w1 \\<and>\n    derivation_ge (drop m D) (length w1) \\<and>\n    LeftDerivation v (derivation_shift (drop m D) (length w1) 0) w2", "using breakdown m_bound take_m drop_m"], ["proof (prove)\nusing this:\n  w = w1 @ w2 \\<and>\n  LeftDerivation u (take n D) w1 \\<and>\n  derivation_ge (drop n D) (length w1) \\<and>\n  LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2\n  m \\<le> length D\n  take m D = take n D\n  drop m D = drop n D\n\ngoal (1 subgoal):\n 1. m \\<le> length D \\<and>\n    w = w1 @ w2 \\<and>\n    LeftDerivation u (take m D) w1 \\<and>\n    derivation_ge (drop m D) (length w1) \\<and>\n    LeftDerivation v (derivation_shift (drop m D) (length w1) 0) w2", "by auto"], ["proof (state)\nthis:\n  \\<exists>n w1 w2.\n     n \\<le> length D \\<and>\n     w = w1 @ w2 \\<and>\n     LeftDerivation u (take n D) w1 \\<and>\n     derivation_ge (drop n D) (length w1) \\<and>\n     LeftDerivation v (derivation_shift (drop n D) (length w1) 0) w2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerives1_append_replace_in_left: \n  assumes ld1: \"LeftDerives1 (\\<alpha>@\\<delta>) i r \\<beta>\"\n  assumes i_bound: \"i < length \\<alpha>\"\n  shows \"\\<exists> \\<alpha>'. \\<beta> = \\<alpha>'@\\<delta> \\<and> LeftDerives1 \\<alpha> i r \\<alpha>' \\<and> i + length (snd r) \\<le> length \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "obtain \\<alpha>' where \\<alpha>': \"\\<alpha>' = (take i \\<alpha>)@(snd r)@(drop (i+1) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>'.\n        \\<alpha>' =\n        take i \\<alpha> @ snd r @ drop (i + 1) \\<alpha> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<alpha>' = take i \\<alpha> @ snd r @ drop (i + 1) \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "have fst_r: \"fst r = \\<alpha> ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst r = \\<alpha> ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst r = \\<alpha> ! i", "have \"\\<forall>ss n p ssa. \\<not> LeftDerives1 ss n p ssa \\<or> Derives1 ss n p ssa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ss n p ssa.\n       \\<not> LeftDerives1 ss n p ssa \\<or> Derives1 ss n p ssa", "using LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. \\<forall>ss n p ssa.\n       \\<not> LeftDerives1 ss n p ssa \\<or> Derives1 ss n p ssa", "by blast"], ["proof (state)\nthis:\n  \\<forall>ss n p ssa.\n     \\<not> LeftDerives1 ss n p ssa \\<or> Derives1 ss n p ssa\n\ngoal (1 subgoal):\n 1. fst r = \\<alpha> ! i", "then"], ["proof (chain)\npicking this:\n  \\<forall>ss n p ssa.\n     \\<not> LeftDerives1 ss n p ssa \\<or> Derives1 ss n p ssa", "have \"Derives1 (\\<alpha> @ \\<delta>) i r \\<beta>\""], ["proof (prove)\nusing this:\n  \\<forall>ss n p ssa.\n     \\<not> LeftDerives1 ss n p ssa \\<or> Derives1 ss n p ssa\n\ngoal (1 subgoal):\n 1. Derives1 (\\<alpha> @ \\<delta>) i r \\<beta>", "using ld1"], ["proof (prove)\nusing this:\n  \\<forall>ss n p ssa.\n     \\<not> LeftDerives1 ss n p ssa \\<or> Derives1 ss n p ssa\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 (\\<alpha> @ \\<delta>) i r \\<beta>", "by blast"], ["proof (state)\nthis:\n  Derives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n\ngoal (1 subgoal):\n 1. fst r = \\<alpha> ! i", "then"], ["proof (chain)\npicking this:\n  Derives1 (\\<alpha> @ \\<delta>) i r \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  Derives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n\ngoal (1 subgoal):\n 1. fst r = \\<alpha> ! i", "using Derives1_nonterminal i_bound splits_at_def"], ["proof (prove)\nusing this:\n  Derives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n  \\<lbrakk>Derives1 ?a ?i ?r ?b;\n   splits_at ?a ?i ?\\<alpha> ?N ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> fst ?r = ?N \\<and> is_nonterminal ?N\n  i < length \\<alpha>\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. fst r = \\<alpha> ! i", "by auto"], ["proof (state)\nthis:\n  fst r = \\<alpha> ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst r = \\<alpha> ! i\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "have \"Derives1 \\<alpha> i r \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> i r \\<alpha>'", "using i_bound ld1"], ["proof (prove)\nusing this:\n  i < length \\<alpha>\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n\ngoal (1 subgoal):\n 1. Derives1 \\<alpha> i r \\<alpha>'", "apply (auto simp add: \\<alpha>' Derives1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y N.\n                         \\<alpha> = x @ N # y \\<and>\n                         (\\<exists>\\<alpha>'.\n                             take i \\<alpha> @\n                             snd r @ drop (Suc i) \\<alpha> =\n                             x @ \\<alpha>' @ y \\<and>\n                             is_sentence x \\<and>\n                             is_sentence y \\<and>\n                             (N, \\<alpha>') \\<in> \\<RR> \\<and>\n                             r = (N, \\<alpha>') \\<and> i = length x)", "apply (rule_tac x=\"take i \\<alpha>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y N.\n                         \\<alpha> = take i \\<alpha> @ N # y \\<and>\n                         (\\<exists>\\<alpha>'.\n                             take i \\<alpha> @\n                             snd r @ drop (Suc i) \\<alpha> =\n                             take i \\<alpha> @ \\<alpha>' @ y \\<and>\n                             is_sentence (take i \\<alpha>) \\<and>\n                             is_sentence y \\<and>\n                             (N, \\<alpha>') \\<in> \\<RR> \\<and>\n                             r = (N, \\<alpha>') \\<and>\n                             i = length (take i \\<alpha>))", "apply (rule_tac x=\"drop (i+1) \\<alpha>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>N.\n                         \\<alpha> =\n                         take i \\<alpha> @ N # drop (i + 1) \\<alpha> \\<and>\n                         (\\<exists>\\<alpha>'.\n                             take i \\<alpha> @\n                             snd r @ drop (Suc i) \\<alpha> =\n                             take i \\<alpha> @\n                             \\<alpha>' @ drop (i + 1) \\<alpha> \\<and>\n                             is_sentence (take i \\<alpha>) \\<and>\n                             is_sentence (drop (i + 1) \\<alpha>) \\<and>\n                             (N, \\<alpha>') \\<in> \\<RR> \\<and>\n                             r = (N, \\<alpha>') \\<and>\n                             i = length (take i \\<alpha>))", "apply (rule_tac x=\"fst r\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> =\n                      take i \\<alpha> @ fst r # drop (i + 1) \\<alpha> \\<and>\n                      (\\<exists>\\<alpha>'.\n                          take i \\<alpha> @ snd r @ drop (Suc i) \\<alpha> =\n                          take i \\<alpha> @\n                          \\<alpha>' @ drop (i + 1) \\<alpha> \\<and>\n                          is_sentence (take i \\<alpha>) \\<and>\n                          is_sentence (drop (i + 1) \\<alpha>) \\<and>\n                          (fst r, \\<alpha>') \\<in> \\<RR> \\<and>\n                          r = (fst r, \\<alpha>') \\<and>\n                          i = length (take i \\<alpha>))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> =\n                      take i \\<alpha> @ fst r # drop (Suc i) \\<alpha>\n 2. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (take i \\<alpha>)\n 3. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (drop (Suc i) \\<alpha>)\n 4. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "apply (simp add: fst_r)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> =\n                      take i \\<alpha> @ \\<alpha> ! i # drop (Suc i) \\<alpha>\n 2. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (take i \\<alpha>)\n 3. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (drop (Suc i) \\<alpha>)\n 4. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "using id_take_nth_drop"], ["proof (prove)\nusing this:\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> =\n                      take i \\<alpha> @ \\<alpha> ! i # drop (Suc i) \\<alpha>\n 2. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (take i \\<alpha>)\n 3. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (drop (Suc i) \\<alpha>)\n 4. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (take i \\<alpha>)\n 2. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (drop (Suc i) \\<alpha>)\n 3. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "using Derives1_sentence1 LeftDerives1_implies_Derives1 is_sentence_concat \n      is_sentence_take"], ["proof (prove)\nusing this:\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> is_sentence ?a\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  is_sentence ?y \\<Longrightarrow> is_sentence (take ?n ?y)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (take i \\<alpha>)\n 2. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (drop (Suc i) \\<alpha>)\n 3. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> is_sentence (drop (Suc i) \\<alpha>)\n 2. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "apply (metis Derives1_sentence1 LeftDerives1_implies_Derives1 append_take_drop_id \n      is_sentence_concat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "using Derives1_rule LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> ?r \\<in> \\<RR>\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length \\<alpha>;\n     LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\\<rbrakk>\n    \\<Longrightarrow> r \\<in> \\<RR>", "by blast"], ["proof (state)\nthis:\n  Derives1 \\<alpha> i r \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "then"], ["proof (chain)\npicking this:\n  Derives1 \\<alpha> i r \\<alpha>'", "have leftderives1_\\<alpha>_\\<alpha>': \"LeftDerives1 \\<alpha> i r \\<alpha>'\""], ["proof (prove)\nusing this:\n  Derives1 \\<alpha> i r \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>'", "using LeftDerives1_def i_bound ld1 leftmost_cons_less"], ["proof (prove)\nusing this:\n  Derives1 \\<alpha> i r \\<alpha>'\n  LeftDerives1 ?u ?i ?r ?v = (leftmost ?i ?u \\<and> Derives1 ?u ?i ?r ?v)\n  i < length \\<alpha>\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n  ?i < length ?u \\<Longrightarrow> leftmost ?i (?u @ ?v) = leftmost ?i ?u\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>'", "by auto"], ["proof (state)\nthis:\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "have i_bound_\\<alpha>': \"i + length (snd r) \\<le> length \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + length (snd r) \\<le> length \\<alpha>'", "using \\<alpha>' i_bound"], ["proof (prove)\nusing this:\n  \\<alpha>' = take i \\<alpha> @ snd r @ drop (i + 1) \\<alpha>\n  i < length \\<alpha>\n\ngoal (1 subgoal):\n 1. i + length (snd r) \\<le> length \\<alpha>'", "by (simp add: add_mono_thms_linordered_semiring(2) le_add1 less_or_eq_imp_le min.absorb2)"], ["proof (state)\nthis:\n  i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "have is_sentence_\\<delta>: \"is_sentence \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence \\<delta>", "using Derives1_sentence1 LeftDerives1_implies_Derives1 is_sentence_concat ld1"], ["proof (prove)\nusing this:\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> is_sentence ?a\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n\ngoal (1 subgoal):\n 1. is_sentence \\<delta>", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "then"], ["proof (chain)\npicking this:\n  is_sentence \\<delta>", "have \\<beta>: \"\\<beta> = \\<alpha>'@\\<delta>\""], ["proof (prove)\nusing this:\n  is_sentence \\<delta>\n\ngoal (1 subgoal):\n 1. \\<beta> = \\<alpha>' @ \\<delta>", "using ld1 leftderives1_\\<alpha>_\\<alpha>' Derives1_append_suffix Derives1_unique_dest \n      LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  is_sentence \\<delta>\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n  \\<lbrakk>Derives1 ?v ?i ?r ?w; is_sentence ?u\\<rbrakk>\n  \\<Longrightarrow> Derives1 (?v @ ?u) ?i ?r (?w @ ?u)\n  \\<lbrakk>Derives1 ?u ?i ?r ?v; Derives1 ?u ?i ?r ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. \\<beta> = \\<alpha>' @ \\<delta>", "by blast"], ["proof (state)\nthis:\n  \\<beta> = \\<alpha>' @ \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n       LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "apply (rule_tac x=\"\\<alpha>'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n    LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n    i + length (snd r) \\<le> length \\<alpha>'", "using \\<beta> i_bound_\\<alpha>' leftderives1_\\<alpha>_\\<alpha>'"], ["proof (prove)\nusing this:\n  \\<beta> = \\<alpha>' @ \\<delta>\n  i + length (snd r) \\<le> length \\<alpha>'\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n    LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n    i + length (snd r) \\<le> length \\<alpha>'", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>'.\n     \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n     LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_propagate:\n  assumes intro: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j \\<gamma>\"\n  assumes i_\\<alpha>: \"i < length \\<alpha>\"\n  assumes non: \"is_nonterminal (\\<gamma> ! j)\"\n  shows \"\\<exists> \\<omega>. LeftDerivation \\<alpha> ((i,r)#D) \\<omega> \\<and> \\<gamma> = \\<omega>@\\<delta> \\<and> j < length \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "from intro LeftDerivationIntro_def[where \\<alpha>=\"\\<alpha>@\\<delta>\" and i=i and r=r and ix=ix and D=D and \n    j=j and \\<gamma>=\\<gamma>]"], ["proof (chain)\npicking this:\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma>\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma> =\n  (\\<exists>\\<beta>.\n      LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta> \\<and>\n      ix < length (snd r) \\<and>\n      snd r ! ix = \\<gamma> ! j \\<and>\n      LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>)", "obtain \\<beta> where ld_\\<beta>: \"LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\" and \n     ix: \"ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j\" and \n     \\<beta>_fix: \"LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\""], ["proof (prove)\nusing this:\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma>\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma> =\n  (\\<exists>\\<beta>.\n      LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta> \\<and>\n      ix < length (snd r) \\<and>\n      snd r ! ix = \\<gamma> ! j \\<and>\n      LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<lbrakk>LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>;\n         ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j;\n         LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n  ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "from LeftDerives1_append_replace_in_left[OF ld_\\<beta> i_\\<alpha>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>'.\n     \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n     LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'", "obtain \\<alpha>' where \\<alpha>': \"\\<beta> = \\<alpha>' @ \\<delta> \\<and> LeftDerives1 \\<alpha> i r \\<alpha>' \\<and> i + length (snd r) \\<le> length \\<alpha>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>'.\n     \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n     LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>'.\n        \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n        LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n        i + length (snd r) \\<le> length \\<alpha>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n  LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "have i_plus_ix_bound: \"i + ix < length \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + ix < length \\<alpha>'", "using \\<alpha>' ix"], ["proof (prove)\nusing this:\n  \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n  LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n  ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j\n\ngoal (1 subgoal):\n 1. i + ix < length \\<alpha>'", "by linarith"], ["proof (state)\nthis:\n  i + ix < length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "have ld_\\<gamma>: \"LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>", "using \\<beta>_fix \\<alpha>'"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n  \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n  LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>", "by simp"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "then"], ["proof (chain)\npicking this:\n  LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>", "have non_i_ix: \"is_nonterminal ((\\<alpha>' @ \\<delta>) ! (i + ix))\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. is_nonterminal ((\\<alpha>' @ \\<delta>) ! (i + ix))", "by (simp add: LeftDerivationFix_def non)"], ["proof (state)\nthis:\n  is_nonterminal ((\\<alpha>' @ \\<delta>) ! (i + ix))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "from LeftDerivationFix_splits_at_nonterminal[OF ld_\\<gamma> non_i_ix]"], ["proof (chain)\npicking this:\n  \\<exists>U a1 a2 b1.\n     splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1", "obtain U a1 a2 b1 where U: \n    \"splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and> splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\""], ["proof (prove)\nusing this:\n  \\<exists>U a1 a2 b1.\n     splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. (\\<And>a1 U a2 b1.\n        splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n        splits_at \\<gamma> j b1 U a2 \\<and>\n        LeftDerivation a1 D b1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "have \"\\<exists> q. a2 = q@\\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q", "using splits_at_append_suffix_prevails[OF _ i_plus_ix_bound, where b=\\<delta>] U"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) ?u ?N ?v \\<Longrightarrow>\n  \\<exists>v'. ?v = v' @ \\<delta> \\<and> \\<alpha>' = ?u @ [?N] @ v'\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q", "by blast"], ["proof (state)\nthis:\n  \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q", "obtain q where q: \"a2 = q@\\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\""], ["proof (prove)\nusing this:\n  \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n       \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "apply (rule_tac x=\"b1@[U]@q\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> ((i, r) # D) (b1 @ [U] @ q) \\<and>\n    \\<gamma> = (b1 @ [U] @ q) @ \\<delta> \\<and> j < length (b1 @ [U] @ q)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 \\<alpha> i r x \\<and> LeftDerivation x D (b1 @ U # q)\n 2. \\<gamma> = b1 @ U # q @ \\<delta>\n 3. j < Suc (length b1 + length q)", "apply (rule_tac x=\"\\<alpha>'\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n    LeftDerivation \\<alpha>' D (b1 @ U # q)\n 2. \\<gamma> = b1 @ U # q @ \\<delta>\n 3. j < Suc (length b1 + length q)", "apply (metis LeftDerivationFix_def LeftDerivation_append_suffix U \\<alpha>' \n      q append_Cons append_Nil is_sentence_concat ld_\\<gamma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<gamma> = b1 @ U # q @ \\<delta>\n 2. j < Suc (length b1 + length q)", "using U q splits_at_combine"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n  a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> \\<Longrightarrow>\n  ?\\<delta> = ?\\<alpha> @ [?N] @ ?\\<beta>\n\ngoal (2 subgoals):\n 1. \\<gamma> = b1 @ U # q @ \\<delta>\n 2. j < Suc (length b1 + length q)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < Suc (length b1 + length q)", "using U splits_at_def"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. j < Suc (length b1 + length q)", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<omega>.\n     LeftDerivation \\<alpha> ((i, r) # D) \\<omega> \\<and>\n     \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_finish:\n  assumes intro: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j \\<gamma>\"\n  assumes i_\\<alpha>: \"i < length \\<alpha>\"\n  shows \"\\<exists> k \\<omega> \\<delta>'.\n    k \\<le> length D \\<and>\n    LeftDerivation \\<alpha> ((i, r)#(take k D)) \\<omega> \\<and>\n    LeftDerivation (\\<alpha> @ \\<delta>) ((i, r)#(take k D)) (\\<omega> @ \\<delta>) \\<and>\n    derivation_ge (drop k D) (length \\<omega>) \\<and>\n    LeftDerivation \\<delta> (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n    \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "from intro LeftDerivationIntro_def[where \\<alpha>=\"\\<alpha>@\\<delta>\" and i=i and r=r and ix=ix and D=D and \n    j=j and \\<gamma>=\\<gamma>]"], ["proof (chain)\npicking this:\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma>\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma> =\n  (\\<exists>\\<beta>.\n      LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta> \\<and>\n      ix < length (snd r) \\<and>\n      snd r ! ix = \\<gamma> ! j \\<and>\n      LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>)", "obtain \\<beta> where ld_\\<beta>: \"LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\" and \n     ix: \"ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j\" and \n     \\<beta>_fix: \"LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\""], ["proof (prove)\nusing this:\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma>\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j \\<gamma> =\n  (\\<exists>\\<beta>.\n      LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta> \\<and>\n      ix < length (snd r) \\<and>\n      snd r ! ix = \\<gamma> ! j \\<and>\n      LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<lbrakk>LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>;\n         ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j;\n         LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>\n  ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "from LeftDerives1_append_replace_in_left[OF ld_\\<beta> i_\\<alpha>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>'.\n     \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n     LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'", "obtain \\<alpha>' where \\<alpha>': \"\\<beta> = \\<alpha>' @ \\<delta> \\<and> LeftDerives1 \\<alpha> i r \\<alpha>' \\<and> i + length (snd r) \\<le> length \\<alpha>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>'.\n     \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n     LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>'.\n        \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n        LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n        i + length (snd r) \\<le> length \\<alpha>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n  LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have i_plus_ix_bound: \"i + ix < length \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + ix < length \\<alpha>'", "using \\<alpha>' ix"], ["proof (prove)\nusing this:\n  \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n  LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n  ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j\n\ngoal (1 subgoal):\n 1. i + ix < length \\<alpha>'", "by linarith"], ["proof (state)\nthis:\n  i + ix < length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have ld_\\<gamma>: \"LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>", "using \\<beta>_fix \\<alpha>'"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n  \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n  LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>", "by simp"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "from LeftDerivationFix_splits_at_symbol[OF ld_\\<gamma>]"], ["proof (chain)\npicking this:\n  \\<exists>U a1 a2 b1 b2 n.\n     splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U b2 \\<and>\n     n \\<le> length D \\<and>\n     LeftDerivation a1 (take n D) b1 \\<and>\n     derivation_ge (drop n D) (Suc (length b1)) \\<and>\n     LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n      b2 \\<and>\n     (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "obtain U a1 a2 b1 b2 n where U: \n    \"splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U b2 \\<and>\n     n \\<le> length D \\<and>\n     LeftDerivation a1 (take n D) b1 \\<and>\n     derivation_ge (drop n D) (Suc (length b1)) \\<and>\n     LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0) b2 \\<and>\n     (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\""], ["proof (prove)\nusing this:\n  \\<exists>U a1 a2 b1 b2 n.\n     splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U b2 \\<and>\n     n \\<le> length D \\<and>\n     LeftDerivation a1 (take n D) b1 \\<and>\n     derivation_ge (drop n D) (Suc (length b1)) \\<and>\n     LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n      b2 \\<and>\n     (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. (\\<And>a1 U a2 b1 b2 n.\n        splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n        splits_at \\<gamma> j b1 U b2 \\<and>\n        n \\<le> length D \\<and>\n        LeftDerivation a1 (take n D) b1 \\<and>\n        derivation_ge (drop n D) (Suc (length b1)) \\<and>\n        LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n         b2 \\<and>\n        (n = length D \\<or>\n         n < length D \\<and> is_word (b1 @ [U])) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have n_bound: \"n \\<le> length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length D", "using U"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. n \\<le> length D", "by blast"], ["proof (state)\nthis:\n  n \\<le> length D\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have \"\\<exists> q. a2 = q@\\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q", "using splits_at_append_suffix_prevails[OF _ i_plus_ix_bound, where b=\\<delta>] U"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) ?u ?N ?v \\<Longrightarrow>\n  \\<exists>v'. ?v = v' @ \\<delta> \\<and> \\<alpha>' = ?u @ [?N] @ v'\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q", "by blast"], ["proof (state)\nthis:\n  \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q", "obtain q where q: \"a2 = q@\\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\""], ["proof (prove)\nusing this:\n  \\<exists>q. a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have j: \"j = length b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = length b1", "using U"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. j = length b1", "by (simp add: dual_order.strict_implies_order  min.absorb2 splits_at_def)"], ["proof (state)\nthis:\n  j = length b1\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have \"n = length D \\<or> n < length D \\<and> is_word (b1 @ [U])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length D \\<or> n < length D \\<and> is_word (b1 @ [U])", "using U"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. n = length D \\<or> n < length D \\<and> is_word (b1 @ [U])", "by blast"], ["proof (state)\nthis:\n  n = length D \\<or> n < length D \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "then"], ["proof (chain)\npicking this:\n  n = length D \\<or> n < length D \\<and> is_word (b1 @ [U])", "show ?thesis"], ["proof (prove)\nusing this:\n  n = length D \\<or> n < length D \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = length D \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n 2. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "case 1"], ["proof (state)\nthis:\n  n = length D\n\ngoal (2 subgoals):\n 1. n = length D \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n 2. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "from 1"], ["proof (chain)\npicking this:\n  n = length D", "have drop_n_D: \"drop n D = []\""], ["proof (prove)\nusing this:\n  n = length D\n\ngoal (1 subgoal):\n 1. drop n D = []", "by (simp add: U)"], ["proof (state)\nthis:\n  drop n D = []\n\ngoal (2 subgoals):\n 1. n = length D \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n 2. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "then"], ["proof (chain)\npicking this:\n  drop n D = []", "have \"LeftDerivation a2 [] b2\""], ["proof (prove)\nusing this:\n  drop n D = []\n\ngoal (1 subgoal):\n 1. LeftDerivation a2 [] b2", "using U"], ["proof (prove)\nusing this:\n  drop n D = []\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. LeftDerivation a2 [] b2", "by simp"], ["proof (state)\nthis:\n  LeftDerivation a2 [] b2\n\ngoal (2 subgoals):\n 1. n = length D \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n 2. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "then"], ["proof (chain)\npicking this:\n  LeftDerivation a2 [] b2", "have a2_eq_b2: \"a2 = b2\""], ["proof (prove)\nusing this:\n  LeftDerivation a2 [] b2\n\ngoal (1 subgoal):\n 1. a2 = b2", "by simp"], ["proof (state)\nthis:\n  a2 = b2\n\ngoal (2 subgoals):\n 1. n = length D \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n 2. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "apply (rule_tac x=\"n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<omega> \\<delta>'.\n       n \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take n D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take n D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop n D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "apply (rule_tac x=\"b1@[U]@q\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>'.\n       n \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take n D) (b1 @ [U] @ q) \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take n D)\n        ((b1 @ [U] @ q) @ \\<delta>) \\<and>\n       derivation_ge (drop n D) (length (b1 @ [U] @ q)) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n D) (length (b1 @ [U] @ q)) 0)\n        \\<delta>' \\<and>\n       \\<gamma> = (b1 @ [U] @ q) @ \\<delta>' \\<and>\n       j < length (b1 @ [U] @ q)", "apply (rule_tac x=\"\\<delta>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length D \\<and>\n    LeftDerivation \\<alpha> ((i, r) # take n D) (b1 @ [U] @ q) \\<and>\n    LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take n D)\n     ((b1 @ [U] @ q) @ \\<delta>) \\<and>\n    derivation_ge (drop n D) (length (b1 @ [U] @ q)) \\<and>\n    LeftDerivation \\<delta>\n     (derivation_shift (drop n D) (length (b1 @ [U] @ q)) 0) \\<delta> \\<and>\n    \\<gamma> = (b1 @ [U] @ q) @ \\<delta> \\<and> j < length (b1 @ [U] @ q)", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. n \\<le> length D\n 2. \\<exists>x.\n       LeftDerives1 \\<alpha> i r x \\<and>\n       LeftDerivation x (take n D) (b1 @ U # q)\n 3. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take n D) (b1 @ U # q @ \\<delta>)\n 4. derivation_ge (drop n D) (Suc (length b1 + length q))\n 5. LeftDerivation \\<delta>\n     (derivation_shift (drop n D) (Suc (length b1 + length q)) 0) \\<delta>\n 6. \\<gamma> = b1 @ U # q @ \\<delta>\n 7. j < Suc (length b1 + length q)", "apply (simp add: 1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 \\<alpha> i r x \\<and>\n       LeftDerivation x (take n D) (b1 @ U # q)\n 2. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take n D) (b1 @ U # q @ \\<delta>)\n 3. derivation_ge (drop n D) (Suc (length b1 + length q))\n 4. LeftDerivation \\<delta>\n     (derivation_shift (drop n D) (Suc (length b1 + length q)) 0) \\<delta>\n 5. \\<gamma> = b1 @ U # q @ \\<delta>\n 6. j < Suc (length b1 + length q)", "apply (rule_tac x=\"\\<alpha>'\" in exI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n    LeftDerivation \\<alpha>' (take n D) (b1 @ U # q)\n 2. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take n D) (b1 @ U # q @ \\<delta>)\n 3. derivation_ge (drop n D) (Suc (length b1 + length q))\n 4. LeftDerivation \\<delta>\n     (derivation_shift (drop n D) (Suc (length b1 + length q)) 0) \\<delta>\n 5. \\<gamma> = b1 @ U # q @ \\<delta>\n 6. j < Suc (length b1 + length q)", "apply (metis LeftDerivationFix_is_sentence LeftDerivation_append_suffix U \\<alpha>' \n            append_Cons append_Nil is_sentence_concat ld_\\<gamma> q)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take n D) (b1 @ U # q @ \\<delta>)\n 2. derivation_ge (drop n D) (Suc (length b1 + length q))\n 3. LeftDerivation \\<delta>\n     (derivation_shift (drop n D) (Suc (length b1 + length q)) 0) \\<delta>\n 4. \\<gamma> = b1 @ U # q @ \\<delta>\n 5. j < Suc (length b1 + length q)", "apply (rule_tac x=\"\\<alpha>' @ \\<delta>\" in exI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerives1 (\\<alpha> @ \\<delta>) i r (\\<alpha>' @ \\<delta>) \\<and>\n    LeftDerivation (\\<alpha>' @ \\<delta>) (take n D) (b1 @ U # q @ \\<delta>)\n 2. derivation_ge (drop n D) (Suc (length b1 + length q))\n 3. LeftDerivation \\<delta>\n     (derivation_shift (drop n D) (Suc (length b1 + length q)) 0) \\<delta>\n 4. \\<gamma> = b1 @ U # q @ \\<delta>\n 5. j < Suc (length b1 + length q)", "apply (metis \"1.hyps\" LeftDerivationFix_def U \\<alpha>' a2_eq_b2 id_take_nth_drop ld_\\<beta> \n            ld_\\<gamma> q splits_at_def take_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. derivation_ge (drop n D) (Suc (length b1 + length q))\n 2. LeftDerivation \\<delta>\n     (derivation_shift (drop n D) (Suc (length b1 + length q)) 0) \\<delta>\n 3. \\<gamma> = b1 @ U # q @ \\<delta>\n 4. j < Suc (length b1 + length q)", "apply (simp add: drop_n_D)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<gamma> = b1 @ U # q @ \\<delta>\n 2. j < Suc (length b1 + length q)", "apply (metis U a2_eq_b2 id_take_nth_drop q splits_at_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < Suc (length b1 + length q)", "using j"], ["proof (prove)\nusing this:\n  j = length b1\n\ngoal (1 subgoal):\n 1. j < Suc (length b1 + length q)", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>k \\<omega> \\<delta>'.\n     k \\<le> length D \\<and>\n     LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n     LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n      (\\<omega> @ \\<delta>) \\<and>\n     derivation_ge (drop k D) (length \\<omega>) \\<and>\n     LeftDerivation \\<delta>\n      (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n     \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "case 2"], ["proof (state)\nthis:\n  n < length D \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "obtain E where E: \"E = (derivation_shift (drop n D) (Suc (length b1)) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E.\n        E =\n        derivation_shift (drop n D) (Suc (length b1)) 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E = derivation_shift (drop n D) (Suc (length b1)) 0\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "then"], ["proof (chain)\npicking this:\n  E = derivation_shift (drop n D) (Suc (length b1)) 0", "have \"LeftDerivation (q@\\<delta>) E b2\""], ["proof (prove)\nusing this:\n  E = derivation_shift (drop n D) (Suc (length b1)) 0\n\ngoal (1 subgoal):\n 1. LeftDerivation (q @ \\<delta>) E b2", "using U q"], ["proof (prove)\nusing this:\n  E = derivation_shift (drop n D) (Suc (length b1)) 0\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n  a2 = q @ \\<delta> \\<and> \\<alpha>' = a1 @ [U] @ q\n\ngoal (1 subgoal):\n 1. LeftDerivation (q @ \\<delta>) E b2", "by simp"], ["proof (state)\nthis:\n  LeftDerivation (q @ \\<delta>) E b2\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "from LeftDerivation_breakdown'[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n w1 w2.\n     n \\<le> length E \\<and>\n     b2 = w1 @ w2 \\<and>\n     LeftDerivation q (take n E) w1 \\<and>\n     derivation_ge (drop n E) (length w1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift (drop n E) (length w1) 0) w2", "obtain n' w1 w2 where w1w2:\n        \"n' \\<le> length E \\<and>\n         b2 = w1 @ w2 \\<and>\n         LeftDerivation q (take n' E) w1 \\<and>\n         derivation_ge (drop n' E) (length w1) \\<and>\n         LeftDerivation \\<delta> (derivation_shift (drop n' E) (length w1) 0) w2\""], ["proof (prove)\nusing this:\n  \\<exists>n w1 w2.\n     n \\<le> length E \\<and>\n     b2 = w1 @ w2 \\<and>\n     LeftDerivation q (take n E) w1 \\<and>\n     derivation_ge (drop n E) (length w1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift (drop n E) (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. (\\<And>n' w1 w2.\n        n' \\<le> length E \\<and>\n        b2 = w1 @ w2 \\<and>\n        LeftDerivation q (take n' E) w1 \\<and>\n        derivation_ge (drop n' E) (length w1) \\<and>\n        LeftDerivation \\<delta> (derivation_shift (drop n' E) (length w1) 0)\n         w2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n' \\<le> length E \\<and>\n  b2 = w1 @ w2 \\<and>\n  LeftDerivation q (take n' E) w1 \\<and>\n  derivation_ge (drop n' E) (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' E) (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have length_E_D: \"length E = length D - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length E = length D - n", "using E n_bound"], ["proof (prove)\nusing this:\n  E = derivation_shift (drop n D) (Suc (length b1)) 0\n  n \\<le> length D\n\ngoal (1 subgoal):\n 1. length E = length D - n", "by simp"], ["proof (state)\nthis:\n  length E = length D - n\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have n_plus_n'_bound: \"n + n' \\<le> length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + n' \\<le> length D", "using length_E_D w1w2 n_bound"], ["proof (prove)\nusing this:\n  length E = length D - n\n  n' \\<le> length E \\<and>\n  b2 = w1 @ w2 \\<and>\n  LeftDerivation q (take n' E) w1 \\<and>\n  derivation_ge (drop n' E) (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' E) (length w1) 0) w2\n  n \\<le> length D\n\ngoal (1 subgoal):\n 1. n + n' \\<le> length D", "by arith"], ["proof (state)\nthis:\n  n + n' \\<le> length D\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have take_breakdown: \"take (n + n') D = (take n D) @ (take n' (drop n D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (n + n') D = take n D @ take n' (drop n D)", "using take_add"], ["proof (prove)\nusing this:\n  take (?i + ?j) ?xs = take ?i ?xs @ take ?j (drop ?i ?xs)\n\ngoal (1 subgoal):\n 1. take (n + n') D = take n D @ take n' (drop n D)", "by blast"], ["proof (state)\nthis:\n  take (n + n') D = take n D @ take n' (drop n D)\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have q_w1: \"LeftDerivation q (take n' E) w1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation q (take n' E) w1", "using w1w2"], ["proof (prove)\nusing this:\n  n' \\<le> length E \\<and>\n  b2 = w1 @ w2 \\<and>\n  LeftDerivation q (take n' E) w1 \\<and>\n  derivation_ge (drop n' E) (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' E) (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. LeftDerivation q (take n' E) w1", "by blast"], ["proof (state)\nthis:\n  LeftDerivation q (take n' E) w1\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have isw: \"is_word (b1 @ [U])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_word (b1 @ [U])", "using 2"], ["proof (prove)\nusing this:\n  n < length D \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. is_word (b1 @ [U])", "by blast"], ["proof (state)\nthis:\n  is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have take_n': \"take n' (drop n D) = derivation_shift (take n' E) 0 (Suc (length b1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n' (drop n D) = derivation_shift (take n' E) 0 (Suc (length b1))", "by (metis E U derivation_shift_left_right_cancel take_derivation_shift)"], ["proof (state)\nthis:\n  take n' (drop n D) = derivation_shift (take n' E) 0 (Suc (length b1))\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have \\<alpha>'_derives_b1_U_w1: \"LeftDerivation \\<alpha>' (take (n + n') D) (b1 @ U # w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha>' (take (n + n') D) (b1 @ U # w1)", "apply (subst take_breakdown)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha>' (take n D @ take n' (drop n D)) (b1 @ U # w1)", "apply (rule_tac LeftDerivation_implies_append[where b=\"b1@[U]@q\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivation \\<alpha>' (take n D) (b1 @ [U] @ q)\n 2. LeftDerivation (b1 @ [U] @ q) (take n' (drop n D)) (b1 @ U # w1)", "apply (metis LeftDerivationFix_is_sentence LeftDerivation_append_suffix U \n          is_sentence_concat ld_\\<gamma> q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (b1 @ [U] @ q) (take n' (drop n D)) (b1 @ U # w1)", "apply (simp add: take_n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (b1 @ U # q)\n     (derivation_shift (take n' E) 0 (Suc (length b1))) (b1 @ U # w1)", "by (rule LeftDerivation_append_prefix[OF q_w1, where u = \"b1@[U]\", OF isw, simplified])"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha>' (take (n + n') D) (b1 @ U # w1)\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "have dge: \"derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))", "have \"derivation_ge (drop n' (drop n D)) (length b1 + 1 + length w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (drop n' (drop n D)) (length b1 + 1 + length w1)", "by (metis (no_types) E Suc_eq_plus1 U append_take_drop_id derivation_ge_append derivation_ge_shift_plus drop_derivation_shift w1w2)"], ["proof (state)\nthis:\n  derivation_ge (drop n' (drop n D)) (length b1 + 1 + length w1)\n\ngoal (1 subgoal):\n 1. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))", "then"], ["proof (chain)\npicking this:\n  derivation_ge (drop n' (drop n D)) (length b1 + 1 + length w1)", "show \"derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\""], ["proof (prove)\nusing this:\n  derivation_ge (drop n' (drop n D)) (length b1 + 1 + length w1)\n\ngoal (1 subgoal):\n 1. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))", "by (metis (no_types) Suc_eq_plus1 add.commute drop_drop semiring_normalization_rules(23))"], ["proof (state)\nthis:\n  derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n\ngoal (1 subgoal):\n 1. n < length D \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k \\<omega> \\<delta>'.\n       k \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "apply (rule_tac x=\"n+n'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<omega> \\<delta>'.\n       n + n' \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take (n + n') D) \\<omega> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take (n + n') D)\n        (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop (n + n') D) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (n + n') D) (length \\<omega>) 0)\n        \\<delta>' \\<and>\n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "apply (rule_tac x=\"b1 @ [U] @ w1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>'.\n       n + n' \\<le> length D \\<and>\n       LeftDerivation \\<alpha> ((i, r) # take (n + n') D)\n        (b1 @ [U] @ w1) \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take (n + n') D)\n        ((b1 @ [U] @ w1) @ \\<delta>) \\<and>\n       derivation_ge (drop (n + n') D) (length (b1 @ [U] @ w1)) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (n + n') D) (length (b1 @ [U] @ w1)) 0)\n        \\<delta>' \\<and>\n       \\<gamma> = (b1 @ [U] @ w1) @ \\<delta>' \\<and>\n       j < length (b1 @ [U] @ w1)", "apply (rule_tac x=w2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n + n' \\<le> length D \\<and>\n    LeftDerivation \\<alpha> ((i, r) # take (n + n') D)\n     (b1 @ [U] @ w1) \\<and>\n    LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take (n + n') D)\n     ((b1 @ [U] @ w1) @ \\<delta>) \\<and>\n    derivation_ge (drop (n + n') D) (length (b1 @ [U] @ w1)) \\<and>\n    LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (length (b1 @ [U] @ w1)) 0)\n     w2 \\<and>\n    \\<gamma> = (b1 @ [U] @ w1) @ w2 \\<and> j < length (b1 @ [U] @ w1)", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. n + n' \\<le> length D\n 2. \\<exists>x.\n       LeftDerives1 \\<alpha> i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1)\n 3. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1 @ \\<delta>)\n 4. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 5. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 6. \\<gamma> = b1 @ U # w1 @ w2\n 7. j < Suc (length b1 + length w1)", "using n_plus_n'_bound"], ["proof (prove)\nusing this:\n  n + n' \\<le> length D\n\ngoal (7 subgoals):\n 1. n + n' \\<le> length D\n 2. \\<exists>x.\n       LeftDerives1 \\<alpha> i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1)\n 3. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1 @ \\<delta>)\n 4. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 5. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 6. \\<gamma> = b1 @ U # w1 @ w2\n 7. j < Suc (length b1 + length w1)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 \\<alpha> i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1)\n 2. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1 @ \\<delta>)\n 3. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 4. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 5. \\<gamma> = b1 @ U # w1 @ w2\n 6. j < Suc (length b1 + length w1)", "apply (rule_tac x=\"\\<alpha>'\" in exI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n    LeftDerivation \\<alpha>' (take (n + n') D) (b1 @ U # w1)\n 2. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1 @ \\<delta>)\n 3. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 4. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 5. \\<gamma> = b1 @ U # w1 @ w2\n 6. j < Suc (length b1 + length w1)", "using \\<alpha>' \\<alpha>'_derives_b1_U_w1"], ["proof (prove)\nusing this:\n  \\<beta> = \\<alpha>' @ \\<delta> \\<and>\n  LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n  LeftDerivation \\<alpha>' (take (n + n') D) (b1 @ U # w1)\n\ngoal (6 subgoals):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n    LeftDerivation \\<alpha>' (take (n + n') D) (b1 @ U # w1)\n 2. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1 @ \\<delta>)\n 3. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 4. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 5. \\<gamma> = b1 @ U # w1 @ w2\n 6. j < Suc (length b1 + length w1)", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<exists>x.\n       LeftDerives1 (\\<alpha> @ \\<delta>) i r x \\<and>\n       LeftDerivation x (take (n + n') D) (b1 @ U # w1 @ \\<delta>)\n 2. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 3. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 4. \\<gamma> = b1 @ U # w1 @ w2\n 5. j < Suc (length b1 + length w1)", "apply (rule_tac x=\"\\<alpha>' @ \\<delta>\" in exI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerives1 (\\<alpha> @ \\<delta>) i r (\\<alpha>' @ \\<delta>) \\<and>\n    LeftDerivation (\\<alpha>' @ \\<delta>) (take (n + n') D)\n     (b1 @ U # w1 @ \\<delta>)\n 2. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 3. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 4. \\<gamma> = b1 @ U # w1 @ w2\n 5. j < Suc (length b1 + length w1)", "apply (metis Cons_eq_appendI LeftDerivationFix_is_sentence LeftDerivation_append_suffix\n          \\<alpha>' \\<alpha>'_derives_b1_U_w1 append_assoc is_sentence_concat ld_\\<beta> ld_\\<gamma>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. derivation_ge (drop (n + n') D) (Suc (length b1 + length w1))\n 2. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 3. \\<gamma> = b1 @ U # w1 @ w2\n 4. j < Suc (length b1 + length w1)", "apply (rule dge)"], ["proof (prove)\ngoal (3 subgoals):\n 1. LeftDerivation \\<delta>\n     (derivation_shift (drop (n + n') D) (Suc (length b1 + length w1)) 0) w2\n 2. \\<gamma> = b1 @ U # w1 @ w2\n 3. j < Suc (length b1 + length w1)", "apply (metis E Suc_eq_plus1 add.commute derivation_shift_0_shift drop_derivation_shift \n          drop_drop w1w2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<gamma> = b1 @ U # w1 @ w2\n 2. j < Suc (length b1 + length w1)", "using U splits_at_combine w1w2"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha>' @ \\<delta>) (i + ix) a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> \\<Longrightarrow>\n  ?\\<delta> = ?\\<alpha> @ [?N] @ ?\\<beta>\n  n' \\<le> length E \\<and>\n  b2 = w1 @ w2 \\<and>\n  LeftDerivation q (take n' E) w1 \\<and>\n  derivation_ge (drop n' E) (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' E) (length w1) 0) w2\n\ngoal (2 subgoals):\n 1. \\<gamma> = b1 @ U # w1 @ w2\n 2. j < Suc (length b1 + length w1)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < Suc (length b1 + length w1)", "by (simp add: j)"], ["proof (state)\nthis:\n  \\<exists>k \\<omega> \\<delta>'.\n     k \\<le> length D \\<and>\n     LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n     LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n      (\\<omega> @ \\<delta>) \\<and>\n     derivation_ge (drop k D) (length \\<omega>) \\<and>\n     LeftDerivation \\<delta>\n      (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n     \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k \\<omega> \\<delta>'.\n     k \\<le> length D \\<and>\n     LeftDerivation \\<alpha> ((i, r) # take k D) \\<omega> \\<and>\n     LeftDerivation (\\<alpha> @ \\<delta>) ((i, r) # take k D)\n      (\\<omega> @ \\<delta>) \\<and>\n     derivation_ge (drop k D) (length \\<omega>) \\<and>\n     LeftDerivation \\<delta>\n      (derivation_shift (drop k D) (length \\<omega>) 0) \\<delta>' \\<and>\n     \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationLadder_propagate:\n  \"LeftDerivationLadder (\\<alpha>@\\<delta>) D L \\<gamma> \\<Longrightarrow> ladder_i L 0 < length \\<alpha> \\<Longrightarrow> n = ladder_n L index\n   \\<Longrightarrow> index < length L \\<Longrightarrow> \n     if (index + 1 < length L) then\n       (\\<exists> \\<beta>. LeftDerivation \\<alpha> (take n D) \\<beta> \\<and> ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index = \\<beta>@\\<delta> \\<and> \n         ladder_j L index < length \\<beta>)\n     else \n       (\\<exists> n' \\<beta> \\<delta>'. (index = 0 \\<or> ladder_prev_n L index < n') \\<and> n' \\<le> n \\<and> LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n         LeftDerivation (\\<alpha>@\\<delta>) (take n' D) (\\<beta>@\\<delta>) \\<and>\n         derivation_ge (drop n' D) (length \\<beta>) \\<and> \n         LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n         ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index = \\<beta>@\\<delta>' \\<and> ladder_j L index < length \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n     ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n     index < length L\\<rbrakk>\n    \\<Longrightarrow> if index + 1 < length L\n                      then \\<exists>\\<beta>.\n                              LeftDerivation \\<alpha> (take n D)\n                               \\<beta> \\<and>\n                              ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                               index =\n                              \\<beta> @ \\<delta> \\<and>\n                              ladder_j L index < length \\<beta>\n                      else \\<exists>n' \\<beta> \\<delta>'.\n                              (index = 0 \\<or>\n                               ladder_prev_n L index < n') \\<and>\n                              n' \\<le> n \\<and>\n                              LeftDerivation \\<alpha> (take n' D)\n                               \\<beta> \\<and>\n                              LeftDerivation (\\<alpha> @ \\<delta>)\n                               (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                              derivation_ge (drop n' D)\n                               (length \\<beta>) \\<and>\n                              LeftDerivation \\<delta>\n                               (derivation_shift (drop n' D)\n                                 (length \\<beta>) 0)\n                               \\<delta>' \\<and>\n                              ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                               index =\n                              \\<beta> @ \\<delta>' \\<and>\n                              ladder_j L index < length \\<beta>", "proof (induct index arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L 0;\n        0 < length L\\<rbrakk>\n       \\<Longrightarrow> if 0 + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L 0 < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L 0 < length \\<beta>\n 2. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "case 0"], ["proof (state)\nthis:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  ladder_i L 0 < length \\<alpha>\n  n = ladder_n L 0\n  0 < length L\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L 0;\n        0 < length L\\<rbrakk>\n       \\<Longrightarrow> if 0 + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L 0 < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L 0 < length \\<beta>\n 2. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have ldfix:\n    \"LeftDerivationFix (\\<alpha>@\\<delta>) (ladder_i L 0) (take n D) (ladder_j L 0) (ladder_\\<gamma> (\\<alpha>@\\<delta>) D L 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n     (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)", "using \"0.prems\"(1) \"0.prems\"(3) LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  n = ladder_n L 0\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n     (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n   (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L 0;\n        0 < length L\\<rbrakk>\n       \\<Longrightarrow> if 0 + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L 0 < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L 0 < length \\<beta>\n 2. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "from 0"], ["proof (chain)\npicking this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  ladder_i L 0 < length \\<alpha>\n  n = ladder_n L 0\n  0 < length L", "have \"1 < length L \\<or> 1 = length L\""], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  ladder_i L 0 < length \\<alpha>\n  n = ladder_n L 0\n  0 < length L\n\ngoal (1 subgoal):\n 1. 1 < length L \\<or> 1 = length L", "by arith"], ["proof (state)\nthis:\n  1 < length L \\<or> 1 = length L\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L 0;\n        0 < length L\\<rbrakk>\n       \\<Longrightarrow> if 0 + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L 0 < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  0 =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L 0 < length \\<beta>\n 2. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  1 < length L \\<or> 1 = length L", "show ?case"], ["proof (prove)\nusing this:\n  1 < length L \\<or> 1 = length L\n\ngoal (1 subgoal):\n 1. if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "case 1"], ["proof (state)\nthis:\n  1 < length L\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"LeftDerivationIntrosAt (\\<alpha>@\\<delta>) D L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L 1", "using \"0.prems\"(1) \"1.hyps\" LeftDerivationIntros_def LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  1 < length L\n  LeftDerivationIntros ?a ?D ?L =\n  (\\<forall>index.\n      1 \\<le> index \\<and> index < length ?L \\<longrightarrow>\n      LeftDerivationIntrosAt ?a ?D ?L index)\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L 1", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L 1\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "from LeftDerivationIntrosAt_implies_nonterminal[OF this]"], ["proof (chain)\npicking this:\n  is_nonterminal\n   (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L 1 ! ladder_i L 1)", "have \"is_nonterminal (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 ! ladder_j L 0)\""], ["proof (prove)\nusing this:\n  is_nonterminal\n   (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L 1 ! ladder_i L 1)\n\ngoal (1 subgoal):\n 1. is_nonterminal\n     (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 ! ladder_j L 0)", "by (simp add: ladder_\\<alpha>_def ladder_i_def)"], ["proof (state)\nthis:\n  is_nonterminal\n   (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 ! ladder_j L 0)\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "with ldfix"], ["proof (chain)\npicking this:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n   (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n  is_nonterminal\n   (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 ! ladder_j L 0)", "have \"is_nonterminal ((\\<alpha>@\\<delta>) ! (ladder_i L 0))\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n   (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n  is_nonterminal\n   (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 ! ladder_j L 0)\n\ngoal (1 subgoal):\n 1. is_nonterminal ((\\<alpha> @ \\<delta>) ! ladder_i L 0)", "by (simp add: LeftDerivationFix_def)"], ["proof (state)\nthis:\n  is_nonterminal ((\\<alpha> @ \\<delta>) ! ladder_i L 0)\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "from LeftDerivationFix_splits_at_nonterminal[OF ldfix this]"], ["proof (chain)\npicking this:\n  \\<exists>U a1 a2 b1.\n     splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n     splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0)\n      b1 U a2 \\<and>\n     LeftDerivation a1 (take n D) b1", "obtain U a1 a2 b where thesplit:\n      \"splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n       splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b U a2 \\<and> \n       LeftDerivation a1 (take n D) b\""], ["proof (prove)\nusing this:\n  \\<exists>U a1 a2 b1.\n     splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n     splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0)\n      b1 U a2 \\<and>\n     LeftDerivation a1 (take n D) b1\n\ngoal (1 subgoal):\n 1. (\\<And>a1 U a2 b.\n        splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n        splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n         (ladder_j L 0) b U a2 \\<and>\n        LeftDerivation a1 (take n D) b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b U\n   a2 \\<and>\n  LeftDerivation a1 (take n D) b\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"\\<exists> \\<delta>'. a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>'.\n       a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'", "using thesplit splits_at_append_suffix_prevails"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b U\n   a2 \\<and>\n  LeftDerivation a1 (take n D) b\n  \\<lbrakk>splits_at (?a @ ?b) ?i ?u ?N ?v; ?i < length ?a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'. ?v = v' @ ?b \\<and> ?a = ?u @ [?N] @ v'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>'.\n       a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'", "using \"0.prems\"(2)"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b U\n   a2 \\<and>\n  LeftDerivation a1 (take n D) b\n  \\<lbrakk>splits_at (?a @ ?b) ?i ?u ?N ?v; ?i < length ?a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'. ?v = v' @ ?b \\<and> ?a = ?u @ [?N] @ v'\n  ladder_i L 0 < length \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>'.\n       a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<delta>'.\n     a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<delta>'.\n     a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'", "obtain \\<delta>' where \\<delta>': \"a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ ([U] @ \\<delta>')\""], ["proof (prove)\nusing this:\n  \\<exists>\\<delta>'.\n     a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>'.\n        a2 = \\<delta>' @ \\<delta> \\<and>\n        \\<alpha> = a1 @ [U] @ \\<delta>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "obtain \\<beta> where \\<beta>: \"\\<beta> = b @ ([U] @ \\<delta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<beta> = b @ [U] @ \\<delta>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta> = b @ [U] @ \\<delta>'\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"is_sentence \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "using LeftDerivationFix_is_sentence is_sentence_concat ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n   (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<alpha>\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  is_sentence \\<alpha>", "have \"is_sentence ([U] @ \\<delta>')\""], ["proof (prove)\nusing this:\n  is_sentence \\<alpha>\n\ngoal (1 subgoal):\n 1. is_sentence ([U] @ \\<delta>')", "using \\<delta>' is_sentence_concat"], ["proof (prove)\nusing this:\n  is_sentence \\<alpha>\n  a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n\ngoal (1 subgoal):\n 1. is_sentence ([U] @ \\<delta>')", "by blast"], ["proof (state)\nthis:\n  is_sentence ([U] @ \\<delta>')\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "with \\<delta>' thesplit"], ["proof (chain)\npicking this:\n  a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b U\n   a2 \\<and>\n  LeftDerivation a1 (take n D) b\n  is_sentence ([U] @ \\<delta>')", "have \"LeftDerivation (a1 @ ([U] @ \\<delta>')) (take n D) (b @ ([U] @ \\<delta>'))\""], ["proof (prove)\nusing this:\n  a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b U\n   a2 \\<and>\n  LeftDerivation a1 (take n D) b\n  is_sentence ([U] @ \\<delta>')\n\ngoal (1 subgoal):\n 1. LeftDerivation (a1 @ [U] @ \\<delta>') (take n D) (b @ [U] @ \\<delta>')", "using LeftDerivation_append_suffix"], ["proof (prove)\nusing this:\n  a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b U\n   a2 \\<and>\n  LeftDerivation a1 (take n D) b\n  is_sentence ([U] @ \\<delta>')\n  \\<lbrakk>LeftDerivation ?a ?D ?b; is_sentence ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?a @ ?c) ?D (?b @ ?c)\n\ngoal (1 subgoal):\n 1. LeftDerivation (a1 @ [U] @ \\<delta>') (take n D) (b @ [U] @ \\<delta>')", "by blast"], ["proof (state)\nthis:\n  LeftDerivation (a1 @ [U] @ \\<delta>') (take n D) (b @ [U] @ \\<delta>')\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (a1 @ [U] @ \\<delta>') (take n D) (b @ [U] @ \\<delta>')", "have \\<alpha>_derives_\\<beta>: \"LeftDerivation \\<alpha> (take n D) \\<beta>\""], ["proof (prove)\nusing this:\n  LeftDerivation (a1 @ [U] @ \\<delta>') (take n D) (b @ [U] @ \\<delta>')\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take n D) \\<beta>", "using \\<beta> \\<delta>'"], ["proof (prove)\nusing this:\n  LeftDerivation (a1 @ [U] @ \\<delta>') (take n D) (b @ [U] @ \\<delta>')\n  \\<beta> = b @ [U] @ \\<delta>'\n  a2 = \\<delta>' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ \\<delta>'\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take n D) \\<beta>", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take n D) \\<beta>\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \\<beta>_append_\\<delta>: \"ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta>@\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ \\<delta>", "by (metis \\<beta> \\<delta>' append_assoc splits_at_combine thesplit)"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ \\<delta>\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have ladder_j_bound: \"ladder_j L 0 < length \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L 0 < length \\<beta>", "by (metis One_nat_def \\<beta> diff_add_inverse dual_order.strict_implies_order leD le_add1 \n        length_Cons length_append length_take list.size(3) min.absorb2 neq0_conv splits_at_def \n        thesplit zero_less_diff zero_less_one)"], ["proof (state)\nthis:\n  ladder_j L 0 < length \\<beta>\n\ngoal (2 subgoals):\n 1. 1 < length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>\n 2. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "using 1"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (1 subgoal):\n 1. if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < length L \\<Longrightarrow>\n    \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L 0 < length \\<beta>", "apply (rule_tac x=\"\\<beta>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ \\<delta> \\<and>\n    ladder_j L 0 < length \\<beta>", "by (auto simp add: \\<alpha>_derives_\\<beta> \\<beta>_append_\\<delta> ladder_j_bound)"], ["proof (state)\nthis:\n  if 0 + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L 0 < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L 0 < length \\<beta>\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "case 2"], ["proof (state)\nthis:\n  1 = length L\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "note case_2 = 2"], ["proof (state)\nthis:\n  1 = length L\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have n_def: \"n = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length D", "by (metis \"0.prems\"(1) \"0.prems\"(3) \"2.hyps\" LeftDerivationLadder_def One_nat_def \n        diff_Suc_1 is_ladder_def ladder_last_n_intro)"], ["proof (state)\nthis:\n  n = length D\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  n = length D", "have take_n_D: \"take n D = D\""], ["proof (prove)\nusing this:\n  n = length D\n\ngoal (1 subgoal):\n 1. take n D = D", "by (simp add: eq_imp_le)"], ["proof (state)\nthis:\n  take n D = D\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "from LeftDerivationFix_splits_at_symbol[OF ldfix]"], ["proof (chain)\npicking this:\n  \\<exists>U a1 a2 b1 b2 n.\n     splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n     splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0)\n      b1 U b2 \\<and>\n     n \\<le> length (take n D) \\<and>\n     LeftDerivation a1 (take n (take n D)) b1 \\<and>\n     derivation_ge (drop n (take n D)) (Suc (length b1)) \\<and>\n     LeftDerivation a2\n      (derivation_shift (drop n (take n D)) (Suc (length b1)) 0) b2 \\<and>\n     (n = length (take n D) \\<or>\n      n < length (take n D) \\<and> is_word (b1 @ [U]))", "obtain U a1 a2 b1 b2 m where U:\n      \"splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n       splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1 U b2 \\<and>\n       m \\<le> length (take n D) \\<and>\n       LeftDerivation a1 (take m (take n D)) b1 \\<and>\n       derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and> \n       LeftDerivation a2 (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n       (m = length (take n D) \\<or> (m < length (take n D) \\<and> is_word (b1 @ [U])))\""], ["proof (prove)\nusing this:\n  \\<exists>U a1 a2 b1 b2 n.\n     splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n     splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0)\n      b1 U b2 \\<and>\n     n \\<le> length (take n D) \\<and>\n     LeftDerivation a1 (take n (take n D)) b1 \\<and>\n     derivation_ge (drop n (take n D)) (Suc (length b1)) \\<and>\n     LeftDerivation a2\n      (derivation_shift (drop n (take n D)) (Suc (length b1)) 0) b2 \\<and>\n     (n = length (take n D) \\<or>\n      n < length (take n D) \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. (\\<And>a1 U a2 b1 b2 m.\n        splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n        splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n         (ladder_j L 0) b1 U b2 \\<and>\n        m \\<le> length (take n D) \\<and>\n        LeftDerivation a1 (take m (take n D)) b1 \\<and>\n        derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n        LeftDerivation a2\n         (derivation_shift (drop m (take n D)) (Suc (length b1)) 0)\n         b2 \\<and>\n        (m = length (take n D) \\<or>\n         m < length (take n D) \\<and> is_word (b1 @ [U])) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "obtain D' where D': \"D' = derivation_shift (drop m D) (Suc (length b1)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        D' =\n        derivation_shift (drop m D) (Suc (length b1)) 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D' = derivation_shift (drop m D) (Suc (length b1)) 0\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  D' = derivation_shift (drop m D) (Suc (length b1)) 0", "have a2_derives_b2: \"LeftDerivation a2 D' b2\""], ["proof (prove)\nusing this:\n  D' = derivation_shift (drop m D) (Suc (length b1)) 0\n\ngoal (1 subgoal):\n 1. LeftDerivation a2 D' b2", "using U take_n_D"], ["proof (prove)\nusing this:\n  D' = derivation_shift (drop m D) (Suc (length b1)) 0\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n  take n D = D\n\ngoal (1 subgoal):\n 1. LeftDerivation a2 D' b2", "by auto"], ["proof (state)\nthis:\n  LeftDerivation a2 D' b2\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "from U"], ["proof (chain)\npicking this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))", "have m_leq_n: \"m \\<le> n\""], ["proof (prove)\nusing this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by (simp add: \"0.prems\"(1) \"0.prems\"(3) \"0.prems\"(4) LeftDerivationLadder_def is_ladder_def \n         min.absorb2)"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "from U"], ["proof (chain)\npicking this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))", "have \"splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2\""], ["proof (prove)\nusing this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2", "by blast"], ["proof (state)\nthis:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "from splits_at_append_suffix_prevails[OF this 0(2)]"], ["proof (chain)\npicking this:\n  \\<exists>v'. a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v'", "obtain v' where \n      v': \"a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v'\""], ["proof (prove)\nusing this:\n  \\<exists>v'. a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v'\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v'\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have a1_derives_b1: \"LeftDerivation a1 (take m D) b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation a1 (take m D) b1", "using m_leq_n U"], ["proof (prove)\nusing this:\n  m \\<le> n\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. LeftDerivation a1 (take m D) b1", "by (metis \"0.prems\"(1) \"0.prems\"(3) \"2.hyps\" LeftDerivationLadder_def One_nat_def \n        cancel_comm_monoid_add_class.diff_cancel is_ladder_def ladder_last_n_intro order_refl \n        take_all)"], ["proof (state)\nthis:\n  LeftDerivation a1 (take m D) b1\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"LeftDerivation (v' @ \\<delta>) D' b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (v' @ \\<delta>) D' b2", "using a2_derives_b2 v'"], ["proof (prove)\nusing this:\n  LeftDerivation a2 D' b2\n  a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v'\n\ngoal (1 subgoal):\n 1. LeftDerivation (v' @ \\<delta>) D' b2", "by simp"], ["proof (state)\nthis:\n  LeftDerivation (v' @ \\<delta>) D' b2\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "from LeftDerivation_breakdown'[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n w1 w2.\n     n \\<le> length D' \\<and>\n     b2 = w1 @ w2 \\<and>\n     LeftDerivation v' (take n D') w1 \\<and>\n     derivation_ge (drop n D') (length w1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift (drop n D') (length w1) 0) w2", "obtain m' w1 w2 where w12:\n      \"b2 = w1 @ w2 \\<and>\n       m' \\<le> length D' \\<and>\n       LeftDerivation v' (take m' D') w1 \\<and>\n       derivation_ge (drop m' D') (length w1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift (drop m' D') (length w1) 0) w2\""], ["proof (prove)\nusing this:\n  \\<exists>n w1 w2.\n     n \\<le> length D' \\<and>\n     b2 = w1 @ w2 \\<and>\n     LeftDerivation v' (take n D') w1 \\<and>\n     derivation_ge (drop n D') (length w1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift (drop n D') (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2 m'.\n        b2 = w1 @ w2 \\<and>\n        m' \\<le> length D' \\<and>\n        LeftDerivation v' (take m' D') w1 \\<and>\n        derivation_ge (drop m' D') (length w1) \\<and>\n        LeftDerivation \\<delta>\n         (derivation_shift (drop m' D') (length w1) 0) w2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b2 = w1 @ w2 \\<and>\n  m' \\<le> length D' \\<and>\n  LeftDerivation v' (take m' D') w1 \\<and>\n  derivation_ge (drop m' D') (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop m' D') (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"length D' \\<le> length D - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length D' \\<le> length D - m", "by (simp add: D')"], ["proof (state)\nthis:\n  length D' \\<le> length D - m\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  length D' \\<le> length D - m", "have \"m' \\<le> length D - m\""], ["proof (prove)\nusing this:\n  length D' \\<le> length D - m\n\ngoal (1 subgoal):\n 1. m' \\<le> length D - m", "using w12 dual_order.trans"], ["proof (prove)\nusing this:\n  length D' \\<le> length D - m\n  b2 = w1 @ w2 \\<and>\n  m' \\<le> length D' \\<and>\n  LeftDerivation v' (take m' D') w1 \\<and>\n  derivation_ge (drop m' D') (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop m' D') (length w1) 0) w2\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. m' \\<le> length D - m", "by blast"], ["proof (state)\nthis:\n  m' \\<le> length D - m\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  m' \\<le> length D - m", "have m_m'_leq_n: \"m + m' \\<le> n\""], ["proof (prove)\nusing this:\n  m' \\<le> length D - m\n\ngoal (1 subgoal):\n 1. m + m' \\<le> n", "using n_def m_leq_n le_diff_conv2 add.commute"], ["proof (prove)\nusing this:\n  m' \\<le> length D - m\n  n = length D\n  m \\<le> n\n  ?k \\<le> ?j \\<Longrightarrow> (?i \\<le> ?j - ?k) = (?i + ?k \\<le> ?j)\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. m + m' \\<le> n", "by linarith"], ["proof (state)\nthis:\n  m + m' \\<le> n\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "obtain \\<beta> where \\<beta>: \"\\<beta> = b1 @ ([U] @ w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<beta> = b1 @ [U] @ w1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta> = b1 @ [U] @ w1\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"is_sentence ([U] @ v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence ([U] @ v')", "using LeftDerivationFix_is_sentence is_sentence_concat ldfix v'"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n   (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n  a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v'\n\ngoal (1 subgoal):\n 1. is_sentence ([U] @ v')", "by blast"], ["proof (state)\nthis:\n  is_sentence ([U] @ v')\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  is_sentence ([U] @ v')", "have \"LeftDerivation (a1 @ ([U] @ v')) (take m D) (b1 @ ([U] @ v'))\""], ["proof (prove)\nusing this:\n  is_sentence ([U] @ v')\n\ngoal (1 subgoal):\n 1. LeftDerivation (a1 @ [U] @ v') (take m D) (b1 @ [U] @ v')", "using LeftDerivation_append_suffix a1_derives_b1"], ["proof (prove)\nusing this:\n  is_sentence ([U] @ v')\n  \\<lbrakk>LeftDerivation ?a ?D ?b; is_sentence ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?a @ ?c) ?D (?b @ ?c)\n  LeftDerivation a1 (take m D) b1\n\ngoal (1 subgoal):\n 1. LeftDerivation (a1 @ [U] @ v') (take m D) (b1 @ [U] @ v')", "by blast"], ["proof (state)\nthis:\n  LeftDerivation (a1 @ [U] @ v') (take m D) (b1 @ [U] @ v')\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (a1 @ [U] @ v') (take m D) (b1 @ [U] @ v')", "have \\<alpha>_derives_pre_\\<beta>: \"LeftDerivation \\<alpha> (take m D) (b1 @ ([U] @ v'))\""], ["proof (prove)\nusing this:\n  LeftDerivation (a1 @ [U] @ v') (take m D) (b1 @ [U] @ v')\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take m D) (b1 @ [U] @ v')", "using v'"], ["proof (prove)\nusing this:\n  LeftDerivation (a1 @ [U] @ v') (take m D) (b1 @ [U] @ v')\n  a2 = v' @ \\<delta> \\<and> \\<alpha> = a1 @ [U] @ v'\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take m D) (b1 @ [U] @ v')", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take m D) (b1 @ [U] @ v')\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"m = n \\<or> (m < n \\<and> is_word (b1 @ [U]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = n \\<or> m < n \\<and> is_word (b1 @ [U])", "using U n_def[symmetric] take_n_D"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n  length D = n\n  take n D = D\n\ngoal (1 subgoal):\n 1. m = n \\<or> m < n \\<and> is_word (b1 @ [U])", "by simp"], ["proof (state)\nthis:\n  m = n \\<or> m < n \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  m = n \\<or> m < n \\<and> is_word (b1 @ [U])", "have pre_\\<beta>_derives_\\<beta>: \"LeftDerivation (b1 @ ([U] @ v')) (take m' (drop m D)) \\<beta>\""], ["proof (prove)\nusing this:\n  m = n \\<or> m < n \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>\n 2. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "case 1"], ["proof (state)\nthis:\n  m = n\n\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>\n 2. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "then"], ["proof (chain)\npicking this:\n  m = n", "have \"m' = 0\""], ["proof (prove)\nusing this:\n  m = n\n\ngoal (1 subgoal):\n 1. m' = 0", "using m_m'_leq_n"], ["proof (prove)\nusing this:\n  m = n\n  m + m' \\<le> n\n\ngoal (1 subgoal):\n 1. m' = 0", "by arith"], ["proof (state)\nthis:\n  m' = 0\n\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>\n 2. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "then"], ["proof (chain)\npicking this:\n  m' = 0", "show ?case"], ["proof (prove)\nusing this:\n  m' = 0\n\ngoal (1 subgoal):\n 1. LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "apply (simp add: \\<beta>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' = 0 \\<Longrightarrow> v' = w1", "using w12"], ["proof (prove)\nusing this:\n  b2 = w1 @ w2 \\<and>\n  m' \\<le> length D' \\<and>\n  LeftDerivation v' (take m' D') w1 \\<and>\n  derivation_ge (drop m' D') (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop m' D') (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. m' = 0 \\<Longrightarrow> v' = w1", "by simp"], ["proof (state)\nthis:\n  LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>\n\ngoal (1 subgoal):\n 1. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "case 2"], ["proof (state)\nthis:\n  m < n \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "then"], ["proof (chain)\npicking this:\n  m < n \\<and> is_word (b1 @ [U])", "have is_word_prefix: \"is_word (b1 @ [U])\""], ["proof (prove)\nusing this:\n  m < n \\<and> is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. is_word (b1 @ [U])", "by blast"], ["proof (state)\nthis:\n  is_word (b1 @ [U])\n\ngoal (1 subgoal):\n 1. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "have take_drop_eq: \"take m' (drop m D) = derivation_shift (take m' D') \n            0 (length (b1 @ [U]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take m' (drop m D) = derivation_shift (take m' D') 0 (length (b1 @ [U]))", "apply (simp add: D' take_derivation_shift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take m' (drop m D) =\n    derivation_shift\n     (derivation_shift (take m' (drop m D)) (Suc (length b1)) 0) 0\n     (Suc (length b1))", "by (metis U derivation_shift_left_right_cancel take_derivation_shift take_n_D)"], ["proof (state)\nthis:\n  take m' (drop m D) = derivation_shift (take m' D') 0 (length (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "have v'_derives_w1: \"LeftDerivation v' (take m' D') w1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation v' (take m' D') w1", "by (simp add: w12)"], ["proof (state)\nthis:\n  LeftDerivation v' (take m' D') w1\n\ngoal (1 subgoal):\n 1. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "with is_word_prefix"], ["proof (chain)\npicking this:\n  is_word (b1 @ [U])\n  LeftDerivation v' (take m' D') w1", "have \n          \"LeftDerivation ((b1 @ [U]) @ v') (derivation_shift (take m' D') \n            0 (length (b1 @ [U]))) ((b1 @ [U]) @ w1)\""], ["proof (prove)\nusing this:\n  is_word (b1 @ [U])\n  LeftDerivation v' (take m' D') w1\n\ngoal (1 subgoal):\n 1. LeftDerivation ((b1 @ [U]) @ v')\n     (derivation_shift (take m' D') 0 (length (b1 @ [U]))) ((b1 @ [U]) @ w1)", "using  LeftDerivation_append_prefix"], ["proof (prove)\nusing this:\n  is_word (b1 @ [U])\n  LeftDerivation v' (take m' D') w1\n  \\<lbrakk>LeftDerivation ?v ?D ?w; is_word ?u\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?u @ ?v)\n                     (derivation_shift ?D 0 (length ?u)) (?u @ ?w)\n\ngoal (1 subgoal):\n 1. LeftDerivation ((b1 @ [U]) @ v')\n     (derivation_shift (take m' D') 0 (length (b1 @ [U]))) ((b1 @ [U]) @ w1)", "by blast"], ["proof (state)\nthis:\n  LeftDerivation ((b1 @ [U]) @ v')\n   (derivation_shift (take m' D') 0 (length (b1 @ [U]))) ((b1 @ [U]) @ w1)\n\ngoal (1 subgoal):\n 1. m < n \\<and> is_word (b1 @ [U]) \\<Longrightarrow>\n    LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "with take_drop_eq"], ["proof (chain)\npicking this:\n  take m' (drop m D) = derivation_shift (take m' D') 0 (length (b1 @ [U]))\n  LeftDerivation ((b1 @ [U]) @ v')\n   (derivation_shift (take m' D') 0 (length (b1 @ [U]))) ((b1 @ [U]) @ w1)", "show ?case"], ["proof (prove)\nusing this:\n  take m' (drop m D) = derivation_shift (take m' D') 0 (length (b1 @ [U]))\n  LeftDerivation ((b1 @ [U]) @ v')\n   (derivation_shift (take m' D') 0 (length (b1 @ [U]))) ((b1 @ [U]) @ w1)\n\ngoal (1 subgoal):\n 1. LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>", "by (simp add: \\<beta>)"], ["proof (state)\nthis:\n  LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \"(take m D) @ (take m' (drop m D)) = (take (m + m') D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take m D @ take m' (drop m D) = take (m + m') D", "by (simp add: take_add)"], ["proof (state)\nthis:\n  take m D @ take m' (drop m D) = take (m + m') D\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  take m D @ take m' (drop m D) = take (m + m') D", "have \\<alpha>_derives_\\<beta>: \"LeftDerivation \\<alpha> (take (m + m') D) \\<beta>\""], ["proof (prove)\nusing this:\n  take m D @ take m' (drop m D) = take (m + m') D\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (m + m') D) \\<beta>", "using LeftDerivation_implies_append \\<alpha>_derives_pre_\\<beta> pre_\\<beta>_derives_\\<beta>"], ["proof (prove)\nusing this:\n  take m D @ take m' (drop m D) = take (m + m') D\n  \\<lbrakk>LeftDerivation ?a ?D ?b; LeftDerivation ?b ?E ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?a (?D @ ?E) ?c\n  LeftDerivation \\<alpha> (take m D) (b1 @ [U] @ v')\n  LeftDerivation (b1 @ [U] @ v') (take m' (drop m D)) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (m + m') D) \\<beta>", "by fastforce"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (m + m') D) \\<beta>\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have derivation_ge_drop_m_m': \"derivation_ge (drop (m + m') D) (length \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (drop (m + m') D) (length \\<beta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. derivation_ge (drop (m + m') D) (length \\<beta>)", "have f1: \"drop m' (drop m D) = drop (m + m') D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop m' (drop m D) = drop (m + m') D", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  drop m' (drop m D) = drop (m + m') D\n\ngoal (1 subgoal):\n 1. derivation_ge (drop (m + m') D) (length \\<beta>)", "have \"derivation_ge (drop m' (drop m D)) (Suc (length b1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (drop m' (drop m D)) (Suc (length b1))", "by (metis (no_types) U append_take_drop_id derivation_ge_append take_n_D)"], ["proof (state)\nthis:\n  derivation_ge (drop m' (drop m D)) (Suc (length b1))\n\ngoal (1 subgoal):\n 1. derivation_ge (drop (m + m') D) (length \\<beta>)", "then"], ["proof (chain)\npicking this:\n  derivation_ge (drop m' (drop m D)) (Suc (length b1))", "show \"derivation_ge (drop (m + m') D) (length \\<beta>)\""], ["proof (prove)\nusing this:\n  derivation_ge (drop m' (drop m D)) (Suc (length b1))\n\ngoal (1 subgoal):\n 1. derivation_ge (drop (m + m') D) (length \\<beta>)", "using f1"], ["proof (prove)\nusing this:\n  derivation_ge (drop m' (drop m D)) (Suc (length b1))\n  drop m' (drop m D) = drop (m + m') D\n\ngoal (1 subgoal):\n 1. derivation_ge (drop (m + m') D) (length \\<beta>)", "by (metis (no_types) D' \\<beta> append_assoc derivation_ge_shift_plus \n            drop_derivation_shift length_append length_append_singleton w12)"], ["proof (state)\nthis:\n  derivation_ge (drop (m + m') D) (length \\<beta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  derivation_ge (drop (m + m') D) (length \\<beta>)\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have \\<delta>_derives_w2: \"LeftDerivation \\<delta> (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2", "have \"derivation_shift (drop m' D') (length w1) 0 = derivation_shift (drop (m + m') D) (length \\<beta>) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_shift (drop m' D') (length w1) 0 =\n    derivation_shift (drop (m + m') D) (length \\<beta>) 0", "by (simp add: D' \\<beta> add.commute derivation_shift_0_shift drop_derivation_shift)"], ["proof (state)\nthis:\n  derivation_shift (drop m' D') (length w1) 0 =\n  derivation_shift (drop (m + m') D) (length \\<beta>) 0\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2", "then"], ["proof (chain)\npicking this:\n  derivation_shift (drop m' D') (length w1) 0 =\n  derivation_shift (drop (m + m') D) (length \\<beta>) 0", "show \"LeftDerivation \\<delta> (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2\""], ["proof (prove)\nusing this:\n  derivation_shift (drop m' D') (length w1) 0 =\n  derivation_shift (drop (m + m') D) (length \\<beta>) 0\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2", "using w12"], ["proof (prove)\nusing this:\n  derivation_shift (drop m' D') (length w1) 0 =\n  derivation_shift (drop (m + m') D) (length \\<beta>) 0\n  b2 = w1 @ w2 \\<and>\n  m' \\<le> length D' \\<and>\n  LeftDerivation v' (take m' D') w1 \\<and>\n  derivation_ge (drop m' D') (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop m' D') (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2", "by presburger"], ["proof (state)\nthis:\n  LeftDerivation \\<delta>\n   (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivation \\<delta>\n   (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have ladder_\\<gamma>_def: \"ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2", "using U \\<beta> splits_at_combine w12"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n  \\<beta> = b1 @ [U] @ w1\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> \\<Longrightarrow>\n  ?\\<delta> = ?\\<alpha> @ [?N] @ ?\\<beta>\n  b2 = w1 @ w2 \\<and>\n  m' \\<le> length D' \\<and>\n  LeftDerivation v' (take m' D') w1 \\<and>\n  derivation_ge (drop m' D') (length w1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop m' D') (length w1) 0) w2\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2", "by auto"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "have ladder_j_bound: \"ladder_j L 0 < length \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L 0 < length \\<beta>", "using U \\<beta> splits_at_def"], ["proof (prove)\nusing this:\n  splits_at (\\<alpha> @ \\<delta>) (ladder_i L 0) a1 U a2 \\<and>\n  splits_at (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0) (ladder_j L 0) b1\n   U b2 \\<and>\n  m \\<le> length (take n D) \\<and>\n  LeftDerivation a1 (take m (take n D)) b1 \\<and>\n  derivation_ge (drop m (take n D)) (Suc (length b1)) \\<and>\n  LeftDerivation a2\n   (derivation_shift (drop m (take n D)) (Suc (length b1)) 0) b2 \\<and>\n  (m = length (take n D) \\<or>\n   m < length (take n D) \\<and> is_word (b1 @ [U]))\n  \\<beta> = b1 @ [U] @ w1\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. ladder_j L 0 < length \\<beta>", "by auto"], ["proof (state)\nthis:\n  ladder_j L 0 < length \\<beta>\n\ngoal (1 subgoal):\n 1. 1 = length L \\<Longrightarrow>\n    if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "using 2"], ["proof (prove)\nusing this:\n  1 = length L\n\ngoal (1 subgoal):\n 1. if 0 + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L 0 < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow>\n    \\<exists>n'\\<le>n.\n       \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          (\\<exists>\\<delta>'.\n              LeftDerivation \\<delta>\n               (derivation_shift (drop n' D) (length \\<beta>) 0)\n               \\<delta>' \\<and>\n              ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n              \\<beta> @ \\<delta>' \\<and>\n              ladder_j L 0 < length \\<beta>)", "apply (rule_tac x=\"m + m'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow>\n    m + m' \\<le> n \\<and>\n    (\\<exists>\\<beta>.\n        LeftDerivation \\<alpha> (take (m + m') D) \\<beta> \\<and>\n        LeftDerivation (\\<alpha> @ \\<delta>) (take (m + m') D)\n         (\\<beta> @ \\<delta>) \\<and>\n        derivation_ge (drop (m + m') D) (length \\<beta>) \\<and>\n        (\\<exists>\\<delta>'.\n            LeftDerivation \\<delta>\n             (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L 0 < length \\<beta>))", "apply (auto simp add: m_m'_leq_n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow>\n    \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take (m + m') D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take (m + m') D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop (m + m') D) (length \\<beta>) \\<and>\n       (\\<exists>\\<delta>'.\n           LeftDerivation \\<delta>\n            (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n            \\<delta>' \\<and>\n           ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n           \\<beta> @ \\<delta>' \\<and>\n           ladder_j L 0 < length \\<beta>)", "apply (rule_tac x=\"\\<beta>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (m + m') D) \\<beta> \\<and>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (m + m') D)\n     (\\<beta> @ \\<delta>) \\<and>\n    derivation_ge (drop (m + m') D) (length \\<beta>) \\<and>\n    (\\<exists>\\<delta>'.\n        LeftDerivation \\<delta>\n         (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n         \\<delta>' \\<and>\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n        \\<beta> @ \\<delta>' \\<and>\n        ladder_j L 0 < length \\<beta>)", "apply (auto simp add: \\<alpha>_derives_\\<beta>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (m + m') D)\n     (\\<beta> @ \\<delta>)\n 2. Suc 0 = length L \\<Longrightarrow>\n    derivation_ge (drop (m + m') D) (length \\<beta>)\n 3. Suc 0 = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L 0 < length \\<beta>", "using LeftDerivationFix_is_sentence LeftDerivation_append_suffix \\<alpha>_derives_\\<beta> \n        is_sentence_concat ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  \\<lbrakk>LeftDerivation ?a ?D ?b; is_sentence ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?a @ ?c) ?D (?b @ ?c)\n  LeftDerivation \\<alpha> (take (m + m') D) \\<beta>\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) (take n D)\n   (ladder_j L 0) (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n\ngoal (3 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (m + m') D)\n     (\\<beta> @ \\<delta>)\n 2. Suc 0 = length L \\<Longrightarrow>\n    derivation_ge (drop (m + m') D) (length \\<beta>)\n 3. Suc 0 = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L 0 < length \\<beta>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    derivation_ge (drop (m + m') D) (length \\<beta>)\n 2. Suc 0 = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L 0 < length \\<beta>", "using derivation_ge_drop_m_m'"], ["proof (prove)\nusing this:\n  derivation_ge (drop (m + m') D) (length \\<beta>)\n\ngoal (2 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    derivation_ge (drop (m + m') D) (length \\<beta>)\n 2. Suc 0 = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L 0 < length \\<beta>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (m + m') D) (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L 0 < length \\<beta>", "apply (rule_tac x=\"w2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow>\n    LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2 \\<and>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2 \\<and>\n    ladder_j L 0 < length \\<beta>", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2\n 2. Suc 0 = length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2\n 3. Suc 0 = length L \\<Longrightarrow> ladder_j L 0 < length \\<beta>", "using \\<delta>_derives_w2"], ["proof (prove)\nusing this:\n  LeftDerivation \\<delta>\n   (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2\n\ngoal (3 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    LeftDerivation \\<delta>\n     (derivation_shift (drop (m + m') D) (length \\<beta>) 0) w2\n 2. Suc 0 = length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2\n 3. Suc 0 = length L \\<Longrightarrow> ladder_j L 0 < length \\<beta>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2\n 2. Suc 0 = length L \\<Longrightarrow> ladder_j L 0 < length \\<beta>", "using ladder_\\<gamma>_def"], ["proof (prove)\nusing this:\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2\n\ngoal (2 subgoals):\n 1. Suc 0 = length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 = \\<beta> @ w2\n 2. Suc 0 = length L \\<Longrightarrow> ladder_j L 0 < length \\<beta>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow> ladder_j L 0 < length \\<beta>", "using ladder_j_bound"], ["proof (prove)\nusing this:\n  ladder_j L 0 < length \\<beta>\n\ngoal (1 subgoal):\n 1. Suc 0 = length L \\<Longrightarrow> ladder_j L 0 < length \\<beta>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  if 0 + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L 0 < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L 0 < length \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if 0 + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L 0 < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (0 = 0 \\<or> ladder_prev_n L 0 < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L 0 < length \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "case (Suc index)"], ["proof (state)\nthis:\n  \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n   ladder_i L 0 < length \\<alpha>; ?n = ladder_n L index;\n   index < length L\\<rbrakk>\n  \\<Longrightarrow> if index + 1 < length L\n                    then \\<exists>\\<beta>.\n                            LeftDerivation \\<alpha> (take ?n D)\n                             \\<beta> \\<and>\n                            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                             index =\n                            \\<beta> @ \\<delta> \\<and>\n                            ladder_j L index < length \\<beta>\n                    else \\<exists>n' \\<beta> \\<delta>'.\n                            (index = 0 \\<or>\n                             ladder_prev_n L index < n') \\<and>\n                            n' \\<le> ?n \\<and>\n                            LeftDerivation \\<alpha> (take n' D)\n                             \\<beta> \\<and>\n                            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n                             (\\<beta> @ \\<delta>) \\<and>\n                            derivation_ge (drop n' D)\n                             (length \\<beta>) \\<and>\n                            LeftDerivation \\<delta>\n                             (derivation_shift (drop n' D) (length \\<beta>)\n                               0)\n                             \\<delta>' \\<and>\n                            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                             index =\n                            \\<beta> @ \\<delta>' \\<and>\n                            ladder_j L index < length \\<beta>\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  ladder_i L 0 < length \\<alpha>\n  n = ladder_n L (Suc index)\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have step: \"LeftDerivationIntrosAt (\\<alpha>@\\<delta>) D L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L (Suc index)", "by (metis LeftDerivationIntros_def LeftDerivationLadder_def Suc.prems(1) Suc.prems(4)      \n      Suc_eq_plus1_left le_add1)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have index_plus_1_bound: \"index + 1 < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index + 1 < length L", "using Suc.prems(4)"], ["proof (prove)\nusing this:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. index + 1 < length L", "by linarith"], ["proof (state)\nthis:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  index + 1 < length L", "have index_bound: \"index < length L\""], ["proof (prove)\nusing this:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. index < length L", "by arith"], ["proof (state)\nthis:\n  index < length L\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "obtain n' where n': \"n' = ladder_n L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        n' = ladder_n L index \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n' = ladder_n L index\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "from Suc.hyps[OF Suc.prems(1) Suc.prems(2) n' index_bound] index_plus_1_bound"], ["proof (chain)\npicking this:\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n'a \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n'a) \\<and>\n          n'a \\<le> n' \\<and>\n          LeftDerivation \\<alpha> (take n'a D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n'a D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n'a D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n'a D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>\n  index + 1 < length L", "have \"\\<exists> \\<alpha>'. LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and> \n    ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index = \\<alpha>'@\\<delta> \\<and> ladder_j L index < length \\<alpha>'\""], ["proof (prove)\nusing this:\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n'a \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n'a) \\<and>\n          n'a \\<le> n' \\<and>\n          LeftDerivation \\<alpha> (take n'a D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n'a D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n'a D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n'a D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<alpha>' @ \\<delta> \\<and>\n       ladder_j L index < length \\<alpha>'", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>'.\n     LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n     ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n     \\<alpha>' @ \\<delta> \\<and>\n     ladder_j L index < length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>'.\n     LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n     ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n     \\<alpha>' @ \\<delta> \\<and>\n     ladder_j L index < length \\<alpha>'", "obtain \\<alpha>' where \\<alpha>': \"LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and> \n    ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index = \\<alpha>'@\\<delta> \\<and> ladder_j L index < length \\<alpha>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>'.\n     LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n     ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n     \\<alpha>' @ \\<delta> \\<and>\n     ladder_j L index < length \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>'.\n        LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n        \\<alpha>' @ \\<delta> \\<and>\n        ladder_j L index < length \\<alpha>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  \\<alpha>' @ \\<delta> \\<and>\n  ladder_j L index < length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have Suc_index_bound: \"Suc index < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc index < length L", "using Suc.prems"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  ladder_i L 0 < length \\<alpha>\n  n = ladder_n L (Suc index)\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. Suc index < length L", "by auto"], ["proof (state)\nthis:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have is_ladder: \"is_ladder D L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder D L", "using Suc.prems LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  ladder_i L 0 < length \\<alpha>\n  n = ladder_n L (Suc index)\n  Suc index < length L\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. is_ladder D L", "by auto"], ["proof (state)\nthis:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have n_def: \"n = ladder_n L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = ladder_n L (Suc index)", "using Suc_index_bound n'"], ["proof (prove)\nusing this:\n  Suc index < length L\n  n' = ladder_n L index\n\ngoal (1 subgoal):\n 1. n = ladder_n L (Suc index)", "by (simp add: Suc.prems(3))"], ["proof (state)\nthis:\n  n = ladder_n L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "with n'"], ["proof (chain)\npicking this:\n  n' = ladder_n L index\n  n = ladder_n L (Suc index)", "have n'_less_n: \"n' < n\""], ["proof (prove)\nusing this:\n  n' = ladder_n L index\n  n = ladder_n L (Suc index)\n\ngoal (1 subgoal):\n 1. n' < n", "using is_ladder Suc_index_bound is_ladder_def lessI"], ["proof (prove)\nusing this:\n  n' = ladder_n L index\n  n = ladder_n L (Suc index)\n  is_ladder D L\n  Suc index < length L\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  ?n < Suc ?n\n\ngoal (1 subgoal):\n 1. n' < n", "by blast"], ["proof (state)\nthis:\n  n' < n\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have ladder_\\<alpha>_is_\\<gamma>: \"ladder_\\<alpha> (\\<alpha>@\\<delta>) D L (Suc index) = ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index", "by (simp add: ladder_\\<alpha>_def)"], ["proof (state)\nthis:\n  ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc index) =\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "obtain i where i: \"i = ladder_i L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i = ladder_i L (Suc index) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i = ladder_i L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "obtain e where e: \"e = (D ! n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e. e = D ! n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  e = D ! n'\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "obtain E where E: \"E = drop (Suc n') (take n D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E.\n        E = drop (Suc n') (take n D) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E = drop (Suc n') (take n D)\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "obtain ix where ix: \"ix = ladder_ix L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ix.\n        ix = ladder_ix L (Suc index) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ix = ladder_ix L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "obtain j where j: \"j = ladder_j L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j = ladder_j L (Suc index) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j = ladder_j L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "obtain \\<gamma> where \\<gamma>: \"\\<gamma> = ladder_\\<gamma> (\\<alpha>@\\<delta>) D L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<gamma> =\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n         (Suc index) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have intro: \"LeftDerivationIntro (\\<alpha>'@\\<delta>) i (snd e) ix E j \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (\\<alpha>' @ \\<delta>) i (snd e) ix E j \\<gamma>", "by (metis E LeftDerivationIntrosAt_def \\<alpha>' \\<gamma> ladder_\\<alpha>_is_\\<gamma> \n      diff_Suc_1 e i ix j local.step n' n_def)"], ["proof (state)\nthis:\n  LeftDerivationIntro (\\<alpha>' @ \\<delta>) i (snd e) ix E j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have is_eq_fst_e: \"i = fst e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = fst e", "by (metis LeftDerivationIntrosAt_def diff_Suc_1 e i local.step n')"], ["proof (state)\nthis:\n  i = fst e\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have i_less_\\<alpha>': \"i < length \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length \\<alpha>'", "using i \\<alpha>' ladder_i_def"], ["proof (prove)\nusing this:\n  i = ladder_i L (Suc index)\n  LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  \\<alpha>' @ \\<delta> \\<and>\n  ladder_j L index < length \\<alpha>'\n  ladder_i ?L ?index =\n  (if ?index = 0 then deriv_i (hd ?L) else ladder_j ?L (?index - 1))\n\ngoal (1 subgoal):\n 1. i < length \\<alpha>'", "by simp"], ["proof (state)\nthis:\n  i < length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "have \"(Suc index) + 1 < length L \\<or> (Suc index) + 1 = length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc index + 1 < length L \\<or> Suc index + 1 = length L", "using Suc_index_bound"], ["proof (prove)\nusing this:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. Suc index + 1 < length L \\<or> Suc index + 1 = length L", "by arith"], ["proof (state)\nthis:\n  Suc index + 1 < length L \\<or> Suc index + 1 = length L\n\ngoal (1 subgoal):\n 1. \\<And>index n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>LeftDerivationLadder (\\<alpha> @ \\<delta>) D L\n                             \\<gamma>;\n                    ladder_i L 0 < length \\<alpha>; n = ladder_n L index;\n                    index < length L\\<rbrakk>\n                   \\<Longrightarrow> if index + 1 < length L\n                                     then \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L index < length \\<beta>\n                                     else \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation \\<delta>\n        (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>;\n        LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>;\n        ladder_i L 0 < length \\<alpha>; n = ladder_n L (Suc index);\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> if Suc index + 1 < length L\n                         then \\<exists>\\<beta>.\n                                 LeftDerivation \\<alpha> (take n D)\n                                  \\<beta> \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta> \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>\n                         else \\<exists>n' \\<beta> \\<delta>'.\n                                 (Suc index = 0 \\<or>\n                                  ladder_prev_n L (Suc index) < n') \\<and>\n                                 n' \\<le> n \\<and>\n                                 LeftDerivation \\<alpha> (take n' D)\n                                  \\<beta> \\<and>\n                                 LeftDerivation (\\<alpha> @ \\<delta>)\n                                  (take n' D) (\\<beta> @ \\<delta>) \\<and>\n                                 derivation_ge (drop n' D)\n                                  (length \\<beta>) \\<and>\n                                 LeftDerivation \\<delta>\n                                  (derivation_shift (drop n' D)\n                                    (length \\<beta>) 0)\n                                  \\<delta>' \\<and>\n                                 ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L\n                                  (Suc index) =\n                                 \\<beta> @ \\<delta>' \\<and>\n                                 ladder_j L (Suc index) < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  Suc index + 1 < length L \\<or> Suc index + 1 = length L", "show ?case"], ["proof (prove)\nusing this:\n  Suc index + 1 < length L \\<or> Suc index + 1 = length L\n\ngoal (1 subgoal):\n 1. if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "case 1"], ["proof (state)\nthis:\n  Suc index + 1 < length L\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from 1"], ["proof (chain)\npicking this:\n  Suc index + 1 < length L", "have \"LeftDerivationIntrosAt (\\<alpha>@\\<delta>) D L (Suc (Suc index))\""], ["proof (prove)\nusing this:\n  Suc index + 1 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L (Suc (Suc index))", "by (metis LeftDerivationIntros_def LeftDerivationLadder_def Suc.prems(1) \n          Suc_eq_plus1 Suc_eq_plus1_left le_add1)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L (Suc (Suc index))\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from LeftDerivationIntrosAt_implies_nonterminal[OF this]"], ["proof (chain)\npicking this:\n  is_nonterminal\n   (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc (Suc index)) !\n    ladder_i L (Suc (Suc index)))", "have \n        \"is_nonterminal (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc (Suc index)) ! ladder_i L (Suc (Suc index)))\""], ["proof (prove)\nusing this:\n  is_nonterminal\n   (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc (Suc index)) !\n    ladder_i L (Suc (Suc index)))\n\ngoal (1 subgoal):\n 1. is_nonterminal\n     (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc (Suc index)) !\n      ladder_i L (Suc (Suc index)))", "by blast"], ["proof (state)\nthis:\n  is_nonterminal\n   (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc (Suc index)) !\n    ladder_i L (Suc (Suc index)))\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "then"], ["proof (chain)\npicking this:\n  is_nonterminal\n   (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc (Suc index)) !\n    ladder_i L (Suc (Suc index)))", "have non_\\<gamma>_j: \"is_nonterminal (\\<gamma> ! j)\""], ["proof (prove)\nusing this:\n  is_nonterminal\n   (ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L (Suc (Suc index)) !\n    ladder_i L (Suc (Suc index)))\n\ngoal (1 subgoal):\n 1. is_nonterminal (\\<gamma> ! j)", "by (simp add: \\<gamma> j ladder_\\<alpha>_def ladder_i_def)"], ["proof (state)\nthis:\n  is_nonterminal (\\<gamma> ! j)\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from LeftDerivationIntro_propagate[OF intro i_less_\\<alpha>' non_\\<gamma>_j]"], ["proof (chain)\npicking this:\n  \\<exists>\\<omega>.\n     LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and>\n     \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>", "obtain \\<omega> where \\<omega>: \"LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and> \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<omega>.\n     LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and>\n     \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and>\n        \\<gamma> = \\<omega> @ \\<delta> \\<and>\n        j < length \\<omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and>\n  \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "have \\<alpha>_\\<omega>: \"LeftDerivation \\<alpha> ((take n' D)@((i, snd e) # E)) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take n' D @ (i, snd e) # E) \\<omega>", "using \\<alpha>' \\<omega> LeftDerivation_implies_append"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take n' D) \\<alpha>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  \\<alpha>' @ \\<delta> \\<and>\n  ladder_j L index < length \\<alpha>'\n  LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and>\n  \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>\n  \\<lbrakk>LeftDerivation ?a ?D ?b; LeftDerivation ?b ?E ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?a (?D @ ?E) ?c\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take n' D @ (i, snd e) # E) \\<omega>", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take n' D @ (i, snd e) # E) \\<omega>\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "have i_e: \"(i, snd e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, snd e) = e", "by (simp add: is_eq_fst_e)"], ["proof (state)\nthis:\n  (i, snd e) = e\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "have take_n_D_e: \"((take n' D)@(e # E)) = take n D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "(* automatically found *)"], ["proof (state)\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "obtain nn :: \"(nat \\<times> symbol \\<times> symbol list) list \\<Rightarrow> (nat \\<times> nat \\<times> nat) list \\<Rightarrow> nat\" and \n          nna :: \"(nat \\<times> symbol \\<times> symbol list) list \\<Rightarrow> (nat \\<times> nat \\<times> nat) list \\<Rightarrow> nat\" and \n          nnb :: \"(nat \\<times> symbol \\<times> symbol list) list \\<Rightarrow> (nat \\<times> nat \\<times> nat) list \\<Rightarrow> nat\" where\n          f1: \"(\\<forall>ps psa. \\<not> is_ladder ps psa \\<or> psa \\<noteq> [] \\<and> (\\<forall>n. \\<not> n < length psa \\<or> \n            ladder_n psa n \\<le> length ps) \\<and> (\\<forall>n na. (\\<not> n < na \\<or> \\<not> na < length psa) \\<or> \n            ladder_n psa n < ladder_n psa na) \\<and> ladder_last_n psa = length ps) \\<and> \n            (\\<forall>ps psa. (psa = [] \\<or> nn ps psa < length psa \\<and> \\<not> ladder_n psa (nn ps psa) \\<le> \n              length ps \\<or> (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and> \n              \\<not> ladder_n psa (nna ps psa) < ladder_n psa (nnb ps psa) \\<or> \n              ladder_last_n psa \\<noteq> length ps) \\<or> is_ladder ps psa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn nna nnb.\n        (\\<forall>ps psa.\n            \\<not> is_ladder ps psa \\<or>\n            psa \\<noteq> [] \\<and>\n            (\\<forall>n.\n                \\<not> n < length psa \\<or>\n                ladder_n psa n \\<le> length ps) \\<and>\n            (\\<forall>n na.\n                (\\<not> n < na \\<or> \\<not> na < length psa) \\<or>\n                ladder_n psa n < ladder_n psa na) \\<and>\n            ladder_last_n psa = length ps) \\<and>\n        (\\<forall>ps psa.\n            (psa = [] \\<or>\n             nn ps psa < length psa \\<and>\n             \\<not> ladder_n psa (nn ps psa) \\<le> length ps \\<or>\n             (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and>\n             \\<not> ladder_n psa (nna ps psa)\n                    < ladder_n psa (nnb ps psa) \\<or>\n             ladder_last_n psa \\<noteq> length ps) \\<or>\n            is_ladder ps psa) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using is_ladder_def"], ["proof (prove)\nusing this:\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. (\\<And>nn nna nnb.\n        (\\<forall>ps psa.\n            \\<not> is_ladder ps psa \\<or>\n            psa \\<noteq> [] \\<and>\n            (\\<forall>n.\n                \\<not> n < length psa \\<or>\n                ladder_n psa n \\<le> length ps) \\<and>\n            (\\<forall>n na.\n                (\\<not> n < na \\<or> \\<not> na < length psa) \\<or>\n                ladder_n psa n < ladder_n psa na) \\<and>\n            ladder_last_n psa = length ps) \\<and>\n        (\\<forall>ps psa.\n            (psa = [] \\<or>\n             nn ps psa < length psa \\<and>\n             \\<not> ladder_n psa (nn ps psa) \\<le> length ps \\<or>\n             (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and>\n             \\<not> ladder_n psa (nna ps psa)\n                    < ladder_n psa (nnb ps psa) \\<or>\n             ladder_last_n psa \\<noteq> length ps) \\<or>\n            is_ladder ps psa) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  (\\<forall>ps psa.\n      \\<not> is_ladder ps psa \\<or>\n      psa \\<noteq> [] \\<and>\n      (\\<forall>n.\n          \\<not> n < length psa \\<or> ladder_n psa n \\<le> length ps) \\<and>\n      (\\<forall>n na.\n          (\\<not> n < na \\<or> \\<not> na < length psa) \\<or>\n          ladder_n psa n < ladder_n psa na) \\<and>\n      ladder_last_n psa = length ps) \\<and>\n  (\\<forall>ps psa.\n      (psa = [] \\<or>\n       nn ps psa < length psa \\<and>\n       \\<not> ladder_n psa (nn ps psa) \\<le> length ps \\<or>\n       (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and>\n       \\<not> ladder_n psa (nna ps psa) < ladder_n psa (nnb ps psa) \\<or>\n       ladder_last_n psa \\<noteq> length ps) \\<or>\n      is_ladder ps psa)\n\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "then"], ["proof (chain)\npicking this:\n  (\\<forall>ps psa.\n      \\<not> is_ladder ps psa \\<or>\n      psa \\<noteq> [] \\<and>\n      (\\<forall>n.\n          \\<not> n < length psa \\<or> ladder_n psa n \\<le> length ps) \\<and>\n      (\\<forall>n na.\n          (\\<not> n < na \\<or> \\<not> na < length psa) \\<or>\n          ladder_n psa n < ladder_n psa na) \\<and>\n      ladder_last_n psa = length ps) \\<and>\n  (\\<forall>ps psa.\n      (psa = [] \\<or>\n       nn ps psa < length psa \\<and>\n       \\<not> ladder_n psa (nn ps psa) \\<le> length ps \\<or>\n       (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and>\n       \\<not> ladder_n psa (nna ps psa) < ladder_n psa (nnb ps psa) \\<or>\n       ladder_last_n psa \\<noteq> length ps) \\<or>\n      is_ladder ps psa)", "have f2: \"ladder_last_n L = length D\""], ["proof (prove)\nusing this:\n  (\\<forall>ps psa.\n      \\<not> is_ladder ps psa \\<or>\n      psa \\<noteq> [] \\<and>\n      (\\<forall>n.\n          \\<not> n < length psa \\<or> ladder_n psa n \\<le> length ps) \\<and>\n      (\\<forall>n na.\n          (\\<not> n < na \\<or> \\<not> na < length psa) \\<or>\n          ladder_n psa n < ladder_n psa na) \\<and>\n      ladder_last_n psa = length ps) \\<and>\n  (\\<forall>ps psa.\n      (psa = [] \\<or>\n       nn ps psa < length psa \\<and>\n       \\<not> ladder_n psa (nn ps psa) \\<le> length ps \\<or>\n       (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and>\n       \\<not> ladder_n psa (nna ps psa) < ladder_n psa (nnb ps psa) \\<or>\n       ladder_last_n psa \\<noteq> length ps) \\<or>\n      is_ladder ps psa)\n\ngoal (1 subgoal):\n 1. ladder_last_n L = length D", "using is_ladder"], ["proof (prove)\nusing this:\n  (\\<forall>ps psa.\n      \\<not> is_ladder ps psa \\<or>\n      psa \\<noteq> [] \\<and>\n      (\\<forall>n.\n          \\<not> n < length psa \\<or> ladder_n psa n \\<le> length ps) \\<and>\n      (\\<forall>n na.\n          (\\<not> n < na \\<or> \\<not> na < length psa) \\<or>\n          ladder_n psa n < ladder_n psa na) \\<and>\n      ladder_last_n psa = length ps) \\<and>\n  (\\<forall>ps psa.\n      (psa = [] \\<or>\n       nn ps psa < length psa \\<and>\n       \\<not> ladder_n psa (nn ps psa) \\<le> length ps \\<or>\n       (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and>\n       \\<not> ladder_n psa (nna ps psa) < ladder_n psa (nnb ps psa) \\<or>\n       ladder_last_n psa \\<noteq> length ps) \\<or>\n      is_ladder ps psa)\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. ladder_last_n L = length D", "by blast"], ["proof (state)\nthis:\n  ladder_last_n L = length D\n\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "have f3: \"min (ladder_last_n L) n = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (ladder_last_n L) n = n", "using f1"], ["proof (prove)\nusing this:\n  (\\<forall>ps psa.\n      \\<not> is_ladder ps psa \\<or>\n      psa \\<noteq> [] \\<and>\n      (\\<forall>n.\n          \\<not> n < length psa \\<or> ladder_n psa n \\<le> length ps) \\<and>\n      (\\<forall>n na.\n          (\\<not> n < na \\<or> \\<not> na < length psa) \\<or>\n          ladder_n psa n < ladder_n psa na) \\<and>\n      ladder_last_n psa = length ps) \\<and>\n  (\\<forall>ps psa.\n      (psa = [] \\<or>\n       nn ps psa < length psa \\<and>\n       \\<not> ladder_n psa (nn ps psa) \\<le> length ps \\<or>\n       (nna ps psa < nnb ps psa \\<and> nnb ps psa < length psa) \\<and>\n       \\<not> ladder_n psa (nna ps psa) < ladder_n psa (nnb ps psa) \\<or>\n       ladder_last_n psa \\<noteq> length ps) \\<or>\n      is_ladder ps psa)\n\ngoal (1 subgoal):\n 1. min (ladder_last_n L) n = n", "by (metis (no_types) Suc_eq_plus1 index_plus_1_bound is_ladder \n            min.absorb2 n_def)"], ["proof (state)\nthis:\n  min (ladder_last_n L) n = n\n\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "then"], ["proof (chain)\npicking this:\n  min (ladder_last_n L) n = n", "have \"take n' (take n D) @ take n D ! n' # E = take n D\""], ["proof (prove)\nusing this:\n  min (ladder_last_n L) n = n\n\ngoal (1 subgoal):\n 1. take n' (take n D) @ take n D ! n' # E = take n D", "using f2"], ["proof (prove)\nusing this:\n  min (ladder_last_n L) n = n\n  ladder_last_n L = length D\n\ngoal (1 subgoal):\n 1. take n' (take n D) @ take n D ! n' # E = take n D", "by (metis E id_take_nth_drop length_take n'_less_n)"], ["proof (state)\nthis:\n  take n' (take n D) @ take n D ! n' # E = take n D\n\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "then"], ["proof (chain)\npicking this:\n  take n' (take n D) @ take n D ! n' # E = take n D", "show ?thesis"], ["proof (prove)\nusing this:\n  take n' (take n D) @ take n D ! n' # E = take n D\n\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "using f3 f2"], ["proof (prove)\nusing this:\n  take n' (take n D) @ take n D ! n' # E = take n D\n  min (ladder_last_n L) n = n\n  ladder_last_n L = length D\n\ngoal (1 subgoal):\n 1. take n' D @ e # E = take n D", "by (metis (no_types) append_assoc append_eq_conv_conj \n            dual_order.strict_implies_order e length_take min.absorb2 n'_less_n nth_append)"], ["proof (state)\nthis:\n  take n' D @ e # E = take n D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take n' D @ e # E = take n D\n\ngoal (2 subgoals):\n 1. Suc index + 1 < length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n 2. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from 1"], ["proof (chain)\npicking this:\n  Suc index + 1 < length L", "show ?case"], ["proof (prove)\nusing this:\n  Suc index + 1 < length L\n\ngoal (1 subgoal):\n 1. if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n       \\<beta> @ \\<delta> \\<and>\n       ladder_j L (Suc index) < length \\<beta>", "apply (rule_tac x=\\<omega> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take n D) \\<omega> \\<and>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta> \\<and>\n    ladder_j L (Suc index) < length \\<omega>", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take n D) \\<omega>\n 2. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>\n 3. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "using \\<alpha>_\\<omega> i_e take_n_D_e"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take n' D @ (i, snd e) # E) \\<omega>\n  (i, snd e) = e\n  take n' D @ e # E = take n D\n\ngoal (3 subgoals):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take n D) \\<omega>\n 2. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>\n 3. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>\n 2. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "using \\<gamma> \\<omega>"], ["proof (prove)\nusing this:\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index)\n  LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and>\n  \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>\n\ngoal (2 subgoals):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>\n 2. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "using \\<omega> j"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha>' ((i, snd e) # E) \\<omega> \\<and>\n  \\<gamma> = \\<omega> @ \\<delta> \\<and> j < length \\<omega>\n  j = ladder_j L (Suc index)\n\ngoal (1 subgoal):\n 1. Suc (Suc index) < length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "by blast"], ["proof (state)\nthis:\n  if Suc index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L (Suc index) < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L (Suc index) < length \\<beta>\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "case 2"], ["proof (state)\nthis:\n  Suc index + 1 = length L\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from LeftDerivationIntro_finish[OF intro i_less_\\<alpha>']"], ["proof (chain)\npicking this:\n  \\<exists>k \\<omega> \\<delta>'.\n     k \\<le> length E \\<and>\n     LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n     LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n      (\\<omega> @ \\<delta>) \\<and>\n     derivation_ge (drop k E) (length \\<omega>) \\<and>\n     LeftDerivation \\<delta>\n      (derivation_shift (drop k E) (length \\<omega>) 0) \\<delta>' \\<and>\n     \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>", "obtain k \\<omega> \\<delta>' where kw\\<delta>':\n      \"k \\<le> length E \\<and>\n       LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n       LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E) (\\<omega> @ \\<delta>) \\<and>\n       derivation_ge (drop k E) (length \\<omega>) \\<and>\n       LeftDerivation \\<delta> (derivation_shift (drop k E) (length \\<omega>) 0) \\<delta>' \\<and> \n       \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\""], ["proof (prove)\nusing this:\n  \\<exists>k \\<omega> \\<delta>'.\n     k \\<le> length E \\<and>\n     LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n     LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n      (\\<omega> @ \\<delta>) \\<and>\n     derivation_ge (drop k E) (length \\<omega>) \\<and>\n     LeftDerivation \\<delta>\n      (derivation_shift (drop k E) (length \\<omega>) 0) \\<delta>' \\<and>\n     \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<omega> \\<delta>'.\n        k \\<le> length E \\<and>\n        LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n        LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n         (\\<omega> @ \\<delta>) \\<and>\n        derivation_ge (drop k E) (length \\<omega>) \\<and>\n        LeftDerivation \\<delta>\n         (derivation_shift (drop k E) (length \\<omega>) 0) \\<delta>' \\<and>\n        \\<gamma> = \\<omega> @ \\<delta>' \\<and>\n        j < length \\<omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<le> length E \\<and>\n  LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n  LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n   (\\<omega> @ \\<delta>) \\<and>\n  derivation_ge (drop k E) (length \\<omega>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop k E) (length \\<omega>) 0)\n   \\<delta>' \\<and>\n  \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "have ladder_last_n_1: \"ladder_last_n L = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_n L = n", "by (metis \"2.hyps\" Suc_eq_plus1 diff_Suc_1 ladder_last_n_def n_def)"], ["proof (state)\nthis:\n  ladder_last_n L = n\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from is_ladder"], ["proof (chain)\npicking this:\n  is_ladder D L", "have ladder_last_n_2: \"ladder_last_n L = length D\""], ["proof (prove)\nusing this:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. ladder_last_n L = length D", "using is_ladder_def"], ["proof (prove)\nusing this:\n  is_ladder D L\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. ladder_last_n L = length D", "by blast"], ["proof (state)\nthis:\n  ladder_last_n L = length D\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from ladder_last_n_1 ladder_last_n_2"], ["proof (chain)\npicking this:\n  ladder_last_n L = n\n  ladder_last_n L = length D", "have n_eq_length_D: \"n = length D\""], ["proof (prove)\nusing this:\n  ladder_last_n L = n\n  ladder_last_n L = length D\n\ngoal (1 subgoal):\n 1. n = length D", "by blast"], ["proof (state)\nthis:\n  n = length D\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "have take_split: \"take (Suc (n' + k)) D = (take n' D) @ ((i, snd e) # take k E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc (n' + k)) D = take n' D @ (i, snd e) # take k E", "apply (simp add: E n_eq_length_D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc (n' + k)) D =\n    take n' D @ (i, snd e) # take k (drop (Suc n') D)", "by (metis (no_types, lifting) Cons_eq_appendI add_Suc append_eq_appendI e \n        is_eq_fst_e n'_less_n n_eq_length_D prod.collapse \n        self_append_conv2 take_Suc_conv_app_nth take_add)"], ["proof (state)\nthis:\n  take (Suc (n' + k)) D = take n' D @ (i, snd e) # take k E\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "have \\<alpha>_\\<omega>: \"LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega>", "apply (subst take_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take n' D @ (i, snd e) # take k E) \\<omega>", "apply (rule LeftDerivation_implies_append[where b=\"\\<alpha>'\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivation \\<alpha> (take n' D) \\<alpha>'\n 2. LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega>", "apply (simp add: \\<alpha>')"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega>", "using kw\\<delta>'"], ["proof (prove)\nusing this:\n  k \\<le> length E \\<and>\n  LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n  LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n   (\\<omega> @ \\<delta>) \\<and>\n  derivation_ge (drop k E) (length \\<omega>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop k E) (length \\<omega>) 0)\n   \\<delta>' \\<and>\n  \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega>", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega>\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "have Suc_n'_k_bound: \"Suc (n' + k) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (n' + k) \\<le> n", "using E kw\\<delta>' n'_less_n"], ["proof (prove)\nusing this:\n  E = drop (Suc n') (take n D)\n  k \\<le> length E \\<and>\n  LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n  LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n   (\\<omega> @ \\<delta>) \\<and>\n  derivation_ge (drop k E) (length \\<omega>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop k E) (length \\<omega>) 0)\n   \\<delta>' \\<and>\n  \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n  n' < n\n\ngoal (1 subgoal):\n 1. Suc (n' + k) \\<le> n", "by auto[1]"], ["proof (state)\nthis:\n  Suc (n' + k) \\<le> n\n\ngoal (1 subgoal):\n 1. Suc index + 1 = length L \\<Longrightarrow>\n    if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "from 2"], ["proof (chain)\npicking this:\n  Suc index + 1 = length L", "show ?case"], ["proof (prove)\nusing this:\n  Suc index + 1 = length L\n\ngoal (1 subgoal):\n 1. if Suc index + 1 < length L\n    then \\<exists>\\<beta>.\n            LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta> \\<and>\n            ladder_j L (Suc index) < length \\<beta>\n    else \\<exists>n' \\<beta> \\<delta>'.\n            (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n            n' \\<le> n \\<and>\n            LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n            LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n             (\\<beta> @ \\<delta>) \\<and>\n            derivation_ge (drop n' D) (length \\<beta>) \\<and>\n            LeftDerivation \\<delta>\n             (derivation_shift (drop n' D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>n'>ladder_prev_n L (Suc index).\n       n' \\<le> n \\<and>\n       (\\<exists>\\<beta>.\n           LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n           LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n            (\\<beta> @ \\<delta>) \\<and>\n           derivation_ge (drop n' D) (length \\<beta>) \\<and>\n           (\\<exists>\\<delta>'.\n               LeftDerivation \\<delta>\n                (derivation_shift (drop n' D) (length \\<beta>) 0)\n                \\<delta>' \\<and>\n               ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n               \\<beta> @ \\<delta>' \\<and>\n               ladder_j L (Suc index) < length \\<beta>))", "apply (rule_tac x=\"Suc (n' + k)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_prev_n L (Suc index) < Suc (n' + k) \\<and>\n    Suc (n' + k) \\<le> n \\<and>\n    (\\<exists>\\<beta>.\n        LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<beta> \\<and>\n        LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n         (\\<beta> @ \\<delta>) \\<and>\n        derivation_ge (drop (Suc (n' + k)) D) (length \\<beta>) \\<and>\n        (\\<exists>\\<delta>'.\n            LeftDerivation \\<delta>\n             (derivation_shift (drop (Suc (n' + k)) D) (length \\<beta>) 0)\n             \\<delta>' \\<and>\n            ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n            \\<beta> @ \\<delta>' \\<and>\n            ladder_j L (Suc index) < length \\<beta>))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_prev_n L (Suc index) < Suc (n' + k)\n 2. Suc (Suc index) = length L \\<Longrightarrow> Suc (n' + k) \\<le> n\n 3. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop (Suc (n' + k)) D) (length \\<beta>) \\<and>\n       (\\<exists>\\<delta>'.\n           LeftDerivation \\<delta>\n            (derivation_shift (drop (Suc (n' + k)) D) (length \\<beta>) 0)\n            \\<delta>' \\<and>\n           ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n           \\<beta> @ \\<delta>' \\<and>\n           ladder_j L (Suc index) < length \\<beta>)", "apply (simp add: ladder_prev_n_def n')"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow> Suc (n' + k) \\<le> n\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop (Suc (n' + k)) D) (length \\<beta>) \\<and>\n       (\\<exists>\\<delta>'.\n           LeftDerivation \\<delta>\n            (derivation_shift (drop (Suc (n' + k)) D) (length \\<beta>) 0)\n            \\<delta>' \\<and>\n           ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n           \\<beta> @ \\<delta>' \\<and>\n           ladder_j L (Suc index) < length \\<beta>)", "using Suc_n'_k_bound"], ["proof (prove)\nusing this:\n  Suc (n' + k) \\<le> n\n\ngoal (2 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow> Suc (n' + k) \\<le> n\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop (Suc (n' + k)) D) (length \\<beta>) \\<and>\n       (\\<exists>\\<delta>'.\n           LeftDerivation \\<delta>\n            (derivation_shift (drop (Suc (n' + k)) D) (length \\<beta>) 0)\n            \\<delta>' \\<and>\n           ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n           \\<beta> @ \\<delta>' \\<and>\n           ladder_j L (Suc index) < length \\<beta>)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n        (\\<beta> @ \\<delta>) \\<and>\n       derivation_ge (drop (Suc (n' + k)) D) (length \\<beta>) \\<and>\n       (\\<exists>\\<delta>'.\n           LeftDerivation \\<delta>\n            (derivation_shift (drop (Suc (n' + k)) D) (length \\<beta>) 0)\n            \\<delta>' \\<and>\n           ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n           \\<beta> @ \\<delta>' \\<and>\n           ladder_j L (Suc index) < length \\<beta>)", "apply (rule_tac x=\"\\<omega>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega> \\<and>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n     (\\<omega> @ \\<delta>) \\<and>\n    derivation_ge (drop (Suc (n' + k)) D) (length \\<omega>) \\<and>\n    (\\<exists>\\<delta>'.\n        LeftDerivation \\<delta>\n         (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n         \\<delta>' \\<and>\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n        \\<omega> @ \\<delta>' \\<and>\n        ladder_j L (Suc index) < length \\<omega>)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega>\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n     (\\<omega> @ \\<delta>)\n 3. Suc (Suc index) = length L \\<Longrightarrow>\n    derivation_ge (drop (Suc (n' + k)) D) (length \\<omega>)\n 4. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n       \\<omega> @ \\<delta>' \\<and>\n       ladder_j L (Suc index) < length \\<omega>", "using \\<alpha>_\\<omega>"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega>\n\ngoal (4 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega>\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n     (\\<omega> @ \\<delta>)\n 3. Suc (Suc index) = length L \\<Longrightarrow>\n    derivation_ge (drop (Suc (n' + k)) D) (length \\<omega>)\n 4. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n       \\<omega> @ \\<delta>' \\<and>\n       ladder_j L (Suc index) < length \\<omega>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n     (\\<omega> @ \\<delta>)\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    derivation_ge (drop (Suc (n' + k)) D) (length \\<omega>)\n 3. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n       \\<omega> @ \\<delta>' \\<and>\n       ladder_j L (Suc index) < length \\<omega>", "using \\<alpha>_\\<omega> LeftDerivationFix_def LeftDerivationLadder_def LeftDerivation_append_suffix \n        Suc.prems(1) is_sentence_concat"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take (Suc (n' + k)) D) \\<omega>\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  \\<lbrakk>LeftDerivation ?a ?D ?b; is_sentence ?c\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (?a @ ?c) ?D (?b @ ?c)\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n\ngoal (3 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation (\\<alpha> @ \\<delta>) (take (Suc (n' + k)) D)\n     (\\<omega> @ \\<delta>)\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    derivation_ge (drop (Suc (n' + k)) D) (length \\<omega>)\n 3. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n       \\<omega> @ \\<delta>' \\<and>\n       ladder_j L (Suc index) < length \\<omega>", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    derivation_ge (drop (Suc (n' + k)) D) (length \\<omega>)\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n       \\<omega> @ \\<delta>' \\<and>\n       ladder_j L (Suc index) < length \\<omega>", "apply (metis E add.commute add_Suc_right drop_drop kw\\<delta>' n_eq_length_D nat_le_linear \n        take_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    \\<exists>\\<delta>'.\n       LeftDerivation \\<delta>\n        (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n       \\<omega> @ \\<delta>' \\<and>\n       ladder_j L (Suc index) < length \\<omega>", "apply (rule_tac x=\"\\<delta>'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation \\<delta>\n     (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n     \\<delta>' \\<and>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>' \\<and>\n    ladder_j L (Suc index) < length \\<omega>", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    LeftDerivation \\<delta>\n     (derivation_shift (drop (Suc (n' + k)) D) (length \\<omega>) 0)\n     \\<delta>'\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>'\n 3. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "apply (metis E LeftDerivationLadder_ladder_n_bound Suc.prems(1) Suc_index_bound \n        add.commute add_Suc_right drop_drop kw\\<delta>' n_def n_eq_length_D take_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>'\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "using \\<gamma> kw\\<delta>'"], ["proof (prove)\nusing this:\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index)\n  k \\<le> length E \\<and>\n  LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n  LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n   (\\<omega> @ \\<delta>) \\<and>\n  derivation_ge (drop k E) (length \\<omega>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop k E) (length \\<omega>) 0)\n   \\<delta>' \\<and>\n  \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal (2 subgoals):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n    \\<omega> @ \\<delta>'\n 2. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "using j kw\\<delta>'"], ["proof (prove)\nusing this:\n  j = ladder_j L (Suc index)\n  k \\<le> length E \\<and>\n  LeftDerivation \\<alpha>' ((i, snd e) # take k E) \\<omega> \\<and>\n  LeftDerivation (\\<alpha>' @ \\<delta>) ((i, snd e) # take k E)\n   (\\<omega> @ \\<delta>) \\<and>\n  derivation_ge (drop k E) (length \\<omega>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop k E) (length \\<omega>) 0)\n   \\<delta>' \\<and>\n  \\<gamma> = \\<omega> @ \\<delta>' \\<and> j < length \\<omega>\n\ngoal (1 subgoal):\n 1. Suc (Suc index) = length L \\<Longrightarrow>\n    ladder_j L (Suc index) < length \\<omega>", "by blast"], ["proof (state)\nthis:\n  if Suc index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L (Suc index) < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L (Suc index) < length \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if Suc index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L (Suc index) < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (Suc index = 0 \\<or> ladder_prev_n L (Suc index) < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (Suc index) =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L (Suc index) < length \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_i_of_cut_at_0: \n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"ladder_i (ladder_cut L n) 0 = ladder_i L 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) 0 = ladder_i L 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) 0 = ladder_i L 0", "have \"length L \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L \\<noteq> 0", "using L_non_empty"], ["proof (prove)\nusing this:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. length L \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length L \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) 0 = ladder_i L 0", "then"], ["proof (chain)\npicking this:\n  length L \\<noteq> 0", "have \"length L = 1 \\<or> length L > 1\""], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length L = 1 \\<or> 1 < length L", "by arith"], ["proof (state)\nthis:\n  length L = 1 \\<or> 1 < length L\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) 0 = ladder_i L 0", "then"], ["proof (chain)\npicking this:\n  length L = 1 \\<or> 1 < length L", "show ?thesis"], ["proof (prove)\nusing this:\n  length L = 1 \\<or> 1 < length L\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) 0 = ladder_i L 0", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    ladder_i (ladder_cut L n) 0 = ladder_i L 0\n 2. 1 < length L \\<Longrightarrow>\n    ladder_i (ladder_cut L n) 0 = ladder_i L 0", "case 1"], ["proof (state)\nthis:\n  length L = 1\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    ladder_i (ladder_cut L n) 0 = ladder_i L 0\n 2. 1 < length L \\<Longrightarrow>\n    ladder_i (ladder_cut L n) 0 = ladder_i L 0", "then"], ["proof (chain)\npicking this:\n  length L = 1", "show ?case"], ["proof (prove)\nusing this:\n  length L = 1\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) 0 = ladder_i L 0", "apply (simp add: ladder_cut_def ladder_i_def deriv_i_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length L = Suc 0 \\<Longrightarrow>\n    snd (snd (hd (L[0 := (n, snd (L ! 0))]))) = snd (snd (hd L))", "by (simp add: assms hd_conv_nth)"], ["proof (state)\nthis:\n  ladder_i (ladder_cut L n) 0 = ladder_i L 0\n\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    ladder_i (ladder_cut L n) 0 = ladder_i L 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    ladder_i (ladder_cut L n) 0 = ladder_i L 0", "case 2"], ["proof (state)\nthis:\n  1 < length L\n\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    ladder_i (ladder_cut L n) 0 = ladder_i L 0", "then"], ["proof (chain)\npicking this:\n  1 < length L", "show ?case"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) 0 = ladder_i L 0", "apply (simp add: ladder_cut_def ladder_i_def deriv_i_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < length L \\<Longrightarrow>\n    snd (snd (hd (let i = length L - Suc 0 in L[i := (n, snd (L ! i))]))) =\n    snd (snd (hd L))", "by (metis diff_is_0_eq hd_conv_nth leD list_update_nonempty nth_list_update_neq)"], ["proof (state)\nthis:\n  ladder_i (ladder_cut L n) 0 = ladder_i L 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_i (ladder_cut L n) 0 = ladder_i L 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_last_j_of_cut: \n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"ladder_last_j (ladder_cut L n) = ladder_last_j L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_j (ladder_cut L n) = ladder_last_j L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_last_j (ladder_cut L n) = ladder_last_j L", "have length_L_nonzero: \"length L \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L \\<noteq> 0", "using L_non_empty"], ["proof (prove)\nusing this:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. length L \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length L \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ladder_last_j (ladder_cut L n) = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  length L \\<noteq> 0", "have length_ladder_cut: \"length (ladder_cut L n) = length L\""], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (ladder_cut L n) = length L", "by (metis ladder_cut_def length_list_update)"], ["proof (state)\nthis:\n  length (ladder_cut L n) = length L\n\ngoal (1 subgoal):\n 1. ladder_last_j (ladder_cut L n) = ladder_last_j L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_j (ladder_cut L n) = ladder_last_j L", "apply (simp add: ladder_last_j_def length_ladder_cut)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j (ladder_cut L n) (length L - Suc 0) =\n    ladder_j L (length L - Suc 0)", "apply (simp add: ladder_cut_def ladder_j_def deriv_j_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd ((let i = length L - Suc 0 in L[i := (n, snd (L ! i))]) !\n              (length L - Suc 0))) =\n    fst (snd (L ! (length L - Suc 0)))", "by (metis length_L_nonzero diff_less neq0_conv nth_list_update_eq snd_conv zero_less_Suc)"], ["proof (state)\nthis:\n  ladder_last_j (ladder_cut L n) = ladder_last_j L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_ladder_cut:\n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"length (ladder_cut L n) = length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ladder_cut L n) = length L", "by (metis ladder_cut_def length_list_update)"], ["", "lemma ladder_last_n_of_cut:\n  assumes L_non_empty: \"L \\<noteq> []\"\n  shows \"ladder_last_n (ladder_cut L n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_n (ladder_cut L n) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_last_n (ladder_cut L n) = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_n (ladder_cut L n) = n", "apply (simp add: ladder_last_n_def length_ladder_cut[OF L_non_empty])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (ladder_cut L n) (length L - Suc 0) = n", "apply (simp add: ladder_n_def ladder_cut_def deriv_n_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ((let i = length L - Suc 0 in L[i := (n, snd (L ! i))]) !\n         (length L - Suc 0)) =\n    n", "by (metis assms diff_Suc_less fst_conv length_greater_0_conv nth_list_update_eq)"], ["proof (state)\nthis:\n  ladder_last_n (ladder_cut L n) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_n_of_cut:\n  assumes L_non_empty: \"L \\<noteq> []\"\n  assumes \"index < length L - 1\"\n  shows \"ladder_n (ladder_cut L n) index = ladder_n L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (ladder_cut L n) index = ladder_n L index", "by (metis assms(2) ladder_cut_def ladder_n_def nat_neq_iff nth_list_update_neq)"], ["", "lemma ladder_n_prev_bound:\n  assumes ladder: \"is_ladder D L\"\n  assumes u_bound: \"u < length L - 1\"\n  shows \"ladder_n L u \\<le> ladder_prev_n L (length L - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_prev_n L (length L - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_prev_n L (length L - 1)", "have \"ladder_n L u \\<le> ladder_n L (length L - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_n L (length L - 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_n L (length L - 2)", "have \"u < Suc (length L - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < Suc (length L - 2)", "using u_bound"], ["proof (prove)\nusing this:\n  u < length L - 1\n\ngoal (1 subgoal):\n 1. u < Suc (length L - 2)", "by linarith"], ["proof (state)\nthis:\n  u < Suc (length L - 2)\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_n L (length L - 2)", "then"], ["proof (chain)\npicking this:\n  u < Suc (length L - 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  u < Suc (length L - 2)\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_n L (length L - 2)", "by (metis (no_types) diff_Suc_less is_ladder_def ladder leI length_greater_0_conv \n        not_less_eq numeral_2_eq_2 order.order_iff_strict)"], ["proof (state)\nthis:\n  ladder_n L u \\<le> ladder_n L (length L - 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_n L u \\<le> ladder_n L (length L - 2)\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_prev_n L (length L - 1)", "then"], ["proof (chain)\npicking this:\n  ladder_n L u \\<le> ladder_n L (length L - 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ladder_n L u \\<le> ladder_n L (length L - 2)\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_prev_n L (length L - 1)", "by (metis One_nat_def Suc_diff_Suc diff_Suc_1 ladder_prev_n_def neq0_conv not_less0 \n      numeral_2_eq_2 u_bound zero_less_diff)"], ["proof (state)\nthis:\n  ladder_n L u \\<le> ladder_prev_n L (length L - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_n_last_is_length:\n  assumes \"is_ladder D L\"\n  shows \"ladder_n L (length L - 1) = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (length L - 1) = length D", "using assms is_ladder_def ladder_last_n_intro"], ["proof (prove)\nusing this:\n  is_ladder D L\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  ?L \\<noteq> [] \\<Longrightarrow>\n  ladder_n ?L (length ?L - Suc 0) = ladder_last_n ?L\n\ngoal (1 subgoal):\n 1. ladder_n L (length L - 1) = length D", "by auto"], ["", "lemma derivation_ge_shift_implies_derivation_ge:\n  assumes dge: \"derivation_ge (derivation_shift F 0 j) k\"\n  shows \"derivation_ge F (k - j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "have \"\\<And> i r. (i, r) \\<in> set (derivation_shift F 0 j) \\<Longrightarrow> i \\<ge> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i r.\n       (i, r) \\<in> set (derivation_shift F 0 j) \\<Longrightarrow> k \\<le> i", "using dge derivation_ge_def"], ["proof (prove)\nusing this:\n  derivation_ge (derivation_shift F 0 j) k\n  derivation_ge ?D ?i = (\\<forall>d\\<in>set ?D. ?i \\<le> fst d)\n\ngoal (1 subgoal):\n 1. \\<And>i r.\n       (i, r) \\<in> set (derivation_shift F 0 j) \\<Longrightarrow> k \\<le> i", "by auto"], ["proof (state)\nthis:\n  (?i, ?r) \\<in> set (derivation_shift F 0 j) \\<Longrightarrow> k \\<le> ?i\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "{"], ["proof (state)\nthis:\n  (?i, ?r) \\<in> set (derivation_shift F 0 j) \\<Longrightarrow> k \\<le> ?i\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "fix r :: \"symbol \\<times> (symbol list)\""], ["proof (state)\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "assume ir: \"(i, r) \\<in> set F\""], ["proof (state)\nthis:\n  (i, r) \\<in> set F\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "then"], ["proof (chain)\npicking this:\n  (i, r) \\<in> set F", "have \"(i + j, r) \\<in> set (derivation_shift F 0 j)\""], ["proof (prove)\nusing this:\n  (i, r) \\<in> set F\n\ngoal (1 subgoal):\n 1. (i + j, r) \\<in> set (derivation_shift F 0 j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (i, r) \\<in> set F \\<Longrightarrow>\n    (i + j, r) \\<in> set (derivation_shift F 0 j)", "have \"(i + j, r) \\<in> (\\<lambda>p. (fst p - 0 + j, snd p)) ` set F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i + j, r) \\<in> (\\<lambda>p. (fst p - 0 + j, snd p)) ` set F", "by (metis (lifting) ir diff_zero image_eqI prod.collapse prod.inject)"], ["proof (state)\nthis:\n  (i + j, r) \\<in> (\\<lambda>p. (fst p - 0 + j, snd p)) ` set F\n\ngoal (1 subgoal):\n 1. (i, r) \\<in> set F \\<Longrightarrow>\n    (i + j, r) \\<in> set (derivation_shift F 0 j)", "then"], ["proof (chain)\npicking this:\n  (i + j, r) \\<in> (\\<lambda>p. (fst p - 0 + j, snd p)) ` set F", "show ?thesis"], ["proof (prove)\nusing this:\n  (i + j, r) \\<in> (\\<lambda>p. (fst p - 0 + j, snd p)) ` set F\n\ngoal (1 subgoal):\n 1. (i + j, r) \\<in> set (derivation_shift F 0 j)", "by (simp add: derivation_shift_def)"], ["proof (state)\nthis:\n  (i + j, r) \\<in> set (derivation_shift F 0 j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i + j, r) \\<in> set (derivation_shift F 0 j)\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "then"], ["proof (chain)\npicking this:\n  (i + j, r) \\<in> set (derivation_shift F 0 j)", "have \"i + j \\<ge> k\""], ["proof (prove)\nusing this:\n  (i + j, r) \\<in> set (derivation_shift F 0 j)\n\ngoal (1 subgoal):\n 1. k \\<le> i + j", "using dge derivation_ge_def"], ["proof (prove)\nusing this:\n  (i + j, r) \\<in> set (derivation_shift F 0 j)\n  derivation_ge (derivation_shift F 0 j) k\n  derivation_ge ?D ?i = (\\<forall>d\\<in>set ?D. ?i \\<le> fst d)\n\ngoal (1 subgoal):\n 1. k \\<le> i + j", "by auto"], ["proof (state)\nthis:\n  k \\<le> i + j\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "then"], ["proof (chain)\npicking this:\n  k \\<le> i + j", "have \"i \\<ge> k - j\""], ["proof (prove)\nusing this:\n  k \\<le> i + j\n\ngoal (1 subgoal):\n 1. k - j \\<le> i", "by auto"], ["proof (state)\nthis:\n  k - j \\<le> i\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "}"], ["proof (state)\nthis:\n  (?i2, ?r2) \\<in> set F \\<Longrightarrow> k - j \\<le> ?i2\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "then"], ["proof (chain)\npicking this:\n  (?i2, ?r2) \\<in> set F \\<Longrightarrow> k - j \\<le> ?i2", "show ?thesis"], ["proof (prove)\nusing this:\n  (?i2, ?r2) \\<in> set F \\<Longrightarrow> k - j \\<le> ?i2\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "using derivation_ge_def"], ["proof (prove)\nusing this:\n  (?i2, ?r2) \\<in> set F \\<Longrightarrow> k - j \\<le> ?i2\n  derivation_ge ?D ?i = (\\<forall>d\\<in>set ?D. ?i \\<le> fst d)\n\ngoal (1 subgoal):\n 1. derivation_ge F (k - j)", "by auto"], ["proof (state)\nthis:\n  derivation_ge F (k - j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Derives1_bound': \"Derives1 a i r b \\<Longrightarrow> i \\<le> length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 a i r b \\<Longrightarrow> i \\<le> length b", "by (metis Derives1_bound Derives1_take append_Nil2 append_take_drop_id drop_eq_Nil \n    dual_order.strict_implies_order length_take min.absorb2 nat_le_linear)"], ["", "lemma LeftDerivation_Derives1_last:\n  assumes \"LeftDerivation a D b\"\n  assumes \"D \\<noteq> []\"\n  shows \"Derives1 (Derive a (take (length D - 1) D)) (fst (last D)) (snd (last D)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derives1 (Derive a (take (length D - 1) D)) (fst (last D))\n     (snd (last D)) b", "by (metis Derive LeftDerivation_Derive_take_LeftDerives1 LeftDerivation_implies_Derivation \n  LeftDerives1_implies_Derives1 assms(1) assms(2) last_conv_nth le_refl length_0_conv take_all)"], ["", "lemma last_of_prefix_in_set:\n  assumes \"n < length E\"\n  assumes \"D = E@F\"\n  shows \"last E \\<in> set (drop n D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "have f1: \"last (drop n E) = last E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (drop n E) = last E", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  last (drop n E) = last E\n\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "have \"drop n E \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n E \\<noteq> []", "by (metis (no_types) Cons_nth_drop_Suc assms(1) list.simps(3))"], ["proof (state)\nthis:\n  drop n E \\<noteq> []\n\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "then"], ["proof (chain)\npicking this:\n  drop n E \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  drop n E \\<noteq> []\n\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "using f1"], ["proof (prove)\nusing this:\n  drop n E \\<noteq> []\n  last (drop n E) = last E\n\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "by (metis (no_types) append.simps(2) append_butlast_last_id append_eq_conv_conj assms(2) drop_append in_set_dropD insertCI list.set(2))"], ["proof (state)\nthis:\n  last E \\<in> set (drop n D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFix_cut_appendix:\n  assumes ldfix: \"LeftDerivationFix (\\<alpha>@\\<delta>) i D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> (take n D) \\<beta>\"\n  assumes n_bound: \"n \\<le> length D\"\n  assumes dge: \"derivation_ge (drop n D) (length \\<beta>)\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationFix \\<alpha> i (take n D) j \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "from LeftDerivationFix_def[where \\<alpha>=\"\\<alpha>@\\<delta>\" and i=i and D=D and j=j and \\<beta>=\"\\<beta>@\\<delta>'\"]"], ["proof (chain)\npicking this:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) i D j (\\<beta> @ \\<delta>') =\n  (is_sentence (\\<alpha> @ \\<delta>) \\<and>\n   is_sentence (\\<beta> @ \\<delta>') \\<and>\n   LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n   i < length (\\<alpha> @ \\<delta>) \\<and>\n   j < length (\\<beta> @ \\<delta>') \\<and>\n   (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n        (take j (\\<beta> @ \\<delta>')) \\<and>\n       LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n        (drop (Suc j) (\\<beta> @ \\<delta>'))))", "obtain E F where EF:\n    \"is_sentence (\\<alpha> @ \\<delta>) \\<and>\n     is_sentence (\\<beta> @ \\<delta>') \\<and>\n     LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n     i < length (\\<alpha> @ \\<delta>) \\<and>\n     j < length (\\<beta> @ \\<delta>') \\<and>\n     (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n     D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i (\\<alpha> @ \\<delta>)) E (take j (\\<beta> @ \\<delta>')) \\<and>\n        LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F (drop (Suc j) (\\<beta> @ \\<delta>'))\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) i D j (\\<beta> @ \\<delta>') =\n  (is_sentence (\\<alpha> @ \\<delta>) \\<and>\n   is_sentence (\\<beta> @ \\<delta>') \\<and>\n   LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n   i < length (\\<alpha> @ \\<delta>) \\<and>\n   j < length (\\<beta> @ \\<delta>') \\<and>\n   (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n        (take j (\\<beta> @ \\<delta>')) \\<and>\n       LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n        (drop (Suc j) (\\<beta> @ \\<delta>'))))\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        is_sentence (\\<alpha> @ \\<delta>) \\<and>\n        is_sentence (\\<beta> @ \\<delta>') \\<and>\n        LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n        i < length (\\<alpha> @ \\<delta>) \\<and>\n        j < length (\\<beta> @ \\<delta>') \\<and>\n        (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n         (take j (\\<beta> @ \\<delta>')) \\<and>\n        LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n         (drop (Suc j) (\\<beta> @ \\<delta>')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) i D j (\\<beta> @ \\<delta>') =\n  (is_sentence (\\<alpha> @ \\<delta>) \\<and>\n   is_sentence (\\<beta> @ \\<delta>') \\<and>\n   LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n   i < length (\\<alpha> @ \\<delta>) \\<and>\n   j < length (\\<beta> @ \\<delta>') \\<and>\n   (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n   (\\<exists>E F.\n       D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n        (take j (\\<beta> @ \\<delta>')) \\<and>\n       LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n        (drop (Suc j) (\\<beta> @ \\<delta>'))))\n  LeftDerivationFix (\\<alpha> @ \\<delta>) i D j (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        is_sentence (\\<alpha> @ \\<delta>) \\<and>\n        is_sentence (\\<beta> @ \\<delta>') \\<and>\n        LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n        i < length (\\<alpha> @ \\<delta>) \\<and>\n        j < length (\\<beta> @ \\<delta>') \\<and>\n        (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n         (take j (\\<beta> @ \\<delta>')) \\<and>\n        LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n         (drop (Suc j) (\\<beta> @ \\<delta>')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_sentence (\\<alpha> @ \\<delta>) \\<and>\n  is_sentence (\\<beta> @ \\<delta>') \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n  i < length (\\<alpha> @ \\<delta>) \\<and>\n  j < length (\\<beta> @ \\<delta>') \\<and>\n  (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n   (take j (\\<beta> @ \\<delta>')) \\<and>\n  LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n   (drop (Suc j) (\\<beta> @ \\<delta>'))\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "with i_in j_in"], ["proof (chain)\npicking this:\n  i < length \\<alpha>\n  j < length \\<beta>\n  is_sentence (\\<alpha> @ \\<delta>) \\<and>\n  is_sentence (\\<beta> @ \\<delta>') \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n  i < length (\\<alpha> @ \\<delta>) \\<and>\n  j < length (\\<beta> @ \\<delta>') \\<and>\n  (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n   (take j (\\<beta> @ \\<delta>')) \\<and>\n  LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n   (drop (Suc j) (\\<beta> @ \\<delta>'))", "have take_i_E_take_j: \"LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\""], ["proof (prove)\nusing this:\n  i < length \\<alpha>\n  j < length \\<beta>\n  is_sentence (\\<alpha> @ \\<delta>) \\<and>\n  is_sentence (\\<beta> @ \\<delta>') \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n  i < length (\\<alpha> @ \\<delta>) \\<and>\n  j < length (\\<beta> @ \\<delta>') \\<and>\n  (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n   (take j (\\<beta> @ \\<delta>')) \\<and>\n  LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n   (drop (Suc j) (\\<beta> @ \\<delta>'))\n\ngoal (1 subgoal):\n 1. LeftDerivation (take i \\<alpha>) E (take j \\<beta>)", "by (simp add: less_or_eq_imp_le)"], ["proof (state)\nthis:\n  LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "obtain m where m: \"m = length E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. m = length E \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = length E\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "{"], ["proof (state)\nthis:\n  m = length E\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "assume n_less_m: \"n < m\""], ["proof (state)\nthis:\n  n < m\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  n < m", "have E_nonempty: \"E \\<noteq> []\""], ["proof (prove)\nusing this:\n  n < m\n\ngoal (1 subgoal):\n 1. E \\<noteq> []", "using gr_implies_not0 list.size(3) m"], ["proof (prove)\nusing this:\n  n < m\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> 0\n  length [] = 0\n  m = length E\n\ngoal (1 subgoal):\n 1. E \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  E \\<noteq> []\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have last_E_in_set: \"last E \\<in> set (drop n D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "using last_of_prefix_in_set n_less_m m EF"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < length ?E; ?D = ?E @ ?F\\<rbrakk>\n  \\<Longrightarrow> last ?E \\<in> set (drop ?n ?D)\n  n < m\n  m = length E\n  is_sentence (\\<alpha> @ \\<delta>) \\<and>\n  is_sentence (\\<beta> @ \\<delta>') \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n  i < length (\\<alpha> @ \\<delta>) \\<and>\n  j < length (\\<beta> @ \\<delta>') \\<and>\n  (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n   (take j (\\<beta> @ \\<delta>')) \\<and>\n  LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n   (drop (Suc j) (\\<beta> @ \\<delta>'))\n\ngoal (1 subgoal):\n 1. last E \\<in> set (drop n D)", "by blast"], ["proof (state)\nthis:\n  last E \\<in> set (drop n D)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "obtain k r where kr: \"(k, r) = last E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k r. (k, r) = last E \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis old.prod.exhaust)"], ["proof (state)\nthis:\n  (k, r) = last E\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have k_lower_bound: \"k \\<ge> length \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<beta> \\<le> k", "using dge last_E_in_set kr"], ["proof (prove)\nusing this:\n  derivation_ge (drop n D) (length \\<beta>)\n  last E \\<in> set (drop n D)\n  (k, r) = last E\n\ngoal (1 subgoal):\n 1. length \\<beta> \\<le> k", "by (metis derivation_ge_def fst_conv)"], ["proof (state)\nthis:\n  length \\<beta> \\<le> k\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have \"\\<exists> \\<alpha>'. Derives1 \\<alpha>' k r (take j \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'. Derives1 \\<alpha>' k r (take j \\<beta>)", "using LeftDerivation_Derives1_last take_i_E_take_j"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerivation ?a ?D ?b; ?D \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Derives1 (Derive ?a (take (length ?D - 1) ?D))\n                     (fst (last ?D)) (snd (last ?D)) ?b\n  LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'. Derives1 \\<alpha>' k r (take j \\<beta>)", "by (metis E_nonempty kr fst_conv snd_conv)"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>'. Derives1 \\<alpha>' k r (take j \\<beta>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>'. Derives1 \\<alpha>' k r (take j \\<beta>)", "have \"k \\<le> j\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>'. Derives1 \\<alpha>' k r (take j \\<beta>)\n\ngoal (1 subgoal):\n 1. k \\<le> j", "by (metis Derives1_bound' j_in length_take less_imp_le_nat min.absorb2)"], ["proof (state)\nthis:\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  k \\<le> j", "have k_upper_bound: \"k < length \\<beta>\""], ["proof (prove)\nusing this:\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. k < length \\<beta>", "using j_in"], ["proof (prove)\nusing this:\n  k \\<le> j\n  j < length \\<beta>\n\ngoal (1 subgoal):\n 1. k < length \\<beta>", "by arith"], ["proof (state)\nthis:\n  k < length \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "from k_lower_bound k_upper_bound"], ["proof (chain)\npicking this:\n  length \\<beta> \\<le> k\n  k < length \\<beta>", "have \"False\""], ["proof (prove)\nusing this:\n  length \\<beta> \\<le> k\n  k < length \\<beta>\n\ngoal (1 subgoal):\n 1. False", "by arith"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "}"], ["proof (state)\nthis:\n  n < m \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  n < m \\<Longrightarrow> False", "have m_le_n: \"m \\<le> n\""], ["proof (prove)\nusing this:\n  n < m \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by arith"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have take_i_E_take_j: \"LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (take i \\<alpha>) E (take j \\<beta>)", "by (simp add: take_i_E_take_j)"], ["proof (state)\nthis:\n  LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have \"take n D = E @ (take (n - m) (derivation_shift F 0 (Suc j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n D = E @ take (n - m) (derivation_shift F 0 (Suc j))", "using EF m m_le_n"], ["proof (prove)\nusing this:\n  is_sentence (\\<alpha> @ \\<delta>) \\<and>\n  is_sentence (\\<beta> @ \\<delta>') \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) D (\\<beta> @ \\<delta>') \\<and>\n  i < length (\\<alpha> @ \\<delta>) \\<and>\n  j < length (\\<beta> @ \\<delta>') \\<and>\n  (\\<alpha> @ \\<delta>) ! i = (\\<beta> @ \\<delta>') ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<alpha> @ \\<delta>)) E\n   (take j (\\<beta> @ \\<delta>')) \\<and>\n  LeftDerivation (drop (Suc i) (\\<alpha> @ \\<delta>)) F\n   (drop (Suc j) (\\<beta> @ \\<delta>'))\n  m = length E\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. take n D = E @ take (n - m) (derivation_shift F 0 (Suc j))", "by auto"], ["proof (state)\nthis:\n  take n D = E @ take (n - m) (derivation_shift F 0 (Suc j))\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  take n D = E @ take (n - m) (derivation_shift F 0 (Suc j))", "have take_n_D: \"take n D = E @ (derivation_shift (take (n - m) F) 0 (Suc j))\""], ["proof (prove)\nusing this:\n  take n D = E @ take (n - m) (derivation_shift F 0 (Suc j))\n\ngoal (1 subgoal):\n 1. take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)", "using take_derivation_shift"], ["proof (prove)\nusing this:\n  take n D = E @ take (n - m) (derivation_shift F 0 (Suc j))\n  take ?n (derivation_shift ?D ?left ?right) =\n  derivation_shift (take ?n ?D) ?left ?right\n\ngoal (1 subgoal):\n 1. take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)", "by auto"], ["proof (state)\nthis:\n  take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "obtain F' where F': \"F' = derivation_shift (take (n - m) F) 0 (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        F' = derivation_shift (take (n - m) F) 0 (Suc j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  F' = derivation_shift (take (n - m) F) 0 (Suc j)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have \"LeftDerivation ((take i \\<alpha>)@(drop i \\<alpha>)) E ((take j \\<beta>)@(drop i \\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (take i \\<alpha> @ drop i \\<alpha>) E\n     (take j \\<beta> @ drop i \\<alpha>)", "using take_i_E_take_j"], ["proof (prove)\nusing this:\n  LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n\ngoal (1 subgoal):\n 1. LeftDerivation (take i \\<alpha> @ drop i \\<alpha>) E\n     (take j \\<beta> @ drop i \\<alpha>)", "by (metis EF LeftDerivation_append_suffix append_take_drop_id is_sentence_concat)"], ["proof (state)\nthis:\n  LeftDerivation (take i \\<alpha> @ drop i \\<alpha>) E\n   (take j \\<beta> @ drop i \\<alpha>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (take i \\<alpha> @ drop i \\<alpha>) E\n   (take j \\<beta> @ drop i \\<alpha>)", "have \"LeftDerivation \\<alpha> E ((take j \\<beta>)@(drop i \\<alpha>))\""], ["proof (prove)\nusing this:\n  LeftDerivation (take i \\<alpha> @ drop i \\<alpha>) E\n   (take j \\<beta> @ drop i \\<alpha>)\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> E (take j \\<beta> @ drop i \\<alpha>)", "by simp"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> E (take j \\<beta> @ drop i \\<alpha>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "with take_n_D"], ["proof (chain)\npicking this:\n  take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)\n  LeftDerivation \\<alpha> E (take j \\<beta> @ drop i \\<alpha>)", "have take_j_drop_i: \"LeftDerivation ((take j \\<beta>)@(drop i \\<alpha>)) F' \\<beta>\""], ["proof (prove)\nusing this:\n  take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)\n  LeftDerivation \\<alpha> E (take j \\<beta> @ drop i \\<alpha>)\n\ngoal (1 subgoal):\n 1. LeftDerivation (take j \\<beta> @ drop i \\<alpha>) F' \\<beta>", "using F'"], ["proof (prove)\nusing this:\n  take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)\n  LeftDerivation \\<alpha> E (take j \\<beta> @ drop i \\<alpha>)\n  F' = derivation_shift (take (n - m) F) 0 (Suc j)\n\ngoal (1 subgoal):\n 1. LeftDerivation (take j \\<beta> @ drop i \\<alpha>) F' \\<beta>", "by (metis Derivation_unique_dest LeftDerivation_append LeftDerivation_implies_Derivation \\<alpha>_\\<beta>)"], ["proof (state)\nthis:\n  LeftDerivation (take j \\<beta> @ drop i \\<alpha>) F' \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have F'_ge: \"derivation_ge F' (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge F' (Suc j)", "using F' derivation_ge_shift"], ["proof (prove)\nusing this:\n  F' = derivation_shift (take (n - m) F) 0 (Suc j)\n  derivation_ge (derivation_shift ?F 0 ?j) ?j\n\ngoal (1 subgoal):\n 1. derivation_ge F' (Suc j)", "by blast"], ["proof (state)\nthis:\n  derivation_ge F' (Suc j)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have drop_append: \"drop i \\<alpha> = [\\<alpha>!i] @ (drop (Suc i) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop i \\<alpha> = [\\<alpha> ! i] @ drop (Suc i) \\<alpha>", "by (simp add: Cons_nth_drop_Suc i_in)"], ["proof (state)\nthis:\n  drop i \\<alpha> = [\\<alpha> ! i] @ drop (Suc i) \\<alpha>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have take_append: \"take j \\<beta> @ [\\<alpha>!i] = take (Suc j) \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take j \\<beta> @ [\\<alpha> ! i] = take (Suc j) \\<beta>", "by (metis LeftDerivationFix_def i_in j_in ldfix nth_superfluous_append take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take j \\<beta> @ [\\<alpha> ! i] = take (Suc j) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have take_drop_Suc: \"(take j \\<beta>)@(drop i \\<alpha>) = (take (Suc j) \\<beta>)@(drop (Suc i) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take j \\<beta> @ drop i \\<alpha> =\n    take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>", "by (simp add: drop_append take_append)"], ["proof (state)\nthis:\n  take j \\<beta> @ drop i \\<alpha> =\n  take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "with take_drop_Suc take_j_drop_i"], ["proof (chain)\npicking this:\n  take j \\<beta> @ drop i \\<alpha> =\n  take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>\n  LeftDerivation (take j \\<beta> @ drop i \\<alpha>) F' \\<beta>\n  take j \\<beta> @ drop i \\<alpha> =\n  take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>", "have \"LeftDerivation ((take (Suc j) \\<beta>)@(drop (Suc i) \\<alpha>)) F' \\<beta>\""], ["proof (prove)\nusing this:\n  take j \\<beta> @ drop i \\<alpha> =\n  take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>\n  LeftDerivation (take j \\<beta> @ drop i \\<alpha>) F' \\<beta>\n  take j \\<beta> @ drop i \\<alpha> =\n  take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>\n\ngoal (1 subgoal):\n 1. LeftDerivation (take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>) F' \\<beta>", "by auto"], ["proof (state)\nthis:\n  LeftDerivation (take (Suc j) \\<beta> @ drop (Suc i) \\<alpha>) F' \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "note helper = LeftDerivation_skip_prefix[OF this]"], ["proof (state)\nthis:\n  derivation_ge F' (length (take (Suc j) \\<beta>)) \\<Longrightarrow>\n  LeftDerivation (drop (Suc i) \\<alpha>)\n   (derivation_shift F' (length (take (Suc j) \\<beta>)) 0)\n   (drop (length (take (Suc j) \\<beta>)) \\<beta>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have len_take: \"length (take (Suc j) \\<beta>) = Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc j) \\<beta>) = Suc j", "by (simp add: Suc_leI j_in min.absorb2)"], ["proof (state)\nthis:\n  length (take (Suc j) \\<beta>) = Suc j\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have F'_shift: \"derivation_shift F' (Suc j) 0 = take (n - m) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_shift F' (Suc j) 0 = take (n - m) F", "using F' derivation_shift_right_left_cancel"], ["proof (prove)\nusing this:\n  F' = derivation_shift (take (n - m) F) 0 (Suc j)\n  derivation_shift (derivation_shift ?D 0 ?r) ?r 0 = ?D\n\ngoal (1 subgoal):\n 1. derivation_shift F' (Suc j) 0 = take (n - m) F", "by blast"], ["proof (state)\nthis:\n  derivation_shift F' (Suc j) 0 = take (n - m) F\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "have LeftDerivation_drop: \"LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F) (drop (Suc j) \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "using helper len_take F'_shift F'_ge"], ["proof (prove)\nusing this:\n  derivation_ge F' (length (take (Suc j) \\<beta>)) \\<Longrightarrow>\n  LeftDerivation (drop (Suc i) \\<alpha>)\n   (derivation_shift F' (length (take (Suc j) \\<beta>)) 0)\n   (drop (length (take (Suc j) \\<beta>)) \\<beta>)\n  length (take (Suc j) \\<beta>) = Suc j\n  derivation_shift F' (Suc j) 0 = take (n - m) F\n  derivation_ge F' (Suc j)\n\ngoal (1 subgoal):\n 1. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "by auto"], ["proof (state)\nthis:\n  LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n   (drop (Suc j) \\<beta>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "apply (auto simp add: LeftDerivationFix_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. is_sentence \\<alpha>\n 2. is_sentence \\<beta>\n 3. LeftDerivation \\<alpha> (take n D) \\<beta>\n 4. i < length \\<alpha>\n 5. j < length \\<beta>\n 6. \\<alpha> ! i = \\<beta> ! j\n 7. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "using LeftDerivationFix_is_sentence is_sentence_concat ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  LeftDerivationFix (\\<alpha> @ \\<delta>) i D j (\\<beta> @ \\<delta>')\n\ngoal (7 subgoals):\n 1. is_sentence \\<alpha>\n 2. is_sentence \\<beta>\n 3. LeftDerivation \\<alpha> (take n D) \\<beta>\n 4. i < length \\<alpha>\n 5. j < length \\<beta>\n 6. \\<alpha> ! i = \\<beta> ! j\n 7. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. is_sentence \\<beta>\n 2. LeftDerivation \\<alpha> (take n D) \\<beta>\n 3. i < length \\<alpha>\n 4. j < length \\<beta>\n 5. \\<alpha> ! i = \\<beta> ! j\n 6. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "using LeftDerivationFix_is_sentence is_sentence_concat ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n  LeftDerivationFix (\\<alpha> @ \\<delta>) i D j (\\<beta> @ \\<delta>')\n\ngoal (6 subgoals):\n 1. is_sentence \\<beta>\n 2. LeftDerivation \\<alpha> (take n D) \\<beta>\n 3. i < length \\<alpha>\n 4. j < length \\<beta>\n 5. \\<alpha> ! i = \\<beta> ! j\n 6. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> (take n D) \\<beta>\n 2. i < length \\<alpha>\n 3. j < length \\<beta>\n 4. \\<alpha> ! i = \\<beta> ! j\n 5. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "using \\<alpha>_\\<beta>"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take n D) \\<beta>\n\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> (take n D) \\<beta>\n 2. i < length \\<alpha>\n 3. j < length \\<beta>\n 4. \\<alpha> ! i = \\<beta> ! j\n 5. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. i < length \\<alpha>\n 2. j < length \\<beta>\n 3. \\<alpha> ! i = \\<beta> ! j\n 4. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "using i_in"], ["proof (prove)\nusing this:\n  i < length \\<alpha>\n\ngoal (4 subgoals):\n 1. i < length \\<alpha>\n 2. j < length \\<beta>\n 3. \\<alpha> ! i = \\<beta> ! j\n 4. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. j < length \\<beta>\n 2. \\<alpha> ! i = \\<beta> ! j\n 3. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "using j_in"], ["proof (prove)\nusing this:\n  j < length \\<beta>\n\ngoal (3 subgoals):\n 1. j < length \\<beta>\n 2. \\<alpha> ! i = \\<beta> ! j\n 3. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha> ! i = \\<beta> ! j\n 2. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "using LeftDerivationFix_def i_in j_in ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n  i < length \\<alpha>\n  j < length \\<beta>\n  LeftDerivationFix (\\<alpha> @ \\<delta>) i D j (\\<beta> @ \\<delta>')\n\ngoal (2 subgoals):\n 1. \\<alpha> ! i = \\<beta> ! j\n 2. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply (rule_tac x=E in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F.\n       take n D = E @ derivation_shift F 0 (Suc j) \\<and>\n       LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n       LeftDerivation (drop (Suc i) \\<alpha>) F (drop (Suc j) \\<beta>)", "apply (rule_tac x=\"take (n - m) F\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j) \\<and>\n    LeftDerivation (take i \\<alpha>) E (take j \\<beta>) \\<and>\n    LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)\n 2. LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n 3. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "using take_n_D"], ["proof (prove)\nusing this:\n  take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)\n\ngoal (3 subgoals):\n 1. take n D = E @ derivation_shift (take (n - m) F) 0 (Suc j)\n 2. LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n 3. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n 2. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "using take_i_E_take_j"], ["proof (prove)\nusing this:\n  LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n\ngoal (2 subgoals):\n 1. LeftDerivation (take i \\<alpha>) E (take j \\<beta>)\n 2. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "using LeftDerivation_drop"], ["proof (prove)\nusing this:\n  LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n   (drop (Suc j) \\<beta>)\n\ngoal (1 subgoal):\n 1. LeftDerivation (drop (Suc i) \\<alpha>) (take (n - m) F)\n     (drop (Suc j) \\<beta>)", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> i (take n D) j \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFix_cut_appendix':\n  assumes ldfix: \"LeftDerivationFix (\\<alpha>@\\<delta>) i D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> D \\<beta>\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationFix \\<alpha> i D j \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i D j \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i D j \\<beta>", "obtain n where n: \"n = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = length D\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i D j \\<beta>", "have \"LeftDerivationFix \\<alpha> i (take n D) j \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "apply (rule_tac LeftDerivationFix_cut_appendix)"], ["proof (prove)\ngoal (6 subgoals):\n 1. LeftDerivationFix (\\<alpha> @ ?\\<delta>) i D j (\\<beta> @ ?\\<delta>')\n 2. LeftDerivation \\<alpha> (take n D) \\<beta>\n 3. n \\<le> length D\n 4. derivation_ge (drop n D) (length \\<beta>)\n 5. i < length \\<alpha>\n 6. j < length \\<beta>", "apply (rule ldfix)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> (take n D) \\<beta>\n 2. n \\<le> length D\n 3. derivation_ge (drop n D) (length \\<beta>)\n 4. i < length \\<alpha>\n 5. j < length \\<beta>", "using \\<alpha>_\\<beta> n"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> D \\<beta>\n  n = length D\n\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> (take n D) \\<beta>\n 2. n \\<le> length D\n 3. derivation_ge (drop n D) (length \\<beta>)\n 4. i < length \\<alpha>\n 5. j < length \\<beta>", "apply auto[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. n \\<le> length D\n 2. derivation_ge (drop n D) (length \\<beta>)\n 3. i < length \\<alpha>\n 4. j < length \\<beta>", "using n"], ["proof (prove)\nusing this:\n  n = length D\n\ngoal (4 subgoals):\n 1. n \\<le> length D\n 2. derivation_ge (drop n D) (length \\<beta>)\n 3. i < length \\<alpha>\n 4. j < length \\<beta>", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_ge (drop n D) (length \\<beta>)\n 2. i < length \\<alpha>\n 3. j < length \\<beta>", "using n"], ["proof (prove)\nusing this:\n  n = length D\n\ngoal (3 subgoals):\n 1. derivation_ge (drop n D) (length \\<beta>)\n 2. i < length \\<alpha>\n 3. j < length \\<beta>", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < length \\<alpha>\n 2. j < length \\<beta>", "using i_in"], ["proof (prove)\nusing this:\n  i < length \\<alpha>\n\ngoal (2 subgoals):\n 1. i < length \\<alpha>\n 2. j < length \\<beta>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length \\<beta>", "using j_in"], ["proof (prove)\nusing this:\n  j < length \\<beta>\n\ngoal (1 subgoal):\n 1. j < length \\<beta>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> i (take n D) j \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i D j \\<beta>", "then"], ["proof (chain)\npicking this:\n  LeftDerivationFix \\<alpha> i (take n D) j \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> i (take n D) j \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i D j \\<beta>", "using n"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> i (take n D) j \\<beta>\n  n = length D\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> i D j \\<beta>", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> i D j \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_cut_appendix:\n  assumes ldfix: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> ((i,r)#(take n D)) \\<beta>\"\n  assumes n_bound: \"n \\<le> length D\"\n  assumes dge: \"derivation_ge (drop n D) (length \\<beta>)\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "from LeftDerivationIntro_def[where \\<alpha>=\"\\<alpha>@\\<delta>\" and i=i and r=r and ix=ix and D=D and j=j and \\<gamma>=\"\\<beta>@\\<delta>'\"]"], ["proof (chain)\npicking this:\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j\n   (\\<beta> @ \\<delta>') =\n  (\\<exists>\\<beta>'.\n      LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>' \\<and>\n      ix < length (snd r) \\<and>\n      snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n      LeftDerivationFix \\<beta>' (i + ix) D j (\\<beta> @ \\<delta>'))", "obtain \\<omega> where \\<omega>: \"LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n      ix < length (snd r) \\<and> snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and> LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\""], ["proof (prove)\nusing this:\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j\n   (\\<beta> @ \\<delta>') =\n  (\\<exists>\\<beta>'.\n      LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>' \\<and>\n      ix < length (snd r) \\<and>\n      snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n      LeftDerivationFix \\<beta>' (i + ix) D j (\\<beta> @ \\<delta>'))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n        ix < length (snd r) \\<and>\n        snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n        LeftDerivationFix \\<omega> (i + ix) D j\n         (\\<beta> @ \\<delta>') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j\n   (\\<beta> @ \\<delta>') =\n  (\\<exists>\\<beta>'.\n      LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<beta>' \\<and>\n      ix < length (snd r) \\<and>\n      snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n      LeftDerivationFix \\<beta>' (i + ix) D j (\\<beta> @ \\<delta>'))\n  LeftDerivationIntro (\\<alpha> @ \\<delta>) i r ix D j (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n        ix < length (snd r) \\<and>\n        snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n        LeftDerivationFix \\<omega> (i + ix) D j\n         (\\<beta> @ \\<delta>') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')", "have \"\\<exists> \\<alpha>'. \\<omega> = \\<alpha>' @ \\<delta> \\<and> i + length (snd r) \\<le> length \\<alpha>'\""], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "using i_in"], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n  i < length \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "using LeftDerives1_append_replace_in_left"], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n  i < length \\<alpha>\n  \\<lbrakk>LeftDerives1 (?\\<alpha> @ ?\\<delta>) ?i ?r ?\\<beta>;\n   ?i < length ?\\<alpha>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<alpha>'.\n                       ?\\<beta> = \\<alpha>' @ ?\\<delta> \\<and>\n                       LeftDerives1 ?\\<alpha> ?i ?r \\<alpha>' \\<and>\n                       ?i + length (snd ?r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>'.\n       \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n       i + length (snd r) \\<le> length \\<alpha>'", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>'.\n     \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>'.\n     \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'", "obtain \\<alpha>' where \\<alpha>': \"\\<omega> = \\<alpha>' @ \\<delta> \\<and> i + length (snd r) \\<le> length \\<alpha>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>'.\n     \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n     i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>'.\n        \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n        i + length (snd r) \\<le> length \\<alpha>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "have \\<alpha>_\\<alpha>': \"LeftDerives1 \\<alpha> i r \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>'", "using \\<alpha>' \\<omega>"], ["proof (prove)\nusing this:\n  \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>'", "using LeftDerives1_skip_suffix i_in"], ["proof (prove)\nusing this:\n  \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n  \\<lbrakk>?i < length ?a; LeftDerives1 (?a @ ?c) ?i ?r (?b @ ?c)\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 ?a ?i ?r ?b\n  i < length \\<alpha>\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>'", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "from \\<alpha>_\\<beta>"], ["proof (chain)\npicking this:\n  LeftDerivation \\<alpha> ((i, r) # take n D) \\<beta>", "obtain u where u: \"LeftDerives1 \\<alpha> i r u \\<and> LeftDerivation u (take n D) \\<beta>\""], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> ((i, r) # take n D) \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        LeftDerives1 \\<alpha> i r u \\<and>\n        LeftDerivation u (take n D) \\<beta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LeftDerives1 \\<alpha> i r u \\<and> LeftDerivation u (take n D) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "with \\<alpha>_\\<alpha>'"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n  LeftDerives1 \\<alpha> i r u \\<and> LeftDerivation u (take n D) \\<beta>", "have \"u = \\<alpha>'\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n  LeftDerives1 \\<alpha> i r u \\<and> LeftDerivation u (take n D) \\<beta>\n\ngoal (1 subgoal):\n 1. u = \\<alpha>'", "using Derives1_unique_dest LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n  LeftDerives1 \\<alpha> i r u \\<and> LeftDerivation u (take n D) \\<beta>\n  \\<lbrakk>Derives1 ?u ?i ?r ?v; Derives1 ?u ?i ?r ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. u = \\<alpha>'", "by blast"], ["proof (state)\nthis:\n  u = \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "with u"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<alpha> i r u \\<and> LeftDerivation u (take n D) \\<beta>\n  u = \\<alpha>'", "have \\<alpha>'_\\<beta>: \"LeftDerivation \\<alpha>' (take n D) \\<beta>\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<alpha> i r u \\<and> LeftDerivation u (take n D) \\<beta>\n  u = \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha>' (take n D) \\<beta>", "by auto"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha>' (take n D) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "have ldfix_append: \"LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j (\\<beta> @ \\<delta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j\n     (\\<beta> @ \\<delta>')", "using \\<alpha>' \\<omega>"], ["proof (prove)\nusing this:\n  \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j\n     (\\<beta> @ \\<delta>')", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<alpha>' @ \\<delta>) (i + ix) D j\n   (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "have i_plus_ix_bound: \"i + ix < length \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + ix < length \\<alpha>'", "using \\<omega> \\<alpha>'"], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n  \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n\ngoal (1 subgoal):\n 1. i + ix < length \\<alpha>'", "using add_lessD1 le_add_diff_inverse less_asym' linorder_neqE_nat nat_add_left_cancel_less"], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n  \\<omega> = \\<alpha>' @ \\<delta> \\<and>\n  i + length (snd r) \\<le> length \\<alpha>'\n  ?i + ?j < ?k \\<Longrightarrow> ?i < ?k\n  ?b \\<le> ?a \\<Longrightarrow> ?b + (?a - ?b) = ?a\n  \\<lbrakk>?a < ?b; ?b < ?a\\<rbrakk> \\<Longrightarrow> ?P\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?R;\n   ?y < ?x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  (?k + ?m < ?k + ?n) = (?m < ?n)\n\ngoal (1 subgoal):\n 1. i + ix < length \\<alpha>'", "by linarith"], ["proof (state)\nthis:\n  i + ix < length \\<alpha>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "from LeftDerivationFix_cut_appendix[OF ldfix_append \\<alpha>'_\\<beta> n_bound dge i_plus_ix_bound j_in]"], ["proof (chain)\npicking this:\n  LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "have ldfix: \"LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>\""], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "."], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "apply (simp add: LeftDerivationIntro_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>'.\n       LeftDerives1 \\<alpha> i r \\<beta>' \\<and>\n       ix < length (snd r) \\<and>\n       snd r ! ix = \\<beta> ! j \\<and>\n       LeftDerivationFix \\<beta>' (i + ix) (take n D) j \\<beta>", "apply (rule_tac x=\"\\<alpha>'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>' \\<and>\n    ix < length (snd r) \\<and>\n    snd r ! ix = \\<beta> ! j \\<and>\n    LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>'\n 2. ix < length (snd r)\n 3. snd r ! ix = \\<beta> ! j\n 4. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "using \\<alpha>_\\<alpha>'"], ["proof (prove)\nusing this:\n  LeftDerives1 \\<alpha> i r \\<alpha>'\n\ngoal (4 subgoals):\n 1. LeftDerives1 \\<alpha> i r \\<alpha>'\n 2. ix < length (snd r)\n 3. snd r ! ix = \\<beta> ! j\n 4. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. ix < length (snd r)\n 2. snd r ! ix = \\<beta> ! j\n 3. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "using \\<omega>"], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<alpha> @ \\<delta>) i r \\<omega> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = (\\<beta> @ \\<delta>') ! j \\<and>\n  LeftDerivationFix \\<omega> (i + ix) D j (\\<beta> @ \\<delta>')\n\ngoal (3 subgoals):\n 1. ix < length (snd r)\n 2. snd r ! ix = \\<beta> ! j\n 3. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd r ! ix = \\<beta> ! j\n 2. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "apply (simp add: \\<omega> j_in)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "using ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha>' (i + ix) (take n D) j \\<beta>", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_cut_appendix':\n  assumes ldfix: \"LeftDerivationIntro (\\<alpha>@\\<delta>) i r ix D j (\\<beta>@\\<delta>')\"\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> ((i,r)#D) \\<beta>\"\n  assumes i_in: \"i < length \\<alpha>\"\n  assumes j_in: \"j < length \\<beta>\"\n  shows \"LeftDerivationIntro \\<alpha> i r ix D j \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<beta>", "obtain n where n: \"n = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = length D\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<beta>", "have \"LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "apply (rule_tac LeftDerivationIntro_cut_appendix)"], ["proof (prove)\ngoal (6 subgoals):\n 1. LeftDerivationIntro (\\<alpha> @ ?\\<delta>) i r ix D j\n     (\\<beta> @ ?\\<delta>')\n 2. LeftDerivation \\<alpha> ((i, r) # take n D) \\<beta>\n 3. n \\<le> length D\n 4. derivation_ge (drop n D) (length \\<beta>)\n 5. i < length \\<alpha>\n 6. j < length \\<beta>", "apply (rule ldfix)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> ((i, r) # take n D) \\<beta>\n 2. n \\<le> length D\n 3. derivation_ge (drop n D) (length \\<beta>)\n 4. i < length \\<alpha>\n 5. j < length \\<beta>", "using \\<alpha>_\\<beta> n"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> ((i, r) # D) \\<beta>\n  n = length D\n\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> ((i, r) # take n D) \\<beta>\n 2. n \\<le> length D\n 3. derivation_ge (drop n D) (length \\<beta>)\n 4. i < length \\<alpha>\n 5. j < length \\<beta>", "apply auto[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. n \\<le> length D\n 2. derivation_ge (drop n D) (length \\<beta>)\n 3. i < length \\<alpha>\n 4. j < length \\<beta>", "using n"], ["proof (prove)\nusing this:\n  n = length D\n\ngoal (4 subgoals):\n 1. n \\<le> length D\n 2. derivation_ge (drop n D) (length \\<beta>)\n 3. i < length \\<alpha>\n 4. j < length \\<beta>", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_ge (drop n D) (length \\<beta>)\n 2. i < length \\<alpha>\n 3. j < length \\<beta>", "using n"], ["proof (prove)\nusing this:\n  n = length D\n\ngoal (3 subgoals):\n 1. derivation_ge (drop n D) (length \\<beta>)\n 2. i < length \\<alpha>\n 3. j < length \\<beta>", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < length \\<alpha>\n 2. j < length \\<beta>", "using i_in"], ["proof (prove)\nusing this:\n  i < length \\<alpha>\n\ngoal (2 subgoals):\n 1. i < length \\<alpha>\n 2. j < length \\<beta>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length \\<beta>", "using j_in"], ["proof (prove)\nusing this:\n  j < length \\<beta>\n\ngoal (1 subgoal):\n 1. j < length \\<beta>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<beta>", "then"], ["proof (chain)\npicking this:\n  LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<beta>", "using n"], ["proof (prove)\nusing this:\n  LeftDerivationIntro \\<alpha> i r ix (take n D) j \\<beta>\n  n = length D\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro \\<alpha> i r ix D j \\<beta>", "by auto"], ["proof (state)\nthis:\n  LeftDerivationIntro \\<alpha> i r ix D j \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_n_monotone: \"is_ladder D L \\<Longrightarrow> u \\<le> v \\<Longrightarrow> v < length L \\<Longrightarrow> ladder_n L u \\<le> ladder_n L v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ladder D L; u \\<le> v; v < length L\\<rbrakk>\n    \\<Longrightarrow> ladder_n L u \\<le> ladder_n L v", "by (metis is_ladder_def le_neq_implies_less linear not_less)"], ["", "lemma ladder_i_cut: \n  assumes index_bound: \"index < length L\"\n  shows \"ladder_i (ladder_cut L n) index = ladder_i L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) index = ladder_i L index", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) index = ladder_i L index", "have \"index = 0 \\<or> index > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index = 0 \\<or> 0 < index", "by arith"], ["proof (state)\nthis:\n  index = 0 \\<or> 0 < index\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) index = ladder_i L index", "then"], ["proof (chain)\npicking this:\n  index = 0 \\<or> 0 < index", "show ?thesis"], ["proof (prove)\nusing this:\n  index = 0 \\<or> 0 < index\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) index = ladder_i L index", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index\n 2. 0 < index \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index", "case 1"], ["proof (state)\nthis:\n  index = 0\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index\n 2. 0 < index \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index", "with index_bound"], ["proof (chain)\npicking this:\n  index < length L\n  index = 0", "have \"L \\<noteq> []\""], ["proof (prove)\nusing this:\n  index < length L\n  index = 0\n\ngoal (1 subgoal):\n 1. L \\<noteq> []", "by (simp add: less_numeral_extra(3))"], ["proof (state)\nthis:\n  L \\<noteq> []\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index\n 2. 0 < index \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index", "then"], ["proof (chain)\npicking this:\n  L \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  L \\<noteq> []\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) index = ladder_i L index", "using 1"], ["proof (prove)\nusing this:\n  L \\<noteq> []\n  index = 0\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) index = ladder_i L index", "by (simp add: ladder_i_of_cut_at_0)"], ["proof (state)\nthis:\n  ladder_i (ladder_cut L n) index = ladder_i L index\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index", "case 2"], ["proof (state)\nthis:\n  0 < index\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_i (ladder_cut L n) index = ladder_i L index", "then"], ["proof (chain)\npicking this:\n  0 < index", "show ?case"], ["proof (prove)\nusing this:\n  0 < index\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut L n) index = ladder_i L index", "apply (auto simp add: ladder_i_def ladder_cut_def ladder_j_def deriv_j_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    fst (snd (L[length L - Suc 0 := (n, snd (L ! (length L - Suc 0)))] !\n              (index - Suc 0))) =\n    fst (snd (L ! (index - Suc 0)))", "using index_bound"], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    fst (snd (L[length L - Suc 0 := (n, snd (L ! (length L - Suc 0)))] !\n              (index - Suc 0))) =\n    fst (snd (L ! (index - Suc 0)))", "by auto"], ["proof (state)\nthis:\n  ladder_i (ladder_cut L n) index = ladder_i L index\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_i (ladder_cut L n) index = ladder_i L index\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_j_cut: \n  assumes index_bound: \"index < length L\"\n  shows \"ladder_j (ladder_cut L n) index = ladder_j L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j (ladder_cut L n) index = ladder_j L index", "by (metis gr_implies_not0 index_bound ladder_cut_def ladder_j_def ladder_last_j_def \n  ladder_last_j_of_cut length_ladder_cut list.size(3) nth_list_update_neq)"], ["", "lemma ladder_ix_cut: \n  assumes index_lower_bound: \"index > 0\"\n  assumes index_upper_bound: \"index < length L\"\n  shows \"ladder_ix (ladder_cut L n) index = ladder_ix L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix (ladder_cut L n) index = ladder_ix L index", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_ix (ladder_cut L n) index = ladder_ix L index", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix (ladder_cut L n) index = ladder_ix L index", "using index_lower_bound"], ["proof (prove)\nusing this:\n  0 < index\n\ngoal (1 subgoal):\n 1. ladder_ix (ladder_cut L n) index = ladder_ix L index", "apply (simp add: ladder_ix_def deriv_ix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    snd (snd (ladder_cut L n ! index)) = snd (snd (L ! index))", "by (metis index_upper_bound ladder_cut_def nth_list_update_eq nth_list_update_neq snd_conv)"], ["proof (state)\nthis:\n  ladder_ix (ladder_cut L n) index = ladder_ix L index\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivation_from_in_between:\n  assumes \\<alpha>_\\<beta>: \"LeftDerivation \\<alpha> (take u D) \\<beta>\"\n  assumes \\<alpha>_\\<gamma>: \"LeftDerivation \\<alpha> (take v D) \\<gamma>\"\n  assumes u_le_v: \"u \\<le> v\"\n  shows \"LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>", "have take_split: \"take v D = take u D @ (drop u (take v D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take v D = take u D @ drop u (take v D)", "by (metis u_le_v add_diff_cancel_left' drop_take le_Suc_ex take_add)"], ["proof (state)\nthis:\n  take v D = take u D @ drop u (take v D)\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>", "then"], ["proof (chain)\npicking this:\n  take v D = take u D @ drop u (take v D)", "show ?thesis"], ["proof (prove)\nusing this:\n  take v D = take u D @ drop u (take v D)\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>", "using \\<alpha>_\\<gamma> \\<alpha>_\\<beta>"], ["proof (prove)\nusing this:\n  take v D = take u D @ drop u (take v D)\n  LeftDerivation \\<alpha> (take v D) \\<gamma>\n  LeftDerivation \\<alpha> (take u D) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>", "by (metis (no_types, lifting) Derivation_unique_dest LeftDerivation_append \n      LeftDerivation_implies_Derivation)"], ["proof (state)\nthis:\n  LeftDerivation \\<beta> (drop u (take v D)) \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationLadder_cut_appendix_helper: \n  assumes LDLadder: \"LeftDerivationLadder (\\<alpha>@\\<delta>) D L \\<gamma>\"\n  assumes ladder_i_in_\\<alpha>: \"ladder_i L 0 < length \\<alpha>\"\n  shows \"\\<exists> E F \\<gamma>1 \\<gamma>2 L'. D = E@F \\<and> \n    \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and> \n    LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and> \n    derivation_ge F (length \\<gamma>1) \\<and>\n    LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0) \\<gamma>2 \\<and>\n    L' = ladder_cut L (length E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have is_ladder_D_L: \"is_ladder D L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder D L", "using LDLadder LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. is_ladder D L", "by blast"], ["proof (state)\nthis:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "obtain n where n: \"n = ladder_last_n L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n = ladder_last_n L \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = ladder_last_n L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  n = ladder_last_n L", "have n_eq_ladder_n: \"n = ladder_n L (length L - 1)\""], ["proof (prove)\nusing this:\n  n = ladder_last_n L\n\ngoal (1 subgoal):\n 1. n = ladder_n L (length L - 1)", "using ladder_last_n_def"], ["proof (prove)\nusing this:\n  n = ladder_last_n L\n  ladder_last_n ?L = ladder_n ?L (length ?L - 1)\n\ngoal (1 subgoal):\n 1. n = ladder_n L (length L - 1)", "by blast"], ["proof (state)\nthis:\n  n = ladder_n L (length L - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have length_L_nonzero: \"length L > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length L", "using LeftDerivationLadder_def assms(1) is_ladder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. 0 < length L", "by blast"], ["proof (state)\nthis:\n  0 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "from LeftDerivationLadder_propagate[OF LDLadder ladder_i_in_\\<alpha> n_eq_ladder_n]"], ["proof (chain)\npicking this:\n  length L - 1 < length L \\<Longrightarrow>\n  if length L - 1 + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L (length L - 1) < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (length L - 1 = 0 \\<or>\n           ladder_prev_n L (length L - 1) < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L (length L - 1) < length \\<beta>", "obtain n' \\<beta> \\<delta>' where finish:\n    \"(length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n     n' \\<le> n \\<and>\n     LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n     LeftDerivation (\\<alpha> @ \\<delta>) (take n' D) (\\<beta> @ \\<delta>) \\<and>\n     derivation_ge (drop n' D) (length \\<beta>) \\<and>\n     LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n     ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) = \\<beta> @ \\<delta>' \\<and> ladder_j L (length L - 1) < length \\<beta>\""], ["proof (prove)\nusing this:\n  length L - 1 < length L \\<Longrightarrow>\n  if length L - 1 + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L (length L - 1) < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (length L - 1 = 0 \\<or>\n           ladder_prev_n L (length L - 1) < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L (length L - 1) < length \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>n' \\<beta> \\<delta>'.\n        (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n        n' \\<le> n \\<and>\n        LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n        LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n         (\\<beta> @ \\<delta>) \\<and>\n        derivation_ge (drop n' D) (length \\<beta>) \\<and>\n        LeftDerivation \\<delta>\n         (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n        \\<beta> @ \\<delta>' \\<and>\n        ladder_j L (length L - 1) < length \\<beta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L - 1 < length L \\<Longrightarrow>\n  if length L - 1 + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L (length L - 1) < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (length L - 1 = 0 \\<or>\n           ladder_prev_n L (length L - 1) < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L (length L - 1) < length \\<beta>\n  0 < length L\n\ngoal (1 subgoal):\n 1. (\\<And>n' \\<beta> \\<delta>'.\n        (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n        n' \\<le> n \\<and>\n        LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n        LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n         (\\<beta> @ \\<delta>) \\<and>\n        derivation_ge (drop n' D) (length \\<beta>) \\<and>\n        LeftDerivation \\<delta>\n         (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n        \\<beta> @ \\<delta>' \\<and>\n        ladder_j L (length L - 1) < length \\<beta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "obtain E where E: \"E = take n' D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E. E = take n' D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E = take n' D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "obtain F where F: \"F = drop n' D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F. F = drop n' D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  F = drop n' D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "obtain L' where L': \"L' = ladder_cut L (length E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        L' = ladder_cut L (length E) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L' = ladder_cut L (length E)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \\<gamma>_ladder: \"\\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1)", "by (metis Derive LDLadder LeftDerivationLadder_def LeftDerivation_implies_Derivation \n      append_Nil2 append_take_drop_id drop_eq_Nil is_ladder_def ladder_\\<gamma>_def le_refl n \n      n_eq_ladder_n)"], ["proof (state)\nthis:\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1)", "have \\<gamma>: \"\\<gamma> = \\<beta> @ \\<delta>'\""], ["proof (prove)\nusing this:\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1)\n\ngoal (1 subgoal):\n 1. \\<gamma> = \\<beta> @ \\<delta>'", "using finish"], ["proof (prove)\nusing this:\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1)\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n\ngoal (1 subgoal):\n 1. \\<gamma> = \\<beta> @ \\<delta>'", "by auto"], ["proof (state)\nthis:\n  \\<gamma> = \\<beta> @ \\<delta>'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \"is_sentence (\\<alpha>@\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence (\\<alpha> @ \\<delta>)", "using LDLadder LeftDerivationFix_is_sentence LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. is_sentence (\\<alpha> @ \\<delta>)", "by blast"], ["proof (state)\nthis:\n  is_sentence (\\<alpha> @ \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  is_sentence (\\<alpha> @ \\<delta>)", "have is_sentence_\\<alpha>: \"is_sentence \\<alpha>\""], ["proof (prove)\nusing this:\n  is_sentence (\\<alpha> @ \\<delta>)\n\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "using is_sentence_concat"], ["proof (prove)\nusing this:\n  is_sentence (\\<alpha> @ \\<delta>)\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \"is_sentence \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence \\<gamma>", "using Derivation_implies_derives LDLadder LeftDerivationFix_is_sentence \n      LeftDerivationLadder_def LeftDerivation_implies_Derivation derives_is_sentence"], ["proof (prove)\nusing this:\n  Derivation ?a ?D ?b \\<Longrightarrow> derives ?a ?b\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationFix ?a ?i ?D ?j ?b \\<Longrightarrow>\n  is_sentence ?a \\<and> is_sentence ?b\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  derives ?\\<alpha> ?\\<beta> \\<Longrightarrow>\n  ?\\<alpha> = ?\\<beta> \\<or>\n  is_sentence ?\\<alpha> \\<and> is_sentence ?\\<beta>\n\ngoal (1 subgoal):\n 1. is_sentence \\<gamma>", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  is_sentence \\<gamma>", "have is_sentence_\\<beta>: \"is_sentence \\<beta>\""], ["proof (prove)\nusing this:\n  is_sentence \\<gamma>\n\ngoal (1 subgoal):\n 1. is_sentence \\<beta>", "using \\<gamma> is_sentence_concat"], ["proof (prove)\nusing this:\n  is_sentence \\<gamma>\n  \\<gamma> = \\<beta> @ \\<delta>'\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n\ngoal (1 subgoal):\n 1. is_sentence \\<beta>", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have length_L': \"length L' = length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L' = length L", "by (metis L' ladder_cut_def length_list_update)"], ["proof (state)\nthis:\n  length L' = length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_last_n_L': \"ladder_last_n L' = length E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_n L' = length E", "using L' ladder_last_n_of_cut length_L_nonzero"], ["proof (prove)\nusing this:\n  L' = ladder_cut L (length E)\n  ?L \\<noteq> [] \\<Longrightarrow> ladder_last_n (ladder_cut ?L ?n) = ?n\n  0 < length L\n\ngoal (1 subgoal):\n 1. ladder_last_n L' = length E", "by blast"], ["proof (state)\nthis:\n  ladder_last_n L' = length E\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have length_D_eq_n: \"length D = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length D = n", "using LDLadder LeftDerivationLadder_def is_ladder_def n"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  n = ladder_last_n L\n\ngoal (1 subgoal):\n 1. length D = n", "by auto"], ["proof (state)\nthis:\n  length D = n\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  length D = n", "have length_E_eq_n': \"length E = n'\""], ["proof (prove)\nusing this:\n  length D = n\n\ngoal (1 subgoal):\n 1. length E = n'", "by (simp add: E finish min.absorb2)"], ["proof (state)\nthis:\n  length E = n'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  length E = n'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume \"u < length L'\""], ["proof (state)\nthis:\n  u < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  u < length L'", "have \"u < length L' - 1 \\<or> u = length L' - 1\""], ["proof (prove)\nusing this:\n  u < length L'\n\ngoal (1 subgoal):\n 1. u < length L' - 1 \\<or> u = length L' - 1", "by arith"], ["proof (state)\nthis:\n  u < length L' - 1 \\<or> u = length L' - 1\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  u < length L' - 1 \\<or> u = length L' - 1", "have \"ladder_n L' u \\<le> length E\""], ["proof (prove)\nusing this:\n  u < length L' - 1 \\<or> u = length L' - 1\n\ngoal (1 subgoal):\n 1. ladder_n L' u \\<le> length E", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. u < length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E\n 2. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "case 1"], ["proof (state)\nthis:\n  u < length L' - 1\n\ngoal (2 subgoals):\n 1. u < length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E\n 2. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "have u_bound: \"u < length L - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L - 1", "using 1"], ["proof (prove)\nusing this:\n  u < length L' - 1\n\ngoal (1 subgoal):\n 1. u < length L - 1", "by (simp add: length_L')"], ["proof (state)\nthis:\n  u < length L - 1\n\ngoal (2 subgoals):\n 1. u < length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E\n 2. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "then"], ["proof (chain)\npicking this:\n  u < length L - 1", "have L'_eq_L: \"ladder_n L' u = ladder_n L u\""], ["proof (prove)\nusing this:\n  u < length L - 1\n\ngoal (1 subgoal):\n 1. ladder_n L' u = ladder_n L u", "using L' ladder_n_of_cut \n          length_L_nonzero length_greater_0_conv"], ["proof (prove)\nusing this:\n  u < length L - 1\n  L' = ladder_cut L (length E)\n  \\<lbrakk>?L \\<noteq> []; ?index < length ?L - 1\\<rbrakk>\n  \\<Longrightarrow> ladder_n (ladder_cut ?L ?n) ?index = ladder_n ?L ?index\n  0 < length L\n  (0 < length ?xs) = (?xs \\<noteq> [])\n\ngoal (1 subgoal):\n 1. ladder_n L' u = ladder_n L u", "by blast"], ["proof (state)\nthis:\n  ladder_n L' u = ladder_n L u\n\ngoal (2 subgoals):\n 1. u < length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E\n 2. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "from u_bound"], ["proof (chain)\npicking this:\n  u < length L - 1", "have \"ladder_n L u \\<le> ladder_prev_n L (length L - 1)\""], ["proof (prove)\nusing this:\n  u < length L - 1\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_prev_n L (length L - 1)", "using ladder_n_prev_bound LeftDerivationLadder_def assms(1)"], ["proof (prove)\nusing this:\n  u < length L - 1\n  \\<lbrakk>is_ladder ?D ?L; ?u < length ?L - 1\\<rbrakk>\n  \\<Longrightarrow> ladder_n ?L ?u \\<le> ladder_prev_n ?L (length ?L - 1)\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_prev_n L (length L - 1)", "by blast"], ["proof (state)\nthis:\n  ladder_n L u \\<le> ladder_prev_n L (length L - 1)\n\ngoal (2 subgoals):\n 1. u < length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E\n 2. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "then"], ["proof (chain)\npicking this:\n  ladder_n L u \\<le> ladder_prev_n L (length L - 1)", "show ?case"], ["proof (prove)\nusing this:\n  ladder_n L u \\<le> ladder_prev_n L (length L - 1)\n\ngoal (1 subgoal):\n 1. ladder_n L' u \\<le> length E", "using L'_eq_L finish length_E_eq_n' u_bound"], ["proof (prove)\nusing this:\n  ladder_n L u \\<le> ladder_prev_n L (length L - 1)\n  ladder_n L' u = ladder_n L u\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n  length E = n'\n  u < length L - 1\n\ngoal (1 subgoal):\n 1. ladder_n L' u \\<le> length E", "by linarith"], ["proof (state)\nthis:\n  ladder_n L' u \\<le> length E\n\ngoal (1 subgoal):\n 1. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "case 2"], ["proof (state)\nthis:\n  u = length L' - 1\n\ngoal (1 subgoal):\n 1. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "then"], ["proof (chain)\npicking this:\n  u = length L' - 1", "have \"ladder_n L' u = length E\""], ["proof (prove)\nusing this:\n  u = length L' - 1\n\ngoal (1 subgoal):\n 1. ladder_n L' u = length E", "using ladder_last_n_L' ladder_last_n_def"], ["proof (prove)\nusing this:\n  u = length L' - 1\n  ladder_last_n L' = length E\n  ladder_last_n ?L = ladder_n ?L (length ?L - 1)\n\ngoal (1 subgoal):\n 1. ladder_n L' u = length E", "by auto"], ["proof (state)\nthis:\n  ladder_n L' u = length E\n\ngoal (1 subgoal):\n 1. u = length L' - 1 \\<Longrightarrow> ladder_n L' u \\<le> length E", "then"], ["proof (chain)\npicking this:\n  ladder_n L' u = length E", "show ?case"], ["proof (prove)\nusing this:\n  ladder_n L' u = length E\n\ngoal (1 subgoal):\n 1. ladder_n L' u \\<le> length E", "by auto"], ["proof (state)\nthis:\n  ladder_n L' u \\<le> length E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_n L' u \\<le> length E\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length E\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note ladder_n_bound = this"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length E\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length E\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix v :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume u_less_v: \"u < v\""], ["proof (state)\nthis:\n  u < v\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume v_bound: \"v < length L'\""], ["proof (state)\nthis:\n  v < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \"v < length L' - 1 \\<or> v = length L' - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < length L' - 1 \\<or> v = length L' - 1", "using v_bound"], ["proof (prove)\nusing this:\n  v < length L'\n\ngoal (1 subgoal):\n 1. v < length L' - 1 \\<or> v = length L' - 1", "by arith"], ["proof (state)\nthis:\n  v < length L' - 1 \\<or> v = length L' - 1\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  v < length L' - 1 \\<or> v = length L' - 1", "have \"ladder_n L' u < ladder_n L' v\""], ["proof (prove)\nusing this:\n  v < length L' - 1 \\<or> v = length L' - 1\n\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. v < length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. v = length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "case 1"], ["proof (state)\nthis:\n  v < length L' - 1\n\ngoal (2 subgoals):\n 1. v < length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. v = length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "using \"1.hyps\" L' LeftDerivationLadder_def assms(1) is_ladder_def ladder_n_of_cut \n            length_L' u_less_v"], ["proof (prove)\nusing this:\n  v < length L' - 1\n  L' = ladder_cut L (length E)\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  \\<lbrakk>?L \\<noteq> []; ?index < length ?L - 1\\<rbrakk>\n  \\<Longrightarrow> ladder_n (ladder_cut ?L ?n) ?index = ladder_n ?L ?index\n  length L' = length L\n  u < v\n\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "by auto"], ["proof (state)\nthis:\n  ladder_n L' u < ladder_n L' v\n\ngoal (1 subgoal):\n 1. v = length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "case 2"], ["proof (state)\nthis:\n  v = length L' - 1\n\ngoal (1 subgoal):\n 1. v = length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "note v_def = 2"], ["proof (state)\nthis:\n  v = length L' - 1\n\ngoal (1 subgoal):\n 1. v = length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "have \"v = 0 \\<or> v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = 0 \\<or> v \\<noteq> 0", "by arith"], ["proof (state)\nthis:\n  v = 0 \\<or> v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v = length L' - 1 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "then"], ["proof (chain)\npicking this:\n  v = 0 \\<or> v \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  v = 0 \\<or> v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. v \\<noteq> 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "case 1"], ["proof (state)\nthis:\n  v = 0\n\ngoal (2 subgoals):\n 1. v = 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. v \\<noteq> 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "then"], ["proof (chain)\npicking this:\n  v = 0", "show ?case"], ["proof (prove)\nusing this:\n  v = 0\n\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "using u_less_v"], ["proof (prove)\nusing this:\n  v = 0\n  u < v\n\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "by auto"], ["proof (state)\nthis:\n  ladder_n L' u < ladder_n L' v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "case 2"], ["proof (state)\nthis:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> 0", "have \"ladder_prev_n L (length L - 1) < n'\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ladder_prev_n L (length L - 1) < n'", "using finish v_def length_L'"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n  v = length L' - 1\n  length L' = length L\n\ngoal (1 subgoal):\n 1. ladder_prev_n L (length L - 1) < n'", "by linarith"], ["proof (state)\nthis:\n  ladder_prev_n L (length L - 1) < n'\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "then"], ["proof (chain)\npicking this:\n  ladder_prev_n L (length L - 1) < n'", "show ?case"], ["proof (prove)\nusing this:\n  ladder_prev_n L (length L - 1) < n'\n\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "by (metis (no_types, lifting) L' LeftDerivationLadder_def assms(1) \n              ladder_last_n_L' ladder_last_n_def ladder_n_of_cut ladder_n_prev_bound \n              le_neq_implies_less length_E_eq_n' length_L' length_greater_0_conv \n              less_trans u_less_v v_def)"], ["proof (state)\nthis:\n  ladder_n L' u < ladder_n L' v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_n L' u < ladder_n L' v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_n L' u < ladder_n L' v\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note ladder_n_pairwise_bound = this"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have is_ladder_E_L': \"is_ladder E L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder E L'", "apply (auto simp add: is_ladder_def ladder_last_n_L')"], ["proof (prove)\ngoal (3 subgoals):\n 1. L' = [] \\<Longrightarrow> False\n 2. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length E\n 3. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "using length_L_nonzero length_L'"], ["proof (prove)\nusing this:\n  0 < length L\n  length L' = length L\n\ngoal (3 subgoals):\n 1. L' = [] \\<Longrightarrow> False\n 2. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length E\n 3. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length E\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "using ladder_n_bound"], ["proof (prove)\nusing this:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length E\n\ngoal (2 subgoals):\n 1. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length E\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "using ladder_n_pairwise_bound"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v", "by blast"], ["proof (state)\nthis:\n  is_ladder E L'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  is_ladder E L'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume index_bound: \"index + 1 < length L\""], ["proof (state)\nthis:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  index + 1 < length L", "have index_le: \"index < length L\""], ["proof (prove)\nusing this:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. index < length L", "by arith"], ["proof (state)\nthis:\n  index < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "from index_bound"], ["proof (chain)\npicking this:\n  index + 1 < length L", "have len_L_minus_1: \"length L - 1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. length L - 1 \\<noteq> 0", "by arith"], ["proof (state)\nthis:\n  length L - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "obtain m where m: \"m = ladder_n L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m = ladder_n L index \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = ladder_n L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "from LeftDerivationLadder_propagate[OF LDLadder ladder_i_in_\\<alpha> m index_le]"], ["proof (chain)\npicking this:\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take m D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n          n' \\<le> m \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>", "obtain \\<omega> where\n      \\<omega>: \"LeftDerivation \\<alpha> (take m D) \\<omega> \\<and> ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index = \\<omega> @ \\<delta> \\<and> \n      ladder_j L index < length \\<omega>\""], ["proof (prove)\nusing this:\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take m D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n          n' \\<le> m \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        LeftDerivation \\<alpha> (take m D) \\<omega> \\<and>\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n        \\<omega> @ \\<delta> \\<and>\n        ladder_j L index < length \\<omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using index_bound"], ["proof (prove)\nusing this:\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take m D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta> \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n          n' \\<le> m \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n           (\\<beta> @ \\<delta>) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation \\<delta>\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        LeftDerivation \\<alpha> (take m D) \\<omega> \\<and>\n        ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n        \\<omega> @ \\<delta> \\<and>\n        ladder_j L index < length \\<omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take m D) \\<omega> \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  \\<omega> @ \\<delta> \\<and>\n  ladder_j L index < length \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have L'_Derive: \"ladder_\\<gamma> \\<alpha> E L' index = Derive \\<alpha> (take (ladder_n L' index) E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> \\<alpha> E L' index =\n    Derive \\<alpha> (take (ladder_n L' index) E)", "by (simp add: ladder_\\<gamma>_def)"], ["proof (state)\nthis:\n  ladder_\\<gamma> \\<alpha> E L' index =\n  Derive \\<alpha> (take (ladder_n L' index) E)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_n_L'_eq_L: \"ladder_n L' index = ladder_n L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L index", "using L' index_bound ladder_n_of_cut length_L_nonzero"], ["proof (prove)\nusing this:\n  L' = ladder_cut L (length E)\n  index + 1 < length L\n  \\<lbrakk>?L \\<noteq> []; ?index < length ?L - 1\\<rbrakk>\n  \\<Longrightarrow> ladder_n (ladder_cut ?L ?n) ?index = ladder_n ?L ?index\n  0 < length L\n\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L index", "by auto"], ["proof (state)\nthis:\n  ladder_n L' index = ladder_n L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \"ladder_prev_n L (length L - 1) < n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_prev_n L (length L - 1) < n'", "using finish len_L_minus_1"], ["proof (prove)\nusing this:\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n  length L - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ladder_prev_n L (length L - 1) < n'", "by blast"], ["proof (state)\nthis:\n  ladder_prev_n L (length L - 1) < n'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  ladder_prev_n L (length L - 1) < n'", "have n'_is_upper_bound: \"ladder_n L (length L - 2) < n'\""], ["proof (prove)\nusing this:\n  ladder_prev_n L (length L - 1) < n'\n\ngoal (1 subgoal):\n 1. ladder_n L (length L - 2) < n'", "using index_bound"], ["proof (prove)\nusing this:\n  ladder_prev_n L (length L - 1) < n'\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. ladder_n L (length L - 2) < n'", "by (metis diff_diff_left ladder_prev_n_def len_L_minus_1 one_add_one)"], ["proof (state)\nthis:\n  ladder_n L (length L - 2) < n'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have index_upper_bound: \"index \\<le> length L - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index \\<le> length L - 2", "using index_bound"], ["proof (prove)\nusing this:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. index \\<le> length L - 2", "by linarith"], ["proof (state)\nthis:\n  index \\<le> length L - 2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_n_upper_bound: \"ladder_n L index \\<le> ladder_n L (length L - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L index \\<le> ladder_n L (length L - 2)", "apply (rule_tac ladder_n_monotone)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_ladder ?D L\n 2. index \\<le> length L - 2\n 3. length L - 2 < length L", "apply (rule_tac is_ladder_D_L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index \\<le> length L - 2\n 2. length L - 2 < length L", "apply (rule index_upper_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length L - 2 < length L", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  0 < length L\n\ngoal (1 subgoal):\n 1. length L - 2 < length L", "by linarith"], ["proof (state)\nthis:\n  ladder_n L index \\<le> ladder_n L (length L - 2)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "with n'_is_upper_bound"], ["proof (chain)\npicking this:\n  ladder_n L (length L - 2) < n'\n  ladder_n L index \\<le> ladder_n L (length L - 2)", "have m_le_n': \"m \\<le> n'\""], ["proof (prove)\nusing this:\n  ladder_n L (length L - 2) < n'\n  ladder_n L index \\<le> ladder_n L (length L - 2)\n\ngoal (1 subgoal):\n 1. m \\<le> n'", "using dual_order.strict_implies_order le_less_trans m"], ["proof (prove)\nusing this:\n  ladder_n L (length L - 2) < n'\n  ladder_n L index \\<le> ladder_n L (length L - 2)\n  ?b < ?a \\<Longrightarrow> ?b \\<le> ?a\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  m = ladder_n L index\n\ngoal (1 subgoal):\n 1. m \\<le> n'", "by linarith"], ["proof (state)\nthis:\n  m \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  m \\<le> n'", "have \"take m E = take m D\""], ["proof (prove)\nusing this:\n  m \\<le> n'\n\ngoal (1 subgoal):\n 1. take m E = take m D", "by (metis E le_take_same length_E_eq_n' order_refl take_all)"], ["proof (state)\nthis:\n  take m E = take m D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  take m E = take m D", "have take_helper: \"(take (ladder_n L' index) E) = take m D\""], ["proof (prove)\nusing this:\n  take m E = take m D\n\ngoal (1 subgoal):\n 1. take (ladder_n L' index) E = take m D", "by (simp add: ladder_n_L'_eq_L m)"], ["proof (state)\nthis:\n  take (ladder_n L' index) E = take m D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  take (ladder_n L' index) E = take m D", "have Derive_eq_\\<omega>: \"Derive \\<alpha> (take (ladder_n L' index) E) = \\<omega>\""], ["proof (prove)\nusing this:\n  take (ladder_n L' index) E = take m D\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (ladder_n L' index) E) = \\<omega>", "by (simp add: Derive LeftDerivation_implies_Derivation \\<omega>)"], ["proof (state)\nthis:\n  Derive \\<alpha> (take (ladder_n L' index) E) = \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  Derive \\<alpha> (take (ladder_n L' index) E) = \\<omega>", "have t1: \"ladder_\\<gamma> (\\<alpha>@\\<delta>) D L index = (ladder_\\<gamma> \\<alpha> E L' index) @ \\<delta>\""], ["proof (prove)\nusing this:\n  Derive \\<alpha> (take (ladder_n L' index) E) = \\<omega>\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n    ladder_\\<gamma> \\<alpha> E L' index @ \\<delta>", "by (simp add: L'_Derive \\<omega>)"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  ladder_\\<gamma> \\<alpha> E L' index @ \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \\<omega>_eq: \"\\<omega> = ladder_\\<gamma> \\<alpha> E L' index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> = ladder_\\<gamma> \\<alpha> E L' index", "by (simp add: Derive_eq_\\<omega> L'_Derive)"], ["proof (state)\nthis:\n  \\<omega> = ladder_\\<gamma> \\<alpha> E L' index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  \\<omega> = ladder_\\<gamma> \\<alpha> E L' index", "have t2: \"LeftDerivation \\<alpha> (take (ladder_n L index) D) (ladder_\\<gamma> \\<alpha> E L' index)\""], ["proof (prove)\nusing this:\n  \\<omega> = ladder_\\<gamma> \\<alpha> E L' index\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L index) D)\n     (ladder_\\<gamma> \\<alpha> E L' index)", "using \\<omega> m"], ["proof (prove)\nusing this:\n  \\<omega> = ladder_\\<gamma> \\<alpha> E L' index\n  LeftDerivation \\<alpha> (take m D) \\<omega> \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  \\<omega> @ \\<delta> \\<and>\n  ladder_j L index < length \\<omega>\n  m = ladder_n L index\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L index) D)\n     (ladder_\\<gamma> \\<alpha> E L' index)", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L index) D)\n   (ladder_\\<gamma> \\<alpha> E L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have t3: \"(take (ladder_n L' index) E) = take (ladder_n L index) D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (ladder_n L' index) E = take (ladder_n L index) D", "by (simp add: m take_helper)"], ["proof (state)\nthis:\n  take (ladder_n L' index) E = take (ladder_n L index) D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have t4: \"ladder_j L index < length (ladder_\\<gamma> \\<alpha> E L' index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> E L' index)", "using \\<omega> \\<omega>_eq"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take m D) \\<omega> \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  \\<omega> @ \\<delta> \\<and>\n  ladder_j L index < length \\<omega>\n  \\<omega> = ladder_\\<gamma> \\<alpha> E L' index\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> E L' index)", "by blast"], ["proof (state)\nthis:\n  ladder_j L index < length (ladder_\\<gamma> \\<alpha> E L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have t5: \"E ! (ladder_n L' index) = D ! (ladder_n L index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E ! ladder_n L' index = D ! ladder_n L index", "using E ladder_n_L'_eq_L ladder_n_upper_bound n'_is_upper_bound"], ["proof (prove)\nusing this:\n  E = take n' D\n  ladder_n L' index = ladder_n L index\n  ladder_n L index \\<le> ladder_n L (length L - 2)\n  ladder_n L (length L - 2) < n'\n\ngoal (1 subgoal):\n 1. E ! ladder_n L' index = D ! ladder_n L index", "by auto"], ["proof (state)\nthis:\n  E ! ladder_n L' index = D ! ladder_n L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note t = t1 t2 t3 t4 t5"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  ladder_\\<gamma> \\<alpha> E L' index @ \\<delta>\n  LeftDerivation \\<alpha> (take (ladder_n L index) D)\n   (ladder_\\<gamma> \\<alpha> E L' index)\n  take (ladder_n L' index) E = take (ladder_n L index) D\n  ladder_j L index < length (ladder_\\<gamma> \\<alpha> E L' index)\n  E ! ladder_n L' index = D ! ladder_n L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  ?index2 + 1 < length L \\<Longrightarrow>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L ?index2 =\n  ladder_\\<gamma> \\<alpha> E L' ?index2 @ \\<delta>\n  ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L ?index2) D)\n   (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  ?index2 + 1 < length L \\<Longrightarrow>\n  take (ladder_n L' ?index2) E = take (ladder_n L ?index2) D\n  ?index2 + 1 < length L \\<Longrightarrow>\n  ladder_j L ?index2 < length (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  ?index2 + 1 < length L \\<Longrightarrow>\n  E ! ladder_n L' ?index2 = D ! ladder_n L ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note ladder_early_stage = this"], ["proof (state)\nthis:\n  ?index2 + 1 < length L \\<Longrightarrow>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L ?index2 =\n  ladder_\\<gamma> \\<alpha> E L' ?index2 @ \\<delta>\n  ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L ?index2) D)\n   (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  ?index2 + 1 < length L \\<Longrightarrow>\n  take (ladder_n L' ?index2) E = take (ladder_n L ?index2) D\n  ?index2 + 1 < length L \\<Longrightarrow>\n  ladder_j L ?index2 < length (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  ?index2 + 1 < length L \\<Longrightarrow>\n  E ! ladder_n L' ?index2 = D ! ladder_n L ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  ?index2 + 1 < length L \\<Longrightarrow>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L ?index2 =\n  ladder_\\<gamma> \\<alpha> E L' ?index2 @ \\<delta>\n  ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L ?index2) D)\n   (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  ?index2 + 1 < length L \\<Longrightarrow>\n  take (ladder_n L' ?index2) E = take (ladder_n L ?index2) D\n  ?index2 + 1 < length L \\<Longrightarrow>\n  ladder_j L ?index2 < length (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  ?index2 + 1 < length L \\<Longrightarrow>\n  E ! ladder_n L' ?index2 = D ! ladder_n L ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume index_bound: \"index < length L\""], ["proof (state)\nthis:\n  index < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have i: \"ladder_i L' index = ladder_i L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L index", "using L' ladder_i_cut"], ["proof (prove)\nusing this:\n  L' = ladder_cut L (length E)\n  ?index < length ?L \\<Longrightarrow>\n  ladder_i (ladder_cut ?L ?n) ?index = ladder_i ?L ?index\n\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L index", "by (simp add: index_bound)"], ["proof (state)\nthis:\n  ladder_i L' index = ladder_i L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have j: \"ladder_j L' index = ladder_j L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L index", "using L' ladder_j_cut"], ["proof (prove)\nusing this:\n  L' = ladder_cut L (length E)\n  ?index < length ?L \\<Longrightarrow>\n  ladder_j (ladder_cut ?L ?n) ?index = ladder_j ?L ?index\n\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L index", "by (simp add: index_bound)"], ["proof (state)\nthis:\n  ladder_j L' index = ladder_j L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ix: \"index > 0 \\<Longrightarrow> ladder_ix L' index = ladder_ix L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow> ladder_ix L' index = ladder_ix L index", "using L' ladder_ix_cut"], ["proof (prove)\nusing this:\n  L' = ladder_cut L (length E)\n  \\<lbrakk>0 < ?index; ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_ix (ladder_cut ?L ?n) ?index =\n                    ladder_ix ?L ?index\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow> ladder_ix L' index = ladder_ix L index", "by (simp add: index_bound)"], ["proof (state)\nthis:\n  0 < index \\<Longrightarrow> ladder_ix L' index = ladder_ix L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \\<alpha>: \"ladder_\\<alpha> (\\<alpha>@\\<delta>) D L index = (ladder_\\<alpha> \\<alpha> E L' index) @ \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L index =\n    ladder_\\<alpha> \\<alpha> E L' index @ \\<delta>", "by (simp add: index_bound ladder_\\<alpha>_def ladder_early_stage(1))"], ["proof (state)\nthis:\n  ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L index =\n  ladder_\\<alpha> \\<alpha> E L' index @ \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have i_bound: \"index > 0 \\<Longrightarrow> ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)", "using i index_bound ladder_\\<alpha>_def ladder_early_stage(4) ladder_i_def"], ["proof (prove)\nusing this:\n  ladder_i L' index = ladder_i L index\n  index < length L\n  ladder_\\<alpha> ?a ?D ?L ?index =\n  (if ?index = 0 then ?a else ladder_\\<gamma> ?a ?D ?L (?index - 1))\n  ?index2 + 1 < length L \\<Longrightarrow>\n  ladder_j L ?index2 < length (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  ladder_i ?L ?index =\n  (if ?index = 0 then deriv_i (hd ?L) else ladder_j ?L (?index - 1))\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)", "by auto"], ["proof (state)\nthis:\n  0 < index \\<Longrightarrow>\n  ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note ij = i j ix \\<alpha> i_bound"], ["proof (state)\nthis:\n  ladder_i L' index = ladder_i L index\n  ladder_j L' index = ladder_j L index\n  0 < index \\<Longrightarrow> ladder_ix L' index = ladder_ix L index\n  ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L index =\n  ladder_\\<alpha> \\<alpha> E L' index @ \\<delta>\n  0 < index \\<Longrightarrow>\n  ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  ?index2 < length L \\<Longrightarrow>\n  ladder_i L' ?index2 = ladder_i L ?index2\n  ?index2 < length L \\<Longrightarrow>\n  ladder_j L' ?index2 = ladder_j L ?index2\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_ix L' ?index2 = ladder_ix L ?index2\n  ?index2 < length L \\<Longrightarrow>\n  ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L ?index2 =\n  ladder_\\<alpha> \\<alpha> E L' ?index2 @ \\<delta>\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_i L' ?index2\n                    < length (ladder_\\<alpha> \\<alpha> E L' ?index2)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note ladder_every_stage = this"], ["proof (state)\nthis:\n  ?index2 < length L \\<Longrightarrow>\n  ladder_i L' ?index2 = ladder_i L ?index2\n  ?index2 < length L \\<Longrightarrow>\n  ladder_j L' ?index2 = ladder_j L ?index2\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_ix L' ?index2 = ladder_ix L ?index2\n  ?index2 < length L \\<Longrightarrow>\n  ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L ?index2 =\n  ladder_\\<alpha> \\<alpha> E L' ?index2 @ \\<delta>\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_i L' ?index2\n                    < length (ladder_\\<alpha> \\<alpha> E L' ?index2)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  ?index2 < length L \\<Longrightarrow>\n  ladder_i L' ?index2 = ladder_i L ?index2\n  ?index2 < length L \\<Longrightarrow>\n  ladder_j L' ?index2 = ladder_j L ?index2\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_ix L' ?index2 = ladder_ix L ?index2\n  ?index2 < length L \\<Longrightarrow>\n  ladder_\\<alpha> (\\<alpha> @ \\<delta>) D L ?index2 =\n  ladder_\\<alpha> \\<alpha> E L' ?index2 @ \\<delta>\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_i L' ?index2\n                    < length (ladder_\\<alpha> \\<alpha> E L' ?index2)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix v :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume u_le_v: \"u \\<le> v\""], ["proof (state)\nthis:\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume v_bound: \"v < length L\""], ["proof (state)\nthis:\n  v < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \"ladder_n L u \\<le> ladder_n L v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_n L v", "using is_ladder_D_L ladder_n_monotone u_le_v v_bound"], ["proof (prove)\nusing this:\n  is_ladder D L\n  \\<lbrakk>is_ladder ?D ?L; ?u \\<le> ?v; ?v < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_n ?L ?u \\<le> ladder_n ?L ?v\n  u \\<le> v\n  v < length L\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> ladder_n L v", "by blast"], ["proof (state)\nthis:\n  ladder_n L u \\<le> ladder_n L v\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 \\<le> ?v2; ?v2 < length L\\<rbrakk>\n  \\<Longrightarrow> ladder_n L ?u2 \\<le> ladder_n L ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note ladder_L_n_pairwise_le = this"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 \\<le> ?v2; ?v2 < length L\\<rbrakk>\n  \\<Longrightarrow> ladder_n L ?u2 \\<le> ladder_n L ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 \\<le> ?v2; ?v2 < length L\\<rbrakk>\n  \\<Longrightarrow> ladder_n L ?u2 \\<le> ladder_n L ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume index_lower_bound: \"index > 0\""], ["proof (state)\nthis:\n  0 < index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume index_upper_bound: \"index + 1 < length L\""], ["proof (state)\nthis:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note derivation = ladder_early_stage(2)"], ["proof (state)\nthis:\n  ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L ?index2) D)\n   (ladder_\\<gamma> \\<alpha> E L' ?index2)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have derivation1: \n      \"LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D) (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n     (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))", "using derivation[of \"index - Suc 0\"] index_lower_bound index_upper_bound"], ["proof (prove)\nusing this:\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n   (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n  0 < index\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n     (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))", "using One_nat_def Suc_diff_1 Suc_eq_plus1 le_less_trans lessI less_or_eq_imp_le"], ["proof (prove)\nusing this:\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n   (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n  0 < index\n  index + 1 < length L\n  1 = Suc 0\n  0 < ?n \\<Longrightarrow> Suc (?n - 1) = ?n\n  Suc ?n = ?n + 1\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  ?n < Suc ?n\n  ?m < ?n \\<or> ?m = ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n     (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))", "by linarith"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n   (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have derivation2:\n      \"LeftDerivation \\<alpha> (take (ladder_n L index) D) (ladder_\\<gamma> \\<alpha> E L' index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L index) D)\n     (ladder_\\<gamma> \\<alpha> E L' index)", "using derivation[of index] index_upper_bound"], ["proof (prove)\nusing this:\n  index + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L index) D)\n   (ladder_\\<gamma> \\<alpha> E L' index)\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L index) D)\n     (ladder_\\<gamma> \\<alpha> E L' index)", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L index) D)\n   (ladder_\\<gamma> \\<alpha> E L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_\\<alpha>_is_\\<gamma>[symmetric]: \"ladder_\\<gamma> \\<alpha> E L' (index - Suc 0) = ladder_\\<alpha> \\<alpha> E L' index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> \\<alpha> E L' (index - Suc 0) =\n    ladder_\\<alpha> \\<alpha> E L' index", "using index_lower_bound ladder_\\<alpha>_def"], ["proof (prove)\nusing this:\n  0 < index\n  ladder_\\<alpha> ?a ?D ?L ?index =\n  (if ?index = 0 then ?a else ladder_\\<gamma> ?a ?D ?L (?index - 1))\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> \\<alpha> E L' (index - Suc 0) =\n    ladder_\\<alpha> \\<alpha> E L' index", "by auto"], ["proof (state)\nthis:\n  ladder_\\<alpha> \\<alpha> E L' index =\n  ladder_\\<gamma> \\<alpha> E L' (index - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_n_le: \"ladder_n L (index - Suc 0) \\<le> ladder_n L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (index - Suc 0) \\<le> ladder_n L index", "apply (rule_tac ladder_L_n_pairwise_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index - Suc 0 \\<le> index\n 2. index < length L", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L", "using index_upper_bound"], ["proof (prove)\nusing this:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. index < length L", "by arith"], ["proof (state)\nthis:\n  ladder_n L (index - Suc 0) \\<le> ladder_n L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "from LeftDerivation_from_in_between[OF derivation1 derivation2 ladder_n_le] ladder_\\<alpha>_is_\\<gamma>"], ["proof (chain)\npicking this:\n  LeftDerivation (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n   (drop (ladder_n L (index - Suc 0)) (take (ladder_n L index) D))\n   (ladder_\\<gamma> \\<alpha> E L' index)\n  ladder_\\<alpha> \\<alpha> E L' index =\n  ladder_\\<gamma> \\<alpha> E L' (index - Suc 0)", "have \"LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index) (drop (ladder_n L' (index - Suc 0)) \n      (take (ladder_n L' index) E)) (ladder_\\<gamma> \\<alpha> E L' index)\""], ["proof (prove)\nusing this:\n  LeftDerivation (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n   (drop (ladder_n L (index - Suc 0)) (take (ladder_n L index) D))\n   (ladder_\\<gamma> \\<alpha> E L' index)\n  ladder_\\<alpha> \\<alpha> E L' index =\n  ladder_\\<gamma> \\<alpha> E L' (index - Suc 0)\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     (drop (ladder_n L' (index - Suc 0)) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)", "by (metis L' Suc_leI add_lessD1 index_lower_bound index_upper_bound ladder_early_stage(3) \n        ladder_n_of_cut le_add_diff_inverse2 length_L_nonzero length_greater_0_conv less_diff_conv)"], ["proof (state)\nthis:\n  LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n   (drop (ladder_n L' (index - Suc 0)) (take (ladder_n L' index) E))\n   (ladder_\\<gamma> \\<alpha> E L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?index2; ?index2 + 1 < length L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (ladder_\\<alpha> \\<alpha> E L' ?index2)\n                     (drop (ladder_n L' (?index2 - Suc 0))\n                       (take (ladder_n L' ?index2) E))\n                     (ladder_\\<gamma> \\<alpha> E L' ?index2)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note LeftDerivation_delta_early = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?index2; ?index2 + 1 < length L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (ladder_\\<alpha> \\<alpha> E L' ?index2)\n                     (drop (ladder_n L' (?index2 - Suc 0))\n                       (take (ladder_n L' ?index2) E))\n                     (ladder_\\<gamma> \\<alpha> E L' ?index2)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have LeftDerivationFix_\\<alpha>_0: \"LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E) \n    (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have ldfix: \"LeftDerivationFix (\\<alpha>@\\<delta>) (ladder_i L 0) (take (ladder_n L 0) D) (ladder_j L 0) \n      (ladder_\\<gamma> (\\<alpha>@\\<delta>) D L 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)", "using LDLadder LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n   (take (ladder_n L 0) D) (ladder_j L 0)\n   (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have ladder_i_L': \"ladder_i L' 0 = ladder_i L 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L' 0 = ladder_i L 0", "using L' ladder_i_of_cut_at_0 length_L_nonzero"], ["proof (prove)\nusing this:\n  L' = ladder_cut L (length E)\n  ?L \\<noteq> [] \\<Longrightarrow>\n  ladder_i (ladder_cut ?L ?n) 0 = ladder_i ?L 0\n  0 < length L\n\ngoal (1 subgoal):\n 1. ladder_i L' 0 = ladder_i L 0", "by blast"], ["proof (state)\nthis:\n  ladder_i L' 0 = ladder_i L 0\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have ladder_j_L': \"ladder_j L' 0 = ladder_j L 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' 0 = ladder_j L 0", "by (metis L' ladder_cut_def ladder_j_def ladder_last_j_def ladder_last_j_of_cut \n         length_L' length_greater_0_conv nth_list_update_neq)"], ["proof (state)\nthis:\n  ladder_j L' 0 = ladder_j L 0\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have \"length L = 1 \\<or> length L > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L = 1 \\<or> 1 < length L", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  0 < length L\n\ngoal (1 subgoal):\n 1. length L = 1 \\<or> 1 < length L", "by linarith"], ["proof (state)\nthis:\n  length L = 1 \\<or> 1 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "then"], ["proof (chain)\npicking this:\n  length L = 1 \\<or> 1 < length L", "show ?thesis"], ["proof (prove)\nusing this:\n  length L = 1 \\<or> 1 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "case 1"], ["proof (state)\nthis:\n  length L = 1\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "from 1"], ["proof (chain)\npicking this:\n  length L = 1", "have ladder_n_L'_0: \"ladder_n L' 0 = n'\""], ["proof (prove)\nusing this:\n  length L = 1\n\ngoal (1 subgoal):\n 1. ladder_n L' 0 = n'", "using diff_is_0_eq' ladder_last_n_L' ladder_last_n_def length_E_eq_n' \n            length_L' less_or_eq_imp_le"], ["proof (prove)\nusing this:\n  length L = 1\n  ?m \\<le> ?n \\<Longrightarrow> ?m - ?n = 0\n  ladder_last_n L' = length E\n  ladder_last_n ?L = ladder_n ?L (length ?L - 1)\n  length E = n'\n  length L' = length L\n  ?m < ?n \\<or> ?m = ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. ladder_n L' 0 = n'", "by auto"], ["proof (state)\nthis:\n  ladder_n L' 0 = n'\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have take_n'_E: \"take n' E = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n' E = E", "by (simp add: length_E_eq_n')"], ["proof (state)\nthis:\n  take n' E = E\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "from ladder_n_L'_0 take_n'_E"], ["proof (chain)\npicking this:\n  ladder_n L' 0 = n'\n  take n' E = E", "have take_ladder_n_L': \"take (ladder_n L' 0) E = E\""], ["proof (prove)\nusing this:\n  ladder_n L' 0 = n'\n  take n' E = E\n\ngoal (1 subgoal):\n 1. take (ladder_n L' 0) E = E", "by auto"], ["proof (state)\nthis:\n  take (ladder_n L' 0) E = E\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have \"ladder_n L 0 = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L 0 = length D", "by (simp add: \"1.hyps\" length_D_eq_n n_eq_ladder_n)"], ["proof (state)\nthis:\n  ladder_n L 0 = length D\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "then"], ["proof (chain)\npicking this:\n  ladder_n L 0 = length D", "have take_ladder_n_L_0: \"take (ladder_n L 0) D = D\""], ["proof (prove)\nusing this:\n  ladder_n L 0 = length D\n\ngoal (1 subgoal):\n 1. take (ladder_n L 0) D = D", "by simp"], ["proof (state)\nthis:\n  take (ladder_n L 0) D = D\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have ladder_\\<gamma>_\\<alpha>: \"ladder_\\<gamma> \\<alpha> E L' 0 = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> \\<alpha> E L' 0 = \\<beta>", "apply (simp add: ladder_\\<gamma>_def take_ladder_n_L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive \\<alpha> E = \\<beta>", "by (simp add: Derive E LeftDerivation_implies_Derivation finish)"], ["proof (state)\nthis:\n  ladder_\\<gamma> \\<alpha> E L' 0 = \\<beta>\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have ladder_j_in_\\<beta>: \"ladder_j L 0 < length \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L 0 < length \\<beta>", "using finish \"1.hyps\""], ["proof (prove)\nusing this:\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n  length L = 1\n\ngoal (1 subgoal):\n 1. ladder_j L 0 < length \\<beta>", "by auto"], ["proof (state)\nthis:\n  ladder_j L 0 < length \\<beta>\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have ldfix_1: \"LeftDerivationFix (\\<alpha>@\\<delta>) (ladder_i L 0) D (ladder_j L 0) (\\<beta>@\\<delta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) D (ladder_j L 0)\n     (\\<beta> @ \\<delta>')", "using \"1.hyps\" \\<gamma> \\<gamma>_ladder ldfix take_ladder_n_L_0"], ["proof (prove)\nusing this:\n  length L = 1\n  \\<gamma> = \\<beta> @ \\<delta>'\n  \\<gamma> = ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1)\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n   (take (ladder_n L 0) D) (ladder_j L 0)\n   (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n  take (ladder_n L 0) D = D\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) D (ladder_j L 0)\n     (\\<beta> @ \\<delta>')", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) D (ladder_j L 0)\n   (\\<beta> @ \\<delta>')\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "then"], ["proof (chain)\npicking this:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) D (ladder_j L 0)\n   (\\<beta> @ \\<delta>')", "have \"LeftDerivationFix \\<alpha> (ladder_i L 0) E (ladder_j L 0) \\<beta>\""], ["proof (prove)\nusing this:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0) D (ladder_j L 0)\n   (\\<beta> @ \\<delta>')\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L 0) E (ladder_j L 0) \\<beta>", "by (simp add: E LeftDerivationFix_cut_appendix finish ladder_i_in_\\<alpha> ladder_j_in_\\<beta> \n            length_D_eq_n)"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) E (ladder_j L 0) \\<beta>\n\ngoal (2 subgoals):\n 1. length L = 1 \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "then"], ["proof (chain)\npicking this:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) E (ladder_j L 0) \\<beta>", "show ?case"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) E (ladder_j L 0) \\<beta>\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "by (simp add: ladder_i_L' ladder_j_L' take_ladder_n_L' ladder_\\<gamma>_\\<alpha>)"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "case 2"], ["proof (state)\nthis:\n  1 < length L\n\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have h: \"0 + 1 < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + 1 < length L", "using \"2.hyps\""], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (1 subgoal):\n 1. 0 + 1 < length L", "by auto"], ["proof (state)\nthis:\n  0 + 1 < length L\n\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "note stage = ladder_early_stage[of 0, OF h]"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n  ladder_\\<gamma> \\<alpha> E L' 0 @ \\<delta>\n  LeftDerivation \\<alpha> (take (ladder_n L 0) D)\n   (ladder_\\<gamma> \\<alpha> E L' 0)\n  take (ladder_n L' 0) E = take (ladder_n L 0) D\n  ladder_j L 0 < length (ladder_\\<gamma> \\<alpha> E L' 0)\n  E ! ladder_n L' 0 = D ! ladder_n L 0\n\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "have ldfix0: \"LeftDerivationFix (\\<alpha>@\\<delta>) (ladder_i L 0) (take (ladder_n L 0) D) (ladder_j L 0) \n          ((ladder_\\<gamma> \\<alpha> E L' 0) @ \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> \\<alpha> E L' 0 @ \\<delta>)", "using ladder_i_L' ladder_j_L' ldfix stage(1) stage(3)"], ["proof (prove)\nusing this:\n  ladder_i L' 0 = ladder_i L 0\n  ladder_j L' 0 = ladder_j L 0\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n   (take (ladder_n L 0) D) (ladder_j L 0)\n   (ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0)\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L 0 =\n  ladder_\\<gamma> \\<alpha> E L' 0 @ \\<delta>\n  take (ladder_n L' 0) E = take (ladder_n L 0) D\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> \\<alpha> E L' 0 @ \\<delta>)", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<alpha> @ \\<delta>) (ladder_i L 0)\n   (take (ladder_n L 0) D) (ladder_j L 0)\n   (ladder_\\<gamma> \\<alpha> E L' 0 @ \\<delta>)\n\ngoal (1 subgoal):\n 1. 1 < length L \\<Longrightarrow>\n    LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "from LeftDerivationFix_cut_appendix'[OF ldfix0 stage(2) ladder_i_in_\\<alpha> stage(4)]"], ["proof (chain)\npicking this:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "show ?case"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)", "by (simp add: ladder_i_L' ladder_j_L' stage(3))"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume index_bounds: \"1 \\<le> index \\<and> index + 1 < length L\""], ["proof (state)\nthis:\n  1 \\<le> index \\<and> index + 1 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have introsAt_appendix: \"LeftDerivationIntrosAt (\\<alpha>@\\<delta>) D L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index", "using LDLadder LeftDerivationIntros_def LeftDerivationLadder_def add_lessD1 index_bounds"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationIntros ?a ?D ?L =\n  (\\<forall>index.\n      1 \\<le> index \\<and> index < length ?L \\<longrightarrow>\n      LeftDerivationIntrosAt ?a ?D ?L index)\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  ?i + ?j < ?k \\<Longrightarrow> ?i < ?k\n  1 \\<le> index \\<and> index + 1 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have index_plus_1_upper_bound: \"index + 1 < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index + 1 < length L", "using index_bounds"], ["proof (prove)\nusing this:\n  1 \\<le> index \\<and> index + 1 < length L\n\ngoal (1 subgoal):\n 1. index + 1 < length L", "by arith"], ["proof (state)\nthis:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note early_stage = ladder_early_stage[of index, OF index_plus_1_upper_bound]"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L index =\n  ladder_\\<gamma> \\<alpha> E L' index @ \\<delta>\n  LeftDerivation \\<alpha> (take (ladder_n L index) D)\n   (ladder_\\<gamma> \\<alpha> E L' index)\n  take (ladder_n L' index) E = take (ladder_n L index) D\n  ladder_j L index < length (ladder_\\<gamma> \\<alpha> E L' index)\n  E ! ladder_n L' index = D ! ladder_n L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_i_L_index_eq_fst: \"ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L index = fst (D ! ladder_n L (index - Suc 0))", "using introsAt_appendix LeftDerivationIntrosAt_def index_bounds"], ["proof (prove)\nusing this:\n  LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index\n  LeftDerivationIntrosAt ?a ?D ?L ?index =\n  (let \\<alpha> = ladder_\\<alpha> ?a ?D ?L ?index; i = ladder_i ?L ?index;\n       j = ladder_j ?L ?index; ix = ladder_ix ?L ?index;\n       \\<gamma> = ladder_\\<gamma> ?a ?D ?L ?index;\n       n = ladder_n ?L (?index - 1); m = ladder_n ?L ?index; e = ?D ! n;\n       E = drop (Suc n) (take m ?D)\n   in i = fst e \\<and>\n      LeftDerivationIntro \\<alpha> i (snd e) ix E j \\<gamma>)\n  1 \\<le> index \\<and> index + 1 < length L\n\ngoal (1 subgoal):\n 1. ladder_i L index = fst (D ! ladder_n L (index - Suc 0))", "by (metis One_nat_def)"], ["proof (state)\nthis:\n  ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have E_at_D_at: \"(E ! ladder_n L' (index - Suc 0)) = (D ! ladder_n L (index - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)", "using ladder_early_stage[of \"index - Suc 0\"]"], ["proof (prove)\nusing this:\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (index - Suc 0) =\n  ladder_\\<gamma> \\<alpha> E L' (index - Suc 0) @ \\<delta>\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n   (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  take (ladder_n L' (index - Suc 0)) E = take (ladder_n L (index - Suc 0)) D\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  ladder_j L (index - Suc 0)\n  < length (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n\ngoal (1 subgoal):\n 1. E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)", "by (metis One_nat_def add_lessD1 index_bounds le_add_diff_inverse2)"], ["proof (state)\nthis:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)", "have ladder_i_L'_index_eq_fst: \"ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\""], ["proof (prove)\nusing this:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n\ngoal (1 subgoal):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))", "using index_bounds ladder_i_L_index_eq_fst ladder_every_stage(1) le_add1 le_less_trans"], ["proof (prove)\nusing this:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n  1 \\<le> index \\<and> index + 1 < length L\n  ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\n  ?index2 < length L \\<Longrightarrow>\n  ladder_i L' ?index2 = ladder_i L ?index2\n  ?n \\<le> ?n + ?m\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))", "by auto"], ["proof (state)\nthis:\n  ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have same_derivation: \"(drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E)) =\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E) =\n    drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)", "using L' early_stage(3) index_bounds ladder_n_of_cut length_L_nonzero"], ["proof (prove)\nusing this:\n  L' = ladder_cut L (length E)\n  take (ladder_n L' index) E = take (ladder_n L index) D\n  1 \\<le> index \\<and> index + 1 < length L\n  \\<lbrakk>?L \\<noteq> []; ?index < length ?L - 1\\<rbrakk>\n  \\<Longrightarrow> ladder_n (ladder_cut ?L ?n) ?index = ladder_n ?L ?index\n  0 < length L\n\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E) =\n    drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)", "by auto"], ["proof (state)\nthis:\n  drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E) =\n  drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have deriv_split: \"(drop (ladder_n L' (index - Suc 0)) (take (ladder_n L' index) E)) =\n       ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (ladder_n L' (index - Suc 0)) (take (ladder_n L' index) E) =\n    (ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n    drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E)", "by (metis Cons_nth_drop_Suc One_nat_def Suc_le_lessD add_lessD1 diff_Suc_less index_bounds \n        ladder_i_L'_index_eq_fst ladder_n_bound ladder_n_pairwise_bound length_L' \n        length_take min.absorb2 nth_take prod.collapse)"], ["proof (state)\nthis:\n  drop (ladder_n L' (index - Suc 0)) (take (ladder_n L' index) E) =\n  (ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n  drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \"LeftDerivationIntrosAt \\<alpha> E L' index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> E L' index", "apply (auto simp add: LeftDerivationIntrosAt_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n 2. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index)", "using ladder_i_L'_index_eq_fst"], ["proof (prove)\nusing this:\n  ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n\ngoal (2 subgoals):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n 2. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index)", "apply (rule_tac LeftDerivationIntro_cut_appendix'[where \\<delta>=\\<delta> and \\<delta>' = \\<delta>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index @ \\<delta>)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index @ \\<delta>)\n 2. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)\n 3. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 4. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "apply (metis E_at_D_at LeftDerivationIntrosAt_def One_nat_def Suc_le_lessD add_lessD1 \n        early_stage(1) index_bounds introsAt_appendix ladder_every_stage(2) \n        ladder_every_stage(3) ladder_every_stage(4) ladder_i_L'_index_eq_fst same_derivation)"], ["proof (prove)\ngoal (3 subgoals):\n 1. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)\n 2. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 3. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "defer 1"], ["proof (prove)\ngoal (3 subgoals):\n 1. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 2. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)\n 3. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)", "using index_bounds ladder_every_stage(5)"], ["proof (prove)\nusing this:\n  1 \\<le> index \\<and> index + 1 < length L\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_i L' ?index2\n                    < length (ladder_\\<alpha> \\<alpha> E L' ?index2)\n\ngoal (3 subgoals):\n 1. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 2. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)\n 3. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)\n 2. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)", "using early_stage(4) index_bounds ladder_every_stage(2)"], ["proof (prove)\nusing this:\n  ladder_j L index < length (ladder_\\<gamma> \\<alpha> E L' index)\n  1 \\<le> index \\<and> index + 1 < length L\n  ?index2 < length L \\<Longrightarrow>\n  ladder_j L' ?index2 = ladder_j L ?index2\n\ngoal (2 subgoals):\n 1. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)\n 2. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)", "using LeftDerivation_delta_early deriv_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?index2; ?index2 + 1 < length L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation (ladder_\\<alpha> \\<alpha> E L' ?index2)\n                     (drop (ladder_n L' (?index2 - Suc 0))\n                       (take (ladder_n L' ?index2) E))\n                     (ladder_\\<gamma> \\<alpha> E L' ?index2)\n  drop (ladder_n L' (index - Suc 0)) (take (ladder_n L' index) E) =\n  (ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n  drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E)\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_\\<gamma> \\<alpha> E L' index)", "by (metis One_nat_def Suc_le_eq index_bounds)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt \\<alpha> E L' index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  1 \\<le> ?index2 \\<and> ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivationIntrosAt \\<alpha> E L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note LeftDerivationIntrosAt_early = this"], ["proof (state)\nthis:\n  1 \\<le> ?index2 \\<and> ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivationIntrosAt \\<alpha> E L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "{"], ["proof (state)\nthis:\n  1 \\<le> ?index2 \\<and> ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivationIntrosAt \\<alpha> E L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "assume index_bounds: \"1 \\<le> index \\<and> index + 1 = length L\""], ["proof (state)\nthis:\n  1 \\<le> index \\<and> index + 1 = length L\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have introsAt_appendix: \"LeftDerivationIntrosAt (\\<alpha>@\\<delta>) D L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index", "using LDLadder LeftDerivationIntros_def LeftDerivationLadder_def add_lessD1 index_bounds"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationIntros ?a ?D ?L =\n  (\\<forall>index.\n      1 \\<le> index \\<and> index < length ?L \\<longrightarrow>\n      LeftDerivationIntrosAt ?a ?D ?L index)\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  ?i + ?j < ?k \\<Longrightarrow> ?i < ?k\n  1 \\<le> index \\<and> index + 1 = length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index", "by (metis Suc_eq_plus1 not_less_eq)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_i_L_index_eq_fst: \"ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L index = fst (D ! ladder_n L (index - Suc 0))", "using introsAt_appendix LeftDerivationIntrosAt_def index_bounds"], ["proof (prove)\nusing this:\n  LeftDerivationIntrosAt (\\<alpha> @ \\<delta>) D L index\n  LeftDerivationIntrosAt ?a ?D ?L ?index =\n  (let \\<alpha> = ladder_\\<alpha> ?a ?D ?L ?index; i = ladder_i ?L ?index;\n       j = ladder_j ?L ?index; ix = ladder_ix ?L ?index;\n       \\<gamma> = ladder_\\<gamma> ?a ?D ?L ?index;\n       n = ladder_n ?L (?index - 1); m = ladder_n ?L ?index; e = ?D ! n;\n       E = drop (Suc n) (take m ?D)\n   in i = fst e \\<and>\n      LeftDerivationIntro \\<alpha> i (snd e) ix E j \\<gamma>)\n  1 \\<le> index \\<and> index + 1 = length L\n\ngoal (1 subgoal):\n 1. ladder_i L index = fst (D ! ladder_n L (index - Suc 0))", "by (metis One_nat_def)"], ["proof (state)\nthis:\n  ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have E_at_D_at: \"(E ! ladder_n L' (index - Suc 0)) = (D ! ladder_n L (index - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)", "using ladder_early_stage[of \"index - Suc 0\"]"], ["proof (prove)\nusing this:\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (index - Suc 0) =\n  ladder_\\<gamma> \\<alpha> E L' (index - Suc 0) @ \\<delta>\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L (index - Suc 0)) D)\n   (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  take (ladder_n L' (index - Suc 0)) E = take (ladder_n L (index - Suc 0)) D\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  ladder_j L (index - Suc 0)\n  < length (ladder_\\<gamma> \\<alpha> E L' (index - Suc 0))\n  index - Suc 0 + 1 < length L \\<Longrightarrow>\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n\ngoal (1 subgoal):\n 1. E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)", "by (metis One_nat_def Suc_eq_plus1 index_bounds le_add_diff_inverse2 lessI)"], ["proof (state)\nthis:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "then"], ["proof (chain)\npicking this:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)", "have ladder_i_L'_index_eq_fst: \"ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\""], ["proof (prove)\nusing this:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n\ngoal (1 subgoal):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))", "using index_bounds ladder_i_L_index_eq_fst ladder_every_stage(1) le_add1 le_less_trans"], ["proof (prove)\nusing this:\n  E ! ladder_n L' (index - Suc 0) = D ! ladder_n L (index - Suc 0)\n  1 \\<le> index \\<and> index + 1 = length L\n  ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\n  ?index2 < length L \\<Longrightarrow>\n  ladder_i L' ?index2 = ladder_i L ?index2\n  ?n \\<le> ?n + ?m\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))", "by auto"], ["proof (state)\nthis:\n  ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "obtain D' where D': \"D' = (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        D' =\n        drop (Suc (ladder_n L (index - Suc 0)))\n         (take (ladder_n L index) D) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D' = drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "obtain k where k: \"k = (ladder_n L' index) - (Suc (ladder_n L' (index - Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k =\n        ladder_n L' index -\n        Suc (ladder_n L' (index - Suc 0)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k = ladder_n L' index - Suc (ladder_n L' (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_n_L'_index: \"ladder_n L' index = length E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' index = length E", "by (metis diff_add_inverse2 index_bounds ladder_last_n_L' ladder_last_n_def length_L')"], ["proof (state)\nthis:\n  ladder_n L' index = length E\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have take_is_E: \"take (ladder_n L' index) E = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (ladder_n L' index) E = E", "by (simp add: ladder_n_L'_index)"], ["proof (state)\nthis:\n  take (ladder_n L' index) E = E\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_n_L_index: \"ladder_n L index = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L index = length D", "by (metis diff_add_inverse2 index_bounds length_D_eq_n n_eq_ladder_n)"], ["proof (state)\nthis:\n  ladder_n L index = length D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have take_is_D: \"take (ladder_n L index) D = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (ladder_n L index) D = D", "by (simp add: ladder_n_L_index)"], ["proof (state)\nthis:\n  take (ladder_n L index) D = D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have write_as_take_k_D': \"(drop (Suc (ladder_n L' (index - Suc 0))) E) = take k D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L' (index - Suc 0))) E = take k D'", "using take_is_D"], ["proof (prove)\nusing this:\n  take (ladder_n L index) D = D\n\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L' (index - Suc 0))) E = take k D'", "by (metis D' E L' One_nat_def Suc_le_lessD add_diff_cancel_right' diff_Suc_less \n        drop_take index_bounds k ladder_n_L'_index ladder_n_of_cut length_E_eq_n' \n        length_L_nonzero length_greater_0_conv)"], ["proof (state)\nthis:\n  drop (Suc (ladder_n L' (index - Suc 0))) E = take k D'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have k_bound: \"k \\<le> length D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length D'", "by (metis le_iff_add append_take_drop_id k ladder_n_L'_index length_append \n        length_drop write_as_take_k_D')"], ["proof (state)\nthis:\n  k \\<le> length D'\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have D'_alt: \"D' = drop (Suc (ladder_n L (index - Suc 0))) D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D' = drop (Suc (ladder_n L (index - Suc 0))) D", "by (simp add: D' take_is_D)"], ["proof (state)\nthis:\n  D' = drop (Suc (ladder_n L (index - Suc 0))) D\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have \"LeftDerivationIntrosAt \\<alpha> E L' index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> E L' index", "apply (auto simp add: LeftDerivationIntrosAt_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n 2. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index)", "using ladder_i_L'_index_eq_fst"], ["proof (prove)\nusing this:\n  ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n\ngoal (2 subgoals):\n 1. ladder_i L' index = fst (E ! ladder_n L' (index - Suc 0))\n 2. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) E))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index)", "apply (subst take_is_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index) (drop (Suc (ladder_n L' (index - Suc 0))) E)\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> E L' index)", "apply (subst write_as_take_k_D')"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index) (take k D') (ladder_j L' index)\n     (ladder_\\<gamma> \\<alpha> E L' index)", "apply (rule_tac LeftDerivationIntro_cut_appendix[where \\<delta>=\\<delta> and \\<delta>' = \\<delta>'])"], ["proof (prove)\ngoal (6 subgoals):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> E L' index @ \\<delta>)\n     (ladder_i L' index) (snd (E ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index) D' (ladder_j L' index)\n     (ladder_\\<gamma> \\<alpha> E L' index @ \\<delta>')\n 2. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      take k D')\n     (ladder_\\<gamma> \\<alpha> E L' index)\n 3. k \\<le> length D'\n 4. derivation_ge (drop k D') (length (ladder_\\<gamma> \\<alpha> E L' index))\n 5. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 6. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "apply (metis D' Derive E E_at_D_at LeftDerivationIntrosAt_def \n        LeftDerivation_implies_Derivation One_nat_def Suc_le_lessD add_diff_cancel_right' \n        diff_Suc_less finish index_bounds introsAt_appendix ladder_\\<gamma>_def ladder_every_stage(2) \n        ladder_every_stage(3) ladder_every_stage(4) ladder_i_L'_index_eq_fst length_L_nonzero \n        take_is_E)"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivation (ladder_\\<alpha> \\<alpha> E L' index)\n     ((ladder_i L' index, snd (E ! ladder_n L' (index - Suc 0))) #\n      take k D')\n     (ladder_\\<gamma> \\<alpha> E L' index)\n 2. k \\<le> length D'\n 3. derivation_ge (drop k D') (length (ladder_\\<gamma> \\<alpha> E L' index))\n 4. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 5. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "apply (metis Cons_nth_drop_Suc E L' LeftDerivation_from_in_between LeftDerivation_take_derive \n        One_nat_def Suc_le_lessD add_diff_cancel_right' diff_Suc_less finish index_bounds \n        ladder_\\<alpha>_def ladder_\\<gamma>_def ladder_i_L'_index_eq_fst ladder_n_L'_index ladder_n_of_cut \n        ladder_prev_n_def length_E_eq_n' length_L_nonzero less_imp_le_nat less_numeral_extra(3) \n        list.size(3) prod.collapse take_is_E write_as_take_k_D')"], ["proof (prove)\ngoal (4 subgoals):\n 1. k \\<le> length D'\n 2. derivation_ge (drop k D') (length (ladder_\\<gamma> \\<alpha> E L' index))\n 3. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 4. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "using k_bound"], ["proof (prove)\nusing this:\n  k \\<le> length D'\n\ngoal (4 subgoals):\n 1. k \\<le> length D'\n 2. derivation_ge (drop k D') (length (ladder_\\<gamma> \\<alpha> E L' index))\n 3. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 4. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_ge (drop k D') (length (ladder_\\<gamma> \\<alpha> E L' index))\n 2. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 3. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "using D'_alt"], ["proof (prove)\nusing this:\n  D' = drop (Suc (ladder_n L (index - Suc 0))) D\n\ngoal (3 subgoals):\n 1. derivation_ge (drop k D') (length (ladder_\\<gamma> \\<alpha> E L' index))\n 2. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 3. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "apply (metis (no_types, lifting) Derive E L' LeftDerivation_implies_Derivation \n        One_nat_def Suc_leI Suc_le_lessD add_diff_cancel_right' diff_Suc_less drop_drop finish \n        index_bounds k ladder_\\<gamma>_def ladder_n_L'_index ladder_n_of_cut ladder_prev_n_def \n        le_add_diff_inverse2 length_E_eq_n' length_L_nonzero length_greater_0_conv \n        less_not_refl2 take_is_E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 2. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "using index_bounds ladder_every_stage(5)"], ["proof (prove)\nusing this:\n  1 \\<le> index \\<and> index + 1 = length L\n  \\<lbrakk>?index2 < length L; 0 < ?index2\\<rbrakk>\n  \\<Longrightarrow> ladder_i L' ?index2\n                    < length (ladder_\\<alpha> \\<alpha> E L' ?index2)\n\ngoal (2 subgoals):\n 1. ladder_i L' index < length (ladder_\\<alpha> \\<alpha> E L' index)\n 2. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' index < length (ladder_\\<gamma> \\<alpha> E L' index)", "by (metis Derive E LeftDerivation_implies_Derivation One_nat_def add_diff_cancel_right' \n        diff_Suc_less finish index_bounds ladder_\\<gamma>_def ladder_every_stage(2) length_L_nonzero \n        take_is_E)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt \\<alpha> E L' index\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "}"], ["proof (state)\nthis:\n  1 \\<le> ?index2 \\<and> ?index2 + 1 = length L \\<Longrightarrow>\n  LeftDerivationIntrosAt \\<alpha> E L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "note LeftDerivationIntrosAt_last = this"], ["proof (state)\nthis:\n  1 \\<le> ?index2 \\<and> ?index2 + 1 = length L \\<Longrightarrow>\n  LeftDerivationIntrosAt \\<alpha> E L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "have ladder_E_L': \"LeftDerivationLadder \\<alpha> E L' \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationLadder \\<alpha> E L' \\<beta>", "apply (auto simp add: LeftDerivationLadder_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivation \\<alpha> E \\<beta>\n 2. is_ladder E L'\n 3. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 4. LeftDerivationIntros \\<alpha> E L'", "using finish E"], ["proof (prove)\nusing this:\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n  E = take n' D\n\ngoal (4 subgoals):\n 1. LeftDerivation \\<alpha> E \\<beta>\n 2. is_ladder E L'\n 3. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 4. LeftDerivationIntros \\<alpha> E L'", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_ladder E L'\n 2. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 3. LeftDerivationIntros \\<alpha> E L'", "using is_ladder_E_L'"], ["proof (prove)\nusing this:\n  is_ladder E L'\n\ngoal (3 subgoals):\n 1. is_ladder E L'\n 2. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 3. LeftDerivationIntros \\<alpha> E L'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. LeftDerivationIntros \\<alpha> E L'", "using LeftDerivationFix_\\<alpha>_0"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n\ngoal (2 subgoals):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) E)\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> E L' 0)\n 2. LeftDerivationIntros \\<alpha> E L'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntros \\<alpha> E L'", "using LeftDerivationIntros_def LeftDerivationIntrosAt_early LeftDerivationIntrosAt_last"], ["proof (prove)\nusing this:\n  LeftDerivationIntros ?a ?D ?L =\n  (\\<forall>index.\n      1 \\<le> index \\<and> index < length ?L \\<longrightarrow>\n      LeftDerivationIntrosAt ?a ?D ?L index)\n  1 \\<le> ?index2 \\<and> ?index2 + 1 < length L \\<Longrightarrow>\n  LeftDerivationIntrosAt \\<alpha> E L' ?index2\n  1 \\<le> ?index2 \\<and> ?index2 + 1 = length L \\<Longrightarrow>\n  LeftDerivationIntrosAt \\<alpha> E L' ?index2\n\ngoal (1 subgoal):\n 1. LeftDerivationIntros \\<alpha> E L'", "by (metis Suc_eq_plus1 Suc_leI le_neq_implies_less length_L')"], ["proof (state)\nthis:\n  LeftDerivationLadder \\<alpha> E L' \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "apply (rule_tac x=E in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "apply (rule_tac x=F in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "apply (rule_tac x=\\<beta> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<beta> @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<beta> \\<and>\n       derivation_ge F (length \\<beta>) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n        \\<gamma>2 \\<and>\n       L' = ladder_cut L (length E)", "apply (rule_tac x=\\<delta>' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<beta> @ \\<delta>' \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<beta> \\<and>\n       derivation_ge F (length \\<beta>) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       L' = ladder_cut L (length E)", "apply (rule_tac x=L' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = E @ F \\<and>\n    \\<gamma> = \\<beta> @ \\<delta>' \\<and>\n    LeftDerivationLadder \\<alpha> E L' \\<beta> \\<and>\n    derivation_ge F (length \\<beta>) \\<and>\n    LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>' \\<and>\n    L' = ladder_cut L (length E)", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. D = E @ F\n 2. \\<gamma> = \\<beta> @ \\<delta>'\n 3. LeftDerivationLadder \\<alpha> E L' \\<beta>\n 4. derivation_ge F (length \\<beta>)\n 5. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 6. L' = ladder_cut L (length E)", "using E F"], ["proof (prove)\nusing this:\n  E = take n' D\n  F = drop n' D\n\ngoal (6 subgoals):\n 1. D = E @ F\n 2. \\<gamma> = \\<beta> @ \\<delta>'\n 3. LeftDerivationLadder \\<alpha> E L' \\<beta>\n 4. derivation_ge F (length \\<beta>)\n 5. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 6. L' = ladder_cut L (length E)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<gamma> = \\<beta> @ \\<delta>'\n 2. LeftDerivationLadder \\<alpha> E L' \\<beta>\n 3. derivation_ge F (length \\<beta>)\n 4. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 5. L' = ladder_cut L (length E)", "apply (rule \\<gamma>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivationLadder \\<alpha> E L' \\<beta>\n 2. derivation_ge F (length \\<beta>)\n 3. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 4. L' = ladder_cut L (length E)", "using ladder_E_L'"], ["proof (prove)\nusing this:\n  LeftDerivationLadder \\<alpha> E L' \\<beta>\n\ngoal (4 subgoals):\n 1. LeftDerivationLadder \\<alpha> E L' \\<beta>\n 2. derivation_ge F (length \\<beta>)\n 3. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 4. L' = ladder_cut L (length E)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_ge F (length \\<beta>)\n 2. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 3. L' = ladder_cut L (length E)", "using F finish"], ["proof (prove)\nusing this:\n  F = drop n' D\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n\ngoal (3 subgoals):\n 1. derivation_ge F (length \\<beta>)\n 2. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 3. L' = ladder_cut L (length E)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 2. L' = ladder_cut L (length E)", "using F finish"], ["proof (prove)\nusing this:\n  F = drop n' D\n  (length L - 1 = 0 \\<or> ladder_prev_n L (length L - 1) < n') \\<and>\n  n' \\<le> n \\<and>\n  LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n  LeftDerivation (\\<alpha> @ \\<delta>) (take n' D)\n   (\\<beta> @ \\<delta>) \\<and>\n  derivation_ge (drop n' D) (length \\<beta>) \\<and>\n  LeftDerivation \\<delta> (derivation_shift (drop n' D) (length \\<beta>) 0)\n   \\<delta>' \\<and>\n  ladder_\\<gamma> (\\<alpha> @ \\<delta>) D L (length L - 1) =\n  \\<beta> @ \\<delta>' \\<and>\n  ladder_j L (length L - 1) < length \\<beta>\n\ngoal (2 subgoals):\n 1. LeftDerivation \\<delta> (derivation_shift F (length \\<beta>) 0)\n     \\<delta>'\n 2. L' = ladder_cut L (length E)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. L' = ladder_cut L (length E)", "by (rule L')"], ["proof (state)\nthis:\n  \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n     D = E @ F \\<and>\n     \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n     LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n     derivation_ge F (length \\<gamma>1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n      \\<gamma>2 \\<and>\n     L' = ladder_cut L (length E)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem LeftDerivationLadder_cut_appendix: \n  assumes LDLadder: \"LeftDerivationLadder (\\<alpha>@\\<delta>) D L \\<gamma>\"\n  assumes ladder_i_in_\\<alpha>: \"ladder_i L 0 < length \\<alpha>\"\n  shows \"\\<exists> E F \\<gamma>1 \\<gamma>2 L'. D = E@F \\<and> \n    \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and> \n    LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and> \n    derivation_ge F (length \\<gamma>1) \\<and>\n    LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0) \\<gamma>2 \\<and>\n    length L' = length L \\<and> ladder_i L' 0 = ladder_i L 0 \\<and>\n    ladder_last_j L' = ladder_last_j L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "from LeftDerivationLadder_cut_appendix_helper[OF LDLadder ladder_i_in_\\<alpha>]"], ["proof (chain)\npicking this:\n  \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n     D = E @ F \\<and>\n     \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n     LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n     derivation_ge F (length \\<gamma>1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n      \\<gamma>2 \\<and>\n     L' = ladder_cut L (length E)", "obtain E F \\<gamma>1 \\<gamma>2 L' where helper:\n    \"D = E @ F \\<and>\n     \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n     LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n     derivation_ge F (length \\<gamma>1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0) \\<gamma>2 \\<and> L' = ladder_cut L (length E)\""], ["proof (prove)\nusing this:\n  \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n     D = E @ F \\<and>\n     \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n     LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n     derivation_ge F (length \\<gamma>1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n      \\<gamma>2 \\<and>\n     L' = ladder_cut L (length E)\n\ngoal (1 subgoal):\n 1. (\\<And>E F \\<gamma>1 \\<gamma>2 L'.\n        D = E @ F \\<and>\n        \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n        LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n        derivation_ge F (length \\<gamma>1) \\<and>\n        LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n         \\<gamma>2 \\<and>\n        L' = ladder_cut L (length E) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D = E @ F \\<and>\n  \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n  LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n  derivation_ge F (length \\<gamma>1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n   \\<gamma>2 \\<and>\n  L' = ladder_cut L (length E)\n\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "apply (rule_tac x=E in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F \\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "apply (rule_tac x=F in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>1 \\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "apply (rule_tac x=\\<gamma>1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>2 L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "apply (rule_tac x=\\<gamma>2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       D = E @ F \\<and>\n       \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n       LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n       derivation_ge F (length \\<gamma>1) \\<and>\n       LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n        \\<gamma>2 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 = ladder_i L 0 \\<and>\n       ladder_last_j L' = ladder_last_j L", "apply (rule_tac x=L' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = E @ F \\<and>\n    \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n    LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n    derivation_ge F (length \\<gamma>1) \\<and>\n    LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n     \\<gamma>2 \\<and>\n    length L' = length L \\<and>\n    ladder_i L' 0 = ladder_i L 0 \\<and> ladder_last_j L' = ladder_last_j L", "using helper LDLadder LeftDerivationLadder_def is_ladder_def ladder_i_of_cut_at_0 \n      ladder_last_j_of_cut length_ladder_cut"], ["proof (prove)\nusing this:\n  D = E @ F \\<and>\n  \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n  LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n  derivation_ge F (length \\<gamma>1) \\<and>\n  LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n   \\<gamma>2 \\<and>\n  L' = ladder_cut L (length E)\n  LeftDerivationLadder (\\<alpha> @ \\<delta>) D L \\<gamma>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  ?L \\<noteq> [] \\<Longrightarrow>\n  ladder_i (ladder_cut ?L ?n) 0 = ladder_i ?L 0\n  ?L \\<noteq> [] \\<Longrightarrow>\n  ladder_last_j (ladder_cut ?L ?n) = ladder_last_j ?L\n  ?L \\<noteq> [] \\<Longrightarrow> length (ladder_cut ?L ?n) = length ?L\n\ngoal (1 subgoal):\n 1. D = E @ F \\<and>\n    \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n    LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n    derivation_ge F (length \\<gamma>1) \\<and>\n    LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n     \\<gamma>2 \\<and>\n    length L' = length L \\<and>\n    ladder_i L' 0 = ladder_i L 0 \\<and> ladder_last_j L' = ladder_last_j L", "by force"], ["proof (state)\nthis:\n  \\<exists>E F \\<gamma>1 \\<gamma>2 L'.\n     D = E @ F \\<and>\n     \\<gamma> = \\<gamma>1 @ \\<gamma>2 \\<and>\n     LeftDerivationLadder \\<alpha> E L' \\<gamma>1 \\<and>\n     derivation_ge F (length \\<gamma>1) \\<and>\n     LeftDerivation \\<delta> (derivation_shift F (length \\<gamma>1) 0)\n      \\<gamma>2 \\<and>\n     length L' = length L \\<and>\n     ladder_i L' 0 = ladder_i L 0 \\<and> ladder_last_j L' = ladder_last_j L\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ladder_stepdown_diff :: \"ladder \\<Rightarrow> nat\" where\n  \"ladder_stepdown_diff L = Suc (ladder_n L 0)\""], ["", "definition ladder_stepdown_\\<alpha>_0 :: \"sentence \\<Rightarrow> derivation \\<Rightarrow> ladder \\<Rightarrow> sentence\" where\n  \"ladder_stepdown_\\<alpha>_0 a D L = Derive a (take (ladder_stepdown_diff L) D)\""], ["", "lemma LeftDerivationIntro_LeftDerives1:\n  assumes \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma>\"\n  assumes \"splits_at \\<alpha> i a1 A a2\"\n  shows \"LeftDerives1 \\<alpha> i r (a1@(snd r)@a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> i r (a1 @ snd r @ a2)", "by (metis LeftDerivationIntro_def LeftDerivationIntro_examine_rule LeftDerivationIntro_is_sentence \n  LeftDerives1_def assms(1) assms(2) prod.collapse splits_at_implies_Derives1)"], ["", "lemma LeftDerives1_Derive:\n  assumes \"LeftDerives1 \\<alpha> i r \\<gamma>\"\n  shows \"Derive \\<alpha> [(i, r)] = \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive \\<alpha> [(i, r)] = \\<gamma>", "by (metis Derive LeftDerivation.simps(1) LeftDerivation_LeftDerives1 \n  LeftDerivation_implies_Derivation append_Nil assms)"], ["", "lemma ladder_stepdown_\\<alpha>_0_altdef:\n  assumes ladder: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes length_L: \"length L > 1\"\n  assumes split: \"splits_at (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) a1 A a2\"\n  shows \"ladder_stepdown_\\<alpha>_0 \\<alpha> D L = a1 @ (snd (snd (D ! (ladder_n L 0)))) @ a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "have 1: \"ladder_\\<alpha> \\<alpha> D L 1 = Derive \\<alpha> (take (ladder_n L 0) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<alpha> \\<alpha> D L 1 = Derive \\<alpha> (take (ladder_n L 0) D)", "by (simp add: ladder_\\<alpha>_def ladder_\\<gamma>_def)"], ["proof (state)\nthis:\n  ladder_\\<alpha> \\<alpha> D L 1 = Derive \\<alpha> (take (ladder_n L 0) D)\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "obtain rule  where rule: \"rule = snd (D ! (ladder_n L 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rule.\n        rule = snd (D ! ladder_n L 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rule = snd (D ! ladder_n L 0)\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "have \"\\<exists> E \\<omega>. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule (ladder_ix L 1)\n    E (ladder_j L 1) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E \\<omega>.\n       LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n        rule (ladder_ix L 1) E (ladder_j L 1) \\<omega>", "by (metis LeftDerivationIntrosAt_def LeftDerivationIntros_def LeftDerivationLadder_def \n      One_nat_def diff_Suc_1 ladder length_L order_refl rule)"], ["proof (state)\nthis:\n  \\<exists>E \\<omega>.\n     LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n      rule (ladder_ix L 1) E (ladder_j L 1) \\<omega>\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "then"], ["proof (chain)\npicking this:\n  \\<exists>E \\<omega>.\n     LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n      rule (ladder_ix L 1) E (ladder_j L 1) \\<omega>", "obtain E \\<omega> where intro: \n    \"LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule (ladder_ix L 1) E (ladder_j L 1) \\<omega>\""], ["proof (prove)\nusing this:\n  \\<exists>E \\<omega>.\n     LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n      rule (ladder_ix L 1) E (ladder_j L 1) \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<And>E \\<omega>.\n        LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n         rule (ladder_ix L 1) E (ladder_j L 1) \\<omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n   (ladder_ix L 1) E (ladder_j L 1) \\<omega>\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "then"], ["proof (chain)\npicking this:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n   (ladder_ix L 1) E (ladder_j L 1) \\<omega>", "have 2: \"LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule (a1@(snd rule)@a2)\""], ["proof (prove)\nusing this:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n   (ladder_ix L 1) E (ladder_j L 1) \\<omega>\n\ngoal (1 subgoal):\n 1. LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n     (a1 @ snd rule @ a2)", "using LeftDerivationIntro_LeftDerives1 split"], ["proof (prove)\nusing this:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n   (ladder_ix L 1) E (ladder_j L 1) \\<omega>\n  \\<lbrakk>LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<gamma>;\n   splits_at ?\\<alpha> ?i ?a1.0 ?A ?a2.0\\<rbrakk>\n  \\<Longrightarrow> LeftDerives1 ?\\<alpha> ?i ?r (?a1.0 @ snd ?r @ ?a2.0)\n  splits_at (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) a1 A a2\n\ngoal (1 subgoal):\n 1. LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n     (a1 @ snd rule @ a2)", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n   (a1 @ snd rule @ a2)\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "have fst_D: \"fst (D ! (ladder_n L 0)) = ladder_i L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (D ! ladder_n L 0) = ladder_i L 1", "by (metis LeftDerivationIntrosAt_def LeftDerivationIntros_def LeftDerivationLadder_def \n      One_nat_def diff_Suc_1 ladder le_numeral_extra(4) length_L)"], ["proof (state)\nthis:\n  fst (D ! ladder_n L 0) = ladder_i L 1\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "have derive_derive: \"Derive \\<alpha> (take (Suc (ladder_n L 0)) D) = \n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! (ladder_n L 0)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "have f1: \"Derivation \\<alpha> (take (Suc (ladder_n L 0)) D) (Derive \\<alpha> (take (Suc (ladder_n L 0)) D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derivation \\<alpha> (take (Suc (ladder_n L 0)) D)\n     (Derive \\<alpha> (take (Suc (ladder_n L 0)) D))", "using Derivation_take_derive LeftDerivationLadder_def LeftDerivation_implies_Derivation ladder"], ["proof (prove)\nusing this:\n  Derivation ?a ?D ?b \\<Longrightarrow>\n  Derivation ?a (take ?n ?D) (Derive ?a (take ?n ?D))\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n\ngoal (1 subgoal):\n 1. Derivation \\<alpha> (take (Suc (ladder_n L 0)) D)\n     (Derive \\<alpha> (take (Suc (ladder_n L 0)) D))", "by blast"], ["proof (state)\nthis:\n  Derivation \\<alpha> (take (Suc (ladder_n L 0)) D)\n   (Derive \\<alpha> (take (Suc (ladder_n L 0)) D))\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "have f2: \"length L - 1 < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L - 1 < length L", "using length_L"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (1 subgoal):\n 1. length L - 1 < length L", "by linarith"], ["proof (state)\nthis:\n  length L - 1 < length L\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "have \"0 < length L - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length L - 1", "using length_L"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (1 subgoal):\n 1. 0 < length L - 1", "by linarith"], ["proof (state)\nthis:\n  0 < length L - 1\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "then"], ["proof (chain)\npicking this:\n  0 < length L - 1", "have f3: \"take (Suc (ladder_n L 0)) D = take (ladder_n L 0) D @ [D ! ladder_n L 0]\""], ["proof (prove)\nusing this:\n  0 < length L - 1\n\ngoal (1 subgoal):\n 1. take (Suc (ladder_n L 0)) D = take (ladder_n L 0) D @ [D ! ladder_n L 0]", "using f2"], ["proof (prove)\nusing this:\n  0 < length L - 1\n  length L - 1 < length L\n\ngoal (1 subgoal):\n 1. take (Suc (ladder_n L 0)) D = take (ladder_n L 0) D @ [D ! ladder_n L 0]", "by (metis (full_types) LeftDerivationLadder_def is_ladder_def ladder ladder_last_n_def take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take (Suc (ladder_n L 0)) D = take (ladder_n L 0) D @ [D ! ladder_n L 0]\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "obtain sss :: \"symbol list \\<Rightarrow> (nat \\<times> symbol \\<times> symbol list) list \\<Rightarrow> (nat \\<times> symbol \\<times> symbol list) list \\<Rightarrow> symbol list \\<Rightarrow> symbol list\" where\n        \"\\<forall>x0 x1 x2 x3. (\\<exists>v4. Derivation x3 x2 v4 \\<and> Derivation v4 x1 x0) = (Derivation x3 x2 (sss x0 x1 x2 x3) \\<and> Derivation (sss x0 x1 x2 x3) x1 x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sss.\n        \\<forall>x0 x1 x2 x3.\n           (\\<exists>v4. Derivation x3 x2 v4 \\<and> Derivation v4 x1 x0) =\n           (Derivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n            Derivation (sss x0 x1 x2 x3) x1 x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. Derivation x3 x2 v4 \\<and> Derivation v4 x1 x0) =\n     (Derivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      Derivation (sss x0 x1 x2 x3) x1 x0)\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. Derivation x3 x2 v4 \\<and> Derivation v4 x1 x0) =\n     (Derivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      Derivation (sss x0 x1 x2 x3) x1 x0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. Derivation x3 x2 v4 \\<and> Derivation v4 x1 x0) =\n     (Derivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      Derivation (sss x0 x1 x2 x3) x1 x0)\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "using f3 f1 Derivation_append Derive"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. Derivation x3 x2 v4 \\<and> Derivation v4 x1 x0) =\n     (Derivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      Derivation (sss x0 x1 x2 x3) x1 x0)\n  take (Suc (ladder_n L 0)) D = take (ladder_n L 0) D @ [D ! ladder_n L 0]\n  Derivation \\<alpha> (take (Suc (ladder_n L 0)) D)\n   (Derive \\<alpha> (take (Suc (ladder_n L 0)) D))\n  Derivation ?a (?D @ ?E) ?c =\n  (\\<exists>b. Derivation ?a ?D b \\<and> Derivation b ?E ?c)\n  Derivation ?a ?D ?b \\<Longrightarrow> Derive ?a ?D = ?b\n\ngoal (1 subgoal):\n 1. Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n    Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "by auto"], ["proof (state)\nthis:\n  Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n  Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n  Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "then"], ["proof (chain)\npicking this:\n  Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n  Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]", "have 3: \"ladder_stepdown_\\<alpha>_0 \\<alpha> D L = Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! (ladder_n L 0)]\""], ["proof (prove)\nusing this:\n  Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n  Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! ladder_n L 0]", "using 1"], ["proof (prove)\nusing this:\n  Derive \\<alpha> (take (Suc (ladder_n L 0)) D) =\n  Derive (Derive \\<alpha> (take (ladder_n L 0) D)) [D ! ladder_n L 0]\n  ladder_\\<alpha> \\<alpha> D L 1 = Derive \\<alpha> (take (ladder_n L 0) D)\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! ladder_n L 0]", "by (simp add: ladder_stepdown_\\<alpha>_0_def ladder_stepdown_diff_def)"], ["proof (state)\nthis:\n  ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n  Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! ladder_n L 0]\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "have 4: \"D ! (ladder_n L 0) = (ladder_i L 1, rule)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D ! ladder_n L 0 = (ladder_i L 1, rule)", "using rule fst_D"], ["proof (prove)\nusing this:\n  rule = snd (D ! ladder_n L 0)\n  fst (D ! ladder_n L 0) = ladder_i L 1\n\ngoal (1 subgoal):\n 1. D ! ladder_n L 0 = (ladder_i L 1, rule)", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  D ! ladder_n L 0 = (ladder_i L 1, rule)\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "then"], ["proof (chain)\npicking this:\n  D ! ladder_n L 0 = (ladder_i L 1, rule)", "show ?thesis"], ["proof (prove)\nusing this:\n  D ! ladder_n L 0 = (ladder_i L 1, rule)\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "using 2 3 4 LeftDerives1_Derive snd_conv"], ["proof (prove)\nusing this:\n  D ! ladder_n L 0 = (ladder_i L 1, rule)\n  LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) rule\n   (a1 @ snd rule @ a2)\n  ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n  Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! ladder_n L 0]\n  D ! ladder_n L 0 = (ladder_i L 1, rule)\n  LeftDerives1 ?\\<alpha> ?i ?r ?\\<gamma> \\<Longrightarrow>\n  Derive ?\\<alpha> [(?i, ?r)] = ?\\<gamma>\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    a1 @ snd (snd (D ! ladder_n L 0)) @ a2", "by auto"], ["proof (state)\nthis:\n  ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n  a1 @ snd (snd (D ! ladder_n L 0)) @ a2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_i_0_bound:\n  assumes ld: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  shows \"ladder_i L 0 < length \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L 0 < length \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_i L 0 < length \\<alpha>", "have \"LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D) \n    (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n     (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)", "using ld LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n     (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)", "by simp"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)\n\ngoal (1 subgoal):\n 1. ladder_i L 0 < length \\<alpha>", "then"], ["proof (chain)\npicking this:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)\n\ngoal (1 subgoal):\n 1. ladder_i L 0 < length \\<alpha>", "using LeftDerivationFix_def"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n\ngoal (1 subgoal):\n 1. ladder_i L 0 < length \\<alpha>", "by simp"], ["proof (state)\nthis:\n  ladder_i L 0 < length \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_j_bound:\n  assumes ld: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes index_bound: \"index < length L\"\n  shows \"ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "have ld': \"LeftDerivationLadder (\\<alpha>@[]) D L \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationLadder (\\<alpha> @ []) D L \\<gamma>", "using ld"], ["proof (prove)\nusing this:\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerivationLadder (\\<alpha> @ []) D L \\<gamma>", "by simp"], ["proof (state)\nthis:\n  LeftDerivationLadder (\\<alpha> @ []) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "have ladder_i_0: \"ladder_i L 0 < length \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L 0 < length \\<alpha>", "using ladder_i_0_bound ld"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?\\<alpha> ?D ?L ?\\<gamma> \\<Longrightarrow>\n  ladder_i ?L 0 < length ?\\<alpha>\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n\ngoal (1 subgoal):\n 1. ladder_i L 0 < length \\<alpha>", "by auto"], ["proof (state)\nthis:\n  ladder_i L 0 < length \\<alpha>\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "obtain n where n: \"n = ladder_n L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n = ladder_n L index \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = ladder_n L index\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "note propagate = LeftDerivationLadder_propagate[OF ld' ladder_i_0 n index_bound]"], ["proof (state)\nthis:\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation []\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ []) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "from index_bound"], ["proof (chain)\npicking this:\n  index < length L", "have \"index + 1 < length L \\<or> index + 1 = length L\""], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (1 subgoal):\n 1. index + 1 < length L \\<or> index + 1 = length L", "by arith"], ["proof (state)\nthis:\n  index + 1 < length L \\<or> index + 1 = length L\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "then"], ["proof (chain)\npicking this:\n  index + 1 < length L \\<or> index + 1 = length L", "show ?thesis"], ["proof (prove)\nusing this:\n  index + 1 < length L \\<or> index + 1 = length L\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. index + 1 < length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\n 2. index + 1 = length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "case 1"], ["proof (state)\nthis:\n  index + 1 < length L\n\ngoal (2 subgoals):\n 1. index + 1 < length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\n 2. index + 1 = length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "then"], ["proof (chain)\npicking this:\n  index + 1 < length L", "have \"\\<exists>\\<beta>. LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n         ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and> ladder_j L index < length \\<beta>\""], ["proof (prove)\nusing this:\n  index + 1 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n       ladder_j L index < length \\<beta>", "using propagate"], ["proof (prove)\nusing this:\n  index + 1 < length L\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation []\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ []) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n       ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n       ladder_j L index < length \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<beta>.\n     LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n     ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n     ladder_j L index < length \\<beta>\n\ngoal (2 subgoals):\n 1. index + 1 < length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\n 2. index + 1 = length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n     ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n     ladder_j L index < length \\<beta>", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n     ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n     ladder_j L index < length \\<beta>\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "by auto"], ["proof (state)\nthis:\n  ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\n\ngoal (1 subgoal):\n 1. index + 1 = length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. index + 1 = length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "case 2"], ["proof (state)\nthis:\n  index + 1 = length L\n\ngoal (1 subgoal):\n 1. index + 1 = length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "then"], ["proof (chain)\npicking this:\n  index + 1 = length L", "have \"\n        \\<exists>n' \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation [] (derivation_shift (drop n' D) (length \\<beta>) 0) \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ \\<delta>' \\<and> ladder_j L index < length \\<beta>\""], ["proof (prove)\nusing this:\n  index + 1 = length L\n\ngoal (1 subgoal):\n 1. \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation [] (derivation_shift (drop n' D) (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ []) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>", "using propagate"], ["proof (prove)\nusing this:\n  index + 1 = length L\n  if index + 1 < length L\n  then \\<exists>\\<beta>.\n          LeftDerivation \\<alpha> (take n D) \\<beta> \\<and>\n          ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ [] \\<and>\n          ladder_j L index < length \\<beta>\n  else \\<exists>n' \\<beta> \\<delta>'.\n          (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n          n' \\<le> n \\<and>\n          LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n          LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n          derivation_ge (drop n' D) (length \\<beta>) \\<and>\n          LeftDerivation []\n           (derivation_shift (drop n' D) (length \\<beta>) 0)\n           \\<delta>' \\<and>\n          ladder_\\<gamma> (\\<alpha> @ []) D L index =\n          \\<beta> @ \\<delta>' \\<and>\n          ladder_j L index < length \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>n' \\<beta> \\<delta>'.\n       (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n       n' \\<le> n \\<and>\n       LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n       LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n       derivation_ge (drop n' D) (length \\<beta>) \\<and>\n       LeftDerivation [] (derivation_shift (drop n' D) (length \\<beta>) 0)\n        \\<delta>' \\<and>\n       ladder_\\<gamma> (\\<alpha> @ []) D L index =\n       \\<beta> @ \\<delta>' \\<and>\n       ladder_j L index < length \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<exists>n' \\<beta> \\<delta>'.\n     (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n     n' \\<le> n \\<and>\n     LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n     LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n     derivation_ge (drop n' D) (length \\<beta>) \\<and>\n     LeftDerivation [] (derivation_shift (drop n' D) (length \\<beta>) 0)\n      \\<delta>' \\<and>\n     ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ \\<delta>' \\<and>\n     ladder_j L index < length \\<beta>\n\ngoal (1 subgoal):\n 1. index + 1 = length L \\<Longrightarrow>\n    ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n' \\<beta> \\<delta>'.\n     (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n     n' \\<le> n \\<and>\n     LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n     LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n     derivation_ge (drop n' D) (length \\<beta>) \\<and>\n     LeftDerivation [] (derivation_shift (drop n' D) (length \\<beta>) 0)\n      \\<delta>' \\<and>\n     ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ \\<delta>' \\<and>\n     ladder_j L index < length \\<beta>", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>n' \\<beta> \\<delta>'.\n     (index = 0 \\<or> ladder_prev_n L index < n') \\<and>\n     n' \\<le> n \\<and>\n     LeftDerivation \\<alpha> (take n' D) \\<beta> \\<and>\n     LeftDerivation (\\<alpha> @ []) (take n' D) (\\<beta> @ []) \\<and>\n     derivation_ge (drop n' D) (length \\<beta>) \\<and>\n     LeftDerivation [] (derivation_shift (drop n' D) (length \\<beta>) 0)\n      \\<delta>' \\<and>\n     ladder_\\<gamma> (\\<alpha> @ []) D L index = \\<beta> @ \\<delta>' \\<and>\n     ladder_j L index < length \\<beta>\n\ngoal (1 subgoal):\n 1. ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)", "by auto"], ["proof (state)\nthis:\n  ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_j L index < length (ladder_\\<gamma> \\<alpha> D L index)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_last_j_bound:\n  assumes ld: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  shows \"ladder_last_j L < length \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_j L < length \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_last_j L < length \\<gamma>", "have \"length L - 1 < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L - 1 < length L", "using LeftDerivationLadder_def assms is_ladder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n\ngoal (1 subgoal):\n 1. length L - 1 < length L", "by auto"], ["proof (state)\nthis:\n  length L - 1 < length L\n\ngoal (1 subgoal):\n 1. ladder_last_j L < length \\<gamma>", "from ladder_j_bound[OF ld this]"], ["proof (chain)\npicking this:\n  ladder_j L (length L - 1)\n  < length (ladder_\\<gamma> \\<alpha> D L (length L - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  ladder_j L (length L - 1)\n  < length (ladder_\\<gamma> \\<alpha> D L (length L - 1))\n\ngoal (1 subgoal):\n 1. ladder_last_j L < length \\<gamma>", "by (metis Derive LeftDerivationLadder_def LeftDerivation_implies_Derivation One_nat_def \n      is_ladder_def ladder_last_j_def last_ladder_\\<gamma> ld)"], ["proof (state)\nthis:\n  ladder_last_j L < length \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "fun ladder_shift_n :: \"nat \\<Rightarrow> ladder \\<Rightarrow> ladder\" where \n  \"ladder_shift_n N [] = []\"\n| \"ladder_shift_n N ((n, j, i)#L) = ((n - N, j, i)#(ladder_shift_n N L))\""], ["", "fun ladder_stepdown :: \"ladder \\<Rightarrow> ladder\"\nwhere \n  \"ladder_stepdown [] = undefined\"\n| \"ladder_stepdown [v] = undefined\"\n| \"ladder_stepdown ((n0, j0, i0)#(n1, j1, ix1)#L) = \n  (n1 - Suc n0, j1, j0 + ix1) # (ladder_shift_n (Suc n0) L)\""], ["", "lemma ladder_shift_n_length: \n  \"length (ladder_shift_n N L) = length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ladder_shift_n N L) = length L", "by (induct L, auto)"], ["", "lemma ladder_stepdown_prepare:\n  assumes \"length L > 1\"\n  shows \"L = (ladder_n L 0, ladder_j L 0, ladder_i L 0)#\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1)#(drop 2 L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L =\n    (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L =\n    (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L", "have \"\\<exists> n0 j0 i0 n1 j1 ix1 L'. L = ((n0, j0, i0)#(n1, j1, ix1)#L')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n0 j0 i0 n1 j1 ix1 L'. L = (n0, j0, i0) # (n1, j1, ix1) # L'", "by (metis One_nat_def Suc_eq_plus1 assms ladder_stepdown.cases less_not_refl list.size(3) \n      list.size(4) not_less0)"], ["proof (state)\nthis:\n  \\<exists>n0 j0 i0 n1 j1 ix1 L'. L = (n0, j0, i0) # (n1, j1, ix1) # L'\n\ngoal (1 subgoal):\n 1. L =\n    (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L", "then"], ["proof (chain)\npicking this:\n  \\<exists>n0 j0 i0 n1 j1 ix1 L'. L = (n0, j0, i0) # (n1, j1, ix1) # L'", "obtain n0 j0 i0 n1 j1 ix1 L' where L': \"L = ((n0, j0, i0)#(n1, j1, ix1)#L')\""], ["proof (prove)\nusing this:\n  \\<exists>n0 j0 i0 n1 j1 ix1 L'. L = (n0, j0, i0) # (n1, j1, ix1) # L'\n\ngoal (1 subgoal):\n 1. (\\<And>n0 j0 i0 n1 j1 ix1 L'.\n        L = (n0, j0, i0) # (n1, j1, ix1) # L' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L = (n0, j0, i0) # (n1, j1, ix1) # L'\n\ngoal (1 subgoal):\n 1. L =\n    (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L", "have n0: \"n0 = ladder_n L 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n0 = ladder_n L 0", "using L'"], ["proof (prove)\nusing this:\n  L = (n0, j0, i0) # (n1, j1, ix1) # L'\n\ngoal (1 subgoal):\n 1. n0 = ladder_n L 0", "by (auto simp add: ladder_n_def deriv_n_def)"], ["proof (state)\nthis:\n  n0 = ladder_n L 0\n\ngoal (1 subgoal):\n 1. L =\n    (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. L =\n    (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L", "using L'"], ["proof (prove)\nusing this:\n  L = (n0, j0, i0) # (n1, j1, ix1) # L'\n\ngoal (1 subgoal):\n 1. L =\n    (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n    (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L", "by (auto simp add: ladder_n_def deriv_n_def ladder_j_def deriv_j_def \n      ladder_i_def deriv_i_def ladder_ix_def deriv_ix_def)"], ["proof (state)\nthis:\n  L =\n  (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n  (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_stepdown_length:\n  assumes \"length L > 1\"\n  shows \"length (ladder_stepdown L) = length L - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ladder_stepdown L) = length L - 1", "apply (subst ladder_stepdown_prepare[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (ladder_stepdown\n       ((ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n        (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L)) =\n    length L - 1", "apply (simp add: ladder_shift_n_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length L - 2) = length L - Suc 0", "using assms"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (1 subgoal):\n 1. Suc (length L - 2) = length L - Suc 0", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ladder_stepdown_i_0:\n  assumes \"length L > 1\"\n  shows \"ladder_i (ladder_stepdown L) 0 = ladder_i L 1 + ladder_ix L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i (ladder_stepdown L) 0 = ladder_i L 1 + ladder_ix L 1", "using ladder_stepdown_prepare[OF assms] ladder_i_def ladder_j_def deriv_j_def"], ["proof (prove)\nusing this:\n  L =\n  (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n  (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L\n  ladder_i ?L ?index =\n  (if ?index = 0 then deriv_i (hd ?L) else ladder_j ?L (?index - 1))\n  ladder_j ?L ?index = deriv_j (?L ! ?index)\n  deriv_j ?d = fst (snd ?d)\n\ngoal (1 subgoal):\n 1. ladder_i (ladder_stepdown L) 0 = ladder_i L 1 + ladder_ix L 1", "by (metis One_nat_def deriv_i_def diff_Suc_1 ladder_stepdown.simps(3) list.sel(1) \n    snd_conv zero_neq_one)"], ["", "lemma ladder_shift_n_cons: \"ladder_shift_n N (x#L) = (fst x - N, snd x)#(ladder_shift_n N L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_shift_n N (x # L) = (fst x - N, snd x) # ladder_shift_n N L", "apply (induct L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_shift_n N [x] = (fst x - N, snd x) # ladder_shift_n N []\n 2. \\<And>a L.\n       ladder_shift_n N (x # L) =\n       (fst x - N, snd x) # ladder_shift_n N L \\<Longrightarrow>\n       ladder_shift_n N (x # a # L) =\n       (fst x - N, snd x) # ladder_shift_n N (a # L)", "by (cases x, simp)+"], ["", "lemma ladder_shift_n_drop: \"ladder_shift_n N (drop n L) = drop n (ladder_shift_n N L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_shift_n N (drop n L) = drop n (ladder_shift_n N L)", "proof (induct L arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. ladder_shift_n N (drop n []) = drop n (ladder_shift_n N [])\n 2. \\<And>a L n.\n       (\\<And>n.\n           ladder_shift_n N (drop n L) =\n           drop n (ladder_shift_n N L)) \\<Longrightarrow>\n       ladder_shift_n N (drop n (a # L)) = drop n (ladder_shift_n N (a # L))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. ladder_shift_n N (drop n []) = drop n (ladder_shift_n N [])\n 2. \\<And>a L n.\n       (\\<And>n.\n           ladder_shift_n N (drop n L) =\n           drop n (ladder_shift_n N L)) \\<Longrightarrow>\n       ladder_shift_n N (drop n (a # L)) = drop n (ladder_shift_n N (a # L))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_shift_n N (drop n []) = drop n (ladder_shift_n N [])", "by simp"], ["proof (state)\nthis:\n  ladder_shift_n N (drop n []) = drop n (ladder_shift_n N [])\n\ngoal (1 subgoal):\n 1. \\<And>a L n.\n       (\\<And>n.\n           ladder_shift_n N (drop n L) =\n           drop n (ladder_shift_n N L)) \\<Longrightarrow>\n       ladder_shift_n N (drop n (a # L)) = drop n (ladder_shift_n N (a # L))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L n.\n       (\\<And>n.\n           ladder_shift_n N (drop n L) =\n           drop n (ladder_shift_n N L)) \\<Longrightarrow>\n       ladder_shift_n N (drop n (a # L)) = drop n (ladder_shift_n N (a # L))", "case (Cons x L)"], ["proof (state)\nthis:\n  ladder_shift_n N (drop ?n L) = drop ?n (ladder_shift_n N L)\n\ngoal (1 subgoal):\n 1. \\<And>a L n.\n       (\\<And>n.\n           ladder_shift_n N (drop n L) =\n           drop n (ladder_shift_n N L)) \\<Longrightarrow>\n       ladder_shift_n N (drop n (a # L)) = drop n (ladder_shift_n N (a # L))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))", "by simp"], ["proof (state)\nthis:\n  ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))", "case (Suc n)"], ["proof (state)\nthis:\n  na__ = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       na__ = Suc nat \\<Longrightarrow>\n       ladder_shift_n N (drop na__ (x # L)) =\n       drop na__ (ladder_shift_n N (x # L))", "then"], ["proof (chain)\npicking this:\n  na__ = Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  na__ = Suc n\n\ngoal (1 subgoal):\n 1. ladder_shift_n N (drop na__ (x # L)) =\n    drop na__ (ladder_shift_n N (x # L))", "by (simp add: ladder_shift_n_cons Cons)"], ["proof (state)\nthis:\n  ladder_shift_n N (drop na__ (x # L)) =\n  drop na__ (ladder_shift_n N (x # L))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_shift_n N (drop n (x # L)) = drop n (ladder_shift_n N (x # L))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_2_shift:\n  assumes \"index > 0\"\n  assumes \"length L > 1\"\n  shows \"drop 2 L ! (index - Suc 0) = L ! Suc index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop 2 L ! (index - Suc 0) = L ! Suc index", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. drop 2 L ! (index - Suc 0) = L ! Suc index", "define l1 l2 and L' where \"l1 = L ! 0\" \"l2 = L ! 1\"\n    and \"L' = drop 2 L\""], ["proof (state)\nthis:\n  l1 = L ! 0\n  l2 = L ! 1\n  L' = drop 2 L\n\ngoal (1 subgoal):\n 1. drop 2 L ! (index - Suc 0) = L ! Suc index", "with \\<open>length L > 1\\<close>"], ["proof (chain)\npicking this:\n  1 < length L\n  l1 = L ! 0\n  l2 = L ! 1\n  L' = drop 2 L", "have \"L = l1 # l2 # L'\""], ["proof (prove)\nusing this:\n  1 < length L\n  l1 = L ! 0\n  l2 = L ! 1\n  L' = drop 2 L\n\ngoal (1 subgoal):\n 1. L = l1 # l2 # L'", "by (cases L) (auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  L = l1 # l2 # L'\n\ngoal (1 subgoal):\n 1. drop 2 L ! (index - Suc 0) = L ! Suc index", "with \\<open>index > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < index\n  L = l1 # l2 # L'", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < index\n  L = l1 # l2 # L'\n\ngoal (1 subgoal):\n 1. drop 2 L ! (index - Suc 0) = L ! Suc index", "by simp"], ["proof (state)\nthis:\n  drop 2 L ! (index - Suc 0) = L ! Suc index\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_shift_n_at:\n  \"index < length L \\<Longrightarrow> (ladder_shift_n N L) ! index = (fst (L ! index) - N, snd (L ! index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L \\<Longrightarrow>\n    ladder_shift_n N L ! index = (fst (L ! index) - N, snd (L ! index))", "proof (induct L arbitrary: index)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       ladder_shift_n N [] ! index =\n       (fst ([] ! index) - N, snd ([] ! index))\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   ladder_shift_n N L ! index =\n                   (fst (L ! index) - N, snd (L ! index));\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> ladder_shift_n N (a # L) ! index =\n                         (fst ((a # L) ! index) - N, snd ((a # L) ! index))", "case Nil"], ["proof (state)\nthis:\n  index < length []\n\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       ladder_shift_n N [] ! index =\n       (fst ([] ! index) - N, snd ([] ! index))\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   ladder_shift_n N L ! index =\n                   (fst (L ! index) - N, snd (L ! index));\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> ladder_shift_n N (a # L) ! index =\n                         (fst ((a # L) ! index) - N, snd ((a # L) ! index))", "then"], ["proof (chain)\npicking this:\n  index < length []", "show ?case"], ["proof (prove)\nusing this:\n  index < length []\n\ngoal (1 subgoal):\n 1. ladder_shift_n N [] ! index = (fst ([] ! index) - N, snd ([] ! index))", "by auto"], ["proof (state)\nthis:\n  ladder_shift_n N [] ! index = (fst ([] ! index) - N, snd ([] ! index))\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   ladder_shift_n N L ! index =\n                   (fst (L ! index) - N, snd (L ! index));\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> ladder_shift_n N (a # L) ! index =\n                         (fst ((a # L) ! index) - N, snd ((a # L) ! index))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   ladder_shift_n N L ! index =\n                   (fst (L ! index) - N, snd (L ! index));\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> ladder_shift_n N (a # L) ! index =\n                         (fst ((a # L) ! index) - N, snd ((a # L) ! index))", "case (Cons x L)"], ["proof (state)\nthis:\n  ?index < length L \\<Longrightarrow>\n  ladder_shift_n N L ! ?index = (fst (L ! ?index) - N, snd (L ! ?index))\n  index < length (x # L)\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   ladder_shift_n N L ! index =\n                   (fst (L ! index) - N, snd (L ! index));\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> ladder_shift_n N (a # L) ! index =\n                         (fst ((a # L) ! index) - N, snd ((a # L) ! index))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_shift_n N (x # L) ! index =\n    (fst ((x # L) ! index) - N, snd ((x # L) ! index))", "apply (simp add: ladder_shift_n_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fst x - N, snd x) # ladder_shift_n N L) ! index =\n    (fst ((x # L) ! index) - N, snd ((x # L) ! index))", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ((fst x - N, snd x) # ladder_shift_n N L) ! index =\n    (fst ((x # L) ! index) - N, snd ((x # L) ! index))\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       ((fst x - N, snd x) # ladder_shift_n N L) ! index =\n       (fst ((x # L) ! index) - N, snd ((x # L) ! index))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       ladder_shift_n N L ! nat = (fst (L ! nat) - N, snd (L ! nat))", "apply (rule_tac Cons(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> nat < length L", "using Cons(2)"], ["proof (prove)\nusing this:\n  index < length (x # L)\n\ngoal (1 subgoal):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> nat < length L", "by auto"], ["proof (state)\nthis:\n  ladder_shift_n N (x # L) ! index =\n  (fst ((x # L) ! index) - N, snd ((x # L) ! index))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_stepdown_j:\n  assumes length_L_greater_1: \"length L > 1\"\n  assumes L': \"L' = ladder_stepdown L\"\n  assumes index_bound: \"index < length L'\"\n  shows \"ladder_j L' index = ladder_j L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "note L_prepare = ladder_stepdown_prepare[OF length_L_greater_1]"], ["proof (state)\nthis:\n  L =\n  (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n  (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L\n\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "have ladder_stepdown_L_def: \"ladder_stepdown L = ((ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0), ladder_j L 0 + ladder_ix L (Suc 0)) #\n    ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_stepdown L =\n    (ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0),\n     ladder_j L 0 + ladder_ix L (Suc 0)) #\n    ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L)", "by (subst L_prepare, simp)"], ["proof (state)\nthis:\n  ladder_stepdown L =\n  (ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0),\n   ladder_j L 0 + ladder_ix L (Suc 0)) #\n  ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L)\n\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "have \"index = 0 \\<or> index > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index = 0 \\<or> 0 < index", "by arith"], ["proof (state)\nthis:\n  index = 0 \\<or> 0 < index\n\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "then"], ["proof (chain)\npicking this:\n  index = 0 \\<or> 0 < index", "show \"ladder_j L' index = ladder_j L (Suc index)\""], ["proof (prove)\nusing this:\n  index = 0 \\<or> 0 < index\n\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)\n 2. 0 < index \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)", "case 1"], ["proof (state)\nthis:\n  index = 0\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)\n 2. 0 < index \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "by (simp add: L' ladder_stepdown_L_def 1 ladder_j_def deriv_j_def)"], ["proof (state)\nthis:\n  ladder_j L' index = ladder_j L (Suc index)\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)", "case 2"], ["proof (state)\nthis:\n  0 < index\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)", "have index_bound': \"Suc index < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc index < length L", "using index_bound L' ladder_stepdown_length length_L_greater_1"], ["proof (prove)\nusing this:\n  index < length L'\n  L' = ladder_stepdown L\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n\ngoal (1 subgoal):\n 1. Suc index < length L", "by auto"], ["proof (state)\nthis:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow> ladder_j L' index = ladder_j L (Suc index)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "apply (simp add: L' ladder_stepdown_L_def 2 ladder_j_def ladder_shift_n_drop drop_2_shift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_j\n     (drop 2 (ladder_shift_n (Suc (ladder_n L 0)) L) ! (index - Suc 0)) =\n    deriv_j (L ! Suc index)", "apply (subst drop_2_shift)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < index\n 2. 1 < length (ladder_shift_n (Suc (ladder_n L 0)) L)\n 3. deriv_j (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_j (L ! Suc index)", "apply (simp add: 2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 < length (ladder_shift_n (Suc (ladder_n L 0)) L)\n 2. deriv_j (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_j (L ! Suc index)", "using length_L_greater_1"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (2 subgoals):\n 1. 1 < length (ladder_shift_n (Suc (ladder_n L 0)) L)\n 2. deriv_j (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_j (L ! Suc index)", "apply (simp add: ladder_shift_n_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_j (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_j (L ! Suc index)", "apply (simp add: deriv_j_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index)) =\n    fst (snd (L ! Suc index))", "apply (simp add: ladder_shift_n_at[OF index_bound'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ladder_j L' index = ladder_j L (Suc index)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_j L' index = ladder_j L (Suc index)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_stepdown_last_j:\n  assumes length_L_greater_1: \"length L > 1\"\n  shows \"ladder_last_j (ladder_stepdown L) = ladder_last_j L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_j (ladder_stepdown L) = ladder_last_j L", "using ladder_stepdown_j Suc_diff_Suc diff_Suc_1 ladder_last_j_def ladder_stepdown_length \n  length_L_greater_1 lessI"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length ?L; ?L' = ladder_stepdown ?L;\n   ?index < length ?L'\\<rbrakk>\n  \\<Longrightarrow> ladder_j ?L' ?index = ladder_j ?L (Suc ?index)\n  ?n < ?m \\<Longrightarrow> Suc (?m - Suc ?n) = ?m - ?n\n  Suc ?n - 1 = ?n\n  ladder_last_j ?L = ladder_j ?L (length ?L - 1)\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n  ?n < Suc ?n\n\ngoal (1 subgoal):\n 1. ladder_last_j (ladder_stepdown L) = ladder_last_j L", "by auto"], ["", "lemma ladder_stepdown_n:\n  assumes length_L_greater_1: \"length L > 1\"\n  assumes L': \"L' = ladder_stepdown L\"\n  assumes index_bound: \"index < length L'\"\n  shows \"ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "note L_prepare = ladder_stepdown_prepare[OF length_L_greater_1]"], ["proof (state)\nthis:\n  L =\n  (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n  (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L\n\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "have ladder_stepdown_L_def: \"ladder_stepdown L = ((ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0), ladder_j L 0 + ladder_ix L (Suc 0)) #\n    ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_stepdown L =\n    (ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0),\n     ladder_j L 0 + ladder_ix L (Suc 0)) #\n    ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L)", "by (subst L_prepare, simp)"], ["proof (state)\nthis:\n  ladder_stepdown L =\n  (ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0),\n   ladder_j L 0 + ladder_ix L (Suc 0)) #\n  ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L)\n\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "have \"index = 0 \\<or> index > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index = 0 \\<or> 0 < index", "by arith"], ["proof (state)\nthis:\n  index = 0 \\<or> 0 < index\n\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "then"], ["proof (chain)\npicking this:\n  index = 0 \\<or> 0 < index", "show \"ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\""], ["proof (prove)\nusing this:\n  index = 0 \\<or> 0 < index\n\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\n 2. 0 < index \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "case 1"], ["proof (state)\nthis:\n  index = 0\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\n 2. 0 < index \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "by (simp add: L' ladder_stepdown_L_def 1 ladder_n_def deriv_n_def ladder_stepdown_diff_def)"], ["proof (state)\nthis:\n  ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "case 2"], ["proof (state)\nthis:\n  0 < index\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "have index_bound': \"Suc index < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc index < length L", "using index_bound L' ladder_stepdown_length length_L_greater_1"], ["proof (prove)\nusing this:\n  index < length L'\n  L' = ladder_stepdown L\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n\ngoal (1 subgoal):\n 1. Suc index < length L", "by auto"], ["proof (state)\nthis:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L", "apply (simp add: L' ladder_stepdown_L_def 2 ladder_n_def ladder_shift_n_drop drop_2_shift\n          ladder_stepdown_diff_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n\n     (drop 2 (ladder_shift_n (Suc (deriv_n (L ! 0))) L) ! (index - Suc 0)) =\n    deriv_n (L ! Suc index) - Suc (deriv_n (L ! 0))", "apply (subst drop_2_shift)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < index\n 2. 1 < length (ladder_shift_n (Suc (deriv_n (L ! 0))) L)\n 3. deriv_n (ladder_shift_n (Suc (deriv_n (L ! 0))) L ! Suc index) =\n    deriv_n (L ! Suc index) - Suc (deriv_n (L ! 0))", "apply (simp add: 2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 < length (ladder_shift_n (Suc (deriv_n (L ! 0))) L)\n 2. deriv_n (ladder_shift_n (Suc (deriv_n (L ! 0))) L ! Suc index) =\n    deriv_n (L ! Suc index) - Suc (deriv_n (L ! 0))", "using length_L_greater_1"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (2 subgoals):\n 1. 1 < length (ladder_shift_n (Suc (deriv_n (L ! 0))) L)\n 2. deriv_n (ladder_shift_n (Suc (deriv_n (L ! 0))) L ! Suc index) =\n    deriv_n (L ! Suc index) - Suc (deriv_n (L ! 0))", "apply (simp add: ladder_shift_n_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n (ladder_shift_n (Suc (deriv_n (L ! 0))) L ! Suc index) =\n    deriv_n (L ! Suc index) - Suc (deriv_n (L ! 0))", "apply (simp add: deriv_n_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (ladder_shift_n (Suc (fst (L ! 0))) L ! Suc index) =\n    fst (L ! Suc index) - Suc (fst (L ! 0))", "apply (simp add: ladder_shift_n_at[OF index_bound'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ladder_n L' index = ladder_n L (Suc index) - ladder_stepdown_diff L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_stepdown_ix:\n  assumes length_L_greater_1: \"length L > 1\"\n  assumes L': \"L' = ladder_stepdown L\"\n  assumes index_lower_bound: \"0 < index\"\n  assumes index_upper_bound: \"index < length L'\"\n  shows \"ladder_ix L' index = ladder_ix L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "note L_prepare = ladder_stepdown_prepare[OF length_L_greater_1]"], ["proof (state)\nthis:\n  L =\n  (ladder_n L 0, ladder_j L 0, ladder_i L 0) #\n  (ladder_n L 1, ladder_j L 1, ladder_ix L 1) # drop 2 L\n\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "have ladder_stepdown_L_def: \"ladder_stepdown L = ((ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0), ladder_j L 0 + ladder_ix L (Suc 0)) #\n    ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_stepdown L =\n    (ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0),\n     ladder_j L 0 + ladder_ix L (Suc 0)) #\n    ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L)", "by (subst L_prepare, simp)"], ["proof (state)\nthis:\n  ladder_stepdown L =\n  (ladder_n L (Suc 0) - Suc (ladder_n L 0), ladder_j L (Suc 0),\n   ladder_j L 0 + ladder_ix L (Suc 0)) #\n  ladder_shift_n (Suc (ladder_n L 0)) (drop 2 L)\n\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "have index_bound': \"Suc index < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc index < length L", "using index_upper_bound L' ladder_stepdown_length length_L_greater_1"], ["proof (prove)\nusing this:\n  index < length L'\n  L' = ladder_stepdown L\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n\ngoal (1 subgoal):\n 1. Suc index < length L", "by auto"], ["proof (state)\nthis:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "apply (simp add: L' ladder_stepdown_L_def index_lower_bound ladder_ix_def ladder_shift_n_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index = 0 \\<longrightarrow> undefined = deriv_ix (L ! Suc 0)) \\<and>\n    deriv_ix\n     (drop 2 (ladder_shift_n (Suc (ladder_n L 0)) L) ! (index - Suc 0)) =\n    deriv_ix (L ! Suc index)", "apply (subst drop_2_shift)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < index\n 2. 1 < length (ladder_shift_n (Suc (ladder_n L 0)) L)\n 3. (index = 0 \\<longrightarrow> undefined = deriv_ix (L ! Suc 0)) \\<and>\n    deriv_ix (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_ix (L ! Suc index)", "apply (simp add: index_lower_bound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 < length (ladder_shift_n (Suc (ladder_n L 0)) L)\n 2. (index = 0 \\<longrightarrow> undefined = deriv_ix (L ! Suc 0)) \\<and>\n    deriv_ix (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_ix (L ! Suc index)", "using length_L_greater_1"], ["proof (prove)\nusing this:\n  1 < length L\n\ngoal (2 subgoals):\n 1. 1 < length (ladder_shift_n (Suc (ladder_n L 0)) L)\n 2. (index = 0 \\<longrightarrow> undefined = deriv_ix (L ! Suc 0)) \\<and>\n    deriv_ix (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_ix (L ! Suc index)", "apply (simp add: ladder_shift_n_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index = 0 \\<longrightarrow> undefined = deriv_ix (L ! Suc 0)) \\<and>\n    deriv_ix (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index) =\n    deriv_ix (L ! Suc index)", "apply (simp add: deriv_ix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index = 0 \\<longrightarrow> undefined = snd (snd (L ! Suc 0))) \\<and>\n    snd (snd (ladder_shift_n (Suc (ladder_n L 0)) L ! Suc index)) =\n    snd (snd (L ! Suc index))", "apply (simp add: ladder_shift_n_at[OF index_bound'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. index = 0 \\<longrightarrow> undefined = snd (snd (L ! Suc 0))", "using index_lower_bound"], ["proof (prove)\nusing this:\n  0 < index\n\ngoal (1 subgoal):\n 1. index = 0 \\<longrightarrow> undefined = snd (snd (L ! Suc 0))", "by arith"], ["proof (state)\nthis:\n  ladder_ix L' index = ladder_ix L (Suc index)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Derive_Derive:\n  assumes \"Derivation \\<alpha> (D@E) \\<gamma>\"\n  shows \"Derive (Derive \\<alpha> D) E = Derive \\<alpha> (D@E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive (Derive \\<alpha> D) E = Derive \\<alpha> (D @ E)", "using Derivation_append Derive assms"], ["proof (prove)\nusing this:\n  Derivation ?a (?D @ ?E) ?c =\n  (\\<exists>b. Derivation ?a ?D b \\<and> Derivation b ?E ?c)\n  Derivation ?a ?D ?b \\<Longrightarrow> Derive ?a ?D = ?b\n  Derivation \\<alpha> (D @ E) \\<gamma>\n\ngoal (1 subgoal):\n 1. Derive (Derive \\<alpha> D) E = Derive \\<alpha> (D @ E)", "by fastforce"], ["", "lemma drop_at_shift:\n  assumes \"n \\<le> index\"\n  assumes \"index < length D\"\n  shows \"drop n D ! (index - n) = D ! index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n D ! (index - n) = D ! index", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  n \\<le> index\n  index < length D\n\ngoal (1 subgoal):\n 1. drop n D ! (index - n) = D ! index", "by auto"], ["", "theorem LeftDerivationLadder_stepdown:\n  assumes ldl: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\" \n  assumes length_L: \"length L > 1\"\n  shows \"\\<exists> L'. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (drop (ladder_stepdown_diff L) D)\n           L' \\<gamma> \\<and> length L' = length L - 1 \\<and> ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n           ladder_last_j L' = ladder_last_j L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "obtain L' where L': \"L' = ladder_stepdown L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        L' = ladder_stepdown L \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L' = ladder_stepdown L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have ldl1: \"LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (drop (ladder_stepdown_diff L) D) \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>", "have D_split: \"D = (take (ladder_stepdown_diff L) D) @ (drop (ladder_stepdown_diff L) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D", "by simp"], ["proof (state)\nthis:\n  D = take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>", "using D_split ldl"], ["proof (prove)\nusing this:\n  D = take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>D =\n             take (ladder_stepdown_diff L) D @\n             drop (ladder_stepdown_diff L) D;\n     LeftDerivationLadder \\<alpha> D L \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation\n                       (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n                       (drop (ladder_stepdown_diff L) D) \\<gamma>", "obtain sss :: \"symbol list \\<Rightarrow> (nat \\<times> symbol \\<times> symbol list) list \\<Rightarrow> (nat \\<times> symbol \\<times> symbol list) list \\<Rightarrow> symbol list \\<Rightarrow> symbol list\" where\n          \"\\<forall>x0 x1 x2 x3. (\\<exists>v4. LeftDerivation x3 x2 v4 \\<and> LeftDerivation v4 x1 x0) = (LeftDerivation x3 x2 (sss x0 x1 x2 x3) \\<and> LeftDerivation (sss x0 x1 x2 x3) x1 x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sss.\n        \\<forall>x0 x1 x2 x3.\n           (\\<exists>v4.\n               LeftDerivation x3 x2 v4 \\<and> LeftDerivation v4 x1 x0) =\n           (LeftDerivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n            LeftDerivation (sss x0 x1 x2 x3) x1 x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. LeftDerivation x3 x2 v4 \\<and> LeftDerivation v4 x1 x0) =\n     (LeftDerivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      LeftDerivation (sss x0 x1 x2 x3) x1 x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D =\n             take (ladder_stepdown_diff L) D @\n             drop (ladder_stepdown_diff L) D;\n     LeftDerivationLadder \\<alpha> D L \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation\n                       (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n                       (drop (ladder_stepdown_diff L) D) \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. LeftDerivation x3 x2 v4 \\<and> LeftDerivation v4 x1 x0) =\n     (LeftDerivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      LeftDerivation (sss x0 x1 x2 x3) x1 x0)", "have \"(\\<not> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D) \\<gamma> \\<or> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D) (sss \\<gamma> (drop (ladder_stepdown_diff L) D) (take (ladder_stepdown_diff L) D) \\<alpha>) \\<and> LeftDerivation (sss \\<gamma> (drop (ladder_stepdown_diff L) D) (take (ladder_stepdown_diff L) D) \\<alpha>) (drop (ladder_stepdown_diff L) D) \\<gamma>) \\<and> (LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D) \\<gamma> \\<or> (\\<forall>ss. \\<not> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D) ss \\<or> \\<not> LeftDerivation ss (drop (ladder_stepdown_diff L) D) \\<gamma>))\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. LeftDerivation x3 x2 v4 \\<and> LeftDerivation v4 x1 x0) =\n     (LeftDerivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      LeftDerivation (sss x0 x1 x2 x3) x1 x0)\n\ngoal (1 subgoal):\n 1. (\\<not> LeftDerivation \\<alpha>\n             (take (ladder_stepdown_diff L) D @\n              drop (ladder_stepdown_diff L) D)\n             \\<gamma> \\<or>\n     LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n      (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n        (take (ladder_stepdown_diff L) D) \\<alpha>) \\<and>\n     LeftDerivation\n      (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n        (take (ladder_stepdown_diff L) D) \\<alpha>)\n      (drop (ladder_stepdown_diff L) D) \\<gamma>) \\<and>\n    (LeftDerivation \\<alpha>\n      (take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D)\n      \\<gamma> \\<or>\n     (\\<forall>ss.\n         \\<not> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n                 ss \\<or>\n         \\<not> LeftDerivation ss (drop (ladder_stepdown_diff L) D)\n                 \\<gamma>))", "using LeftDerivation_append"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2 x3.\n     (\\<exists>v4. LeftDerivation x3 x2 v4 \\<and> LeftDerivation v4 x1 x0) =\n     (LeftDerivation x3 x2 (sss x0 x1 x2 x3) \\<and>\n      LeftDerivation (sss x0 x1 x2 x3) x1 x0)\n  LeftDerivation ?a (?D @ ?E) ?c =\n  (\\<exists>b. LeftDerivation ?a ?D b \\<and> LeftDerivation b ?E ?c)\n\ngoal (1 subgoal):\n 1. (\\<not> LeftDerivation \\<alpha>\n             (take (ladder_stepdown_diff L) D @\n              drop (ladder_stepdown_diff L) D)\n             \\<gamma> \\<or>\n     LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n      (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n        (take (ladder_stepdown_diff L) D) \\<alpha>) \\<and>\n     LeftDerivation\n      (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n        (take (ladder_stepdown_diff L) D) \\<alpha>)\n      (drop (ladder_stepdown_diff L) D) \\<gamma>) \\<and>\n    (LeftDerivation \\<alpha>\n      (take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D)\n      \\<gamma> \\<or>\n     (\\<forall>ss.\n         \\<not> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n                 ss \\<or>\n         \\<not> LeftDerivation ss (drop (ladder_stepdown_diff L) D)\n                 \\<gamma>))", "by blast"], ["proof (state)\nthis:\n  (\\<not> LeftDerivation \\<alpha>\n           (take (ladder_stepdown_diff L) D @\n            drop (ladder_stepdown_diff L) D)\n           \\<gamma> \\<or>\n   LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n    (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n      (take (ladder_stepdown_diff L) D) \\<alpha>) \\<and>\n   LeftDerivation\n    (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n      (take (ladder_stepdown_diff L) D) \\<alpha>)\n    (drop (ladder_stepdown_diff L) D) \\<gamma>) \\<and>\n  (LeftDerivation \\<alpha>\n    (take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D)\n    \\<gamma> \\<or>\n   (\\<forall>ss.\n       \\<not> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n               ss \\<or>\n       \\<not> LeftDerivation ss (drop (ladder_stepdown_diff L) D) \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D =\n             take (ladder_stepdown_diff L) D @\n             drop (ladder_stepdown_diff L) D;\n     LeftDerivationLadder \\<alpha> D L \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> LeftDerivation\n                       (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n                       (drop (ladder_stepdown_diff L) D) \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (\\<not> LeftDerivation \\<alpha>\n           (take (ladder_stepdown_diff L) D @\n            drop (ladder_stepdown_diff L) D)\n           \\<gamma> \\<or>\n   LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n    (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n      (take (ladder_stepdown_diff L) D) \\<alpha>) \\<and>\n   LeftDerivation\n    (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n      (take (ladder_stepdown_diff L) D) \\<alpha>)\n    (drop (ladder_stepdown_diff L) D) \\<gamma>) \\<and>\n  (LeftDerivation \\<alpha>\n    (take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D)\n    \\<gamma> \\<or>\n   (\\<forall>ss.\n       \\<not> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n               ss \\<or>\n       \\<not> LeftDerivation ss (drop (ladder_stepdown_diff L) D) \\<gamma>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<not> LeftDerivation \\<alpha>\n           (take (ladder_stepdown_diff L) D @\n            drop (ladder_stepdown_diff L) D)\n           \\<gamma> \\<or>\n   LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n    (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n      (take (ladder_stepdown_diff L) D) \\<alpha>) \\<and>\n   LeftDerivation\n    (sss \\<gamma> (drop (ladder_stepdown_diff L) D)\n      (take (ladder_stepdown_diff L) D) \\<alpha>)\n    (drop (ladder_stepdown_diff L) D) \\<gamma>) \\<and>\n  (LeftDerivation \\<alpha>\n    (take (ladder_stepdown_diff L) D @ drop (ladder_stepdown_diff L) D)\n    \\<gamma> \\<or>\n   (\\<forall>ss.\n       \\<not> LeftDerivation \\<alpha> (take (ladder_stepdown_diff L) D)\n               ss \\<or>\n       \\<not> LeftDerivation ss (drop (ladder_stepdown_diff L) D) \\<gamma>))\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>", "by (metis (no_types) D_split Derivation_take_derive Derivation_unique_dest LeftDerivationLadder_def LeftDerivation_implies_Derivation ladder_stepdown_\\<alpha>_0_def ldl)"], ["proof (state)\nthis:\n  LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have L'_nonempty: \"L' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' \\<noteq> []", "using L' ladder_stepdown_length length_L"], ["proof (prove)\nusing this:\n  L' = ladder_stepdown L\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n\ngoal (1 subgoal):\n 1. L' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  L' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "{"], ["proof (state)\nthis:\n  L' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "assume u': \"u < length L'\""], ["proof (state)\nthis:\n  u < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  u < length L'", "have Suc_u: \"Suc u < length L\""], ["proof (prove)\nusing this:\n  u < length L'\n\ngoal (1 subgoal):\n 1. Suc u < length L", "using L' ladder_stepdown_length length_L"], ["proof (prove)\nusing this:\n  u < length L'\n  L' = ladder_stepdown L\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n\ngoal (1 subgoal):\n 1. Suc u < length L", "by auto"], ["proof (state)\nthis:\n  Suc u < length L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have \"ladder_n L (Suc u)  \\<le> length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (Suc u) \\<le> length D", "using ldl Suc_u"], ["proof (prove)\nusing this:\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n  Suc u < length L\n\ngoal (1 subgoal):\n 1. ladder_n L (Suc u) \\<le> length D", "by (simp add: LeftDerivationLadder_ladder_n_bound)"], ["proof (state)\nthis:\n  ladder_n L (Suc u) \\<le> length D\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  ladder_n L (Suc u) \\<le> length D", "have \"ladder_n L' u \\<le> length D - ladder_stepdown_diff L\""], ["proof (prove)\nusing this:\n  ladder_n L (Suc u) \\<le> length D\n\ngoal (1 subgoal):\n 1. ladder_n L' u \\<le> length D - ladder_stepdown_diff L", "apply (subst ladder_stepdown_n[OF length_L L' u'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (Suc u) \\<le> length D \\<Longrightarrow>\n    ladder_n L (Suc u) - ladder_stepdown_diff L\n    \\<le> length D - ladder_stepdown_diff L", "by auto"], ["proof (state)\nthis:\n  ladder_n L' u \\<le> length D - ladder_stepdown_diff L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "}"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow>\n  ladder_n L' ?u2 \\<le> length D - ladder_stepdown_diff L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "note is_ladder_prop1 = this"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow>\n  ladder_n L' ?u2 \\<le> length D - ladder_stepdown_diff L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "{"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow>\n  ladder_n L' ?u2 \\<le> length D - ladder_stepdown_diff L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "fix v :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "assume u_less_v: \"u < v\""], ["proof (state)\nthis:\n  u < v\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "assume v_L': \"v < length L'\""], ["proof (state)\nthis:\n  v < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "from u_less_v v_L'"], ["proof (chain)\npicking this:\n  u < v\n  v < length L'", "have u_L': \"u < length L'\""], ["proof (prove)\nusing this:\n  u < v\n  v < length L'\n\ngoal (1 subgoal):\n 1. u < length L'", "by arith"], ["proof (state)\nthis:\n  u < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have \"ladder_n L (Suc u) < ladder_n L (Suc v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (Suc u) < ladder_n L (Suc v)", "using ldl"], ["proof (prove)\nusing this:\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n\ngoal (1 subgoal):\n 1. ladder_n L (Suc u) < ladder_n L (Suc v)", "by (metis (no_types, lifting) L' LeftDerivationLadder_def One_nat_def Suc_diff_1 \n        Suc_lessD Suc_mono is_ladder_def ladder_stepdown_length length_L u_less_v v_L')"], ["proof (state)\nthis:\n  ladder_n L (Suc u) < ladder_n L (Suc v)\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  ladder_n L (Suc u) < ladder_n L (Suc v)", "have \"ladder_n L' u < ladder_n L' v\""], ["proof (prove)\nusing this:\n  ladder_n L (Suc u) < ladder_n L (Suc v)\n\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "apply (simp add: ladder_stepdown_n[OF length_L L'] u_L' v_L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (Suc u) < ladder_n L (Suc v) \\<Longrightarrow>\n    ladder_n L (Suc u) - ladder_stepdown_diff L\n    < ladder_n L (Suc v) - ladder_stepdown_diff L", "by (metis (no_types, lifting) L' LeftDerivationLadder_def Suc_eq_plus1 Suc_leI \n        diff_less_mono is_ladder_def ladder_stepdown_diff_def ladder_stepdown_length ldl \n        length_L less_diff_conv u_L' zero_less_Suc)"], ["proof (state)\nthis:\n  ladder_n L' u < ladder_n L' v\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "note is_ladder_prop2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have is_ladder_L': \"is_ladder (drop (ladder_stepdown_diff L) D) L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder (drop (ladder_stepdown_diff L) D) L'", "apply (auto simp add: is_ladder_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. L' = [] \\<Longrightarrow> False\n 2. \\<And>u.\n       u < length L' \\<Longrightarrow>\n       ladder_n L' u \\<le> length D - ladder_stepdown_diff L\n 3. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 4. ladder_last_n L' = length D - ladder_stepdown_diff L", "using L'_nonempty"], ["proof (prove)\nusing this:\n  L' \\<noteq> []\n\ngoal (4 subgoals):\n 1. L' = [] \\<Longrightarrow> False\n 2. \\<And>u.\n       u < length L' \\<Longrightarrow>\n       ladder_n L' u \\<le> length D - ladder_stepdown_diff L\n 3. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 4. ladder_last_n L' = length D - ladder_stepdown_diff L", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u.\n       u < length L' \\<Longrightarrow>\n       ladder_n L' u \\<le> length D - ladder_stepdown_diff L\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 3. ladder_last_n L' = length D - ladder_stepdown_diff L", "using is_ladder_prop1"], ["proof (prove)\nusing this:\n  ?u2 < length L' \\<Longrightarrow>\n  ladder_n L' ?u2 \\<le> length D - ladder_stepdown_diff L\n\ngoal (3 subgoals):\n 1. \\<And>u.\n       u < length L' \\<Longrightarrow>\n       ladder_n L' u \\<le> length D - ladder_stepdown_diff L\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 3. ladder_last_n L' = length D - ladder_stepdown_diff L", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. ladder_last_n L' = length D - ladder_stepdown_diff L", "using is_ladder_prop2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. ladder_last_n L' = length D - ladder_stepdown_diff L", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_n L' = length D - ladder_stepdown_diff L", "using ladder_last_n_def ladder_stepdown_n L' LeftDerivationLadder_def Suc_diff_Suc diff_Suc_1 \n      ladder_n_last_is_length ladder_stepdown_length ldl length_L lessI"], ["proof (prove)\nusing this:\n  ladder_last_n ?L = ladder_n ?L (length ?L - 1)\n  \\<lbrakk>1 < length ?L; ?L' = ladder_stepdown ?L;\n   ?index < length ?L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n ?L' ?index =\n                    ladder_n ?L (Suc ?index) - ladder_stepdown_diff ?L\n  L' = ladder_stepdown L\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  ?n < ?m \\<Longrightarrow> Suc (?m - Suc ?n) = ?m - ?n\n  Suc ?n - 1 = ?n\n  is_ladder ?D ?L \\<Longrightarrow> ladder_n ?L (length ?L - 1) = length ?D\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n  1 < length L\n  ?n < Suc ?n\n\ngoal (1 subgoal):\n 1. ladder_last_n L' = length D - ladder_stepdown_diff L", "by auto"], ["proof (state)\nthis:\n  is_ladder (drop (ladder_stepdown_diff L) D) L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have ldfix: \"LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D)) (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (drop (ladder_stepdown_diff L) D) L' 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "have introsAt_L_1: \"LeftDerivationIntrosAt \\<alpha> D L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> D L 1", "using LeftDerivationIntros_def LeftDerivationLadder_def ldl length_L"], ["proof (prove)\nusing this:\n  LeftDerivationIntros ?a ?D ?L =\n  (\\<forall>index.\n      1 \\<le> index \\<and> index < length ?L \\<longrightarrow>\n      LeftDerivationIntrosAt ?a ?D ?L index)\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n  1 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> D L 1", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt \\<alpha> D L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "thm LeftDerivationIntrosAt_def"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt \\<alpha> D L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "obtain n where n: \"n = ladder_n L 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = ladder_n L 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = ladder_n L 0\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "obtain m where m: \"m = ladder_n L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. m = ladder_n L 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = ladder_n L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "have \"LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) (snd (D ! n)) \n      (ladder_ix L 1) (drop (Suc n) (take m D)) (ladder_j L 1) (ladder_\\<gamma> \\<alpha> D L 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n     (snd (D ! n)) (ladder_ix L 1) (drop (Suc n) (take m D)) (ladder_j L 1)\n     (ladder_\\<gamma> \\<alpha> D L 1)", "using n m introsAt_L_1"], ["proof (prove)\nusing this:\n  n = ladder_n L 0\n  m = ladder_n L 1\n  LeftDerivationIntrosAt \\<alpha> D L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n     (snd (D ! n)) (ladder_ix L 1) (drop (Suc n) (take m D)) (ladder_j L 1)\n     (ladder_\\<gamma> \\<alpha> D L 1)", "by (metis LeftDerivationIntrosAt_def One_nat_def diff_Suc_1)"], ["proof (state)\nthis:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n   (snd (D ! n)) (ladder_ix L 1) (drop (Suc n) (take m D)) (ladder_j L 1)\n   (ladder_\\<gamma> \\<alpha> D L 1)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "from iffD1[OF  LeftDerivationIntro_def this]"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n      (snd (D ! n)) \\<beta> \\<and>\n     ladder_ix L 1 < length (snd (snd (D ! n))) \\<and>\n     snd (snd (D ! n)) ! ladder_ix L 1 =\n     ladder_\\<gamma> \\<alpha> D L 1 ! ladder_j L 1 \\<and>\n     LeftDerivationFix \\<beta> (ladder_i L 1 + ladder_ix L 1)\n      (drop (Suc n) (take m D)) (ladder_j L 1)\n      (ladder_\\<gamma> \\<alpha> D L 1)", "obtain \\<beta> where \\<beta>:\n      \"LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) (snd (D ! n)) \\<beta> \\<and>\n       ladder_ix L 1 < length (snd (snd (D ! n))) \\<and>\n       snd (snd (D ! n)) ! ladder_ix L 1 = ladder_\\<gamma> \\<alpha> D L 1 ! ladder_j L 1 \\<and>\n       LeftDerivationFix \\<beta> (ladder_i L 1 + ladder_ix L 1) (drop (Suc n) (take m D)) (ladder_j L 1)\n       (ladder_\\<gamma> \\<alpha> D L 1)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n      (snd (D ! n)) \\<beta> \\<and>\n     ladder_ix L 1 < length (snd (snd (D ! n))) \\<and>\n     snd (snd (D ! n)) ! ladder_ix L 1 =\n     ladder_\\<gamma> \\<alpha> D L 1 ! ladder_j L 1 \\<and>\n     LeftDerivationFix \\<beta> (ladder_i L 1 + ladder_ix L 1)\n      (drop (Suc n) (take m D)) (ladder_j L 1)\n      (ladder_\\<gamma> \\<alpha> D L 1)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1)\n         (snd (D ! n)) \\<beta> \\<and>\n        ladder_ix L 1 < length (snd (snd (D ! n))) \\<and>\n        snd (snd (D ! n)) ! ladder_ix L 1 =\n        ladder_\\<gamma> \\<alpha> D L 1 ! ladder_j L 1 \\<and>\n        LeftDerivationFix \\<beta> (ladder_i L 1 + ladder_ix L 1)\n         (drop (Suc n) (take m D)) (ladder_j L 1)\n         (ladder_\\<gamma> \\<alpha> D L 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) (snd (D ! n))\n   \\<beta> \\<and>\n  ladder_ix L 1 < length (snd (snd (D ! n))) \\<and>\n  snd (snd (D ! n)) ! ladder_ix L 1 =\n  ladder_\\<gamma> \\<alpha> D L 1 ! ladder_j L 1 \\<and>\n  LeftDerivationFix \\<beta> (ladder_i L 1 + ladder_ix L 1)\n   (drop (Suc n) (take m D)) (ladder_j L 1) (ladder_\\<gamma> \\<alpha> D L 1)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "have \"\\<beta> = Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> = Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n]", "by (metis (no_types, hide_lams) LeftDerivationIntrosAt_def LeftDerives1_Derive \\<beta> \n        cancel_comm_monoid_add_class.diff_cancel introsAt_L_1 n prod.collapse)"], ["proof (state)\nthis:\n  \\<beta> = Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n]\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "then"], ["proof (chain)\npicking this:\n  \\<beta> = Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n]", "have \\<beta>_def: \"\\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L\""], ["proof (prove)\nusing this:\n  \\<beta> = Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n]\n\ngoal (1 subgoal):\n 1. \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> =\n    Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n] \\<Longrightarrow>\n    \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L", "obtain sss :: \"nat \\<Rightarrow> symbol list \\<Rightarrow> symbol list\" and ss :: \"nat \\<Rightarrow> symbol list \\<Rightarrow> symbol\" and sssa :: \"nat \\<Rightarrow> symbol list \\<Rightarrow> symbol list\" where\n          \"\\<forall>x2 x3. (\\<exists>v4 v5 v6. splits_at x3 x2 v4 v5 v6) = splits_at x3 x2 (sss x2 x3) (ss x2 x3) (sssa x2 x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sss ss sssa.\n        \\<forall>x2 x3.\n           (\\<exists>v4 v5 v6. splits_at x3 x2 v4 v5 v6) =\n           splits_at x3 x2 (sss x2 x3) (ss x2 x3)\n            (sssa x2 x3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x2 x3.\n     (\\<exists>v4 v5 v6. splits_at x3 x2 v4 v5 v6) =\n     splits_at x3 x2 (sss x2 x3) (ss x2 x3) (sssa x2 x3)\n\ngoal (1 subgoal):\n 1. \\<beta> =\n    Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n] \\<Longrightarrow>\n    \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L", "then"], ["proof (chain)\npicking this:\n  \\<forall>x2 x3.\n     (\\<exists>v4 v5 v6. splits_at x3 x2 v4 v5 v6) =\n     splits_at x3 x2 (sss x2 x3) (ss x2 x3) (sssa x2 x3)", "have f1: \"\\<forall>ssa n p ssb. \\<not> Derives1 ssa n p ssb \\<or> splits_at ssa n (sss n ssa) (ss n ssa) (sssa n ssa)\""], ["proof (prove)\nusing this:\n  \\<forall>x2 x3.\n     (\\<exists>v4 v5 v6. splits_at x3 x2 v4 v5 v6) =\n     splits_at x3 x2 (sss x2 x3) (ss x2 x3) (sssa x2 x3)\n\ngoal (1 subgoal):\n 1. \\<forall>ssa n p ssb.\n       \\<not> Derives1 ssa n p ssb \\<or>\n       splits_at ssa n (sss n ssa) (ss n ssa) (sssa n ssa)", "using splits_at_ex"], ["proof (prove)\nusing this:\n  \\<forall>x2 x3.\n     (\\<exists>v4 v5 v6. splits_at x3 x2 v4 v5 v6) =\n     splits_at x3 x2 (sss x2 x3) (ss x2 x3) (sssa x2 x3)\n  Derives1 ?\\<delta> ?i ?r ?s \\<Longrightarrow>\n  \\<exists>\\<alpha> N \\<beta>. splits_at ?\\<delta> ?i \\<alpha> N \\<beta>\n\ngoal (1 subgoal):\n 1. \\<forall>ssa n p ssb.\n       \\<not> Derives1 ssa n p ssb \\<or>\n       splits_at ssa n (sss n ssa) (ss n ssa) (sssa n ssa)", "by presburger"], ["proof (state)\nthis:\n  \\<forall>ssa n p ssb.\n     \\<not> Derives1 ssa n p ssb \\<or>\n     splits_at ssa n (sss n ssa) (ss n ssa) (sssa n ssa)\n\ngoal (1 subgoal):\n 1. \\<beta> =\n    Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n] \\<Longrightarrow>\n    \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L", "then"], ["proof (chain)\npicking this:\n  \\<forall>ssa n p ssb.\n     \\<not> Derives1 ssa n p ssb \\<or>\n     splits_at ssa n (sss n ssa) (ss n ssa) (sssa n ssa)", "have \"\\<beta> = sss (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1) @ snd (snd (D ! n)) @ sssa (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1)\""], ["proof (prove)\nusing this:\n  \\<forall>ssa n p ssb.\n     \\<not> Derives1 ssa n p ssb \\<or>\n     splits_at ssa n (sss n ssa) (ss n ssa) (sssa n ssa)\n\ngoal (1 subgoal):\n 1. \\<beta> =\n    sss (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1) @\n    snd (snd (D ! n)) @ sssa (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1)", "by (meson LeftDerives1_implies_Derives1 \\<beta> splits_at_combine_dest)"], ["proof (state)\nthis:\n  \\<beta> =\n  sss (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1) @\n  snd (snd (D ! n)) @ sssa (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1)\n\ngoal (1 subgoal):\n 1. \\<beta> =\n    Derive (ladder_\\<alpha> \\<alpha> D L 1) [D ! n] \\<Longrightarrow>\n    \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L", "then"], ["proof (chain)\npicking this:\n  \\<beta> =\n  sss (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1) @\n  snd (snd (D ! n)) @ sssa (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> =\n  sss (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1) @\n  snd (snd (D ! n)) @ sssa (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1)\n\ngoal (1 subgoal):\n 1. \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L", "using f1"], ["proof (prove)\nusing this:\n  \\<beta> =\n  sss (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1) @\n  snd (snd (D ! n)) @ sssa (ladder_i L 1) (ladder_\\<alpha> \\<alpha> D L 1)\n  \\<forall>ssa n p ssb.\n     \\<not> Derives1 ssa n p ssb \\<or>\n     splits_at ssa n (sss n ssa) (ss n ssa) (sssa n ssa)\n\ngoal (1 subgoal):\n 1. \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L", "by (metis (no_types) LeftDerives1_implies_Derives1 \\<beta> ladder_stepdown_\\<alpha>_0_altdef ldl length_L n)"], ["proof (state)\nthis:\n  \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "have ladder_i_L'_0: \"ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1", "using L' ladder_stepdown_i_0 length_L"], ["proof (prove)\nusing this:\n  L' = ladder_stepdown L\n  1 < length ?L \\<Longrightarrow>\n  ladder_i (ladder_stepdown ?L) 0 = ladder_i ?L 1 + ladder_ix ?L 1\n  1 < length L\n\ngoal (1 subgoal):\n 1. ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1", "by blast"], ["proof (state)\nthis:\n  ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "have derivation_eq: \"(take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D)) = \n      (drop (Suc n) (take m D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D) =\n    drop (Suc n) (take m D)", "using n m"], ["proof (prove)\nusing this:\n  n = ladder_n L 0\n  m = ladder_n L 1\n\ngoal (1 subgoal):\n 1. take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D) =\n    drop (Suc n) (take m D)", "by (metis L' L'_nonempty One_nat_def drop_take ladder_stepdown_diff_def ladder_stepdown_n\n        length_L length_greater_0_conv)"], ["proof (state)\nthis:\n  take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D) =\n  drop (Suc n) (take m D)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "have ladder_j_L'_0: \"ladder_j L' 0 = ladder_j L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' 0 = ladder_j L 1", "using L' L'_nonempty ladder_stepdown_j length_L"], ["proof (prove)\nusing this:\n  L' = ladder_stepdown L\n  L' \\<noteq> []\n  \\<lbrakk>1 < length ?L; ?L' = ladder_stepdown ?L;\n   ?index < length ?L'\\<rbrakk>\n  \\<Longrightarrow> ladder_j ?L' ?index = ladder_j ?L (Suc ?index)\n  1 < length L\n\ngoal (1 subgoal):\n 1. ladder_j L' 0 = ladder_j L 1", "by auto"], ["proof (state)\nthis:\n  ladder_j L' 0 = ladder_j L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "have ladder_\\<gamma>: \"(ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (drop (ladder_stepdown_diff L) D) L' 0) =\n      ladder_\\<gamma> \\<alpha> D L 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' 0 =\n    ladder_\\<gamma> \\<alpha> D L 1", "by (metis Derivation_take_derive Derivation_unique_dest LeftDerivationFix_def \n        LeftDerivation_implies_Derivation \\<beta> \\<beta>_def derivation_eq ladder_\\<gamma>_def ldl1)"], ["proof (state)\nthis:\n  ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' 0 =\n  ladder_\\<gamma> \\<alpha> D L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "from \\<beta>_def \\<beta> ladder_i_L'_0 derivation_eq ladder_j_L'_0 ladder_\\<gamma>"], ["proof (chain)\npicking this:\n  \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L\n  LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) (snd (D ! n))\n   \\<beta> \\<and>\n  ladder_ix L 1 < length (snd (snd (D ! n))) \\<and>\n  snd (snd (D ! n)) ! ladder_ix L 1 =\n  ladder_\\<gamma> \\<alpha> D L 1 ! ladder_j L 1 \\<and>\n  LeftDerivationFix \\<beta> (ladder_i L 1 + ladder_ix L 1)\n   (drop (Suc n) (take m D)) (ladder_j L 1) (ladder_\\<gamma> \\<alpha> D L 1)\n  ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1\n  take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D) =\n  drop (Suc n) (take m D)\n  ladder_j L' 0 = ladder_j L 1\n  ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' 0 =\n  ladder_\\<gamma> \\<alpha> D L 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> = ladder_stepdown_\\<alpha>_0 \\<alpha> D L\n  LeftDerives1 (ladder_\\<alpha> \\<alpha> D L 1) (ladder_i L 1) (snd (D ! n))\n   \\<beta> \\<and>\n  ladder_ix L 1 < length (snd (snd (D ! n))) \\<and>\n  snd (snd (D ! n)) ! ladder_ix L 1 =\n  ladder_\\<gamma> \\<alpha> D L 1 ! ladder_j L 1 \\<and>\n  LeftDerivationFix \\<beta> (ladder_i L 1 + ladder_ix L 1)\n   (drop (Suc n) (take m D)) (ladder_j L 1) (ladder_\\<gamma> \\<alpha> D L 1)\n  ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1\n  take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D) =\n  drop (Suc n) (take m D)\n  ladder_j L' 0 = ladder_j L 1\n  ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' 0 =\n  ladder_\\<gamma> \\<alpha> D L 1\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (ladder_i L' 0) (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n   (ladder_j L' 0)\n   (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (ladder_i L' 0) (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n   (ladder_j L' 0)\n   (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' 0)\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "{"], ["proof (state)\nthis:\n  LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (ladder_i L' 0) (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n   (ladder_j L' 0)\n   (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' 0)\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "assume index_lower_bound: \"Suc 0 \\<le> index\""], ["proof (state)\nthis:\n  Suc 0 \\<le> index\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "assume index_upper_bound: \"index < length L'\""], ["proof (state)\nthis:\n  index < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  index < length L'", "have Suc_index_upper_bound: \"Suc index < length L\""], ["proof (prove)\nusing this:\n  index < length L'\n\ngoal (1 subgoal):\n 1. Suc index < length L", "using L' Suc_diff_Suc Suc_less_eq diff_Suc_1 ladder_stepdown_length length_L less_Suc_eq"], ["proof (prove)\nusing this:\n  index < length L'\n  L' = ladder_stepdown L\n  ?n < ?m \\<Longrightarrow> Suc (?m - Suc ?n) = ?m - ?n\n  (Suc ?m < Suc ?n) = (?m < ?n)\n  Suc ?n - 1 = ?n\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. Suc index < length L", "by auto"], ["proof (state)\nthis:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  Suc index < length L", "have intros_at_Suc_index: \"LeftDerivationIntrosAt \\<alpha> D L (Suc index)\""], ["proof (prove)\nusing this:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> D L (Suc index)", "by (metis LeftDerivationIntros_def LeftDerivationLadder_def Suc_eq_plus1_left ldl le_add1)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt \\<alpha> D L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "from iffD1[OF LeftDerivationIntrosAt_def this]"], ["proof (chain)\npicking this:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>", "have ldintro:\n      \"let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc index); i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n       ix = ladder_ix L (Suc index); \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc index); n = ladder_n L (Suc index - 1);\n       m = ladder_n L (Suc index); e = D ! n; E = drop (Suc n) (take m D)\n       in i = fst e \\<and> LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\""], ["proof (prove)\nusing this:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n\ngoal (1 subgoal):\n 1. let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc index);\n        i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n        ix = ladder_ix L (Suc index);\n        \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc index);\n        n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index);\n        e = D ! n; E = drop (Suc n) (take m D)\n    in i = fst e \\<and>\n       LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>", "by blast"], ["proof (state)\nthis:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have index_minus_Suc_0_bound: \"index - Suc 0 < length L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index - Suc 0 < length L'", "by (simp add: index_upper_bound less_imp_diff_less)"], ["proof (state)\nthis:\n  index - Suc 0 < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "note helpers = length_L L' index_minus_Suc_0_bound"], ["proof (state)\nthis:\n  1 < length L\n  L' = ladder_stepdown L\n  index - Suc 0 < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have ladder_i_L'_index:\n      \"ladder_i L' index = fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L' index =\n    fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))", "apply (auto simp add: ladder_i_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_i (hd L') = fst (drop (ladder_stepdown_diff L) D ! ladder_n L' 0)\n 2. 0 < index \\<Longrightarrow>\n    ladder_j L' (index - Suc 0) =\n    fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))", "using index_lower_bound"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_i (hd L') = fst (drop (ladder_stepdown_diff L) D ! ladder_n L' 0)\n 2. 0 < index \\<Longrightarrow>\n    ladder_j L' (index - Suc 0) =\n    fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_j L' (index - Suc 0) =\n    fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))", "apply (simp add: ladder_stepdown_n[OF helpers] ladder_stepdown_j[OF helpers])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_j L index =\n    fst (drop (ladder_stepdown_diff L) D !\n         (ladder_n L index - ladder_stepdown_diff L))", "apply (subst drop_at_shift)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < index \\<Longrightarrow>\n    ladder_stepdown_diff L \\<le> ladder_n L index\n 2. 0 < index \\<Longrightarrow> ladder_n L index < length D\n 3. 0 < index \\<Longrightarrow>\n    ladder_j L index = fst (D ! ladder_n L index)", "using LeftDerivationLadder_def Suc_index_upper_bound Suc_leI Suc_lessD is_ladder_def \n        ladder_stepdown_diff_def ldl"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  Suc index < length L\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  ladder_stepdown_diff ?L = Suc (ladder_n ?L 0)\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n\ngoal (3 subgoals):\n 1. 0 < index \\<Longrightarrow>\n    ladder_stepdown_diff L \\<le> ladder_n L index\n 2. 0 < index \\<Longrightarrow> ladder_n L index < length D\n 3. 0 < index \\<Longrightarrow>\n    ladder_j L index = fst (D ! ladder_n L index)", "apply presburger"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < index \\<Longrightarrow> ladder_n L index < length D\n 2. 0 < index \\<Longrightarrow>\n    ladder_j L index = fst (D ! ladder_n L index)", "apply (metis LeftDerivationLadder_def One_nat_def Suc_eq_plus1 Suc_index_upper_bound \n        add.commute add_diff_cancel_right' ladder_n_minus_1_bound ldl le_add1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    ladder_j L index = fst (D ! ladder_n L index)", "by (metis LeftDerivationIntrosAt_def intros_at_Suc_index diff_Suc_1 ladder_i_def nat.simps(3))"], ["proof (state)\nthis:\n  ladder_i L' index =\n  fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have intro_at_index: \n      \"LeftDerivationIntro (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (drop (ladder_stepdown_diff L) D) L' index)\n       (ladder_i L' index) (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n       (ladder_ix L' index)\n       (drop (Suc (ladder_n L' (index - Suc 0)))\n         (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n       (ladder_j L' index) (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) \n         (drop (ladder_stepdown_diff L) D) L' index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have arg1: \"(ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) \n        (drop (ladder_stepdown_diff L) D) L' index) = ladder_\\<alpha> \\<alpha> D L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index =\n    ladder_\\<alpha> \\<alpha> D L (Suc index)", "apply (auto simp add: ladder_\\<alpha>_def ladder_\\<gamma>_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    Derive \\<alpha> (take (ladder_n L 0) D)\n 2. 0 < index \\<Longrightarrow>\n    Derive (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (take (ladder_n L' (index - Suc 0))\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L index) D)", "using index_lower_bound"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_stepdown_\\<alpha>_0 \\<alpha> D L =\n    Derive \\<alpha> (take (ladder_n L 0) D)\n 2. 0 < index \\<Longrightarrow>\n    Derive (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (take (ladder_n L' (index - Suc 0))\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L index) D)", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    Derive (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (take (ladder_n L' (index - Suc 0))\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L index) D)", "apply (simp add: ladder_stepdown_n[OF helpers] ladder_stepdown_\\<alpha>_0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    Derive (Derive \\<alpha> (take (ladder_stepdown_diff L) D))\n     (take (ladder_n L index - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L index) D)", "apply (subst Derive_Derive[where \\<gamma>=\"ladder_\\<gamma> \\<alpha> D L index\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < index \\<Longrightarrow>\n    Derivation \\<alpha>\n     (take (ladder_stepdown_diff L) D @\n      take (ladder_n L index - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D))\n     (ladder_\\<gamma> \\<alpha> D L index)\n 2. 0 < index \\<Longrightarrow>\n    Derive \\<alpha>\n     (take (ladder_stepdown_diff L) D @\n      take (ladder_n L index - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L index) D)", "apply (metis (no_types, lifting) Derivation_take_derive LeftDerivationLadder_def \n          LeftDerivation_implies_Derivation Suc_index_upper_bound Suc_leI Suc_lessD \n          add.commute is_ladder_def ladder_\\<gamma>_def ladder_stepdown_diff_def ldl \n          le_add_diff_inverse2 take_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < index \\<Longrightarrow>\n    Derive \\<alpha>\n     (take (ladder_stepdown_diff L) D @\n      take (ladder_n L index - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L index) D)", "by (metis LeftDerivationLadder_def Suc_index_upper_bound Suc_leI Suc_lessD add.commute \n          is_ladder_def ladder_stepdown_diff_def ldl le_add_diff_inverse2 take_add)"], ["proof (state)\nthis:\n  ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' index =\n  ladder_\\<alpha> \\<alpha> D L (Suc index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have arg2: \"ladder_i L' index = ladder_i L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L (Suc index)", "using L' index_lower_bound index_minus_Suc_0_bound ladder_i_def ladder_stepdown_j \n          length_L"], ["proof (prove)\nusing this:\n  L' = ladder_stepdown L\n  Suc 0 \\<le> index\n  index - Suc 0 < length L'\n  ladder_i ?L ?index =\n  (if ?index = 0 then deriv_i (hd ?L) else ladder_j ?L (?index - 1))\n  \\<lbrakk>1 < length ?L; ?L' = ladder_stepdown ?L;\n   ?index < length ?L'\\<rbrakk>\n  \\<Longrightarrow> ladder_j ?L' ?index = ladder_j ?L (Suc ?index)\n  1 < length L\n\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L (Suc index)", "by auto"], ["proof (state)\nthis:\n  ladder_i L' index = ladder_i L (Suc index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "obtain n where n: \"n = ladder_n L (Suc index - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n = ladder_n L (Suc index - 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = ladder_n L (Suc index - 1)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have arg3: \"(snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))) = \n        snd (D ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)) =\n    snd (D ! n)", "apply (simp add: ladder_stepdown_n[OF helpers] index_lower_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (drop (ladder_stepdown_diff L) D !\n         (ladder_n L (Suc (index - Suc 0)) - ladder_stepdown_diff L)) =\n    snd (D ! n)", "apply (subst drop_at_shift)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ladder_stepdown_diff L \\<le> ladder_n L (Suc (index - Suc 0))\n 2. ladder_n L (Suc (index - Suc 0)) < length D\n 3. snd (D ! ladder_n L (Suc (index - Suc 0))) = snd (D ! n)", "using index_lower_bound"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n\ngoal (3 subgoals):\n 1. ladder_stepdown_diff L \\<le> ladder_n L (Suc (index - Suc 0))\n 2. ladder_n L (Suc (index - Suc 0)) < length D\n 3. snd (D ! ladder_n L (Suc (index - Suc 0))) = snd (D ! n)", "apply (metis (no_types, hide_lams) L' LeftDerivationLadder_def One_nat_def Suc_eq_plus1 \n          add.commute diff_Suc_1 index_upper_bound is_ladder_def ladder_stepdown_diff_def \n          ladder_stepdown_length ldl le_add_diff_inverse2 length_L less_or_eq_imp_le n \n          nat.simps(3) neq0_conv not_less not_less_eq_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_n L (Suc (index - Suc 0)) < length D\n 2. snd (D ! ladder_n L (Suc (index - Suc 0))) = snd (D ! n)", "using index_lower_bound"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n\ngoal (2 subgoals):\n 1. ladder_n L (Suc (index - Suc 0)) < length D\n 2. snd (D ! ladder_n L (Suc (index - Suc 0))) = snd (D ! n)", "apply (metis LeftDerivationLadder_def One_nat_def Suc_index_upper_bound Suc_le_lessD \n          Suc_pred diff_Suc_1 ladder_n_minus_1_bound ldl le_imp_less_Suc less_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (D ! ladder_n L (Suc (index - Suc 0))) = snd (D ! n)", "using index_lower_bound n"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n  n = ladder_n L (Suc index - 1)\n\ngoal (1 subgoal):\n 1. snd (D ! ladder_n L (Suc (index - Suc 0))) = snd (D ! n)", "by (simp add: Suc_diff_le)"], ["proof (state)\nthis:\n  snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)) =\n  snd (D ! n)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have arg4: \"ladder_ix L' index = ladder_ix L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "using ladder_stepdown_ix L' Suc_le_lessD index_lower_bound index_upper_bound length_L"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length ?L; ?L' = ladder_stepdown ?L; 0 < ?index;\n   ?index < length ?L'\\<rbrakk>\n  \\<Longrightarrow> ladder_ix ?L' ?index = ladder_ix ?L (Suc ?index)\n  L' = ladder_stepdown L\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m < ?n\n  Suc 0 \\<le> index\n  index < length L'\n  1 < length L\n\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L (Suc index)", "by auto"], ["proof (state)\nthis:\n  ladder_ix L' index = ladder_ix L (Suc index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "obtain m where m: \"m = ladder_n L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m = ladder_n L (Suc index) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = ladder_n L (Suc index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have Suc_index_Suc: \"Suc (index - Suc 0) = index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (index - Suc 0) = index", "using index_lower_bound"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n\ngoal (1 subgoal):\n 1. Suc (index - Suc 0) = index", "by arith"], ["proof (state)\nthis:\n  Suc (index - Suc 0) = index\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have arg5: \"(drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) \n        (drop (ladder_stepdown_diff L) D))) = drop (Suc n) (take m D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L' (index - Suc 0)))\n     (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)) =\n    drop (Suc n) (take m D)", "apply (simp add: ladder_stepdown_n[OF helpers] \n          ladder_stepdown_n[OF length_L L' index_upper_bound] n m Suc_index_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L index - ladder_stepdown_diff L))\n     (take (ladder_n L (Suc index) - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D)) =\n    drop (Suc (ladder_n L index)) (take (ladder_n L (Suc index)) D)", "by (metis (no_types, lifting) LeftDerivationLadder_def Suc_eq_plus1_left \n          Suc_index_upper_bound Suc_leI Suc_le_lessD Suc_lessD drop_drop drop_take \n          index_lower_bound is_ladder_def ladder_stepdown_diff_def ldl le_add_diff_inverse2)"], ["proof (state)\nthis:\n  drop (Suc (ladder_n L' (index - Suc 0)))\n   (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)) =\n  drop (Suc n) (take m D)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have arg6: \"ladder_j L' index = ladder_j L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "using L' index_upper_bound ladder_stepdown_j length_L"], ["proof (prove)\nusing this:\n  L' = ladder_stepdown L\n  index < length L'\n  \\<lbrakk>1 < length ?L; ?L' = ladder_stepdown ?L;\n   ?index < length ?L'\\<rbrakk>\n  \\<Longrightarrow> ladder_j ?L' ?index = ladder_j ?L (Suc ?index)\n  1 < length L\n\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L (Suc index)", "by blast"], ["proof (state)\nthis:\n  ladder_j L' index = ladder_j L (Suc index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "have arg7: \"(ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) \n         (drop (ladder_stepdown_diff L) D) L' index) = ladder_\\<gamma> \\<alpha> D L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index =\n    ladder_\\<gamma> \\<alpha> D L (Suc index)", "apply (simp add: ladder_\\<gamma>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L (Suc index)) D)", "apply (simp add: ladder_stepdown_n[OF length_L L' index_upper_bound] ladder_stepdown_\\<alpha>_0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive (Derive \\<alpha> (take (ladder_stepdown_diff L) D))\n     (take (ladder_n L (Suc index) - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L (Suc index)) D)", "apply (subst Derive_Derive[where \\<gamma>=\"ladder_\\<gamma> \\<alpha> D L (Suc index)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Derivation \\<alpha>\n     (take (ladder_stepdown_diff L) D @\n      take (ladder_n L (Suc index) - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D))\n     (ladder_\\<gamma> \\<alpha> D L (Suc index))\n 2. Derive \\<alpha>\n     (take (ladder_stepdown_diff L) D @\n      take (ladder_n L (Suc index) - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L (Suc index)) D)", "apply (metis (no_types, lifting) L' LeftDerivationLadder_def \n          LeftDerivation_implies_Derivation LeftDerivation_take_derive Suc_le_lessD \n          add_diff_inverse_nat diff_is_0_eq index_lower_bound index_upper_bound is_ladder_L' \n          is_ladder_def ladder_\\<gamma>_def ladder_stepdown_n ldl le_0_eq length_L less_numeral_extra(3) \n          less_or_eq_imp_le take_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Derive \\<alpha>\n     (take (ladder_stepdown_diff L) D @\n      take (ladder_n L (Suc index) - ladder_stepdown_diff L)\n       (drop (ladder_stepdown_diff L) D)) =\n    Derive \\<alpha> (take (ladder_n L (Suc index)) D)", "by (metis (no_types, lifting) L' One_nat_def add_diff_inverse_nat diff_is_0_eq \n          index_lower_bound index_upper_bound is_ladder_L' is_ladder_def ladder_stepdown_n le_0_eq \n          le_neq_implies_less length_L less_numeral_extra(3) less_or_eq_imp_le take_add zero_less_one)"], ["proof (state)\nthis:\n  ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' index =\n  ladder_\\<gamma> \\<alpha> D L (Suc index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "from ldintro arg1 arg2 arg3 arg4 arg5 arg6 arg7"], ["proof (chain)\npicking this:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n  ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' index =\n  ladder_\\<alpha> \\<alpha> D L (Suc index)\n  ladder_i L' index = ladder_i L (Suc index)\n  snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)) =\n  snd (D ! n)\n  ladder_ix L' index = ladder_ix L (Suc index)\n  drop (Suc (ladder_n L' (index - Suc 0)))\n   (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)) =\n  drop (Suc n) (take m D)\n  ladder_j L' index = ladder_j L (Suc index)\n  ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' index =\n  ladder_\\<gamma> \\<alpha> D L (Suc index)", "show ?thesis"], ["proof (prove)\nusing this:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n  ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' index =\n  ladder_\\<alpha> \\<alpha> D L (Suc index)\n  ladder_i L' index = ladder_i L (Suc index)\n  snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)) =\n  snd (D ! n)\n  ladder_ix L' index = ladder_ix L (Suc index)\n  drop (Suc (ladder_n L' (index - Suc 0)))\n   (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)) =\n  drop (Suc n) (take m D)\n  ladder_j L' index = ladder_j L (Suc index)\n  ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' index =\n  ladder_\\<gamma> \\<alpha> D L (Suc index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "by (metis m n)"], ["proof (state)\nthis:\n  LeftDerivationIntro\n   (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index)\n   (ladder_i L' index)\n   (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n   (ladder_ix L' index)\n   (drop (Suc (ladder_n L' (index - Suc 0)))\n     (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n   (ladder_j L' index)\n   (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivationIntro\n   (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index)\n   (ladder_i L' index)\n   (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n   (ladder_ix L' index)\n   (drop (Suc (ladder_n L' (index - Suc 0)))\n     (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n   (ladder_j L' index)\n   (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "have \"LeftDerivationIntrosAt (ladder_stepdown_\\<alpha>_0 \\<alpha> D L) (drop (ladder_stepdown_diff L) D) \n      L' index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index", "apply (auto simp add: LeftDerivationIntrosAt_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_i L' index =\n    fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))\n 2. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "using ladder_i_L'_index"], ["proof (prove)\nusing this:\n  ladder_i L' index =\n  fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))\n\ngoal (2 subgoals):\n 1. ladder_i L' index =\n    fst (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0))\n 2. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "using intro_at_index"], ["proof (prove)\nusing this:\n  LeftDerivationIntro\n   (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index)\n   (ladder_i L' index)\n   (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n   (ladder_ix L' index)\n   (drop (Suc (ladder_n L' (index - Suc 0)))\n     (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n   (ladder_j L' index)\n   (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)\n     (ladder_i L' index)\n     (snd (drop (ladder_stepdown_diff L) D ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) (drop (ladder_stepdown_diff L) D)))\n     (ladder_j L' index)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' index)", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) L' index\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Suc 0 \\<le> ?index2; ?index2 < length L'\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt\n                     (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n                     (drop (ladder_stepdown_diff L) D) L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "note introsAt = this"], ["proof (state)\nthis:\n  \\<lbrakk>Suc 0 \\<le> ?index2; ?index2 < length L'\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt\n                     (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n                     (drop (ladder_stepdown_diff L) D) L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n        (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n       length L' = length L - 1 \\<and>\n       ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n       ladder_last_j L' = ladder_last_j L", "apply (rule_tac x=\"L'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n    length L' = length L - 1 \\<and>\n    ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n    ladder_last_j L' = ladder_last_j L", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>\n 2. length L' = length L - Suc 0\n 3. ladder_i L' 0 = ladder_i L (Suc 0) + ladder_ix L (Suc 0)\n 4. ladder_last_j L' = ladder_last_j L", "defer 1"], ["proof (prove)\ngoal (4 subgoals):\n 1. length L' = length L - Suc 0\n 2. ladder_i L' 0 = ladder_i L (Suc 0) + ladder_ix L (Suc 0)\n 3. ladder_last_j L' = ladder_last_j L\n 4. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>", "using L' ladder_stepdown_length length_L"], ["proof (prove)\nusing this:\n  L' = ladder_stepdown L\n  1 < length ?L \\<Longrightarrow>\n  length (ladder_stepdown ?L) = length ?L - 1\n  1 < length L\n\ngoal (4 subgoals):\n 1. length L' = length L - Suc 0\n 2. ladder_i L' 0 = ladder_i L (Suc 0) + ladder_ix L (Suc 0)\n 3. ladder_last_j L' = ladder_last_j L\n 4. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. ladder_i L' 0 = ladder_i L (Suc 0) + ladder_ix L (Suc 0)\n 2. ladder_last_j L' = ladder_last_j L\n 3. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>", "using ladder_stepdown_i_0 length_L L'"], ["proof (prove)\nusing this:\n  1 < length ?L \\<Longrightarrow>\n  ladder_i (ladder_stepdown ?L) 0 = ladder_i ?L 1 + ladder_ix ?L 1\n  1 < length L\n  L' = ladder_stepdown L\n\ngoal (3 subgoals):\n 1. ladder_i L' 0 = ladder_i L (Suc 0) + ladder_ix L (Suc 0)\n 2. ladder_last_j L' = ladder_last_j L\n 3. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_last_j L' = ladder_last_j L\n 2. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>", "using ladder_stepdown_last_j L' length_L"], ["proof (prove)\nusing this:\n  1 < length ?L \\<Longrightarrow>\n  ladder_last_j (ladder_stepdown ?L) = ladder_last_j ?L\n  L' = ladder_stepdown L\n  1 < length L\n\ngoal (2 subgoals):\n 1. ladder_last_j L' = ladder_last_j L\n 2. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' \\<gamma>", "apply (auto simp add: LeftDerivationLadder_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>\n 2. is_ladder (drop (ladder_stepdown_diff L) D) L'\n 3. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)\n 4. LeftDerivationIntros (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L'", "using ldl1"], ["proof (prove)\nusing this:\n  LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (drop (ladder_stepdown_diff L) D) \\<gamma>\n\ngoal (4 subgoals):\n 1. LeftDerivation (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) \\<gamma>\n 2. is_ladder (drop (ladder_stepdown_diff L) D) L'\n 3. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)\n 4. LeftDerivationIntros (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L'", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_ladder (drop (ladder_stepdown_diff L) D) L'\n 2. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)\n 3. LeftDerivationIntros (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L'", "using is_ladder_L'"], ["proof (prove)\nusing this:\n  is_ladder (drop (ladder_stepdown_diff L) D) L'\n\ngoal (3 subgoals):\n 1. is_ladder (drop (ladder_stepdown_diff L) D) L'\n 2. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)\n 3. LeftDerivationIntros (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)\n 2. LeftDerivationIntros (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L'", "using ldfix"], ["proof (prove)\nusing this:\n  LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n   (ladder_i L' 0) (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n   (ladder_j L' 0)\n   (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L' 0)\n\ngoal (2 subgoals):\n 1. LeftDerivationFix (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (ladder_i L' 0)\n     (take (ladder_n L' 0) (drop (ladder_stepdown_diff L) D))\n     (ladder_j L' 0)\n     (ladder_\\<gamma> (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n       (drop (ladder_stepdown_diff L) D) L' 0)\n 2. LeftDerivationIntros (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntros (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n     (drop (ladder_stepdown_diff L) D) L'", "apply (auto simp add: LeftDerivationIntros_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>Suc 0 \\<le> index; index < length L'\\<rbrakk>\n       \\<Longrightarrow> LeftDerivationIntrosAt\n                          (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n                          (drop (ladder_stepdown_diff L) D) L' index", "apply (simp add: introsAt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>L'.\n     LeftDerivationLadder (ladder_stepdown_\\<alpha>_0 \\<alpha> D L)\n      (drop (ladder_stepdown_diff L) D) L' \\<gamma> \\<and>\n     length L' = length L - 1 \\<and>\n     ladder_i L' 0 = ladder_i L 1 + ladder_ix L 1 \\<and>\n     ladder_last_j L' = ladder_last_j L\n\ngoal:\nNo subgoals!", "qed"], ["", "fun ladder_shift_j :: \"nat \\<Rightarrow> ladder \\<Rightarrow> ladder\" where \n  \"ladder_shift_j d [] = []\"\n| \"ladder_shift_j d ((n, j, i)#L) = ((n, j - d, i)#(ladder_shift_j d L))\""], ["", "definition ladder_cut_prefix :: \"nat \\<Rightarrow> ladder \\<Rightarrow> ladder\"\nwhere\n  \"ladder_cut_prefix d L = \n    (ladder_shift_j d L)[0 := (ladder_n L 0, ladder_j L 0 - d, ladder_i L 0 - d)]\""], ["", "lemma ladder_shift_j_length: \n  \"length (ladder_shift_j d L) = length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ladder_shift_j d L) = length L", "by (induct L, auto)"], ["", "lemma ladder_cut_prefix_length:\n  shows \"length (ladder_cut_prefix d L) = length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ladder_cut_prefix d L) = length L", "apply (simp add: ladder_cut_prefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ladder_shift_j d L) = length L", "apply (simp add: ladder_shift_j_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ladder_shift_j_cons: \"ladder_shift_j d (x#L) = (fst x, fst (snd x) - d, snd(snd x))#\n  (ladder_shift_j d L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_shift_j d (x # L) =\n    (fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L", "apply (induct L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_shift_j d [x] =\n    (fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d []\n 2. \\<And>a L.\n       ladder_shift_j d (x # L) =\n       (fst x, fst (snd x) - d, snd (snd x)) #\n       ladder_shift_j d L \\<Longrightarrow>\n       ladder_shift_j d (x # a # L) =\n       (fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d (a # L)", "by (cases x, simp)+"], ["", "lemma deriv_j_ladder_shift_j: \n  \"index < length L \\<Longrightarrow> deriv_j (ladder_shift_j d L ! index) = deriv_j (L ! index) - d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L \\<Longrightarrow>\n    deriv_j (ladder_shift_j d L ! index) = deriv_j (L ! index) - d", "proof (induct L arbitrary: index)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       deriv_j (ladder_shift_j d [] ! index) = deriv_j ([] ! index) - d\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_j (ladder_shift_j d L ! index) =\n                   deriv_j (L ! index) - d;\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_j (ladder_shift_j d (a # L) ! index) =\n                         deriv_j ((a # L) ! index) - d", "case Nil"], ["proof (state)\nthis:\n  index < length []\n\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       deriv_j (ladder_shift_j d [] ! index) = deriv_j ([] ! index) - d\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_j (ladder_shift_j d L ! index) =\n                   deriv_j (L ! index) - d;\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_j (ladder_shift_j d (a # L) ! index) =\n                         deriv_j ((a # L) ! index) - d", "then"], ["proof (chain)\npicking this:\n  index < length []", "show ?case"], ["proof (prove)\nusing this:\n  index < length []\n\ngoal (1 subgoal):\n 1. deriv_j (ladder_shift_j d [] ! index) = deriv_j ([] ! index) - d", "by auto"], ["proof (state)\nthis:\n  deriv_j (ladder_shift_j d [] ! index) = deriv_j ([] ! index) - d\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_j (ladder_shift_j d L ! index) =\n                   deriv_j (L ! index) - d;\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_j (ladder_shift_j d (a # L) ! index) =\n                         deriv_j ((a # L) ! index) - d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_j (ladder_shift_j d L ! index) =\n                   deriv_j (L ! index) - d;\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_j (ladder_shift_j d (a # L) ! index) =\n                         deriv_j ((a # L) ! index) - d", "case (Cons x L)"], ["proof (state)\nthis:\n  ?index < length L \\<Longrightarrow>\n  deriv_j (ladder_shift_j d L ! ?index) = deriv_j (L ! ?index) - d\n  index < length (x # L)\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_j (ladder_shift_j d L ! index) =\n                   deriv_j (L ! index) - d;\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_j (ladder_shift_j d (a # L) ! index) =\n                         deriv_j ((a # L) ! index) - d", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_j (ladder_shift_j d (x # L) ! index) =\n    deriv_j ((x # L) ! index) - d", "apply (subst ladder_shift_j_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_j\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_j ((x # L) ! index) - d", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_j\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_j ((x # L) ! index) - d\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j\n        (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n         index) =\n       deriv_j ((x # L) ! index) - d", "using Cons"], ["proof (prove)\nusing this:\n  ?index < length L \\<Longrightarrow>\n  deriv_j (ladder_shift_j d L ! ?index) = deriv_j (L ! ?index) - d\n  index < length (x # L)\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_j\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_j ((x # L) ! index) - d\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j\n        (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n         index) =\n       deriv_j ((x # L) ! index) - d", "by (auto simp add: deriv_j_def)"], ["proof (state)\nthis:\n  deriv_j (ladder_shift_j d (x # L) ! index) = deriv_j ((x # L) ! index) - d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deriv_n_ladder_shift_j: \n  \"index < length L \\<Longrightarrow> deriv_n (ladder_shift_j d L ! index) = deriv_n (L ! index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L \\<Longrightarrow>\n    deriv_n (ladder_shift_j d L ! index) = deriv_n (L ! index)", "proof (induct L arbitrary: index)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       deriv_n (ladder_shift_j d [] ! index) = deriv_n ([] ! index)\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_n (ladder_shift_j d L ! index) =\n                   deriv_n (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_n (ladder_shift_j d (a # L) ! index) =\n                         deriv_n ((a # L) ! index)", "case Nil"], ["proof (state)\nthis:\n  index < length []\n\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       deriv_n (ladder_shift_j d [] ! index) = deriv_n ([] ! index)\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_n (ladder_shift_j d L ! index) =\n                   deriv_n (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_n (ladder_shift_j d (a # L) ! index) =\n                         deriv_n ((a # L) ! index)", "then"], ["proof (chain)\npicking this:\n  index < length []", "show ?case"], ["proof (prove)\nusing this:\n  index < length []\n\ngoal (1 subgoal):\n 1. deriv_n (ladder_shift_j d [] ! index) = deriv_n ([] ! index)", "by auto"], ["proof (state)\nthis:\n  deriv_n (ladder_shift_j d [] ! index) = deriv_n ([] ! index)\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_n (ladder_shift_j d L ! index) =\n                   deriv_n (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_n (ladder_shift_j d (a # L) ! index) =\n                         deriv_n ((a # L) ! index)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_n (ladder_shift_j d L ! index) =\n                   deriv_n (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_n (ladder_shift_j d (a # L) ! index) =\n                         deriv_n ((a # L) ! index)", "case (Cons x L)"], ["proof (state)\nthis:\n  ?index < length L \\<Longrightarrow>\n  deriv_n (ladder_shift_j d L ! ?index) = deriv_n (L ! ?index)\n  index < length (x # L)\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_n (ladder_shift_j d L ! index) =\n                   deriv_n (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_n (ladder_shift_j d (a # L) ! index) =\n                         deriv_n ((a # L) ! index)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n (ladder_shift_j d (x # L) ! index) = deriv_n ((x # L) ! index)", "apply (subst ladder_shift_j_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_n\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_n ((x # L) ! index)", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_n\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_n ((x # L) ! index)\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n\n        (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n         index) =\n       deriv_n ((x # L) ! index)", "using Cons"], ["proof (prove)\nusing this:\n  ?index < length L \\<Longrightarrow>\n  deriv_n (ladder_shift_j d L ! ?index) = deriv_n (L ! ?index)\n  index < length (x # L)\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_n\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_n ((x # L) ! index)\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n\n        (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n         index) =\n       deriv_n ((x # L) ! index)", "by (auto simp add: deriv_n_def)"], ["proof (state)\nthis:\n  deriv_n (ladder_shift_j d (x # L) ! index) = deriv_n ((x # L) ! index)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deriv_ix_ladder_shift_j: \n  \"index < length L \\<Longrightarrow> deriv_ix (ladder_shift_j d L ! index) = deriv_ix (L ! index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L \\<Longrightarrow>\n    deriv_ix (ladder_shift_j d L ! index) = deriv_ix (L ! index)", "proof (induct L arbitrary: index)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       deriv_ix (ladder_shift_j d [] ! index) = deriv_ix ([] ! index)\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_ix (ladder_shift_j d L ! index) =\n                   deriv_ix (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_ix (ladder_shift_j d (a # L) ! index) =\n                         deriv_ix ((a # L) ! index)", "case Nil"], ["proof (state)\nthis:\n  index < length []\n\ngoal (2 subgoals):\n 1. \\<And>index.\n       index < length [] \\<Longrightarrow>\n       deriv_ix (ladder_shift_j d [] ! index) = deriv_ix ([] ! index)\n 2. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_ix (ladder_shift_j d L ! index) =\n                   deriv_ix (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_ix (ladder_shift_j d (a # L) ! index) =\n                         deriv_ix ((a # L) ! index)", "then"], ["proof (chain)\npicking this:\n  index < length []", "show ?case"], ["proof (prove)\nusing this:\n  index < length []\n\ngoal (1 subgoal):\n 1. deriv_ix (ladder_shift_j d [] ! index) = deriv_ix ([] ! index)", "by auto"], ["proof (state)\nthis:\n  deriv_ix (ladder_shift_j d [] ! index) = deriv_ix ([] ! index)\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_ix (ladder_shift_j d L ! index) =\n                   deriv_ix (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_ix (ladder_shift_j d (a # L) ! index) =\n                         deriv_ix ((a # L) ! index)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_ix (ladder_shift_j d L ! index) =\n                   deriv_ix (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_ix (ladder_shift_j d (a # L) ! index) =\n                         deriv_ix ((a # L) ! index)", "case (Cons x L)"], ["proof (state)\nthis:\n  ?index < length L \\<Longrightarrow>\n  deriv_ix (ladder_shift_j d L ! ?index) = deriv_ix (L ! ?index)\n  index < length (x # L)\n\ngoal (1 subgoal):\n 1. \\<And>a L index.\n       \\<lbrakk>\\<And>index.\n                   index < length L \\<Longrightarrow>\n                   deriv_ix (ladder_shift_j d L ! index) =\n                   deriv_ix (L ! index);\n        index < length (a # L)\\<rbrakk>\n       \\<Longrightarrow> deriv_ix (ladder_shift_j d (a # L) ! index) =\n                         deriv_ix ((a # L) ! index)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_ix (ladder_shift_j d (x # L) ! index) = deriv_ix ((x # L) ! index)", "apply (subst ladder_shift_j_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_ix\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_ix ((x # L) ! index)", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_ix\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_ix ((x # L) ! index)\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_ix\n        (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n         index) =\n       deriv_ix ((x # L) ! index)", "using Cons"], ["proof (prove)\nusing this:\n  ?index < length L \\<Longrightarrow>\n  deriv_ix (ladder_shift_j d L ! ?index) = deriv_ix (L ! ?index)\n  index < length (x # L)\n\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_ix\n     (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n      index) =\n    deriv_ix ((x # L) ! index)\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_ix\n        (((fst x, fst (snd x) - d, snd (snd x)) # ladder_shift_j d L) !\n         index) =\n       deriv_ix ((x # L) ! index)", "by (auto simp add: deriv_ix_def)"], ["proof (state)\nthis:\n  deriv_ix (ladder_shift_j d (x # L) ! index) = deriv_ix ((x # L) ! index)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ladder_cut_prefix_j: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_j (ladder_cut_prefix d L) index = ladder_j L index - d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j (ladder_cut_prefix d L) index = ladder_j L index - d", "apply (simp add: ladder_j_def ladder_cut_prefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_j\n     ((ladder_shift_j d L)\n      [0 := (ladder_n L 0, deriv_j (L ! 0) - d, ladder_i L 0 - d)] !\n      index) =\n    deriv_j (L ! index) - d", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_j\n     ((ladder_shift_j d L)\n      [0 := (ladder_n L 0, deriv_j (L ! 0) - d, ladder_i L 0 - d)] !\n      index) =\n    deriv_j (L ! index) - d\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, deriv_j (L ! 0) - d, ladder_i L 0 - d)] !\n         index) =\n       deriv_j (L ! index) - d", "apply (auto simp add: length_L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_j\n     ((ladder_shift_j d L)\n      [0 := (ladder_n L 0, deriv_j (L ! 0) - d, ladder_i L 0 - d)] ! 0) =\n    deriv_j (L ! 0) - d\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j (ladder_shift_j d L ! Suc nat) = deriv_j (L ! Suc nat) - d", "apply (subst nth_list_update_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index = 0 \\<Longrightarrow> 0 < length (ladder_shift_j d L)\n 2. index = 0 \\<Longrightarrow>\n    deriv_j (ladder_n L 0, deriv_j (L ! 0) - d, ladder_i L 0 - d) =\n    deriv_j (L ! 0) - d\n 3. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j (ladder_shift_j d L ! Suc nat) = deriv_j (L ! Suc nat) - d", "apply (simp only: ladder_shift_j_length length_L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_j (ladder_n L 0, deriv_j (L ! 0) - d, ladder_i L 0 - d) =\n    deriv_j (L ! 0) - d\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j (ladder_shift_j d L ! Suc nat) = deriv_j (L ! Suc nat) - d", "apply (simp add: deriv_j_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j (ladder_shift_j d L ! Suc nat) = deriv_j (L ! Suc nat) - d", "apply (subst deriv_j_ladder_shift_j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> Suc nat < length L\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j (L ! Suc nat) - d = deriv_j (L ! Suc nat) - d", "using index_bound"], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (2 subgoals):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> Suc nat < length L\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j (L ! Suc nat) - d = deriv_j (L ! Suc nat) - d", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_j (L ! Suc nat) - d = deriv_j (L ! Suc nat) - d", "by blast"], ["", "lemma hd_0_subst: \"length L > 0 \\<Longrightarrow> hd (L [0 := x]) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length L \\<Longrightarrow> hd (L[0 := x]) = x", "using hd_conv_nth"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs = ?xs ! 0\n\ngoal (1 subgoal):\n 1. 0 < length L \\<Longrightarrow> hd (L[0 := x]) = x", "by (simp add: upd_conv_take_nth_drop)"], ["", "lemma ladder_cut_prefix_i: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_i (ladder_cut_prefix d L) index = ladder_i L index - d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i (ladder_cut_prefix d L) index = ladder_i L index - d", "apply (simp add: ladder_i_def ladder_cut_prefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index = 0 \\<longrightarrow>\n     deriv_i\n      (hd ((ladder_shift_j d L)\n           [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])) =\n     deriv_i (hd L) - d) \\<and>\n    (0 < index \\<longrightarrow>\n     ladder_j\n      ((ladder_shift_j d L)\n       [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])\n      (index - Suc 0) =\n     ladder_j L (index - Suc 0) - d)", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    (index = 0 \\<longrightarrow>\n     deriv_i\n      (hd ((ladder_shift_j d L)\n           [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])) =\n     deriv_i (hd L) - d) \\<and>\n    (0 < index \\<longrightarrow>\n     ladder_j\n      ((ladder_shift_j d L)\n       [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])\n      (index - Suc 0) =\n     ladder_j L (index - Suc 0) - d)\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       (index = 0 \\<longrightarrow>\n        deriv_i\n         (hd ((ladder_shift_j d L)\n              [0 := (ladder_n L 0, ladder_j L 0 - d,\n                     deriv_i (hd L) - d)])) =\n        deriv_i (hd L) - d) \\<and>\n       (0 < index \\<longrightarrow>\n        ladder_j\n         ((ladder_shift_j d L)\n          [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])\n         (index - Suc 0) =\n        ladder_j L (index - Suc 0) - d)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_i\n     (hd ((ladder_shift_j d L)\n          [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])) =\n    deriv_i (hd L) - d\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       (index = 0 \\<longrightarrow>\n        deriv_i\n         (hd ((ladder_shift_j d L)\n              [0 := (ladder_n L 0, ladder_j L 0 - d,\n                     deriv_i (hd L) - d)])) =\n        deriv_i (hd L) - d) \\<and>\n       (0 < index \\<longrightarrow>\n        ladder_j\n         ((ladder_shift_j d L)\n          [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])\n         (index - Suc 0) =\n        ladder_j L (index - Suc 0) - d)", "apply (subst hd_0_subst)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index = 0 \\<Longrightarrow> 0 < length (ladder_shift_j d L)\n 2. index = 0 \\<Longrightarrow>\n    deriv_i (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d) =\n    deriv_i (hd L) - d\n 3. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       (index = 0 \\<longrightarrow>\n        deriv_i\n         (hd ((ladder_shift_j d L)\n              [0 := (ladder_n L 0, ladder_j L 0 - d,\n                     deriv_i (hd L) - d)])) =\n        deriv_i (hd L) - d) \\<and>\n       (0 < index \\<longrightarrow>\n        ladder_j\n         ((ladder_shift_j d L)\n          [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])\n         (index - Suc 0) =\n        ladder_j L (index - Suc 0) - d)", "using length_L ladder_shift_j_length"], ["proof (prove)\nusing this:\n  0 < length L\n  length (ladder_shift_j ?d ?L) = length ?L\n\ngoal (3 subgoals):\n 1. index = 0 \\<Longrightarrow> 0 < length (ladder_shift_j d L)\n 2. index = 0 \\<Longrightarrow>\n    deriv_i (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d) =\n    deriv_i (hd L) - d\n 3. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       (index = 0 \\<longrightarrow>\n        deriv_i\n         (hd ((ladder_shift_j d L)\n              [0 := (ladder_n L 0, ladder_j L 0 - d,\n                     deriv_i (hd L) - d)])) =\n        deriv_i (hd L) - d) \\<and>\n       (0 < index \\<longrightarrow>\n        ladder_j\n         ((ladder_shift_j d L)\n          [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])\n         (index - Suc 0) =\n        ladder_j L (index - Suc 0) - d)", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_i (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d) =\n    deriv_i (hd L) - d\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       (index = 0 \\<longrightarrow>\n        deriv_i\n         (hd ((ladder_shift_j d L)\n              [0 := (ladder_n L 0, ladder_j L 0 - d,\n                     deriv_i (hd L) - d)])) =\n        deriv_i (hd L) - d) \\<and>\n       (0 < index \\<longrightarrow>\n        ladder_j\n         ((ladder_shift_j d L)\n          [0 := (ladder_n L 0, ladder_j L 0 - d, deriv_i (hd L) - d)])\n         (index - Suc 0) =\n        ladder_j L (index - Suc 0) - d)", "apply (auto simp add: deriv_i_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       ladder_j\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, snd (snd (hd L)) - d)])\n        nat =\n       ladder_j L nat - d", "apply (case_tac nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>index = Suc nat; nat = 0\\<rbrakk>\n       \\<Longrightarrow> ladder_j\n                          ((ladder_shift_j d L)\n                           [0 := (ladder_n L 0, ladder_j L 0 - d,\n                                  snd (snd (hd L)) - d)])\n                          nat =\n                         ladder_j L nat - d\n 2. \\<And>nat nata.\n       \\<lbrakk>index = Suc nat; nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> ladder_j\n                          ((ladder_shift_j d L)\n                           [0 := (ladder_n L 0, ladder_j L 0 - d,\n                                  snd (snd (hd L)) - d)])\n                          nat =\n                         ladder_j L nat - d", "apply (simp add: ladder_j_def deriv_j_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>index = Suc 0; nat = 0\\<rbrakk>\n       \\<Longrightarrow> fst (snd ((ladder_shift_j d L)\n                                   [0 :=\n(ladder_n L 0, fst (snd (L ! 0)) - d, snd (snd (hd L)) - d)] !\n                                   0)) =\n                         fst (snd (L ! 0)) - d\n 2. \\<And>nat nata.\n       \\<lbrakk>index = Suc nat; nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> ladder_j\n                          ((ladder_shift_j d L)\n                           [0 := (ladder_n L 0, ladder_j L 0 - d,\n                                  snd (snd (hd L)) - d)])\n                          nat =\n                         ladder_j L nat - d", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = Suc 0 \\<Longrightarrow>\n    fst (snd ((ladder_shift_j d L)\n              [0 := (ladder_n L 0, fst (snd (L ! 0)) - d,\n                     snd (snd (hd L)) - d)] !\n              0)) =\n    fst (snd (L ! 0)) - d\n 2. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       ladder_j\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, snd (snd (hd L)) - d)])\n        (Suc nata) =\n       ladder_j L (Suc nata) - d", "apply (subst nth_list_update_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index = Suc 0 \\<Longrightarrow> 0 < length (ladder_shift_j d L)\n 2. index = Suc 0 \\<Longrightarrow>\n    fst (snd (ladder_n L 0, fst (snd (L ! 0)) - d, snd (snd (hd L)) - d)) =\n    fst (snd (L ! 0)) - d\n 3. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       ladder_j\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, snd (snd (hd L)) - d)])\n        (Suc nata) =\n       ladder_j L (Suc nata) - d", "using length_L ladder_shift_j_length"], ["proof (prove)\nusing this:\n  0 < length L\n  length (ladder_shift_j ?d ?L) = length ?L\n\ngoal (3 subgoals):\n 1. index = Suc 0 \\<Longrightarrow> 0 < length (ladder_shift_j d L)\n 2. index = Suc 0 \\<Longrightarrow>\n    fst (snd (ladder_n L 0, fst (snd (L ! 0)) - d, snd (snd (hd L)) - d)) =\n    fst (snd (L ! 0)) - d\n 3. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       ladder_j\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, snd (snd (hd L)) - d)])\n        (Suc nata) =\n       ladder_j L (Suc nata) - d", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = Suc 0 \\<Longrightarrow>\n    fst (snd (ladder_n L 0, fst (snd (L ! 0)) - d, snd (snd (hd L)) - d)) =\n    fst (snd (L ! 0)) - d\n 2. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       ladder_j\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, snd (snd (hd L)) - d)])\n        (Suc nata) =\n       ladder_j L (Suc nata) - d", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       ladder_j\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, snd (snd (hd L)) - d)])\n        (Suc nata) =\n       ladder_j L (Suc nata) - d", "apply (simp add: ladder_j_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       deriv_j (ladder_shift_j d L ! Suc nata) = deriv_j (L ! Suc nata) - d", "apply (subst deriv_j_ladder_shift_j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nata. index = Suc (Suc nata) \\<Longrightarrow> Suc nata < length L\n 2. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       deriv_j (L ! Suc nata) - d = deriv_j (L ! Suc nata) - d", "using index_bound"], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (2 subgoals):\n 1. \\<And>nata. index = Suc (Suc nata) \\<Longrightarrow> Suc nata < length L\n 2. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       deriv_j (L ! Suc nata) - d = deriv_j (L ! Suc nata) - d", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nata.\n       index = Suc (Suc nata) \\<Longrightarrow>\n       deriv_j (L ! Suc nata) - d = deriv_j (L ! Suc nata) - d", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ladder_cut_prefix_n: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_n (ladder_cut_prefix d L) index = ladder_n L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (ladder_cut_prefix d L) index = ladder_n L index", "apply (simp add: ladder_cut_prefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n\n     ((ladder_shift_j d L)\n      [0 := (ladder_n L 0, ladder_j L 0 - d, ladder_i L 0 - d)])\n     index =\n    ladder_n L index", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_n\n     ((ladder_shift_j d L)\n      [0 := (ladder_n L 0, ladder_j L 0 - d, ladder_i L 0 - d)])\n     index =\n    ladder_n L index\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       ladder_n\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, ladder_i L 0 - d)])\n        index =\n       ladder_n L index", "apply (auto simp add: ladder_n_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_n\n     ((ladder_shift_j d L)\n      [0 := (deriv_n (L ! 0), ladder_j L 0 - d, ladder_i L 0 - d)] ! 0) =\n    deriv_n (L ! 0)\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n (ladder_shift_j d L ! Suc nat) = deriv_n (L ! Suc nat)", "apply (subst nth_list_update_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index = 0 \\<Longrightarrow> 0 < length (ladder_shift_j d L)\n 2. index = 0 \\<Longrightarrow>\n    deriv_n (deriv_n (L ! 0), ladder_j L 0 - d, ladder_i L 0 - d) =\n    deriv_n (L ! 0)\n 3. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n (ladder_shift_j d L ! Suc nat) = deriv_n (L ! Suc nat)", "apply (simp add: ladder_shift_j_length)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index = 0 \\<Longrightarrow> L \\<noteq> []\n 2. index = 0 \\<Longrightarrow>\n    deriv_n (deriv_n (L ! 0), ladder_j L 0 - d, ladder_i L 0 - d) =\n    deriv_n (L ! 0)\n 3. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n (ladder_shift_j d L ! Suc nat) = deriv_n (L ! Suc nat)", "using length_L"], ["proof (prove)\nusing this:\n  0 < length L\n\ngoal (3 subgoals):\n 1. index = 0 \\<Longrightarrow> L \\<noteq> []\n 2. index = 0 \\<Longrightarrow>\n    deriv_n (deriv_n (L ! 0), ladder_j L 0 - d, ladder_i L 0 - d) =\n    deriv_n (L ! 0)\n 3. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n (ladder_shift_j d L ! Suc nat) = deriv_n (L ! Suc nat)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    deriv_n (deriv_n (L ! 0), ladder_j L 0 - d, ladder_i L 0 - d) =\n    deriv_n (L ! 0)\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n (ladder_shift_j d L ! Suc nat) = deriv_n (L ! Suc nat)", "apply (simp add: deriv_n_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_n (ladder_shift_j d L ! Suc nat) = deriv_n (L ! Suc nat)", "apply (rule_tac deriv_n_ladder_shift_j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> Suc nat < length L", "using index_bound"], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (1 subgoal):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> Suc nat < length L", "by arith"], ["", "lemma ladder_cut_prefix_ix: \n  assumes index_bound: \"index < length L\"\n  assumes length_L: \"length L > 0\"\n  shows \"ladder_ix (ladder_cut_prefix d L) index = ladder_ix L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix (ladder_cut_prefix d L) index = ladder_ix L index", "apply (simp add: ladder_cut_prefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix\n     ((ladder_shift_j d L)\n      [0 := (ladder_n L 0, ladder_j L 0 - d, ladder_i L 0 - d)])\n     index =\n    ladder_ix L index", "apply (cases index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index = 0 \\<Longrightarrow>\n    ladder_ix\n     ((ladder_shift_j d L)\n      [0 := (ladder_n L 0, ladder_j L 0 - d, ladder_i L 0 - d)])\n     index =\n    ladder_ix L index\n 2. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       ladder_ix\n        ((ladder_shift_j d L)\n         [0 := (ladder_n L 0, ladder_j L 0 - d, ladder_i L 0 - d)])\n        index =\n       ladder_ix L index", "apply (auto simp add: ladder_ix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       index = Suc nat \\<Longrightarrow>\n       deriv_ix (ladder_shift_j d L ! Suc nat) = deriv_ix (L ! Suc nat)", "apply (rule_tac deriv_ix_ladder_shift_j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> Suc nat < length L", "using index_bound"], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (1 subgoal):\n 1. \\<And>nat. index = Suc nat \\<Longrightarrow> Suc nat < length L", "by arith"], ["", "lemma LeftDerivationFix_derivation_ge_is_nonterminal:\n  assumes ldfix: \"LeftDerivationFix \\<alpha> i D j \\<gamma>\"\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  assumes is_nonterminal: \"is_nonterminal (\\<gamma> ! j)\"\n  shows \"(D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j) \\<or> (i > d \\<and> j \\<ge> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "have \"is_nonterminal (\\<alpha> ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nonterminal (\\<alpha> ! i)", "using ldfix is_nonterminal"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> i D j \\<gamma>\n  is_nonterminal (\\<gamma> ! j)\n\ngoal (1 subgoal):\n 1. is_nonterminal (\\<alpha> ! i)", "by (simp add: LeftDerivationFix_def)"], ["proof (state)\nthis:\n  is_nonterminal (\\<alpha> ! i)\n\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "from LeftDerivationFix_splits_at_nonterminal[OF ldfix this]"], ["proof (chain)\npicking this:\n  \\<exists>U a1 a2 b1.\n     splits_at \\<alpha> i a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1", "obtain U a1 a2 b1 where U:\n    \"splits_at \\<alpha> i a1 U a2 \\<and> splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\""], ["proof (prove)\nusing this:\n  \\<exists>U a1 a2 b1.\n     splits_at \\<alpha> i a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. (\\<And>a1 U a2 b1.\n        splits_at \\<alpha> i a1 U a2 \\<and>\n        splits_at \\<gamma> j b1 U a2 \\<and>\n        LeftDerivation a1 D b1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "have \"D = [] \\<or> D \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = [] \\<or> D \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  D = [] \\<or> D \\<noteq> []\n\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  D = [] \\<or> D \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  D = [] \\<or> D \\<noteq> []\n\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. D = [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j\n 2. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "case 1"], ["proof (state)\nthis:\n  D = []\n\ngoal (2 subgoals):\n 1. D = [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j\n 2. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  D = []", "have \"a1 = b1\""], ["proof (prove)\nusing this:\n  D = []\n\ngoal (1 subgoal):\n 1. a1 = b1", "using U"], ["proof (prove)\nusing this:\n  D = []\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. a1 = b1", "by auto"], ["proof (state)\nthis:\n  a1 = b1\n\ngoal (2 subgoals):\n 1. D = [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j\n 2. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  a1 = b1", "have i_eq_j: \"i = j\""], ["proof (prove)\nusing this:\n  a1 = b1\n\ngoal (1 subgoal):\n 1. i = j", "using U"], ["proof (prove)\nusing this:\n  a1 = b1\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. i = j", "by (metis dual_order.strict_implies_order length_take min.absorb2 splits_at_def)"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. D = [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j\n 2. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "from 1"], ["proof (chain)\npicking this:\n  D = []", "have \"\\<alpha> = \\<gamma>\""], ["proof (prove)\nusing this:\n  D = []\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<gamma>", "using ldfix LeftDerivationFix_def"], ["proof (prove)\nusing this:\n  D = []\n  LeftDerivationFix \\<alpha> i D j \\<gamma>\n  LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<beta> =\n  (is_sentence ?\\<alpha> \\<and>\n   is_sentence ?\\<beta> \\<and>\n   LeftDerivation ?\\<alpha> ?D ?\\<beta> \\<and>\n   ?i < length ?\\<alpha> \\<and>\n   ?j < length ?\\<beta> \\<and>\n   ?\\<alpha> ! ?i = ?\\<beta> ! ?j \\<and>\n   (\\<exists>E F.\n       ?D = E @ derivation_shift F 0 (Suc ?j) \\<and>\n       LeftDerivation (take ?i ?\\<alpha>) E (take ?j ?\\<beta>) \\<and>\n       LeftDerivation (drop (Suc ?i) ?\\<alpha>) F (drop (Suc ?j) ?\\<beta>)))\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<alpha> = \\<gamma>\n\ngoal (2 subgoals):\n 1. D = [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j\n 2. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "with 1 i_eq_j"], ["proof (chain)\npicking this:\n  D = []\n  i = j\n  \\<alpha> = \\<gamma>", "show ?case"], ["proof (prove)\nusing this:\n  D = []\n  i = j\n  \\<alpha> = \\<gamma>\n\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "by blast"], ["proof (state)\nthis:\n  D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n  d < i \\<and> d \\<le> j\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "case 2"], ["proof (state)\nthis:\n  D \\<noteq> []\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "have \"\\<exists> a1'. LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a1'. LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'", "using U 2"], ["proof (prove)\nusing this:\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n  D \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>a1'. LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'", "by (metis LeftDerivation.elims(2) list.sel(1))"], ["proof (state)\nthis:\n  \\<exists>a1'. LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  \\<exists>a1'. LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'", "obtain a1' where a1': \"LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'\""], ["proof (prove)\nusing this:\n  \\<exists>a1'. LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'\n\ngoal (1 subgoal):\n 1. (\\<And>a1'.\n        LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'", "have \"(fst (hd D)) < length a1\""], ["proof (prove)\nusing this:\n  LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'\n\ngoal (1 subgoal):\n 1. fst (hd D) < length a1", "using Derives1_bound LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 a1 (fst (hd D)) (snd (hd D)) a1'\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> ?i < length ?a\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. fst (hd D) < length a1", "by blast"], ["proof (state)\nthis:\n  fst (hd D) < length a1\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  fst (hd D) < length a1", "have fst_less_i: \"(fst (hd D)) < i\""], ["proof (prove)\nusing this:\n  fst (hd D) < length a1\n\ngoal (1 subgoal):\n 1. fst (hd D) < i", "using U"], ["proof (prove)\nusing this:\n  fst (hd D) < length a1\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n\ngoal (1 subgoal):\n 1. fst (hd D) < i", "by (simp add: leD min.absorb2 nat_le_linear splits_at_def)"], ["proof (state)\nthis:\n  fst (hd D) < i\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "have d_le_fst: \"d \\<le> fst (hd D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> fst (hd D)", "using derivation_ge_d 2"], ["proof (prove)\nusing this:\n  derivation_ge D d\n  D \\<noteq> []\n\ngoal (1 subgoal):\n 1. d \\<le> fst (hd D)", "by (simp add: derivation_ge_def)"], ["proof (state)\nthis:\n  d \\<le> fst (hd D)\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "with fst_less_i"], ["proof (chain)\npicking this:\n  fst (hd D) < i\n  d \\<le> fst (hd D)", "have d_less_i: \"d < i\""], ["proof (prove)\nusing this:\n  fst (hd D) < i\n  d \\<le> fst (hd D)\n\ngoal (1 subgoal):\n 1. d < i", "using le_less_trans"], ["proof (prove)\nusing this:\n  fst (hd D) < i\n  d \\<le> fst (hd D)\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. d < i", "by blast"], ["proof (state)\nthis:\n  d < i\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "have \"\\<exists> b1'. LeftDerives1 b1' (fst (last D)) (snd (last D)) b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1'. LeftDerives1 b1' (fst (last D)) (snd (last D)) b1", "using U 2"], ["proof (prove)\nusing this:\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n  D \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>b1'. LeftDerives1 b1' (fst (last D)) (snd (last D)) b1", "by (metis Derive LeftDerivation_Derive_take_LeftDerives1 LeftDerivation_implies_Derivation \n          last_conv_nth length_0_conv order_refl take_all)"], ["proof (state)\nthis:\n  \\<exists>b1'. LeftDerives1 b1' (fst (last D)) (snd (last D)) b1\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  \\<exists>b1'. LeftDerives1 b1' (fst (last D)) (snd (last D)) b1", "obtain b1' where b1': \"LeftDerives1 b1' (fst (last D)) (snd (last D)) b1\""], ["proof (prove)\nusing this:\n  \\<exists>b1'. LeftDerives1 b1' (fst (last D)) (snd (last D)) b1\n\ngoal (1 subgoal):\n 1. (\\<And>b1'.\n        LeftDerives1 b1' (fst (last D)) (snd (last D)) b1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 b1' (fst (last D)) (snd (last D)) b1\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 b1' (fst (last D)) (snd (last D)) b1", "have \"fst (last D) \\<le> length b1\""], ["proof (prove)\nusing this:\n  LeftDerives1 b1' (fst (last D)) (snd (last D)) b1\n\ngoal (1 subgoal):\n 1. fst (last D) \\<le> length b1", "using Derives1_bound' LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 b1' (fst (last D)) (snd (last D)) b1\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> ?i \\<le> length ?b\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. fst (last D) \\<le> length b1", "by blast"], ["proof (state)\nthis:\n  fst (last D) \\<le> length b1\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  fst (last D) \\<le> length b1", "have fst_le_j: \"fst (last D) \\<le> j\""], ["proof (prove)\nusing this:\n  fst (last D) \\<le> length b1\n\ngoal (1 subgoal):\n 1. fst (last D) \\<le> j", "using U splits_at_def"], ["proof (prove)\nusing this:\n  fst (last D) \\<le> length b1\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U a2 \\<and> LeftDerivation a1 D b1\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. fst (last D) \\<le> j", "by auto"], ["proof (state)\nthis:\n  fst (last D) \\<le> j\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "have \"d \\<le> fst (last D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> fst (last D)", "using derivation_ge_d 2"], ["proof (prove)\nusing this:\n  derivation_ge D d\n  D \\<noteq> []\n\ngoal (1 subgoal):\n 1. d \\<le> fst (last D)", "using derivation_ge_def last_in_set"], ["proof (prove)\nusing this:\n  derivation_ge D d\n  D \\<noteq> []\n  derivation_ge ?D ?i = (\\<forall>d\\<in>set ?D. ?i \\<le> fst d)\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. d \\<le> fst (last D)", "by blast"], ["proof (state)\nthis:\n  d \\<le> fst (last D)\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "with fst_le_j"], ["proof (chain)\npicking this:\n  fst (last D) \\<le> j\n  d \\<le> fst (last D)", "have \"d \\<le> j\""], ["proof (prove)\nusing this:\n  fst (last D) \\<le> j\n  d \\<le> fst (last D)\n\ngoal (1 subgoal):\n 1. d \\<le> j", "using order.trans"], ["proof (prove)\nusing this:\n  fst (last D) \\<le> j\n  d \\<le> fst (last D)\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. d \\<le> j", "by blast"], ["proof (state)\nthis:\n  d \\<le> j\n\ngoal (1 subgoal):\n 1. D \\<noteq> [] \\<Longrightarrow>\n    D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "with d_less_i"], ["proof (chain)\npicking this:\n  d < i\n  d \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  d < i\n  d \\<le> j\n\ngoal (1 subgoal):\n 1. D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n    d < i \\<and> d \\<le> j", "by auto"], ["proof (state)\nthis:\n  D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n  d < i \\<and> d \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D = [] \\<and> \\<alpha> = \\<gamma> \\<and> i = j \\<or>\n  d < i \\<and> d \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationFix_derivation_ge:\n  assumes ldfix: \"LeftDerivationFix \\<alpha> i D j \\<gamma>\"\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  shows \"i = j \\<or> (i > d \\<and> j \\<ge> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<or> d < i \\<and> d \\<le> j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i = j \\<or> d < i \\<and> d \\<le> j", "from LeftDerivationFix_splits_at_symbol[OF ldfix]"], ["proof (chain)\npicking this:\n  \\<exists>U a1 a2 b1 b2 n.\n     splits_at \\<alpha> i a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U b2 \\<and>\n     n \\<le> length D \\<and>\n     LeftDerivation a1 (take n D) b1 \\<and>\n     derivation_ge (drop n D) (Suc (length b1)) \\<and>\n     LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n      b2 \\<and>\n     (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))", "obtain U a1 a2 b1 b2 n where U:\n    \"splits_at \\<alpha> i a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U b2 \\<and>\n     n \\<le> length D \\<and>\n     LeftDerivation a1 (take n D) b1 \\<and>\n     derivation_ge (drop n D) (Suc (length b1)) \\<and>\n     LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0) b2 \\<and>\n     (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\""], ["proof (prove)\nusing this:\n  \\<exists>U a1 a2 b1 b2 n.\n     splits_at \\<alpha> i a1 U a2 \\<and>\n     splits_at \\<gamma> j b1 U b2 \\<and>\n     n \\<le> length D \\<and>\n     LeftDerivation a1 (take n D) b1 \\<and>\n     derivation_ge (drop n D) (Suc (length b1)) \\<and>\n     LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n      b2 \\<and>\n     (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. (\\<And>a1 U a2 b1 b2 n.\n        splits_at \\<alpha> i a1 U a2 \\<and>\n        splits_at \\<gamma> j b1 U b2 \\<and>\n        n \\<le> length D \\<and>\n        LeftDerivation a1 (take n D) b1 \\<and>\n        derivation_ge (drop n D) (Suc (length b1)) \\<and>\n        LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n         b2 \\<and>\n        (n = length D \\<or>\n         n < length D \\<and> is_word (b1 @ [U])) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. i = j \\<or> d < i \\<and> d \\<le> j", "have \"n = 0 \\<or> n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<or> 0 < n", "by auto"], ["proof (state)\nthis:\n  n = 0 \\<or> 0 < n\n\ngoal (1 subgoal):\n 1. i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  n = 0 \\<or> 0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0 \\<or> 0 < n\n\ngoal (1 subgoal):\n 1. i = j \\<or> d < i \\<and> d \\<le> j", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j\n 2. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "case 1"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j\n 2. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  n = 0", "have \"a1 = b1\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. a1 = b1", "using U"], ["proof (prove)\nusing this:\n  n = 0\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. a1 = b1", "by auto"], ["proof (state)\nthis:\n  a1 = b1\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j\n 2. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  a1 = b1", "have i_eq_j: \"i = j\""], ["proof (prove)\nusing this:\n  a1 = b1\n\ngoal (1 subgoal):\n 1. i = j", "using U"], ["proof (prove)\nusing this:\n  a1 = b1\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. i = j", "by (metis dual_order.strict_implies_order length_take min.absorb2 splits_at_def)"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j\n 2. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  i = j", "show ?case"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. i = j \\<or> d < i \\<and> d \\<le> j", "by blast"], ["proof (state)\nthis:\n  i = j \\<or> d < i \\<and> d \\<le> j\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "case 2"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "obtain E where E: \"E = take n D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E. E = take n D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E = take n D\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "have E_nonempty: \"E \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<noteq> []", "using E 2"], ["proof (prove)\nusing this:\n  E = take n D\n  0 < n\n\ngoal (1 subgoal):\n 1. E \\<noteq> []", "using U less_nat_zero_code list.size(3) take_eq_Nil"], ["proof (prove)\nusing this:\n  E = take n D\n  0 < n\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n  (?n < 0) = False\n  length [] = 0\n  (take ?n ?xs = []) = (?n = 0 \\<or> ?xs = [])\n\ngoal (1 subgoal):\n 1. E \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  E \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "have \"\\<exists> a1'. LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a1'. LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'", "using U E E_nonempty"], ["proof (prove)\nusing this:\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n  E = take n D\n  E \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>a1'. LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'", "by (metis LeftDerivation.simps(2) list.exhaust list.sel(1))"], ["proof (state)\nthis:\n  \\<exists>a1'. LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  \\<exists>a1'. LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'", "obtain a1' where a1': \"LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'\""], ["proof (prove)\nusing this:\n  \\<exists>a1'. LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'\n\ngoal (1 subgoal):\n 1. (\\<And>a1'.\n        LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'", "have \"(fst (hd E)) < length a1\""], ["proof (prove)\nusing this:\n  LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'\n\ngoal (1 subgoal):\n 1. fst (hd E) < length a1", "using Derives1_bound LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 a1 (fst (hd E)) (snd (hd E)) a1'\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> ?i < length ?a\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. fst (hd E) < length a1", "by blast"], ["proof (state)\nthis:\n  fst (hd E) < length a1\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  fst (hd E) < length a1", "have fst_less_i: \"(fst (hd E)) < i\""], ["proof (prove)\nusing this:\n  fst (hd E) < length a1\n\ngoal (1 subgoal):\n 1. fst (hd E) < i", "using U"], ["proof (prove)\nusing this:\n  fst (hd E) < length a1\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n\ngoal (1 subgoal):\n 1. fst (hd E) < i", "by (simp add: leD min.absorb2 nat_le_linear splits_at_def)"], ["proof (state)\nthis:\n  fst (hd E) < i\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "have d_le_fst: \"d \\<le> fst (hd E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> fst (hd E)", "using derivation_ge_d E_nonempty E"], ["proof (prove)\nusing this:\n  derivation_ge D d\n  E \\<noteq> []\n  E = take n D\n\ngoal (1 subgoal):\n 1. d \\<le> fst (hd E)", "by (simp add: LeftDerivation.elims(2) U derivation_ge_def hd_conv_nth)"], ["proof (state)\nthis:\n  d \\<le> fst (hd E)\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "with fst_less_i"], ["proof (chain)\npicking this:\n  fst (hd E) < i\n  d \\<le> fst (hd E)", "have d_less_i: \"d < i\""], ["proof (prove)\nusing this:\n  fst (hd E) < i\n  d \\<le> fst (hd E)\n\ngoal (1 subgoal):\n 1. d < i", "using le_less_trans"], ["proof (prove)\nusing this:\n  fst (hd E) < i\n  d \\<le> fst (hd E)\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. d < i", "by blast"], ["proof (state)\nthis:\n  d < i\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "have \"\\<exists> b1'. LeftDerives1 b1' (fst (last E)) (snd (last E)) b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1'. LeftDerives1 b1' (fst (last E)) (snd (last E)) b1", "using E_nonempty U E"], ["proof (prove)\nusing this:\n  E \\<noteq> []\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n  E = take n D\n\ngoal (1 subgoal):\n 1. \\<exists>b1'. LeftDerives1 b1' (fst (last E)) (snd (last E)) b1", "by (metis LeftDerivation_append1 append_butlast_last_id prod.collapse)"], ["proof (state)\nthis:\n  \\<exists>b1'. LeftDerives1 b1' (fst (last E)) (snd (last E)) b1\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  \\<exists>b1'. LeftDerives1 b1' (fst (last E)) (snd (last E)) b1", "obtain b1' where b1': \"LeftDerives1 b1' (fst (last E)) (snd (last E)) b1\""], ["proof (prove)\nusing this:\n  \\<exists>b1'. LeftDerives1 b1' (fst (last E)) (snd (last E)) b1\n\ngoal (1 subgoal):\n 1. (\\<And>b1'.\n        LeftDerives1 b1' (fst (last E)) (snd (last E)) b1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 b1' (fst (last E)) (snd (last E)) b1\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 b1' (fst (last E)) (snd (last E)) b1", "have \"fst (last E) \\<le> length b1\""], ["proof (prove)\nusing this:\n  LeftDerives1 b1' (fst (last E)) (snd (last E)) b1\n\ngoal (1 subgoal):\n 1. fst (last E) \\<le> length b1", "using Derives1_bound' LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 b1' (fst (last E)) (snd (last E)) b1\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> ?i \\<le> length ?b\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. fst (last E) \\<le> length b1", "by blast"], ["proof (state)\nthis:\n  fst (last E) \\<le> length b1\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  fst (last E) \\<le> length b1", "have fst_le_j: \"fst (last E) \\<le> j\""], ["proof (prove)\nusing this:\n  fst (last E) \\<le> length b1\n\ngoal (1 subgoal):\n 1. fst (last E) \\<le> j", "using U splits_at_def"], ["proof (prove)\nusing this:\n  fst (last E) \\<le> length b1\n  splits_at \\<alpha> i a1 U a2 \\<and>\n  splits_at \\<gamma> j b1 U b2 \\<and>\n  n \\<le> length D \\<and>\n  LeftDerivation a1 (take n D) b1 \\<and>\n  derivation_ge (drop n D) (Suc (length b1)) \\<and>\n  LeftDerivation a2 (derivation_shift (drop n D) (Suc (length b1)) 0)\n   b2 \\<and>\n  (n = length D \\<or> n < length D \\<and> is_word (b1 @ [U]))\n  splits_at ?\\<delta> ?i ?\\<alpha> ?N ?\\<beta> =\n  (?i < length ?\\<delta> \\<and>\n   ?\\<alpha> = take ?i ?\\<delta> \\<and>\n   ?N = ?\\<delta> ! ?i \\<and> ?\\<beta> = drop (Suc ?i) ?\\<delta>)\n\ngoal (1 subgoal):\n 1. fst (last E) \\<le> j", "by auto"], ["proof (state)\nthis:\n  fst (last E) \\<le> j\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "have \"d \\<le> fst (last E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> fst (last E)", "using derivation_ge_d E_nonempty E"], ["proof (prove)\nusing this:\n  derivation_ge D d\n  E \\<noteq> []\n  E = take n D\n\ngoal (1 subgoal):\n 1. d \\<le> fst (last E)", "using derivation_ge_d last_in_set"], ["proof (prove)\nusing this:\n  derivation_ge D d\n  E \\<noteq> []\n  E = take n D\n  derivation_ge D d\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. d \\<le> fst (last E)", "by (metis derivation_ge_def set_take_subset subsetCE)"], ["proof (state)\nthis:\n  d \\<le> fst (last E)\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "with fst_le_j"], ["proof (chain)\npicking this:\n  fst (last E) \\<le> j\n  d \\<le> fst (last E)", "have \"d \\<le> j\""], ["proof (prove)\nusing this:\n  fst (last E) \\<le> j\n  d \\<le> fst (last E)\n\ngoal (1 subgoal):\n 1. d \\<le> j", "using order.trans"], ["proof (prove)\nusing this:\n  fst (last E) \\<le> j\n  d \\<le> fst (last E)\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. d \\<le> j", "by blast"], ["proof (state)\nthis:\n  d \\<le> j\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> i = j \\<or> d < i \\<and> d \\<le> j", "with d_less_i"], ["proof (chain)\npicking this:\n  d < i\n  d \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  d < i\n  d \\<le> j\n\ngoal (1 subgoal):\n 1. i = j \\<or> d < i \\<and> d \\<le> j", "by auto"], ["proof (state)\nthis:\n  i = j \\<or> d < i \\<and> d \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = j \\<or> d < i \\<and> d \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_derivation_ge:\n  assumes ldintro: \"LeftDerivationIntro \\<alpha> i r ix D j \\<gamma>\"\n  assumes i_ge_d: \"i \\<ge> d\"\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  shows \"j \\<ge> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<le> j", "from iffD1[OF LeftDerivationIntro_def ldintro]"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     LeftDerives1 \\<alpha> i r \\<beta> \\<and>\n     ix < length (snd r) \\<and>\n     snd r ! ix = \\<gamma> ! j \\<and>\n     LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>", "obtain \\<beta> where \\<beta>:\n    \"LeftDerives1 \\<alpha> i r \\<beta> \\<and> ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j \\<and> \n     LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     LeftDerives1 \\<alpha> i r \\<beta> \\<and>\n     ix < length (snd r) \\<and>\n     snd r ! ix = \\<gamma> ! j \\<and>\n     LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        LeftDerives1 \\<alpha> i r \\<beta> \\<and>\n        ix < length (snd r) \\<and>\n        snd r ! ix = \\<gamma> ! j \\<and>\n        LeftDerivationFix \\<beta> (i + ix) D j \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 \\<alpha> i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. d \\<le> j", "then"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<alpha> i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>", "have \"(i + ix = j) \\<or> (i + ix > d \\<and> j \\<ge> d)\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<alpha> i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. i + ix = j \\<or> d < i + ix \\<and> d \\<le> j", "using LeftDerivationFix_derivation_ge derivation_ge_d"], ["proof (prove)\nusing this:\n  LeftDerives1 \\<alpha> i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n  \\<lbrakk>LeftDerivationFix ?\\<alpha> ?i ?D ?j ?\\<gamma>;\n   derivation_ge ?D ?d\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j \\<or> ?d < ?i \\<and> ?d \\<le> ?j\n  derivation_ge D d\n\ngoal (1 subgoal):\n 1. i + ix = j \\<or> d < i + ix \\<and> d \\<le> j", "by blast"], ["proof (state)\nthis:\n  i + ix = j \\<or> d < i + ix \\<and> d \\<le> j\n\ngoal (1 subgoal):\n 1. d \\<le> j", "then"], ["proof (chain)\npicking this:\n  i + ix = j \\<or> d < i + ix \\<and> d \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  i + ix = j \\<or> d < i + ix \\<and> d \\<le> j\n\ngoal (1 subgoal):\n 1. d \\<le> j", "proof (induct rule: disjCases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. i + ix = j \\<Longrightarrow> d \\<le> j\n 2. d < i + ix \\<and> d \\<le> j \\<Longrightarrow> d \\<le> j", "case 1"], ["proof (state)\nthis:\n  i + ix = j\n\ngoal (2 subgoals):\n 1. i + ix = j \\<Longrightarrow> d \\<le> j\n 2. d < i + ix \\<and> d \\<le> j \\<Longrightarrow> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  i + ix = j", "show ?case"], ["proof (prove)\nusing this:\n  i + ix = j\n\ngoal (1 subgoal):\n 1. d \\<le> j", "using i_ge_d trans_le_add1"], ["proof (prove)\nusing this:\n  i + ix = j\n  d \\<le> i\n  ?i \\<le> ?j \\<Longrightarrow> ?i \\<le> ?j + ?m\n\ngoal (1 subgoal):\n 1. d \\<le> j", "by blast"], ["proof (state)\nthis:\n  d \\<le> j\n\ngoal (1 subgoal):\n 1. d < i + ix \\<and> d \\<le> j \\<Longrightarrow> d \\<le> j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d < i + ix \\<and> d \\<le> j \\<Longrightarrow> d \\<le> j", "case 2"], ["proof (state)\nthis:\n  d < i + ix \\<and> d \\<le> j\n\ngoal (1 subgoal):\n 1. d < i + ix \\<and> d \\<le> j \\<Longrightarrow> d \\<le> j", "then"], ["proof (chain)\npicking this:\n  d < i + ix \\<and> d \\<le> j", "show ?case"], ["proof (prove)\nusing this:\n  d < i + ix \\<and> d \\<le> j\n\ngoal (1 subgoal):\n 1. d \\<le> j", "by simp"], ["proof (state)\nthis:\n  d \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivation_ge_LeftDerivationLadder:\n  assumes derivation_ge_d: \"derivation_ge D d\"\n  assumes ladder: \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes ladder_i_0: \"ladder_i L 0 \\<ge> d\"\n  shows \"index < length L \\<Longrightarrow> ladder_i L index \\<ge> d \\<and> ladder_j L index \\<ge> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L \\<Longrightarrow>\n    d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index", "proof (induct index)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    d \\<le> ladder_i L 0 \\<and> d \\<le> ladder_j L 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "case 0"], ["proof (state)\nthis:\n  0 < length L\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    d \\<le> ladder_i L 0 \\<and> d \\<le> ladder_j L 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "from iffD1[OF LeftDerivationLadder_def ladder]"], ["proof (chain)\npicking this:\n  LeftDerivation \\<alpha> D \\<gamma> \\<and>\n  is_ladder D L \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0) \\<and>\n  LeftDerivationIntros \\<alpha> D L", "have ldfix: \"LeftDerivationFix \\<alpha> (ladder_i L 0)\n      (take (ladder_n L 0) D) (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)\""], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> D \\<gamma> \\<and>\n  is_ladder D L \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0) \\<and>\n  LeftDerivationIntros \\<alpha> D L\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n     (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0)\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    d \\<le> ladder_i L 0 \\<and> d \\<le> ladder_j L 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "have \"derivation_ge (take (ladder_n L 0) D) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (take (ladder_n L 0) D) d", "using derivation_ge_d"], ["proof (prove)\nusing this:\n  derivation_ge D d\n\ngoal (1 subgoal):\n 1. derivation_ge (take (ladder_n L 0) D) d", "by (metis append_take_drop_id derivation_ge_append)"], ["proof (state)\nthis:\n  derivation_ge (take (ladder_n L 0) D) d\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    d \\<le> ladder_i L 0 \\<and> d \\<le> ladder_j L 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "from ladder_i_0 derivation_ge_d LeftDerivationFix_derivation_ge[OF ldfix this]"], ["proof (chain)\npicking this:\n  d \\<le> ladder_i L 0\n  derivation_ge D d\n  ladder_i L 0 = ladder_j L 0 \\<or>\n  d < ladder_i L 0 \\<and> d \\<le> ladder_j L 0", "show ?case"], ["proof (prove)\nusing this:\n  d \\<le> ladder_i L 0\n  derivation_ge D d\n  ladder_i L 0 = ladder_j L 0 \\<or>\n  d < ladder_i L 0 \\<and> d \\<le> ladder_j L 0\n\ngoal (1 subgoal):\n 1. d \\<le> ladder_i L 0 \\<and> d \\<le> ladder_j L 0", "by linarith"], ["proof (state)\nthis:\n  d \\<le> ladder_i L 0 \\<and> d \\<le> ladder_j L 0\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "case (Suc n)"], ["proof (state)\nthis:\n  n < length L \\<Longrightarrow>\n  d \\<le> ladder_i L n \\<and> d \\<le> ladder_j L n\n  Suc n < length L\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "have ladder_i_Suc: \"ladder_i L (Suc n) \\<ge> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> ladder_i L (Suc n)", "apply (auto simp add: ladder_i_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> ladder_j L n", "using Suc"], ["proof (prove)\nusing this:\n  n < length L \\<Longrightarrow>\n  d \\<le> ladder_i L n \\<and> d \\<le> ladder_j L n\n  Suc n < length L\n\ngoal (1 subgoal):\n 1. d \\<le> ladder_j L n", "by auto"], ["proof (state)\nthis:\n  d \\<le> ladder_i L (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "from iffD1[OF LeftDerivationLadder_def ladder]"], ["proof (chain)\npicking this:\n  LeftDerivation \\<alpha> D \\<gamma> \\<and>\n  is_ladder D L \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0) \\<and>\n  LeftDerivationIntros \\<alpha> D L", "have \"LeftDerivationIntros \\<alpha> D L\""], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> D \\<gamma> \\<and>\n  is_ladder D L \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0) (take (ladder_n L 0) D)\n   (ladder_j L 0) (ladder_\\<gamma> \\<alpha> D L 0) \\<and>\n  LeftDerivationIntros \\<alpha> D L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntros \\<alpha> D L", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntros \\<alpha> D L\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "then"], ["proof (chain)\npicking this:\n  LeftDerivationIntros \\<alpha> D L", "have \"LeftDerivationIntrosAt \\<alpha> D L (Suc n)\""], ["proof (prove)\nusing this:\n  LeftDerivationIntros \\<alpha> D L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> D L (Suc n)", "using Suc.prems"], ["proof (prove)\nusing this:\n  LeftDerivationIntros \\<alpha> D L\n  Suc n < length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> D L (Suc n)", "by (metis LeftDerivationIntros_def Suc_eq_plus1_left le_add1)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt \\<alpha> D L (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                d \\<le> ladder_i L index \\<and> d \\<le> ladder_j L index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> d \\<le> ladder_i L (Suc index) \\<and>\n                         d \\<le> ladder_j L (Suc index)", "from iffD1[OF LeftDerivationIntrosAt_def this]"], ["proof (chain)\npicking this:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc n);\n      i = ladder_i L (Suc n); j = ladder_j L (Suc n);\n      ix = ladder_ix L (Suc n);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc n);\n      na = ladder_n L (Suc n - 1); m = ladder_n L (Suc n); e = D ! na;\n      E = drop (Suc na) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>", "show ?case"], ["proof (prove)\nusing this:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc n);\n      i = ladder_i L (Suc n); j = ladder_j L (Suc n);\n      ix = ladder_ix L (Suc n);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc n);\n      na = ladder_n L (Suc n - 1); m = ladder_n L (Suc n); e = D ! na;\n      E = drop (Suc na) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n\ngoal (1 subgoal):\n 1. d \\<le> ladder_i L (Suc n) \\<and> d \\<le> ladder_j L (Suc n)", "using ladder_i_Suc LeftDerivationIntro_derivation_ge"], ["proof (prove)\nusing this:\n  let \\<alpha>' = ladder_\\<alpha> \\<alpha> D L (Suc n);\n      i = ladder_i L (Suc n); j = ladder_j L (Suc n);\n      ix = ladder_ix L (Suc n);\n      \\<gamma> = ladder_\\<gamma> \\<alpha> D L (Suc n);\n      na = ladder_n L (Suc n - 1); m = ladder_n L (Suc n); e = D ! na;\n      E = drop (Suc na) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n  d \\<le> ladder_i L (Suc n)\n  \\<lbrakk>LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<gamma>;\n   ?d \\<le> ?i; derivation_ge ?D ?d\\<rbrakk>\n  \\<Longrightarrow> ?d \\<le> ?j\n\ngoal (1 subgoal):\n 1. d \\<le> ladder_i L (Suc n) \\<and> d \\<le> ladder_j L (Suc n)", "by (metis append_take_drop_id derivation_ge_append derivation_ge_d)"], ["proof (state)\nthis:\n  d \\<le> ladder_i L (Suc n) \\<and> d \\<le> ladder_j L (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivation_shift_append:\n  \"derivation_shift (A@B) left right = \n    (derivation_shift A left right) @ (derivation_shift B left right)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_shift (A @ B) left right =\n    derivation_shift A left right @ derivation_shift B left right", "by (induct A, simp+)"], ["", "lemma derivation_shift_right_left_subtract: \n  \"right \\<ge> left \\<Longrightarrow> derivation_shift (derivation_shift L 0 right) left 0 = \n  derivation_shift L 0 (right - left)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left \\<le> right \\<Longrightarrow>\n    derivation_shift (derivation_shift L 0 right) left 0 =\n    derivation_shift L 0 (right - left)", "by (induct L, simp+)"], ["", "lemma LeftDerivationFix_cut_prefix:\n  assumes \"LeftDerivationFix (\\<delta>@\\<alpha>) i D j \\<gamma>\"\n  assumes \"derivation_ge D (length \\<delta>)\"\n  assumes \"i \\<ge> length \\<delta>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  shows \"\\<exists> \\<gamma>'. \\<gamma> = \\<delta> @ \\<gamma>' \\<and> \n    LeftDerivationFix \\<alpha> (i - length \\<delta>) (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have j_ge_d: \"j \\<ge> length \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> j", "using assms(3) LeftDerivationFix_derivation_ge[OF assms(1) assms(2)]"], ["proof (prove)\nusing this:\n  length \\<delta> \\<le> i\n  i = j \\<or> length \\<delta> < i \\<and> length \\<delta> \\<le> j\n\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> j", "by arith"], ["proof (state)\nthis:\n  length \\<delta> \\<le> j\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "obtain \\<gamma>' where \\<gamma>': \"\\<gamma>' = drop (length \\<delta>) \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        \\<gamma>' = drop (length \\<delta>) \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<gamma>' = drop (length \\<delta>) \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "from iffD1[OF LeftDerivationFix_def assms(1)]"], ["proof (chain)\npicking this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take i (\\<delta> @ \\<alpha>)) E\n       (take j \\<gamma>) \\<and>\n      LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n       (drop (Suc j) \\<gamma>))", "obtain E F where EF:\n   \"is_sentence (\\<delta> @ \\<alpha>) \\<and>\n    is_sentence \\<gamma> \\<and>\n    LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n    i < length (\\<delta> @ \\<alpha>) \\<and>\n    j < length \\<gamma> \\<and>\n    (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n    D = E @ derivation_shift F 0 (Suc j) \\<and>\n    LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n    LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F (drop (Suc j) \\<gamma>)\""], ["proof (prove)\nusing this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  (\\<exists>E F.\n      D = E @ derivation_shift F 0 (Suc j) \\<and>\n      LeftDerivation (take i (\\<delta> @ \\<alpha>)) E\n       (take j \\<gamma>) \\<and>\n      LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n       (drop (Suc j) \\<gamma>))\n\ngoal (1 subgoal):\n 1. (\\<And>E F.\n        is_sentence (\\<delta> @ \\<alpha>) \\<and>\n        is_sentence \\<gamma> \\<and>\n        LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n        i < length (\\<delta> @ \\<alpha>) \\<and>\n        j < length \\<gamma> \\<and>\n        (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n        D = E @ derivation_shift F 0 (Suc j) \\<and>\n        LeftDerivation (take i (\\<delta> @ \\<alpha>)) E\n         (take j \\<gamma>) \\<and>\n        LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n         (drop (Suc j) \\<gamma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n  LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n   (drop (Suc j) \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "then"], ["proof (chain)\npicking this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n  LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n   (drop (Suc j) \\<gamma>)", "have \"LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma>\""], ["proof (prove)\nusing this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n  LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n   (drop (Suc j) \\<gamma>)\n\ngoal (1 subgoal):\n 1. LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma>", "by blast"], ["proof (state)\nthis:\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "from LeftDerivation_skip_prefixword_ex[OF this is_word_\\<delta>]"], ["proof (chain)\npicking this:\n  \\<exists>w'.\n     \\<gamma> = \\<delta> @ w' \\<and>\n     LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0) w'", "obtain \\<gamma>' where \\<gamma>': \"\\<gamma> = \\<delta> @ \\<gamma>' \\<and> LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0) \\<gamma>'\""], ["proof (prove)\nusing this:\n  \\<exists>w'.\n     \\<gamma> = \\<delta> @ w' \\<and>\n     LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0) w'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n        LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0)\n         \\<gamma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0) \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have ldf1: \"is_sentence \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "using EF is_sentence_concat"], ["proof (prove)\nusing this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n  LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n   (drop (Suc j) \\<gamma>)\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n\ngoal (1 subgoal):\n 1. is_sentence \\<alpha>", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have ldf2: \"is_sentence \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sentence \\<gamma>'", "using EF \\<gamma>' is_sentence_concat"], ["proof (prove)\nusing this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n  LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n   (drop (Suc j) \\<gamma>)\n  \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0) \\<gamma>'\n  is_sentence (?x @ ?y) = (is_sentence ?x \\<and> is_sentence ?y)\n\ngoal (1 subgoal):\n 1. is_sentence \\<gamma>'", "by blast"], ["proof (state)\nthis:\n  is_sentence \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have ldf3: \"i - length \\<delta> < length \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - length \\<delta> < length \\<alpha>", "by (metis EF append_Nil assms(3) drop_append drop_eq_Nil not_le)"], ["proof (state)\nthis:\n  i - length \\<delta> < length \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have ldf4: \"j - length \\<delta> < length \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j - length \\<delta> < length \\<gamma>'", "by (metis EF append_Nil j_ge_d \\<gamma>' drop_append drop_eq_Nil not_le)"], ["proof (state)\nthis:\n  j - length \\<delta> < length \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have ldf5: \"\\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)", "by (metis \\<gamma>' EF assms(3) j_ge_d leD nth_append)"], ["proof (state)\nthis:\n  \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have D_split: \"D = E @ derivation_shift F 0 (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = E @ derivation_shift F 0 (Suc j)", "using EF"], ["proof (prove)\nusing this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n  LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n   (drop (Suc j) \\<gamma>)\n\ngoal (1 subgoal):\n 1. D = E @ derivation_shift F 0 (Suc j)", "by blast"], ["proof (state)\nthis:\n  D = E @ derivation_shift F 0 (Suc j)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationFix \\<alpha> (i - length \\<delta>)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "apply (rule_tac x=\\<gamma>' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n    LeftDerivationFix \\<alpha> (i - length \\<delta>)\n     (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n     \\<gamma>'", "apply (auto simp add: \\<gamma>')"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (i - length \\<delta>)\n     (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n     \\<gamma>'", "apply (auto simp add: LeftDerivationFix_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. is_sentence \\<alpha>\n 2. is_sentence \\<gamma>'\n 3. LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0)\n     \\<gamma>'\n 4. i - length \\<delta> < length \\<alpha>\n 5. j - length \\<delta> < length \\<gamma>'\n 6. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 7. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using ldf1"], ["proof (prove)\nusing this:\n  is_sentence \\<alpha>\n\ngoal (7 subgoals):\n 1. is_sentence \\<alpha>\n 2. is_sentence \\<gamma>'\n 3. LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0)\n     \\<gamma>'\n 4. i - length \\<delta> < length \\<alpha>\n 5. j - length \\<delta> < length \\<gamma>'\n 6. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 7. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. is_sentence \\<gamma>'\n 2. LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0)\n     \\<gamma>'\n 3. i - length \\<delta> < length \\<alpha>\n 4. j - length \\<delta> < length \\<gamma>'\n 5. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 6. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using ldf2"], ["proof (prove)\nusing this:\n  is_sentence \\<gamma>'\n\ngoal (6 subgoals):\n 1. is_sentence \\<gamma>'\n 2. LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0)\n     \\<gamma>'\n 3. i - length \\<delta> < length \\<alpha>\n 4. j - length \\<delta> < length \\<gamma>'\n 5. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 6. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0)\n     \\<gamma>'\n 2. i - length \\<delta> < length \\<alpha>\n 3. j - length \\<delta> < length \\<gamma>'\n 4. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 5. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using \\<gamma>'"], ["proof (prove)\nusing this:\n  \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0) \\<gamma>'\n\ngoal (5 subgoals):\n 1. LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0)\n     \\<gamma>'\n 2. i - length \\<delta> < length \\<alpha>\n 3. j - length \\<delta> < length \\<gamma>'\n 4. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 5. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. i - length \\<delta> < length \\<alpha>\n 2. j - length \\<delta> < length \\<gamma>'\n 3. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 4. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using ldf3"], ["proof (prove)\nusing this:\n  i - length \\<delta> < length \\<alpha>\n\ngoal (4 subgoals):\n 1. i - length \\<delta> < length \\<alpha>\n 2. j - length \\<delta> < length \\<gamma>'\n 3. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 4. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. j - length \\<delta> < length \\<gamma>'\n 2. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 3. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using ldf4"], ["proof (prove)\nusing this:\n  j - length \\<delta> < length \\<gamma>'\n\ngoal (3 subgoals):\n 1. j - length \\<delta> < length \\<gamma>'\n 2. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 3. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 2. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using ldf5"], ["proof (prove)\nusing this:\n  \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<alpha> ! (i - length \\<delta>) = \\<gamma>' ! (j - length \\<delta>)\n 2. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E F.\n       derivation_shift D (length \\<delta>) 0 =\n       E @ derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>) E\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (rule_tac x=\"derivation_shift E (length \\<delta>) 0\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F.\n       derivation_shift D (length \\<delta>) 0 =\n       derivation_shift E (length \\<delta>) 0 @\n       derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n       LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n        (derivation_shift E (length \\<delta>) 0)\n        (take (j - length \\<delta>) \\<gamma>') \\<and>\n       LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n        (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (rule_tac x=\"F\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_shift D (length \\<delta>) 0 =\n    derivation_shift E (length \\<delta>) 0 @\n    derivation_shift F 0 (Suc (j - length \\<delta>)) \\<and>\n    LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>') \\<and>\n    LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_shift D (length \\<delta>) 0 =\n    derivation_shift E (length \\<delta>) 0 @\n    derivation_shift F 0 (Suc (j - length \\<delta>))\n 2. LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>')\n 3. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (subst D_split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_shift (E @ derivation_shift F 0 (Suc j)) (length \\<delta>)\n     0 =\n    derivation_shift E (length \\<delta>) 0 @\n    derivation_shift F 0 (Suc (j - length \\<delta>))\n 2. LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>')\n 3. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (simp add: derivation_shift_append)"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_shift (derivation_shift F 0 (Suc j)) (length \\<delta>) 0 =\n    derivation_shift F 0 (Suc (j - length \\<delta>))\n 2. LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>')\n 3. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (subst derivation_shift_right_left_subtract)"], ["proof (prove)\ngoal (4 subgoals):\n 1. length \\<delta> \\<le> Suc j\n 2. derivation_shift F 0 (Suc j - length \\<delta>) =\n    derivation_shift F 0 (Suc (j - length \\<delta>))\n 3. LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>')\n 4. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (simp add: j_ge_d le_Suc_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. derivation_shift F 0 (Suc j - length \\<delta>) =\n    derivation_shift F 0 (Suc (j - length \\<delta>))\n 2. LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>')\n 3. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using j_ge_d"], ["proof (prove)\nusing this:\n  length \\<delta> \\<le> j\n\ngoal (3 subgoals):\n 1. derivation_shift F 0 (Suc j - length \\<delta>) =\n    derivation_shift F 0 (Suc (j - length \\<delta>))\n 2. LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>')\n 3. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (simp add: Suc_diff_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivation (take (i - length \\<delta>) \\<alpha>)\n     (derivation_shift E (length \\<delta>) 0)\n     (take (j - length \\<delta>) \\<gamma>')\n 2. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "apply (metis EF LeftDerivation_implies_Derivation LeftDerivation_skip_prefix \\<gamma>' \n      append_eq_conv_conj assms(3) drop_take is_word_Derivation_derivation_ge is_word_\\<delta> \n      take_all take_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "using EF Suc_diff_le \\<gamma>' assms(3) j_ge_d"], ["proof (prove)\nusing this:\n  is_sentence (\\<delta> @ \\<alpha>) \\<and>\n  is_sentence \\<gamma> \\<and>\n  LeftDerivation (\\<delta> @ \\<alpha>) D \\<gamma> \\<and>\n  i < length (\\<delta> @ \\<alpha>) \\<and>\n  j < length \\<gamma> \\<and>\n  (\\<delta> @ \\<alpha>) ! i = \\<gamma> ! j \\<and>\n  D = E @ derivation_shift F 0 (Suc j) \\<and>\n  LeftDerivation (take i (\\<delta> @ \\<alpha>)) E (take j \\<gamma>) \\<and>\n  LeftDerivation (drop (Suc i) (\\<delta> @ \\<alpha>)) F\n   (drop (Suc j) \\<gamma>)\n  ?n \\<le> ?m \\<Longrightarrow> Suc ?m - ?n = Suc (?m - ?n)\n  \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivation \\<alpha> (derivation_shift D (length \\<delta>) 0) \\<gamma>'\n  length \\<delta> \\<le> i\n  length \\<delta> \\<le> j\n\ngoal (1 subgoal):\n 1. LeftDerivation (drop (Suc (i - length \\<delta>)) \\<alpha>) F\n     (drop (Suc (j - length \\<delta>)) \\<gamma>')", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<gamma>'.\n     \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<alpha> (i - length \\<delta>)\n      (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n      \\<gamma>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerives1_propagate_prefix:\n  \"LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<Longrightarrow> i \\<ge> length \\<delta> \\<Longrightarrow> is_prefix \\<delta> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>;\n     length \\<delta> \\<le> i\\<rbrakk>\n    \\<Longrightarrow> is_prefix \\<delta> \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>;\n     length \\<delta> \\<le> i\\<rbrakk>\n    \\<Longrightarrow> is_prefix \\<delta> \\<beta>", "assume a1: \"LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>\""], ["proof (state)\nthis:\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>;\n     length \\<delta> \\<le> i\\<rbrakk>\n    \\<Longrightarrow> is_prefix \\<delta> \\<beta>", "assume a2: \"length \\<delta> \\<le> i\""], ["proof (state)\nthis:\n  length \\<delta> \\<le> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>;\n     length \\<delta> \\<le> i\\<rbrakk>\n    \\<Longrightarrow> is_prefix \\<delta> \\<beta>", "have f3: \"take i (\\<delta> @ \\<alpha>) = take i \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i (\\<delta> @ \\<alpha>) = take i \\<beta>", "using a1 Derives1_take LeftDerives1_implies_Derives1"], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>\n  Derives1 ?a ?i ?r ?b \\<Longrightarrow> take ?i ?a = take ?i ?b\n  LeftDerives1 ?a ?i ?r ?b \\<Longrightarrow> Derives1 ?a ?i ?r ?b\n\ngoal (1 subgoal):\n 1. take i (\\<delta> @ \\<alpha>) = take i \\<beta>", "by blast"], ["proof (state)\nthis:\n  take i (\\<delta> @ \\<alpha>) = take i \\<beta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>;\n     length \\<delta> \\<le> i\\<rbrakk>\n    \\<Longrightarrow> is_prefix \\<delta> \\<beta>", "then"], ["proof (chain)\npicking this:\n  take i (\\<delta> @ \\<alpha>) = take i \\<beta>", "have f4: \"length (take i \\<beta>) = i\""], ["proof (prove)\nusing this:\n  take i (\\<delta> @ \\<alpha>) = take i \\<beta>\n\ngoal (1 subgoal):\n 1. length (take i \\<beta>) = i", "using a1"], ["proof (prove)\nusing this:\n  take i (\\<delta> @ \\<alpha>) = take i \\<beta>\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>\n\ngoal (1 subgoal):\n 1. length (take i \\<beta>) = i", "by (metis (no_types) Derives1_bound LeftDerives1_implies_Derives1 dual_order.strict_implies_order length_take min.absorb2)"], ["proof (state)\nthis:\n  length (take i \\<beta>) = i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>;\n     length \\<delta> \\<le> i\\<rbrakk>\n    \\<Longrightarrow> is_prefix \\<delta> \\<beta>", "have \"take (length \\<delta>) (take i \\<beta>) = \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length \\<delta>) (take i \\<beta>) = \\<delta>", "using f3 a2"], ["proof (prove)\nusing this:\n  take i (\\<delta> @ \\<alpha>) = take i \\<beta>\n  length \\<delta> \\<le> i\n\ngoal (1 subgoal):\n 1. take (length \\<delta>) (take i \\<beta>) = \\<delta>", "by (simp add: append_eq_conv_conj)"], ["proof (state)\nthis:\n  take (length \\<delta>) (take i \\<beta>) = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta>;\n     length \\<delta> \\<le> i\\<rbrakk>\n    \\<Longrightarrow> is_prefix \\<delta> \\<beta>", "then"], ["proof (chain)\npicking this:\n  take (length \\<delta>) (take i \\<beta>) = \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  take (length \\<delta>) (take i \\<beta>) = \\<delta>\n\ngoal (1 subgoal):\n 1. is_prefix \\<delta> \\<beta>", "using f4 a2"], ["proof (prove)\nusing this:\n  take (length \\<delta>) (take i \\<beta>) = \\<delta>\n  length (take i \\<beta>) = i\n  length \\<delta> \\<le> i\n\ngoal (1 subgoal):\n 1. is_prefix \\<delta> \\<beta>", "by (metis (no_types) append_Nil2 append_eq_conv_conj diff_is_0_eq' is_prefix_take take_0 take_append)"], ["proof (state)\nthis:\n  is_prefix \\<delta> \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationIntro_cut_prefix:\n  assumes \"LeftDerivationIntro (\\<delta>@\\<alpha>) i r ix D j \\<gamma>\"\n  assumes \"derivation_ge D (length \\<delta>)\"\n  assumes \"i \\<ge> length \\<delta>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  shows \"\\<exists> \\<gamma>'. \\<gamma> = \\<delta> @ \\<gamma>' \\<and> \n    LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "from iffD1[OF LeftDerivationIntro_def assms(1)]"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n     ix < length (snd r) \\<and>\n     snd r ! ix = \\<gamma> ! j \\<and>\n     LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>", "obtain \\<beta> where \\<beta>:\n    \"LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n     ix < length (snd r) \\<and> snd r ! ix = \\<gamma> ! j \\<and> LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n     ix < length (snd r) \\<and>\n     snd r ! ix = \\<gamma> ! j \\<and>\n     LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n        ix < length (snd r) \\<and>\n        snd r ! ix = \\<gamma> ! j \\<and>\n        LeftDerivationFix \\<beta> (i + ix) D j \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have \"\\<exists> \\<beta>'. \\<beta> = \\<delta> @ \\<beta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>'. \\<beta> = \\<delta> @ \\<beta>'", "using LeftDerives1_propagate_prefix \\<beta> assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerives1 (?\\<delta> @ ?\\<alpha>) ?i ?r ?\\<beta>;\n   length ?\\<delta> \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> is_prefix ?\\<delta> ?\\<beta>\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n  length \\<delta> \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>'. \\<beta> = \\<delta> @ \\<beta>'", "by (metis append_dropped_prefix)"], ["proof (state)\nthis:\n  \\<exists>\\<beta>'. \\<beta> = \\<delta> @ \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>'. \\<beta> = \\<delta> @ \\<beta>'", "obtain \\<beta>' where \\<beta>': \"\\<beta> = \\<delta> @ \\<beta>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>'. \\<beta> = \\<delta> @ \\<beta>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>'.\n        \\<beta> = \\<delta> @ \\<beta>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta> = \\<delta> @ \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "with \\<beta>"], ["proof (chain)\npicking this:\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n  \\<beta> = \\<delta> @ \\<beta>'", "have \"LeftDerives1 (\\<delta> @ \\<alpha>) i r (\\<delta> @ \\<beta>')\""], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n  \\<beta> = \\<delta> @ \\<beta>'\n\ngoal (1 subgoal):\n 1. LeftDerives1 (\\<delta> @ \\<alpha>) i r (\\<delta> @ \\<beta>')", "by simp"], ["proof (state)\nthis:\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r (\\<delta> @ \\<beta>')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "from LeftDerives1_skip_prefix[OF assms(3) this]"], ["proof (chain)\npicking this:\n  LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta>'", "have \\<alpha>_\\<beta>': \"LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta>'\""], ["proof (prove)\nusing this:\n  LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta>'\n\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta>'", "by blast"], ["proof (state)\nthis:\n  LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have ldfix: \"LeftDerivationFix (\\<delta> @ \\<beta>') (i + ix) D j \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<delta> @ \\<beta>') (i + ix) D j \\<gamma>", "using \\<beta> \\<beta>'"], ["proof (prove)\nusing this:\n  LeftDerives1 (\\<delta> @ \\<alpha>) i r \\<beta> \\<and>\n  ix < length (snd r) \\<and>\n  snd r ! ix = \\<gamma> ! j \\<and>\n  LeftDerivationFix \\<beta> (i + ix) D j \\<gamma>\n  \\<beta> = \\<delta> @ \\<beta>'\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<delta> @ \\<beta>') (i + ix) D j \\<gamma>", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<delta> @ \\<beta>') (i + ix) D j \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have \\<delta>_le_i_plus_ix: \"length \\<delta> \\<le> i + ix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> i + ix", "using assms(3)"], ["proof (prove)\nusing this:\n  length \\<delta> \\<le> i\n\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> i + ix", "by arith"], ["proof (state)\nthis:\n  length \\<delta> \\<le> i + ix\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "from LeftDerivationFix_cut_prefix[OF ldfix assms(2) \\<delta>_le_i_plus_ix assms(4)]"], ["proof (chain)\npicking this:\n  \\<exists>\\<gamma>'.\n     \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<beta>' (i + ix - length \\<delta>)\n      (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n      \\<gamma>'", "obtain \\<gamma>' where \\<gamma>': \"\\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<beta>' (i + ix - length \\<delta>) (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<gamma>'.\n     \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<beta>' (i + ix - length \\<delta>)\n      (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n      \\<gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n        LeftDerivationFix \\<beta>' (i + ix - length \\<delta>)\n         (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n         \\<gamma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationFix \\<beta>' (i + ix - length \\<delta>)\n   (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have same_symbol: \"\\<gamma> ! j = \\<gamma>' ! (j - length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> ! j = \\<gamma>' ! (j - length \\<delta>)", "by (metis LeftDerivationFix_def \\<beta> \\<beta>' \\<delta>_le_i_plus_ix \\<gamma>' leD nth_append)"], ["proof (state)\nthis:\n  \\<gamma> ! j = \\<gamma>' ! (j - length \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "have \\<beta>'_\\<gamma>': \"LeftDerivationFix \\<beta>' (i - length \\<delta> + ix) \n    (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<beta>' (i - length \\<delta> + ix)\n     (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n     \\<gamma>'", "by (simp add: \\<gamma>' assms(3))"], ["proof (state)\nthis:\n  LeftDerivationFix \\<beta>' (i - length \\<delta> + ix)\n   (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "apply (simp add: LeftDerivationIntro_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       (\\<exists>\\<beta>.\n           LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta> \\<and>\n           ix < length (snd r) \\<and>\n           snd r ! ix = \\<gamma>' ! (j - length \\<delta>) \\<and>\n           LeftDerivationFix \\<beta> (i - length \\<delta> + ix)\n            (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n            \\<gamma>')", "apply (rule_tac x=\\<gamma>' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n    (\\<exists>\\<beta>.\n        LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta> \\<and>\n        ix < length (snd r) \\<and>\n        snd r ! ix = \\<gamma>' ! (j - length \\<delta>) \\<and>\n        LeftDerivationFix \\<beta> (i - length \\<delta> + ix)\n         (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n         \\<gamma>')", "apply (auto simp add: \\<gamma>')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta> \\<and>\n       ix < length (snd r) \\<and>\n       snd r ! ix = \\<gamma>' ! (j - length \\<delta>) \\<and>\n       LeftDerivationFix \\<beta> (i - length \\<delta> + ix)\n        (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n        \\<gamma>'", "apply (rule_tac x=\\<beta>' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerives1 \\<alpha> (i - length \\<delta>) r \\<beta>' \\<and>\n    ix < length (snd r) \\<and>\n    snd r ! ix = \\<gamma>' ! (j - length \\<delta>) \\<and>\n    LeftDerivationFix \\<beta>' (i - length \\<delta> + ix)\n     (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n     \\<gamma>'", "by (auto simp add: \\<beta> \\<alpha>_\\<beta>' same_symbol \\<beta>'_\\<gamma>')"], ["proof (state)\nthis:\n  \\<exists>\\<gamma>'.\n     \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationIntro \\<alpha> (i - length \\<delta>) r ix\n      (derivation_shift D (length \\<delta>) 0) (j - length \\<delta>)\n      \\<gamma>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LeftDerivationLadder_implies_LeftDerivation_at_index:\n  assumes \"LeftDerivationLadder \\<alpha> D L \\<gamma>\"\n  assumes \"index < length L\"\n  shows \"LeftDerivation \\<alpha> (take (ladder_n L index) D) (ladder_\\<gamma> \\<alpha> D L index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L index) D)\n     (ladder_\\<gamma> \\<alpha> D L index)", "using LeftDerivationLadder_def LeftDerivation_take_derive assms(1) ladder_\\<gamma>_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivation ?a ?D ?b \\<Longrightarrow>\n  LeftDerivation ?a (take ?n ?D) (Derive ?a (take ?n ?D))\n  LeftDerivationLadder \\<alpha> D L \\<gamma>\n  ladder_\\<gamma> ?a ?D ?L ?index = Derive ?a (take (ladder_n ?L ?index) ?D)\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L index) D)\n     (ladder_\\<gamma> \\<alpha> D L index)", "by auto"], ["", "lemma LeftDerivationLadder_cut_prefix_propagate:\n  assumes ladder: \"LeftDerivationLadder (\\<delta>@\\<alpha>) D L \\<gamma>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  assumes derivation_ge_\\<delta>: \"derivation_ge D (length \\<delta>)\"\n  assumes ladder_i_0: \"ladder_i L 0 \\<ge> length \\<delta>\"\n  assumes L': \"L' = ladder_cut_prefix (length \\<delta>) L\"\n  assumes D': \"D' = derivation_shift D (length \\<delta>) 0\"\n  shows \"index < length L \\<Longrightarrow> \n    LeftDerivation \\<alpha> (take (ladder_n L' index) D') (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n    ladder_\\<alpha> (\\<delta>@\\<alpha>) D L index = \\<delta>@(ladder_\\<alpha> \\<alpha> D' L' index) \\<and>\n    ladder_\\<gamma> (\\<delta>@\\<alpha>) D L index = \\<delta>@(ladder_\\<gamma> \\<alpha> D' L' index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n     (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index", "proof (induct index)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "case 0"], ["proof (state)\nthis:\n  0 < length L\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have ladder_\\<alpha>: \"ladder_\\<alpha> (\\<delta>@\\<alpha>) D L 0 = \\<delta>@(ladder_\\<alpha> \\<alpha> D' L' 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0", "by (simp add: ladder_\\<alpha>_def)"], ["proof (state)\nthis:\n  ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n  \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have ldfix: \"LeftDerivationFix (\\<delta>@\\<alpha>) (ladder_i L 0) (take (ladder_n L 0) D) \n      (ladder_j L 0) (ladder_\\<gamma> (\\<delta>@\\<alpha>) D L 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<delta> @ \\<alpha>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)", "using ladder LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<delta> @ \\<alpha>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<delta> @ \\<alpha>) (ladder_i L 0)\n   (take (ladder_n L 0) D) (ladder_j L 0)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have dge_take: \"derivation_ge (take (ladder_n L 0) D) (length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (take (ladder_n L 0) D) (length \\<delta>)", "using derivation_ge_\\<delta>"], ["proof (prove)\nusing this:\n  derivation_ge D (length \\<delta>)\n\ngoal (1 subgoal):\n 1. derivation_ge (take (ladder_n L 0) D) (length \\<delta>)", "by (metis append_take_drop_id derivation_ge_append)"], ["proof (state)\nthis:\n  derivation_ge (take (ladder_n L 0) D) (length \\<delta>)\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "from LeftDerivationFix_cut_prefix[OF ldfix dge_take ladder_i_0 is_word_\\<delta>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n      (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n      (ladder_j L 0 - length \\<delta>) \\<gamma>'", "obtain \\<gamma>' where \\<gamma>': \"ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n      LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>) (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n      (ladder_j L 0 - length \\<delta>) \\<gamma>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n      (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n      (ladder_j L 0 - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n        \\<delta> @ \\<gamma>' \\<and>\n        LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n         (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n         (ladder_j L 0 - length \\<delta>) \\<gamma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n   (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n   (ladder_j L 0 - length \\<delta>) \\<gamma>'\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have ladder_\\<gamma>: \"ladder_\\<gamma> (\\<delta>@\\<alpha>) D L 0 = \\<delta>@(ladder_\\<gamma> \\<alpha> D' L' 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0", "using \\<gamma>'"], ["proof (prove)\nusing this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n   (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n   (ladder_j L 0 - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0", "by (metis \"0.prems\" D' Derive L' LeftDerivationFix_def \n        LeftDerivation_implies_Derivation ladder_\\<gamma>_def ladder_cut_prefix_n take_derivation_shift)"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have \"LeftDerivation \\<alpha> (take (ladder_n L' 0) D') (ladder_\\<gamma> \\<alpha> D' L' 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0)", "have \"LeftDerivation (\\<delta>@\\<alpha>) (take (ladder_n L 0) D) (ladder_\\<gamma> (\\<delta>@\\<alpha>) D L 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L 0) D)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)", "using LeftDerivationLadder_implies_LeftDerivation_at_index ladder \"0.prems\""], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerivationLadder ?\\<alpha> ?D ?L ?\\<gamma>;\n   ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?\\<alpha> (take (ladder_n ?L ?index) ?D)\n                     (ladder_\\<gamma> ?\\<alpha> ?D ?L ?index)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  0 < length L\n\ngoal (1 subgoal):\n 1. LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L 0) D)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)", "by blast"], ["proof (state)\nthis:\n  LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L 0) D)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0)", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L 0) D)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L 0) D)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0)", "by (metis D' LeftDerivationLadder_def LeftDerivation_skip_prefix \n          LeftDerivation_take_derive derivation_ge_\\<delta> ladder ladder_\\<gamma>_def)"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n   (ladder_\\<gamma> \\<alpha> D' L' 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n   (ladder_\\<gamma> \\<alpha> D' L' 0)\n\ngoal (2 subgoals):\n 1. 0 < length L \\<Longrightarrow>\n    LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n 2. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "then"], ["proof (chain)\npicking this:\n  LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n   (ladder_\\<gamma> \\<alpha> D' L' 0)", "show ?case"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n   (ladder_\\<gamma> \\<alpha> D' L' 0)\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0", "using ladder_\\<alpha> ladder_\\<gamma>"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n   (ladder_\\<gamma> \\<alpha> D' L' 0)\n  ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n  \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n     (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0", "by auto"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L' 0) D')\n   (ladder_\\<gamma> \\<alpha> D' L' 0) \\<and>\n  ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L 0 =\n  \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' 0 \\<and>\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' 0\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "case (Suc index)"], ["proof (state)\nthis:\n  index < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n   (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n  ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have index_less_L: \"index < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index < length L", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. index < length L", "by arith"], ["proof (state)\nthis:\n  index < length L\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "then"], ["proof (chain)\npicking this:\n  index < length L", "have induct: \"ladder_\\<gamma> (\\<delta>@\\<alpha>) D L index = \\<delta>@(ladder_\\<gamma> \\<alpha> D' L' index)\""], ["proof (prove)\nusing this:\n  index < length L\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index", "using Suc"], ["proof (prove)\nusing this:\n  index < length L\n  index < length L \\<Longrightarrow>\n  LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n   (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n  ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index", "by blast"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "then"], ["proof (chain)\npicking this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index", "have ladder_\\<alpha>: \"ladder_\\<alpha> (\\<delta>@\\<alpha>) D L (Suc index) = \\<delta>@(ladder_\\<alpha> \\<alpha> D' L' (Suc index))\""], ["proof (prove)\nusing this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index\n\ngoal (1 subgoal):\n 1. ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index) =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' (Suc index)", "by (simp add: ladder_\\<alpha>_def)"], ["proof (state)\nthis:\n  ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have introsAt: \"LeftDerivationIntrosAt (\\<delta>@\\<alpha>) D L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L (Suc index)", "using Suc(2) ladder"], ["proof (prove)\nusing this:\n  Suc index < length L\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L (Suc index)", "by (metis LeftDerivationIntros_def LeftDerivationLadder_def Suc_eq_plus1_left le_add1)"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "obtain n m e E where n: \"n = ladder_n L (Suc index - 1)\" and\n      m: \"m = ladder_n L (Suc index)\" and e: \"e = D ! n\" and E: \"E = drop (Suc n) (take m D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n m e E.\n        \\<lbrakk>n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index);\n         e = D ! n; E = drop (Suc n) (take m D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = ladder_n L (Suc index - 1)\n  m = ladder_n L (Suc index)\n  e = D ! n\n  E = drop (Suc n) (take m D)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "from iffD1[OF LeftDerivationIntrosAt_def introsAt]"], ["proof (chain)\npicking this:\n  let \\<alpha>' = ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>", "have \n      \"LeftDerivationIntro (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index)) (ladder_i L (Suc index)) (snd e) \n       (ladder_ix L (Suc index)) E (ladder_j L (Suc index)) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))\""], ["proof (prove)\nusing this:\n  let \\<alpha>' = ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index))\n     (ladder_i L (Suc index)) (snd e) (ladder_ix L (Suc index)) E\n     (ladder_j L (Suc index))\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))", "using n m e E Let_def"], ["proof (prove)\nusing this:\n  let \\<alpha>' = ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index);\n      i = ladder_i L (Suc index); j = ladder_j L (Suc index);\n      ix = ladder_ix L (Suc index);\n      \\<gamma> = ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index);\n      n = ladder_n L (Suc index - 1); m = ladder_n L (Suc index); e = D ! n;\n      E = drop (Suc n) (take m D)\n  in i = fst e \\<and>\n     LeftDerivationIntro \\<alpha>' i (snd e) ix E j \\<gamma>\n  n = ladder_n L (Suc index - 1)\n  m = ladder_n L (Suc index)\n  e = D ! n\n  E = drop (Suc n) (take m D)\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index))\n     (ladder_i L (Suc index)) (snd e) (ladder_ix L (Suc index)) E\n     (ladder_j L (Suc index))\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))", "by meson"], ["proof (state)\nthis:\n  LeftDerivationIntro\n   (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index))\n   (ladder_i L (Suc index)) (snd e) (ladder_ix L (Suc index)) E\n   (ladder_j L (Suc index))\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "then"], ["proof (chain)\npicking this:\n  LeftDerivationIntro\n   (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index))\n   (ladder_i L (Suc index)) (snd e) (ladder_ix L (Suc index)) E\n   (ladder_j L (Suc index))\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))", "have ldintro:\n      \"LeftDerivationIntro (\\<delta>@(ladder_\\<alpha> \\<alpha> D' L' (Suc index))) (ladder_i L (Suc index)) (snd e) \n       (ladder_ix L (Suc index)) E (ladder_j L (Suc index)) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))\""], ["proof (prove)\nusing this:\n  LeftDerivationIntro\n   (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index))\n   (ladder_i L (Suc index)) (snd e) (ladder_ix L (Suc index)) E\n   (ladder_j L (Suc index))\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro\n     (\\<delta> @ ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n     (ladder_i L (Suc index)) (snd e) (ladder_ix L (Suc index)) E\n     (ladder_j L (Suc index))\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))", "by (simp add: ladder_\\<alpha>)"], ["proof (state)\nthis:\n  LeftDerivationIntro\n   (\\<delta> @ ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   (ladder_i L (Suc index)) (snd e) (ladder_ix L (Suc index)) E\n   (ladder_j L (Suc index))\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have dge_E_\\<delta>: \"derivation_ge E (length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge E (length \\<delta>)", "apply (simp add: E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (drop (Suc n) (take m D)) (length \\<delta>)", "using derivation_ge_\\<delta>"], ["proof (prove)\nusing this:\n  derivation_ge D (length \\<delta>)\n\ngoal (1 subgoal):\n 1. derivation_ge (drop (Suc n) (take m D)) (length \\<delta>)", "by (metis append_take_drop_id derivation_ge_append)"], ["proof (state)\nthis:\n  derivation_ge E (length \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have ladder_i_Suc: \"length \\<delta> \\<le> ladder_i L (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> ladder_i L (Suc index)", "using Suc.prems derivation_ge_LeftDerivationLadder derivation_ge_\\<delta> ladder ladder_i_0"], ["proof (prove)\nusing this:\n  Suc index < length L\n  \\<lbrakk>derivation_ge ?D ?d;\n   LeftDerivationLadder ?\\<alpha> ?D ?L ?\\<gamma>; ?d \\<le> ladder_i ?L 0;\n   ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> ?d \\<le> ladder_i ?L ?index \\<and>\n                    ?d \\<le> ladder_j ?L ?index\n  derivation_ge D (length \\<delta>)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  length \\<delta> \\<le> ladder_i L 0\n\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> ladder_i L (Suc index)", "by blast"], ["proof (state)\nthis:\n  length \\<delta> \\<le> ladder_i L (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "from LeftDerivationIntro_cut_prefix[OF ldintro dge_E_\\<delta> ladder_i_Suc is_word_\\<delta>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n      (ladder_i L (Suc index) - length \\<delta>) (snd e)\n      (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n      (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'", "obtain \\<gamma>' where \\<gamma>': \"ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) = \\<delta> @ \\<gamma>' \\<and>\n      LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index)) (ladder_i L (Suc index) - length \\<delta>) (snd e)\n      (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0) (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n      (ladder_i L (Suc index) - length \\<delta>) (snd e)\n      (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n      (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n        \\<delta> @ \\<gamma>' \\<and>\n        LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n         (ladder_i L (Suc index) - length \\<delta>) (snd e)\n         (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n         (ladder_j L (Suc index) - length \\<delta>)\n         \\<gamma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   (ladder_i L (Suc index) - length \\<delta>) (snd e)\n   (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n   (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "then"], ["proof (chain)\npicking this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   (ladder_i L (Suc index) - length \\<delta>) (snd e)\n   (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n   (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'", "have \"LeftDerivation (ladder_\\<alpha> \\<alpha> D' L' (Suc index)) \n      ((ladder_i L (Suc index) - length \\<delta>, snd e) # (derivation_shift E (length \\<delta>) 0)) \\<gamma>'\""], ["proof (prove)\nusing this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   (ladder_i L (Suc index) - length \\<delta>) (snd e)\n   (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n   (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n     ((ladder_i L (Suc index) - length \\<delta>, snd e) #\n      derivation_shift E (length \\<delta>) 0)\n     \\<gamma>'", "using LeftDerivationIntro_implies_LeftDerivation"], ["proof (prove)\nusing this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   (ladder_i L (Suc index) - length \\<delta>) (snd e)\n   (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n   (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'\n  LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<gamma> \\<Longrightarrow>\n  LeftDerivation ?\\<alpha> ((?i, ?r) # ?D) ?\\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n     ((ladder_i L (Suc index) - length \\<delta>, snd e) #\n      derivation_shift E (length \\<delta>) 0)\n     \\<gamma>'", "by blast"], ["proof (state)\nthis:\n  LeftDerivation (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   ((ladder_i L (Suc index) - length \\<delta>, snd e) #\n    derivation_shift E (length \\<delta>) 0)\n   \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   ((ladder_i L (Suc index) - length \\<delta>, snd e) #\n    derivation_shift E (length \\<delta>) 0)\n   \\<gamma>'", "have \"LeftDerivation (ladder_\\<gamma> \\<alpha> D' L' index) \n      ((ladder_i L (Suc index) - length \\<delta>, snd e) # (derivation_shift E (length \\<delta>) 0)) \\<gamma>'\""], ["proof (prove)\nusing this:\n  LeftDerivation (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   ((ladder_i L (Suc index) - length \\<delta>, snd e) #\n    derivation_shift E (length \\<delta>) 0)\n   \\<gamma>'\n\ngoal (1 subgoal):\n 1. LeftDerivation (ladder_\\<gamma> \\<alpha> D' L' index)\n     ((ladder_i L (Suc index) - length \\<delta>, snd e) #\n      derivation_shift E (length \\<delta>) 0)\n     \\<gamma>'", "by (auto simp add: ladder_\\<alpha>_def)"], ["proof (state)\nthis:\n  LeftDerivation (ladder_\\<gamma> \\<alpha> D' L' index)\n   ((ladder_i L (Suc index) - length \\<delta>, snd e) #\n    derivation_shift E (length \\<delta>) 0)\n   \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "have ld: \"LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D') (ladder_\\<gamma> \\<alpha> D' L' (Suc index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n     (ladder_\\<gamma> \\<alpha> D' L' (Suc index))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n     (ladder_\\<gamma> \\<alpha> D' L' (Suc index))", "have \"LeftDerivation (\\<delta>@\\<alpha>) (take (ladder_n L (Suc index)) D) (ladder_\\<gamma> (\\<delta>@\\<alpha>) D L (Suc index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L (Suc index)) D)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))", "using LeftDerivationLadder_implies_LeftDerivation_at_index ladder Suc.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeftDerivationLadder ?\\<alpha> ?D ?L ?\\<gamma>;\n   ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?\\<alpha> (take (ladder_n ?L ?index) ?D)\n                     (ladder_\\<gamma> ?\\<alpha> ?D ?L ?index)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  Suc index < length L\n\ngoal (1 subgoal):\n 1. LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L (Suc index)) D)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))", "by blast"], ["proof (state)\nthis:\n  LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L (Suc index)) D)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n     (ladder_\\<gamma> \\<alpha> D' L' (Suc index))", "then"], ["proof (chain)\npicking this:\n  LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L (Suc index)) D)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))", "show ?thesis"], ["proof (prove)\nusing this:\n  LeftDerivation (\\<delta> @ \\<alpha>) (take (ladder_n L (Suc index)) D)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index))\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n     (ladder_\\<gamma> \\<alpha> D' L' (Suc index))", "by (metis D' LeftDerivationLadder_def LeftDerivation_skip_prefix \n          LeftDerivation_take_derive derivation_ge_\\<delta> ladder ladder_\\<gamma>_def)"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n   (ladder_\\<gamma> \\<alpha> D' L' (Suc index))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n   (ladder_\\<gamma> \\<alpha> D' L' (Suc index))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>index < length L \\<Longrightarrow>\n                LeftDerivation \\<alpha> (take (ladder_n L' index) D')\n                 (ladder_\\<gamma> \\<alpha> D' L' index) \\<and>\n                ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index \\<and>\n                ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n                \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' index;\n        Suc index < length L\\<rbrakk>\n       \\<Longrightarrow> LeftDerivation \\<alpha>\n                          (take (ladder_n L' (Suc index)) D')\n                          (ladder_\\<gamma> \\<alpha> D' L'\n                            (Suc index)) \\<and>\n                         ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n                         ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L\n                          (Suc index) =\n                         \\<delta> @\n                         ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "then"], ["proof (chain)\npicking this:\n  LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n   (ladder_\\<gamma> \\<alpha> D' L' (Suc index))", "show ?case"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n   (ladder_\\<gamma> \\<alpha> D' L' (Suc index))\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n     (ladder_\\<gamma> \\<alpha> D' L' (Suc index)) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index) =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "using \\<gamma>' D' Derive L' LeftDerivationIntro_def n m e E ld\n        LeftDerivation_implies_Derivation ladder_\\<gamma>_def ladder_cut_prefix_n take_derivation_shift"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n   (ladder_\\<gamma> \\<alpha> D' L' (Suc index))\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' (Suc index))\n   (ladder_i L (Suc index) - length \\<delta>) (snd e)\n   (ladder_ix L (Suc index)) (derivation_shift E (length \\<delta>) 0)\n   (ladder_j L (Suc index) - length \\<delta>) \\<gamma>'\n  D' = derivation_shift D (length \\<delta>) 0\n  Derivation ?a ?D ?b \\<Longrightarrow> Derive ?a ?D = ?b\n  L' = ladder_cut_prefix (length \\<delta>) L\n  LeftDerivationIntro ?\\<alpha> ?i ?r ?ix ?D ?j ?\\<gamma> =\n  (\\<exists>\\<beta>.\n      LeftDerives1 ?\\<alpha> ?i ?r \\<beta> \\<and>\n      ?ix < length (snd ?r) \\<and>\n      snd ?r ! ?ix = ?\\<gamma> ! ?j \\<and>\n      LeftDerivationFix \\<beta> (?i + ?ix) ?D ?j ?\\<gamma>)\n  n = ladder_n L (Suc index - 1)\n  m = ladder_n L (Suc index)\n  e = D ! n\n  E = drop (Suc n) (take m D)\n  LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n   (ladder_\\<gamma> \\<alpha> D' L' (Suc index))\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  ladder_\\<gamma> ?a ?D ?L ?index = Derive ?a (take (ladder_n ?L ?index) ?D)\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_n (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_n ?L ?index\n  take ?n (derivation_shift ?D ?left ?right) =\n  derivation_shift (take ?n ?D) ?left ?right\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n     (ladder_\\<gamma> \\<alpha> D' L' (Suc index)) \\<and>\n    ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index) =\n    \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n    ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n    \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' (Suc index)", "by (metis (no_types, lifting) LeftDerivationLadder_implies_LeftDerivation_at_index \n        LeftDerivation_skip_prefixword_ex Suc.prems Suc_leI index_less_L is_word_\\<delta> ladder \n        ladder_\\<alpha> le_0_eq neq0_conv)"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> (take (ladder_n L' (Suc index)) D')\n   (ladder_\\<gamma> \\<alpha> D' L' (Suc index)) \\<and>\n  ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ ladder_\\<alpha> \\<alpha> D' L' (Suc index) \\<and>\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L (Suc index) =\n  \\<delta> @ ladder_\\<gamma> \\<alpha> D' L' (Suc index)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem LeftDerivationLadder_cut_prefix:\n  assumes ladder: \"LeftDerivationLadder (\\<delta>@\\<alpha>) D L \\<gamma>\"\n  assumes is_word_\\<delta>: \"is_word \\<delta>\"\n  assumes ladder_i_0: \"ladder_i L 0 \\<ge> length \\<delta>\"\n  shows \"\\<exists> D' L' \\<gamma>'. \\<gamma> = \\<delta> @ \\<gamma>' \\<and> \n    LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n    D' = derivation_shift D (length \\<delta>) 0 \\<and>\n    length L' = length L \\<and> ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n    ladder_last_j L' + length \\<delta> = ladder_last_j L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "obtain D' where D': \"D' = derivation_shift D (length \\<delta>) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        D' = derivation_shift D (length \\<delta>) 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D' = derivation_shift D (length \\<delta>) 0\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "obtain L' where L': \"L' = ladder_cut_prefix (length \\<delta>) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        L' = ladder_cut_prefix (length \\<delta>) L \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L' = ladder_cut_prefix (length \\<delta>) L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "obtain \\<gamma>' where \\<gamma>': \"\\<gamma>' = drop (length \\<delta>) \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        \\<gamma>' = drop (length \\<delta>) \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<gamma>' = drop (length \\<delta>) \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have ladder_last_j_upper_bound: \"ladder_last_j L < length \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_j L < length \\<gamma>", "using ladder"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. ladder_last_j L < length \\<gamma>", "using ladder_last_j_bound"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  LeftDerivationLadder ?\\<alpha> ?D ?L ?\\<gamma> \\<Longrightarrow>\n  ladder_last_j ?L < length ?\\<gamma>\n\ngoal (1 subgoal):\n 1. ladder_last_j L < length \\<gamma>", "by blast"], ["proof (state)\nthis:\n  ladder_last_j L < length \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have derivation_ge_\\<delta>: \"derivation_ge D (length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge D (length \\<delta>)", "using is_word_\\<delta> LeftDerivationLadder_def \n    LeftDerivation_implies_Derivation is_word_Derivation_derivation_ge ladder"], ["proof (prove)\nusing this:\n  is_word \\<delta>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivation ?a ?D ?b \\<Longrightarrow> Derivation ?a ?D ?b\n  \\<lbrakk>is_word ?w; Derivation (?w @ ?a) ?D ?b\\<rbrakk>\n  \\<Longrightarrow> derivation_ge ?D (length ?w)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. derivation_ge D (length \\<delta>)", "by blast"], ["proof (state)\nthis:\n  derivation_ge D (length \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "note derivation_ge_ladder =  \n    derivation_ge_LeftDerivationLadder[OF derivation_ge_\\<delta> ladder ladder_i_0]"], ["proof (state)\nthis:\n  ?index < length L \\<Longrightarrow>\n  length \\<delta> \\<le> ladder_i L ?index \\<and>\n  length \\<delta> \\<le> ladder_j L ?index\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have ladder_last_j_lower_bound: \"ladder_last_j L \\<ge> length \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> ladder_last_j L", "using LeftDerivationLadder_def derivation_ge_ladder is_ladder_def ladder \n      ladder_last_j_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  ?index < length L \\<Longrightarrow>\n  length \\<delta> \\<le> ladder_i L ?index \\<and>\n  length \\<delta> \\<le> ladder_j L ?index\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  ladder_last_j ?L = ladder_j ?L (length ?L - 1)\n\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> ladder_last_j L", "by auto"], ["proof (state)\nthis:\n  length \\<delta> \\<le> ladder_last_j L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "from ladder_last_j_upper_bound ladder_last_j_lower_bound"], ["proof (chain)\npicking this:\n  ladder_last_j L < length \\<gamma>\n  length \\<delta> \\<le> ladder_last_j L", "have \\<delta>_less_\\<gamma>: \"length \\<delta> < length \\<gamma>\""], ["proof (prove)\nusing this:\n  ladder_last_j L < length \\<gamma>\n  length \\<delta> \\<le> ladder_last_j L\n\ngoal (1 subgoal):\n 1. length \\<delta> < length \\<gamma>", "by arith"], ["proof (state)\nthis:\n  length \\<delta> < length \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  length \\<delta> < length \\<gamma>", "have \\<gamma>_def: \"\\<gamma> = \\<delta> @ \\<gamma>'\""], ["proof (prove)\nusing this:\n  length \\<delta> < length \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<gamma> = \\<delta> @ \\<gamma>'", "by (metis LeftDerivation.simps(1) LeftDerivationLadder_def LeftDerivation_ge_take \\<gamma>' \n      append_eq_conv_conj derivation_ge_\\<delta> ladder)"], ["proof (state)\nthis:\n  \\<gamma> = \\<delta> @ \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have length_L_nonzero: \"length L \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L \\<noteq> 0", "using LeftDerivationLadder_def is_ladder_def ladder"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. length L \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length L \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have ladder_i_L'_thm: \"\\<And> index. index < length L \\<Longrightarrow> ladder_i L' index + length \\<delta> = ladder_i L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_i L' index + length \\<delta> = ladder_i L index", "apply (simp add: L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_i (ladder_cut_prefix (length \\<delta>) L) index +\n       length \\<delta> =\n       ladder_i L index", "apply (subst ladder_cut_prefix_i)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index. index < length L \\<Longrightarrow> index < length L\n 2. \\<And>index. index < length L \\<Longrightarrow> 0 < length L\n 3. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_i L index - length \\<delta> + length \\<delta> =\n       ladder_i L index", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index. index < length L \\<Longrightarrow> 0 < length L\n 2. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_i L index - length \\<delta> + length \\<delta> =\n       ladder_i L index", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>index. index < length L \\<Longrightarrow> 0 < length L\n 2. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_i L index - length \\<delta> + length \\<delta> =\n       ladder_i L index", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_i L index - length \\<delta> + length \\<delta> =\n       ladder_i L index", "using derivation_ge_ladder"], ["proof (prove)\nusing this:\n  ?index < length L \\<Longrightarrow>\n  length \\<delta> \\<le> ladder_i L ?index \\<and>\n  length \\<delta> \\<le> ladder_j L ?index\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_i L index - length \\<delta> + length \\<delta> =\n       ladder_i L index", "by auto"], ["proof (state)\nthis:\n  ?index < length L \\<Longrightarrow>\n  ladder_i L' ?index + length \\<delta> = ladder_i L ?index\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have ladder_j_L'_thm: \"\\<And> index. index < length L \\<Longrightarrow> ladder_j L' index + length \\<delta> = ladder_j L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j L' index + length \\<delta> = ladder_j L index", "apply (simp add: L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j (ladder_cut_prefix (length \\<delta>) L) index +\n       length \\<delta> =\n       ladder_j L index", "apply (subst ladder_cut_prefix_j)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index. index < length L \\<Longrightarrow> index < length L\n 2. \\<And>index. index < length L \\<Longrightarrow> 0 < length L\n 3. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j L index - length \\<delta> + length \\<delta> =\n       ladder_j L index", "using LeftDerivationLadder_def is_ladder_def ladder"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (3 subgoals):\n 1. \\<And>index. index < length L \\<Longrightarrow> index < length L\n 2. \\<And>index. index < length L \\<Longrightarrow> 0 < length L\n 3. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j L index - length \\<delta> + length \\<delta> =\n       ladder_j L index", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index. index < length L \\<Longrightarrow> 0 < length L\n 2. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j L index - length \\<delta> + length \\<delta> =\n       ladder_j L index", "using LeftDerivationLadder_def is_ladder_def ladder"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<And>index. index < length L \\<Longrightarrow> 0 < length L\n 2. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j L index - length \\<delta> + length \\<delta> =\n       ladder_j L index", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j L index - length \\<delta> + length \\<delta> =\n       ladder_j L index", "using derivation_ge_ladder"], ["proof (prove)\nusing this:\n  ?index < length L \\<Longrightarrow>\n  length \\<delta> \\<le> ladder_i L ?index \\<and>\n  length \\<delta> \\<le> ladder_j L ?index\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       index < length L \\<Longrightarrow>\n       ladder_j L index - length \\<delta> + length \\<delta> =\n       ladder_j L index", "by auto"], ["proof (state)\nthis:\n  ?index < length L \\<Longrightarrow>\n  ladder_j L' ?index + length \\<delta> = ladder_j L ?index\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have length_L': \"length L' = length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L' = length L", "using L' ladder_cut_prefix_length"], ["proof (prove)\nusing this:\n  L' = ladder_cut_prefix (length \\<delta>) L\n  length (ladder_cut_prefix ?d ?L) = length ?L\n\ngoal (1 subgoal):\n 1. length L' = length L", "by simp"], ["proof (state)\nthis:\n  length L' = length L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have \\<alpha>_\\<gamma>': \"LeftDerivation \\<alpha> D' \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> D' \\<gamma>'", "using D' LeftDerivationLadder_def LeftDerivation_skip_prefix \\<gamma>' derivation_ge_\\<delta> ladder"], ["proof (prove)\nusing this:\n  D' = derivation_shift D (length \\<delta>) 0\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  \\<lbrakk>LeftDerivation (?u @ ?v) ?D ?w;\n   derivation_ge ?D (length ?u)\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?v (derivation_shift ?D (length ?u) 0)\n                     (drop (length ?u) ?w)\n  \\<gamma>' = drop (length \\<delta>) \\<gamma>\n  derivation_ge D (length \\<delta>)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. LeftDerivation \\<alpha> D' \\<gamma>'", "by blast"], ["proof (state)\nthis:\n  LeftDerivation \\<alpha> D' \\<gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have length_D': \"length D' = length D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length D' = length D", "by (simp add: D')"], ["proof (state)\nthis:\n  length D' = length D\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have is_ladder_D_L: \"is_ladder D L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ladder D L", "using LeftDerivationLadder_def ladder"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (1 subgoal):\n 1. is_ladder D L", "by blast"], ["proof (state)\nthis:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "{"], ["proof (state)\nthis:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "assume u_bound_L': \"u < length L'\""], ["proof (state)\nthis:\n  u < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have u_bound_L: \"u < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < length L", "using length_L'"], ["proof (prove)\nusing this:\n  length L' = length L\n\ngoal (1 subgoal):\n 1. u < length L", "using u_bound_L'"], ["proof (prove)\nusing this:\n  length L' = length L\n  u < length L'\n\ngoal (1 subgoal):\n 1. u < length L", "by simp"], ["proof (state)\nthis:\n  u < length L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have \"ladder_n L' u \\<le> length D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' u \\<le> length D'", "apply (simp add: length_D' L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (ladder_cut_prefix (length \\<delta>) L) u \\<le> length D", "apply (subst ladder_cut_prefix_n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. u < length L\n 2. 0 < length L\n 3. ladder_n L u \\<le> length D", "apply (simp add: u_bound_L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L u \\<le> length D", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L u \\<le> length D", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> length D", "using u_bound_L is_ladder_D_L"], ["proof (prove)\nusing this:\n  u < length L\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. ladder_n L u \\<le> length D", "by (simp add: is_ladder_def)"], ["proof (state)\nthis:\n  ladder_n L' u \\<le> length D'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "}"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length D'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "note is_ladder_1 = this"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length D'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "{"], ["proof (state)\nthis:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length D'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "fix v :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "assume u_less_v: \"u < v\""], ["proof (state)\nthis:\n  u < v\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "assume v_bound_L': \"v < length L'\""], ["proof (state)\nthis:\n  v < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  v < length L'", "have v_bound_L: \"v < length L\""], ["proof (prove)\nusing this:\n  v < length L'\n\ngoal (1 subgoal):\n 1. v < length L", "by (simp add: length_L')"], ["proof (state)\nthis:\n  v < length L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "with u_less_v"], ["proof (chain)\npicking this:\n  u < v\n  v < length L", "have u_bound_L: \"u < length L\""], ["proof (prove)\nusing this:\n  u < v\n  v < length L\n\ngoal (1 subgoal):\n 1. u < length L", "by arith"], ["proof (state)\nthis:\n  u < length L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have \"ladder_n L' u < ladder_n L' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L' u < ladder_n L' v", "apply (simp add: L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (ladder_cut_prefix (length \\<delta>) L) u\n    < ladder_n (ladder_cut_prefix (length \\<delta>) L) v", "apply (subst ladder_cut_prefix_n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. u < length L\n 2. 0 < length L\n 3. ladder_n L u < ladder_n (ladder_cut_prefix (length \\<delta>) L) v", "using u_bound_L"], ["proof (prove)\nusing this:\n  u < length L\n\ngoal (3 subgoals):\n 1. u < length L\n 2. 0 < length L\n 3. ladder_n L u < ladder_n (ladder_cut_prefix (length \\<delta>) L) v", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L u < ladder_n (ladder_cut_prefix (length \\<delta>) L) v", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L u < ladder_n (ladder_cut_prefix (length \\<delta>) L) v", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L u < ladder_n (ladder_cut_prefix (length \\<delta>) L) v", "apply (subst ladder_cut_prefix_n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. v < length L\n 2. 0 < length L\n 3. ladder_n L u < ladder_n L v", "using v_bound_L"], ["proof (prove)\nusing this:\n  v < length L\n\ngoal (3 subgoals):\n 1. v < length L\n 2. 0 < length L\n 3. ladder_n L u < ladder_n L v", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L u < ladder_n L v", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L u < ladder_n L v", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L u < ladder_n L v", "using u_less_v v_bound_L is_ladder_D_L"], ["proof (prove)\nusing this:\n  u < v\n  v < length L\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. ladder_n L u < ladder_n L v", "by (simp add: is_ladder_def)"], ["proof (state)\nthis:\n  ladder_n L' u < ladder_n L' v\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "note is_ladder_2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have is_ladder_3: \"ladder_last_n L' = length D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_last_n L' = length D'", "apply (simp add: length_D' ladder_last_n_def L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n (ladder_cut_prefix (length \\<delta>) L)\n     (length (ladder_cut_prefix (length \\<delta>) L) - Suc 0) =\n    length D", "apply (subst ladder_cut_prefix_n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (ladder_cut_prefix (length \\<delta>) L) - Suc 0 < length L\n 2. 0 < length L\n 3. ladder_n L (length (ladder_cut_prefix (length \\<delta>) L) - Suc 0) =\n    length D", "apply (simp add: ladder_cut_prefix_length)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length L - Suc 0 < length L\n 2. 0 < length L\n 3. ladder_n L (length (ladder_cut_prefix (length \\<delta>) L) - Suc 0) =\n    length D", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (3 subgoals):\n 1. length L - Suc 0 < length L\n 2. 0 < length L\n 3. ladder_n L (length (ladder_cut_prefix (length \\<delta>) L) - Suc 0) =\n    length D", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L (length (ladder_cut_prefix (length \\<delta>) L) - Suc 0) =\n    length D", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < length L\n 2. ladder_n L (length (ladder_cut_prefix (length \\<delta>) L) - Suc 0) =\n    length D", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (length (ladder_cut_prefix (length \\<delta>) L) - Suc 0) =\n    length D", "apply (simp add: ladder_cut_prefix_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_n L (length L - Suc 0) = length D", "using is_ladder_D_L"], ["proof (prove)\nusing this:\n  is_ladder D L\n\ngoal (1 subgoal):\n 1. ladder_n L (length L - Suc 0) = length D", "by (simp add: is_ladder_def ladder_last_n_def)"], ["proof (state)\nthis:\n  ladder_last_n L' = length D'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have is_ladder_4: \"LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D') \n    (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)", "have ldfix: \"LeftDerivationFix (\\<delta>@\\<alpha>) (ladder_i L 0) (take (ladder_n L 0) D) \n    (ladder_j L 0) (ladder_\\<gamma> (\\<delta>@\\<alpha>) D L 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<delta> @ \\<alpha>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)", "using ladder LeftDerivationLadder_def"], ["proof (prove)\nusing this:\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix (\\<delta> @ \\<alpha>) (ladder_i L 0)\n     (take (ladder_n L 0) D) (ladder_j L 0)\n     (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)", "by blast"], ["proof (state)\nthis:\n  LeftDerivationFix (\\<delta> @ \\<alpha>) (ladder_i L 0)\n   (take (ladder_n L 0) D) (ladder_j L 0)\n   (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)", "have dge: \"derivation_ge (take (ladder_n L 0) D) (length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge (take (ladder_n L 0) D) (length \\<delta>)", "using derivation_ge_\\<delta>"], ["proof (prove)\nusing this:\n  derivation_ge D (length \\<delta>)\n\ngoal (1 subgoal):\n 1. derivation_ge (take (ladder_n L 0) D) (length \\<delta>)", "by (metis append_take_drop_id derivation_ge_append)"], ["proof (state)\nthis:\n  derivation_ge (take (ladder_n L 0) D) (length \\<delta>)\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)", "from LeftDerivationFix_cut_prefix[OF ldfix dge ladder_i_0 is_word_\\<delta>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n      (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n      (ladder_j L 0 - length \\<delta>) \\<gamma>'", "obtain \\<gamma>' where \\<gamma>': \"ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n      LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>) (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n      (ladder_j L 0 - length \\<delta>) \\<gamma>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n      (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n      (ladder_j L 0 - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 =\n        \\<delta> @ \\<gamma>' \\<and>\n        LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n         (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n         (ladder_j L 0 - length \\<delta>) \\<gamma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n   (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n   (ladder_j L 0 - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)", "then"], ["proof (chain)\npicking this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n   (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n   (ladder_j L 0 - length \\<delta>) \\<gamma>'", "show ?thesis"], ["proof (prove)\nusing this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n   (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n   (ladder_j L 0 - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)", "using LeftDerivationLadder_cut_prefix_propagate D' L' append_eq_conv_conj derivation_ge_\\<delta> \n        is_word_\\<delta> ladder ladder_cut_prefix_i ladder_cut_prefix_j ladder_cut_prefix_n ladder_i_0 \n        length_0_conv length_L_nonzero length_greater_0_conv take_derivation_shift"], ["proof (prove)\nusing this:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L 0 = \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationFix \\<alpha> (ladder_i L 0 - length \\<delta>)\n   (derivation_shift (take (ladder_n L 0) D) (length \\<delta>) 0)\n   (ladder_j L 0 - length \\<delta>) \\<gamma>'\n  \\<lbrakk>LeftDerivationLadder (?\\<delta> @ ?\\<alpha>) ?D ?L ?\\<gamma>;\n   is_word ?\\<delta>; derivation_ge ?D (length ?\\<delta>);\n   length ?\\<delta> \\<le> ladder_i ?L 0;\n   ?L' = ladder_cut_prefix (length ?\\<delta>) ?L;\n   ?D' = derivation_shift ?D (length ?\\<delta>) 0;\n   ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?\\<alpha>\n                     (take (ladder_n ?L' ?index) ?D')\n                     (ladder_\\<gamma> ?\\<alpha> ?D' ?L' ?index) \\<and>\n                    ladder_\\<alpha> (?\\<delta> @ ?\\<alpha>) ?D ?L ?index =\n                    ?\\<delta> @\n                    ladder_\\<alpha> ?\\<alpha> ?D' ?L' ?index \\<and>\n                    ladder_\\<gamma> (?\\<delta> @ ?\\<alpha>) ?D ?L ?index =\n                    ?\\<delta> @ ladder_\\<gamma> ?\\<alpha> ?D' ?L' ?index\n  D' = derivation_shift D (length \\<delta>) 0\n  L' = ladder_cut_prefix (length \\<delta>) L\n  (?xs @ ?ys = ?zs) =\n  (?xs = take (length ?xs) ?zs \\<and> ?ys = drop (length ?xs) ?zs)\n  derivation_ge D (length \\<delta>)\n  is_word \\<delta>\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_i (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_i ?L ?index - ?d\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_j (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_j ?L ?index - ?d\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_n (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_n ?L ?index\n  length \\<delta> \\<le> ladder_i L 0\n  (length ?xs = 0) = (?xs = [])\n  length L \\<noteq> 0\n  (0 < length ?xs) = (?xs \\<noteq> [])\n  take ?n (derivation_shift ?D ?left ?right) =\n  derivation_shift (take ?n ?D) ?left ?right\n\ngoal (1 subgoal):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)", "by auto"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "{"], ["proof (state)\nthis:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "fix index :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "assume index_lower_bound: \"Suc 0 \\<le> index\""], ["proof (state)\nthis:\n  Suc 0 \\<le> index\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "assume index_upper_bound: \"index < length L'\""], ["proof (state)\nthis:\n  index < length L'\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have introsAt: \"LeftDerivationIntrosAt (\\<delta>@\\<alpha>) D L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L index", "by (metis LeftDerivationIntros_def LeftDerivationLadder_def One_nat_def index_lower_bound \n        index_upper_bound ladder length_L')"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L index\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L index", "have ladder_i_L: \"ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\""], ["proof (prove)\nusing this:\n  LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L index\n\ngoal (1 subgoal):\n 1. ladder_i L index = fst (D ! ladder_n L (index - Suc 0))", "by (metis LeftDerivationIntrosAt_def One_nat_def \\<open>LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L index\\<close>)"], ["proof (state)\nthis:\n  ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have ladder_i_L'_as_L: \"ladder_i L' index = ladder_i L index - (length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L index - length \\<delta>", "using ladder_cut_prefix_i L' index_upper_bound is_ladder_D_L is_ladder_not_empty length_L' \n        length_greater_0_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_i (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_i ?L ?index - ?d\n  L' = ladder_cut_prefix (length \\<delta>) L\n  index < length L'\n  is_ladder D L\n  is_ladder ?D ?L \\<Longrightarrow> ?L \\<noteq> []\n  length L' = length L\n  (0 < length ?xs) = (?xs \\<noteq> [])\n\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L index - length \\<delta>", "by auto"], ["proof (state)\nthis:\n  ladder_i L' index = ladder_i L index - length \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have length_L_gr_0: \"length L > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length L", "using length_L' length_L_nonzero"], ["proof (prove)\nusing this:\n  length L' = length L\n  length L \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < length L", "by arith"], ["proof (state)\nthis:\n  0 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have index_Suc_upper_bound_L: \"index - Suc 0 < length L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index - Suc 0 < length L", "using index_upper_bound length_L'"], ["proof (prove)\nusing this:\n  index < length L'\n  length L' = length L\n\ngoal (1 subgoal):\n 1. index - Suc 0 < length L", "by arith"], ["proof (state)\nthis:\n  index - Suc 0 < length L\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have \"fst (D' ! ladder_n L' (index - Suc 0)) =  fst (D ! ladder_n L (index - Suc 0)) - (length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (D' ! ladder_n L' (index - Suc 0)) =\n    fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>", "apply (subst D', subst L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (derivation_shift D (length \\<delta>) 0 !\n         ladder_n (ladder_cut_prefix (length \\<delta>) L) (index - Suc 0)) =\n    fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>", "apply (subst ladder_cut_prefix_n[OF index_Suc_upper_bound_L length_L_gr_0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (derivation_shift D (length \\<delta>) 0 !\n         ladder_n L (index - Suc 0)) =\n    fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>", "apply (simp add: derivation_shift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (map (\\<lambda>d. (fst d - length \\<delta>, snd d)) D !\n         ladder_n L (index - Suc 0)) =\n    fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>", "using index_lower_bound index_upper_bound is_ladder_D_L ladder_n_minus_1_bound length_L'"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n  index < length L'\n  is_ladder D L\n  \\<lbrakk>is_ladder ?D ?L; 1 \\<le> ?index; ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_n ?L (?index - Suc 0) < length ?D\n  length L' = length L\n\ngoal (1 subgoal):\n 1. fst (map (\\<lambda>d. (fst d - length \\<delta>, snd d)) D !\n         ladder_n L (index - Suc 0)) =\n    fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>", "by auto"], ["proof (state)\nthis:\n  fst (D' ! ladder_n L' (index - Suc 0)) =\n  fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  fst (D' ! ladder_n L' (index - Suc 0)) =\n  fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>", "have ladder_i_L': \"ladder_i L' index = fst (D' ! ladder_n L' (index - Suc 0))\""], ["proof (prove)\nusing this:\n  fst (D' ! ladder_n L' (index - Suc 0)) =\n  fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>\n\ngoal (1 subgoal):\n 1. ladder_i L' index = fst (D' ! ladder_n L' (index - Suc 0))", "using ladder_i_L ladder_i_L'_as_L"], ["proof (prove)\nusing this:\n  fst (D' ! ladder_n L' (index - Suc 0)) =\n  fst (D ! ladder_n L (index - Suc 0)) - length \\<delta>\n  ladder_i L index = fst (D ! ladder_n L (index - Suc 0))\n  ladder_i L' index = ladder_i L index - length \\<delta>\n\ngoal (1 subgoal):\n 1. ladder_i L' index = fst (D' ! ladder_n L' (index - Suc 0))", "by auto"], ["proof (state)\nthis:\n  ladder_i L' index = fst (D' ! ladder_n L' (index - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "have \"LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index) (ladder_i L' index)\n      (snd (D' ! ladder_n L' (index - Suc 0))) (ladder_ix L' index)\n      (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D')) (ladder_j L' index)\n      (ladder_\\<gamma> \\<alpha> D' L' index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have \"LeftDerivationIntro (ladder_\\<alpha> (\\<delta>@\\<alpha>) D L index) (ladder_i L index)\n        (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n        (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)) (ladder_j L index)\n        (ladder_\\<gamma> (\\<delta>@\\<alpha>) D L index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index)\n     (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n     (ladder_ix L index)\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)", "using introsAt"], ["proof (prove)\nusing this:\n  LeftDerivationIntrosAt (\\<delta> @ \\<alpha>) D L index\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index)\n     (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n     (ladder_ix L index)\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)", "by (metis LeftDerivationIntrosAt_def One_nat_def)"], ["proof (state)\nthis:\n  LeftDerivationIntro (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index)\n   (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n   (ladder_ix L index)\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "then"], ["proof (chain)\npicking this:\n  LeftDerivationIntro (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index)\n   (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n   (ladder_ix L index)\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)", "have ldintro: \"LeftDerivationIntro (\\<delta>@(ladder_\\<alpha> \\<alpha> D' L' index)) (ladder_i L index)\n        (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n        (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)) (ladder_j L index)\n        (ladder_\\<gamma> (\\<delta>@\\<alpha>) D L index)\""], ["proof (prove)\nusing this:\n  LeftDerivationIntro (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index)\n   (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n   (ladder_ix L index)\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (\\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n     (ladder_ix L index)\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)", "using D' L' LeftDerivationLadder_cut_prefix_propagate derivation_ge_\\<delta> index_upper_bound \n          is_word_\\<delta> ladder ladder_i_0 length_L'"], ["proof (prove)\nusing this:\n  LeftDerivationIntro (ladder_\\<alpha> (\\<delta> @ \\<alpha>) D L index)\n   (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n   (ladder_ix L index)\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)\n  D' = derivation_shift D (length \\<delta>) 0\n  L' = ladder_cut_prefix (length \\<delta>) L\n  \\<lbrakk>LeftDerivationLadder (?\\<delta> @ ?\\<alpha>) ?D ?L ?\\<gamma>;\n   is_word ?\\<delta>; derivation_ge ?D (length ?\\<delta>);\n   length ?\\<delta> \\<le> ladder_i ?L 0;\n   ?L' = ladder_cut_prefix (length ?\\<delta>) ?L;\n   ?D' = derivation_shift ?D (length ?\\<delta>) 0;\n   ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?\\<alpha>\n                     (take (ladder_n ?L' ?index) ?D')\n                     (ladder_\\<gamma> ?\\<alpha> ?D' ?L' ?index) \\<and>\n                    ladder_\\<alpha> (?\\<delta> @ ?\\<alpha>) ?D ?L ?index =\n                    ?\\<delta> @\n                    ladder_\\<alpha> ?\\<alpha> ?D' ?L' ?index \\<and>\n                    ladder_\\<gamma> (?\\<delta> @ ?\\<alpha>) ?D ?L ?index =\n                    ?\\<delta> @ ladder_\\<gamma> ?\\<alpha> ?D' ?L' ?index\n  derivation_ge D (length \\<delta>)\n  index < length L'\n  is_word \\<delta>\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  length \\<delta> \\<le> ladder_i L 0\n  length L' = length L\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (\\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n     (ladder_ix L index)\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)", "by auto"], ["proof (state)\nthis:\n  LeftDerivationIntro (\\<delta> @ ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L index) (snd (D ! ladder_n L (index - Suc 0)))\n   (ladder_ix L index)\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (ladder_j L index) (ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have dge: \"derivation_ge (drop (Suc (ladder_n L (index - Suc 0))) \n        (take (ladder_n L index) D)) (length \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivation_ge\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>)", "using derivation_ge_\\<delta>"], ["proof (prove)\nusing this:\n  derivation_ge D (length \\<delta>)\n\ngoal (1 subgoal):\n 1. derivation_ge\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>)", "by (metis append_take_drop_id derivation_ge_append)"], ["proof (state)\nthis:\n  derivation_ge\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (length \\<delta>)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have \\<delta>_le_i_L: \"length \\<delta> \\<le> ladder_i L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> ladder_i L index", "using derivation_ge_ladder index_upper_bound length_L'"], ["proof (prove)\nusing this:\n  ?index < length L \\<Longrightarrow>\n  length \\<delta> \\<le> ladder_i L ?index \\<and>\n  length \\<delta> \\<le> ladder_j L ?index\n  index < length L'\n  length L' = length L\n\ngoal (1 subgoal):\n 1. length \\<delta> \\<le> ladder_i L index", "by auto"], ["proof (state)\nthis:\n  length \\<delta> \\<le> ladder_i L index\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "from LeftDerivationIntro_cut_prefix[OF ldintro dge \\<delta>_le_i_L is_word_\\<delta>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n      (ladder_i L index - length \\<delta>)\n      (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n      (derivation_shift\n        (drop (Suc (ladder_n L (index - Suc 0)))\n          (take (ladder_n L index) D))\n        (length \\<delta>) 0)\n      (ladder_j L index - length \\<delta>) \\<gamma>'", "obtain \\<gamma>' where \\<gamma>':\n         \"ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index = \\<delta> @ \\<gamma>' \\<and>\n           LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index) (ladder_i L index - length \\<delta>)\n           (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n           (derivation_shift (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)) \n           (length \\<delta>) 0) (ladder_j L index - length \\<delta>) \\<gamma>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<gamma>'.\n     ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n     \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n      (ladder_i L index - length \\<delta>)\n      (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n      (derivation_shift\n        (drop (Suc (ladder_n L (index - Suc 0)))\n          (take (ladder_n L index) D))\n        (length \\<delta>) 0)\n      (ladder_j L index - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>'.\n        ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n        \\<delta> @ \\<gamma>' \\<and>\n        LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n         (ladder_i L index - length \\<delta>)\n         (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n         (derivation_shift\n           (drop (Suc (ladder_n L (index - Suc 0)))\n             (take (ladder_n L index) D))\n           (length \\<delta>) 0)\n         (ladder_j L index - length \\<delta>) \\<gamma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L index - length \\<delta>)\n   (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n   (derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0)\n   (ladder_j L index - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have h1: \"ladder_i L' index = ladder_i L index - length \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L index - length \\<delta>", "using L' ladder_cut_prefix_i ladder_i_L'_as_L"], ["proof (prove)\nusing this:\n  L' = ladder_cut_prefix (length \\<delta>) L\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_i (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_i ?L ?index - ?d\n  ladder_i L' index = ladder_i L index - length \\<delta>\n\ngoal (1 subgoal):\n 1. ladder_i L' index = ladder_i L index - length \\<delta>", "by blast"], ["proof (state)\nthis:\n  ladder_i L' index = ladder_i L index - length \\<delta>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have h2: \"(snd (D' ! ladder_n L' (index - Suc 0))) = (snd (D ! ladder_n L (index - Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (D' ! ladder_n L' (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "apply (subst L', subst ladder_cut_prefix_n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index - Suc 0 < length L\n 2. 0 < length L\n 3. snd (D' ! ladder_n L (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "apply (simp add: index_Suc_upper_bound_L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length L\n 2. snd (D' ! ladder_n L (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "using length_L_gr_0"], ["proof (prove)\nusing this:\n  0 < length L\n\ngoal (2 subgoals):\n 1. 0 < length L\n 2. snd (D' ! ladder_n L (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (D' ! ladder_n L (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "apply (subst D')"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (derivation_shift D (length \\<delta>) 0 !\n         ladder_n L (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "apply (simp add: derivation_shift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (map (\\<lambda>d. (fst d - length \\<delta>, snd d)) D !\n         ladder_n L (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "using index_lower_bound index_upper_bound is_ladder_D_L ladder_n_minus_1_bound \n          length_L'"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> index\n  index < length L'\n  is_ladder D L\n  \\<lbrakk>is_ladder ?D ?L; 1 \\<le> ?index; ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_n ?L (?index - Suc 0) < length ?D\n  length L' = length L\n\ngoal (1 subgoal):\n 1. snd (map (\\<lambda>d. (fst d - length \\<delta>, snd d)) D !\n         ladder_n L (index - Suc 0)) =\n    snd (D ! ladder_n L (index - Suc 0))", "by auto"], ["proof (state)\nthis:\n  snd (D' ! ladder_n L' (index - Suc 0)) =\n  snd (D ! ladder_n L (index - Suc 0))\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have h3: \"ladder_ix L' index = ladder_ix L index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L index", "using ladder_cut_prefix_ix L' index_upper_bound length_L' length_L_gr_0"], ["proof (prove)\nusing this:\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_ix (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_ix ?L ?index\n  L' = ladder_cut_prefix (length \\<delta>) L\n  index < length L'\n  length L' = length L\n  0 < length L\n\ngoal (1 subgoal):\n 1. ladder_ix L' index = ladder_ix L index", "by auto"], ["proof (state)\nthis:\n  ladder_ix L' index = ladder_ix L index\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have h4: \"(drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D')) = \n        (derivation_shift (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D)) \n           (length \\<delta>) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D') =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply (subst D')"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L' (index - Suc 0)))\n     (take (ladder_n L' index) (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply (subst L')+"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop\n     (Suc (ladder_n (ladder_cut_prefix (length \\<delta>) L)\n            (index - Suc 0)))\n     (take (ladder_n (ladder_cut_prefix (length \\<delta>) L) index)\n       (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply (subst ladder_cut_prefix_n, simp add: index_Suc_upper_bound_L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length L\n 2. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n (ladder_cut_prefix (length \\<delta>) L) index)\n       (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "using length_L_gr_0"], ["proof (prove)\nusing this:\n  0 < length L\n\ngoal (2 subgoals):\n 1. 0 < length L\n 2. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n (ladder_cut_prefix (length \\<delta>) L) index)\n       (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n (ladder_cut_prefix (length \\<delta>) L) index)\n       (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply (subst ladder_cut_prefix_n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. index < length L\n 2. 0 < length L\n 3. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n L index) (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "using index_upper_bound length_L'"], ["proof (prove)\nusing this:\n  index < length L'\n  length L' = length L\n\ngoal (3 subgoals):\n 1. index < length L\n 2. 0 < length L\n 3. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n L index) (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply arith"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length L\n 2. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n L index) (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "using length_L_gr_0"], ["proof (prove)\nusing this:\n  0 < length L\n\ngoal (2 subgoals):\n 1. 0 < length L\n 2. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n L index) (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n L index) (derivation_shift D (length \\<delta>) 0)) =\n    derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0", "apply (simp add: derivation_shift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc (ladder_n L (index - Suc 0)))\n     (take (ladder_n L index)\n       (map (\\<lambda>d. (fst d - length \\<delta>, snd d)) D)) =\n    map (\\<lambda>d. (fst d - length \\<delta>, snd d))\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))", "by (simp add: drop_map take_map)"], ["proof (state)\nthis:\n  drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D') =\n  derivation_shift\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (length \\<delta>) 0\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have h5: \"ladder_j L' index = ladder_j L index - length \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L index - length \\<delta>", "using ladder_cut_prefix_j L' index_upper_bound length_L' length_L_gr_0"], ["proof (prove)\nusing this:\n  \\<lbrakk>?index < length ?L; 0 < length ?L\\<rbrakk>\n  \\<Longrightarrow> ladder_j (ladder_cut_prefix ?d ?L) ?index =\n                    ladder_j ?L ?index - ?d\n  L' = ladder_cut_prefix (length \\<delta>) L\n  index < length L'\n  length L' = length L\n  0 < length L\n\ngoal (1 subgoal):\n 1. ladder_j L' index = ladder_j L index - length \\<delta>", "by auto"], ["proof (state)\nthis:\n  ladder_j L' index = ladder_j L index - length \\<delta>\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have h6: \"ladder_\\<gamma> \\<alpha> D' L' index = \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladder_\\<gamma> \\<alpha> D' L' index = \\<gamma>'", "using D' L' LeftDerivationLadder_cut_prefix_propagate \\<gamma>' derivation_ge_\\<delta> index_upper_bound \n          is_word_\\<delta> ladder ladder_i_0 length_L'"], ["proof (prove)\nusing this:\n  D' = derivation_shift D (length \\<delta>) 0\n  L' = ladder_cut_prefix (length \\<delta>) L\n  \\<lbrakk>LeftDerivationLadder (?\\<delta> @ ?\\<alpha>) ?D ?L ?\\<gamma>;\n   is_word ?\\<delta>; derivation_ge ?D (length ?\\<delta>);\n   length ?\\<delta> \\<le> ladder_i ?L 0;\n   ?L' = ladder_cut_prefix (length ?\\<delta>) ?L;\n   ?D' = derivation_shift ?D (length ?\\<delta>) 0;\n   ?index < length ?L\\<rbrakk>\n  \\<Longrightarrow> LeftDerivation ?\\<alpha>\n                     (take (ladder_n ?L' ?index) ?D')\n                     (ladder_\\<gamma> ?\\<alpha> ?D' ?L' ?index) \\<and>\n                    ladder_\\<alpha> (?\\<delta> @ ?\\<alpha>) ?D ?L ?index =\n                    ?\\<delta> @\n                    ladder_\\<alpha> ?\\<alpha> ?D' ?L' ?index \\<and>\n                    ladder_\\<gamma> (?\\<delta> @ ?\\<alpha>) ?D ?L ?index =\n                    ?\\<delta> @ ladder_\\<gamma> ?\\<alpha> ?D' ?L' ?index\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L index - length \\<delta>)\n   (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n   (derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0)\n   (ladder_j L index - length \\<delta>) \\<gamma>'\n  derivation_ge D (length \\<delta>)\n  index < length L'\n  is_word \\<delta>\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n  length \\<delta> \\<le> ladder_i L 0\n  length L' = length L\n\ngoal (1 subgoal):\n 1. ladder_\\<gamma> \\<alpha> D' L' index = \\<gamma>'", "by auto"], ["proof (state)\nthis:\n  ladder_\\<gamma> \\<alpha> D' L' index = \\<gamma>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "using h1 h2 h3 h4 h5 h6 \\<gamma>'"], ["proof (prove)\nusing this:\n  ladder_i L' index = ladder_i L index - length \\<delta>\n  snd (D' ! ladder_n L' (index - Suc 0)) =\n  snd (D ! ladder_n L (index - Suc 0))\n  ladder_ix L' index = ladder_ix L index\n  drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D') =\n  derivation_shift\n   (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n   (length \\<delta>) 0\n  ladder_j L' index = ladder_j L index - length \\<delta>\n  ladder_\\<gamma> \\<alpha> D' L' index = \\<gamma>'\n  ladder_\\<gamma> (\\<delta> @ \\<alpha>) D L index =\n  \\<delta> @ \\<gamma>' \\<and>\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L index - length \\<delta>)\n   (snd (D ! ladder_n L (index - Suc 0))) (ladder_ix L index)\n   (derivation_shift\n     (drop (Suc (ladder_n L (index - Suc 0))) (take (ladder_n L index) D))\n     (length \\<delta>) 0)\n   (ladder_j L index - length \\<delta>) \\<gamma>'\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "by simp"], ["proof (state)\nthis:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n   (ladder_ix L' index)\n   (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D'))\n   (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n   (ladder_ix L' index)\n   (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D'))\n   (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "then"], ["proof (chain)\npicking this:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n   (ladder_ix L' index)\n   (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D'))\n   (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)", "have \"LeftDerivationIntrosAt \\<alpha> D' L' index\""], ["proof (prove)\nusing this:\n  LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n   (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n   (ladder_ix L' index)\n   (drop (Suc (ladder_n L' (index - Suc 0))) (take (ladder_n L' index) D'))\n   (ladder_j L' index) (ladder_\\<gamma> \\<alpha> D' L' index)\n\ngoal (1 subgoal):\n 1. LeftDerivationIntrosAt \\<alpha> D' L' index", "apply (auto simp add: LeftDerivationIntrosAt_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index)\n     (ladder_\\<gamma> \\<alpha> D' L' index) \\<Longrightarrow>\n    ladder_i L' index = fst (D' ! ladder_n L' (index - Suc 0))", "using ladder_i_L'"], ["proof (prove)\nusing this:\n  ladder_i L' index = fst (D' ! ladder_n L' (index - Suc 0))\n\ngoal (1 subgoal):\n 1. LeftDerivationIntro (ladder_\\<alpha> \\<alpha> D' L' index)\n     (ladder_i L' index) (snd (D' ! ladder_n L' (index - Suc 0)))\n     (ladder_ix L' index)\n     (drop (Suc (ladder_n L' (index - Suc 0)))\n       (take (ladder_n L' index) D'))\n     (ladder_j L' index)\n     (ladder_\\<gamma> \\<alpha> D' L' index) \\<Longrightarrow>\n    ladder_i L' index = fst (D' ! ladder_n L' (index - Suc 0))", "by blast"], ["proof (state)\nthis:\n  LeftDerivationIntrosAt \\<alpha> D' L' index\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Suc 0 \\<le> ?index2; ?index2 < length L'\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt \\<alpha> D' L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "note is_ladder_5 = this"], ["proof (state)\nthis:\n  \\<lbrakk>Suc 0 \\<le> ?index2; ?index2 < length L'\\<rbrakk>\n  \\<Longrightarrow> LeftDerivationIntrosAt \\<alpha> D' L' ?index2\n\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D' L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "apply (rule_tac x=\"D'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L' \\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "apply (rule_tac x=\"L'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<gamma>'.\n       \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n       LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n       D' = derivation_shift D (length \\<delta>) 0 \\<and>\n       length L' = length L \\<and>\n       ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n       ladder_last_j L' + length \\<delta> = ladder_last_j L", "apply (rule_tac x=\"\\<gamma>'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n    LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n    D' = derivation_shift D (length \\<delta>) 0 \\<and>\n    length L' = length L \\<and>\n    ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n    ladder_last_j L' + length \\<delta> = ladder_last_j L", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<gamma> = \\<delta> @ \\<gamma>'\n 2. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'\n 3. D' = derivation_shift D (length \\<delta>) 0\n 4. length L' = length L\n 5. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 6. ladder_last_j L' + length \\<delta> = ladder_last_j L", "using \\<gamma>_def"], ["proof (prove)\nusing this:\n  \\<gamma> = \\<delta> @ \\<gamma>'\n\ngoal (6 subgoals):\n 1. \\<gamma> = \\<delta> @ \\<gamma>'\n 2. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'\n 3. D' = derivation_shift D (length \\<delta>) 0\n 4. length L' = length L\n 5. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 6. ladder_last_j L' + length \\<delta> = ladder_last_j L", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'\n 2. D' = derivation_shift D (length \\<delta>) 0\n 3. length L' = length L\n 4. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 5. ladder_last_j L' + length \\<delta> = ladder_last_j L", "defer 1"], ["proof (prove)\ngoal (5 subgoals):\n 1. D' = derivation_shift D (length \\<delta>) 0\n 2. length L' = length L\n 3. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 4. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 5. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "using D'"], ["proof (prove)\nusing this:\n  D' = derivation_shift D (length \\<delta>) 0\n\ngoal (5 subgoals):\n 1. D' = derivation_shift D (length \\<delta>) 0\n 2. length L' = length L\n 3. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 4. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 5. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. length L' = length L\n 2. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 3. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 4. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "using L' ladder_cut_prefix_length"], ["proof (prove)\nusing this:\n  L' = ladder_cut_prefix (length \\<delta>) L\n  length (ladder_cut_prefix ?d ?L) = length ?L\n\ngoal (4 subgoals):\n 1. length L' = length L\n 2. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 3. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 4. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. ladder_i L' 0 + length \\<delta> = ladder_i L 0\n 2. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 3. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply (subst ladder_i_L'_thm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < length L\n 2. ladder_i L 0 = ladder_i L 0\n 3. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 4. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "using LeftDerivationLadder_def is_ladder_def ladder"], ["proof (prove)\nusing this:\n  LeftDerivationLadder ?a ?D ?L ?b =\n  (LeftDerivation ?a ?D ?b \\<and>\n   is_ladder ?D ?L \\<and>\n   LeftDerivationFix ?a (ladder_i ?L 0) (take (ladder_n ?L 0) ?D)\n    (ladder_j ?L 0) (ladder_\\<gamma> ?a ?D ?L 0) \\<and>\n   LeftDerivationIntros ?a ?D ?L)\n  is_ladder ?D ?L =\n  (?L \\<noteq> [] \\<and>\n   (\\<forall>u<length ?L. ladder_n ?L u \\<le> length ?D) \\<and>\n   (\\<forall>u v.\n       u < v \\<and> v < length ?L \\<longrightarrow>\n       ladder_n ?L u < ladder_n ?L v) \\<and>\n   ladder_last_n ?L = length ?D)\n  LeftDerivationLadder (\\<delta> @ \\<alpha>) D L \\<gamma>\n\ngoal (4 subgoals):\n 1. 0 < length L\n 2. ladder_i L 0 = ladder_i L 0\n 3. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 4. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. ladder_i L 0 = ladder_i L 0\n 2. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 3. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_last_j L' + length \\<delta> = ladder_last_j L\n 2. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply (simp add: ladder_last_j_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_j L' (length L' - Suc 0) + length \\<delta> =\n    ladder_j L (length L - Suc 0)\n 2. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply (subst ladder_j_L'_thm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length L' - Suc 0 < length L\n 2. ladder_j L (length L' - Suc 0) = ladder_j L (length L - Suc 0)\n 3. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply (simp add: length_L')"], ["proof (prove)\ngoal (3 subgoals):\n 1. length L - Suc 0 < length L\n 2. ladder_j L (length L' - Suc 0) = ladder_j L (length L - Suc 0)\n 3. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "using length_L_nonzero"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n\ngoal (3 subgoals):\n 1. length L - Suc 0 < length L\n 2. ladder_j L (length L' - Suc 0) = ladder_j L (length L - Suc 0)\n 3. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply arith"], ["proof (prove)\ngoal (2 subgoals):\n 1. ladder_j L (length L' - Suc 0) = ladder_j L (length L - Suc 0)\n 2. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply (simp add: length_L')"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationLadder \\<alpha> D' L' \\<gamma>'", "apply (auto simp add: LeftDerivationLadder_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. LeftDerivation \\<alpha> D' \\<gamma>'\n 2. is_ladder D' L'\n 3. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 4. LeftDerivationIntros \\<alpha> D' L'", "using \\<alpha>_\\<gamma>'"], ["proof (prove)\nusing this:\n  LeftDerivation \\<alpha> D' \\<gamma>'\n\ngoal (4 subgoals):\n 1. LeftDerivation \\<alpha> D' \\<gamma>'\n 2. is_ladder D' L'\n 3. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 4. LeftDerivationIntros \\<alpha> D' L'", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_ladder D' L'\n 2. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 3. LeftDerivationIntros \\<alpha> D' L'", "apply (auto simp add: is_ladder_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. L' = [] \\<Longrightarrow> False\n 2. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length D'\n 3. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 4. ladder_last_n L' = length D'\n 5. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 6. LeftDerivationIntros \\<alpha> D' L'", "using length_L_nonzero length_L'"], ["proof (prove)\nusing this:\n  length L \\<noteq> 0\n  length L' = length L\n\ngoal (6 subgoals):\n 1. L' = [] \\<Longrightarrow> False\n 2. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length D'\n 3. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 4. ladder_last_n L' = length D'\n 5. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 6. LeftDerivationIntros \\<alpha> D' L'", "apply auto[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length D'\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 3. ladder_last_n L' = length D'\n 4. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 5. LeftDerivationIntros \\<alpha> D' L'", "using is_ladder_1"], ["proof (prove)\nusing this:\n  ?u2 < length L' \\<Longrightarrow> ladder_n L' ?u2 \\<le> length D'\n\ngoal (5 subgoals):\n 1. \\<And>u. u < length L' \\<Longrightarrow> ladder_n L' u \\<le> length D'\n 2. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 3. ladder_last_n L' = length D'\n 4. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 5. LeftDerivationIntros \\<alpha> D' L'", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. ladder_last_n L' = length D'\n 3. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 4. LeftDerivationIntros \\<alpha> D' L'", "using is_ladder_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u2 < ?v2; ?v2 < length L'\\<rbrakk>\n  \\<Longrightarrow> ladder_n L' ?u2 < ladder_n L' ?v2\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u < v; v < length L'\\<rbrakk>\n       \\<Longrightarrow> ladder_n L' u < ladder_n L' v\n 2. ladder_last_n L' = length D'\n 3. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 4. LeftDerivationIntros \\<alpha> D' L'", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. ladder_last_n L' = length D'\n 2. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 3. LeftDerivationIntros \\<alpha> D' L'", "using is_ladder_3"], ["proof (prove)\nusing this:\n  ladder_last_n L' = length D'\n\ngoal (3 subgoals):\n 1. ladder_last_n L' = length D'\n 2. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 3. LeftDerivationIntros \\<alpha> D' L'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 2. LeftDerivationIntros \\<alpha> D' L'", "using is_ladder_4"], ["proof (prove)\nusing this:\n  LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n   (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n\ngoal (2 subgoals):\n 1. LeftDerivationFix \\<alpha> (ladder_i L' 0) (take (ladder_n L' 0) D')\n     (ladder_j L' 0) (ladder_\\<gamma> \\<alpha> D' L' 0)\n 2. LeftDerivationIntros \\<alpha> D' L'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. LeftDerivationIntros \\<alpha> D' L'", "by (auto simp add: LeftDerivationIntros_def is_ladder_5)"], ["proof (state)\nthis:\n  \\<exists>D' L' \\<gamma>'.\n     \\<gamma> = \\<delta> @ \\<gamma>' \\<and>\n     LeftDerivationLadder \\<alpha> D' L' \\<gamma>' \\<and>\n     D' = derivation_shift D (length \\<delta>) 0 \\<and>\n     length L' = length L \\<and>\n     ladder_i L' 0 + length \\<delta> = ladder_i L 0 \\<and>\n     ladder_last_j L' + length \\<delta> = ladder_last_j L\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}