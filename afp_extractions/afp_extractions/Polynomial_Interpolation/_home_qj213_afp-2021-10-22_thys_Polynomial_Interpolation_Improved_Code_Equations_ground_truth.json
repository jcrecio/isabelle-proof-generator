{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Improved_Code_Equations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma divmod_integer_code''[code]: \"divmod_integer k l =\n  (if k = 0 then (0, 0)\n    else if l > 0 then\n            (if k > 0 then divmod_abs' k l\n             else case divmod_abs' (- k) l of (r, s) \\<Rightarrow>\n                  if s = 0 then (- r, 0) else (- r - 1, l - s))\n    else if l = 0 then (0, k)\n    else apsnd uminus\n            (if k < 0 then divmod_abs' (-k) (-l)\n             else case divmod_abs' k (-l) of (r, s) \\<Rightarrow>\n                  if s = 0 then (- r, 0) else (- r - 1, - l - s)))\"", "lemma divmod_nat_code'[code]: \"Divides.divmod_nat m n = (\n  let k = integer_of_nat m; l = integer_of_nat n\n  in map_prod nat_of_integer nat_of_integer\n  (if k = 0 then (0, 0)\n    else if l = 0 then (0,k) else\n            divmod_abs' k l))\"", "lemma binomial_code[code]:\n  \"n choose k = (if k \\<le> n then fact n div (fact k * fact (n - k)) else 0)\""], "translations": [["", "lemma divmod_integer_code''[code]: \"divmod_integer k l =\n  (if k = 0 then (0, 0)\n    else if l > 0 then\n            (if k > 0 then divmod_abs' k l\n             else case divmod_abs' (- k) l of (r, s) \\<Rightarrow>\n                  if s = 0 then (- r, 0) else (- r - 1, l - s))\n    else if l = 0 then (0, k)\n    else apsnd uminus\n            (if k < 0 then divmod_abs' (-k) (-l)\n             else case divmod_abs' k (-l) of (r, s) \\<Rightarrow>\n                  if s = 0 then (- r, 0) else (- r - 1, - l - s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divmod_integer k l =\n    (if k = 0 then (0, 0)\n     else if 0 < l\n          then if 0 < k then divmod_abs' k l\n               else case divmod_abs' (- k) l of\n                    (r, s) \\<Rightarrow>\n                      if s = 0 then (- r, 0) else (- r - 1, l - s)\n          else if l = 0 then (0, k)\n               else apsnd uminus\n                     (if k < 0 then divmod_abs' (- k) (- l)\n                      else case divmod_abs' k (- l) of\n                           (r, s) \\<Rightarrow>\n                             if s = 0 then (- r, 0)\n                             else (- r - 1, - l - s)))", "unfolding divmod_integer_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = 0 then (0, 0)\n     else if 0 < l\n          then if 0 < k then Code_Numeral.divmod_abs k l\n               else case Code_Numeral.divmod_abs k l of\n                    (r, s) \\<Rightarrow>\n                      if s = 0 then (- r, 0) else (- r - 1, l - s)\n          else if l = 0 then (0, k)\n               else apsnd uminus\n                     (if k < 0 then Code_Numeral.divmod_abs k l\n                      else case Code_Numeral.divmod_abs k l of\n                           (r, s) \\<Rightarrow>\n                             if s = 0 then (- r, 0)\n                             else (- r - 1, - l - s))) =\n    (if k = 0 then (0, 0)\n     else if 0 < l\n          then if 0 < k then divmod_abs' k l\n               else case divmod_abs' (- k) l of\n                    (r, s) \\<Rightarrow>\n                      if s = 0 then (- r, 0) else (- r - 1, l - s)\n          else if l = 0 then (0, k)\n               else apsnd uminus\n                     (if k < 0 then divmod_abs' (- k) (- l)\n                      else case divmod_abs' k (- l) of\n                           (r, s) \\<Rightarrow>\n                             if s = 0 then (- r, 0)\n                             else (- r - 1, - l - s)))", "by (cases \"l = 0\"; cases \"l < 0\"; cases \"l > 0\"; auto split: prod.splits simp: divmod_abs'_def divmod_abs_def)"], ["", "code_printing \\<comment> \\<open>FIXME illusion of partiality\\<close>\n  constant divmod_abs' \\<rightharpoonup>\n    (SML) \"IntInf.divMod/ ( _,/ _ )\"\n    and (Eval) \"Integer.div'_mod/ ( _ )/ ( _ )\"\n    and (OCaml) \"Z.div'_rem\"\n    and (Haskell) \"divMod/ ( _ )/ ( _ )\"\n    and (Scala) \"!((k: BigInt) => (l: BigInt) =>/ if (l == 0)/ (BigInt(0), k) else/ (k '/% l))\""], ["", "subsection \\<open>@{const Divides.divmod_nat}.\\<close>"], ["", "text \\<open>We implement @{const Divides.divmod_nat} via @{const divmod_integer}\n  instead of invoking both division and modulo separately, \n  and we further simplify the case-analysis which is\n  performed in @{thm divmod_integer_code''}.\\<close>"], ["", "lemma divmod_nat_code'[code]: \"Divides.divmod_nat m n = (\n  let k = integer_of_nat m; l = integer_of_nat n\n  in map_prod nat_of_integer nat_of_integer\n  (if k = 0 then (0, 0)\n    else if l = 0 then (0,k) else\n            divmod_abs' k l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divmod_nat m n =\n    (let k = integer_of_nat m; l = integer_of_nat n\n     in map_prod nat_of_integer nat_of_integer\n         (if k = 0 then (0, 0)\n          else if l = 0 then (0, k) else divmod_abs' k l))", "using divmod_nat_code [of m n]"], ["proof (prove)\nusing this:\n  divmod_nat m n =\n  (let k = integer_of_nat m; l = integer_of_nat n\n   in map_prod nat_of_integer nat_of_integer\n       (if k = 0 then (0, 0)\n        else if l = 0 then (0, k) else Code_Numeral.divmod_abs k l))\n\ngoal (1 subgoal):\n 1. divmod_nat m n =\n    (let k = integer_of_nat m; l = integer_of_nat n\n     in map_prod nat_of_integer nat_of_integer\n         (if k = 0 then (0, 0)\n          else if l = 0 then (0, k) else divmod_abs' k l))", "by (simp add: divmod_abs'_def integer_of_nat_eq_of_nat Let_def)"], ["", "subsection \\<open>@{const binomial}\\<close>"], ["", "lemma binomial_code[code]:\n  \"n choose k = (if k \\<le> n then fact n div (fact k * fact (n - k)) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n choose k =\n    (if k \\<le> n then fact n div (fact k * fact (n - k)) else 0)", "using binomial_eq_0[of n k] binomial_altdef_nat[of k n]"], ["proof (prove)\nusing this:\n  n < k \\<Longrightarrow> n choose k = 0\n  k \\<le> n \\<Longrightarrow>\n  n choose k = fact n div (fact k * fact (n - k))\n\ngoal (1 subgoal):\n 1. n choose k =\n    (if k \\<le> n then fact n div (fact k * fact (n - k)) else 0)", "by simp"], ["", "end"]]}