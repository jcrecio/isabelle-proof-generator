{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Newton_Interpolation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma (in map_poly_comm_ring_hom) horner_composition_hom:\n  \"horner_composition (map hom cs) (map hom xs) = map_poly hom (horner_composition cs xs)\"", "lemma horner_coeffs_ints: assumes len: \"length cs \\<le> Suc (length ys)\"\n  shows \"(set (coeffs (horner_composition cs (map rat_of_int ys))) \\<subseteq> \\<int>) = (set cs \\<subseteq> \\<int>)\"", "lemma [simp]: \"xd i i = 0\" \"xd i j + xd j k = xd i k\" \"xd i j + xd k i = xd k j\"", "lemma Xii_1[simp]: \"Xij i i = 1\"", "lemma smult_1[simp]: \"smult d 1 = [:d:]\"", "lemma newton_poly_sum: \n  \"newton_poly n = sum_list (map (\\<lambda> i. smult (c i) (N i)) [0 ..< Suc n])\"", "lemma poly_newton_poly: \"poly (newton_poly n) y = sum_list (map (\\<lambda> i. c i * poly (N i) y) [0 ..< Suc n])\"", "lemma poly_N_xi: \"poly (N i) (x j) = pprod j 0 i\"", "lemma poly_N_xi_cond: \"poly (N i) (x j) = (if j < i then 0 else pprod j 0 i)\"", "lemma poly_newton_poly_xj: assumes \"j \\<le> n\"\n  shows \"poly (newton_poly n) (x j) = sum_list (map (\\<lambda> i. c i * poly (N i) (x j)) [0 ..< Suc j])\"", "lemma xd_diff: \"i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> xd i j \\<noteq> 0\"\n   \"i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> xd j i \\<noteq> 0\"", "lemma divided_differences_main: assumes \"k \\<le> n\" \"i < k\"\n  shows \"sum_list (map (\\<lambda> j. xij_f i (i + j) * pprod k i (i + j)) [0..<Suc k - i]) = \n  sum_list (map (\\<lambda> j. xij_f (Suc i) (Suc i + j) * pprod k (Suc i) (Suc i + j)) [0..<Suc k - Suc i])\"", "lemma divided_differences: assumes kn: \"k \\<le> n\" and ik: \"i \\<le> k\"\n  shows \"sum_list (map (\\<lambda> j. xij_f i (i + j) * pprod k i (i + j)) [0..<Suc k - i]) = f k\"", "lemma newton_poly_sound: assumes \"k \\<le> n\"\n  shows \"poly (newton_poly n) (x k) = f k\"", "lemma newton_poly_degree: \"degree (newton_poly n) \\<le> n\"", "lemma newton_coefficients_main: \n  \"k < n \\<Longrightarrow> newton_coefficients_main (rev (map f [0..<Suc k])) (rev (map x [0..<Suc k]))\n    = rev (map (\\<lambda> i. map (\\<lambda> j. xij_f j i) [0..<Suc i]) [0..<Suc k])\"", "lemma newton_coefficients: \"newton_coefficients = rev (map c [0 ..< n])\"", "lemma newton_poly_impl: assumes \"n = Suc nn\"\n  shows \"newton_poly_impl = newton_poly nn\"", "lemma divided_differences_impl_int_Some:\n  \"length gs \\<le> length ys \n  \\<Longrightarrow> divided_differences_impl_int gs g x ys = Some res\n  \\<Longrightarrow> divided_differences_impl (map rat_of_int gs) (rat_of_int g) (rat_of_int x) (map rat_of_int ys) = map rat_of_int res\n    \\<and> length res = Suc (length gs)\"", "lemma div_Ints_mod_0: assumes \"rat_of_int a / rat_of_int b \\<in> \\<int>\" \"b \\<noteq> 0\"\n  shows \"a mod b = 0\"", "lemma divided_differences_impl_int_None:\n  \"length gs \\<le> length ys \n  \\<Longrightarrow> divided_differences_impl_int gs g x ys = None\n  \\<Longrightarrow> x \\<notin> set (take (length gs) ys)\n  \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int gs) (rat_of_int g) (rat_of_int x) (map rat_of_int ys)) \\<notin> \\<int>\"", "lemma newton_coefficients_main_int_Some:\n  \"length gs = length ys \\<Longrightarrow> length ys \\<le> length xs  \n  \\<Longrightarrow> newton_coefficients_main_int gs ys = Some res\n  \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs) (map rat_of_int gs) (map rat_of_int ys) = map (map rat_of_int) res\n    \\<and> (\\<forall> x \\<in> set res. x \\<noteq> [] \\<and> length x \\<le> length ys) \\<and> length res = length gs\"", "lemma newton_coefficients_main_int_None: assumes dist: \"distinct xs\"\n  shows \"length gs = length ys \\<Longrightarrow> length ys \\<le> length xs  \n  \\<Longrightarrow> newton_coefficients_main_int gs ys = None\n  \\<Longrightarrow> ys = drop (length xs - length ys) (rev xs)\n  \\<Longrightarrow> \\<exists> row \\<in> set (newton_coefficients_main (map rat_of_int xs) (map rat_of_int gs) (map rat_of_int ys)). hd row \\<notin> \\<int>\"", "lemma newton_coefficients_int: assumes dist: \"distinct xs\"\n  and len: \"length xs = length fs\"\n  shows \"newton_coefficients_int = (let cs = newton_coefficients (map rat_of_int xs) (map of_int fs)\n    in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs) else None)\"", "lemma newton_poly_impl_int: assumes len: \"length xs = length fs\" \n  and dist: \"distinct xs\"\n  shows \"newton_poly_impl_int = (let p = newton_poly_impl (map rat_of_int xs) (map of_int fs)\n    in if set (coeffs p) \\<subseteq> \\<int> then Some (map_poly int_of_rat p) else None)\"", "lemma newton_interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = newton_interpolation_poly xs_ys\"\n  and xy: \"(x,y) \\<in> set xs_ys\"\n  shows \"poly p x = y\"", "lemma degree_newton_interpolation_poly:  \n  shows \"degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\"", "lemma newton_interpolation_poly_int: assumes dist: \"distinct (map fst xs_ys)\"\n  shows \"newton_interpolation_poly_int xs_ys = (let \n     rxs_ys = map (\\<lambda> (x,y). (rat_of_int x, rat_of_int y)) xs_ys;\n     rp = newton_interpolation_poly rxs_ys\n     in if (\\<forall> x \\<in> set (coeffs rp). is_int_rat x) then\n       Some (map_poly int_of_rat rp) else None)\""], "translations": [["", "lemma (in map_poly_comm_ring_hom) horner_composition_hom:\n  \"horner_composition (map hom cs) (map hom xs) = map_poly hom (horner_composition cs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (map hom cs) (map hom xs) =\n    map_poly hom (horner_composition cs xs)", "by (induct cs xs rule: horner_composition.induct, auto simp: hom_distribs)"], ["", "lemma horner_coeffs_ints: assumes len: \"length cs \\<le> Suc (length ys)\"\n  shows \"(set (coeffs (horner_composition cs (map rat_of_int ys))) \\<subseteq> \\<int>) = (set cs \\<subseteq> \\<int>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (coeffs (horner_composition cs (map rat_of_int ys)))\n     \\<subseteq> \\<int>) =\n    (set cs \\<subseteq> \\<int>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (set (coeffs (horner_composition cs (map rat_of_int ys)))\n     \\<subseteq> \\<int>) =\n    (set cs \\<subseteq> \\<int>)", "let ?ir = \"int_of_rat\""], ["proof (state)\ngoal (1 subgoal):\n 1. (set (coeffs (horner_composition cs (map rat_of_int ys)))\n     \\<subseteq> \\<int>) =\n    (set cs \\<subseteq> \\<int>)", "let ?ri = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. (set (coeffs (horner_composition cs (map rat_of_int ys)))\n     \\<subseteq> \\<int>) =\n    (set cs \\<subseteq> \\<int>)", "let ?mir = \"map ?ir\""], ["proof (state)\ngoal (1 subgoal):\n 1. (set (coeffs (horner_composition cs (map rat_of_int ys)))\n     \\<subseteq> \\<int>) =\n    (set cs \\<subseteq> \\<int>)", "let ?mri = \"map ?ri\""], ["proof (state)\ngoal (1 subgoal):\n 1. (set (coeffs (horner_composition cs (map rat_of_int ys)))\n     \\<subseteq> \\<int>) =\n    (set cs \\<subseteq> \\<int>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (coeffs (horner_composition cs (map rat_of_int ys)))\n     \\<subseteq> \\<int>) =\n    (set cs \\<subseteq> \\<int>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    set cs \\<subseteq> \\<int>\n 2. set cs \\<subseteq> \\<int> \\<Longrightarrow>\n    set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int>", "define ics where \"ics = map ?ir cs\""], ["proof (state)\nthis:\n  ics = map int_of_rat cs\n\ngoal (2 subgoals):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    set cs \\<subseteq> \\<int>\n 2. set cs \\<subseteq> \\<int> \\<Longrightarrow>\n    set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int>", "assume \"set cs \\<subseteq> \\<int>\""], ["proof (state)\nthis:\n  set cs \\<subseteq> \\<int>\n\ngoal (2 subgoals):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    set cs \\<subseteq> \\<int>\n 2. set cs \\<subseteq> \\<int> \\<Longrightarrow>\n    set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int>", "hence ics: \"cs = ?mri ics\""], ["proof (prove)\nusing this:\n  set cs \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. cs = map rat_of_int ics", "unfolding ics_def map_map o_def"], ["proof (prove)\nusing this:\n  set cs \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. cs = map (\\<lambda>x. rat_of_int (int_of_rat x)) cs", "by (simp add: map_idI subset_code(1))"], ["proof (state)\nthis:\n  cs = map rat_of_int ics\n\ngoal (2 subgoals):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    set cs \\<subseteq> \\<int>\n 2. set cs \\<subseteq> \\<int> \\<Longrightarrow>\n    set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int>", "show \"set (coeffs (horner_composition cs (?mri ys))) \\<subseteq> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int>", "unfolding ics of_int_poly_hom.horner_composition_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (coeffs (of_int_poly (horner_composition ics ys)))\n    \\<subseteq> \\<int>", "by auto"], ["proof (state)\nthis:\n  set (coeffs (horner_composition cs (map rat_of_int ys)))\n  \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    set cs \\<subseteq> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    set cs \\<subseteq> \\<int>", "assume \"set (coeffs (horner_composition cs (?mri ys))) \\<subseteq> \\<int>\""], ["proof (state)\nthis:\n  set (coeffs (horner_composition cs (map rat_of_int ys)))\n  \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. set (coeffs (horner_composition cs (map rat_of_int ys)))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    set cs \\<subseteq> \\<int>", "thus \"set cs \\<subseteq> \\<int>\""], ["proof (prove)\nusing this:\n  set (coeffs (horner_composition cs (map rat_of_int ys)))\n  \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. set cs \\<subseteq> \\<int>", "using len"], ["proof (prove)\nusing this:\n  set (coeffs (horner_composition cs (map rat_of_int ys)))\n  \\<subseteq> \\<int>\n  length cs \\<le> Suc (length ys)\n\ngoal (1 subgoal):\n 1. set cs \\<subseteq> \\<int>", "proof (induct cs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>set (coeffs (horner_composition [] (map rat_of_int ys)))\n                \\<subseteq> \\<int>;\n        length [] \\<le> Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> \\<int>\n 2. \\<And>a cs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set (coeffs\n                                  (horner_composition cs\n                                    (map rat_of_int ys)))\n                            \\<subseteq> \\<int>;\n                    length cs \\<le> Suc (length ys)\\<rbrakk>\n                   \\<Longrightarrow> set cs \\<subseteq> \\<int>;\n        set (coeffs (horner_composition (a # cs) (map rat_of_int ys)))\n        \\<subseteq> \\<int>;\n        length (a # cs) \\<le> Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> set (a # cs) \\<subseteq> \\<int>", "case (Cons c cs xs)"], ["proof (state)\nthis:\n  \\<lbrakk>set (coeffs (horner_composition cs (map rat_of_int ?ys)))\n           \\<subseteq> \\<int>;\n   length cs \\<le> Suc (length ?ys)\\<rbrakk>\n  \\<Longrightarrow> set cs \\<subseteq> \\<int>\n  set (coeffs (horner_composition (c # cs) (map rat_of_int xs)))\n  \\<subseteq> \\<int>\n  length (c # cs) \\<le> Suc (length xs)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>set (coeffs (horner_composition [] (map rat_of_int ys)))\n                \\<subseteq> \\<int>;\n        length [] \\<le> Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> \\<int>\n 2. \\<And>a cs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set (coeffs\n                                  (horner_composition cs\n                                    (map rat_of_int ys)))\n                            \\<subseteq> \\<int>;\n                    length cs \\<le> Suc (length ys)\\<rbrakk>\n                   \\<Longrightarrow> set cs \\<subseteq> \\<int>;\n        set (coeffs (horner_composition (a # cs) (map rat_of_int ys)))\n        \\<subseteq> \\<int>;\n        length (a # cs) \\<le> Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> set (a # cs) \\<subseteq> \\<int>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (c # cs) \\<subseteq> \\<int>", "proof (cases \"cs = [] \\<or> xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<or> xs = [] \\<Longrightarrow> set (c # cs) \\<subseteq> \\<int>\n 2. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "case True"], ["proof (state)\nthis:\n  cs = [] \\<or> xs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<or> xs = [] \\<Longrightarrow> set (c # cs) \\<subseteq> \\<int>\n 2. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>set (coeffs (horner_composition cs (map rat_of_int ?ys)))\n           \\<subseteq> \\<int>;\n   length cs \\<le> Suc (length ?ys)\\<rbrakk>\n  \\<Longrightarrow> set cs \\<subseteq> \\<int>\n  set (coeffs (horner_composition (c # cs) (map rat_of_int xs)))\n  \\<subseteq> \\<int>\n  length (c # cs) \\<le> Suc (length xs)\n  cs = [] \\<or> xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (coeffs (horner_composition cs (map rat_of_int ?ys)))\n           \\<subseteq> \\<int>;\n   length cs \\<le> Suc (length ?ys)\\<rbrakk>\n  \\<Longrightarrow> set cs \\<subseteq> \\<int>\n  set (coeffs (horner_composition (c # cs) (map rat_of_int xs)))\n  \\<subseteq> \\<int>\n  length (c # cs) \\<le> Suc (length xs)\n  cs = [] \\<or> xs = []\n\ngoal (1 subgoal):\n 1. set (c # cs) \\<subseteq> \\<int>", "by (cases \"c = 0\"; cases cs, auto)"], ["proof (state)\nthis:\n  set (c # cs) \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "case False"], ["proof (state)\nthis:\n  \\<not> (cs = [] \\<or> xs = [])\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "then"], ["proof (chain)\npicking this:\n  \\<not> (cs = [] \\<or> xs = [])", "obtain d ds and y ys where cs: \"cs = d # ds\" and xs: \"xs = y # ys\""], ["proof (prove)\nusing this:\n  \\<not> (cs = [] \\<or> xs = [])\n\ngoal (1 subgoal):\n 1. (\\<And>d ds y ys.\n        \\<lbrakk>cs = d # ds; xs = y # ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases cs, auto, cases xs, auto)"], ["proof (state)\nthis:\n  cs = d # ds\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "let ?q = \"horner_composition cs (?mri ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "define q where \"q = ?q\""], ["proof (state)\nthis:\n  q = horner_composition cs (map rat_of_int ys)\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "define p where \"p = q * [:- ?ri y, 1:] + [:c:]\""], ["proof (state)\nthis:\n  p = q * [:- rat_of_int y, 1:] + [:c:]\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have id: \"horner_composition (c # cs) (?mri xs) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (c # cs) (map rat_of_int xs) = p", "unfolding cs xs q_def p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (c # d # ds) (map rat_of_int (y # ys)) =\n    horner_composition (d # ds) (map rat_of_int ys) *\n    [:- rat_of_int y, 1:] +\n    [:c:]", "by simp"], ["proof (state)\nthis:\n  horner_composition (c # cs) (map rat_of_int xs) = p\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have coeff: \"coeff p i \\<in> \\<int>\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p i \\<in> \\<int>", "proof (cases \"coeff p i \\<in> set (coeffs p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. coeff p i \\<in> set (coeffs p) \\<Longrightarrow> coeff p i \\<in> \\<int>\n 2. coeff p i \\<notin> set (coeffs p) \\<Longrightarrow>\n    coeff p i \\<in> \\<int>", "case True"], ["proof (state)\nthis:\n  coeff p i \\<in> set (coeffs p)\n\ngoal (2 subgoals):\n 1. coeff p i \\<in> set (coeffs p) \\<Longrightarrow> coeff p i \\<in> \\<int>\n 2. coeff p i \\<notin> set (coeffs p) \\<Longrightarrow>\n    coeff p i \\<in> \\<int>", "with Cons(2)[unfolded id]"], ["proof (chain)\npicking this:\n  set (coeffs p) \\<subseteq> \\<int>\n  coeff p i \\<in> set (coeffs p)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (coeffs p) \\<subseteq> \\<int>\n  coeff p i \\<in> set (coeffs p)\n\ngoal (1 subgoal):\n 1. coeff p i \\<in> \\<int>", "by blast"], ["proof (state)\nthis:\n  coeff p i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff p i \\<notin> set (coeffs p) \\<Longrightarrow>\n    coeff p i \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff p i \\<notin> set (coeffs p) \\<Longrightarrow>\n    coeff p i \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  coeff p i \\<notin> set (coeffs p)\n\ngoal (1 subgoal):\n 1. coeff p i \\<notin> set (coeffs p) \\<Longrightarrow>\n    coeff p i \\<in> \\<int>", "hence \"coeff p i = 0\""], ["proof (prove)\nusing this:\n  coeff p i \\<notin> set (coeffs p)\n\ngoal (1 subgoal):\n 1. coeff p i = 0", "using range_coeff[of p]"], ["proof (prove)\nusing this:\n  coeff p i \\<notin> set (coeffs p)\n  range (coeff p) = insert 0 (set (coeffs p))\n\ngoal (1 subgoal):\n 1. coeff p i = 0", "by blast"], ["proof (state)\nthis:\n  coeff p i = 0\n\ngoal (1 subgoal):\n 1. coeff p i \\<notin> set (coeffs p) \\<Longrightarrow>\n    coeff p i \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff p i = 0\n\ngoal (1 subgoal):\n 1. coeff p i \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  coeff p i \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff p ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "{"], ["proof (state)\nthis:\n  coeff p ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "let ?f = \"\\<lambda> j. coeff [:- ?ri y, 1:] j * coeff q (Suc i - j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"coeff p (Suc i) = coeff ([: -?ri y, 1 :] * q) (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p (Suc i) = coeff ([:- rat_of_int y, 1:] * q) (Suc i)", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (q * [:- rat_of_int y, 1:] + [:c:]) (Suc i) =\n    coeff ([:- rat_of_int y, 1:] * q) (Suc i)", "by simp"], ["proof (state)\nthis:\n  coeff p (Suc i) = coeff ([:- rat_of_int y, 1:] * q) (Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "also"], ["proof (state)\nthis:\n  coeff p (Suc i) = coeff ([:- rat_of_int y, 1:] * q) (Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"\\<dots> = (\\<Sum>j\\<le>Suc i. ?f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff ([:- rat_of_int y, 1:] * q) (Suc i) =\n    (\\<Sum>j\\<le>Suc i. coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j))", "unfolding coeff_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>Suc i.\n        coeff [:- rat_of_int y, 1:] ia * coeff q (Suc i - ia)) =\n    (\\<Sum>j\\<le>Suc i. coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j))", "by simp"], ["proof (state)\nthis:\n  coeff ([:- rat_of_int y, 1:] * q) (Suc i) =\n  (\\<Sum>j\\<le>Suc i. coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j))\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "also"], ["proof (state)\nthis:\n  coeff ([:- rat_of_int y, 1:] * q) (Suc i) =\n  (\\<Sum>j\\<le>Suc i. coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j))\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"\\<dots> = ?f 0 + ?f 1 + (\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}. ?f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>Suc i.\n        coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j)) =\n    coeff [:- rat_of_int y, 1:] 0 * coeff q (Suc i - 0) +\n    coeff [:- rat_of_int y, 1:] 1 * coeff q (Suc i - 1) +\n    (\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}.\n       coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j))", "by (subst sum.remove[of _ 0], force+, subst sum.remove[of _ 1], force+)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>Suc i. coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j)) =\n  coeff [:- rat_of_int y, 1:] 0 * coeff q (Suc i - 0) +\n  coeff [:- rat_of_int y, 1:] 1 * coeff q (Suc i - 1) +\n  (\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}.\n     coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j))\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>Suc i. coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j)) =\n  coeff [:- rat_of_int y, 1:] 0 * coeff q (Suc i - 0) +\n  coeff [:- rat_of_int y, 1:] 1 * coeff q (Suc i - 1) +\n  (\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}.\n     coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j))\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"(\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}. ?f j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}.\n       coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j)) =\n    0", "proof (rule sum.neutral, auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> Suc i; x \\<noteq> Suc 0;\n        coeff q (Suc i - x) \\<noteq> 0; 0 < x\\<rbrakk>\n       \\<Longrightarrow> coeff [:- rat_of_int y, 1:] x = 0", "case (1 x)"], ["proof (state)\nthis:\n  x \\<le> Suc i\n  x \\<noteq> Suc 0\n  coeff q (Suc i - x) \\<noteq> 0\n  0 < x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> Suc i; x \\<noteq> Suc 0;\n        coeff q (Suc i - x) \\<noteq> 0; 0 < x\\<rbrakk>\n       \\<Longrightarrow> coeff [:- rat_of_int y, 1:] x = 0", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<le> Suc i\n  x \\<noteq> Suc 0\n  coeff q (Suc i - x) \\<noteq> 0\n  0 < x\n\ngoal (1 subgoal):\n 1. coeff [:- rat_of_int y, 1:] x = 0", "by (cases x, auto, cases \"x - 1\", auto)"], ["proof (state)\nthis:\n  coeff [:- rat_of_int y, 1:] x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}.\n     coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{..Suc i} - {0} - {Suc 0}.\n     coeff [:- rat_of_int y, 1:] j * coeff q (Suc i - j)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"?f 0 = - ?ri y * coeff q (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff [:- rat_of_int y, 1:] 0 * coeff q (Suc i - 0) =\n    - rat_of_int y * coeff q (Suc i)", "by simp"], ["proof (state)\nthis:\n  coeff [:- rat_of_int y, 1:] 0 * coeff q (Suc i - 0) =\n  - rat_of_int y * coeff q (Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "also"], ["proof (state)\nthis:\n  coeff [:- rat_of_int y, 1:] 0 * coeff q (Suc i - 0) =\n  - rat_of_int y * coeff q (Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"?f 1 = coeff q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff [:- rat_of_int y, 1:] 1 * coeff q (Suc i - 1) = coeff q i", "by simp"], ["proof (state)\nthis:\n  coeff [:- rat_of_int y, 1:] 1 * coeff q (Suc i - 1) = coeff q i\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "finally"], ["proof (chain)\npicking this:\n  coeff p (Suc i) = - rat_of_int y * coeff q (Suc i) + coeff q i + 0", "have int: \"coeff q i - ?ri y * coeff q (Suc i) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  coeff p (Suc i) = - rat_of_int y * coeff q (Suc i) + coeff q i + 0\n\ngoal (1 subgoal):\n 1. coeff q i - rat_of_int y * coeff q (Suc i) \\<in> \\<int>", "using coeff[of \"Suc i\"]"], ["proof (prove)\nusing this:\n  coeff p (Suc i) = - rat_of_int y * coeff q (Suc i) + coeff q i + 0\n  coeff p (Suc i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff q i - rat_of_int y * coeff q (Suc i) \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  coeff q i - rat_of_int y * coeff q (Suc i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "assume \"coeff q (Suc i) \\<in> \\<int>\""], ["proof (state)\nthis:\n  coeff q (Suc i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "hence \"?ri y * coeff q (Suc i) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  coeff q (Suc i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int y * coeff q (Suc i) \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  rat_of_int y * coeff q (Suc i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "hence \"coeff q i \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  rat_of_int y * coeff q (Suc i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff q i \\<in> \\<int>", "using int Ints_diff Ints_minus"], ["proof (prove)\nusing this:\n  rat_of_int y * coeff q (Suc i) \\<in> \\<int>\n  coeff q i - rat_of_int y * coeff q (Suc i) \\<in> \\<int>\n  \\<lbrakk>?a \\<in> \\<int>; ?b \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> ?a - ?b \\<in> \\<int>\n  ?a \\<in> \\<int> \\<Longrightarrow> - ?a \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff q i \\<in> \\<int>", "by force"], ["proof (state)\nthis:\n  coeff q i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "}"], ["proof (state)\nthis:\n  coeff q (Suc ?i2) \\<in> \\<int> \\<Longrightarrow> coeff q ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "note coeff_q = this"], ["proof (state)\nthis:\n  coeff q (Suc ?i2) \\<in> \\<int> \\<Longrightarrow> coeff q ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "{"], ["proof (state)\nthis:\n  coeff q (Suc ?i2) \\<in> \\<int> \\<Longrightarrow> coeff q ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "assume \"i \\<le> degree q\""], ["proof (state)\nthis:\n  i \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "hence \"coeff q (degree q - i) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  i \\<le> degree q\n\ngoal (1 subgoal):\n 1. coeff q (degree q - i) \\<in> \\<int>", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> degree q \\<Longrightarrow> coeff q (degree q - 0) \\<in> \\<int>\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> degree q \\<Longrightarrow>\n                coeff q (degree q - i) \\<in> \\<int>;\n        Suc i \\<le> degree q\\<rbrakk>\n       \\<Longrightarrow> coeff q (degree q - Suc i) \\<in> \\<int>", "case 0"], ["proof (state)\nthis:\n  0 \\<le> degree q\n\ngoal (2 subgoals):\n 1. 0 \\<le> degree q \\<Longrightarrow> coeff q (degree q - 0) \\<in> \\<int>\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> degree q \\<Longrightarrow>\n                coeff q (degree q - i) \\<in> \\<int>;\n        Suc i \\<le> degree q\\<rbrakk>\n       \\<Longrightarrow> coeff q (degree q - Suc i) \\<in> \\<int>", "from coeff_q[of \"degree q\"]"], ["proof (chain)\npicking this:\n  coeff q (Suc (degree q)) \\<in> \\<int> \\<Longrightarrow>\n  lead_coeff q \\<in> \\<int>", "show ?case"], ["proof (prove)\nusing this:\n  coeff q (Suc (degree q)) \\<in> \\<int> \\<Longrightarrow>\n  lead_coeff q \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff q (degree q - 0) \\<in> \\<int>", "by (metis Ints_0 Suc_n_not_le_n diff_zero le_degree)"], ["proof (state)\nthis:\n  coeff q (degree q - 0) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> degree q \\<Longrightarrow>\n                coeff q (degree q - i) \\<in> \\<int>;\n        Suc i \\<le> degree q\\<rbrakk>\n       \\<Longrightarrow> coeff q (degree q - Suc i) \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> degree q \\<Longrightarrow>\n                coeff q (degree q - i) \\<in> \\<int>;\n        Suc i \\<le> degree q\\<rbrakk>\n       \\<Longrightarrow> coeff q (degree q - Suc i) \\<in> \\<int>", "case (Suc i)"], ["proof (state)\nthis:\n  i \\<le> degree q \\<Longrightarrow> coeff q (degree q - i) \\<in> \\<int>\n  Suc i \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> degree q \\<Longrightarrow>\n                coeff q (degree q - i) \\<in> \\<int>;\n        Suc i \\<le> degree q\\<rbrakk>\n       \\<Longrightarrow> coeff q (degree q - Suc i) \\<in> \\<int>", "with coeff_q[of i]"], ["proof (chain)\npicking this:\n  coeff q (Suc i) \\<in> \\<int> \\<Longrightarrow> coeff q i \\<in> \\<int>\n  i \\<le> degree q \\<Longrightarrow> coeff q (degree q - i) \\<in> \\<int>\n  Suc i \\<le> degree q", "show ?case"], ["proof (prove)\nusing this:\n  coeff q (Suc i) \\<in> \\<int> \\<Longrightarrow> coeff q i \\<in> \\<int>\n  i \\<le> degree q \\<Longrightarrow> coeff q (degree q - i) \\<in> \\<int>\n  Suc i \\<le> degree q\n\ngoal (1 subgoal):\n 1. coeff q (degree q - Suc i) \\<in> \\<int>", "by (metis Suc_diff_Suc Suc_leD Suc_n_not_le_n coeff_q le_less)"], ["proof (state)\nthis:\n  coeff q (degree q - Suc i) \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff q (degree q - i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "}"], ["proof (state)\nthis:\n  ?i2 \\<le> degree q \\<Longrightarrow> coeff q (degree q - ?i2) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "note coeff_q = this"], ["proof (state)\nthis:\n  ?i2 \\<le> degree q \\<Longrightarrow> coeff q (degree q - ?i2) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "{"], ["proof (state)\nthis:\n  ?i2 \\<le> degree q \\<Longrightarrow> coeff q (degree q - ?i2) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"coeff q i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff q i \\<in> \\<int>", "proof (cases \"i \\<le> degree q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>\n 2. \\<not> i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>", "case True"], ["proof (state)\nthis:\n  i \\<le> degree q\n\ngoal (2 subgoals):\n 1. i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>\n 2. \\<not> i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>", "with coeff_q[of \"degree q - i\"]"], ["proof (chain)\npicking this:\n  degree q - i \\<le> degree q \\<Longrightarrow>\n  coeff q (degree q - (degree q - i)) \\<in> \\<int>\n  i \\<le> degree q", "show ?thesis"], ["proof (prove)\nusing this:\n  degree q - i \\<le> degree q \\<Longrightarrow>\n  coeff q (degree q - (degree q - i)) \\<in> \\<int>\n  i \\<le> degree q\n\ngoal (1 subgoal):\n 1. coeff q i \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  coeff q i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>", "hence \"coeff q i = 0\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> degree q\n\ngoal (1 subgoal):\n 1. coeff q i = 0", "using le_degree"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> degree q\n  coeff ?p ?n \\<noteq> (0::?'a) \\<Longrightarrow> ?n \\<le> degree ?p\n\ngoal (1 subgoal):\n 1. coeff q i = 0", "by blast"], ["proof (state)\nthis:\n  coeff q i = 0\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree q \\<Longrightarrow> coeff q i \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff q i = 0\n\ngoal (1 subgoal):\n 1. coeff q i \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  coeff q i \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff q i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "}"], ["proof (state)\nthis:\n  coeff q ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "note coeff_q = this"], ["proof (state)\nthis:\n  coeff q ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "hence \"set (coeffs q) \\<subseteq> \\<int>\""], ["proof (prove)\nusing this:\n  coeff q ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. set (coeffs q) \\<subseteq> \\<int>", "by (auto simp: coeffs_def)"], ["proof (state)\nthis:\n  set (coeffs q) \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "from Cons(1)[OF this[unfolded q_def]] Cons(3) xs"], ["proof (chain)\npicking this:\n  length cs \\<le> Suc (length ys) \\<Longrightarrow>\n  set cs \\<subseteq> \\<int>\n  length (c # cs) \\<le> Suc (length xs)\n  xs = y # ys", "have IH: \"set cs \\<subseteq> \\<int>\""], ["proof (prove)\nusing this:\n  length cs \\<le> Suc (length ys) \\<Longrightarrow>\n  set cs \\<subseteq> \\<int>\n  length (c # cs) \\<le> Suc (length xs)\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. set cs \\<subseteq> \\<int>", "by auto"], ["proof (state)\nthis:\n  set cs \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "define r where \"r = coeff q 0 * (- ?ri y)\""], ["proof (state)\nthis:\n  r = coeff q 0 * - rat_of_int y\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have r: \"r \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> \\<int>", "using coeff_q[of 0]"], ["proof (prove)\nusing this:\n  coeff q 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. r \\<in> \\<int>", "unfolding r_def"], ["proof (prove)\nusing this:\n  coeff q 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff q 0 * - rat_of_int y \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  r \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"coeff p 0 \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p 0 \\<in> \\<int>", "by fact"], ["proof (state)\nthis:\n  coeff p 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "also"], ["proof (state)\nthis:\n  coeff p 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "have \"coeff p 0 = r + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p 0 = r + c", "unfolding p_def r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (q * [:- rat_of_int y, 1:] + [:c:]) 0 =\n    coeff q 0 * - rat_of_int y + c", "by simp"], ["proof (state)\nthis:\n  coeff p 0 = r + c\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "finally"], ["proof (chain)\npicking this:\n  r + c \\<in> \\<int>", "have c: \"c \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  r + c \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. c \\<in> \\<int>", "using r"], ["proof (prove)\nusing this:\n  r + c \\<in> \\<int>\n  r \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. c \\<in> \\<int>", "using Ints_diff"], ["proof (prove)\nusing this:\n  r + c \\<in> \\<int>\n  r \\<in> \\<int>\n  \\<lbrakk>?a \\<in> \\<int>; ?b \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> ?a - ?b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. c \\<in> \\<int>", "by force"], ["proof (state)\nthis:\n  c \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> (cs = [] \\<or> xs = []) \\<Longrightarrow>\n    set (c # cs) \\<subseteq> \\<int>", "with IH"], ["proof (chain)\npicking this:\n  set cs \\<subseteq> \\<int>\n  c \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  set cs \\<subseteq> \\<int>\n  c \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. set (c # cs) \\<subseteq> \\<int>", "by auto"], ["proof (state)\nthis:\n  set (c # cs) \\<subseteq> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (c # cs) \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>set (coeffs (horner_composition [] (map rat_of_int ys)))\n                \\<subseteq> \\<int>;\n        length [] \\<le> Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> \\<int>", "qed simp"], ["proof (state)\nthis:\n  set cs \\<subseteq> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (set (coeffs (horner_composition cs (map rat_of_int ys)))\n   \\<subseteq> \\<int>) =\n  (set cs \\<subseteq> \\<int>)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\nfixes \n  ty :: \"'a :: field itself\"\n  and xs :: \"'a list\"\n  and fs :: \"'a list\"\nbegin"], ["", "fun divided_differences_impl :: \"'a list \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"divided_differences_impl (xi_j1 # x_j1s) fj xj (xi # xis) = (let \n    x_js = divided_differences_impl x_j1s fj xj xis;\n    new = (hd x_js - xi_j1) / (xj - xi)\n    in new # x_js)\"\n| \"divided_differences_impl [] fj xj xis = [fj]\""], ["", "fun newton_coefficients_main :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\" where\n  \"newton_coefficients_main [fj] xjs = [[fj]]\"\n| \"newton_coefficients_main (fj # fjs) (xj # xjs) = (\n    let rec = newton_coefficients_main fjs xjs; row = hd rec;\n      new_row = divided_differences_impl row fj xj xs\n    in new_row # rec)\"\n| \"newton_coefficients_main _ _ = []\""], ["", "definition newton_coefficients :: \"'a list\" where\n  \"newton_coefficients = map hd (newton_coefficients_main (rev fs) (rev xs))\""], ["", "definition newton_poly_impl :: \"'a poly\" where\n  \"newton_poly_impl = horner_composition (rev newton_coefficients) xs\""], ["", "qualified"], ["", "definition \"x i = xs ! i\""], ["", "qualified"], ["", "definition \"f i = fs ! i\""], ["", "private"], ["", "definition \"xd i j = x i - x j\""], ["", "lemma [simp]: \"xd i i = 0\" \"xd i j + xd j k = xd i k\" \"xd i j + xd k i = xd k j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xd i i = (0::'a) &&&\n    xd i j + xd j k = xd i k &&& xd i j + xd k i = xd k j", "unfolding xd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x i - x i = (0::'a) &&&\n    x i - x j + (x j - x k) = x i - x k &&&\n    x i - x j + (x k - x i) = x k - x j", "by simp_all"], ["", "(* divided differences [xi,..,xj]f *)\nprivate"], ["", "function xij_f :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a\" where\n  \"xij_f i j = (if i < j then (xij_f (i + 1) j - xij_f i (j - 1)) / xd j i else f i)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if i < j\n        then (xij_f_sumC (i + 1, j) - xij_f_sumC (i, j - 1)) / xd j i\n        else f i) =\n       (if ia < ja\n        then (xij_f_sumC (ia + 1, ja) - xij_f_sumC (ia, ja - 1)) / xd ja ia\n        else f ia)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All xij_f_dom", "by (relation \"measure (\\<lambda> (i,j). j - i)\", auto)"], ["", "private"], ["", "definition c :: \"nat \\<Rightarrow> 'a\" where\n  \"c i = xij_f 0 i\""], ["", "private"], ["", "definition \"X j = [: - x j, 1:]\""], ["", "private"], ["", "function b :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a poly\" where\n  \"b i n = (if i \\<ge> n then [:c n:] else b (Suc i) n * X i + [:c i:])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i n. x = (i, n) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i n ia na.\n       (i, n) = (ia, na) \\<Longrightarrow>\n       (if n \\<le> i then [:c n:] else b_sumC (Suc i, n) * X i + [:c i:]) =\n       (if na \\<le> ia then [:c na:]\n        else b_sumC (Suc ia, na) * X ia + [:c ia:])", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All b_dom", "by (relation \"measure (\\<lambda> (i,n). Suc n - i)\", auto)"], ["", "declare b.simps[simp del]"], ["", "definition newton_poly :: \"nat \\<Rightarrow> 'a poly\" where\n  \"newton_poly n = b 0 n\""], ["", "private"], ["", "definition \"Xij i j = prod_list (map X [i ..< j])\""], ["", "private"], ["", "definition \"N i = Xij 0 i\""], ["", "lemma Xii_1[simp]: \"Xij i i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xij i i = 1", "unfolding Xij_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map X [i..<i]) = 1", "by simp"], ["", "lemma smult_1[simp]: \"smult d 1 = [:d:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult d 1 = [:d:]", "by (fact smult_one)"], ["", "private"], ["", "lemma newton_poly_sum: \n  \"newton_poly n = sum_list (map (\\<lambda> i. smult (c i) (N i)) [0 ..< Suc n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_poly n =\n    (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (N i))", "unfolding newton_poly_def N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "assume \"j \\<le> n\""], ["proof (state)\nthis:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "hence \"b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\""], ["proof (prove)\nusing this:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "proof (induct j n rule: b.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> b (Suc i) n =\n                                  (\\<Sum>ia\\<leftarrow>[Suc i..<\n                  Suc n]. smult (c ia) (Xij (Suc i) ia));\n        i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> b i n =\n                         (\\<Sum>ia\\<leftarrow>[i..<\n         Suc n]. smult (c ia) (Xij i ia))", "case (1 j n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> n \\<le> j; Suc j \\<le> n\\<rbrakk>\n  \\<Longrightarrow> b (Suc j) n =\n                    (\\<Sum>i\\<leftarrow>[Suc j..<\n   Suc n]. smult (c i) (Xij (Suc j) i))\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> b (Suc i) n =\n                                  (\\<Sum>ia\\<leftarrow>[Suc i..<\n                  Suc n]. smult (c ia) (Xij (Suc i) ia));\n        i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> b i n =\n                         (\\<Sum>ia\\<leftarrow>[i..<\n         Suc n]. smult (c ia) (Xij i ia))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "proof (cases \"j \\<ge> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n 2. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "case True"], ["proof (state)\nthis:\n  n \\<le> j\n\ngoal (2 subgoals):\n 1. n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n 2. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "with 1(2)"], ["proof (chain)\npicking this:\n  j \\<le> n\n  n \\<le> j", "have j: \"j = n\""], ["proof (prove)\nusing this:\n  j \\<le> n\n  n \\<le> j\n\ngoal (1 subgoal):\n 1. j = n", "by auto"], ["proof (state)\nthis:\n  j = n\n\ngoal (2 subgoals):\n 1. n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n 2. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "hence \"b j n = [:c n:]\""], ["proof (prove)\nusing this:\n  j = n\n\ngoal (1 subgoal):\n 1. b j n = [:c n:]", "unfolding b.simps[of j n]"], ["proof (prove)\nusing this:\n  j = n\n\ngoal (1 subgoal):\n 1. (if n \\<le> j then [:c n:] else b (Suc j) n * X j + [:c j:]) = [:c n:]", "by simp"], ["proof (state)\nthis:\n  b j n = [:c n:]\n\ngoal (2 subgoals):\n 1. n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n 2. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  b j n = [:c n:]\n\ngoal (1 subgoal):\n 1. b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "unfolding j"], ["proof (prove)\nusing this:\n  b n n = [:c n:]\n\ngoal (1 subgoal):\n 1. b n n = (\\<Sum>i\\<leftarrow>[n..<Suc n]. smult (c i) (Xij n i))", "by simp"], ["proof (state)\nthis:\n  b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "hence b: \"b j n = b (Suc j) n * X j + [: c j:]\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> j\n\ngoal (1 subgoal):\n 1. b j n = b (Suc j) n * X j + [:c j:]", "unfolding b.simps[of j n]"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> j\n\ngoal (1 subgoal):\n 1. (if n \\<le> j then [:c n:] else b (Suc j) n * X j + [:c j:]) =\n    b (Suc j) n * X j + [:c j:]", "by simp"], ["proof (state)\nthis:\n  b j n = b (Suc j) n * X j + [:c j:]\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "define nn where \"nn = Suc n\""], ["proof (state)\nthis:\n  nn = Suc n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "from 1(2)"], ["proof (chain)\npicking this:\n  j \\<le> n", "have id: \"[j..< nn] = j # [Suc j ..< nn]\""], ["proof (prove)\nusing this:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. [j..<nn] = j # [Suc j..<nn]", "unfolding nn_def"], ["proof (prove)\nusing this:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. [j..<Suc n] = j # [Suc j..<Suc n]", "by (simp add: upt_rec)"], ["proof (state)\nthis:\n  [j..<nn] = j # [Suc j..<nn]\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "from False"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> j", "have \"Suc j \\<le> n\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> j\n\ngoal (1 subgoal):\n 1. Suc j \\<le> n", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "note IH = 1(1)[OF False this]"], ["proof (state)\nthis:\n  b (Suc j) n =\n  (\\<Sum>i\\<leftarrow>[Suc j..<Suc n]. smult (c i) (Xij (Suc j) i))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "have id2: \"(\\<Sum>x\\<leftarrow>[Suc j..< nn]. smult (c x) (Xij (Suc j) x * X j)) =\n          (\\<Sum>i\\<leftarrow>[Suc j..< nn]. smult (c i) (Xij j i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[Suc j..<nn]. smult (c x) (Xij (Suc j) x * X j)) =\n    (\\<Sum>i\\<leftarrow>[Suc j..<nn]. smult (c i) (Xij j i))", "proof (rule arg_cong[of _ _ sum_list], rule map_ext, intro impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [Suc j..<nn] \\<Longrightarrow>\n       smult (c x) (Xij (Suc j) x * X j) = smult (c x) (Xij j x)", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> set [Suc j..<nn]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [Suc j..<nn] \\<Longrightarrow>\n       smult (c x) (Xij (Suc j) x * X j) = smult (c x) (Xij j x)", "hence \"Xij (Suc j) i * X j = Xij j i\""], ["proof (prove)\nusing this:\n  i \\<in> set [Suc j..<nn]\n\ngoal (1 subgoal):\n 1. Xij (Suc j) i * X j = Xij j i", "by (simp add: Xij_def upt_conv_Cons)"], ["proof (state)\nthis:\n  Xij (Suc j) i * X j = Xij j i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [Suc j..<nn] \\<Longrightarrow>\n       smult (c x) (Xij (Suc j) x * X j) = smult (c x) (Xij j x)", "thus ?case"], ["proof (prove)\nusing this:\n  Xij (Suc j) i * X j = Xij j i\n\ngoal (1 subgoal):\n 1. smult (c i) (Xij (Suc j) i * X j) = smult (c i) (Xij j i)", "by simp"], ["proof (state)\nthis:\n  smult (c i) (Xij (Suc j) i * X j) = smult (c i) (Xij j i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[Suc j..<nn]. smult (c x) (Xij (Suc j) x * X j)) =\n  (\\<Sum>i\\<leftarrow>[Suc j..<nn]. smult (c i) (Xij j i))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j \\<Longrightarrow>\n    b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "unfolding b IH sum_list_mult_const[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[Suc j..<\n                         Suc n]. smult (c x) (Xij (Suc j) x) * X j) +\n    [:c j:] =\n    (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))", "unfolding nn_def[symmetric] id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[Suc j..<nn]. smult (c x) (Xij (Suc j) x) * X j) +\n    [:c j:] =\n    (\\<Sum>i\\<leftarrow>j # [Suc j..<nn]. smult (c i) (Xij j i))", "by (simp add: id2)"], ["proof (state)\nthis:\n  b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b j n = (\\<Sum>i\\<leftarrow>[j..<Suc n]. smult (c i) (Xij j i))\n\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "}"], ["proof (state)\nthis:\n  ?j2 \\<le> n \\<Longrightarrow>\n  b ?j2 n = (\\<Sum>i\\<leftarrow>[?j2..<Suc n]. smult (c i) (Xij ?j2 i))\n\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "from this[of 0]"], ["proof (chain)\npicking this:\n  0 \\<le> n \\<Longrightarrow>\n  b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "show \"b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))\""], ["proof (prove)\nusing this:\n  0 \\<le> n \\<Longrightarrow>\n  b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))\n\ngoal (1 subgoal):\n 1. b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))", "by simp"], ["proof (state)\nthis:\n  b 0 n = (\\<Sum>i\\<leftarrow>[0..<Suc n]. smult (c i) (Xij 0 i))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma poly_newton_poly: \"poly (newton_poly n) y = sum_list (map (\\<lambda> i. c i * poly (N i) y) [0 ..< Suc n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) y =\n    (\\<Sum>i\\<leftarrow>[0..<Suc n]. c i * poly (N i) y)", "unfolding newton_poly_sum poly_sum_list map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<Suc n]. poly (smult (c x) (N x)) y) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc n]. c i * poly (N i) y)", "by simp"], ["", "private"], ["", "definition \"pprod k i j = (\\<Prod>l\\<leftarrow>[i..<j]. xd k l)\""], ["", "private"], ["", "lemma poly_N_xi: \"poly (N i) (x j) = pprod j 0 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (N i) (x j) = pprod j 0 i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (N i) (x j) = pprod j 0 i", "have \"poly (N i) (x j) = (\\<Prod>l\\<leftarrow>[0..<i]. xd j l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (N i) (x j) = prod_list (map (xd j) [0..<i])", "unfolding N_def Xij_def poly_prod_list X_def[abs_def] map_map o_def xd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>xa\\<leftarrow>[0..<i]. poly [:- x xa, 1::'a:] (x j)) =\n    (\\<Prod>l\\<leftarrow>[0..<i]. x j - x l)", "by simp"], ["proof (state)\nthis:\n  poly (N i) (x j) = prod_list (map (xd j) [0..<i])\n\ngoal (1 subgoal):\n 1. poly (N i) (x j) = pprod j 0 i", "also"], ["proof (state)\nthis:\n  poly (N i) (x j) = prod_list (map (xd j) [0..<i])\n\ngoal (1 subgoal):\n 1. poly (N i) (x j) = pprod j 0 i", "have \"\\<dots> = pprod j 0 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (xd j) [0..<i]) = pprod j 0 i", "unfolding pprod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (xd j) [0..<i]) = prod_list (map (xd j) [0..<i])", ".."], ["proof (state)\nthis:\n  prod_list (map (xd j) [0..<i]) = pprod j 0 i\n\ngoal (1 subgoal):\n 1. poly (N i) (x j) = pprod j 0 i", "finally"], ["proof (chain)\npicking this:\n  poly (N i) (x j) = pprod j 0 i", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (N i) (x j) = pprod j 0 i\n\ngoal (1 subgoal):\n 1. poly (N i) (x j) = pprod j 0 i", "."], ["proof (state)\nthis:\n  poly (N i) (x j) = pprod j 0 i\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma poly_N_xi_cond: \"poly (N i) (x j) = (if j < i then 0 else pprod j 0 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "proof (cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)\n 2. \\<not> j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)\n 2. \\<not> j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "using poly_N_xi"], ["proof (prove)\nusing this:\n  \\<not> j < i\n  poly (N ?i) (x ?j) = pprod ?j 0 ?i\n\ngoal (1 subgoal):\n 1. poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "by simp"], ["proof (state)\nthis:\n  poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "case True"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "hence \"j \\<in> set [0 ..< i]\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. j \\<in> set [0..<i]", "by auto"], ["proof (state)\nthis:\n  j \\<in> set [0..<i]\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "from split_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. [0..<i] = ys @ j # zs", "obtain bef aft where id2: \"[0 ..< i] = bef @ j # aft\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. [0..<i] = ys @ j # zs\n\ngoal (1 subgoal):\n 1. (\\<And>bef aft.\n        [0..<i] = bef @ j # aft \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [0..<i] = bef @ j # aft\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "have \"(\\<Prod>k\\<leftarrow>[0..<i]. xd j k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (xd j) [0..<i]) = (0::'a)", "unfolding id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (xd j) (bef @ j # aft)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  prod_list (map (xd j) [0..<i]) = (0::'a)\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "with True"], ["proof (chain)\npicking this:\n  j < i\n  prod_list (map (xd j) [0..<i]) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  j < i\n  prod_list (map (xd j) [0..<i]) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)", "unfolding poly_N_xi pprod_def"], ["proof (prove)\nusing this:\n  j < i\n  prod_list (map (xd j) [0..<i]) = (0::'a)\n\ngoal (1 subgoal):\n 1. prod_list (map (xd j) [0..<i]) =\n    (if j < i then 0::'a else prod_list (map (xd j) [0..<i]))", "by auto"], ["proof (state)\nthis:\n  poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (N i) (x j) = (if j < i then 0::'a else pprod j 0 i)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma poly_newton_poly_xj: assumes \"j \\<le> n\"\n  shows \"poly (newton_poly n) (x j) = sum_list (map (\\<lambda> i. c i * poly (N i) (x j)) [0 ..< Suc j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x j) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x j) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j))", "from assms"], ["proof (chain)\npicking this:\n  j \\<le> n", "have id: \"[0 ..< Suc n] = [0 ..< Suc j] @ [Suc j ..< Suc n]\""], ["proof (prove)\nusing this:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. [0..<Suc n] = [0..<Suc j] @ [Suc j..<Suc n]", "by (metis Suc_le_mono le_Suc_ex less_eq_nat.simps(1) upt_add_eq_append)"], ["proof (state)\nthis:\n  [0..<Suc n] = [0..<Suc j] @ [Suc j..<Suc n]\n\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x j) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j))", "have id2: \"(\\<Sum>i\\<leftarrow>[Suc j..< Suc n]. c i * poly (N i) (x j)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[Suc j..<Suc n]. c i * poly (N i) (x j)) = (0::'a)", "by (rule sum_list_neutral, unfold poly_N_xi_cond, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[Suc j..<Suc n]. c i * poly (N i) (x j)) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x j) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x j) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j))", "unfolding poly_newton_poly id map_append sum_list_append id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j)) + (0::'a) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j))", "by simp"], ["proof (state)\nthis:\n  poly (local.newton_poly n) (x j) =\n  (\\<Sum>i\\<leftarrow>[0..<Suc j]. c i * poly (N i) (x j))\n\ngoal:\nNo subgoals!", "qed"], ["", "declare xij_f.simps[simp del]"], ["", "context\n  fixes n\n  assumes dist: \"\\<And> i j. i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> x i \\<noteq> x j\"\nbegin"], ["", "private"], ["", "lemma xd_diff: \"i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> xd i j \\<noteq> 0\"\n   \"i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> xd j i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < j; j \\<le> n\\<rbrakk>\n     \\<Longrightarrow> xd i j \\<noteq> (0::'a)) &&&\n    (\\<lbrakk>i < j; j \\<le> n\\<rbrakk>\n     \\<Longrightarrow> xd j i \\<noteq> (0::'a))", "using dist[of i j] dist[of j i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < j; j \\<le> n\\<rbrakk> \\<Longrightarrow> x i \\<noteq> x j\n  \\<lbrakk>j < i; i \\<le> n\\<rbrakk> \\<Longrightarrow> x j \\<noteq> x i\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < j; j \\<le> n\\<rbrakk>\n     \\<Longrightarrow> xd i j \\<noteq> (0::'a)) &&&\n    (\\<lbrakk>i < j; j \\<le> n\\<rbrakk>\n     \\<Longrightarrow> xd j i \\<noteq> (0::'a))", "unfolding xd_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < j; j \\<le> n\\<rbrakk> \\<Longrightarrow> x i \\<noteq> x j\n  \\<lbrakk>j < i; i \\<le> n\\<rbrakk> \\<Longrightarrow> x j \\<noteq> x i\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < j; j \\<le> n\\<rbrakk>\n     \\<Longrightarrow> x i - x j \\<noteq> (0::'a)) &&&\n    (\\<lbrakk>i < j; j \\<le> n\\<rbrakk>\n     \\<Longrightarrow> x j - x i \\<noteq> (0::'a))", "by auto"], ["", "text \\<open>This is the key technical lemma for soundness of Newton interpolation.\\<close>"], ["", "private"], ["", "lemma divided_differences_main: assumes \"k \\<le> n\" \"i < k\"\n  shows \"sum_list (map (\\<lambda> j. xij_f i (i + j) * pprod k i (i + j)) [0..<Suc k - i]) = \n  sum_list (map (\\<lambda> j. xij_f (Suc i) (Suc i + j) * pprod k (Suc i) (Suc i + j)) [0..<Suc k - Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "let ?exp = \"\\<lambda> i j. xij_f i (i + j) * pprod k i (i + j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "define ei where \"ei = ?exp i\""], ["proof (state)\nthis:\n  ei = (\\<lambda>j. xij_f i (i + j) * pprod k i (i + j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "define esi where \"esi = ?exp (Suc i)\""], ["proof (state)\nthis:\n  esi =\n  (\\<lambda>j. xij_f (Suc i) (Suc i + j) * pprod k (Suc i) (Suc i + j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "let ?ki = \"k - i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "let ?sumi = \"\\<lambda> xs. sum_list (map ei xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "let ?sumsi = \"\\<lambda> xs. sum_list (map esi xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "let ?mid = \"\\<lambda> j. xij_f i (k - j) * pprod k (Suc i) (k - j) * xd (k - j) i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "let ?sum = \"\\<lambda> j. ?sumi [0 ..< ?ki - j] + ?sumsi [?ki - j ..< ?ki] + ?mid j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "define fin where \"fin = ?ki - 1\""], ["proof (state)\nthis:\n  fin = k - i - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have fin: \"fin < ?ki\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin < k - i", "unfolding fin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k - i - 1 < k - i", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. k - i - 1 < k - i", "by auto"], ["proof (state)\nthis:\n  fin < k - i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have id: \"[ 0 ..< Suc k - i] = [0 ..< ?ki] @ [?ki]\" and \n    id2: \"[i..<k] = i # [Suc i ..< k]\" and\n    id3: \"k - (i + (k - Suc i)) = 1\" \"k - (?ki - 1) = Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc k - i] = [0..<k - i] @ [k - i] &&&\n    [i..<k] = i # [Suc i..<k] &&&\n    k - (i + (k - Suc i)) = 1 &&& k - (k - i - 1) = Suc i", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. [0..<Suc k - i] = [0..<k - i] @ [k - i] &&&\n    [i..<k] = i # [Suc i..<k] &&&\n    k - (i + (k - Suc i)) = 1 &&& k - (k - i - 1) = Suc i", "by (auto simp: Suc_diff_le upt_conv_Cons)"], ["proof (state)\nthis:\n  [0..<Suc k - i] = [0..<k - i] @ [k - i]\n  [i..<k] = i # [Suc i..<k]\n  k - (i + (k - Suc i)) = 1\n  k - (k - i - 1) = Suc i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have neq: \"xd (Suc i) i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xd (Suc i) i \\<noteq> (0::'a)", "using xd_diff[of i \"Suc i\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < Suc i; Suc i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> xd i (Suc i) \\<noteq> (0::'a)\n  \\<lbrakk>i < Suc i; Suc i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> xd (Suc i) i \\<noteq> (0::'a)\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. xd (Suc i) i \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  xd (Suc i) i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"sum_list (map (\\<lambda> j. xij_f i (i + j) * pprod k i (i + j)) [0..<Suc k - i])\n    = ?sumi [0 ..< Suc k - i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    sum_list (map ei [0..<Suc k - i])", "unfolding ei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  sum_list (map ei [0..<Suc k - i])\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  sum_list (map ei [0..<Suc k - i])\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"\\<dots> = ?sumi [0 ..< ?ki] + ?sumsi [?ki ..< ?ki] + ei ?ki\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<Suc k - i]) =\n    sum_list (map ei [0..<k - i]) + sum_list (map esi [k - i..<k - i]) +\n    ei (k - i)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei ([0..<k - i] @ [k - i])) =\n    sum_list (map ei [0..<k - i]) + sum_list (map esi [k - i..<k - i]) +\n    ei (k - i)", "by simp"], ["proof (state)\nthis:\n  sum_list (map ei [0..<Suc k - i]) =\n  sum_list (map ei [0..<k - i]) + sum_list (map esi [k - i..<k - i]) +\n  ei (k - i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  sum_list (map ei [0..<Suc k - i]) =\n  sum_list (map ei [0..<k - i]) + sum_list (map esi [k - i..<k - i]) +\n  ei (k - i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"\\<dots> = ?sum 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i]) + sum_list (map esi [k - i..<k - i]) +\n    ei (k - i) =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i", "unfolding ei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<k - i]. xij_f i (i + j) * pprod k i (i + j)) +\n    sum_list (map esi [k - i..<k - i]) +\n    xij_f i (i + (k - i)) * pprod k i (i + (k - i)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         k - i - 0]. xij_f i (i + j) * pprod k i (i + j)) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<k - i]. xij_f i (i + j) * pprod k i (i + j)) +\n    sum_list (map esi [k - i..<k - i]) +\n    xij_f i (i + (k - i)) * pprod k i (i + (k - i)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         k - i - 0]. xij_f i (i + j) * pprod k i (i + j)) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i", "by (simp add: pprod_def id2)"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i]) + sum_list (map esi [k - i..<k - i]) +\n  ei (k - i) =\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i]) + sum_list (map esi [k - i..<k - i]) +\n  ei (k - i) =\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"?sum 0 = ?sum fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - fin]) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i", "using fin"], ["proof (prove)\nusing this:\n  fin < k - i\n\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - fin]) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i", "proof (induct fin)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "case (Suc fin)"], ["proof (state)\nthis:\n  fin < k - i \\<Longrightarrow>\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i\n  Suc fin < k - i\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "from Suc(2) assms"], ["proof (chain)\npicking this:\n  Suc fin < k - i\n  k \\<le> n\n  i < k", "have fki: \"fin < ?ki\" and ikf: \"i < k - Suc fin\" \"i < k - fin\" and kfn: \"k - fin \\<le> n\""], ["proof (prove)\nusing this:\n  Suc fin < k - i\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. fin < k - i &&& (i < k - Suc fin &&& i < k - fin) &&& k - fin \\<le> n", "by auto"], ["proof (state)\nthis:\n  fin < k - i\n  i < k - Suc fin\n  i < k - fin\n  k - fin \\<le> n\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "from xd_diff[OF ikf(2) kfn]"], ["proof (chain)\npicking this:\n  xd i (k - fin) \\<noteq> (0::'a)\n  xd (k - fin) i \\<noteq> (0::'a)", "have nz: \"xd (k - fin) i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  xd i (k - fin) \\<noteq> (0::'a)\n  xd (k - fin) i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. xd (k - fin) i \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  xd (k - fin) i \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "note IH = Suc(1)[OF fki]"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have id4: \"[0 ..< ?ki - fin] = [0 ..< ?ki - Suc fin] @ [?ki - Suc fin]\" \n      \"i + (k - i - Suc fin) = k - Suc fin\" \n      \"Suc (k - Suc fin) = k - fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<k - i - fin] = [0..<k - i - Suc fin] @ [k - i - Suc fin] &&&\n    i + (k - i - Suc fin) = k - Suc fin &&& Suc (k - Suc fin) = k - fin", "using Suc(2) assms  \\<open>fin < ?ki\\<close>"], ["proof (prove)\nusing this:\n  Suc fin < k - i\n  k \\<le> n\n  i < k\n  fin < k - i\n\ngoal (1 subgoal):\n 1. [0..<k - i - fin] = [0..<k - i - Suc fin] @ [k - i - Suc fin] &&&\n    i + (k - i - Suc fin) = k - Suc fin &&& Suc (k - Suc fin) = k - fin", "by (metis Suc_diff_Suc le0 upt_Suc) (insert Suc(2), auto)"], ["proof (state)\nthis:\n  [0..<k - i - fin] = [0..<k - i - Suc fin] @ [k - i - Suc fin]\n  i + (k - i - Suc fin) = k - Suc fin\n  Suc (k - Suc fin) = k - fin\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "from Suc(2) assms"], ["proof (chain)\npicking this:\n  Suc fin < k - i\n  k \\<le> n\n  i < k", "have id5: \"[i..<k - Suc fin] = i # [Suc i ..< k - Suc fin]\"\n      \"[Suc i..<k - fin] = [Suc i..<k - Suc fin] @ [k - Suc fin]\""], ["proof (prove)\nusing this:\n  Suc fin < k - i\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. [i..<k - Suc fin] = i # [Suc i..<k - Suc fin] &&&\n    [Suc i..<k - fin] = [Suc i..<k - Suc fin] @ [k - Suc fin]", "by (force simp: upt_rec) (metis Suc_leI id4(3) ikf(1) upt_Suc)"], ["proof (state)\nthis:\n  [i..<k - Suc fin] = i # [Suc i..<k - Suc fin]\n  [Suc i..<k - fin] = [Suc i..<k - Suc fin] @ [k - Suc fin]\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"?sum 0 = ?sum fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - fin]) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i", "by (rule IH)"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"\\<dots> = ?sumi [0 ..< ?ki - Suc fin] + ?sumsi [?ki - fin ..< ?ki] + \n      (ei (?ki - Suc fin) + ?mid fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - fin]) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n    sum_list (map ei [0..<k - i - Suc fin]) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    (ei (k - i - Suc fin) +\n     xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i)", "unfolding id4"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei ([0..<k - i - Suc fin] @ [k - i - Suc fin])) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n    sum_list (map ei [0..<k - i - Suc fin]) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    (ei (k - i - Suc fin) +\n     xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i)", "by simp"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  (ei (k - i - Suc fin) +\n   xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  (ei (k - i - Suc fin) +\n   xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"?mid fin = (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin))\n      * pprod k (Suc i) (k - fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n    (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n    pprod k (Suc i) (k - fin)", "unfolding xij_f.simps[of i \"k - fin\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < k - fin\n     then (xij_f (i + 1) (k - fin) - xij_f i (k - fin - 1)) / xd (k - fin) i\n     else f i) *\n    pprod k (Suc i) (k - fin) *\n    xd (k - fin) i =\n    (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n    pprod k (Suc i) (k - fin)", "using ikf nz"], ["proof (prove)\nusing this:\n  i < k - Suc fin\n  i < k - fin\n  xd (k - fin) i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (if i < k - fin\n     then (xij_f (i + 1) (k - fin) - xij_f i (k - fin - 1)) / xd (k - fin) i\n     else f i) *\n    pprod k (Suc i) (k - fin) *\n    xd (k - fin) i =\n    (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n    pprod k (Suc i) (k - fin)", "by simp"], ["proof (state)\nthis:\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n  (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n  pprod k (Suc i) (k - fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n  (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n  pprod k (Suc i) (k - fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"\\<dots> = xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) -\n      xij_f i (k - Suc fin) * pprod k (Suc i) (k - fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n    pprod k (Suc i) (k - fin) =\n    xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) -\n    xij_f i (k - Suc fin) * pprod k (Suc i) (k - fin)", "by algebra"], ["proof (state)\nthis:\n  (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n  pprod k (Suc i) (k - fin) =\n  xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) -\n  xij_f i (k - Suc fin) * pprod k (Suc i) (k - fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  (xij_f (Suc i) (k - fin) - xij_f i (k - Suc fin)) *\n  pprod k (Suc i) (k - fin) =\n  xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) -\n  xij_f i (k - Suc fin) * pprod k (Suc i) (k - fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) = esi (?ki - Suc fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) =\n    esi (k - i - Suc fin)", "unfolding esi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) =\n    xij_f (Suc i) (Suc i + (k - i - Suc fin)) *\n    pprod k (Suc i) (Suc i + (k - i - Suc fin))", "using ikf"], ["proof (prove)\nusing this:\n  i < k - Suc fin\n  i < k - fin\n\ngoal (1 subgoal):\n 1. xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) =\n    xij_f (Suc i) (Suc i + (k - i - Suc fin)) *\n    pprod k (Suc i) (Suc i + (k - i - Suc fin))", "by (simp add: id4)"], ["proof (state)\nthis:\n  xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) =\n  esi (k - i - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  xij_f (Suc i) (k - fin) * pprod k (Suc i) (k - fin) =\n  esi (k - i - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"ei (?ki - Suc fin) = xij_f i (k - Suc fin) * pprod k i (k - Suc fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ei (k - i - Suc fin) = xij_f i (k - Suc fin) * pprod k i (k - Suc fin)", "unfolding ei_def id4"], ["proof (prove)\ngoal (1 subgoal):\n 1. xij_f i (k - Suc fin) * pprod k i (k - Suc fin) =\n    xij_f i (k - Suc fin) * pprod k i (k - Suc fin)", "using ikf"], ["proof (prove)\nusing this:\n  i < k - Suc fin\n  i < k - fin\n\ngoal (1 subgoal):\n 1. xij_f i (k - Suc fin) * pprod k i (k - Suc fin) =\n    xij_f i (k - Suc fin) * pprod k i (k - Suc fin)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  ei (k - i - Suc fin) = xij_f i (k - Suc fin) * pprod k i (k - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "finally"], ["proof (chain)\npicking this:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  (xij_f i (k - Suc fin) * pprod k i (k - Suc fin) +\n   (esi (k - i - Suc fin) -\n    xij_f i (k - Suc fin) * pprod k (Suc i) (k - fin)))", "have \"?sum 0 = ?sumi [0 ..< ?ki - Suc fin] \n      + (esi (?ki - Suc fin) + ?sumsi [?ki - fin ..< ?ki])\n      + (xij_f i (k - Suc fin) * (pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin)))\""], ["proof (prove)\nusing this:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  (xij_f i (k - Suc fin) * pprod k i (k - Suc fin) +\n   (esi (k - i - Suc fin) -\n    xij_f i (k - Suc fin) * pprod k (Suc i) (k - fin)))\n\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - Suc fin]) +\n    (esi (k - i - Suc fin) + sum_list (map esi [k - i - fin..<k - i])) +\n    xij_f i (k - Suc fin) *\n    (pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin))", "by algebra"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  (esi (k - i - Suc fin) + sum_list (map esi [k - i - fin..<k - i])) +\n  xij_f i (k - Suc fin) *\n  (pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin))\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  (esi (k - i - Suc fin) + sum_list (map esi [k - i - fin..<k - i])) +\n  xij_f i (k - Suc fin) *\n  (pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin))\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"esi (?ki - Suc fin) + ?sumsi [?ki - fin ..< ?ki] \n      = ?sumsi ((?ki - Suc fin) # [?ki - fin ..< ?ki])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esi (k - i - Suc fin) + sum_list (map esi [k - i - fin..<k - i]) =\n    sum_list (map esi ((k - i - Suc fin) # [k - i - fin..<k - i]))", "by simp"], ["proof (state)\nthis:\n  esi (k - i - Suc fin) + sum_list (map esi [k - i - fin..<k - i]) =\n  sum_list (map esi ((k - i - Suc fin) # [k - i - fin..<k - i]))\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  esi (k - i - Suc fin) + sum_list (map esi [k - i - fin..<k - i]) =\n  sum_list (map esi ((k - i - Suc fin) # [k - i - fin..<k - i]))\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"(?ki - Suc fin) # [?ki - fin ..< ?ki] = [?ki - Suc fin ..< ?ki]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k - i - Suc fin) # [k - i - fin..<k - i] = [k - i - Suc fin..<k - i]", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc fin < k - i\n\ngoal (1 subgoal):\n 1. (k - i - Suc fin) # [k - i - fin..<k - i] = [k - i - Suc fin..<k - i]", "by (simp add: Suc_diff_Suc upt_rec)"], ["proof (state)\nthis:\n  (k - i - Suc fin) # [k - i - fin..<k - i] = [k - i - Suc fin..<k - i]\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  (k - i - Suc fin) # [k - i - fin..<k - i] = [k - i - Suc fin..<k - i]\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin) \n      = (xd k i) * pprod k (Suc i) (k - Suc fin) - (xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin) =\n    xd k i * pprod k (Suc i) (k - Suc fin) -\n    xd k (k - Suc fin) * pprod k (Suc i) (k - Suc fin)", "unfolding pprod_def id5"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map (xd k) (i # [Suc i..<k - Suc fin])) -\n    prod_list (map (xd k) ([Suc i..<k - Suc fin] @ [k - Suc fin])) =\n    xd k i * prod_list (map (xd k) [Suc i..<k - Suc fin]) -\n    xd k (k - Suc fin) * prod_list (map (xd k) [Suc i..<k - Suc fin])", "by simp"], ["proof (state)\nthis:\n  pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin) =\n  xd k i * pprod k (Suc i) (k - Suc fin) -\n  xd k (k - Suc fin) * pprod k (Suc i) (k - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  pprod k i (k - Suc fin) - pprod k (Suc i) (k - fin) =\n  xd k i * pprod k (Suc i) (k - Suc fin) -\n  xd k (k - Suc fin) * pprod k (Suc i) (k - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"\\<dots> = (xd k i - xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xd k i * pprod k (Suc i) (k - Suc fin) -\n    xd k (k - Suc fin) * pprod k (Suc i) (k - Suc fin) =\n    (xd k i - xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin)", "by algebra"], ["proof (state)\nthis:\n  xd k i * pprod k (Suc i) (k - Suc fin) -\n  xd k (k - Suc fin) * pprod k (Suc i) (k - Suc fin) =\n  (xd k i - xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  xd k i * pprod k (Suc i) (k - Suc fin) -\n  xd k (k - Suc fin) * pprod k (Suc i) (k - Suc fin) =\n  (xd k i - xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"\\<dots> = (xd (k - Suc fin) i) * pprod k (Suc i) (k - Suc fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xd k i - xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin) =\n    xd (k - Suc fin) i * pprod k (Suc i) (k - Suc fin)", "unfolding xd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x k - x i - (x k - x (k - Suc fin))) * pprod k (Suc i) (k - Suc fin) =\n    (x (k - Suc fin) - x i) * pprod k (Suc i) (k - Suc fin)", "by simp"], ["proof (state)\nthis:\n  (xd k i - xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin) =\n  xd (k - Suc fin) i * pprod k (Suc i) (k - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "also"], ["proof (state)\nthis:\n  (xd k i - xd k (k - Suc fin)) * pprod k (Suc i) (k - Suc fin) =\n  xd (k - Suc fin) i * pprod k (Suc i) (k - Suc fin)\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "have \"xij_f i (k - Suc fin) * \\<dots> = ?mid (Suc fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xij_f i (k - Suc fin) *\n    (xd (k - Suc fin) i * pprod k (Suc i) (k - Suc fin)) =\n    xij_f i (k - Suc fin) * pprod k (Suc i) (k - Suc fin) *\n    xd (k - Suc fin) i", "by simp"], ["proof (state)\nthis:\n  xij_f i (k - Suc fin) *\n  (xd (k - Suc fin) i * pprod k (Suc i) (k - Suc fin)) =\n  xij_f i (k - Suc fin) * pprod k (Suc i) (k - Suc fin) * xd (k - Suc fin) i\n\ngoal (2 subgoals):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i\n 2. \\<And>fin.\n       \\<lbrakk>fin < k - i \\<Longrightarrow>\n                sum_list (map ei [0..<k - i - 0]) +\n                sum_list (map esi [k - i - 0..<k - i]) +\n                xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n                sum_list (map ei [0..<k - i - fin]) +\n                sum_list (map esi [k - i - fin..<k - i]) +\n                xij_f i (k - fin) * pprod k (Suc i) (k - fin) *\n                xd (k - fin) i;\n        Suc fin < k - i\\<rbrakk>\n       \\<Longrightarrow> sum_list (map ei [0..<k - i - 0]) +\n                         sum_list (map esi [k - i - 0..<k - i]) +\n                         xij_f i (k - 0) * pprod k (Suc i) (k - 0) *\n                         xd (k - 0) i =\n                         sum_list (map ei [0..<k - i - Suc fin]) +\n                         sum_list (map esi [k - i - Suc fin..<k - i]) +\n                         xij_f i (k - Suc fin) *\n                         pprod k (Suc i) (k - Suc fin) *\n                         xd (k - Suc fin) i", "finally"], ["proof (chain)\npicking this:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  sum_list (map esi [k - i - Suc fin..<k - i]) +\n  xij_f i (k - Suc fin) * pprod k (Suc i) (k - Suc fin) * xd (k - Suc fin) i", "show ?case"], ["proof (prove)\nusing this:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  sum_list (map esi [k - i - Suc fin..<k - i]) +\n  xij_f i (k - Suc fin) * pprod k (Suc i) (k - Suc fin) * xd (k - Suc fin) i\n\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - Suc fin]) +\n    sum_list (map esi [k - i - Suc fin..<k - i]) +\n    xij_f i (k - Suc fin) * pprod k (Suc i) (k - Suc fin) *\n    xd (k - Suc fin) i", "by simp"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - Suc fin]) +\n  sum_list (map esi [k - i - Suc fin..<k - i]) +\n  xij_f i (k - Suc fin) * pprod k (Suc i) (k - Suc fin) * xd (k - Suc fin) i\n\ngoal (1 subgoal):\n 1. 0 < k - i \\<Longrightarrow>\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n    sum_list (map ei [0..<k - i - 0]) +\n    sum_list (map esi [k - i - 0..<k - i]) +\n    xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i", "qed simp"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - 0]) +\n  sum_list (map esi [k - i - 0..<k - i]) +\n  xij_f i (k - 0) * pprod k (Suc i) (k - 0) * xd (k - 0) i =\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"\\<dots> = (ei 0 + ?mid (k - i - 1)) + ?sumsi [1 ..< k - i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - fin]) +\n    sum_list (map esi [k - i - fin..<k - i]) +\n    xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n    ei 0 +\n    xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n    xd (k - (k - i - 1)) i +\n    sum_list (map esi [1..<k - i])", "unfolding fin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map ei [0..<k - i - (k - i - 1)]) +\n    sum_list (map esi [k - i - (k - i - 1)..<k - i]) +\n    xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n    xd (k - (k - i - 1)) i =\n    ei 0 +\n    xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n    xd (k - (k - i - 1)) i +\n    sum_list (map esi [1..<k - i])", "by (simp add: id3)"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n  ei 0 +\n  xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n  xd (k - (k - i - 1)) i +\n  sum_list (map esi [1..<k - i])\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  sum_list (map ei [0..<k - i - fin]) +\n  sum_list (map esi [k - i - fin..<k - i]) +\n  xij_f i (k - fin) * pprod k (Suc i) (k - fin) * xd (k - fin) i =\n  ei 0 +\n  xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n  xd (k - (k - i - 1)) i +\n  sum_list (map esi [1..<k - i])\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"ei 0 + ?mid (k - i - 1) = esi 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ei 0 +\n    xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n    xd (k - (k - i - 1)) i =\n    esi 0", "unfolding id3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ei 0 + xij_f i (Suc i) * pprod k (Suc i) (Suc i) * xd (Suc i) i = esi 0", "unfolding ei_def esi_def xij_f.simps[of i i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. xij_f i (i + 0) * pprod k i (i + 0) +\n    xij_f i (Suc i) * pprod k (Suc i) (Suc i) * xd (Suc i) i =\n    xij_f (Suc i) (Suc i + 0) * pprod k (Suc i) (Suc i + 0)", "using neq assms"], ["proof (prove)\nusing this:\n  xd (Suc i) i \\<noteq> (0::'a)\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. xij_f i (i + 0) * pprod k i (i + 0) +\n    xij_f i (Suc i) * pprod k (Suc i) (Suc i) * xd (Suc i) i =\n    xij_f (Suc i) (Suc i + 0) * pprod k (Suc i) (Suc i + 0)", "by (simp add: field_simps xij_f.simps pprod_def)"], ["proof (state)\nthis:\n  ei 0 +\n  xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n  xd (k - (k - i - 1)) i =\n  esi 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  ei 0 +\n  xij_f i (k - (k - i - 1)) * pprod k (Suc i) (k - (k - i - 1)) *\n  xd (k - (k - i - 1)) i =\n  esi 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"esi 0 + ?sumsi [1 ..< k - i] = ?sumsi (0 # [1 ..< k - i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esi 0 + sum_list (map esi [1..<k - i]) =\n    sum_list (map esi (0 # [1..<k - i]))", "by simp"], ["proof (state)\nthis:\n  esi 0 + sum_list (map esi [1..<k - i]) =\n  sum_list (map esi (0 # [1..<k - i]))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  esi 0 + sum_list (map esi [1..<k - i]) =\n  sum_list (map esi (0 # [1..<k - i]))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"0 # [1 ..< k - i] = [0 ..< Suc k - Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 # [1..<k - i] = [0..<Suc k - Suc i]", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. 0 # [1..<k - i] = [0..<Suc k - Suc i]", "by (simp add: upt_rec)"], ["proof (state)\nthis:\n  0 # [1..<k - i] = [0..<Suc k - Suc i]\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "also"], ["proof (state)\nthis:\n  0 # [1..<k - i] = [0..<Suc k - Suc i]\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "have \"?sumsi \\<dots> = sum_list (map (\\<lambda> j. xij_f (Suc i) (Suc i + j) * \n    pprod k (Suc i) (Suc i + j)) [0..<Suc k - Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map esi [0..<Suc k - Suc i]) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "unfolding esi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n  i < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "by simp"], ["proof (state)\nthis:\n  sum_list (map esi [0..<Suc k - Suc i]) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       Suc i]. xij_f (Suc i) (Suc i + j) *\n                               pprod k (Suc i) (Suc i + j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       Suc i]. xij_f (Suc i) (Suc i + j) *\n                               pprod k (Suc i) (Suc i + j))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       Suc i]. xij_f (Suc i) (Suc i + j) *\n                               pprod k (Suc i) (Suc i + j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc i]. xij_f (Suc i) (Suc i + j) *\n                                 pprod k (Suc i) (Suc i + j))", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       Suc i]. xij_f (Suc i) (Suc i + j) *\n                               pprod k (Suc i) (Suc i + j))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma divided_differences: assumes kn: \"k \\<le> n\" and ik: \"i \\<le> k\"\n  shows \"sum_list (map (\\<lambda> j. xij_f i (i + j) * pprod k i (i + j)) [0..<Suc k - i]) = f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "fix ii"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "assume \"i + ii \\<le> k\""], ["proof (state)\nthis:\n  i + ii \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "hence \"sum_list (map (\\<lambda> j. xij_f i (i + j) * pprod k i (i + j)) [0..<Suc k - i])\n      = sum_list (map (\\<lambda> j. xij_f (i + ii) (i + ii + j) * pprod k (i + ii) (i + ii + j)) [0..<Suc k - (i + ii)])\""], ["proof (prove)\nusing this:\n  i + ii \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          ii)]. xij_f (i + ii) (i + ii + j) *\n                                pprod k (i + ii) (i + ii + j))", "proof (induct ii)"], ["proof (state)\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow>\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          0)]. xij_f (i + 0) (i + 0 + j) *\n                               pprod k (i + 0) (i + 0 + j))\n 2. \\<And>ii.\n       \\<lbrakk>i + ii \\<le> k \\<Longrightarrow>\n                (\\<Sum>j\\<leftarrow>[0..<\n                                     Suc k -\n                                     i]. xij_f i (i + j) *\n   pprod k i (i + j)) =\n                (\\<Sum>j\\<leftarrow>[0..<\n                                     Suc k -\n                                     (i +\nii)]. xij_f (i + ii) (i + ii + j) * pprod k (i + ii) (i + ii + j));\n        i + Suc ii \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<leftarrow>[0..<\n        Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n                         (\\<Sum>j\\<leftarrow>[0..<\n        Suc k -\n        (i +\n         Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                   pprod k (i + Suc ii) (i + Suc ii + j))", "case (Suc ii)"], ["proof (state)\nthis:\n  i + ii \\<le> k \\<Longrightarrow>\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       (i +\n                        ii)]. xij_f (i + ii) (i + ii + j) *\n                              pprod k (i + ii) (i + ii + j))\n  i + Suc ii \\<le> k\n\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow>\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          0)]. xij_f (i + 0) (i + 0 + j) *\n                               pprod k (i + 0) (i + 0 + j))\n 2. \\<And>ii.\n       \\<lbrakk>i + ii \\<le> k \\<Longrightarrow>\n                (\\<Sum>j\\<leftarrow>[0..<\n                                     Suc k -\n                                     i]. xij_f i (i + j) *\n   pprod k i (i + j)) =\n                (\\<Sum>j\\<leftarrow>[0..<\n                                     Suc k -\n                                     (i +\nii)]. xij_f (i + ii) (i + ii + j) * pprod k (i + ii) (i + ii + j));\n        i + Suc ii \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<leftarrow>[0..<\n        Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n                         (\\<Sum>j\\<leftarrow>[0..<\n        Suc k -\n        (i +\n         Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                   pprod k (i + Suc ii) (i + Suc ii + j))", "hence le1: \"i + ii \\<le> k\" and le2: \"i + ii < k\""], ["proof (prove)\nusing this:\n  i + ii \\<le> k \\<Longrightarrow>\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       (i +\n                        ii)]. xij_f (i + ii) (i + ii + j) *\n                              pprod k (i + ii) (i + ii + j))\n  i + Suc ii \\<le> k\n\ngoal (1 subgoal):\n 1. i + ii \\<le> k &&& i + ii < k", "by simp_all"], ["proof (state)\nthis:\n  i + ii \\<le> k\n  i + ii < k\n\ngoal (2 subgoals):\n 1. i + 0 \\<le> k \\<Longrightarrow>\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          0)]. xij_f (i + 0) (i + 0 + j) *\n                               pprod k (i + 0) (i + 0 + j))\n 2. \\<And>ii.\n       \\<lbrakk>i + ii \\<le> k \\<Longrightarrow>\n                (\\<Sum>j\\<leftarrow>[0..<\n                                     Suc k -\n                                     i]. xij_f i (i + j) *\n   pprod k i (i + j)) =\n                (\\<Sum>j\\<leftarrow>[0..<\n                                     Suc k -\n                                     (i +\nii)]. xij_f (i + ii) (i + ii + j) * pprod k (i + ii) (i + ii + j));\n        i + Suc ii \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>j\\<leftarrow>[0..<\n        Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n                         (\\<Sum>j\\<leftarrow>[0..<\n        Suc k -\n        (i +\n         Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                   pprod k (i + Suc ii) (i + Suc ii + j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                                    pprod k (i + Suc ii) (i + Suc ii + j))", "unfolding Suc(1)[OF le1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          ii)]. xij_f (i + ii) (i + ii + j) *\n                                pprod k (i + ii) (i + ii + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                                    pprod k (i + Suc ii) (i + Suc ii + j))", "unfolding divided_differences_main[OF kn le2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc (i +\n                              ii)]. xij_f (Suc (i + ii))\n                                     (Suc (i + ii) + j) *\n                                    pprod k (Suc (i + ii))\n                                     (Suc (i + ii) + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                                    pprod k (i + Suc ii) (i + Suc ii + j))", "using Suc(2)"], ["proof (prove)\nusing this:\n  i + Suc ii \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         Suc (i +\n                              ii)]. xij_f (Suc (i + ii))\n                                     (Suc (i + ii) + j) *\n                                    pprod k (Suc (i + ii))\n                                     (Suc (i + ii) + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                                    pprod k (i + Suc ii) (i + Suc ii + j))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       (i +\n                        Suc ii)]. xij_f (i + Suc ii) (i + Suc ii + j) *\n                                  pprod k (i + Suc ii) (i + Suc ii + j))\n\ngoal (1 subgoal):\n 1. i + 0 \\<le> k \\<Longrightarrow>\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          0)]. xij_f (i + 0) (i + 0 + j) *\n                               pprod k (i + 0) (i + 0 + j))", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       (i +\n                        ii)]. xij_f (i + ii) (i + ii + j) *\n                              pprod k (i + ii) (i + ii + j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "}"], ["proof (state)\nthis:\n  i + ?ii2 \\<le> k \\<Longrightarrow>\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       (i +\n                        ?ii2)]. xij_f (i + ?ii2) (i + ?ii2 + j) *\n                                pprod k (i + ?ii2) (i + ?ii2 + j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "note main = this"], ["proof (state)\nthis:\n  i + ?ii2 \\<le> k \\<Longrightarrow>\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k -\n                       (i +\n                        ?ii2)]. xij_f (i + ?ii2) (i + ?ii2 + j) *\n                                pprod k (i + ?ii2) (i + ?ii2 + j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "have ik: \"i + (k - i) \\<le> k\" and id: \"i + (k - i) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + (k - i) \\<le> k &&& i + (k - i) = k", "using ik"], ["proof (prove)\nusing this:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. i + (k - i) \\<le> k &&& i + (k - i) = k", "by simp_all"], ["proof (state)\nthis:\n  i + (k - i) \\<le> k\n  i + (k - i) = k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n    f k", "unfolding main[OF ik]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k -\n                         (i +\n                          (k -\n                           i))]. xij_f (i + (k - i)) (i + (k - i) + j) *\n                                 pprod k (i + (k - i)) (i + (k - i) + j)) =\n    f k", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - k]. xij_f k (k + j) * pprod k k (k + j)) =\n    f k", "by (simp add: xij_f.simps pprod_def)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - i]. xij_f i (i + j) * pprod k i (i + j)) =\n  f k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma newton_poly_sound: assumes \"k \\<le> n\"\n  shows \"poly (newton_poly n) (x k) = f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x k) = f k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x k) = f k", "have \"poly (newton_poly n) (x k) = \n    sum_list (map (\\<lambda> j. xij_f 0 (0 + j) * pprod k 0 (0 + j)) [0..<Suc k - 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x k) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - 0]. xij_f 0 (0 + j) * pprod k 0 (0 + j))", "unfolding poly_newton_poly_xj[OF assms] c_def poly_N_xi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<Suc k]. xij_f 0 i * pprod k 0 i) =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - 0]. xij_f 0 (0 + j) * pprod k 0 (0 + j))", "by simp"], ["proof (state)\nthis:\n  poly (local.newton_poly n) (x k) =\n  (\\<Sum>j\\<leftarrow>[0..<Suc k - 0]. xij_f 0 (0 + j) * pprod k 0 (0 + j))\n\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x k) = f k", "also"], ["proof (state)\nthis:\n  poly (local.newton_poly n) (x k) =\n  (\\<Sum>j\\<leftarrow>[0..<Suc k - 0]. xij_f 0 (0 + j) * pprod k 0 (0 + j))\n\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x k) = f k", "have \"\\<dots> = f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc k - 0]. xij_f 0 (0 + j) * pprod k 0 (0 + j)) =\n    f k", "by (rule divided_differences[OF assms], simp)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc k - 0]. xij_f 0 (0 + j) * pprod k 0 (0 + j)) =\n  f k\n\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x k) = f k", "finally"], ["proof (chain)\npicking this:\n  poly (local.newton_poly n) (x k) = f k", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (local.newton_poly n) (x k) = f k\n\ngoal (1 subgoal):\n 1. poly (local.newton_poly n) (x k) = f k", "by simp"], ["proof (state)\nthis:\n  poly (local.newton_poly n) (x k) = f k\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma newton_poly_degree: \"degree (newton_poly n) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (local.newton_poly n) \\<le> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (local.newton_poly n) \\<le> n", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (local.newton_poly n) \\<le> n", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (local.newton_poly n) \\<le> n", "have \"i \\<le> n \\<Longrightarrow> degree (b i n) \\<le> n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> n \\<Longrightarrow> degree (b i n) \\<le> n - i", "proof (induct i n rule: b.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> degree (b (Suc i) n) \\<le> n - Suc i;\n        i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> degree (b i n) \\<le> n - i", "case (1 i n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> degree (b (Suc i) n) \\<le> n - Suc i\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> degree (b (Suc i) n) \\<le> n - Suc i;\n        i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> degree (b i n) \\<le> n - i", "note b = b.simps[of i n]"], ["proof (state)\nthis:\n  b i n = (if n \\<le> i then [:c n:] else b (Suc i) n * X i + [:c i:])\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> degree (b (Suc i) n) \\<le> n - Suc i;\n        i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> degree (b i n) \\<le> n - i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (b i n) \\<le> n - i", "proof (cases \"n \\<le> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i\n 2. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "case True"], ["proof (state)\nthis:\n  n \\<le> i\n\ngoal (2 subgoals):\n 1. n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i\n 2. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. degree (b i n) \\<le> n - i", "unfolding b"], ["proof (prove)\nusing this:\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. degree (if n \\<le> i then [:c n:] else b (Suc i) n * X i + [:c i:])\n    \\<le> n - i", "by auto"], ["proof (state)\nthis:\n  degree (b i n) \\<le> n - i\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "have \"degree (b i n) = degree (b (Suc i) n * X i + [:c i:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (b i n) = degree (b (Suc i) n * X i + [:c i:])", "using False"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. degree (b i n) = degree (b (Suc i) n * X i + [:c i:])", "unfolding b"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. degree (if n \\<le> i then [:c n:] else b (Suc i) n * X i + [:c i:]) =\n    degree (b (Suc i) n * X i + [:c i:])", "by simp"], ["proof (state)\nthis:\n  degree (b i n) = degree (b (Suc i) n * X i + [:c i:])\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "also"], ["proof (state)\nthis:\n  degree (b i n) = degree (b (Suc i) n * X i + [:c i:])\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "have \"\\<dots> \\<le> max (degree (b (Suc i) n * X i)) (degree [:c i:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (b (Suc i) n * X i + [:c i:])\n    \\<le> max (degree (b (Suc i) n * X i)) (degree [:c i:])", "by (rule degree_add_le_max)"], ["proof (state)\nthis:\n  degree (b (Suc i) n * X i + [:c i:])\n  \\<le> max (degree (b (Suc i) n * X i)) (degree [:c i:])\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "also"], ["proof (state)\nthis:\n  degree (b (Suc i) n * X i + [:c i:])\n  \\<le> max (degree (b (Suc i) n * X i)) (degree [:c i:])\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "have \"\\<dots> = degree (b (Suc i) n * X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (degree (b (Suc i) n * X i)) (degree [:c i:]) =\n    degree (b (Suc i) n * X i)", "by simp"], ["proof (state)\nthis:\n  max (degree (b (Suc i) n * X i)) (degree [:c i:]) =\n  degree (b (Suc i) n * X i)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "also"], ["proof (state)\nthis:\n  max (degree (b (Suc i) n * X i)) (degree [:c i:]) =\n  degree (b (Suc i) n * X i)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "have \"\\<dots> \\<le> degree (b (Suc i) n) + degree (X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (b (Suc i) n * X i) \\<le> degree (b (Suc i) n) + degree (X i)", "by (rule degree_mult_le)"], ["proof (state)\nthis:\n  degree (b (Suc i) n * X i) \\<le> degree (b (Suc i) n) + degree (X i)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "also"], ["proof (state)\nthis:\n  degree (b (Suc i) n * X i) \\<le> degree (b (Suc i) n) + degree (X i)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "have \"\\<dots> \\<le> n - Suc i + degree (X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (b (Suc i) n) + degree (X i) \\<le> n - Suc i + degree (X i)", "using 1(1)[OF False] 1(2) False add_le_mono1 not_less_eq_eq"], ["proof (prove)\nusing this:\n  Suc i \\<le> n \\<Longrightarrow> degree (b (Suc i) n) \\<le> n - Suc i\n  i \\<le> n\n  \\<not> n \\<le> i\n  ?i \\<le> ?j \\<Longrightarrow> ?i + ?k \\<le> ?j + ?k\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. degree (b (Suc i) n) + degree (X i) \\<le> n - Suc i + degree (X i)", "by blast"], ["proof (state)\nthis:\n  degree (b (Suc i) n) + degree (X i) \\<le> n - Suc i + degree (X i)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "also"], ["proof (state)\nthis:\n  degree (b (Suc i) n) + degree (X i) \\<le> n - Suc i + degree (X i)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "have \"\\<dots> = n - Suc i + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc i + degree (X i) = n - Suc i + 1", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc i + degree [:- x i, 1::'a:] = n - Suc i + 1", "by simp"], ["proof (state)\nthis:\n  n - Suc i + degree (X i) = n - Suc i + 1\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "also"], ["proof (state)\nthis:\n  n - Suc i + degree (X i) = n - Suc i + 1\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "have \"\\<dots> = n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc i + 1 = n - i", "using 1(2) False"], ["proof (prove)\nusing this:\n  i \\<le> n\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. n - Suc i + 1 = n - i", "by auto"], ["proof (state)\nthis:\n  n - Suc i + 1 = n - i\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow> degree (b i n) \\<le> n - i", "finally"], ["proof (chain)\npicking this:\n  degree (b i n) \\<le> n - i", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (b i n) \\<le> n - i\n\ngoal (1 subgoal):\n 1. degree (b i n) \\<le> n - i", "."], ["proof (state)\nthis:\n  degree (b i n) \\<le> n - i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (b i n) \\<le> n - i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<le> n \\<Longrightarrow> degree (b i n) \\<le> n - i\n\ngoal (1 subgoal):\n 1. degree (local.newton_poly n) \\<le> n", "}"], ["proof (state)\nthis:\n  ?i2 \\<le> n \\<Longrightarrow> degree (b ?i2 n) \\<le> n - ?i2\n\ngoal (1 subgoal):\n 1. degree (local.newton_poly n) \\<le> n", "from this[of 0]"], ["proof (chain)\npicking this:\n  0 \\<le> n \\<Longrightarrow> degree (b 0 n) \\<le> n - 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> n \\<Longrightarrow> degree (b 0 n) \\<le> n - 0\n\ngoal (1 subgoal):\n 1. degree (local.newton_poly n) \\<le> n", "unfolding newton_poly_def"], ["proof (prove)\nusing this:\n  0 \\<le> n \\<Longrightarrow> degree (b 0 n) \\<le> n - 0\n\ngoal (1 subgoal):\n 1. degree (b 0 n) \\<le> n", "by simp"], ["proof (state)\nthis:\n  degree (local.newton_poly n) \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes n\n  assumes xs: \"length xs = n\"\n    and fs: \"length fs = n\"\nbegin"], ["", "lemma newton_coefficients_main: \n  \"k < n \\<Longrightarrow> newton_coefficients_main (rev (map f [0..<Suc k])) (rev (map x [0..<Suc k]))\n    = rev (map (\\<lambda> i. map (\\<lambda> j. xij_f j i) [0..<Suc i]) [0..<Suc k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    local.newton_coefficients_main (rev (map f [0..<Suc k]))\n     (rev (map x [0..<Suc k])) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<Suc k])", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    local.newton_coefficients_main (rev (map f [0..<Suc 0]))\n     (rev (map x [0..<Suc 0])) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<Suc 0])\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    local.newton_coefficients_main (rev (map f [0..<Suc 0]))\n     (rev (map x [0..<Suc 0])) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<Suc 0])\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_coefficients_main (rev (map f [0..<Suc 0]))\n     (rev (map x [0..<Suc 0])) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<Suc 0])", "by (simp add: xij_f.simps)"], ["proof (state)\nthis:\n  local.newton_coefficients_main (rev (map f [0..<Suc 0]))\n   (rev (map x [0..<Suc 0])) =\n  rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n        [0..<Suc 0])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow>\n  local.newton_coefficients_main (rev (map f [0..<Suc k]))\n   (rev (map x [0..<Suc k])) =\n  rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n        [0..<Suc k])\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "hence \"k < n\""], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow>\n  local.newton_coefficients_main (rev (map f [0..<Suc k]))\n   (rev (map x [0..<Suc k])) =\n  rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n        [0..<Suc k])\n  Suc k < n\n\ngoal (1 subgoal):\n 1. k < n", "by auto"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "note IH = Suc(1)[OF this]"], ["proof (state)\nthis:\n  local.newton_coefficients_main (rev (map f [0..<Suc k]))\n   (rev (map x [0..<Suc k])) =\n  rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n        [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "have id: \"\\<And> f. rev (map f [0..<Suc (Suc k)]) = f (Suc k) # f k # rev (map f [0..< k])\" \n    and id2: \"\\<And> f. f k # rev (map f [0..<k]) = rev (map f [0..< Suc k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        rev (map f [0..<Suc (Suc k)]) =\n        f (Suc k) # f k # rev (map f [0..<k])) &&&\n    (\\<And>f. f k # rev (map f [0..<k]) = rev (map f [0..<Suc k]))", "by simp_all"], ["proof (state)\nthis:\n  rev (map ?f [0..<Suc (Suc k)]) = ?f (Suc k) # ?f k # rev (map ?f [0..<k])\n  ?f k # rev (map ?f [0..<k]) = rev (map ?f [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                local.newton_coefficients_main (rev (map f [0..<Suc k]))\n                 (rev (map x [0..<Suc k])) =\n                rev (map (\\<lambda>i.\n                             map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                      [0..<Suc k]);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> local.newton_coefficients_main\n                          (rev (map f [0..<Suc (Suc k)]))\n                          (rev (map x [0..<Suc (Suc k)])) =\n                         rev (map (\\<lambda>i.\nmap (\\<lambda>j. xij_f j i) [0..<Suc i])\n                               [0..<Suc (Suc k)])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_coefficients_main (rev (map f [0..<Suc (Suc k)]))\n     (rev (map x [0..<Suc (Suc k)])) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<Suc (Suc k)])", "unfolding id newton_coefficients_main.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (hd (local.newton_coefficients_main (f k # rev (map f [0..<k]))\n           (x k # rev (map x [0..<k]))))\n     (f (Suc k)) (x (Suc k)) xs #\n    local.newton_coefficients_main (f k # rev (map f [0..<k]))\n     (x k # rev (map x [0..<k])) =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)] #\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "unfolding id2 IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (hd (rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<Suc k])))\n     (f (Suc k)) (x (Suc k)) xs #\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<Suc k]) =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)] #\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "unfolding list.simps id2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)] \\<and>\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "proof (rule conjI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "have xs: \"xs = map x [0 ..< n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map x [0..<n]", "using xs"], ["proof (prove)\nusing this:\n  length xs = n\n\ngoal (1 subgoal):\n 1. xs = map x [0..<n]", "unfolding x_def[abs_def]"], ["proof (prove)\nusing this:\n  length xs = n\n\ngoal (1 subgoal):\n 1. xs = map ((!) xs) [0..<n]", "by (intro nth_equalityI, auto)"], ["proof (state)\nthis:\n  xs = map x [0..<n]\n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "define nn where \"nn = (0 :: nat)\""], ["proof (state)\nthis:\n  nn = 0\n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "define m where \"m = Suc k - nn\""], ["proof (state)\nthis:\n  m = Suc k - nn\n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "have prems: \"m = Suc k - nn\" \"nn < Suc (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = Suc k - nn &&& nn < Suc (Suc k)", "unfolding m_def nn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k - 0 = Suc k - 0 &&& 0 < Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  m = Suc k - nn\n  nn < Suc (Suc k)\n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "have \"?case = (divided_differences_impl (map ((\\<lambda>j. xij_f j k)) [nn..< Suc k]) (f (Suc k)) (x (Suc k)) (map x [nn ..< n]) =\n      map ((\\<lambda>j. xij_f j (Suc k))) [nn..<Suc (Suc k)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.divided_differences_impl\n      (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n           rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                 [0..<k])))\n      (f (Suc k)) (x (Suc k)) xs =\n     map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]) =\n    (local.divided_differences_impl\n      (map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n      (map x [nn..<n]) =\n     map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)])", "unfolding nn_def xs[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.divided_differences_impl\n      (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n           rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                 [0..<k])))\n      (f (Suc k)) (x (Suc k)) xs =\n     map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]) =\n    (local.divided_differences_impl\n      (map (\\<lambda>j. xij_f j k) [0..<Suc k]) (f (Suc k)) (x (Suc k)) xs =\n     map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)])", "by simp"], ["proof (state)\nthis:\n  (local.divided_differences_impl\n    (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n         rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n               [0..<k])))\n    (f (Suc k)) (x (Suc k)) xs =\n   map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]) =\n  (local.divided_differences_impl (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n    (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n   map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)])\n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "also"], ["proof (state)\nthis:\n  (local.divided_differences_impl\n    (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n         rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n               [0..<k])))\n    (f (Suc k)) (x (Suc k)) xs =\n   map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]) =\n  (local.divided_differences_impl (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n    (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n   map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)])\n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n     (map x [nn..<n]) =\n    map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]", "using prems"], ["proof (prove)\nusing this:\n  m = Suc k - nn\n  nn < Suc (Suc k)\n\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n     (map x [nn..<n]) =\n    map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]", "proof (induct m arbitrary: nn)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nn.\n       \\<lbrakk>0 = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]\n 2. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "case 0"], ["proof (state)\nthis:\n  0 = Suc k - nn\n  nn < Suc (Suc k)\n\ngoal (2 subgoals):\n 1. \\<And>nn.\n       \\<lbrakk>0 = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]\n 2. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "hence nn: \"nn = Suc k\""], ["proof (prove)\nusing this:\n  0 = Suc k - nn\n  nn < Suc (Suc k)\n\ngoal (1 subgoal):\n 1. nn = Suc k", "by auto"], ["proof (state)\nthis:\n  nn = Suc k\n\ngoal (2 subgoals):\n 1. \\<And>nn.\n       \\<lbrakk>0 = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]\n 2. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n     (map x [nn..<n]) =\n    map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]", "unfolding nn"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (map (\\<lambda>j. xij_f j k) [Suc k..<Suc k]) (f (Suc k)) (x (Suc k))\n     (map x [Suc k..<n]) =\n    map (\\<lambda>j. xij_f j (Suc k)) [Suc k..<Suc (Suc k)]", "by (simp add: xij_f.simps)"], ["proof (state)\nthis:\n  local.divided_differences_impl (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n   (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n  map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]\n\ngoal (1 subgoal):\n 1. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>m = Suc k - ?nn1; ?nn1 < Suc (Suc k)\\<rbrakk>\n  \\<Longrightarrow> local.divided_differences_impl\n                     (map (\\<lambda>j. xij_f j k) [?nn1..<Suc k])\n                     (f (Suc k)) (x (Suc k)) (map x [?nn1..<n]) =\n                    map (\\<lambda>j. xij_f j (Suc k)) [?nn1..<Suc (Suc k)]\n  Suc m = Suc k - nn\n  nn < Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "with \\<open>Suc k < n\\<close>"], ["proof (chain)\npicking this:\n  Suc k < n\n  \\<lbrakk>m = Suc k - ?nn1; ?nn1 < Suc (Suc k)\\<rbrakk>\n  \\<Longrightarrow> local.divided_differences_impl\n                     (map (\\<lambda>j. xij_f j k) [?nn1..<Suc k])\n                     (f (Suc k)) (x (Suc k)) (map x [?nn1..<n]) =\n                    map (\\<lambda>j. xij_f j (Suc k)) [?nn1..<Suc (Suc k)]\n  Suc m = Suc k - nn\n  nn < Suc (Suc k)", "have \"nn < n\" and le: \"nn < Suc k\""], ["proof (prove)\nusing this:\n  Suc k < n\n  \\<lbrakk>m = Suc k - ?nn1; ?nn1 < Suc (Suc k)\\<rbrakk>\n  \\<Longrightarrow> local.divided_differences_impl\n                     (map (\\<lambda>j. xij_f j k) [?nn1..<Suc k])\n                     (f (Suc k)) (x (Suc k)) (map x [?nn1..<n]) =\n                    map (\\<lambda>j. xij_f j (Suc k)) [?nn1..<Suc (Suc k)]\n  Suc m = Suc k - nn\n  nn < Suc (Suc k)\n\ngoal (1 subgoal):\n 1. nn < n &&& nn < Suc k", "by auto"], ["proof (state)\nthis:\n  nn < n\n  nn < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "with Suc(2-)"], ["proof (chain)\npicking this:\n  Suc m = Suc k - nn\n  nn < Suc (Suc k)\n  nn < n\n  nn < Suc k", "have id: \n        \"[nn..<Suc k] = nn # [Suc nn..< Suc k]\"\n        \"[nn..<n] = nn # [Suc nn..< n]\"\n      and id2: \"[nn..<Suc (Suc k)] = nn # [Suc nn..<Suc (Suc k)]\"\n        \"[Suc nn..<Suc (Suc k)] = Suc nn # [Suc (Suc nn)..<Suc (Suc k)]\""], ["proof (prove)\nusing this:\n  Suc m = Suc k - nn\n  nn < Suc (Suc k)\n  nn < n\n  nn < Suc k\n\ngoal (1 subgoal):\n 1. ([nn..<Suc k] = nn # [Suc nn..<Suc k] &&&\n     [nn..<n] = nn # [Suc nn..<n]) &&&\n    [nn..<Suc (Suc k)] = nn # [Suc nn..<Suc (Suc k)] &&&\n    [Suc nn..<Suc (Suc k)] = Suc nn # [Suc (Suc nn)..<Suc (Suc k)]", "by (auto simp: upt_rec)"], ["proof (state)\nthis:\n  [nn..<Suc k] = nn # [Suc nn..<Suc k]\n  [nn..<n] = nn # [Suc nn..<n]\n  [nn..<Suc (Suc k)] = nn # [Suc nn..<Suc (Suc k)]\n  [Suc nn..<Suc (Suc k)] = Suc nn # [Suc (Suc nn)..<Suc (Suc k)]\n\ngoal (1 subgoal):\n 1. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "from Suc(2-)"], ["proof (chain)\npicking this:\n  Suc m = Suc k - nn\n  nn < Suc (Suc k)", "have \"m = Suc k - Suc nn\" \"Suc nn < Suc (Suc k)\""], ["proof (prove)\nusing this:\n  Suc m = Suc k - nn\n  nn < Suc (Suc k)\n\ngoal (1 subgoal):\n 1. m = Suc k - Suc nn &&& Suc nn < Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  m = Suc k - Suc nn\n  Suc nn < Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "note IH = Suc(1)[OF this]"], ["proof (state)\nthis:\n  local.divided_differences_impl\n   (map (\\<lambda>j. xij_f j k) [Suc nn..<Suc k]) (f (Suc k)) (x (Suc k))\n   (map x [Suc nn..<n]) =\n  map (\\<lambda>j. xij_f j (Suc k)) [Suc nn..<Suc (Suc k)]\n\ngoal (1 subgoal):\n 1. \\<And>m nn.\n       \\<lbrakk>\\<And>nn.\n                   \\<lbrakk>m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> local.divided_differences_impl\n(map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n(map x [nn..<n]) =\n                                     map (\\<lambda>j. xij_f j (Suc k))\n[nn..<Suc (Suc k)];\n        Suc m = Suc k - nn; nn < Suc (Suc k)\\<rbrakk>\n       \\<Longrightarrow> local.divided_differences_impl\n                          (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n                          (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n                         map (\\<lambda>j. xij_f j (Suc k))\n                          [nn..<Suc (Suc k)]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (map (\\<lambda>j. xij_f j k) [nn..<Suc k]) (f (Suc k)) (x (Suc k))\n     (map x [nn..<n]) =\n    map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]", "unfolding id list.simps divided_differences_impl.simps IH Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hd (map (\\<lambda>j. xij_f j (Suc k)) [Suc nn..<Suc (Suc k)]) -\n     xij_f nn k) /\n    (x (Suc k) - x nn) #\n    map (\\<lambda>j. xij_f j (Suc k)) [Suc nn..<Suc (Suc k)] =\n    map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]", "unfolding id2 list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hd (xij_f (Suc nn) (Suc k) #\n         map (\\<lambda>j. xij_f j (Suc k)) [Suc (Suc nn)..<Suc (Suc k)]) -\n     xij_f nn k) /\n    (x (Suc k) - x nn) =\n    xij_f nn (Suc k) \\<and>\n    xij_f (Suc nn) (Suc k) = xij_f (Suc nn) (Suc k) \\<and>\n    map (\\<lambda>j. xij_f j (Suc k)) [Suc (Suc nn)..<Suc (Suc k)] =\n    map (\\<lambda>j. xij_f j (Suc k)) [Suc (Suc nn)..<Suc (Suc k)]", "using le"], ["proof (prove)\nusing this:\n  nn < Suc k\n\ngoal (1 subgoal):\n 1. (hd (xij_f (Suc nn) (Suc k) #\n         map (\\<lambda>j. xij_f j (Suc k)) [Suc (Suc nn)..<Suc (Suc k)]) -\n     xij_f nn k) /\n    (x (Suc k) - x nn) =\n    xij_f nn (Suc k) \\<and>\n    xij_f (Suc nn) (Suc k) = xij_f (Suc nn) (Suc k) \\<and>\n    map (\\<lambda>j. xij_f j (Suc k)) [Suc (Suc nn)..<Suc (Suc k)] =\n    map (\\<lambda>j. xij_f j (Suc k)) [Suc (Suc nn)..<Suc (Suc k)]", "by (simp add: xij_f.simps[of nn \"Suc k\"] xd_def)"], ["proof (state)\nthis:\n  local.divided_differences_impl (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n   (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n  map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.divided_differences_impl (map (\\<lambda>j. xij_f j k) [nn..<Suc k])\n   (f (Suc k)) (x (Suc k)) (map x [nn..<n]) =\n  map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)]\n\ngoal (2 subgoals):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n 2. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "finally"], ["proof (chain)\npicking this:\n  (local.divided_differences_impl\n    (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n         rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n               [0..<k])))\n    (f (Suc k)) (x (Suc k)) xs =\n   map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]) =\n  (map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)] =\n   map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)])", "show ?case"], ["proof (prove)\nusing this:\n  (local.divided_differences_impl\n    (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n         rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n               [0..<k])))\n    (f (Suc k)) (x (Suc k)) xs =\n   map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]) =\n  (map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)] =\n   map (\\<lambda>j. xij_f j (Suc k)) [nn..<Suc (Suc k)])\n\ngoal (1 subgoal):\n 1. local.divided_differences_impl\n     (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n          rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n                [0..<k])))\n     (f (Suc k)) (x (Suc k)) xs =\n    map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]", "by simp"], ["proof (state)\nthis:\n  local.divided_differences_impl\n   (hd (map (\\<lambda>j. xij_f j k) [0..<Suc k] #\n        rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n              [0..<k])))\n   (f (Suc k)) (x (Suc k)) xs =\n  map (\\<lambda>j. xij_f j (Suc k)) [0..<Suc (Suc k)]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>j. xij_f j k) [0..<Suc k] =\n    map (\\<lambda>j. xij_f j k) [0..<Suc k] \\<and>\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n          [0..<k]) =\n    rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i]) [0..<k])", "qed simp"], ["proof (state)\nthis:\n  local.newton_coefficients_main (rev (map f [0..<Suc (Suc k)]))\n   (rev (map x [0..<Suc (Suc k)])) =\n  rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n        [0..<Suc (Suc k)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma newton_coefficients: \"newton_coefficients = rev (map c [0 ..< n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_coefficients = rev (map c [0..<n])", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.newton_coefficients = rev (map c [0..<n])\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.newton_coefficients = rev (map c [0..<n])\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "hence xs: \"xs = []\" \"fs = []\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. xs = [] &&& fs = []", "using xs fs"], ["proof (prove)\nusing this:\n  n = 0\n  length xs = n\n  length fs = n\n\ngoal (1 subgoal):\n 1. xs = [] &&& fs = []", "by auto"], ["proof (state)\nthis:\n  xs = []\n  fs = []\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.newton_coefficients = rev (map c [0..<n])\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_coefficients = rev (map c [0..<n])", "unfolding newton_coefficients_def 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. map hd (local.newton_coefficients_main (rev fs) (rev xs)) =\n    rev (map c [0..<0])", "using newton_coefficients_main.simps"], ["proof (prove)\nusing this:\n  local.newton_coefficients_main [?fj] ?xjs = [[?fj]]\n  local.newton_coefficients_main (?fj # ?v # ?va) (?xj # ?xjs) =\n  (let rec = local.newton_coefficients_main (?v # ?va) ?xjs; row = hd rec;\n       new_row = local.divided_differences_impl row ?fj ?xj xs\n   in new_row # rec)\n  local.newton_coefficients_main [] ?uv = []\n  local.newton_coefficients_main (?v # ?vb # ?vc) [] = []\n\ngoal (1 subgoal):\n 1. map hd (local.newton_coefficients_main (rev fs) (rev xs)) =\n    rev (map c [0..<0])", "unfolding xs"], ["proof (prove)\nusing this:\n  Newton_Interpolation.newton_coefficients_main [] [?fj] ?xjs = [[?fj]]\n  Newton_Interpolation.newton_coefficients_main [] (?fj # ?v # ?va)\n   (?xj # ?xjs) =\n  (let rec =\n         Newton_Interpolation.newton_coefficients_main [] (?v # ?va) ?xjs;\n       row = hd rec; new_row = local.divided_differences_impl row ?fj ?xj []\n   in new_row # rec)\n  Newton_Interpolation.newton_coefficients_main [] [] ?uv = []\n  Newton_Interpolation.newton_coefficients_main [] (?v # ?vb # ?vc) [] = []\n\ngoal (1 subgoal):\n 1. map hd\n     (Newton_Interpolation.newton_coefficients_main [] (rev []) (rev [])) =\n    rev (map (??.Newton_Interpolation.c [] []) [0..<0])", "by simp"], ["proof (state)\nthis:\n  local.newton_coefficients = rev (map c [0..<n])\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "case (Suc nn)"], ["proof (state)\nthis:\n  n = Suc nn\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "hence sn: \"Suc nn = n\" and nn: \"nn < n\""], ["proof (prove)\nusing this:\n  n = Suc nn\n\ngoal (1 subgoal):\n 1. Suc nn = n &&& nn < n", "by auto"], ["proof (state)\nthis:\n  Suc nn = n\n  nn < n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "from fs"], ["proof (chain)\npicking this:\n  length fs = n", "have fs: \"map f [0..<Suc nn] = fs\""], ["proof (prove)\nusing this:\n  length fs = n\n\ngoal (1 subgoal):\n 1. map f [0..<Suc nn] = fs", "unfolding sn"], ["proof (prove)\nusing this:\n  length fs = n\n\ngoal (1 subgoal):\n 1. map f [0..<n] = fs", "by (intro nth_equalityI, auto simp: f_def)"], ["proof (state)\nthis:\n  map f [0..<Suc nn] = fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "from xs"], ["proof (chain)\npicking this:\n  length xs = n", "have xs: \"map x [0..<Suc nn] = xs\""], ["proof (prove)\nusing this:\n  length xs = n\n\ngoal (1 subgoal):\n 1. map x [0..<Suc nn] = xs", "unfolding sn"], ["proof (prove)\nusing this:\n  length xs = n\n\ngoal (1 subgoal):\n 1. map x [0..<n] = xs", "by (intro nth_equalityI, auto simp: x_def)"], ["proof (state)\nthis:\n  map x [0..<Suc nn] = xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       local.newton_coefficients = rev (map c [0..<n])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_coefficients = rev (map c [0..<n])", "unfolding newton_coefficients_def\n      newton_coefficients_main[OF nn, unfolded fs xs]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map hd\n     (rev (map (\\<lambda>i. map (\\<lambda>j. xij_f j i) [0..<Suc i])\n            [0..<Suc nn])) =\n    rev (map c [0..<n])", "unfolding sn rev_map[symmetric] map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (map (\\<lambda>x. hd (map (\\<lambda>j. xij_f j x) [0..<Suc x]))\n          [0..<n]) =\n    rev (map c [0..<n])", "by (rule arg_cong[of _ _ rev], subst upt_rec, intro nth_equalityI, auto simp: c_def)"], ["proof (state)\nthis:\n  local.newton_coefficients = rev (map c [0..<n])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma newton_poly_impl: assumes \"n = Suc nn\"\n  shows \"newton_poly_impl = newton_poly nn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_poly_impl = local.newton_poly nn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_poly_impl = local.newton_poly nn", "define i where \"i = (0 :: nat)\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. local.newton_poly_impl = local.newton_poly nn", "have xs: \"map x [0..<n] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map x [0..<n] = xs", "using xs"], ["proof (prove)\nusing this:\n  length xs = n\n\ngoal (1 subgoal):\n 1. map x [0..<n] = xs", "by (intro nth_equalityI, auto simp: x_def)"], ["proof (state)\nthis:\n  map x [0..<n] = xs\n\ngoal (1 subgoal):\n 1. local.newton_poly_impl = local.newton_poly nn", "have \"i \\<le> nn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> nn", "unfolding i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> nn", "by simp"], ["proof (state)\nthis:\n  i \\<le> nn\n\ngoal (1 subgoal):\n 1. local.newton_poly_impl = local.newton_poly nn", "hence \"horner_composition (map c [i..<Suc nn]) (map x [i..<Suc nn]) = b i nn\""], ["proof (prove)\nusing this:\n  i \\<le> nn\n\ngoal (1 subgoal):\n 1. horner_composition (map c [i..<Suc nn]) (map x [i..<Suc nn]) = b i nn", "proof (induct i nn rule: b.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> horner_composition (map c [Suc i..<Suc n])\n                                   (map x [Suc i..<Suc n]) =\n                                  b (Suc i) n;\n        i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> horner_composition (map c [i..<Suc n])\n                          (map x [i..<Suc n]) =\n                         b i n", "case (1 i n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> horner_composition (map c [Suc i..<Suc n])\n                     (map x [Suc i..<Suc n]) =\n                    b (Suc i) n\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i; Suc i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> horner_composition (map c [Suc i..<Suc n])\n                                   (map x [Suc i..<Suc n]) =\n                                  b (Suc i) n;\n        i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> horner_composition (map c [i..<Suc n])\n                          (map x [i..<Suc n]) =\n                         b i n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "proof (cases \"n \\<le> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n\n 2. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "case True"], ["proof (state)\nthis:\n  n \\<le> i\n\ngoal (2 subgoals):\n 1. n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n\n 2. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "with 1(2)"], ["proof (chain)\npicking this:\n  i \\<le> n\n  n \\<le> i", "have i: \"i = n\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. i = n", "by simp"], ["proof (state)\nthis:\n  i = n\n\ngoal (2 subgoals):\n 1. n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n\n 2. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "unfolding i b.simps[of n n]"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (map c [n..<Suc n]) (map x [n..<Suc n]) =\n    (if n \\<le> n then [:c n:] else b (Suc n) n * X n + [:c n:])", "by simp"], ["proof (state)\nthis:\n  horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "hence \"Suc i \\<le> n\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. Suc i \\<le> n", "by simp"], ["proof (state)\nthis:\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "note IH = 1(1)[OF False this]"], ["proof (state)\nthis:\n  horner_composition (map c [Suc i..<Suc n]) (map x [Suc i..<Suc n]) =\n  b (Suc i) n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "have bi: \"b i n = b (Suc i) n * X i + [:c i:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b i n = b (Suc i) n * X i + [:c i:]", "using False"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. b i n = b (Suc i) n * X i + [:c i:]", "by (simp add: b.simps)"], ["proof (state)\nthis:\n  b i n = b (Suc i) n * X i + [:c i:]\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "from False"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> i", "have id: \"[i ..< Suc n] = i # [Suc i ..< Suc n]\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. [i..<Suc n] = i # [Suc i..<Suc n]", "by (simp add: upt_rec)"], ["proof (state)\nthis:\n  [i..<Suc n] = i # [Suc i..<Suc n]\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "from False"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> i", "have id2: \"[Suc i ..< Suc n] = Suc i # [Suc (Suc i) ..< Suc n]\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> i\n\ngoal (1 subgoal):\n 1. [Suc i..<Suc n] = Suc i # [Suc (Suc i)..<Suc n]", "by (simp add: upt_rec)"], ["proof (state)\nthis:\n  [Suc i..<Suc n] = Suc i # [Suc (Suc i)..<Suc n]\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i \\<Longrightarrow>\n    horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n", "unfolding id bi list.simps horner_composition.simps id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (c (Suc i) # map c [Suc (Suc i)..<Suc n])\n     (x (Suc i) # map x [Suc (Suc i)..<Suc n]) *\n    [:- x i, 1::'a:] +\n    [:c i:] =\n    b (Suc i) n * X i + [:c i:]", "unfolding IH[unfolded id2 list.simps]"], ["proof (prove)\ngoal (1 subgoal):\n 1. b (Suc i) n * [:- x i, 1::'a:] + [:c i:] = b (Suc i) n * X i + [:c i:]", "by (simp add: X_def)"], ["proof (state)\nthis:\n  horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  horner_composition (map c [i..<Suc n]) (map x [i..<Suc n]) = b i n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  horner_composition (map c [i..<Suc nn]) (map x [i..<Suc nn]) = b i nn\n\ngoal (1 subgoal):\n 1. local.newton_poly_impl = local.newton_poly nn", "thus ?thesis"], ["proof (prove)\nusing this:\n  horner_composition (map c [i..<Suc nn]) (map x [i..<Suc nn]) = b i nn\n\ngoal (1 subgoal):\n 1. local.newton_poly_impl = local.newton_poly nn", "unfolding newton_poly_impl_def newton_coefficients rev_rev_ident newton_poly_def i_def\n      assms[symmetric] xs"], ["proof (prove)\nusing this:\n  horner_composition (map c [0..<n]) xs = b 0 nn\n\ngoal (1 subgoal):\n 1. horner_composition (map c [0..<n]) xs = b 0 nn", "."], ["proof (state)\nthis:\n  local.newton_poly_impl = local.newton_poly nn\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context \n  fixes xs fs :: \"int list\"\nbegin"], ["", "fun divided_differences_impl_int :: \"int list \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int list \\<Rightarrow> int list option\" where\n  \"divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) = (\n     case divided_differences_impl_int x_j1s fj xj xis of None \\<Rightarrow> None\n   | Some x_js \\<Rightarrow> let (new,m) = divmod_int (hd x_js - xi_j1) (xj - xi)\n     in if m = 0 then Some (new # x_js) else None)\"\n| \"divided_differences_impl_int [] fj xj xis = Some [fj]\""], ["", "fun newton_coefficients_main_int :: \"int list \\<Rightarrow> int list \\<Rightarrow> int list list option\" where\n  \"newton_coefficients_main_int [fj] xjs = Some [[fj]]\"\n| \"newton_coefficients_main_int (fj # fjs) (xj # xjs) = (do {\n    rec \\<leftarrow> newton_coefficients_main_int fjs xjs;\n    let row = hd rec;\n    new_row \\<leftarrow> divided_differences_impl_int row fj xj xs;\n    Some (new_row # rec)})\"\n| \"newton_coefficients_main_int _ _ = Some []\""], ["", "definition newton_coefficients_int :: \"int list option\" where\n  \"newton_coefficients_int = map_option (map hd) (newton_coefficients_main_int (rev fs) (rev xs))\""], ["", "lemma divided_differences_impl_int_Some:\n  \"length gs \\<le> length ys \n  \\<Longrightarrow> divided_differences_impl_int gs g x ys = Some res\n  \\<Longrightarrow> divided_differences_impl (map rat_of_int gs) (rat_of_int g) (rat_of_int x) (map rat_of_int ys) = map rat_of_int res\n    \\<and> length res = Suc (length gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length gs \\<le> length ys;\n     divided_differences_impl_int gs g x ys = Some res\\<rbrakk>\n    \\<Longrightarrow> divided_differences_impl (map rat_of_int gs)\n                       (rat_of_int g) (rat_of_int x) (map rat_of_int ys) =\n                      map rat_of_int res \\<and>\n                      length res = Suc (length gs)", "proof (induct gs g x ys arbitrary: res rule: divided_differences_impl_int.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "case (1 xi_j1 x_j1s fj xj xi xis)"], ["proof (state)\nthis:\n  \\<lbrakk>length x_j1s \\<le> length xis;\n   divided_differences_impl_int x_j1s fj xj xis = Some ?res\\<rbrakk>\n  \\<Longrightarrow> divided_differences_impl (map rat_of_int x_j1s)\n                     (rat_of_int fj) (rat_of_int xj) (map rat_of_int xis) =\n                    map rat_of_int ?res \\<and>\n                    length ?res = Suc (length x_j1s)\n  length (xi_j1 # x_j1s) \\<le> length (xi # xis)\n  divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) = Some res\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "note some = 1(3)"], ["proof (state)\nthis:\n  divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) = Some res\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "from 1(2)"], ["proof (chain)\npicking this:\n  length (xi_j1 # x_j1s) \\<le> length (xi # xis)", "have len: \"length x_j1s \\<le> length xis\""], ["proof (prove)\nusing this:\n  length (xi_j1 # x_j1s) \\<le> length (xi # xis)\n\ngoal (1 subgoal):\n 1. length x_j1s \\<le> length xis", "by auto"], ["proof (state)\nthis:\n  length x_j1s \\<le> length xis\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "from some"], ["proof (chain)\npicking this:\n  divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) = Some res", "obtain x_js where rec: \"divided_differences_impl_int x_j1s fj xj xis = Some x_js\""], ["proof (prove)\nusing this:\n  divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) = Some res\n\ngoal (1 subgoal):\n 1. (\\<And>x_js.\n        divided_differences_impl_int x_j1s fj xj xis =\n        Some x_js \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  divided_differences_impl_int x_j1s fj xj xis = Some x_js\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "note IH = 1(1)[OF len rec]"], ["proof (state)\nthis:\n  divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int xis) =\n  map rat_of_int x_js \\<and>\n  length x_js = Suc (length x_j1s)\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "have id: \"hd (map rat_of_int x_js) = rat_of_int (hd x_js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (map rat_of_int x_js) = rat_of_int (hd x_js)", "using IH"], ["proof (prove)\nusing this:\n  divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int xis) =\n  map rat_of_int x_js \\<and>\n  length x_js = Suc (length x_j1s)\n\ngoal (1 subgoal):\n 1. hd (map rat_of_int x_js) = rat_of_int (hd x_js)", "by (cases x_js, auto)"], ["proof (state)\nthis:\n  hd (map rat_of_int x_js) = rat_of_int (hd x_js)\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "from some[simplified, unfolded rec divmod_int_def]"], ["proof (chain)\npicking this:\n  (case Some x_js of None \\<Rightarrow> None\n   | Some x_js \\<Rightarrow>\n       let (new, m) =\n             ((hd x_js - xi_j1) div (xj - xi),\n              (hd x_js - xi_j1) mod (xj - xi))\n       in if m = 0 then Some (new # x_js) else None) =\n  Some res", "have mod: \"(hd x_js - xi_j1) mod (xj - xi) = 0\"\n    and res: \"res = (hd x_js - xi_j1) div (xj - xi) # x_js\""], ["proof (prove)\nusing this:\n  (case Some x_js of None \\<Rightarrow> None\n   | Some x_js \\<Rightarrow>\n       let (new, m) =\n             ((hd x_js - xi_j1) div (xj - xi),\n              (hd x_js - xi_j1) mod (xj - xi))\n       in if m = 0 then Some (new # x_js) else None) =\n  Some res\n\ngoal (1 subgoal):\n 1. (hd x_js - xi_j1) mod (xj - xi) = 0 &&&\n    res = (hd x_js - xi_j1) div (xj - xi) # x_js", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (hd x_js - xi_j1) mod (xj - xi) = 0\n  res = (hd x_js - xi_j1) div (xj - xi) # x_js\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "have \"rat_of_int ((hd x_js - xi_j1) div (xj - xi)) = rat_of_int (hd x_js - xi_j1) / rat_of_int (xj - xi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int ((hd x_js - xi_j1) div (xj - xi)) =\n    rat_of_int (hd x_js - xi_j1) / rat_of_int (xj - xi)", "using mod"], ["proof (prove)\nusing this:\n  (hd x_js - xi_j1) mod (xj - xi) = 0\n\ngoal (1 subgoal):\n 1. rat_of_int ((hd x_js - xi_j1) div (xj - xi)) =\n    rat_of_int (hd x_js - xi_j1) / rat_of_int (xj - xi)", "by force"], ["proof (state)\nthis:\n  rat_of_int ((hd x_js - xi_j1) div (xj - xi)) =\n  rat_of_int (hd x_js - xi_j1) / rat_of_int (xj - xi)\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "hence \"(rat_of_int (hd x_js) - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) = \n    rat_of_int ((hd x_js - xi_j1) div (xj - xi))\""], ["proof (prove)\nusing this:\n  rat_of_int ((hd x_js - xi_j1) div (xj - xi)) =\n  rat_of_int (hd x_js - xi_j1) / rat_of_int (xj - xi)\n\ngoal (1 subgoal):\n 1. (rat_of_int (hd x_js) - rat_of_int xi_j1) /\n    (rat_of_int xj - rat_of_int xi) =\n    rat_of_int ((hd x_js - xi_j1) div (xj - xi))", "by simp"], ["proof (state)\nthis:\n  (rat_of_int (hd x_js) - rat_of_int xi_j1) /\n  (rat_of_int xj - rat_of_int xi) =\n  rat_of_int ((hd x_js - xi_j1) div (xj - xi))\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length x_j1s \\<le> length xis;\n                    divided_differences_impl_int x_j1s fj xj xis =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> divided_differences_impl\n(map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n(map rat_of_int xis) =\n                                     map rat_of_int res \\<and>\n                                     length res = Suc (length x_j1s);\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl\n                          (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n                          (rat_of_int xj) (map rat_of_int (xi # xis)) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (xi_j1 # x_j1s))\n 2. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 3. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "thus ?case"], ["proof (prove)\nusing this:\n  (rat_of_int (hd x_js) - rat_of_int xi_j1) /\n  (rat_of_int xj - rat_of_int xi) =\n  rat_of_int ((hd x_js - xi_j1) div (xj - xi))\n\ngoal (1 subgoal):\n 1. divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n     (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)) =\n    map rat_of_int res \\<and>\n    length res = Suc (length (xi_j1 # x_j1s))", "by (simp add: IH Let_def res id)"], ["proof (state)\nthis:\n  divided_differences_impl (map rat_of_int (xi_j1 # x_j1s)) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int (xi # xis)) =\n  map rat_of_int res \\<and>\n  length res = Suc (length (xi_j1 # x_j1s))\n\ngoal (2 subgoals):\n 1. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 2. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 2. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "case (2 fj xj xis res)"], ["proof (state)\nthis:\n  length [] \\<le> length xis\n  divided_differences_impl_int [] fj xj xis = Some res\n\ngoal (2 subgoals):\n 1. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 2. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "hence res: \"res = [fj]\""], ["proof (prove)\nusing this:\n  length [] \\<le> length xis\n  divided_differences_impl_int [] fj xj xis = Some res\n\ngoal (1 subgoal):\n 1. res = [fj]", "by simp"], ["proof (state)\nthis:\n  res = [fj]\n\ngoal (2 subgoals):\n 1. \\<And>fj xj xis res.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int [])\n                          (rat_of_int fj) (rat_of_int xj)\n                          (map rat_of_int xis) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length [])\n 2. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "thus ?case"], ["proof (prove)\nusing this:\n  res = [fj]\n\ngoal (1 subgoal):\n 1. divided_differences_impl (map rat_of_int []) (rat_of_int fj)\n     (rat_of_int xj) (map rat_of_int xis) =\n    map rat_of_int res \\<and>\n    length res = Suc (length [])", "by simp"], ["proof (state)\nthis:\n  divided_differences_impl (map rat_of_int []) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int xis) =\n  map rat_of_int res \\<and>\n  length res = Suc (length [])\n\ngoal (1 subgoal):\n 1. \\<And>v va b c res.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = Some res\\<rbrakk>\n       \\<Longrightarrow> divided_differences_impl (map rat_of_int (v # va))\n                          (rat_of_int b) (rat_of_int c)\n                          (map rat_of_int []) =\n                         map rat_of_int res \\<and>\n                         length res = Suc (length (v # va))", "qed simp"], ["", "lemma div_Ints_mod_0: assumes \"rat_of_int a / rat_of_int b \\<in> \\<int>\" \"b \\<noteq> 0\"\n  shows \"a mod b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod b = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a mod b = 0", "define c where \"c = int_of_rat (rat_of_int a / rat_of_int b)\""], ["proof (state)\nthis:\n  c = int_of_rat (rat_of_int a / rat_of_int b)\n\ngoal (1 subgoal):\n 1. a mod b = 0", "have \"rat_of_int a / rat_of_int b = rat_of_int c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int a / rat_of_int b = rat_of_int c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int a / rat_of_int b =\n    rat_of_int (int_of_rat (rat_of_int a / rat_of_int b))", "using assms(1)"], ["proof (prove)\nusing this:\n  rat_of_int a / rat_of_int b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int a / rat_of_int b =\n    rat_of_int (int_of_rat (rat_of_int a / rat_of_int b))", "by simp"], ["proof (state)\nthis:\n  rat_of_int a / rat_of_int b = rat_of_int c\n\ngoal (1 subgoal):\n 1. a mod b = 0", "hence \"rat_of_int a = rat_of_int b * rat_of_int c\""], ["proof (prove)\nusing this:\n  rat_of_int a / rat_of_int b = rat_of_int c\n\ngoal (1 subgoal):\n 1. rat_of_int a = rat_of_int b * rat_of_int c", "using assms(2)"], ["proof (prove)\nusing this:\n  rat_of_int a / rat_of_int b = rat_of_int c\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int a = rat_of_int b * rat_of_int c", "by (metis divide_cancel_right nonzero_mult_div_cancel_left of_int_eq_0_iff)"], ["proof (state)\nthis:\n  rat_of_int a = rat_of_int b * rat_of_int c\n\ngoal (1 subgoal):\n 1. a mod b = 0", "hence a: \"a = b * c\""], ["proof (prove)\nusing this:\n  rat_of_int a = rat_of_int b * rat_of_int c\n\ngoal (1 subgoal):\n 1. a = b * c", "by (simp add: of_int_hom.injectivity)"], ["proof (state)\nthis:\n  a = b * c\n\ngoal (1 subgoal):\n 1. a mod b = 0", "show \"a mod b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod b = 0", "unfolding a"], ["proof (prove)\ngoal (1 subgoal):\n 1. b * c mod b = 0", "by simp"], ["proof (state)\nthis:\n  a mod b = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma divided_differences_impl_int_None:\n  \"length gs \\<le> length ys \n  \\<Longrightarrow> divided_differences_impl_int gs g x ys = None\n  \\<Longrightarrow> x \\<notin> set (take (length gs) ys)\n  \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int gs) (rat_of_int g) (rat_of_int x) (map rat_of_int ys)) \\<notin> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length gs \\<le> length ys;\n     divided_differences_impl_int gs g x ys = None;\n     x \\<notin> set (take (length gs) ys)\\<rbrakk>\n    \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int gs)\n                           (rat_of_int g) (rat_of_int x)\n                           (map rat_of_int ys))\n                      \\<notin> \\<int>", "proof (induct gs g x ys rule: divided_differences_impl_int.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis.\n       \\<lbrakk>\\<lbrakk>length x_j1s \\<le> length xis;\n                 divided_differences_impl_int x_j1s fj xj xis = None;\n                 xj \\<notin> set (take (length x_j1s) xis)\\<rbrakk>\n                \\<Longrightarrow> hd (divided_differences_impl\n (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n (map rat_of_int xis))\n                                  \\<notin> \\<int>;\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        None;\n        xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (xi_j1 # x_j1s))\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int (xi # xis)))\n                         \\<notin> \\<int>\n 2. \\<And>fj xj xis.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = None;\n        xj \\<notin> set (take (length []) xis)\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int [])\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int xis))\n                         \\<notin> \\<int>\n 3. \\<And>v va b c.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = None;\n        c \\<notin> set (take (length (v # va)) [])\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (v # va)) (rat_of_int b)\n                              (rat_of_int c) (map rat_of_int []))\n                         \\<notin> \\<int>", "case (1 xi_j1 x_j1s fj xj xi xis)"], ["proof (state)\nthis:\n  \\<lbrakk>length x_j1s \\<le> length xis;\n   divided_differences_impl_int x_j1s fj xj xis = None;\n   xj \\<notin> set (take (length x_j1s) xis)\\<rbrakk>\n  \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int x_j1s)\n                         (rat_of_int fj) (rat_of_int xj)\n                         (map rat_of_int xis))\n                    \\<notin> \\<int>\n  length (xi_j1 # x_j1s) \\<le> length (xi # xis)\n  divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) = None\n  xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis.\n       \\<lbrakk>\\<lbrakk>length x_j1s \\<le> length xis;\n                 divided_differences_impl_int x_j1s fj xj xis = None;\n                 xj \\<notin> set (take (length x_j1s) xis)\\<rbrakk>\n                \\<Longrightarrow> hd (divided_differences_impl\n (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n (map rat_of_int xis))\n                                  \\<notin> \\<int>;\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        None;\n        xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (xi_j1 # x_j1s))\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int (xi # xis)))\n                         \\<notin> \\<int>\n 2. \\<And>fj xj xis.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = None;\n        xj \\<notin> set (take (length []) xis)\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int [])\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int xis))\n                         \\<notin> \\<int>\n 3. \\<And>v va b c.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = None;\n        c \\<notin> set (take (length (v # va)) [])\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (v # va)) (rat_of_int b)\n                              (rat_of_int c) (map rat_of_int []))\n                         \\<notin> \\<int>", "note none = 1(3)"], ["proof (state)\nthis:\n  divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) = None\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis.\n       \\<lbrakk>\\<lbrakk>length x_j1s \\<le> length xis;\n                 divided_differences_impl_int x_j1s fj xj xis = None;\n                 xj \\<notin> set (take (length x_j1s) xis)\\<rbrakk>\n                \\<Longrightarrow> hd (divided_differences_impl\n (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n (map rat_of_int xis))\n                                  \\<notin> \\<int>;\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        None;\n        xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (xi_j1 # x_j1s))\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int (xi # xis)))\n                         \\<notin> \\<int>\n 2. \\<And>fj xj xis.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = None;\n        xj \\<notin> set (take (length []) xis)\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int [])\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int xis))\n                         \\<notin> \\<int>\n 3. \\<And>v va b c.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = None;\n        c \\<notin> set (take (length (v # va)) [])\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (v # va)) (rat_of_int b)\n                              (rat_of_int c) (map rat_of_int []))\n                         \\<notin> \\<int>", "from 1(2,4)"], ["proof (chain)\npicking this:\n  length (xi_j1 # x_j1s) \\<le> length (xi # xis)\n  xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))", "have len: \"length x_j1s \\<le> length xis\" and xj: \"xj \\<notin> set (take (length x_j1s) xis)\" and xji: \"xj \\<noteq> xi\""], ["proof (prove)\nusing this:\n  length (xi_j1 # x_j1s) \\<le> length (xi # xis)\n  xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\n\ngoal (1 subgoal):\n 1. length x_j1s \\<le> length xis &&&\n    xj \\<notin> set (take (length x_j1s) xis) &&& xj \\<noteq> xi", "by auto"], ["proof (state)\nthis:\n  length x_j1s \\<le> length xis\n  xj \\<notin> set (take (length x_j1s) xis)\n  xj \\<noteq> xi\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis.\n       \\<lbrakk>\\<lbrakk>length x_j1s \\<le> length xis;\n                 divided_differences_impl_int x_j1s fj xj xis = None;\n                 xj \\<notin> set (take (length x_j1s) xis)\\<rbrakk>\n                \\<Longrightarrow> hd (divided_differences_impl\n (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n (map rat_of_int xis))\n                                  \\<notin> \\<int>;\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        None;\n        xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (xi_j1 # x_j1s))\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int (xi # xis)))\n                         \\<notin> \\<int>\n 2. \\<And>fj xj xis.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = None;\n        xj \\<notin> set (take (length []) xis)\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int [])\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int xis))\n                         \\<notin> \\<int>\n 3. \\<And>v va b c.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = None;\n        c \\<notin> set (take (length (v # va)) [])\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (v # va)) (rat_of_int b)\n                              (rat_of_int c) (map rat_of_int []))\n                         \\<notin> \\<int>", "define d where \"d = divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj) (map rat_of_int xis)\""], ["proof (state)\nthis:\n  d =\n  divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int xis)\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis.\n       \\<lbrakk>\\<lbrakk>length x_j1s \\<le> length xis;\n                 divided_differences_impl_int x_j1s fj xj xis = None;\n                 xj \\<notin> set (take (length x_j1s) xis)\\<rbrakk>\n                \\<Longrightarrow> hd (divided_differences_impl\n (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n (map rat_of_int xis))\n                                  \\<notin> \\<int>;\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        None;\n        xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (xi_j1 # x_j1s))\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int (xi # xis)))\n                         \\<notin> \\<int>\n 2. \\<And>fj xj xis.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = None;\n        xj \\<notin> set (take (length []) xis)\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int [])\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int xis))\n                         \\<notin> \\<int>\n 3. \\<And>v va b c.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = None;\n        c \\<notin> set (take (length (v # va)) [])\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (v # va)) (rat_of_int b)\n                              (rat_of_int c) (map rat_of_int []))\n                         \\<notin> \\<int>", "note IH = 1(1)[OF len _ xj]"], ["proof (state)\nthis:\n  divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n  hd (divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n       (rat_of_int xj) (map rat_of_int xis))\n  \\<notin> \\<int>\n\ngoal (3 subgoals):\n 1. \\<And>xi_j1 x_j1s fj xj xi xis.\n       \\<lbrakk>\\<lbrakk>length x_j1s \\<le> length xis;\n                 divided_differences_impl_int x_j1s fj xj xis = None;\n                 xj \\<notin> set (take (length x_j1s) xis)\\<rbrakk>\n                \\<Longrightarrow> hd (divided_differences_impl\n (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj)\n (map rat_of_int xis))\n                                  \\<notin> \\<int>;\n        length (xi_j1 # x_j1s) \\<le> length (xi # xis);\n        divided_differences_impl_int (xi_j1 # x_j1s) fj xj (xi # xis) =\n        None;\n        xj \\<notin> set (take (length (xi_j1 # x_j1s)) (xi # xis))\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (xi_j1 # x_j1s))\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int (xi # xis)))\n                         \\<notin> \\<int>\n 2. \\<And>fj xj xis.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = None;\n        xj \\<notin> set (take (length []) xis)\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int [])\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int xis))\n                         \\<notin> \\<int>\n 3. \\<And>v va b c.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = None;\n        c \\<notin> set (take (length (v # va)) [])\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (v # va)) (rat_of_int b)\n                              (rat_of_int c) (map rat_of_int []))\n                         \\<notin> \\<int>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>", "proof (cases \"divided_differences_impl_int x_j1s fj xj xis\")"], ["proof (state)\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "case None"], ["proof (state)\nthis:\n  divided_differences_impl_int x_j1s fj xj xis = None\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "from IH[OF None]"], ["proof (chain)\npicking this:\n  hd (divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n       (rat_of_int xj) (map rat_of_int xis))\n  \\<notin> \\<int>", "have d: \"hd d \\<notin> \\<int>\""], ["proof (prove)\nusing this:\n  hd (divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n       (rat_of_int xj) (map rat_of_int xis))\n  \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. hd d \\<notin> \\<int>", "unfolding d_def"], ["proof (prove)\nusing this:\n  hd (divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n       (rat_of_int xj) (map rat_of_int xis))\n  \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. hd (divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n         (rat_of_int xj) (map rat_of_int xis))\n    \\<notin> \\<int>", "by auto"], ["proof (state)\nthis:\n  hd d \\<notin> \\<int>\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "{"], ["proof (state)\nthis:\n  hd d \\<notin> \\<int>\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "let ?x = \"(hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\""], ["proof (state)\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "assume \"?x \\<in> \\<int>\""], ["proof (state)\nthis:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "hence \"?x * (of_int (xj - xi)) + rat_of_int xi_j1 \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n    rat_of_int (xj - xi) +\n    rat_of_int xi_j1\n    \\<in> \\<int>", "using Ints_mult Ints_add Ints_of_int"], ["proof (prove)\nusing this:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) \\<in> \\<int>\n  \\<lbrakk>?a \\<in> \\<int>; ?b \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b \\<in> \\<int>\n  \\<lbrakk>?a \\<in> \\<int>; ?b \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> ?a + ?b \\<in> \\<int>\n  of_int ?z \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n    rat_of_int (xj - xi) +\n    rat_of_int xi_j1\n    \\<in> \\<int>", "by blast"], ["proof (state)\nthis:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n  rat_of_int (xj - xi) +\n  rat_of_int xi_j1\n  \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "also"], ["proof (state)\nthis:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n  rat_of_int (xj - xi) +\n  rat_of_int xi_j1\n  \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "have \"?x * (of_int (xj - xi)) = hd d - rat_of_int xi_j1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n    rat_of_int (xj - xi) =\n    hd d - rat_of_int xi_j1", "using xji"], ["proof (prove)\nusing this:\n  xj \\<noteq> xi\n\ngoal (1 subgoal):\n 1. (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n    rat_of_int (xj - xi) =\n    hd d - rat_of_int xi_j1", "by auto"], ["proof (state)\nthis:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n  rat_of_int (xj - xi) =\n  hd d - rat_of_int xi_j1\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "also"], ["proof (state)\nthis:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) *\n  rat_of_int (xj - xi) =\n  hd d - rat_of_int xi_j1\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "have \"\\<dots> + rat_of_int xi_j1 = hd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd d - rat_of_int xi_j1 + rat_of_int xi_j1 = hd d", "by simp"], ["proof (state)\nthis:\n  hd d - rat_of_int xi_j1 + rat_of_int xi_j1 = hd d\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "finally"], ["proof (chain)\npicking this:\n  hd d \\<in> \\<int>", "have False"], ["proof (prove)\nusing this:\n  hd d \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. False", "using d"], ["proof (prove)\nusing this:\n  hd d \\<in> \\<int>\n  hd d \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "}"], ["proof (state)\nthis:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\n  \\<in> \\<int> \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. divided_differences_impl_int x_j1s fj xj xis = None \\<Longrightarrow>\n    hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>\n 2. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (hd d - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\n  \\<in> \\<int> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>", "by (auto simp: Let_def d_def[symmetric])"], ["proof (state)\nthis:\n  hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n       (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n  \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "case (Some res)"], ["proof (state)\nthis:\n  divided_differences_impl_int x_j1s fj xj xis = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "from divided_differences_impl_int_Some[OF len Some]"], ["proof (chain)\npicking this:\n  divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int xis) =\n  map rat_of_int res \\<and>\n  length res = Suc (length x_j1s)", "have id: \"divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj) (rat_of_int xj) (map rat_of_int xis) =\n      map rat_of_int res\" and res: \"res \\<noteq> []\""], ["proof (prove)\nusing this:\n  divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int xis) =\n  map rat_of_int res \\<and>\n  length res = Suc (length x_j1s)\n\ngoal (1 subgoal):\n 1. divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n     (rat_of_int xj) (map rat_of_int xis) =\n    map rat_of_int res &&&\n    res \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  divided_differences_impl (map rat_of_int x_j1s) (rat_of_int fj)\n   (rat_of_int xj) (map rat_of_int xis) =\n  map rat_of_int res\n  res \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "have hd: \"hd (map rat_of_int res) = of_int (hd res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (map rat_of_int res) = rat_of_int (hd res)", "using res"], ["proof (prove)\nusing this:\n  res \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (map rat_of_int res) = rat_of_int (hd res)", "by (cases res, auto)"], ["proof (state)\nthis:\n  hd (map rat_of_int res) = rat_of_int (hd res)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "define a where \"a = (hd res - xi_j1)\""], ["proof (state)\nthis:\n  a = hd res - xi_j1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "define b where \"b = xj - xi\""], ["proof (state)\nthis:\n  b = xj - xi\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "from none[simplified, unfolded Some divmod_int_def]"], ["proof (chain)\npicking this:\n  (case Some res of None \\<Rightarrow> None\n   | Some x_js \\<Rightarrow>\n       let (new, m) =\n             ((hd x_js - xi_j1) div (xj - xi),\n              (hd x_js - xi_j1) mod (xj - xi))\n       in if m = 0 then Some (new # x_js) else None) =\n  None", "have mod: \"a mod b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (case Some res of None \\<Rightarrow> None\n   | Some x_js \\<Rightarrow>\n       let (new, m) =\n             ((hd x_js - xi_j1) div (xj - xi),\n              (hd x_js - xi_j1) mod (xj - xi))\n       in if m = 0 then Some (new # x_js) else None) =\n  None\n\ngoal (1 subgoal):\n 1. a mod b \\<noteq> 0", "by (auto split: if_splits simp: a_def b_def)"], ["proof (state)\nthis:\n  a mod b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "{"], ["proof (state)\nthis:\n  a mod b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "assume \"(rat_of_int (hd res) - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi) \\<in> \\<int>\""], ["proof (state)\nthis:\n  (rat_of_int (hd res) - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "hence \"rat_of_int a / rat_of_int b \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  (rat_of_int (hd res) - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int a / rat_of_int b \\<in> \\<int>", "unfolding a_def b_def"], ["proof (prove)\nusing this:\n  (rat_of_int (hd res) - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (hd res - xi_j1) / rat_of_int (xj - xi) \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  rat_of_int a / rat_of_int b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "moreover"], ["proof (state)\nthis:\n  rat_of_int a / rat_of_int b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "have \"b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "using xji"], ["proof (prove)\nusing this:\n  xj \\<noteq> xi\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "unfolding b_def"], ["proof (prove)\nusing this:\n  xj \\<noteq> xi\n\ngoal (1 subgoal):\n 1. xj - xi \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "ultimately"], ["proof (chain)\npicking this:\n  rat_of_int a / rat_of_int b \\<in> \\<int>\n  b \\<noteq> 0", "have False"], ["proof (prove)\nusing this:\n  rat_of_int a / rat_of_int b \\<in> \\<int>\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using mod div_Ints_mod_0"], ["proof (prove)\nusing this:\n  rat_of_int a / rat_of_int b \\<in> \\<int>\n  b \\<noteq> 0\n  a mod b \\<noteq> 0\n  \\<lbrakk>rat_of_int ?a / rat_of_int ?b \\<in> \\<int>;\n   ?b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?a mod ?b = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "}"], ["proof (state)\nthis:\n  (rat_of_int (hd res) - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\n  \\<in> \\<int> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       divided_differences_impl_int x_j1s fj xj xis =\n       Some a \\<Longrightarrow>\n       hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n            (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n       \\<notin> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (rat_of_int (hd res) - rat_of_int xi_j1) / (rat_of_int xj - rat_of_int xi)\n  \\<in> \\<int> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n         (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n    \\<notin> \\<int>", "by (auto simp: id Let_def hd)"], ["proof (state)\nthis:\n  hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n       (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n  \\<notin> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (divided_differences_impl (map rat_of_int (xi_j1 # x_j1s))\n       (rat_of_int fj) (rat_of_int xj) (map rat_of_int (xi # xis)))\n  \\<notin> \\<int>\n\ngoal (2 subgoals):\n 1. \\<And>fj xj xis.\n       \\<lbrakk>length [] \\<le> length xis;\n        divided_differences_impl_int [] fj xj xis = None;\n        xj \\<notin> set (take (length []) xis)\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl (map rat_of_int [])\n                              (rat_of_int fj) (rat_of_int xj)\n                              (map rat_of_int xis))\n                         \\<notin> \\<int>\n 2. \\<And>v va b c.\n       \\<lbrakk>length (v # va) \\<le> length [];\n        divided_differences_impl_int (v # va) b c [] = None;\n        c \\<notin> set (take (length (v # va)) [])\\<rbrakk>\n       \\<Longrightarrow> hd (divided_differences_impl\n                              (map rat_of_int (v # va)) (rat_of_int b)\n                              (rat_of_int c) (map rat_of_int []))\n                         \\<notin> \\<int>", "qed auto"], ["", "lemma newton_coefficients_main_int_Some:\n  \"length gs = length ys \\<Longrightarrow> length ys \\<le> length xs  \n  \\<Longrightarrow> newton_coefficients_main_int gs ys = Some res\n  \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs) (map rat_of_int gs) (map rat_of_int ys) = map (map rat_of_int) res\n    \\<and> (\\<forall> x \\<in> set res. x \\<noteq> [] \\<and> length x \\<le> length ys) \\<and> length res = length gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length gs = length ys; length ys \\<le> length xs;\n     local.newton_coefficients_main_int gs ys = Some res\\<rbrakk>\n    \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                       (map rat_of_int gs) (map rat_of_int ys) =\n                      map (map rat_of_int) res \\<and>\n                      (\\<forall>x\\<in>set res.\n                          x \\<noteq> [] \\<and>\n                          length x \\<le> length ys) \\<and>\n                      length res = length gs", "proof (induct gs ys arbitrary: res rule: newton_coefficients_main_int.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "case (2 fv v va xj xjs res)"], ["proof (state)\nthis:\n  \\<lbrakk>length (v # va) = length xjs; length xjs \\<le> length xs;\n   local.newton_coefficients_main_int (v # va) xjs = Some ?res\\<rbrakk>\n  \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                     (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                    map (map rat_of_int) ?res \\<and>\n                    (\\<forall>x\\<in>set ?res.\n                        x \\<noteq> [] \\<and>\n                        length x \\<le> length xjs) \\<and>\n                    length ?res = length (v # va)\n  length (fv # v # va) = length (xj # xjs)\n  length (xj # xjs) \\<le> length xs\n  local.newton_coefficients_main_int (fv # v # va) (xj # xjs) = Some res\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "from 2(2,3)"], ["proof (chain)\npicking this:\n  length (fv # v # va) = length (xj # xjs)\n  length (xj # xjs) \\<le> length xs", "have len: \"length (v # va) = length xjs\" \"length xjs \\<le> length xs\""], ["proof (prove)\nusing this:\n  length (fv # v # va) = length (xj # xjs)\n  length (xj # xjs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. length (v # va) = length xjs &&& length xjs \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  length (v # va) = length xjs\n  length xjs \\<le> length xs\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "note some = 2(4)"], ["proof (state)\nthis:\n  local.newton_coefficients_main_int (fv # v # va) (xj # xjs) = Some res\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "let ?n = \"newton_coefficients_main_int (v # va) xjs\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "let ?ri = rat_of_int"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "let ?mri = \"map ?ri\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "from some"], ["proof (chain)\npicking this:\n  local.newton_coefficients_main_int (fv # v # va) (xj # xjs) = Some res", "obtain rec where n: \"?n = Some rec\""], ["proof (prove)\nusing this:\n  local.newton_coefficients_main_int (fv # v # va) (xj # xjs) = Some res\n\ngoal (1 subgoal):\n 1. (\\<And>rec.\n        local.newton_coefficients_main_int (v # va) xjs =\n        Some rec \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?n, auto)"], ["proof (state)\nthis:\n  local.newton_coefficients_main_int (v # va) xjs = Some rec\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "note some = some[simplified, unfolded n]"], ["proof (state)\nthis:\n  Some rec \\<bind>\n  (\\<lambda>rec.\n      divided_differences_impl_int (hd rec) fv xj xs \\<bind>\n      (\\<lambda>new_row. Some (new_row # rec))) =\n  Some res\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "let ?d = \"divided_differences_impl_int (hd rec) fv xj xs\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "from some"], ["proof (chain)\npicking this:\n  Some rec \\<bind>\n  (\\<lambda>rec.\n      divided_differences_impl_int (hd rec) fv xj xs \\<bind>\n      (\\<lambda>new_row. Some (new_row # rec))) =\n  Some res", "obtain dd where d: \"?d = Some dd\" and res: \"res = dd # rec\""], ["proof (prove)\nusing this:\n  Some rec \\<bind>\n  (\\<lambda>rec.\n      divided_differences_impl_int (hd rec) fv xj xs \\<bind>\n      (\\<lambda>new_row. Some (new_row # rec))) =\n  Some res\n\ngoal (1 subgoal):\n 1. (\\<And>dd.\n        \\<lbrakk>divided_differences_impl_int (hd rec) fv xj xs = Some dd;\n         res = dd # rec\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ?d, auto)"], ["proof (state)\nthis:\n  divided_differences_impl_int (hd rec) fv xj xs = Some dd\n  res = dd # rec\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "note IH = 2(1)[OF len n]"], ["proof (state)\nthis:\n  newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n   (map rat_of_int xjs) =\n  map (map rat_of_int) rec \\<and>\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "from IH"], ["proof (chain)\npicking this:\n  newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n   (map rat_of_int xjs) =\n  map (map rat_of_int) rec \\<and>\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)", "have lenn: \"length (hd rec) \\<le> length xjs\""], ["proof (prove)\nusing this:\n  newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n   (map rat_of_int xjs) =\n  map (map rat_of_int) rec \\<and>\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n\ngoal (1 subgoal):\n 1. length (hd rec) \\<le> length xjs", "by (cases rec, auto)"], ["proof (state)\nthis:\n  length (hd rec) \\<le> length xjs\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "with len"], ["proof (chain)\npicking this:\n  length (v # va) = length xjs\n  length xjs \\<le> length xs\n  length (hd rec) \\<le> length xjs", "have \"length (hd rec) \\<le> length xs\""], ["proof (prove)\nusing this:\n  length (v # va) = length xjs\n  length xjs \\<le> length xs\n  length (hd rec) \\<le> length xjs\n\ngoal (1 subgoal):\n 1. length (hd rec) \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  length (hd rec) \\<le> length xs\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "note dd = divided_differences_impl_int_Some[OF this d]"], ["proof (state)\nthis:\n  divided_differences_impl (map rat_of_int (hd rec)) (rat_of_int fv)\n   (rat_of_int xj) (map rat_of_int xs) =\n  map rat_of_int dd \\<and>\n  length dd = Suc (length (hd rec))\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "have hd: \"hd (map ?mri rec) = ?mri (hd rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (map (map rat_of_int) rec) = map rat_of_int (hd rec)", "using IH"], ["proof (prove)\nusing this:\n  newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n   (map rat_of_int xjs) =\n  map (map rat_of_int) rec \\<and>\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n\ngoal (1 subgoal):\n 1. hd (map (map rat_of_int) rec) = map rat_of_int (hd rec)", "by (cases rec, auto)"], ["proof (state)\nthis:\n  hd (map (map rat_of_int) rec) = map rat_of_int (hd rec)\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>fj v va xj xjs res.\n       \\<lbrakk>\\<And>res.\n                   \\<lbrakk>length (v # va) = length xjs;\n                    length xjs \\<le> length xs;\n                    local.newton_coefficients_main_int (v # va) xjs =\n                    Some res\\<rbrakk>\n                   \\<Longrightarrow> newton_coefficients_main\n(map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs) =\n                                     map (map rat_of_int) res \\<and>\n                                     (\\<forall>x\\<in>set res.\n   x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n                                     length res = length (v # va);\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (fj # v # va))\n                          (map rat_of_int (xj # xjs)) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length (xj # xjs)) \\<and>\n                         length res = length (fj # v # va)\n 3. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 4. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main (map rat_of_int xs)\n     (map rat_of_int (fv # v # va)) (map rat_of_int (xj # xjs)) =\n    map (map rat_of_int) res \\<and>\n    (\\<forall>x\\<in>set res.\n        x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)) \\<and>\n    length res = length (fv # v # va)", "unfolding newton_coefficients_main.simps list.simps\n    IH[THEN conjunct1, unfolded list.simps] Let_def hd\n    dd[THEN conjunct1] res"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map rat_of_int dd = map rat_of_int dd \\<and>\n     map (map rat_of_int) rec = map (map rat_of_int) rec) \\<and>\n    (\\<forall>x\\<in>insert dd (set rec).\n        x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)) \\<and>\n    length (dd # rec) = length (fv # v # va)", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. map rat_of_int dd = map rat_of_int dd\n 2. map (map rat_of_int) rec = map (map rat_of_int) rec\n 3. \\<forall>x\\<in>insert dd (set rec).\n       x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)\n 4. length (dd # rec) = length (fv # v # va)", "show \"length (dd # rec) = length (fv # v # va)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dd # rec) = length (fv # v # va)", "using len\n      IH[THEN conjunct2] dd[THEN conjunct2]"], ["proof (prove)\nusing this:\n  length (v # va) = length xjs\n  length xjs \\<le> length xs\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n  length dd = Suc (length (hd rec))\n\ngoal (1 subgoal):\n 1. length (dd # rec) = length (fv # v # va)", "by auto"], ["proof (state)\nthis:\n  length (dd # rec) = length (fv # v # va)\n\ngoal (3 subgoals):\n 1. map rat_of_int dd = map rat_of_int dd\n 2. map (map rat_of_int) rec = map (map rat_of_int) rec\n 3. \\<forall>x\\<in>insert dd (set rec).\n       x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)", "show \"\\<forall>x\\<in>insert dd (set rec). x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>insert dd (set rec).\n       x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)", "using len IH[THEN conjunct2] dd[THEN conjunct2] lenn"], ["proof (prove)\nusing this:\n  length (v # va) = length xjs\n  length xjs \\<le> length xs\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n  length dd = Suc (length (hd rec))\n  length (hd rec) \\<le> length xjs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>insert dd (set rec).\n       x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>insert dd (set rec).\n     x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)\n\ngoal (2 subgoals):\n 1. map rat_of_int dd = map rat_of_int dd\n 2. map (map rat_of_int) rec = map (map rat_of_int) rec", "qed auto"], ["proof (state)\nthis:\n  newton_coefficients_main (map rat_of_int xs)\n   (map rat_of_int (fv # v # va)) (map rat_of_int (xj # xjs)) =\n  map (map rat_of_int) res \\<and>\n  (\\<forall>x\\<in>set res.\n      x \\<noteq> [] \\<and> length x \\<le> length (xj # xjs)) \\<and>\n  length res = length (fv # v # va)\n\ngoal (3 subgoals):\n 1. \\<And>fj xjs res.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int [fj]) (map rat_of_int xjs) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length xjs) \\<and>\n                         length res = length [fj]\n 2. \\<And>uv_ res.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int []) (map rat_of_int uv_) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length uv_) \\<and>\n                         length res = length []\n 3. \\<And>v vb vc res.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> newton_coefficients_main (map rat_of_int xs)\n                          (map rat_of_int (v # vb # vc))\n                          (map rat_of_int []) =\n                         map (map rat_of_int) res \\<and>\n                         (\\<forall>x\\<in>set res.\n                             x \\<noteq> [] \\<and>\n                             length x \\<le> length []) \\<and>\n                         length res = length (v # vb # vc)", "qed auto"], ["", "lemma newton_coefficients_main_int_None: assumes dist: \"distinct xs\"\n  shows \"length gs = length ys \\<Longrightarrow> length ys \\<le> length xs  \n  \\<Longrightarrow> newton_coefficients_main_int gs ys = None\n  \\<Longrightarrow> ys = drop (length xs - length ys) (rev xs)\n  \\<Longrightarrow> \\<exists> row \\<in> set (newton_coefficients_main (map rat_of_int xs) (map rat_of_int gs) (map rat_of_int ys)). hd row \\<notin> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length gs = length ys; length ys \\<le> length xs;\n     local.newton_coefficients_main_int gs ys = None;\n     ys = drop (length xs - length ys) (rev xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>row\\<in>set\n  (newton_coefficients_main (map rat_of_int xs) (map rat_of_int gs)\n    (map rat_of_int ys)).\n                         hd row \\<notin> \\<int>", "proof (induct gs ys rule: newton_coefficients_main_int.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "case (2 fv v va xj xjs)"], ["proof (state)\nthis:\n  \\<lbrakk>length (v # va) = length xjs; length xjs \\<le> length xs;\n   local.newton_coefficients_main_int (v # va) xjs = None;\n   xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>row\\<in>set\n(newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n  (map rat_of_int xjs)).\n                       hd row \\<notin> \\<int>\n  length (fv # v # va) = length (xj # xjs)\n  length (xj # xjs) \\<le> length xs\n  local.newton_coefficients_main_int (fv # v # va) (xj # xjs) = None\n  xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "from 2(2,3)"], ["proof (chain)\npicking this:\n  length (fv # v # va) = length (xj # xjs)\n  length (xj # xjs) \\<le> length xs", "have len: \"length (v # va) = length xjs\" \"length xjs \\<le> length xs\""], ["proof (prove)\nusing this:\n  length (fv # v # va) = length (xj # xjs)\n  length (xj # xjs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. length (v # va) = length xjs &&& length xjs \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  length (v # va) = length xjs\n  length xjs \\<le> length xs\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "from arg_cong[OF 2(5), of tl] 2(3)"], ["proof (chain)\npicking this:\n  tl (xj # xjs) = tl (drop (length xs - length (xj # xjs)) (rev xs))\n  length (xj # xjs) \\<le> length xs", "have xjs: \"xjs = drop (length xs - length xjs) (rev xs)\""], ["proof (prove)\nusing this:\n  tl (xj # xjs) = tl (drop (length xs - length (xj # xjs)) (rev xs))\n  length (xj # xjs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. xjs = drop (length xs - length xjs) (rev xs)", "by (metis 2(5) butlast_snoc butlast_take length_drop rev.simps(2) rev_drop rev_rev_ident rev_take)"], ["proof (state)\nthis:\n  xjs = drop (length xs - length xjs) (rev xs)\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "note none = 2(4)"], ["proof (state)\nthis:\n  local.newton_coefficients_main_int (fv # v # va) (xj # xjs) = None\n\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "let ?n = \"newton_coefficients_main_int (v # va) xjs\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "let ?n' = \"newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va)) (map rat_of_int xjs)\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "let ?ri = rat_of_int"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "let ?mri = \"map ?ri\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>fj v va xj xjs.\n       \\<lbrakk>\\<lbrakk>length (v # va) = length xjs;\n                 length xjs \\<le> length xs;\n                 local.newton_coefficients_main_int (v # va) xjs = None;\n                 xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>row\n     \\<in>set (newton_coefficients_main (map rat_of_int xs)\n                (map rat_of_int (v # va)) (map rat_of_int xjs)).\n                                     hd row \\<notin> \\<int>;\n        length (fj # v # va) = length (xj # xjs);\n        length (xj # xjs) \\<le> length xs;\n        local.newton_coefficients_main_int (fj # v # va) (xj # xjs) = None;\n        xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (fj # v # va)) (map rat_of_int (xj # xjs))).\n                            hd row \\<notin> \\<int>\n 3. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 4. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                           (map rat_of_int (fv # v # va))\n                           (map rat_of_int (xj # xjs))).\n       hd row \\<notin> \\<int>", "proof (cases ?n)"], ["proof (state)\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (v # va) xjs = None \\<Longrightarrow>\n    \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                           (map rat_of_int (fv # v # va))\n                           (map rat_of_int (xj # xjs))).\n       hd row \\<notin> \\<int>\n 2. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "case None"], ["proof (state)\nthis:\n  local.newton_coefficients_main_int (v # va) xjs = None\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (v # va) xjs = None \\<Longrightarrow>\n    \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                           (map rat_of_int (fv # v # va))\n                           (map rat_of_int (xj # xjs))).\n       hd row \\<notin> \\<int>\n 2. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "from 2(1)[OF len None xjs]"], ["proof (chain)\npicking this:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (v # va)) (map rat_of_int xjs)).\n     hd row \\<notin> \\<int>", "obtain row where \n      row: \"row\\<in>set ?n'\" and \"hd row \\<notin> \\<int>\""], ["proof (prove)\nusing this:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (v # va)) (map rat_of_int xjs)).\n     hd row \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>row.\n        \\<lbrakk>row\n                 \\<in> set (newton_coefficients_main (map rat_of_int xs)\n                             (map rat_of_int (v # va))\n                             (map rat_of_int xjs));\n         hd row \\<notin> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  row\n  \\<in> set (newton_coefficients_main (map rat_of_int xs)\n              (map rat_of_int (v # va)) (map rat_of_int xjs))\n  hd row \\<notin> \\<int>\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (v # va) xjs = None \\<Longrightarrow>\n    \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                           (map rat_of_int (fv # v # va))\n                           (map rat_of_int (xj # xjs))).\n       hd row \\<notin> \\<int>\n 2. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  row\n  \\<in> set (newton_coefficients_main (map rat_of_int xs)\n              (map rat_of_int (v # va)) (map rat_of_int xjs))\n  hd row \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                           (map rat_of_int (fv # v # va))\n                           (map rat_of_int (xj # xjs))).\n       hd row \\<notin> \\<int>", "by (intro bexI[of _ row], auto simp: Let_def)"], ["proof (state)\nthis:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (fv # v # va))\n                         (map rat_of_int (xj # xjs))).\n     hd row \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "case (Some rec)"], ["proof (state)\nthis:\n  local.newton_coefficients_main_int (v # va) xjs = Some rec\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "note some = newton_coefficients_main_int_Some[OF len this]"], ["proof (state)\nthis:\n  newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n   (map rat_of_int xjs) =\n  map (map rat_of_int) rec \\<and>\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "hence len': \"length (hd rec) \\<le> length xjs\""], ["proof (prove)\nusing this:\n  newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n   (map rat_of_int xjs) =\n  map (map rat_of_int) rec \\<and>\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n\ngoal (1 subgoal):\n 1. length (hd rec) \\<le> length xjs", "by (cases rec, auto)"], ["proof (state)\nthis:\n  length (hd rec) \\<le> length xjs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "hence lenn: \"length (hd rec) \\<le> length xs\""], ["proof (prove)\nusing this:\n  length (hd rec) \\<le> length xjs\n\ngoal (1 subgoal):\n 1. length (hd rec) \\<le> length xs", "using len"], ["proof (prove)\nusing this:\n  length (hd rec) \\<le> length xjs\n  length (v # va) = length xjs\n  length xjs \\<le> length xs\n\ngoal (1 subgoal):\n 1. length (hd rec) \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  length (hd rec) \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "have hd: \"hd (map ?mri rec) = ?mri (hd rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (map (map rat_of_int) rec) = map rat_of_int (hd rec)", "using some"], ["proof (prove)\nusing this:\n  newton_coefficients_main (map rat_of_int xs) (map rat_of_int (v # va))\n   (map rat_of_int xjs) =\n  map (map rat_of_int) rec \\<and>\n  (\\<forall>x\\<in>set rec.\n      x \\<noteq> [] \\<and> length x \\<le> length xjs) \\<and>\n  length rec = length (v # va)\n\ngoal (1 subgoal):\n 1. hd (map (map rat_of_int) rec) = map rat_of_int (hd rec)", "by (cases rec, auto)"], ["proof (state)\nthis:\n  hd (map (map rat_of_int) rec) = map rat_of_int (hd rec)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "let ?d = \"divided_differences_impl_int (hd rec) fv xj xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "from none[simplified, unfolded Some]"], ["proof (chain)\npicking this:\n  Some rec \\<bind>\n  (\\<lambda>rec.\n      divided_differences_impl_int (hd rec) fv xj xs \\<bind>\n      (\\<lambda>new_row. Some (new_row # rec))) =\n  None", "have none: \"?d = None\""], ["proof (prove)\nusing this:\n  Some rec \\<bind>\n  (\\<lambda>rec.\n      divided_differences_impl_int (hd rec) fv xj xs \\<bind>\n      (\\<lambda>new_row. Some (new_row # rec))) =\n  None\n\ngoal (1 subgoal):\n 1. divided_differences_impl_int (hd rec) fv xj xs = None", "by (cases ?d, auto)"], ["proof (state)\nthis:\n  divided_differences_impl_int (hd rec) fv xj xs = None\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "have \"xj \\<notin> set (take (length (hd rec)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xj \\<notin> set (take (length (hd rec)) xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "assume \"xj \\<in> set (take (length (hd rec)) xs)\""], ["proof (state)\nthis:\n  xj \\<in> set (take (length (hd rec)) xs)\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xj \\<in> set (take (length (hd rec)) xs)", "obtain i where \"i < length (hd rec)\" and xj: \"xj = xs ! i\""], ["proof (prove)\nusing this:\n  xj \\<in> set (take (length (hd rec)) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (hd rec); xj = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<exists>i<length (take (length (hd rec)) xs).\n     take (length (hd rec)) xs ! i = xj\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (hd rec); xj = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length (hd rec)\n  xj = xs ! i\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "with len'"], ["proof (chain)\npicking this:\n  length (hd rec) \\<le> length xjs\n  i < length (hd rec)\n  xj = xs ! i", "have i: \"i < length xjs\""], ["proof (prove)\nusing this:\n  length (hd rec) \\<le> length xjs\n  i < length (hd rec)\n  xj = xs ! i\n\ngoal (1 subgoal):\n 1. i < length xjs", "by simp"], ["proof (state)\nthis:\n  i < length xjs\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "have \"Suc (length xjs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length xjs) \\<le> length xs", "using 2(3)"], ["proof (prove)\nusing this:\n  length (xj # xjs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. Suc (length xjs) \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  Suc (length xjs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "with i"], ["proof (chain)\npicking this:\n  i < length xjs\n  Suc (length xjs) \\<le> length xs", "have i0: \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i < length xjs\n  Suc (length xjs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "by (metis 2(5) Suc_diff_Suc Suc_le_lessD diff_less dist distinct_conv_nth \n          hd_drop_conv_nth length_Cons length_drop length_greater_0_conv length_rev less_le_trans \n          list.sel(1) list.simps(3) nat_neq_iff rev_nth xj xjs)"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "have \"xj \\<in> set xjs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xj \\<in> set xjs", "by (subst xjs, unfold xj in_set_conv_nth, rule exI[of _ \"length xjs - Suc i\"], insert i 2(3) i0,\n           auto simp: rev_nth)"], ["proof (state)\nthis:\n  xj \\<in> set xjs\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "hence ndist: \"\\<not> distinct (xj # xjs)\""], ["proof (prove)\nusing this:\n  xj \\<in> set xjs\n\ngoal (1 subgoal):\n 1. \\<not> distinct (xj # xjs)", "by auto"], ["proof (state)\nthis:\n  \\<not> distinct (xj # xjs)\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "from dist"], ["proof (chain)\npicking this:\n  distinct xs", "have \"distinct (rev xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (rev xs)", "by simp"], ["proof (state)\nthis:\n  distinct (rev xs)\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "from distinct_drop[OF this]"], ["proof (chain)\npicking this:\n  distinct (drop ?i (rev xs))", "have \"distinct (xj # xjs)\""], ["proof (prove)\nusing this:\n  distinct (drop ?i (rev xs))\n\ngoal (1 subgoal):\n 1. distinct (xj # xjs)", "using 2(5)"], ["proof (prove)\nusing this:\n  distinct (drop ?i (rev xs))\n  xj # xjs = drop (length xs - length (xj # xjs)) (rev xs)\n\ngoal (1 subgoal):\n 1. distinct (xj # xjs)", "by metis"], ["proof (state)\nthis:\n  distinct (xj # xjs)\n\ngoal (1 subgoal):\n 1. xj \\<in> set (take (length (hd rec)) xs) \\<Longrightarrow> False", "with ndist"], ["proof (chain)\npicking this:\n  \\<not> distinct (xj # xjs)\n  distinct (xj # xjs)", "show False"], ["proof (prove)\nusing this:\n  \\<not> distinct (xj # xjs)\n  distinct (xj # xjs)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xj \\<notin> set (take (length (hd rec)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "note dd = divided_differences_impl_int_None[OF lenn none this]"], ["proof (state)\nthis:\n  hd (divided_differences_impl (map rat_of_int (hd rec)) (rat_of_int fv)\n       (rat_of_int xj) (map rat_of_int xs))\n  \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       local.newton_coefficients_main_int (v # va) xjs =\n       Some a \\<Longrightarrow>\n       \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                              (map rat_of_int (fv # v # va))\n                              (map rat_of_int (xj # xjs))).\n          hd row \\<notin> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                           (map rat_of_int (fv # v # va))\n                           (map rat_of_int (xj # xjs))).\n       hd row \\<notin> \\<int>", "by (rule bexI, rule dd, insert some hd, auto)"], ["proof (state)\nthis:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (fv # v # va))\n                         (map rat_of_int (xj # xjs))).\n     hd row \\<notin> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (fv # v # va))\n                         (map rat_of_int (xj # xjs))).\n     hd row \\<notin> \\<int>\n\ngoal (3 subgoals):\n 1. \\<And>fj xjs.\n       \\<lbrakk>length [fj] = length xjs; length xjs \\<le> length xs;\n        local.newton_coefficients_main_int [fj] xjs = None;\n        xjs = drop (length xs - length xjs) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [fj])\n       (map rat_of_int xjs)).\n                            hd row \\<notin> \\<int>\n 2. \\<And>uv_.\n       \\<lbrakk>length [] = length uv_; length uv_ \\<le> length xs;\n        local.newton_coefficients_main_int [] uv_ = None;\n        uv_ = drop (length xs - length uv_) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs) (map rat_of_int [])\n       (map rat_of_int uv_)).\n                            hd row \\<notin> \\<int>\n 3. \\<And>v vb vc.\n       \\<lbrakk>length (v # vb # vc) = length []; length [] \\<le> length xs;\n        local.newton_coefficients_main_int (v # vb # vc) [] = None;\n        [] = drop (length xs - length []) (rev xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>row\\<in>set\n     (newton_coefficients_main (map rat_of_int xs)\n       (map rat_of_int (v # vb # vc)) (map rat_of_int [])).\n                            hd row \\<notin> \\<int>", "qed auto"], ["", "lemma newton_coefficients_int: assumes dist: \"distinct xs\"\n  and len: \"length xs = length fs\"\n  shows \"newton_coefficients_int = (let cs = newton_coefficients (map rat_of_int xs) (map of_int fs)\n    in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "from len"], ["proof (chain)\npicking this:\n  length xs = length fs", "have len: \"length (rev fs) = length (rev xs)\" \"length (rev xs) \\<le> length xs\""], ["proof (prove)\nusing this:\n  length xs = length fs\n\ngoal (1 subgoal):\n 1. length (rev fs) = length (rev xs) &&& length (rev xs) \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  length (rev fs) = length (rev xs)\n  length (rev xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "proof (cases \"newton_coefficients_main_int (rev fs) (rev xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "case (Some res)"], ["proof (state)\nthis:\n  local.newton_coefficients_main_int (rev fs) (rev xs) = Some res\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "have rev: \"\\<And> xs. map rat_of_int (rev xs) = rev (map of_int xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. map rat_of_int (rev xs) = rev (map rat_of_int xs)", "unfolding rev_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. map rat_of_int (rev xs) = map rat_of_int (rev xs)", ".."], ["proof (state)\nthis:\n  map rat_of_int (rev ?xs) = rev (map rat_of_int ?xs)\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "note n = newton_coefficients_main_int_Some[OF len Some, unfolded rev]"], ["proof (state)\nthis:\n  newton_coefficients_main (map rat_of_int xs) (rev (map rat_of_int fs))\n   (rev (map rat_of_int xs)) =\n  map (map rat_of_int) res \\<and>\n  (\\<forall>x\\<in>set res.\n      x \\<noteq> [] \\<and> length x \\<le> length (rev xs)) \\<and>\n  length res = length (rev fs)\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "{"], ["proof (state)\nthis:\n  newton_coefficients_main (map rat_of_int xs) (rev (map rat_of_int fs))\n   (rev (map rat_of_int xs)) =\n  map (map rat_of_int) res \\<and>\n  (\\<forall>x\\<in>set res.\n      x \\<noteq> [] \\<and> length x \\<le> length (rev xs)) \\<and>\n  length res = length (rev fs)\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "fix row"], ["proof (state)\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "assume \"row \\<in> set res\""], ["proof (state)\nthis:\n  row \\<in> set res\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "with n"], ["proof (chain)\npicking this:\n  newton_coefficients_main (map rat_of_int xs) (rev (map rat_of_int fs))\n   (rev (map rat_of_int xs)) =\n  map (map rat_of_int) res \\<and>\n  (\\<forall>x\\<in>set res.\n      x \\<noteq> [] \\<and> length x \\<le> length (rev xs)) \\<and>\n  length res = length (rev fs)\n  row \\<in> set res", "have \"row \\<noteq> []\""], ["proof (prove)\nusing this:\n  newton_coefficients_main (map rat_of_int xs) (rev (map rat_of_int fs))\n   (rev (map rat_of_int xs)) =\n  map (map rat_of_int) res \\<and>\n  (\\<forall>x\\<in>set res.\n      x \\<noteq> [] \\<and> length x \\<le> length (rev xs)) \\<and>\n  length res = length (rev fs)\n  row \\<in> set res\n\ngoal (1 subgoal):\n 1. row \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  row \\<noteq> []\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "hence id: \"hd (map rat_of_int row) = rat_of_int (hd row)\""], ["proof (prove)\nusing this:\n  row \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (map rat_of_int row) = rat_of_int (hd row)", "by (cases row, auto)"], ["proof (state)\nthis:\n  hd (map rat_of_int row) = rat_of_int (hd row)\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "also"], ["proof (state)\nthis:\n  hd (map rat_of_int row) = rat_of_int (hd row)\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (hd row) \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  rat_of_int (hd row) \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "finally"], ["proof (chain)\npicking this:\n  hd (map rat_of_int row) \\<in> \\<int>", "have int: \"hd (map rat_of_int row) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  hd (map rat_of_int row) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. hd (map rat_of_int row) \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  hd (map rat_of_int row) \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "have \"hd row = int_of_rat (hd (map rat_of_int row))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd row = int_of_rat (hd (map rat_of_int row))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd row = int_of_rat (rat_of_int (hd row))", "by simp"], ["proof (state)\nthis:\n  hd row = int_of_rat (hd (map rat_of_int row))\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "note this int"], ["proof (state)\nthis:\n  hd row = int_of_rat (hd (map rat_of_int row))\n  hd (map rat_of_int row) \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "}"], ["proof (state)\nthis:\n  ?row2 \\<in> set res \\<Longrightarrow>\n  hd ?row2 = int_of_rat (hd (map rat_of_int ?row2))\n  ?row2 \\<in> set res \\<Longrightarrow>\n  hd (map rat_of_int ?row2) \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)\n 2. \\<And>a.\n       local.newton_coefficients_main_int (rev fs) (rev xs) =\n       Some a \\<Longrightarrow>\n       local.newton_coefficients_int =\n       (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n        in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n           else None)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?row2 \\<in> set res \\<Longrightarrow>\n  hd ?row2 = int_of_rat (hd (map rat_of_int ?row2))\n  ?row2 \\<in> set res \\<Longrightarrow>\n  hd (map rat_of_int ?row2) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "unfolding newton_coefficients_int_def Some newton_coefficients_def n[THEN conjunct1] Let_def option.simps"], ["proof (prove)\nusing this:\n  ?row2 \\<in> set res \\<Longrightarrow>\n  hd ?row2 = int_of_rat (hd (map rat_of_int ?row2))\n  ?row2 \\<in> set res \\<Longrightarrow>\n  hd (map rat_of_int ?row2) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. Some (map hd res) =\n    (if set (map hd (map (map rat_of_int) res)) \\<subseteq> \\<int>\n     then Some (map int_of_rat (map hd (map (map rat_of_int) res)))\n     else None)", "by (auto simp: o_def)"], ["proof (state)\nthis:\n  local.newton_coefficients_int =\n  (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n   in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs) else None)\n\ngoal (1 subgoal):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "case None"], ["proof (state)\nthis:\n  local.newton_coefficients_main_int (rev fs) (rev xs) = None\n\ngoal (1 subgoal):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "have \"rev xs = drop (length xs - length (rev xs)) (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs = drop (length xs - length (rev xs)) (rev xs)", "by simp"], ["proof (state)\nthis:\n  rev xs = drop (length xs - length (rev xs)) (rev xs)\n\ngoal (1 subgoal):\n 1. local.newton_coefficients_main_int (rev fs) (rev xs) =\n    None \\<Longrightarrow>\n    local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "from newton_coefficients_main_int_None[OF dist len None this]"], ["proof (chain)\npicking this:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (rev fs))\n                         (map rat_of_int (rev xs))).\n     hd row \\<notin> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (rev fs))\n                         (map rat_of_int (rev xs))).\n     hd row \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. local.newton_coefficients_int =\n    (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "unfolding newton_coefficients_int_def newton_coefficients_def None"], ["proof (prove)\nusing this:\n  \\<exists>row\\<in>set (newton_coefficients_main (map rat_of_int xs)\n                         (map rat_of_int (rev fs))\n                         (map rat_of_int (rev xs))).\n     hd row \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. map_option (map hd) None =\n    (let cs = map hd\n               (newton_coefficients_main (map rat_of_int xs)\n                 (rev (map rat_of_int fs)) (rev (map rat_of_int xs)))\n     in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs)\n        else None)", "by (auto simp: Let_def rev_map)"], ["proof (state)\nthis:\n  local.newton_coefficients_int =\n  (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n   in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs) else None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.newton_coefficients_int =\n  (let cs = newton_coefficients (map rat_of_int xs) (map rat_of_int fs)\n   in if set cs \\<subseteq> \\<int> then Some (map int_of_rat cs) else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition newton_poly_impl_int :: \"int poly option\" where\n  \"newton_poly_impl_int \\<equiv> case newton_coefficients_int of None \\<Rightarrow> None \n     | Some nc \\<Rightarrow> Some (horner_composition (rev nc) xs)\""], ["", "lemma newton_poly_impl_int: assumes len: \"length xs = length fs\" \n  and dist: \"distinct xs\"\n  shows \"newton_poly_impl_int = (let p = newton_poly_impl (map rat_of_int xs) (map of_int fs)\n    in if set (coeffs p) \\<subseteq> \\<int> then Some (map_poly int_of_rat p) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "let ?ir = \"int_of_rat\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "let ?ri = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "let ?mir = \"map ?ir\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "let ?mri = \"map ?ri\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "let ?nc = \"newton_coefficients (?mri xs) (?mri fs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "have id: \"newton_poly_impl_int = (if set ?nc \\<subseteq> \\<int>\n    then Some (horner_composition (rev (?mir ?nc)) xs) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (if set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n        \\<subseteq> \\<int>\n     then Some\n           (horner_composition\n             (rev (map int_of_rat\n                    (newton_coefficients (map rat_of_int xs)\n                      (map rat_of_int fs))))\n             xs)\n     else None)", "unfolding newton_poly_impl_int_def newton_coefficients_int[OF dist len] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case if set (newton_coefficients (map rat_of_int xs)\n                   (map rat_of_int fs))\n             \\<subseteq> \\<int>\n          then Some\n                (map int_of_rat\n                  (newton_coefficients (map rat_of_int xs)\n                    (map rat_of_int fs)))\n          else None of\n     None \\<Rightarrow> None\n     | Some nc \\<Rightarrow> Some (horner_composition (rev nc) xs)) =\n    (if set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n        \\<subseteq> \\<int>\n     then Some\n           (horner_composition\n             (rev (map int_of_rat\n                    (newton_coefficients (map rat_of_int xs)\n                      (map rat_of_int fs))))\n             xs)\n     else None)", "by simp"], ["proof (state)\nthis:\n  local.newton_poly_impl_int =\n  (if set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n      \\<subseteq> \\<int>\n   then Some\n         (horner_composition\n           (rev (map int_of_rat\n                  (newton_coefficients (map rat_of_int xs)\n                    (map rat_of_int fs))))\n           xs)\n   else None)\n\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "have len: \"length (rev ?nc) \\<le> Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n    \\<le> Suc (length xs)", "unfolding length_rev"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<le> Suc (length xs)", "by (subst newton_coefficients[OF refl], insert len, auto)"], ["proof (state)\nthis:\n  length (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n  \\<le> Suc (length xs)\n\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.newton_poly_impl_int =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n        \\<subseteq> \\<int>\n     then Some\n           (horner_composition\n             (rev (map int_of_rat\n                    (newton_coefficients (map rat_of_int xs)\n                      (map rat_of_int fs))))\n             xs)\n     else None) =\n    (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "unfolding newton_poly_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n        \\<subseteq> \\<int>\n     then Some\n           (horner_composition\n             (rev (map int_of_rat\n                    (newton_coefficients (map rat_of_int xs)\n                      (map rat_of_int fs))))\n             xs)\n     else None) =\n    (let p = horner_composition\n              (rev (newton_coefficients (map rat_of_int xs)\n                     (map rat_of_int fs)))\n              (map rat_of_int xs)\n     in if set (coeffs p) \\<subseteq> \\<int>\n        then Some (map_poly int_of_rat p) else None)", "unfolding Let_def set_rev rev_map horner_coeffs_ints[OF len]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n        \\<subseteq> \\<int>\n     then Some\n           (horner_composition\n             (map int_of_rat\n               (rev (newton_coefficients (map rat_of_int xs)\n                      (map rat_of_int fs))))\n             xs)\n     else None) =\n    (if set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n        \\<subseteq> \\<int>\n     then Some\n           (map_poly int_of_rat\n             (horner_composition\n               (rev (newton_coefficients (map rat_of_int xs)\n                      (map rat_of_int fs)))\n               (map rat_of_int xs)))\n     else None)", "proof (rule if_cong[OF refl _ refl], rule arg_cong[of _ _ Some])"], ["proof (state)\ngoal (1 subgoal):\n 1. set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "define cs where \"cs = rev ?nc\""], ["proof (state)\nthis:\n  cs = rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n\ngoal (1 subgoal):\n 1. set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "define ics where \"ics = map ?ir cs\""], ["proof (state)\nthis:\n  ics = map int_of_rat cs\n\ngoal (1 subgoal):\n 1. set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "assume \"set ?nc \\<subseteq> \\<int>\""], ["proof (state)\nthis:\n  set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n  \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "hence \"set cs \\<subseteq> \\<int>\""], ["proof (prove)\nusing this:\n  set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n  \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. set cs \\<subseteq> \\<int>", "unfolding cs_def"], ["proof (prove)\nusing this:\n  set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n  \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. set (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n    \\<subseteq> \\<int>", "by auto"], ["proof (state)\nthis:\n  set cs \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "hence ics: \"cs = ?mri ics\""], ["proof (prove)\nusing this:\n  set cs \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. cs = map rat_of_int ics", "unfolding ics_def map_map o_def"], ["proof (prove)\nusing this:\n  set cs \\<subseteq> \\<int>\n\ngoal (1 subgoal):\n 1. cs = map (\\<lambda>x. rat_of_int (int_of_rat x)) cs", "by (simp add: map_idI subset_code(1))"], ["proof (state)\nthis:\n  cs = map rat_of_int ics\n\ngoal (1 subgoal):\n 1. set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "have id: \"horner_composition (rev ?nc) (?mri xs) = map_poly ?ri (horner_composition ics xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition\n     (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n     (map rat_of_int xs) =\n    of_int_poly (horner_composition ics xs)", "unfolding cs_def[symmetric] ics"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition (map rat_of_int ics) (map rat_of_int xs) =\n    of_int_poly (horner_composition ics xs)", "by (rule of_int_poly_hom.horner_composition_hom)"], ["proof (state)\nthis:\n  horner_composition\n   (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n   (map rat_of_int xs) =\n  of_int_poly (horner_composition ics xs)\n\ngoal (1 subgoal):\n 1. set (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))\n    \\<subseteq> \\<int> \\<Longrightarrow>\n    horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "show \"horner_composition (?mir (rev ?nc)) xs\n      = map_poly ?ir (horner_composition (rev ?nc) (?mri xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat\n     (horner_composition\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n       (map rat_of_int xs))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition\n     (map int_of_rat\n       (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n     xs =\n    map_poly int_of_rat (of_int_poly (horner_composition ics xs))", "unfolding cs_def[symmetric] ics_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_composition ics xs =\n    map_poly int_of_rat (of_int_poly (horner_composition ics xs))", "by (subst map_poly_map_poly, auto simp: o_def map_poly_idI)"], ["proof (state)\nthis:\n  horner_composition\n   (map int_of_rat\n     (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs))))\n   xs =\n  map_poly int_of_rat\n   (horner_composition\n     (rev (newton_coefficients (map rat_of_int xs) (map rat_of_int fs)))\n     (map rat_of_int xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.newton_poly_impl_int =\n  (let p = newton_poly_impl (map rat_of_int xs) (map rat_of_int fs)\n   in if set (coeffs p) \\<subseteq> \\<int> then Some (map_poly int_of_rat p)\n      else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition newton_interpolation_poly :: \"('a :: field \\<times> 'a)list \\<Rightarrow> 'a poly\" where\n  \"newton_interpolation_poly x_fs = (let \n    xs = map fst x_fs; fs = map snd x_fs in\n    newton_poly_impl xs fs)\""], ["", "definition newton_interpolation_poly_int :: \"(int \\<times> int)list \\<Rightarrow> int poly option\" where\n  \"newton_interpolation_poly_int x_fs = (let \n    xs = map fst x_fs; fs = map snd x_fs in\n    newton_poly_impl_int xs fs)\""], ["", "lemma newton_interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = newton_interpolation_poly xs_ys\"\n  and xy: \"(x,y) \\<in> set xs_ys\"\n  shows \"poly p x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "proof (cases \"length xs_ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow> poly p x = y\n 2. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "case 0"], ["proof (state)\nthis:\n  length xs_ys = 0\n\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow> poly p x = y\n 2. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  length xs_ys = 0\n\ngoal (1 subgoal):\n 1. poly p x = y", "using xy"], ["proof (prove)\nusing this:\n  length xs_ys = 0\n  (x, y) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. poly p x = y", "by (cases xs_ys, auto)"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "case (Suc nn)"], ["proof (state)\nthis:\n  length xs_ys = Suc nn\n\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "let ?xs = \"map fst xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "let ?fs = \"map snd xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "let ?n = \"Suc nn\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "from xy[unfolded set_conv_nth]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> {xs_ys ! i |i. i < length xs_ys}", "obtain i where xy: \"i \\<le> nn\" \"x = ?xs ! i\" \"y = ?fs ! i\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> {xs_ys ! i |i. i < length xs_ys}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<le> nn; x = map fst xs_ys ! i;\n         y = map snd xs_ys ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {xs_ys ! i |i. i < length xs_ys}\n  length xs_ys = Suc nn\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<le> nn; x = map fst xs_ys ! i;\n         y = map snd xs_ys ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) fst_conv in_set_conv_nth less_Suc_eq_le nth_map snd_conv xy)"], ["proof (state)\nthis:\n  i \\<le> nn\n  x = map fst xs_ys ! i\n  y = map snd xs_ys ! i\n\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "have id: \"newton_interpolation_poly xs_ys = newton_poly ?xs ?fs nn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_interpolation_poly xs_ys =\n    newton_poly (map fst xs_ys) (map snd xs_ys) nn", "unfolding newton_interpolation_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_poly_impl (map fst xs_ys) (map snd xs_ys) =\n    newton_poly (map fst xs_ys) (map snd xs_ys) nn", "by (rule newton_poly_impl[OF _ _ Suc], auto)"], ["proof (state)\nthis:\n  newton_interpolation_poly xs_ys =\n  newton_poly (map fst xs_ys) (map snd xs_ys) nn\n\ngoal (1 subgoal):\n 1. \\<And>nat. length xs_ys = Suc nat \\<Longrightarrow> poly p x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "unfolding p id"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (newton_poly (map fst xs_ys) (map snd xs_ys) nn) x = y", "proof (rule newton_poly_sound[of nn ?xs _ ?fs, unfolded \n      Newton_Interpolation.x_def Newton_Interpolation.f_def, OF _ xy(1), folded xy(2-)])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j \\<le> nn\\<rbrakk>\n       \\<Longrightarrow> map fst xs_ys ! i \\<noteq> map fst xs_ys ! j", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j \\<le> nn\\<rbrakk>\n       \\<Longrightarrow> map fst xs_ys ! i \\<noteq> map fst xs_ys ! j", "show \"i < j \\<Longrightarrow> j \\<le> nn \\<Longrightarrow> ?xs ! i \\<noteq> ?xs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<le> nn\\<rbrakk>\n    \\<Longrightarrow> map fst xs_ys ! i \\<noteq> map fst xs_ys ! j", "using dist Suc nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n  length xs_ys = Suc nn\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<le> nn\\<rbrakk>\n    \\<Longrightarrow> map fst xs_ys ! i \\<noteq> map fst xs_ys ! j", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>i < j; j \\<le> nn\\<rbrakk>\n  \\<Longrightarrow> map fst xs_ys ! i \\<noteq> map fst xs_ys ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_newton_interpolation_poly:  \n  shows \"degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "proof (cases \"length xs_ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow>\n    degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n 2. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "case 0"], ["proof (state)\nthis:\n  length xs_ys = 0\n\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow>\n    degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n 2. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "hence id: \"xs_ys = []\""], ["proof (prove)\nusing this:\n  length xs_ys = 0\n\ngoal (1 subgoal):\n 1. xs_ys = []", "by (cases xs_ys, auto)"], ["proof (state)\nthis:\n  xs_ys = []\n\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow>\n    degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n 2. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "unfolding \n    id newton_interpolation_poly_def Let_def list.simps newton_poly_impl_def\n    Newton_Interpolation.newton_coefficients_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (horner_composition\n       (rev (map hd (newton_coefficients_main [] (rev []) (rev [])))) [])\n    \\<le> length [] - 1", "by simp"], ["proof (state)\nthis:\n  degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "case (Suc nn)"], ["proof (state)\nthis:\n  length xs_ys = Suc nn\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "let ?xs = \"map fst xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "let ?fs = \"map snd xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "let ?n = \"Suc nn\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "have id: \"newton_interpolation_poly xs_ys = newton_poly ?xs ?fs nn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_interpolation_poly xs_ys =\n    newton_poly (map fst xs_ys) (map snd xs_ys) nn", "unfolding newton_interpolation_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_poly_impl (map fst xs_ys) (map snd xs_ys) =\n    newton_poly (map fst xs_ys) (map snd xs_ys) nn", "by (rule newton_poly_impl[OF _ _ Suc], auto)"], ["proof (state)\nthis:\n  newton_interpolation_poly xs_ys =\n  newton_poly (map fst xs_ys) (map snd xs_ys) nn\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (newton_poly (map fst xs_ys) (map snd xs_ys) nn)\n    \\<le> length xs_ys - 1", "using newton_poly_degree[of ?xs ?fs nn] Suc"], ["proof (prove)\nusing this:\n  degree (newton_poly (map fst xs_ys) (map snd xs_ys) nn) \\<le> nn\n  length xs_ys = Suc nn\n\ngoal (1 subgoal):\n 1. degree (newton_poly (map fst xs_ys) (map snd xs_ys) nn)\n    \\<le> length xs_ys - 1", "by simp"], ["proof (state)\nthis:\n  degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For @{const newton_interpolation_poly_int} at this point we just prove that it \n  is equivalent to perfom an interpolation on the rational numbers, and then check\n  whether all resulting coefficients are integers. That this corresponds to a \n  sound and complete interpolation algorithm on the integers is proven in the theory\n  Polynomial-Interpolation, cf.\\ lemmas newton-interpolation-poly-int-Some/None.\\<close>"], ["", "lemma newton_interpolation_poly_int: assumes dist: \"distinct (map fst xs_ys)\"\n  shows \"newton_interpolation_poly_int xs_ys = (let \n     rxs_ys = map (\\<lambda> (x,y). (rat_of_int x, rat_of_int y)) xs_ys;\n     rp = newton_interpolation_poly rxs_ys\n     in if (\\<forall> x \\<in> set (coeffs rp). is_int_rat x) then\n       Some (map_poly int_of_rat rp) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int xs_ys =\n    (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n         rp = newton_interpolation_poly rxs_ys\n     in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n        then Some (map_poly int_of_rat rp) else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int xs_ys =\n    (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n         rp = newton_interpolation_poly rxs_ys\n     in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n        then Some (map_poly int_of_rat rp) else None)", "have id1: \"map fst (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys) = map rat_of_int (map fst xs_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys) =\n    map rat_of_int (map fst xs_ys)", "by (induct xs_ys, auto)"], ["proof (state)\nthis:\n  map fst (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys) =\n  map rat_of_int (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int xs_ys =\n    (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n         rp = newton_interpolation_poly rxs_ys\n     in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n        then Some (map_poly int_of_rat rp) else None)", "have id2: \"map snd (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys) = map rat_of_int (map snd xs_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys) =\n    map rat_of_int (map snd xs_ys)", "by (induct xs_ys, auto)"], ["proof (state)\nthis:\n  map snd (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys) =\n  map rat_of_int (map snd xs_ys)\n\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int xs_ys =\n    (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n         rp = newton_interpolation_poly rxs_ys\n     in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n        then Some (map_poly int_of_rat rp) else None)", "have id3: \"length (map fst xs_ys) = length (map snd xs_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst xs_ys) = length (map snd xs_ys)", "by auto"], ["proof (state)\nthis:\n  length (map fst xs_ys) = length (map snd xs_ys)\n\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int xs_ys =\n    (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n         rp = newton_interpolation_poly rxs_ys\n     in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n        then Some (map_poly int_of_rat rp) else None)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int xs_ys =\n    (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n         rp = newton_interpolation_poly rxs_ys\n     in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n        then Some (map_poly int_of_rat rp) else None)", "unfolding newton_interpolation_poly_def  newton_interpolation_poly_int_def Let_def newton_poly_impl_int[OF id3 dist]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if set (coeffs\n              (newton_poly_impl (map rat_of_int (map fst xs_ys))\n                (map rat_of_int (map snd xs_ys))))\n        \\<subseteq> \\<int>\n     then Some\n           (map_poly int_of_rat\n             (newton_poly_impl (map rat_of_int (map fst xs_ys))\n               (map rat_of_int (map snd xs_ys))))\n     else None) =\n    (if Ball\n         (set (coeffs\n                (newton_poly_impl\n                  (map fst\n                    (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y))\n                      xs_ys))\n                  (map snd\n                    (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y))\n                      xs_ys)))))\n         is_int_rat\n     then Some\n           (map_poly int_of_rat\n             (newton_poly_impl\n               (map fst\n                 (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y))\n                   xs_ys))\n               (map snd\n                 (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y))\n                   xs_ys))))\n     else None)", "unfolding id1 id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if set (coeffs\n              (newton_poly_impl (map rat_of_int (map fst xs_ys))\n                (map rat_of_int (map snd xs_ys))))\n        \\<subseteq> \\<int>\n     then Some\n           (map_poly int_of_rat\n             (newton_poly_impl (map rat_of_int (map fst xs_ys))\n               (map rat_of_int (map snd xs_ys))))\n     else None) =\n    (if Ball\n         (set (coeffs\n                (newton_poly_impl (map rat_of_int (map fst xs_ys))\n                  (map rat_of_int (map snd xs_ys)))))\n         is_int_rat\n     then Some\n           (map_poly int_of_rat\n             (newton_poly_impl (map rat_of_int (map fst xs_ys))\n               (map rat_of_int (map snd xs_ys))))\n     else None)", "by (rule sym, rule if_cong, auto simp: is_int_rat[abs_def])"], ["proof (state)\nthis:\n  newton_interpolation_poly_int xs_ys =\n  (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n       rp = newton_interpolation_poly rxs_ys\n   in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n      then Some (map_poly int_of_rat rp) else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const \n  Newton_Interpolation.x\n  Newton_Interpolation.f"], ["", "end"]]}