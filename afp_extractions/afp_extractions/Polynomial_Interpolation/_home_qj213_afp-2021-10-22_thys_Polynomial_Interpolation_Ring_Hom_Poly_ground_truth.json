{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Ring_Hom_Poly.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma eval_poly_code[code]: \"eval_poly h p x = fold_coeffs (\\<lambda> a b. h a + x * b) p 0\"", "lemma eval_poly_as_sum:\n  fixes h :: \"'a :: zero \\<Rightarrow> 'b :: comm_semiring_1\"\n  assumes \"h 0 = 0\"\n  shows \"eval_poly h p x = (\\<Sum>i\\<le>degree p. x^i * h (coeff p i))\"", "lemma coeff_const: \"coeff [: a :] i = (if i = 0 then a else 0)\"", "lemma x_as_monom: \"[:0,1:] = monom 1 1\"", "lemma x_pow_n: \"monom 1 1 ^ n = monom 1 n\"", "lemma map_poly_eval_poly: assumes h0: \"h 0 = 0\"\n  shows \"map_poly h p = eval_poly (\\<lambda> a. [: h a :]) p [:0,1:]\" (is \"?mp = ?ep\")", "lemma smult_as_map_poly: \"smult a = map_poly ((*) a)\"", "lemma map_poly_hom_monom[simp]: \"map_poly hom (monom a i) = monom (hom a) i\"", "lemma coeff_map_poly_hom[simp]: \"coeff (map_poly hom p) i = hom (coeff p i)\"", "lemma map_poly_hom_add[hom_distribs]:\n    \"map_poly hom (p + q) = map_poly hom p + map_poly hom q\"", "lemma map_poly_pCons_hom[hom_distribs]: \"map_poly hom (pCons a p) = pCons (hom a) (map_poly hom p)\"", "lemma map_poly_hom_smult[hom_distribs]:\n    \"map_poly hom (smult c p) = smult (hom c) (map_poly hom p)\"", "lemma poly_map_poly[simp]: \"poly (map_poly hom p) (hom x) = hom (poly p x)\"", "lemma degree_map_poly_le: \"degree (map_poly f p) \\<le> degree p\"", "lemma coeffs_map_poly: (* An exact variant *)\n  assumes \"f (lead_coeff p) = 0 \\<longleftrightarrow> p = 0\"\n  shows \"coeffs (map_poly f p) = map f (coeffs p)\"", "lemma degree_map_poly: (* An exact variant *)\n  assumes \"f (lead_coeff p) = 0 \\<longleftrightarrow> p = 0\"\n  shows   \"degree (map_poly f p) = degree p\"", "lemma degree_map_poly_hom[simp]: \"degree (map_poly hom p) = degree p\"", "lemma coeffs_map_poly_hom[simp]: \"coeffs (map_poly hom p) = map hom (coeffs p)\"", "lemma hom_lead_coeff[simp]: \"lead_coeff (map_poly hom p) = hom (lead_coeff p)\"", "lemma poly_map_poly_0[simp]:\n    \"poly (map_poly hom p) 0 = hom (poly p 0)\" (is \"?l = ?r\")", "lemma poly_map_poly_1[simp]:\n    \"poly (map_poly hom p) 1 = hom (poly p 1)\" (is \"?l = ?r\")", "lemma map_poly_hom_as_monom_sum:\n    \"(\\<Sum>j\\<le>degree p. monom (hom (coeff p j)) j) = map_poly hom p\"", "lemma map_poly_pcompose[hom_distribs]:\n    \"map_poly hom (f \\<circ>\\<^sub>p g) = map_poly hom f \\<circ>\\<^sub>p map_poly hom g\"", "lemma eval_poly_0[simp]: \"eval_poly hom 0 x = 0\"", "lemma eval_poly_monom: \"eval_poly hom (monom a n) x = hom a * x ^ n\"", "lemma poly_map_poly_eval_poly: \"poly (map_poly hom p) = eval_poly hom p\"", "lemma map_poly_eval_poly: \n  \"map_poly hom p = eval_poly (\\<lambda> a. [: hom a :]) p [:0,1:]\"", "lemma degree_extension: assumes \"degree p \\<le> n\"\n  shows \"(\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i))\n      = (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))\" (is \"?l = ?r\")", "lemma eval_poly_add[simp]: \"eval_poly hom (p + q) x = eval_poly hom p x + eval_poly hom q x\"", "lemma eval_poly_sum: \"eval_poly hom (\\<Sum>k\\<in>A. p k) x = (\\<Sum>k\\<in>A. eval_poly hom (p k) x)\"", "lemma eval_poly_poly: \"eval_poly hom p (hom x) = hom (poly p x)\"", "lemma pseudo_divmod_main_hom:\n    \"pseudo_divmod_main (hom lc) (map_poly hom q) (map_poly hom r) (map_poly hom d) dr i =\n     map_prod (map_poly hom) (map_poly hom) (pseudo_divmod_main lc q r d dr i)\"", "lemma(in inj_comm_ring_hom) pseudo_divmod_hom:\n  \"pseudo_divmod (map_poly hom p) (map_poly hom q) =\n   map_prod (map_poly hom) (map_poly hom) (pseudo_divmod p q)\"", "lemma(in inj_idom_hom) pseudo_mod_hom:\n  \"pseudo_mod (map_poly hom p) (map_poly hom q) = map_poly hom (pseudo_mod p q)\"", "lemma(in idom_hom) map_poly_pderiv[hom_distribs]:\n  \"map_poly hom (pderiv p) = pderiv (map_poly hom p)\"", "lemma map_poly_pdivmod[hom_distribs]:\n  \"map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)\"\n  (is \"?l = ?r\")", "lemma map_poly_div[hom_distribs]: \"map_poly hom (p div q) = map_poly hom p div map_poly hom q\"", "lemma map_poly_mod[hom_distribs]: \"map_poly hom (p mod q) = map_poly hom p mod map_poly hom q\"", "lemma map_poly_normalize[hom_distribs]: \"map_poly hom (normalize p) = normalize (map_poly hom p)\"", "lemma map_poly_gcd[hom_distribs]: \"map_poly hom (gcd p q) = gcd (map_poly hom p) (map_poly hom q)\"", "lemma smult_div_poly: assumes \"\\<And> c. c \\<in> set (coeffs p) \\<Longrightarrow> a dvd c\"\n  shows \"smult a (div_poly a p) = p\"", "lemma coeff_div_poly: \"coeff (div_poly a f) n = coeff f n div a\"", "lemma divide_poly_main_hom: defines \"hh \\<equiv> map_poly hom\" \n  shows \"hh (divide_poly_main lc f g h i j) = divide_poly_main (hom lc) (hh f) (hh g) (hh h) i j\"", "lemma order_hom: \"order (hom x) (map_poly hom f) = order x f\""], "translations": [["", "lemma eval_poly_code[code]: \"eval_poly h p x = fold_coeffs (\\<lambda> a b. h a + x * b) p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly h p x = fold_coeffs (\\<lambda>a b. h a + x * b) p (0::'a)", "by (induct p, auto simp: eval_poly_def)"], ["", "lemma eval_poly_as_sum:\n  fixes h :: \"'a :: zero \\<Rightarrow> 'b :: comm_semiring_1\"\n  assumes \"h 0 = 0\"\n  shows \"eval_poly h p x = (\\<Sum>i\\<le>degree p. x^i * h (coeff p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly h p x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))", "unfolding eval_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (map_poly h 0) x = (\\<Sum>i\\<le>degree 0. x ^ i * h (coeff 0 i))\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly (map_poly h p) x =\n        (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                         (\\<Sum>i\\<le>degree (pCons a p).\n                             x ^ i * h (coeff (pCons a p) i))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. poly (map_poly h 0) x = (\\<Sum>i\\<le>degree 0. x ^ i * h (coeff 0 i))\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly (map_poly h p) x =\n        (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                         (\\<Sum>i\\<le>degree (pCons a p).\n                             x ^ i * h (coeff (pCons a p) i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly h 0) x = (\\<Sum>i\\<le>degree 0. x ^ i * h (coeff 0 i))", "using assms"], ["proof (prove)\nusing this:\n  h (0::'a) = (0::'b)\n\ngoal (1 subgoal):\n 1. poly (map_poly h 0) x = (\\<Sum>i\\<le>degree 0. x ^ i * h (coeff 0 i))", "by simp"], ["proof (state)\nthis:\n  poly (map_poly h 0) x = (\\<Sum>i\\<le>degree 0. x ^ i * h (coeff 0 i))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly (map_poly h p) x =\n        (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                         (\\<Sum>i\\<le>degree (pCons a p).\n                             x ^ i * h (coeff (pCons a p) i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly (map_poly h p) x =\n        (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                         (\\<Sum>i\\<le>degree (pCons a p).\n                             x ^ i * h (coeff (pCons a p) i))", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly (map_poly h p) x =\n        (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                         (\\<Sum>i\\<le>degree (pCons a p).\n                             x ^ i * h (coeff (pCons a p) i))", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i))\n\ngoal (1 subgoal):\n 1. poly (map_poly h (pCons a p)) x =\n    (\\<Sum>i\\<le>degree (pCons a p). x ^ i * h (coeff (pCons a p) i))", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i));\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                      (\\<Sum>i\\<le>degree (pCons a p).\n                          x ^ i * h (coeff (pCons a p) i))\n 2. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i));\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                      (\\<Sum>i\\<le>degree (pCons a p).\n                          x ^ i * h (coeff (pCons a p) i))", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i));\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                      (\\<Sum>i\\<le>degree (pCons a p).\n                          x ^ i * h (coeff (pCons a p) i))\n 2. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i));\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                      (\\<Sum>i\\<le>degree (pCons a p).\n                          x ^ i * h (coeff (pCons a p) i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly h (pCons a p)) x =\n    (\\<Sum>i\\<le>degree (pCons a p). x ^ i * h (coeff (pCons a p) i))", "by (simp add: True map_poly_simps assms)"], ["proof (state)\nthis:\n  poly (map_poly h (pCons a p)) x =\n  (\\<Sum>i\\<le>degree (pCons a p). x ^ i * h (coeff (pCons a p) i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i));\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                      (\\<Sum>i\\<le>degree (pCons a p).\n                          x ^ i * h (coeff (pCons a p) i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i));\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                      (\\<Sum>i\\<le>degree (pCons a p).\n                          x ^ i * h (coeff (pCons a p) i))", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     poly (map_poly h p) x = (\\<Sum>i\\<le>degree p. x ^ i * h (coeff p i));\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly (map_poly h (pCons a p)) x =\n                      (\\<Sum>i\\<le>degree (pCons a p).\n                          x ^ i * h (coeff (pCons a p) i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly h (pCons a p)) x =\n    (\\<Sum>i\\<le>degree (pCons a p). x ^ i * h (coeff (pCons a p) i))", "unfolding degree_pCons_eq[OF False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly h (pCons a p)) x =\n    (\\<Sum>i\\<le>Suc (degree p). x ^ i * h (coeff (pCons a p) i))", "unfolding sum.atMost_Suc_shift"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly h (pCons a p)) x =\n    x ^ 0 * h (coeff (pCons a p) 0) +\n    (\\<Sum>i\\<le>degree p. x ^ Suc i * h (coeff (pCons a p) (Suc i)))", "unfolding map_poly_pCons[OF pCons(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (pCons (h a) (map_poly h p)) x =\n    x ^ 0 * h (coeff (pCons a p) 0) +\n    (\\<Sum>i\\<le>degree p. x ^ Suc i * h (coeff (pCons a p) (Suc i)))", "by (simp add: pCons(2) sum_distrib_left mult.assoc)"], ["proof (state)\nthis:\n  poly (map_poly h (pCons a p)) x =\n  (\\<Sum>i\\<le>degree (pCons a p). x ^ i * h (coeff (pCons a p) i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (map_poly h (pCons a p)) x =\n  (\\<Sum>i\\<le>degree (pCons a p). x ^ i * h (coeff (pCons a p) i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_const: \"coeff [: a :] i = (if i = 0 then a else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff [:a:] i = (if i = 0 then a else (0::'a))", "by (metis coeff_monom monom_0)"], ["", "lemma x_as_monom: \"[:0,1:] = monom 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] = monom (1::'a) 1", "by (simp add: monom_0 monom_Suc)"], ["", "lemma x_pow_n: \"monom 1 1 ^ n = monom 1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 ^ n = monom (1::'a) n", "by (induct n) (simp_all add: monom_0 monom_Suc)"], ["", "lemma map_poly_eval_poly: assumes h0: \"h 0 = 0\"\n  shows \"map_poly h p = eval_poly (\\<lambda> a. [: h a :]) p [:0,1:]\" (is \"?mp = ?ep\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h p = eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly h p) n =\n       coeff (eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]) n", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly h p) n =\n       coeff (eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]) n", "have 2: \"(\\<Sum>x\\<le>i. \\<Sum>xa\\<le>degree p. (if xa = x then 1 else 0) * coeff [:h (coeff p xa):] (i - x)) \n    = h (coeff p i)\" (is \"sum ?f ?s = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "have \"sum ?f ?s = ?f i + sum ?f ({..i} - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) *\n        coeff [:h (coeff p xa):] (i - i)) +\n    (\\<Sum>x\\<in>{..i} - {i}.\n       \\<Sum>xa\\<le>degree p.\n          (if xa = x then 1::'a else (0::'a)) *\n          coeff [:h (coeff p xa):] (i - x))", "by (rule sum.remove[of _ i], auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>i.\n      \\<Sum>xa\\<le>degree p.\n         (if xa = x then 1::'a else (0::'a)) *\n         coeff [:h (coeff p xa):] (i - x)) =\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) *\n      coeff [:h (coeff p xa):] (i - i)) +\n  (\\<Sum>x\\<in>{..i} - {i}.\n     \\<Sum>xa\\<le>degree p.\n        (if xa = x then 1::'a else (0::'a)) *\n        coeff [:h (coeff p xa):] (i - x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>i.\n      \\<Sum>xa\\<le>degree p.\n         (if xa = x then 1::'a else (0::'a)) *\n         coeff [:h (coeff p xa):] (i - x)) =\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) *\n      coeff [:h (coeff p xa):] (i - i)) +\n  (\\<Sum>x\\<in>{..i} - {i}.\n     \\<Sum>xa\\<le>degree p.\n        (if xa = x then 1::'a else (0::'a)) *\n        coeff [:h (coeff p xa):] (i - x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "have \"sum ?f ({..i} - {i}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{..i} - {i}.\n       \\<Sum>xa\\<le>degree p.\n          (if xa = x then 1::'a else (0::'a)) *\n          coeff [:h (coeff p xa):] (i - x)) =\n    (0::'a)", "by (rule sum.neutral, intro ballI, rule sum.neutral, auto simp: coeff_const)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{..i} - {i}.\n     \\<Sum>xa\\<le>degree p.\n        (if xa = x then 1::'a else (0::'a)) *\n        coeff [:h (coeff p xa):] (i - x)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{..i} - {i}.\n     \\<Sum>xa\\<le>degree p.\n        (if xa = x then 1::'a else (0::'a)) *\n        coeff [:h (coeff p xa):] (i - x)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "have \"?f i = (\\<Sum>xa\\<le>degree p. (if xa = i then 1 else 0) * h (coeff p xa))\" (is \"_ = ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) *\n        coeff [:h (coeff p xa):] (i - i)) =\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa))", "unfolding coeff_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) *\n        (if i - i = 0 then h (coeff p xa) else (0::'a))) =\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) *\n      coeff [:h (coeff p xa):] (i - i)) =\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) * h (coeff p xa))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) *\n      coeff [:h (coeff p xa):] (i - i)) =\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) * h (coeff p xa))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "proof (cases \"i \\<le> degree p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)\n 2. \\<not> i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "case True"], ["proof (state)\nthis:\n  i \\<le> degree p\n\ngoal (2 subgoals):\n 1. i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)\n 2. \\<not> i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "by (subst sum.remove[of _ i], insert True, auto)"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n  h (coeff p i)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "hence [simp]: \"coeff p i = 0\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> degree p\n\ngoal (1 subgoal):\n 1. coeff p i = (0::'b)", "using le_degree"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> degree p\n  coeff ?p ?n \\<noteq> (0::?'a) \\<Longrightarrow> ?n \\<le> degree ?p\n\ngoal (1 subgoal):\n 1. coeff p i = (0::'b)", "by blast"], ["proof (state)\nthis:\n  coeff p i = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> degree p \\<Longrightarrow>\n    (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<le>degree p.\n        (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n    h (coeff p i)", "by (subst sum.neutral, auto simp: h0)"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n  h (coeff p i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<le>degree p.\n      (if xa = i then 1::'a else (0::'a)) * h (coeff p xa)) =\n  h (coeff p i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<le>i.\n      \\<Sum>xa\\<le>degree p.\n         (if xa = x then 1::'a else (0::'a)) *\n         coeff [:h (coeff p xa):] (i - x)) =\n  h (coeff p i) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<le>i.\n      \\<Sum>xa\\<le>degree p.\n         (if xa = x then 1::'a else (0::'a)) *\n         coeff [:h (coeff p xa):] (i - x)) =\n  h (coeff p i) + (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        \\<Sum>xa\\<le>degree p.\n           (if xa = x then 1::'a else (0::'a)) *\n           coeff [:h (coeff p xa):] (i - x)) =\n    h (coeff p i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>i.\n      \\<Sum>xa\\<le>degree p.\n         (if xa = x then 1::'a else (0::'a)) *\n         coeff [:h (coeff p xa):] (i - x)) =\n  h (coeff p i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>i.\n      \\<Sum>xa\\<le>degree p.\n         (if xa = x then 1::'a else (0::'a)) *\n         coeff [:h (coeff p xa):] (i - x)) =\n  h (coeff p i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly h p) n =\n       coeff (eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]) n", "have h'0: \"[: h 0 :] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:h (0::'b):] = 0", "using h0"], ["proof (prove)\nusing this:\n  h (0::'b) = (0::'a)\n\ngoal (1 subgoal):\n 1. [:h (0::'b):] = 0", "by auto"], ["proof (state)\nthis:\n  [:h (0::'b):] = 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly h p) n =\n       coeff (eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]) n", "show \"coeff ?mp i = coeff ?ep i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (map_poly h p) i =\n    coeff (eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]) i", "unfolding coeff_map_poly[of h, OF h0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (coeff p i) =\n    coeff (eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]) i", "unfolding eval_poly_as_sum[of \"\\<lambda>a. [: h a :]\", OF h'0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (coeff p i) =\n    coeff (\\<Sum>i\\<le>degree p. [:0::'a, 1::'a:] ^ i * [:h (coeff p i):]) i", "unfolding coeff_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (coeff p i) =\n    (\\<Sum>x\\<le>degree p.\n        coeff ([:0::'a, 1::'a:] ^ x * [:h (coeff p x):]) i)", "unfolding x_as_monom x_pow_n coeff_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (coeff p i) =\n    (\\<Sum>x\\<le>degree p.\n        \\<Sum>ia\\<le>i.\n           coeff (monom (1::'a) x) ia * coeff [:h (coeff p x):] (i - ia))", "unfolding sum.swap[of _ _ \"{..degree p}\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (coeff p i) =\n    (\\<Sum>j\\<le>i.\n        \\<Sum>x\\<le>degree p.\n           coeff (monom (1::'a) x) j * coeff [:h (coeff p x):] (i - j))", "unfolding coeff_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (coeff p i) =\n    (\\<Sum>j\\<le>i.\n        \\<Sum>x\\<le>degree p.\n           (if x = j then 1::'a else (0::'a)) *\n           coeff [:h (coeff p x):] (i - j))", "using 2"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<le>i.\n      \\<Sum>xa\\<le>degree p.\n         (if xa = x then 1::'a else (0::'a)) *\n         coeff [:h (coeff p xa):] (i - x)) =\n  h (coeff p i)\n\ngoal (1 subgoal):\n 1. h (coeff p i) =\n    (\\<Sum>j\\<le>i.\n        \\<Sum>x\\<le>degree p.\n           (if x = j then 1::'a else (0::'a)) *\n           coeff [:h (coeff p x):] (i - j))", "by auto"], ["proof (state)\nthis:\n  coeff (map_poly h p) i =\n  coeff (eval_poly (\\<lambda>a. [:h a:]) p [:0::'a, 1::'a:]) i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_as_map_poly: \"smult a = map_poly ((*) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a = map_poly ((*) a)", "by (rule ext, rule poly_eqI, subst coeff_map_poly, auto)"], ["", "subsection \\<open>@{const map_poly} of Homomorphisms\\<close>"], ["", "context zero_hom begin"], ["", "text \\<open>We will consider @{term hom} is always simpler than @{term \"map_poly hom\"}.\\<close>"], ["", "lemma map_poly_hom_monom[simp]: \"map_poly hom (monom a i) = monom (hom a) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (monom a i) = monom (hom a) i", "by(rule map_poly_monom, auto)"], ["", "lemma coeff_map_poly_hom[simp]: \"coeff (map_poly hom p) i = hom (coeff p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (map_poly hom p) i = hom (coeff p i)", "by (rule coeff_map_poly, rule hom_zero)"], ["", "end"], ["", "locale map_poly_zero_hom = base: zero_hom\nbegin"], ["", "sublocale zero_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom (map_poly hom)", "by (unfold_locales, auto)"], ["", "end"], ["", "text \\<open>@{const map_poly} preserves homomorphisms over addition.\\<close>"], ["", "context comm_monoid_add_hom\nbegin"], ["", "lemma map_poly_hom_add[hom_distribs]:\n    \"map_poly hom (p + q) = map_poly hom p + map_poly hom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (p + q) = map_poly hom p + map_poly hom q", "by (rule map_poly_add; simp add: hom_distribs)"], ["", "end"], ["", "locale map_poly_comm_monoid_add_hom = base: comm_monoid_add_hom\nbegin"], ["", "sublocale comm_monoid_add_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_add_hom (map_poly hom)", "by (unfold_locales, auto simp:hom_distribs)"], ["", "end"], ["", "text \\<open>To preserve homomorphisms over multiplication, it demands commutative ring homomorphisms.\\<close>"], ["", "context comm_semiring_hom begin"], ["", "lemma map_poly_pCons_hom[hom_distribs]: \"map_poly hom (pCons a p) = pCons (hom a) (map_poly hom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (pCons a p) = pCons (hom a) (map_poly hom p)", "unfolding map_poly_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = (0::'a) \\<and> p = 0 then 0\n     else pCons (hom a) (map_poly hom p)) =\n    pCons (hom a) (map_poly hom p)", "by auto"], ["", "lemma map_poly_hom_smult[hom_distribs]:\n    \"map_poly hom (smult c p) = smult (hom c) (map_poly hom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (smult c p) = smult (hom c) (map_poly hom p)", "by (induct p, auto simp: hom_distribs)"], ["", "lemma poly_map_poly[simp]: \"poly (map_poly hom p) (hom x) = hom (poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (hom x) = hom (poly p x)", "by (induct p; simp add: hom_distribs)"], ["", "end"], ["", "locale map_poly_comm_semiring_hom = base: comm_semiring_hom\nbegin"], ["", "sublocale map_poly_comm_monoid_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_monoid_add_hom hom", ".."], ["", "sublocale comm_semiring_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_hom (map_poly hom)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. map_poly hom 1 = 1\n 2. \\<And>x y. map_poly hom (x * y) = map_poly hom x * map_poly hom y", "show \"map_poly hom 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom 1 = 1", "by simp"], ["proof (state)\nthis:\n  map_poly hom 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>x y. map_poly hom (x * y) = map_poly hom x * map_poly hom y", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. map_poly hom (x * y) = map_poly hom x * map_poly hom y", "show \"map_poly hom (p * q) = map_poly hom p * map_poly hom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (p * q) = map_poly hom p * map_poly hom q", "by (induct p, auto simp: hom_distribs)"], ["proof (state)\nthis:\n  map_poly hom (p * q) = map_poly hom p * map_poly hom q\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale map_poly_comm_ring_hom = base: comm_ring_hom\nbegin"], ["", "sublocale map_poly_comm_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_semiring_hom hom", ".."], ["", "sublocale comm_ring_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_hom (map_poly hom)", ".."], ["", "end"], ["", "locale map_poly_idom_hom = base: idom_hom\nbegin"], ["", "sublocale map_poly_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom hom", ".."], ["", "sublocale idom_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_hom (map_poly hom)", ".."], ["", "end"], ["", "subsubsection \\<open>Injectivity\\<close>"], ["", "locale map_poly_inj_zero_hom = base: inj_zero_hom\nbegin"], ["", "sublocale inj_zero_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_zero_hom (map_poly hom)", "proof (unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_poly hom 0 = 0\n 2. \\<And>x y. map_poly hom x = map_poly hom y \\<Longrightarrow> x = y", "fix p q :: \"'a poly\""], ["proof (state)\ngoal (2 subgoals):\n 1. map_poly hom 0 = 0\n 2. \\<And>x y. map_poly hom x = map_poly hom y \\<Longrightarrow> x = y", "assume \"map_poly hom p = map_poly hom q\""], ["proof (state)\nthis:\n  map_poly hom p = map_poly hom q\n\ngoal (2 subgoals):\n 1. map_poly hom 0 = 0\n 2. \\<And>x y. map_poly hom x = map_poly hom y \\<Longrightarrow> x = y", "from cong[of \"\\<lambda>p. coeff p _\", OF refl this]"], ["proof (chain)\npicking this:\n  coeff (map_poly hom p) ?uu5 = coeff (map_poly hom q) ?uu5", "show \"p = q\""], ["proof (prove)\nusing this:\n  coeff (map_poly hom p) ?uu5 = coeff (map_poly hom q) ?uu5\n\ngoal (1 subgoal):\n 1. p = q", "by (auto intro: poly_eqI)"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. map_poly hom 0 = 0", "qed simp"], ["", "end"], ["", "locale map_poly_inj_comm_monoid_add_hom = base: inj_comm_monoid_add_hom\nbegin"], ["", "sublocale map_poly_comm_monoid_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_monoid_add_hom hom", ".."], ["", "sublocale map_poly_inj_zero_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom hom", ".."], ["", "sublocale inj_comm_monoid_add_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_add_hom (map_poly hom)", ".."], ["", "end"], ["", "locale map_poly_inj_comm_semiring_hom = base: inj_comm_semiring_hom\nbegin"], ["", "sublocale map_poly_comm_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_semiring_hom hom", ".."], ["", "sublocale map_poly_inj_zero_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom hom", ".."], ["", "sublocale inj_comm_semiring_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_semiring_hom (map_poly hom)", ".."], ["", "end"], ["", "locale map_poly_inj_comm_ring_hom = base: inj_comm_ring_hom\nbegin"], ["", "sublocale map_poly_inj_comm_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_semiring_hom hom", ".."], ["", "sublocale inj_comm_ring_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom (map_poly hom)", ".."], ["", "end"], ["", "locale map_poly_inj_idom_hom = base: inj_idom_hom\nbegin"], ["", "sublocale map_poly_inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom hom", ".."], ["", "sublocale inj_idom_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom (map_poly hom)", ".."], ["", "end"], ["", "lemma degree_map_poly_le: \"degree (map_poly f p) \\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly f p) \\<le> degree p", "by(induct p;auto)"], ["", "lemma coeffs_map_poly: (* An exact variant *)\n  assumes \"f (lead_coeff p) = 0 \\<longleftrightarrow> p = 0\"\n  shows \"coeffs (map_poly f p) = map f (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (map_poly f p) = map f (coeffs p)", "unfolding coeffs_map_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_while ((=) (0::'a)) (map f (coeffs p)) = map f (coeffs p)", "using assms"], ["proof (prove)\nusing this:\n  (f (lead_coeff p) = (0::'a)) = (p = 0)\n\ngoal (1 subgoal):\n 1. strip_while ((=) (0::'a)) (map f (coeffs p)) = map f (coeffs p)", "by (simp add:coeffs_def)"], ["", "lemma degree_map_poly: (* An exact variant *)\n  assumes \"f (lead_coeff p) = 0 \\<longleftrightarrow> p = 0\"\n  shows   \"degree (map_poly f p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly f p) = degree p", "unfolding degree_eq_length_coeffs"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (coeffs (map_poly f p)) - 1 = length (coeffs p) - 1", "unfolding coeffs_map_poly[of f, OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map f (coeffs p)) - 1 = length (coeffs p) - 1", "by simp"], ["", "context zero_hom_0 begin"], ["", "lemma degree_map_poly_hom[simp]: \"degree (map_poly hom p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly hom p) = degree p", "by (rule degree_map_poly, auto)"], ["", "lemma coeffs_map_poly_hom[simp]: \"coeffs (map_poly hom p) = map hom (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (map_poly hom p) = map hom (coeffs p)", "by (rule coeffs_map_poly, auto)"], ["", "lemma hom_lead_coeff[simp]: \"lead_coeff (map_poly hom p) = hom (lead_coeff p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (map_poly hom p) = hom (lead_coeff p)", "by simp"], ["", "end"], ["", "context comm_semiring_hom begin"], ["", "interpretation map_poly_hom: map_poly_comm_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_semiring_hom hom", ".."], ["", "lemma poly_map_poly_0[simp]:\n    \"poly (map_poly hom p) 0 = hom (poly p 0)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (0::'b) = hom (poly p (0::'a))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (0::'b) = hom (poly p (0::'a))", "have \"?l = poly (map_poly hom p) (hom 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (0::'b) = poly (map_poly hom p) (hom (0::'a))", "by auto"], ["proof (state)\nthis:\n  poly (map_poly hom p) (0::'b) = poly (map_poly hom p) (hom (0::'a))\n\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (0::'b) = hom (poly p (0::'a))", "then"], ["proof (chain)\npicking this:\n  poly (map_poly hom p) (0::'b) = poly (map_poly hom p) (hom (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (map_poly hom p) (0::'b) = poly (map_poly hom p) (hom (0::'a))\n\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (0::'b) = hom (poly p (0::'a))", "unfolding poly_map_poly"], ["proof (prove)\nusing this:\n  poly (map_poly hom p) (0::'b) = hom (poly p (0::'a))\n\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (0::'b) = hom (poly p (0::'a))", "."], ["proof (state)\nthis:\n  poly (map_poly hom p) (0::'b) = hom (poly p (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_map_poly_1[simp]:\n    \"poly (map_poly hom p) 1 = hom (poly p 1)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (1::'b) = hom (poly p (1::'a))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (1::'b) = hom (poly p (1::'a))", "have \"?l = poly (map_poly hom p) (hom 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (1::'b) = poly (map_poly hom p) (hom (1::'a))", "by auto"], ["proof (state)\nthis:\n  poly (map_poly hom p) (1::'b) = poly (map_poly hom p) (hom (1::'a))\n\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (1::'b) = hom (poly p (1::'a))", "then"], ["proof (chain)\npicking this:\n  poly (map_poly hom p) (1::'b) = poly (map_poly hom p) (hom (1::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (map_poly hom p) (1::'b) = poly (map_poly hom p) (hom (1::'a))\n\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (1::'b) = hom (poly p (1::'a))", "unfolding poly_map_poly"], ["proof (prove)\nusing this:\n  poly (map_poly hom p) (1::'b) = hom (poly p (1::'a))\n\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (1::'b) = hom (poly p (1::'a))", "."], ["proof (state)\nthis:\n  poly (map_poly hom p) (1::'b) = hom (poly p (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_hom_as_monom_sum:\n    \"(\\<Sum>j\\<le>degree p. monom (hom (coeff p j)) j) = map_poly hom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>degree p. monom (hom (coeff p j)) j) = map_poly hom p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>degree p. monom (hom (coeff p j)) j) = map_poly hom p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>degree p. monom (hom (coeff p j)) j) = map_poly hom p", "by (subst(6) poly_as_sum_of_monoms'[OF le_refl, symmetric], simp add: hom_distribs)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>degree p. monom (hom (coeff p j)) j) = map_poly hom p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_pcompose[hom_distribs]:\n    \"map_poly hom (f \\<circ>\\<^sub>p g) = map_poly hom f \\<circ>\\<^sub>p map_poly hom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (f \\<circ>\\<^sub>p g) =\n    map_poly hom f \\<circ>\\<^sub>p map_poly hom g", "by (induct f arbitrary: g; auto simp: hom_distribs)"], ["", "end"], ["", "context comm_semiring_hom begin"], ["", "lemma eval_poly_0[simp]: \"eval_poly hom 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly hom 0 x = (0::'b)", "unfolding eval_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom 0) x = (0::'b)", "by simp"], ["", "lemma eval_poly_monom: \"eval_poly hom (monom a n) x = hom a * x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly hom (monom a n) x = hom a * x ^ n", "unfolding eval_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom (monom a n)) x = hom a * x ^ n", "unfolding map_poly_monom[of hom, OF hom_zero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (monom (hom a) n) x = hom a * x ^ n", "using poly_monom"], ["proof (prove)\nusing this:\n  poly (monom ?a ?n) ?x = ?a * ?x ^ ?n\n\ngoal (1 subgoal):\n 1. poly (monom (hom a) n) x = hom a * x ^ n", "."], ["", "lemma poly_map_poly_eval_poly: \"poly (map_poly hom p) = eval_poly hom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) = eval_poly hom p", "unfolding eval_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) = poly (map_poly hom p)", ".."], ["", "lemma map_poly_eval_poly: \n  \"map_poly hom p = eval_poly (\\<lambda> a. [: hom a :]) p [:0,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom p = eval_poly (\\<lambda>a. [:hom a:]) p [:0::'b, 1::'b:]", "by (rule map_poly_eval_poly, simp)"], ["", "lemma degree_extension: assumes \"degree p \\<le> n\"\n  shows \"(\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i))\n      = (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "let ?f = \"\\<lambda> i. x ^ i * hom (coeff p i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "define m where \"m = n - degree p\""], ["proof (state)\nthis:\n  m = n - degree p\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "have n: \"n = degree p + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = degree p + m", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = degree p + (n - degree p)", "using assms"], ["proof (prove)\nusing this:\n  degree p \\<le> n\n\ngoal (1 subgoal):\n 1. n = degree p + (n - degree p)", "by auto"], ["proof (state)\nthis:\n  n = degree p + m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "have \"?r = (\\<Sum> i \\<le> degree p + m. ?f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i))", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i))", ".."], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i)) =\n  (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i)) =\n  (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "have \"\\<dots> = ?l + sum ?f {Suc (degree p) .. degree p + m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) +\n    (\\<Sum>i = Suc (degree p)..degree p + m. x ^ i * hom (coeff p i))", "by (subst sum.union_disjoint[symmetric], auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i)) =\n  (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) +\n  (\\<Sum>i = Suc (degree p)..degree p + m. x ^ i * hom (coeff p i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p + m. x ^ i * hom (coeff p i)) =\n  (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) +\n  (\\<Sum>i = Suc (degree p)..degree p + m. x ^ i * hom (coeff p i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "have \"sum ?f {Suc (degree p) .. degree p + m} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + m. x ^ i * hom (coeff p i)) =\n    (0::'b)", "by (rule sum.neutral, auto simp: coeff_eq_0)"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc (degree p)..degree p + m. x ^ i * hom (coeff p i)) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i)) =\n  (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) + (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i)) =\n  (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) + (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n    (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p. x ^ i * hom (coeff p i)) =\n  (\\<Sum>i\\<le>n. x ^ i * hom (coeff p i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_poly_add[simp]: \"eval_poly hom (p + q) x = eval_poly hom p x + eval_poly hom q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly hom (p + q) x = eval_poly hom p x + eval_poly hom q x", "unfolding eval_poly_def hom_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) x + poly (map_poly hom q) x =\n    poly (map_poly hom p) x + poly (map_poly hom q) x", ".."], ["", "lemma eval_poly_sum: \"eval_poly hom (\\<Sum>k\\<in>A. p k) x = (\\<Sum>k\\<in>A. eval_poly hom (p k) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly hom (sum p A) x = (\\<Sum>k\\<in>A. eval_poly hom (p k) x)", "proof (induct A rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       eval_poly hom (sum p A) x = (\\<Sum>k\\<in>A. eval_poly hom (p k) x)\n 2. eval_poly hom (sum p {}) x = (\\<Sum>k\\<in>{}. eval_poly hom (p k) x)\n 3. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        eval_poly hom (sum p F) x =\n        (\\<Sum>k\\<in>F. eval_poly hom (p k) x)\\<rbrakk>\n       \\<Longrightarrow> eval_poly hom (sum p (insert xa F)) x =\n                         (\\<Sum>k\\<in>insert xa F. eval_poly hom (p k) x)", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  eval_poly hom (sum p A) x = (\\<Sum>k\\<in>A. eval_poly hom (p k) x)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       eval_poly hom (sum p A) x = (\\<Sum>k\\<in>A. eval_poly hom (p k) x)\n 2. eval_poly hom (sum p {}) x = (\\<Sum>k\\<in>{}. eval_poly hom (p k) x)\n 3. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        eval_poly hom (sum p F) x =\n        (\\<Sum>k\\<in>F. eval_poly hom (p k) x)\\<rbrakk>\n       \\<Longrightarrow> eval_poly hom (sum p (insert xa F)) x =\n                         (\\<Sum>k\\<in>insert xa F. eval_poly hom (p k) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly hom (sum p (insert a A)) x =\n    (\\<Sum>k\\<in>insert a A. eval_poly hom (p k) x)", "unfolding sum.insert[OF insert(1-2)] insert(3)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly hom (p a + sum p A) x =\n    eval_poly hom (p a) x + eval_poly hom (sum p A) x", "by simp"], ["proof (state)\nthis:\n  eval_poly hom (sum p (insert a A)) x =\n  (\\<Sum>k\\<in>insert a A. eval_poly hom (p k) x)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       eval_poly hom (sum p A) x = (\\<Sum>k\\<in>A. eval_poly hom (p k) x)\n 2. eval_poly hom (sum p {}) x = (\\<Sum>k\\<in>{}. eval_poly hom (p k) x)", "qed (auto simp: eval_poly_def)"], ["", "lemma eval_poly_poly: \"eval_poly hom p (hom x) = hom (poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly hom p (hom x) = hom (poly p x)", "unfolding eval_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly hom p) (hom x) = hom (poly p x)", "by auto"], ["", "end"], ["", "context comm_ring_hom begin"], ["", "interpretation map_poly_hom: map_poly_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom hom", ".."], ["", "lemma pseudo_divmod_main_hom:\n    \"pseudo_divmod_main (hom lc) (map_poly hom q) (map_poly hom r) (map_poly hom d) dr i =\n     map_prod (map_poly hom) (map_poly hom) (pseudo_divmod_main lc q r d dr i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_divmod_main (hom lc) (map_poly hom q) (map_poly hom r)\n     (map_poly hom d) dr i =\n    map_prod (map_poly hom) (map_poly hom)\n     (pseudo_divmod_main lc q r d dr i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. pseudo_divmod_main (hom lc) (map_poly hom q) (map_poly hom r)\n     (map_poly hom d) dr i =\n    map_prod (map_poly hom) (map_poly hom)\n     (pseudo_divmod_main lc q r d dr i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_divmod_main (hom lc) (map_poly hom q) (map_poly hom r)\n     (map_poly hom d) dr i =\n    map_prod (map_poly hom) (map_poly hom)\n     (pseudo_divmod_main lc q r d dr i)", "by (induct lc q r d dr i rule:pseudo_divmod_main.induct, auto simp: Let_def hom_distribs)"], ["proof (state)\nthis:\n  pseudo_divmod_main (hom lc) (map_poly hom q) (map_poly hom r)\n   (map_poly hom d) dr i =\n  map_prod (map_poly hom) (map_poly hom) (pseudo_divmod_main lc q r d dr i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma(in inj_comm_ring_hom) pseudo_divmod_hom:\n  \"pseudo_divmod (map_poly hom p) (map_poly hom q) =\n   map_prod (map_poly hom) (map_poly hom) (pseudo_divmod p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_divmod (map_poly hom p) (map_poly hom q) =\n    map_prod (map_poly hom) (map_poly hom) (pseudo_divmod p q)", "unfolding pseudo_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if map_poly hom q = 0 then (0, map_poly hom p)\n     else pseudo_divmod_main (lead_coeff (map_poly hom q)) 0\n           (map_poly hom p) (map_poly hom q) (degree (map_poly hom p))\n           (1 + length (coeffs (map_poly hom p)) -\n            length (coeffs (map_poly hom q)))) =\n    map_prod (map_poly hom) (map_poly hom)\n     (if q = 0 then (0, p)\n      else pseudo_divmod_main (lead_coeff q) 0 p q (degree p)\n            (1 + length (coeffs p) - length (coeffs q)))", "using pseudo_divmod_main_hom[of _ 0]"], ["proof (prove)\nusing this:\n  pseudo_divmod_main (hom ?lc) (map_poly hom 0) (map_poly hom ?r)\n   (map_poly hom ?d) ?dr ?i =\n  map_prod (map_poly hom) (map_poly hom)\n   (pseudo_divmod_main ?lc 0 ?r ?d ?dr ?i)\n\ngoal (1 subgoal):\n 1. (if map_poly hom q = 0 then (0, map_poly hom p)\n     else pseudo_divmod_main (lead_coeff (map_poly hom q)) 0\n           (map_poly hom p) (map_poly hom q) (degree (map_poly hom p))\n           (1 + length (coeffs (map_poly hom p)) -\n            length (coeffs (map_poly hom q)))) =\n    map_prod (map_poly hom) (map_poly hom)\n     (if q = 0 then (0, p)\n      else pseudo_divmod_main (lead_coeff q) 0 p q (degree p)\n            (1 + length (coeffs p) - length (coeffs q)))", "by (cases \"q = 0\",auto)"], ["", "lemma(in inj_idom_hom) pseudo_mod_hom:\n  \"pseudo_mod (map_poly hom p) (map_poly hom q) = map_poly hom (pseudo_mod p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (map_poly hom p) (map_poly hom q) =\n    map_poly hom (pseudo_mod p q)", "using pseudo_divmod_hom"], ["proof (prove)\nusing this:\n  pseudo_divmod (map_poly hom ?p) (map_poly hom ?q) =\n  map_prod (map_poly hom) (map_poly hom) (pseudo_divmod ?p ?q)\n\ngoal (1 subgoal):\n 1. pseudo_mod (map_poly hom p) (map_poly hom q) =\n    map_poly hom (pseudo_mod p q)", "unfolding pseudo_mod_def"], ["proof (prove)\nusing this:\n  pseudo_divmod (map_poly hom ?p) (map_poly hom ?q) =\n  map_prod (map_poly hom) (map_poly hom) (pseudo_divmod ?p ?q)\n\ngoal (1 subgoal):\n 1. snd (pseudo_divmod (map_poly hom p) (map_poly hom q)) =\n    map_poly hom (snd (pseudo_divmod p q))", "by auto"], ["", "lemma(in idom_hom) map_poly_pderiv[hom_distribs]:\n  \"map_poly hom (pderiv p) = pderiv (map_poly hom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (pderiv p) = pderiv (map_poly hom p)", "proof (induct p rule: pderiv.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (p \\<noteq> 0 \\<Longrightarrow>\n        map_poly hom (pderiv p) = pderiv (map_poly hom p)) \\<Longrightarrow>\n       map_poly hom (pderiv (pCons a p)) = pderiv (map_poly hom (pCons a p))", "case (1 a p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  map_poly hom (pderiv p) = pderiv (map_poly hom p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (p \\<noteq> 0 \\<Longrightarrow>\n        map_poly hom (pderiv p) = pderiv (map_poly hom p)) \\<Longrightarrow>\n       map_poly hom (pderiv (pCons a p)) = pderiv (map_poly hom (pCons a p))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  map_poly hom (pderiv p) = pderiv (map_poly hom p)", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  map_poly hom (pderiv p) = pderiv (map_poly hom p)\n\ngoal (1 subgoal):\n 1. map_poly hom (pderiv (pCons a p)) = pderiv (map_poly hom (pCons a p))", "unfolding pderiv.simps map_poly_pCons_hom"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  map_poly hom (pderiv p) = pderiv (map_poly hom p)\n\ngoal (1 subgoal):\n 1. map_poly hom (if p = 0 then 0 else p + pCons (0::'a) (pderiv p)) =\n    (if map_poly hom p = 0 then 0\n     else map_poly hom p + pCons (0::'b) (pderiv (map_poly hom p)))", "by (cases \"p = 0\", auto simp: hom_distribs)"], ["proof (state)\nthis:\n  map_poly hom (pderiv (pCons a p)) = pderiv (map_poly hom (pCons a p))\n\ngoal:\nNo subgoals!", "qed"], ["", "context field_hom\nbegin"], ["", "lemma map_poly_pdivmod[hom_distribs]:\n  \"map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "let ?mp = \"map_poly hom\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "interpret map_poly_hom: map_poly_idom_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_idom_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "obtain r s where dm: \"(p div q, p mod q) = (r, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r s.\n        (p div q, p mod q) = (r, s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (p div q, p mod q) = (r, s)\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "hence r: \"r = p div q\" and s: \"s = p mod q\""], ["proof (prove)\nusing this:\n  (p div q, p mod q) = (r, s)\n\ngoal (1 subgoal):\n 1. r = p div q &&& s = p mod q", "by simp_all"], ["proof (state)\nthis:\n  r = p div q\n  s = p mod q\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "from dm [folded pdivmod_pdivmodrel]"], ["proof (chain)\npicking this:\n  eucl_rel_poly p q (r, s)", "have \"eucl_rel_poly p q (r, s)\""], ["proof (prove)\nusing this:\n  eucl_rel_poly p q (r, s)\n\ngoal (1 subgoal):\n 1. eucl_rel_poly p q (r, s)", "by auto"], ["proof (state)\nthis:\n  eucl_rel_poly p q (r, s)\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "from this[unfolded eucl_rel_poly_iff]"], ["proof (chain)\npicking this:\n  p = r * q + s \\<and>\n  (if q = 0 then r = 0 else s = 0 \\<or> degree s < degree q)", "have eq: \"p = r * q + s\" and cond: \"(if q = 0 then r = 0 else s = 0 \\<or> degree s < degree q)\""], ["proof (prove)\nusing this:\n  p = r * q + s \\<and>\n  (if q = 0 then r = 0 else s = 0 \\<or> degree s < degree q)\n\ngoal (1 subgoal):\n 1. p = r * q + s &&&\n    if q = 0 then r = 0 else s = 0 \\<or> degree s < degree q", "by auto"], ["proof (state)\nthis:\n  p = r * q + s\n  if q = 0 then r = 0 else s = 0 \\<or> degree s < degree q\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "from arg_cong[OF eq, of ?mp, unfolded map_poly_add]"], ["proof (chain)\npicking this:\n  map_poly hom p = map_poly hom (r * q + s)", "have eq: \"?mp p = ?mp q * ?mp r + ?mp s\""], ["proof (prove)\nusing this:\n  map_poly hom p = map_poly hom (r * q + s)\n\ngoal (1 subgoal):\n 1. map_poly hom p = map_poly hom q * map_poly hom r + map_poly hom s", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  map_poly hom p = map_poly hom q * map_poly hom r + map_poly hom s\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "from cond"], ["proof (chain)\npicking this:\n  if q = 0 then r = 0 else s = 0 \\<or> degree s < degree q", "have cond: \"(if ?mp q = 0 then ?mp r = 0 else ?mp s = 0 \\<or> degree (?mp s) < degree (?mp q))\""], ["proof (prove)\nusing this:\n  if q = 0 then r = 0 else s = 0 \\<or> degree s < degree q\n\ngoal (1 subgoal):\n 1. if map_poly hom q = 0 then map_poly hom r = 0\n    else map_poly hom s = 0 \\<or>\n         degree (map_poly hom s) < degree (map_poly hom q)", "by simp"], ["proof (state)\nthis:\n  if map_poly hom q = 0 then map_poly hom r = 0\n  else map_poly hom s = 0 \\<or>\n       degree (map_poly hom s) < degree (map_poly hom q)\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "from eq cond"], ["proof (chain)\npicking this:\n  map_poly hom p = map_poly hom q * map_poly hom r + map_poly hom s\n  if map_poly hom q = 0 then map_poly hom r = 0\n  else map_poly hom s = 0 \\<or>\n       degree (map_poly hom s) < degree (map_poly hom q)", "have \"eucl_rel_poly (?mp p) (?mp q) (?mp r, ?mp s)\""], ["proof (prove)\nusing this:\n  map_poly hom p = map_poly hom q * map_poly hom r + map_poly hom s\n  if map_poly hom q = 0 then map_poly hom r = 0\n  else map_poly hom s = 0 \\<or>\n       degree (map_poly hom s) < degree (map_poly hom q)\n\ngoal (1 subgoal):\n 1. eucl_rel_poly (map_poly hom p) (map_poly hom q)\n     (map_poly hom r, map_poly hom s)", "unfolding eucl_rel_poly_iff"], ["proof (prove)\nusing this:\n  map_poly hom p = map_poly hom q * map_poly hom r + map_poly hom s\n  if map_poly hom q = 0 then map_poly hom r = 0\n  else map_poly hom s = 0 \\<or>\n       degree (map_poly hom s) < degree (map_poly hom q)\n\ngoal (1 subgoal):\n 1. map_poly hom p = map_poly hom r * map_poly hom q + map_poly hom s \\<and>\n    (if map_poly hom q = 0 then map_poly hom r = 0\n     else map_poly hom s = 0 \\<or>\n          degree (map_poly hom s) < degree (map_poly hom q))", "by auto"], ["proof (state)\nthis:\n  eucl_rel_poly (map_poly hom p) (map_poly hom q)\n   (map_poly hom r, map_poly hom s)\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "from this[unfolded pdivmod_pdivmodrel]"], ["proof (chain)\npicking this:\n  (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q) =\n  (map_poly hom r, map_poly hom s)", "show ?thesis"], ["proof (prove)\nusing this:\n  (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q) =\n  (map_poly hom r, map_poly hom s)\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "unfolding dm prod.simps"], ["proof (prove)\nusing this:\n  map_poly hom p div map_poly hom q = map_poly hom r \\<and>\n  map_poly hom p mod map_poly hom q = map_poly hom s\n\ngoal (1 subgoal):\n 1. map_prod (map_poly hom) (map_poly hom) (r, s) =\n    (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)", "by simp"], ["proof (state)\nthis:\n  map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n  (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_div[hom_distribs]: \"map_poly hom (p div q) = map_poly hom p div map_poly hom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (p div q) = map_poly hom p div map_poly hom q", "using map_poly_pdivmod[of p q]"], ["proof (prove)\nusing this:\n  map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n  (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)\n\ngoal (1 subgoal):\n 1. map_poly hom (p div q) = map_poly hom p div map_poly hom q", "by simp"], ["", "lemma map_poly_mod[hom_distribs]: \"map_poly hom (p mod q) = map_poly hom p mod map_poly hom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (p mod q) = map_poly hom p mod map_poly hom q", "using map_poly_pdivmod[of p q]"], ["proof (prove)\nusing this:\n  map_prod (map_poly hom) (map_poly hom) (p div q, p mod q) =\n  (map_poly hom p div map_poly hom q, map_poly hom p mod map_poly hom q)\n\ngoal (1 subgoal):\n 1. map_poly hom (p mod q) = map_poly hom p mod map_poly hom q", "by simp"], ["", "end"], ["", "locale field_hom' = field_hom hom\n  for hom :: \"'a :: {field_gcd} \\<Rightarrow> 'b :: {field_gcd}\"\nbegin"], ["", "lemma map_poly_normalize[hom_distribs]: \"map_poly hom (normalize p) = normalize (map_poly hom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (normalize p) = normalize (map_poly hom p)", "by (simp add: normalize_poly_def hom_distribs)"], ["", "lemma map_poly_gcd[hom_distribs]: \"map_poly hom (gcd p q) = gcd (map_poly hom p) (map_poly hom q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (gcd p q) = gcd (map_poly hom p) (map_poly hom q)", "by (induct p q rule: eucl_induct)\n    (simp_all add: map_poly_normalize ac_simps hom_distribs)"], ["", "end"], ["", "definition div_poly :: \"'a :: euclidean_semiring \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\" where\n  \"div_poly a p = map_poly (\\<lambda> c. c div a) p\""], ["", "lemma smult_div_poly: assumes \"\\<And> c. c \\<in> set (coeffs p) \\<Longrightarrow> a dvd c\"\n  shows \"smult a (div_poly a p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a (div_poly a p) = p", "unfolding smult_as_map_poly div_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly ((*) a) (map_poly (\\<lambda>c. c div a) p) = p", "by (subst map_poly_map_poly, force, subst map_poly_idI, insert assms, auto)"], ["", "lemma coeff_div_poly: \"coeff (div_poly a f) n = coeff f n div a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (div_poly a f) n = coeff f n div a", "unfolding div_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (map_poly (\\<lambda>c. c div a) f) n = coeff f n div a", "by (rule coeff_map_poly, auto)"], ["", "locale map_poly_inj_idom_divide_hom = base: inj_idom_divide_hom\nbegin"], ["", "sublocale map_poly_idom_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_idom_hom hom", ".."], ["", "sublocale map_poly_inj_zero_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom hom", ".."], ["", "sublocale inj_idom_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom (map_poly hom)", ".."], ["", "lemma divide_poly_main_hom: defines \"hh \\<equiv> map_poly hom\" \n  shows \"hh (divide_poly_main lc f g h i j) = divide_poly_main (hom lc) (hh f) (hh g) (hh h) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hh (divide_poly_main lc f g h i j) =\n    divide_poly_main (hom lc) (hh f) (hh g) (hh h) i j", "unfolding hh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (divide_poly_main lc f g h i j) =\n    divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n     (map_poly hom h) i j", "proof (induct j arbitrary: lc f g h i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lc f g h i.\n       map_poly hom (divide_poly_main lc f g h i 0) =\n       divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n        (map_poly hom h) i 0\n 2. \\<And>j lc f g h i.\n       (\\<And>lc f g h i.\n           map_poly hom (divide_poly_main lc f g h i j) =\n           divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n            (map_poly hom h) i j) \\<Longrightarrow>\n       map_poly hom (divide_poly_main lc f g h i (Suc j)) =\n       divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n        (map_poly hom h) i (Suc j)", "case (Suc j lc f g h i)"], ["proof (state)\nthis:\n  map_poly hom (divide_poly_main ?lc ?f ?g ?h ?i j) =\n  divide_poly_main (hom ?lc) (map_poly hom ?f) (map_poly hom ?g)\n   (map_poly hom ?h) ?i j\n\ngoal (2 subgoals):\n 1. \\<And>lc f g h i.\n       map_poly hom (divide_poly_main lc f g h i 0) =\n       divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n        (map_poly hom h) i 0\n 2. \\<And>j lc f g h i.\n       (\\<And>lc f g h i.\n           map_poly hom (divide_poly_main lc f g h i j) =\n           divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n            (map_poly hom h) i j) \\<Longrightarrow>\n       map_poly hom (divide_poly_main lc f g h i (Suc j)) =\n       divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n        (map_poly hom h) i (Suc j)", "let ?h = \"map_poly hom\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lc f g h i.\n       map_poly hom (divide_poly_main lc f g h i 0) =\n       divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n        (map_poly hom h) i 0\n 2. \\<And>j lc f g h i.\n       (\\<And>lc f g h i.\n           map_poly hom (divide_poly_main lc f g h i j) =\n           divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n            (map_poly hom h) i j) \\<Longrightarrow>\n       map_poly hom (divide_poly_main lc f g h i (Suc j)) =\n       divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n        (map_poly hom h) i (Suc j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (divide_poly_main lc f g h i (Suc j)) =\n    divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n     (map_poly hom h) i (Suc j)", "unfolding divide_poly_main.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom\n     (if False \\<or> coeff g i div lc * lc = coeff g i\n      then divide_poly_main lc (f + monom (coeff g i div lc) j)\n            (g - monom (coeff g i div lc) j * h) h (i - 1) j\n      else 0) =\n    (if False \\<or>\n        coeff (map_poly hom g) i div hom lc * hom lc =\n        coeff (map_poly hom g) i\n     then divide_poly_main (hom lc)\n           (map_poly hom f + monom (coeff (map_poly hom g) i div hom lc) j)\n           (map_poly hom g -\n            monom (coeff (map_poly hom g) i div hom lc) j * map_poly hom h)\n           (map_poly hom h) (i - 1) j\n     else 0)", "unfolding base.coeff_map_poly_hom base.hom_div[symmetric] base.hom_mult[symmetric] base.eq_iff\n      if_distrib[of ?h] hom_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if False \\<or> coeff g i div lc * lc = coeff g i\n     then map_poly hom\n           (divide_poly_main lc (f + monom (coeff g i div lc) j)\n             (g - monom (coeff g i div lc) j * h) h (i - 1) j)\n     else 0) =\n    (if False \\<or> coeff g i div lc * lc = coeff g i\n     then divide_poly_main (hom lc)\n           (map_poly hom f + monom (hom (coeff g i div lc)) j)\n           (map_poly hom g -\n            monom (hom (coeff g i div lc)) j * map_poly hom h)\n           (map_poly hom h) (i - 1) j\n     else 0)", "by (rule if_cong[OF refl _ refl], subst Suc, simp add: hom_minus hom_add hom_mult)"], ["proof (state)\nthis:\n  map_poly hom (divide_poly_main lc f g h i (Suc j)) =\n  divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n   (map_poly hom h) i (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>lc f g h i.\n       map_poly hom (divide_poly_main lc f g h i 0) =\n       divide_poly_main (hom lc) (map_poly hom f) (map_poly hom g)\n        (map_poly hom h) i 0", "qed simp"], ["", "sublocale inj_idom_divide_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_divide_hom (map_poly hom)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. map_poly hom (x div y) = map_poly hom x div map_poly hom y", "fix f g :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. map_poly hom (x div y) = map_poly hom x div map_poly hom y", "let ?h = \"map_poly hom\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. map_poly hom (x div y) = map_poly hom x div map_poly hom y", "show \"?h (f div g) = (?h f) div (?h g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (f div g) = map_poly hom f div map_poly hom g", "unfolding divide_poly_def if_distrib[of ?h]\n    divide_poly_main_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if g = 0 then map_poly hom 0\n     else divide_poly_main (hom (lead_coeff g)) (map_poly hom 0)\n           (map_poly hom f) (map_poly hom g) (degree f)\n           (1 + length (coeffs f) - length (coeffs g))) =\n    (if map_poly hom g = 0 then 0\n     else divide_poly_main (lead_coeff (map_poly hom g)) 0 (map_poly hom f)\n           (map_poly hom g) (degree (map_poly hom f))\n           (1 + length (coeffs (map_poly hom f)) -\n            length (coeffs (map_poly hom g))))", "by simp"], ["proof (state)\nthis:\n  map_poly hom (f div g) = map_poly hom f div map_poly hom g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_hom: \"order (hom x) (map_poly hom f) = order x f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (hom x) (map_poly hom f) = order x f", "unfolding Polynomial.order_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. \\<not> [:- hom x, 1::'b:] ^ Suc n dvd map_poly hom f) =\n    (LEAST n. \\<not> [:- x, 1::'a:] ^ Suc n dvd f)", "unfolding hom_dvd_iff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. \\<not> [:- hom x, 1::'b:] ^ Suc n dvd map_poly hom f) =\n    (LEAST n.\n        \\<not> map_poly hom ([:- x, 1::'a:] ^ Suc n) dvd map_poly hom f)", "unfolding hom_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. \\<not> [:- hom x, 1::'b:] ^ Suc n dvd map_poly hom f) =\n    (LEAST n. \\<not> map_poly hom [:- x, 1::'a:] ^ Suc n dvd map_poly hom f)", "by (simp add: base.hom_uminus)"], ["", "end"], ["", "subsection \\<open>Example Interpretations\\<close>"], ["", "abbreviation \"of_int_poly \\<equiv> map_poly of_int\""], ["", "interpretation of_int_poly_hom: map_poly_comm_semiring_hom of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_semiring_hom of_int", ".."], ["", "interpretation of_int_poly_hom: map_poly_comm_ring_hom of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom of_int", ".."], ["", "interpretation of_int_poly_hom: map_poly_idom_hom of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_idom_hom of_int", ".."], ["", "interpretation of_int_poly_hom:\n  map_poly_inj_comm_ring_hom \"of_int :: int  \\<Rightarrow> 'a :: {comm_ring_1,ring_char_0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom of_int", ".."], ["", "interpretation of_int_poly_hom:\n  map_poly_inj_idom_hom \"of_int :: int  \\<Rightarrow> 'a :: {idom,ring_char_0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_hom of_int", ".."], ["", "text \\<open>The following operations are homomorphic w.r.t. only @{class monoid_add}.\\<close>"], ["", "interpretation pCons_0_hom: injective \"pCons 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (pCons (0::'a))", "by (unfold_locales, auto)"], ["", "interpretation pCons_0_hom: zero_hom_0 \"pCons 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom_0 (pCons (0::'a))", "by (unfold_locales, auto)"], ["", "interpretation pCons_0_hom: inj_comm_monoid_add_hom \"pCons 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_add_hom (pCons (0::'a))", "by (unfold_locales, auto)"], ["", "interpretation pCons_0_hom: inj_ab_group_add_hom \"pCons 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ab_group_add_hom (pCons (0::'a))", "by (unfold_locales, auto)"], ["", "interpretation monom_hom: injective \"\\<lambda>x. monom x d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (\\<lambda>x. monom x d)", "by (unfold_locales, auto)"], ["", "interpretation monom_hom: inj_monoid_add_hom \"\\<lambda>x. monom x d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_monoid_add_hom (\\<lambda>x. monom x d)", "by (unfold_locales, auto simp: add_monom)"], ["", "interpretation monom_hom: inj_comm_monoid_add_hom \"\\<lambda>x. monom x d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_add_hom (\\<lambda>x. monom x d)", ".."], ["", "end"]]}