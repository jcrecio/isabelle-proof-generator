{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Missing_Unsorted.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma bernoulli_inequality: assumes x: \"-1 \\<le> (x :: 'a :: linordered_field)\"\n  shows \"1 + of_nat n * x \\<le> (1 + x) ^ n\"", "lemma pow_one: \"b ^ x \\<le> 1\"", "lemma pow_zero: \"0 < b ^ x\"", "lemma exp_tends_to_zero: assumes c: \"c > 0\"\n  shows \"\\<exists> x. b ^ x \\<le> c\"", "lemma linear_exp_bound: \"\\<exists> p. \\<forall> x. b ^ x * of_nat x \\<le> p\"", "lemma poly_exp_bound: \"\\<exists> p. \\<forall> x. b ^ x * of_nat x ^ deg \\<le> p\"", "lemma prod_list_replicate[simp]: \"prod_list (replicate n a) = a ^ n\"", "lemma prod_list_power: fixes xs :: \"'a :: comm_monoid_mult list\"\n  shows \"prod_list xs ^ n = (\\<Prod>x\\<leftarrow>xs. x ^ n)\"", "lemma set_upt_Suc: \"{0 ..< Suc i} = insert i {0 ..< i}\"", "lemma prod_pow[simp]: \"(\\<Prod>i = 0..<n. p) = (p :: 'a :: comm_monoid_mult) ^ n\"", "lemma dvd_abs_mult_left_int [simp]:\n  \"\\<bar>a\\<bar> * y dvd x \\<longleftrightarrow> a * y dvd x\" for x y a :: int", "lemma gcd_abs_mult_right_int [simp]:\n  \"gcd x (\\<bar>a\\<bar> * y) = gcd x (a * y)\" for x y a :: int", "lemma lcm_abs_mult_right_int [simp]:\n  \"lcm x (\\<bar>a\\<bar> * y) = lcm x (a * y)\" for x y a :: int", "lemma gcd_abs_mult_left_int [simp]:\n  \"gcd x (a * \\<bar>y\\<bar>) = gcd x (a * y)\" for x y a :: int", "lemma lcm_abs_mult_left_int [simp]:\n  \"lcm x (a * \\<bar>y\\<bar>) = lcm x (a * y)\" for x y a :: int", "lemma list_gcd_simps: \"list_gcd [] = 0\" \"list_gcd (x # xs) = gcd x (list_gcd xs)\"", "lemma list_gcd: \"x \\<in> set xs \\<Longrightarrow> list_gcd xs dvd x\"", "lemma list_gcd_greatest: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> y dvd x) \\<Longrightarrow> y dvd (list_gcd xs)\"", "lemma list_gcd_mult_int [simp]: \n  fixes xs :: \"int list\"\n  shows \"list_gcd (map (times a) xs) = \\<bar>a\\<bar> * list_gcd xs\"", "lemma list_lcm_simps: \"list_lcm [] = 1\" \"list_lcm (x # xs) = lcm x (list_lcm xs)\"", "lemma list_lcm: \"x \\<in> set xs \\<Longrightarrow> x dvd list_lcm xs\"", "lemma list_lcm_least: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> x dvd y) \\<Longrightarrow> list_lcm xs dvd y\"", "lemma lcm_mult_distrib_nat: \"(k :: nat) * lcm m n = lcm (k * m) (k * n)\"", "lemma lcm_mult_distrib_int: \"abs (k::int) * lcm m n = lcm (k * m) (k * n)\"", "lemma list_lcm_mult_int [simp]:\n  fixes xs :: \"int list\"\n  shows \"list_lcm (map (times a) xs) = (if xs = [] then 1 else \\<bar>a\\<bar> * list_lcm xs)\"", "lemma list_lcm_pos:\n  \"list_lcm xs \\<ge> (0 :: int)\"\n  \"0 \\<notin> set xs \\<Longrightarrow> list_lcm xs \\<noteq> 0\"\n  \"0 \\<notin> set xs \\<Longrightarrow> list_lcm xs > 0\"", "lemma quotient_of_nonzero: \"snd (quotient_of r) > 0\" \"snd (quotient_of r) \\<noteq> 0\"", "lemma quotient_of_int_div: assumes q: \"quotient_of (of_int x / of_int y) = (a, b)\"\n  and y: \"y \\<noteq> 0\" \n  shows \"\\<exists> z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z\"", "lemma max_list_non_empty: \"x \\<in> set xs \\<Longrightarrow> x \\<le> max_list_non_empty xs\"", "lemma cnj_reals[simp]: \"(cnj c \\<in> \\<real>) = (c \\<in> \\<real>)\"", "lemma sgn_real_mono: \"x \\<le> y \\<Longrightarrow> sgn x \\<le> sgn (y :: real)\"", "lemma sgn_minus_rat: \"sgn (- (x :: rat)) = - sgn x\"", "lemma real_of_rat_sgn: \"sgn (of_rat x) = real_of_rat (sgn x)\"", "lemma inverse_le_iff_sgn: assumes sgn: \"sgn x = sgn y\"\n  shows \"(inverse (x :: real) \\<le> inverse y) = (y \\<le> x)\"", "lemma inverse_le_sgn: assumes sgn: \"sgn x = sgn y\" and xy: \"x \\<le> (y :: real)\"\n  shows \"inverse y \\<le> inverse x\"", "lemma set_list_update: \"set (xs [i := k]) = \n  (if i < length xs then insert k (set (take i xs) \\<union> set (drop (Suc i) xs)) else set xs)\"", "lemma prod_list_dvd: assumes \"(x :: 'a :: comm_monoid_mult) \\<in> set xs\"\n  shows \"x dvd prod_list xs\"", "lemma dvd_prod: \nfixes A::\"'b set\" \nassumes \"\\<exists>b\\<in>A. a dvd f b\" \"finite A\"\nshows \"a dvd prod f A\"", "lemma prod_list_filter: \"prod_list (filter f xs) * prod_list (filter (\\<lambda> x. \\<not> f x) xs) = prod_list xs\"", "lemma prod_list_partition: assumes \"partition f xs = (ys, zs)\"\n  shows \"prod_list xs = prod_list ys * prod_list zs\"", "lemma dvd_imp_mult_div_cancel_left[simp]:\n  assumes \"(a :: 'a :: semidom_divide) dvd b\"\n  shows \"a * (b div a) = b\"", "lemma (in semidom) prod_list_zero_iff[simp]: \n  \"prod_list xs = 0 \\<longleftrightarrow> 0 \\<in> set xs\"", "lemma unit_prod [intro]:\n  shows \"a dvd 1 \\<Longrightarrow> b dvd 1 \\<Longrightarrow> (a * b) dvd 1\"", "lemma is_unit_mult_iff[simp]:\n  shows \"(a * b) dvd 1 \\<longleftrightarrow> a dvd 1 \\<and> b dvd 1\"", "lemma irreducibleE[elim]:\n  assumes \"irreducible p\"\n      and \"p \\<noteq> 0 \\<Longrightarrow> \\<not> p dvd 1 \\<Longrightarrow> (\\<And>a b. p = a * b \\<Longrightarrow> a dvd 1 \\<or> b dvd 1) \\<Longrightarrow> thesis\"\n  shows thesis", "lemma not_irreducibleE:\n  assumes \"\\<not> irreducible x\"\n      and \"x = 0 \\<Longrightarrow> thesis\"\n      and \"x dvd 1 \\<Longrightarrow> thesis\"\n      and \"\\<And>a b. x = a * b \\<Longrightarrow> \\<not> a dvd 1 \\<Longrightarrow> \\<not> b dvd 1 \\<Longrightarrow> thesis\"\n  shows thesis", "lemma prime_elem_dvd_prod_list:\n  assumes p: \"prime_elem p\" and pA: \"p dvd prod_list A\" shows \"\\<exists>a \\<in> set A. p dvd a\"", "lemma prime_elem_dvd_prod_mset:\n  assumes p: \"prime_elem p\" and pA: \"p dvd prod_mset A\" shows \"\\<exists>a \\<in># A. p dvd a\"", "lemma mult_unit_dvd_iff[simp]:\n  assumes \"b dvd 1\"\n  shows \"a * b dvd c \\<longleftrightarrow> a dvd c\"", "lemma mult_unit_dvd_iff'[simp]: \"a dvd 1 \\<Longrightarrow> (a * b) dvd c \\<longleftrightarrow> b dvd c\"", "lemma irreducibleD':\n  assumes \"irreducible a\" \"b dvd a\"\n  shows   \"a dvd b \\<or> b dvd 1\"", "lemma dvd_times_left_cancel_iff [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"a * b dvd a * c \\<longleftrightarrow> b dvd c\"\n    (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma dvd_times_right_cancel_iff [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"b * a dvd c * a \\<longleftrightarrow> b dvd c\"", "lemma irreducibleI':\n  assumes \"a \\<noteq> 0\" \"\\<not> a dvd 1\" \"\\<And>b. b dvd a \\<Longrightarrow> a dvd b \\<or> b dvd 1\"\n  shows   \"irreducible a\"", "lemma irreducible_altdef:\n  shows \"irreducible x \\<longleftrightarrow> x \\<noteq> 0 \\<and> \\<not> x dvd 1 \\<and> (\\<forall>b. b dvd x \\<longrightarrow> x dvd b \\<or> b dvd 1)\"", "lemma dvd_mult_unit_iff:\n  assumes b: \"b dvd 1\"\n  shows \"a dvd c * b \\<longleftrightarrow> a dvd c\"", "lemma dvd_mult_unit_iff': \"b dvd 1 \\<Longrightarrow> a dvd b * c \\<longleftrightarrow> a dvd c\"", "lemma irreducible_mult_unit_left:\n  shows \"a dvd 1 \\<Longrightarrow> irreducible (a * p) \\<longleftrightarrow> irreducible p\"", "lemma irreducible_mult_unit_right:\n  shows \"a dvd 1 \\<Longrightarrow> irreducible (p * a) \\<longleftrightarrow> irreducible p\"", "lemma prime_elem_imp_irreducible:\n  assumes \"prime_elem p\"\n  shows   \"irreducible p\"", "lemma unit_imp_dvd [dest]: \"b dvd 1 \\<Longrightarrow> b dvd a\"", "lemma unit_mult_left_cancel: \"a dvd 1 \\<Longrightarrow> a * b = a * c \\<longleftrightarrow> b = c\"", "lemma unit_mult_right_cancel: \"a dvd 1 \\<Longrightarrow> b * a = c * a \\<longleftrightarrow> b = c\"", "lemma irreducible_multD:\n  assumes l: \"irreducible (a*b)\"\n  shows \"a dvd 1 \\<and> irreducible b \\<or> b dvd 1 \\<and> irreducible a\"", "lemma (in field) irreducible_field[simp]:\n  \"irreducible x \\<longleftrightarrow> False\"", "lemma (in idom) irreducible_mult:\n  shows \"irreducible (a*b) \\<longleftrightarrow> a dvd 1 \\<and> irreducible b \\<or> b dvd 1 \\<and> irreducible a\""], "translations": [["", "lemma bernoulli_inequality: assumes x: \"-1 \\<le> (x :: 'a :: linordered_field)\"\n  shows \"1 + of_nat n * x \\<le> (1 + x) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "have \"1 + of_nat (Suc n) * x = 1 + x + of_nat n * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + of_nat (Suc n) * x = (1::'a) + x + of_nat n * x", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (1::'a) + of_nat (Suc n) * x = (1::'a) + x + of_nat n * x\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "also"], ["proof (state)\nthis:\n  (1::'a) + of_nat (Suc n) * x = (1::'a) + x + of_nat n * x\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "have \"\\<dots> \\<le> \\<dots> + of_nat n * x ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + x + of_nat n * x\n    \\<le> (1::'a) + x + of_nat n * x + of_nat n * x\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (1::'a) + x + of_nat n * x\n  \\<le> (1::'a) + x + of_nat n * x + of_nat n * x\\<^sup>2\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "also"], ["proof (state)\nthis:\n  (1::'a) + x + of_nat n * x\n  \\<le> (1::'a) + x + of_nat n * x + of_nat n * x\\<^sup>2\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "have \"\\<dots> = (1 + of_nat n * x) * (1 + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + x + of_nat n * x + of_nat n * x\\<^sup>2 =\n    ((1::'a) + of_nat n * x) * ((1::'a) + x)", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  (1::'a) + x + of_nat n * x + of_nat n * x\\<^sup>2 =\n  ((1::'a) + of_nat n * x) * ((1::'a) + x)\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "also"], ["proof (state)\nthis:\n  (1::'a) + x + of_nat n * x + of_nat n * x\\<^sup>2 =\n  ((1::'a) + of_nat n * x) * ((1::'a) + x)\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "have \"\\<dots> \\<le> (1 + x) ^ n * (1 + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) + of_nat n * x) * ((1::'a) + x)\n    \\<le> ((1::'a) + x) ^ n * ((1::'a) + x)", "by (rule mult_right_mono[OF Suc], insert x, auto)"], ["proof (state)\nthis:\n  ((1::'a) + of_nat n * x) * ((1::'a) + x)\n  \\<le> ((1::'a) + x) ^ n * ((1::'a) + x)\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "also"], ["proof (state)\nthis:\n  ((1::'a) + of_nat n * x) * ((1::'a) + x)\n  \\<le> ((1::'a) + x) ^ n * ((1::'a) + x)\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "have \"\\<dots> = (1 + x) ^ (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) + x) ^ n * ((1::'a) + x) = ((1::'a) + x) ^ Suc n", "by simp"], ["proof (state)\nthis:\n  ((1::'a) + x) ^ n * ((1::'a) + x) = ((1::'a) + x) ^ Suc n\n\ngoal (2 subgoals):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0\n 2. \\<And>n.\n       (1::'a) + of_nat n * x \\<le> ((1::'a) + x) ^ n \\<Longrightarrow>\n       (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "finally"], ["proof (chain)\npicking this:\n  (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "show ?case"], ["proof (prove)\nusing this:\n  (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n\n\ngoal (1 subgoal):\n 1. (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n", "."], ["proof (state)\nthis:\n  (1::'a) + of_nat (Suc n) * x \\<le> ((1::'a) + x) ^ Suc n\n\ngoal (1 subgoal):\n 1. (1::'a) + of_nat 0 * x \\<le> ((1::'a) + x) ^ 0", "qed simp"], ["", "context\n  fixes b :: \"'a :: archimedean_field\"\n  assumes b: \"0 < b\" \"b < 1\"\nbegin"], ["", "private"], ["", "lemma pow_one: \"b ^ x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ x \\<le> (1::'a)", "using power_Suc_less_one[OF b, of \"x - 1\"]"], ["proof (prove)\nusing this:\n  b ^ Suc (x - 1) < (1::'a)\n\ngoal (1 subgoal):\n 1. b ^ x \\<le> (1::'a)", "by (cases x, auto)"], ["", "private"], ["", "lemma pow_zero: \"0 < b ^ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < b ^ x", "using b(1)"], ["proof (prove)\nusing this:\n  (0::'a) < b\n\ngoal (1 subgoal):\n 1. (0::'a) < b ^ x", "by simp"], ["", "lemma exp_tends_to_zero: assumes c: \"c > 0\"\n  shows \"\\<exists> x. b ^ x \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. b ^ x \\<le> c", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "assume not: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>x. b ^ x \\<le> c\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "define bb where \"bb = inverse b\""], ["proof (state)\nthis:\n  bb = inverse b\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "define cc where \"cc = inverse c\""], ["proof (state)\nthis:\n  cc = inverse c\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "from b"], ["proof (chain)\npicking this:\n  (0::'a) < b\n  b < (1::'a)", "have bb: \"bb > 1\""], ["proof (prove)\nusing this:\n  (0::'a) < b\n  b < (1::'a)\n\ngoal (1 subgoal):\n 1. (1::'a) < bb", "unfolding bb_def"], ["proof (prove)\nusing this:\n  (0::'a) < b\n  b < (1::'a)\n\ngoal (1 subgoal):\n 1. (1::'a) < inverse b", "by (rule one_less_inverse)"], ["proof (state)\nthis:\n  (1::'a) < bb\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "from c"], ["proof (chain)\npicking this:\n  (0::'a) < c", "have cc: \"cc > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < c\n\ngoal (1 subgoal):\n 1. (0::'a) < cc", "unfolding cc_def"], ["proof (prove)\nusing this:\n  (0::'a) < c\n\ngoal (1 subgoal):\n 1. (0::'a) < inverse c", "by simp"], ["proof (state)\nthis:\n  (0::'a) < cc\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "define bbb where \"bbb = bb - 1\""], ["proof (state)\nthis:\n  bbb = bb - (1::'a)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "have id: \"bb = 1 + bbb\" and bbb: \"bbb > 0\" and bm1: \"bbb \\<ge> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb = (1::'a) + bbb &&& (0::'a) < bbb &&& - (1::'a) \\<le> bbb", "unfolding bbb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bb = (1::'a) + (bb - (1::'a)) &&&\n    (0::'a) < bb - (1::'a) &&& - (1::'a) \\<le> bb - (1::'a)", "using bb"], ["proof (prove)\nusing this:\n  (1::'a) < bb\n\ngoal (1 subgoal):\n 1. bb = (1::'a) + (bb - (1::'a)) &&&\n    (0::'a) < bb - (1::'a) &&& - (1::'a) \\<le> bb - (1::'a)", "by auto"], ["proof (state)\nthis:\n  bb = (1::'a) + bbb\n  (0::'a) < bbb\n  - (1::'a) \\<le> bbb\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "have \"\\<exists> n. cc / bbb < of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. cc / bbb < of_nat n", "by (rule reals_Archimedean2)"], ["proof (state)\nthis:\n  \\<exists>n. cc / bbb < of_nat n\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. cc / bbb < of_nat n", "obtain n where lt: \"cc / bbb < of_nat n\""], ["proof (prove)\nusing this:\n  \\<exists>n. cc / bbb < of_nat n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        cc / bbb < of_nat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cc / bbb < of_nat n\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "from not"], ["proof (chain)\npicking this:\n  \\<nexists>x. b ^ x \\<le> c", "have \"\\<not> b ^ n \\<le> c\""], ["proof (prove)\nusing this:\n  \\<nexists>x. b ^ x \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> b ^ n \\<le> c", "by auto"], ["proof (state)\nthis:\n  \\<not> b ^ n \\<le> c\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "hence bnc: \"b ^ n > c\""], ["proof (prove)\nusing this:\n  \\<not> b ^ n \\<le> c\n\ngoal (1 subgoal):\n 1. c < b ^ n", "by simp"], ["proof (state)\nthis:\n  c < b ^ n\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "have \"bb ^ n = inverse (b ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb ^ n = inverse (b ^ n)", "unfolding bb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse b ^ n = inverse (b ^ n)", "by (rule power_inverse)"], ["proof (state)\nthis:\n  bb ^ n = inverse (b ^ n)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  bb ^ n = inverse (b ^ n)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "have \"\\<dots> < cc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (b ^ n) < cc", "unfolding cc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (b ^ n) < inverse c", "by (rule less_imp_inverse_less[OF bnc c])"], ["proof (state)\nthis:\n  inverse (b ^ n) < cc\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  inverse (b ^ n) < cc\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "have \"\\<dots> < bbb * of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc < bbb * of_nat n", "using lt bbb"], ["proof (prove)\nusing this:\n  cc / bbb < of_nat n\n  (0::'a) < bbb\n\ngoal (1 subgoal):\n 1. cc < bbb * of_nat n", "by (metis mult.commute pos_divide_less_eq)"], ["proof (state)\nthis:\n  cc < bbb * of_nat n\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  cc < bbb * of_nat n\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "have \"\\<dots> \\<le> bb ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bbb * of_nat n \\<le> bb ^ n", "using bernoulli_inequality[OF bm1, folded id, of n]"], ["proof (prove)\nusing this:\n  (1::'a) + of_nat n * bbb \\<le> bb ^ n\n\ngoal (1 subgoal):\n 1. bbb * of_nat n \\<le> bb ^ n", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  bbb * of_nat n \\<le> bb ^ n\n\ngoal (1 subgoal):\n 1. \\<nexists>x. b ^ x \\<le> c \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  bb ^ n < bb ^ n", "show False"], ["proof (prove)\nusing this:\n  bb ^ n < bb ^ n\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_exp_bound: \"\\<exists> p. \\<forall> x. b ^ x * of_nat x \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "from b"], ["proof (chain)\npicking this:\n  (0::'a) < b\n  b < (1::'a)", "have \"1 - b > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < b\n  b < (1::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < (1::'a) - b", "by simp"], ["proof (state)\nthis:\n  (0::'a) < (1::'a) - b\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "from exp_tends_to_zero[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>x. b ^ x \\<le> (1::'a) - b", "obtain x0 where x0: \"b ^ x0 \\<le> 1 - b\""], ["proof (prove)\nusing this:\n  \\<exists>x. b ^ x \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. (\\<And>x0.\n        b ^ x0 \\<le> (1::'a) - b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  b ^ x0 \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "{"], ["proof (state)\nthis:\n  b ^ x0 \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "assume \"x \\<ge> x0\""], ["proof (state)\nthis:\n  x0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "hence \"\\<exists> y. x = x0 + y\""], ["proof (prove)\nusing this:\n  x0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>y. x = x0 + y", "by arith"], ["proof (state)\nthis:\n  \\<exists>y. x = x0 + y\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. x = x0 + y", "obtain y where x: \"x = x0 + y\""], ["proof (prove)\nusing this:\n  \\<exists>y. x = x0 + y\n\ngoal (1 subgoal):\n 1. (\\<And>y. x = x0 + y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x = x0 + y\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "have \"b ^ x = b ^ x0 * b ^ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ x = b ^ x0 * b ^ y", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ (x0 + y) = b ^ x0 * b ^ y", "by (simp add: power_add)"], ["proof (state)\nthis:\n  b ^ x = b ^ x0 * b ^ y\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "also"], ["proof (state)\nthis:\n  b ^ x = b ^ x0 * b ^ y\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "have \"\\<dots> \\<le> b ^ x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ x0 * b ^ y \\<le> b ^ x0", "using pow_one[of y] pow_zero[of x0]"], ["proof (prove)\nusing this:\n  b ^ y \\<le> (1::'a)\n  (0::'a) < b ^ x0\n\ngoal (1 subgoal):\n 1. b ^ x0 * b ^ y \\<le> b ^ x0", "by auto"], ["proof (state)\nthis:\n  b ^ x0 * b ^ y \\<le> b ^ x0\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "also"], ["proof (state)\nthis:\n  b ^ x0 * b ^ y \\<le> b ^ x0\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "have \"\\<dots> \\<le> 1 - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ x0 \\<le> (1::'a) - b", "by (rule x0)"], ["proof (state)\nthis:\n  b ^ x0 \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "finally"], ["proof (chain)\npicking this:\n  b ^ x \\<le> (1::'a) - b", "have \"b ^ x \\<le> 1 - b\""], ["proof (prove)\nusing this:\n  b ^ x \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. b ^ x \\<le> (1::'a) - b", "."], ["proof (state)\nthis:\n  b ^ x \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "}"], ["proof (state)\nthis:\n  x0 \\<le> ?x2 \\<Longrightarrow> b ^ ?x2 \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "note x0 = this"], ["proof (state)\nthis:\n  x0 \\<le> ?x2 \\<Longrightarrow> b ^ ?x2 \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "define bs where \"bs = insert 1 { b ^ Suc x * of_nat (Suc x) | x . x \\<le> x0}\""], ["proof (state)\nthis:\n  bs = insert (1::'a) {b ^ Suc x * of_nat (Suc x) |x. x \\<le> x0}\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "have bs: \"finite bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite bs", "unfolding bs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (insert (1::'a) {b ^ Suc x * of_nat (Suc x) |x. x \\<le> x0})", "by auto"], ["proof (state)\nthis:\n  finite bs\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "define p where \"p = Max bs\""], ["proof (state)\nthis:\n  p = Max bs\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "have bs: \"\\<And> b. b \\<in> bs \\<Longrightarrow> b \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in> bs \\<Longrightarrow> b \\<le> p", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in> bs \\<Longrightarrow> b \\<le> Max bs", "using bs"], ["proof (prove)\nusing this:\n  finite bs\n\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in> bs \\<Longrightarrow> b \\<le> Max bs", "by simp"], ["proof (state)\nthis:\n  ?b \\<in> bs \\<Longrightarrow> ?b \\<le> p\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "hence p1: \"p \\<ge> 1\""], ["proof (prove)\nusing this:\n  ?b \\<in> bs \\<Longrightarrow> ?b \\<le> p\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> p", "unfolding bs_def"], ["proof (prove)\nusing this:\n  ?b \\<in> insert (1::'a)\n            {b ^ Suc x * of_nat (Suc x) |x. x \\<le> x0} \\<Longrightarrow>\n  ?b \\<le> p\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> p", "by auto"], ["proof (state)\nthis:\n  (1::'a) \\<le> p\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p", "proof (rule exI[of _ p], intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. b ^ x * of_nat x \\<le> p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. b ^ x * of_nat x \\<le> p", "show \"b ^ x * of_nat x \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ x * of_nat x \\<le> p", "proof (induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. b ^ 0 * of_nat 0 \\<le> p\n 2. \\<And>x.\n       b ^ x * of_nat x \\<le> p \\<Longrightarrow>\n       b ^ Suc x * of_nat (Suc x) \\<le> p", "case (Suc x)"], ["proof (state)\nthis:\n  b ^ x * of_nat x \\<le> p\n\ngoal (2 subgoals):\n 1. b ^ 0 * of_nat 0 \\<le> p\n 2. \\<And>x.\n       b ^ x * of_nat x \\<le> p \\<Longrightarrow>\n       b ^ Suc x * of_nat (Suc x) \\<le> p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ Suc x * of_nat (Suc x) \\<le> p", "proof (cases \"x \\<le> x0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p\n 2. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "case True"], ["proof (state)\nthis:\n  x \\<le> x0\n\ngoal (2 subgoals):\n 1. x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p\n 2. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ Suc x * of_nat (Suc x) \\<le> p", "by (rule bs, unfold bs_def, insert True, auto)"], ["proof (state)\nthis:\n  b ^ Suc x * of_nat (Suc x) \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> x0\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "let ?x = \"of_nat x :: 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "have \"b ^ (Suc x) * of_nat (Suc x) = b * (b ^ x * ?x) + b ^ Suc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ Suc x * of_nat (Suc x) = b * (b ^ x * of_nat x) + b ^ Suc x", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  b ^ Suc x * of_nat (Suc x) = b * (b ^ x * of_nat x) + b ^ Suc x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "also"], ["proof (state)\nthis:\n  b ^ Suc x * of_nat (Suc x) = b * (b ^ x * of_nat x) + b ^ Suc x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "have \"\\<dots> \\<le> b * p + b ^ Suc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * (b ^ x * of_nat x) + b ^ Suc x \\<le> b * p + b ^ Suc x", "by (rule add_right_mono[OF mult_left_mono[OF Suc]], insert b, auto)"], ["proof (state)\nthis:\n  b * (b ^ x * of_nat x) + b ^ Suc x \\<le> b * p + b ^ Suc x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "also"], ["proof (state)\nthis:\n  b * (b ^ x * of_nat x) + b ^ Suc x \\<le> b * p + b ^ Suc x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "have \"\\<dots> = p - ((1 - b) * p - b ^ (Suc x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * p + b ^ Suc x = p - (((1::'a) - b) * p - b ^ Suc x)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  b * p + b ^ Suc x = p - (((1::'a) - b) * p - b ^ Suc x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "also"], ["proof (state)\nthis:\n  b * p + b ^ Suc x = p - (((1::'a) - b) * p - b ^ Suc x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "have \"\\<dots> \\<le> p - 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)", "have \"b ^ Suc x \\<le> 1 - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ Suc x \\<le> (1::'a) - b", "using x0[of \"Suc x\"] False"], ["proof (prove)\nusing this:\n  x0 \\<le> Suc x \\<Longrightarrow> b ^ Suc x \\<le> (1::'a) - b\n  \\<not> x \\<le> x0\n\ngoal (1 subgoal):\n 1. b ^ Suc x \\<le> (1::'a) - b", "by auto"], ["proof (state)\nthis:\n  b ^ Suc x \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)", "also"], ["proof (state)\nthis:\n  b ^ Suc x \\<le> (1::'a) - b\n\ngoal (1 subgoal):\n 1. p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)", "have \"\\<dots> \\<le> (1 - b) * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) - b \\<le> ((1::'a) - b) * p", "using b p1"], ["proof (prove)\nusing this:\n  (0::'a) < b\n  b < (1::'a)\n  (1::'a) \\<le> p\n\ngoal (1 subgoal):\n 1. (1::'a) - b \\<le> ((1::'a) - b) * p", "by auto"], ["proof (state)\nthis:\n  (1::'a) - b \\<le> ((1::'a) - b) * p\n\ngoal (1 subgoal):\n 1. p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)", "finally"], ["proof (chain)\npicking this:\n  b ^ Suc x \\<le> ((1::'a) - b) * p", "show ?thesis"], ["proof (prove)\nusing this:\n  b ^ Suc x \\<le> ((1::'a) - b) * p\n\ngoal (1 subgoal):\n 1. p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)", "by (intro diff_left_mono, simp)"], ["proof (state)\nthis:\n  p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p - (((1::'a) - b) * p - b ^ Suc x) \\<le> p - (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> x0 \\<Longrightarrow> b ^ Suc x * of_nat (Suc x) \\<le> p", "finally"], ["proof (chain)\npicking this:\n  b ^ Suc x * of_nat (Suc x) \\<le> p - (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  b ^ Suc x * of_nat (Suc x) \\<le> p - (0::'a)\n\ngoal (1 subgoal):\n 1. b ^ Suc x * of_nat (Suc x) \\<le> p", "by simp"], ["proof (state)\nthis:\n  b ^ Suc x * of_nat (Suc x) \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b ^ Suc x * of_nat (Suc x) \\<le> p\n\ngoal (1 subgoal):\n 1. b ^ 0 * of_nat 0 \\<le> p", "qed (insert p1, auto)"], ["proof (state)\nthis:\n  b ^ x * of_nat x \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_exp_bound: \"\\<exists> p. \\<forall> x. b ^ x * of_nat x ^ deg \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p", "proof (induct deg)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ 0 \\<le> p\n 2. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ 0 \\<le> p\n 2. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ 0 \\<le> p", "by (rule exI[of _ 1], intro allI, insert pow_one, auto)"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ 0 \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "case (Suc deg)"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p", "obtain q where IH: \"\\<And> x. b ^ x * (of_nat x) ^ deg \\<le> q\""], ["proof (prove)\nusing this:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        (\\<And>x. b ^ x * of_nat x ^ deg \\<le> q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b ^ ?x * of_nat ?x ^ deg \\<le> q\n\ngoal (1 subgoal):\n 1. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "define p where \"p = max 0 q\""], ["proof (state)\nthis:\n  p = max (0::'a) q\n\ngoal (1 subgoal):\n 1. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "from IH"], ["proof (chain)\npicking this:\n  b ^ ?x * of_nat ?x ^ deg \\<le> q", "have IH: \"\\<And> x. b ^ x * (of_nat x) ^ deg \\<le> p\""], ["proof (prove)\nusing this:\n  b ^ ?x * of_nat ?x ^ deg \\<le> q\n\ngoal (1 subgoal):\n 1. \\<And>x. b ^ x * of_nat x ^ deg \\<le> p", "unfolding p_def"], ["proof (prove)\nusing this:\n  b ^ ?x * of_nat ?x ^ deg \\<le> q\n\ngoal (1 subgoal):\n 1. \\<And>x. b ^ x * of_nat x ^ deg \\<le> max (0::'a) q", "using le_max_iff_disj"], ["proof (prove)\nusing this:\n  b ^ ?x * of_nat ?x ^ deg \\<le> q\n  (?z \\<le> max ?x ?y) = (?z \\<le> ?x \\<or> ?z \\<le> ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x. b ^ x * of_nat x ^ deg \\<le> max (0::'a) q", "by blast"], ["proof (state)\nthis:\n  b ^ ?x * of_nat ?x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "have p: \"p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> p", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> max (0::'a) q", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>deg.\n       \\<exists>p.\n          \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p \\<Longrightarrow>\n       \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "proof (cases \"deg = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. deg = 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p\n 2. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "case True"], ["proof (state)\nthis:\n  deg = 0\n\ngoal (2 subgoals):\n 1. deg = 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p\n 2. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg = 0\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "using linear_exp_bound"], ["proof (prove)\nusing this:\n  deg = 0\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x \\<le> p\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "by simp"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "case False"], ["proof (state)\nthis:\n  deg \\<noteq> 0\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "note deg = this"], ["proof (state)\nthis:\n  deg \\<noteq> 0\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "define p' where \"p' = p*p * 2 ^ Suc deg * inverse b\""], ["proof (state)\nthis:\n  p' = p * p * (2::'a) ^ Suc deg * inverse b\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "let ?f = \"\\<lambda> x. b ^ x * (of_nat x) ^ Suc deg\""], ["proof (state)\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "define f where \"f = ?f\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. b ^ x * of_nat x ^ Suc deg)\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "{"], ["proof (state)\nthis:\n  f = (\\<lambda>x. b ^ x * of_nat x ^ Suc deg)\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "let ?x = \"of_nat x :: 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "have \"f (2 * x) \\<le> (2 ^ Suc deg) * (p * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "hence x1: \"?x \\<ge> 1\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> of_nat x", "by (cases x, auto)"], ["proof (state)\nthis:\n  (1::'a) \\<le> of_nat x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "from x1"], ["proof (chain)\npicking this:\n  (1::'a) \\<le> of_nat x", "have x: \"?x ^ (deg - 1) \\<ge> 1\""], ["proof (prove)\nusing this:\n  (1::'a) \\<le> of_nat x\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> of_nat x ^ (deg - 1)", "by simp"], ["proof (state)\nthis:\n  (1::'a) \\<le> of_nat x ^ (deg - 1)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "from x1"], ["proof (chain)\npicking this:\n  (1::'a) \\<le> of_nat x", "have xx: \"?x ^ Suc deg \\<ge> 1\""], ["proof (prove)\nusing this:\n  (1::'a) \\<le> of_nat x\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> of_nat x ^ Suc deg", "by (rule one_le_power)"], ["proof (state)\nthis:\n  (1::'a) \\<le> of_nat x ^ Suc deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "define c where \"c = b ^ x * b ^ x * (2 ^ Suc deg)\""], ["proof (state)\nthis:\n  c = b ^ x * b ^ x * (2::'a) ^ Suc deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have c: \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < b ^ x * b ^ x * (2::'a) ^ Suc deg", "using b"], ["proof (prove)\nusing this:\n  (0::'a) < b\n  b < (1::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < b ^ x * b ^ x * (2::'a) ^ Suc deg", "by auto"], ["proof (state)\nthis:\n  (0::'a) < c\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"f (2 * x) = ?f (2 * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (2 * x) = b ^ (2 * x) * of_nat (2 * x) ^ Suc deg", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ (2 * x) * of_nat (2 * x) ^ Suc deg =\n    b ^ (2 * x) * of_nat (2 * x) ^ Suc deg", "by simp"], ["proof (state)\nthis:\n  f (2 * x) = b ^ (2 * x) * of_nat (2 * x) ^ Suc deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  f (2 * x) = b ^ (2 * x) * of_nat (2 * x) ^ Suc deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"b ^ (2 * x) = (b ^ x) * (b ^ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ (2 * x) = b ^ x * b ^ x", "by (simp add: power2_eq_square power_even_eq)"], ["proof (state)\nthis:\n  b ^ (2 * x) = b ^ x * b ^ x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  b ^ (2 * x) = b ^ x * b ^ x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"of_nat (2 * x) = 2 * ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (2 * x) = (2::'a) * of_nat x", "by simp"], ["proof (state)\nthis:\n  of_nat (2 * x) = (2::'a) * of_nat x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  of_nat (2 * x) = (2::'a) * of_nat x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"(2 * ?x) ^ Suc deg = 2 ^ Suc deg * ?x ^ Suc deg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2::'a) * of_nat x) ^ Suc deg = (2::'a) ^ Suc deg * of_nat x ^ Suc deg", "by simp"], ["proof (state)\nthis:\n  ((2::'a) * of_nat x) ^ Suc deg = (2::'a) ^ Suc deg * of_nat x ^ Suc deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "finally"], ["proof (chain)\npicking this:\n  f (2 * x) = b ^ x * b ^ x * ((2::'a) ^ Suc deg * of_nat x ^ Suc deg)", "have \"f (2 * x) = c * ?x ^ Suc deg\""], ["proof (prove)\nusing this:\n  f (2 * x) = b ^ x * b ^ x * ((2::'a) ^ Suc deg * of_nat x ^ Suc deg)\n\ngoal (1 subgoal):\n 1. f (2 * x) = c * of_nat x ^ Suc deg", "unfolding c_def"], ["proof (prove)\nusing this:\n  f (2 * x) = b ^ x * b ^ x * ((2::'a) ^ Suc deg * of_nat x ^ Suc deg)\n\ngoal (1 subgoal):\n 1. f (2 * x) = b ^ x * b ^ x * (2::'a) ^ Suc deg * of_nat x ^ Suc deg", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  f (2 * x) = c * of_nat x ^ Suc deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  f (2 * x) = c * of_nat x ^ Suc deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"\\<dots> \\<le> c * ?x ^ Suc deg * ?x ^ (deg - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * of_nat x ^ Suc deg\n    \\<le> c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c * of_nat x ^ Suc deg\n    \\<le> c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1)", "have \"c * ?x ^ Suc deg > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < c * of_nat x ^ Suc deg", "using c xx"], ["proof (prove)\nusing this:\n  (0::'a) < c\n  (1::'a) \\<le> of_nat x ^ Suc deg\n\ngoal (1 subgoal):\n 1. (0::'a) < c * of_nat x ^ Suc deg", "by simp"], ["proof (state)\nthis:\n  (0::'a) < c * of_nat x ^ Suc deg\n\ngoal (1 subgoal):\n 1. c * of_nat x ^ Suc deg\n    \\<le> c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) < c * of_nat x ^ Suc deg\n\ngoal (1 subgoal):\n 1. c * of_nat x ^ Suc deg\n    \\<le> c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1)", "unfolding mult_le_cancel_left1"], ["proof (prove)\nusing this:\n  (0::'a) < c * of_nat x ^ Suc deg\n\ngoal (1 subgoal):\n 1. ((0::'a) < c * of_nat x ^ Suc deg \\<longrightarrow>\n     (1::'a) \\<le> of_nat x ^ (deg - 1)) \\<and>\n    (c * of_nat x ^ Suc deg < (0::'a) \\<longrightarrow>\n     of_nat x ^ (deg - 1) \\<le> (1::'a))", "using x"], ["proof (prove)\nusing this:\n  (0::'a) < c * of_nat x ^ Suc deg\n  (1::'a) \\<le> of_nat x ^ (deg - 1)\n\ngoal (1 subgoal):\n 1. ((0::'a) < c * of_nat x ^ Suc deg \\<longrightarrow>\n     (1::'a) \\<le> of_nat x ^ (deg - 1)) \\<and>\n    (c * of_nat x ^ Suc deg < (0::'a) \\<longrightarrow>\n     of_nat x ^ (deg - 1) \\<le> (1::'a))", "by simp"], ["proof (state)\nthis:\n  c * of_nat x ^ Suc deg \\<le> c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * of_nat x ^ Suc deg \\<le> c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  c * of_nat x ^ Suc deg \\<le> c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"\\<dots> = c * ?x ^ (Suc deg + (deg - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1) =\n    c * of_nat x ^ (Suc deg + (deg - 1))", "by (simp add: power_add)"], ["proof (state)\nthis:\n  c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1) =\n  c * of_nat x ^ (Suc deg + (deg - 1))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  c * of_nat x ^ Suc deg * of_nat x ^ (deg - 1) =\n  c * of_nat x ^ (Suc deg + (deg - 1))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"Suc deg + (deg - 1) = deg + deg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc deg + (deg - 1) = deg + deg", "using deg"], ["proof (prove)\nusing this:\n  deg \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc deg + (deg - 1) = deg + deg", "by simp"], ["proof (state)\nthis:\n  Suc deg + (deg - 1) = deg + deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  Suc deg + (deg - 1) = deg + deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"?x ^ (deg + deg) = (?x ^ deg) * (?x ^ deg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat x ^ (deg + deg) = of_nat x ^ deg * of_nat x ^ deg", "by (simp add: power_add)"], ["proof (state)\nthis:\n  of_nat x ^ (deg + deg) = of_nat x ^ deg * of_nat x ^ deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  of_nat x ^ (deg + deg) = of_nat x ^ deg * of_nat x ^ deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"c * \\<dots> = (2 ^ Suc deg) * ((b ^ x * ?x ^ deg) * (b ^ x * ?x ^ deg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (of_nat x ^ deg * of_nat x ^ deg) =\n    (2::'a) ^ Suc deg * (b ^ x * of_nat x ^ deg * (b ^ x * of_nat x ^ deg))", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ x * b ^ x * (2::'a) ^ Suc deg * (of_nat x ^ deg * of_nat x ^ deg) =\n    (2::'a) ^ Suc deg * (b ^ x * of_nat x ^ deg * (b ^ x * of_nat x ^ deg))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  c * (of_nat x ^ deg * of_nat x ^ deg) =\n  (2::'a) ^ Suc deg * (b ^ x * of_nat x ^ deg * (b ^ x * of_nat x ^ deg))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "also"], ["proof (state)\nthis:\n  c * (of_nat x ^ deg * of_nat x ^ deg) =\n  (2::'a) ^ Suc deg * (b ^ x * of_nat x ^ deg * (b ^ x * of_nat x ^ deg))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"\\<dots> \\<le> (2 ^ Suc deg) * (p * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) ^ Suc deg * (b ^ x * of_nat x ^ deg * (b ^ x * of_nat x ^ deg))\n    \\<le> (2::'a) ^ Suc deg * (p * p)", "by (rule mult_left_mono[OF mult_mono[OF IH IH p]], insert pow_zero[of x], auto)"], ["proof (state)\nthis:\n  (2::'a) ^ Suc deg * (b ^ x * of_nat x ^ deg * (b ^ x * of_nat x ^ deg))\n  \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "finally"], ["proof (chain)\npicking this:\n  f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "show \"f (2 * x) \\<le> (2 ^ Suc deg) * (p * p)\""], ["proof (prove)\nusing this:\n  f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "."], ["proof (state)\nthis:\n  f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)", "qed (auto simp: f_def)"], ["proof (state)\nthis:\n  f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "hence \"?f (2 * x) \\<le> (2 ^ Suc deg) * (p * p)\""], ["proof (prove)\nusing this:\n  f (2 * x) \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. b ^ (2 * x) * of_nat (2 * x) ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)", "unfolding f_def"], ["proof (prove)\nusing this:\n  b ^ (2 * x) * of_nat (2 * x) ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. b ^ (2 * x) * of_nat (2 * x) ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)", "."], ["proof (state)\nthis:\n  b ^ (2 * x) * of_nat (2 * x) ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "}"], ["proof (state)\nthis:\n  b ^ (2 * ?x2) * of_nat (2 * ?x2) ^ Suc deg\n  \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "note even = this"], ["proof (state)\nthis:\n  b ^ (2 * ?x2) * of_nat (2 * ?x2) ^ Suc deg\n  \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. deg \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p", "proof (rule exI[of _ p'], intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. b ^ x * of_nat x ^ Suc deg \\<le> p'", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. b ^ x * of_nat x ^ Suc deg \\<le> p'", "show \"?f y \\<le> p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ y * of_nat y ^ Suc deg \\<le> p'", "proof (cases \"even y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "case True"], ["proof (state)\nthis:\n  even y\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "define x where \"x = y div 2\""], ["proof (state)\nthis:\n  x = y div 2\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"y = 2 * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = 2 * x", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = 2 * (y div 2)", "using True"], ["proof (prove)\nusing this:\n  even y\n\ngoal (1 subgoal):\n 1. y = 2 * (y div 2)", "by simp"], ["proof (state)\nthis:\n  y = 2 * x\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "from even[of x, folded this]"], ["proof (chain)\npicking this:\n  b ^ y * of_nat y ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)", "have \"?f y \\<le> 2 ^ Suc deg * (p * p)\""], ["proof (prove)\nusing this:\n  b ^ y * of_nat y ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (1 subgoal):\n 1. b ^ y * of_nat y ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)", "."], ["proof (state)\nthis:\n  b ^ y * of_nat y ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "also"], ["proof (state)\nthis:\n  b ^ y * of_nat y ^ Suc deg \\<le> (2::'a) ^ Suc deg * (p * p)\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"\\<dots> \\<le> \\<dots> * inverse b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) ^ Suc deg * (p * p)\n    \\<le> (2::'a) ^ Suc deg * (p * p) * inverse b", "unfolding mult_le_cancel_left1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) < (2::'a) ^ Suc deg * (p * p) \\<longrightarrow>\n     (1::'a) \\<le> inverse b) \\<and>\n    ((2::'a) ^ Suc deg * (p * p) < (0::'a) \\<longrightarrow>\n     inverse b \\<le> (1::'a))", "using b p"], ["proof (prove)\nusing this:\n  (0::'a) < b\n  b < (1::'a)\n  (0::'a) \\<le> p\n\ngoal (1 subgoal):\n 1. ((0::'a) < (2::'a) ^ Suc deg * (p * p) \\<longrightarrow>\n     (1::'a) \\<le> inverse b) \\<and>\n    ((2::'a) ^ Suc deg * (p * p) < (0::'a) \\<longrightarrow>\n     inverse b \\<le> (1::'a))", "by (simp add: algebra_split_simps one_le_inverse)"], ["proof (state)\nthis:\n  (2::'a) ^ Suc deg * (p * p) \\<le> (2::'a) ^ Suc deg * (p * p) * inverse b\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "also"], ["proof (state)\nthis:\n  (2::'a) ^ Suc deg * (p * p) \\<le> (2::'a) ^ Suc deg * (p * p) * inverse b\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"\\<dots> = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) ^ Suc deg * (p * p) * inverse b = p'", "unfolding p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) ^ Suc deg * (p * p) * inverse b =\n    p * p * (2::'a) ^ Suc deg * inverse b", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (2::'a) ^ Suc deg * (p * p) * inverse b = p'\n\ngoal (2 subgoals):\n 1. even y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'\n 2. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "finally"], ["proof (chain)\npicking this:\n  b ^ y * of_nat y ^ Suc deg \\<le> p'", "show \"?f y \\<le> p'\""], ["proof (prove)\nusing this:\n  b ^ y * of_nat y ^ Suc deg \\<le> p'\n\ngoal (1 subgoal):\n 1. b ^ y * of_nat y ^ Suc deg \\<le> p'", "."], ["proof (state)\nthis:\n  b ^ y * of_nat y ^ Suc deg \\<le> p'\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "case False"], ["proof (state)\nthis:\n  odd y\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "define x where \"x = y div 2\""], ["proof (state)\nthis:\n  x = y div 2\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"y = 2 * x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = 2 * x + 1", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = 2 * (y div 2) + 1", "using False"], ["proof (prove)\nusing this:\n  odd y\n\ngoal (1 subgoal):\n 1. y = 2 * (y div 2) + 1", "by simp"], ["proof (state)\nthis:\n  y = 2 * x + 1\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "hence \"?f y = ?f (2 * x + 1)\""], ["proof (prove)\nusing this:\n  y = 2 * x + 1\n\ngoal (1 subgoal):\n 1. b ^ y * of_nat y ^ Suc deg =\n    b ^ (2 * x + 1) * of_nat (2 * x + 1) ^ Suc deg", "by simp"], ["proof (state)\nthis:\n  b ^ y * of_nat y ^ Suc deg =\n  b ^ (2 * x + 1) * of_nat (2 * x + 1) ^ Suc deg\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "also"], ["proof (state)\nthis:\n  b ^ y * of_nat y ^ Suc deg =\n  b ^ (2 * x + 1) * of_nat (2 * x + 1) ^ Suc deg\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"\\<dots> \\<le> b ^ (2 * x + 1) * of_nat (2 * x + 2) ^ Suc deg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ (2 * x + 1) * of_nat (2 * x + 1) ^ Suc deg\n    \\<le> b ^ (2 * x + 1) * of_nat (2 * x + 2) ^ Suc deg", "by (rule mult_left_mono[OF power_mono], insert b, auto)"], ["proof (state)\nthis:\n  b ^ (2 * x + 1) * of_nat (2 * x + 1) ^ Suc deg\n  \\<le> b ^ (2 * x + 1) * of_nat (2 * x + 2) ^ Suc deg\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "also"], ["proof (state)\nthis:\n  b ^ (2 * x + 1) * of_nat (2 * x + 1) ^ Suc deg\n  \\<le> b ^ (2 * x + 1) * of_nat (2 * x + 2) ^ Suc deg\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"b ^ (2 * x + 1) = b ^ (2 * x + 2) * inverse b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ (2 * x + 1) = b ^ (2 * x + 2) * inverse b", "using b"], ["proof (prove)\nusing this:\n  (0::'a) < b\n  b < (1::'a)\n\ngoal (1 subgoal):\n 1. b ^ (2 * x + 1) = b ^ (2 * x + 2) * inverse b", "by auto"], ["proof (state)\nthis:\n  b ^ (2 * x + 1) = b ^ (2 * x + 2) * inverse b\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "also"], ["proof (state)\nthis:\n  b ^ (2 * x + 1) = b ^ (2 * x + 2) * inverse b\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"b ^ (2 * x + 2) * inverse b * of_nat (2 * x + 2) ^ Suc deg = \n            inverse b * ?f (2 * (x + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ (2 * x + 2) * inverse b * of_nat (2 * x + 2) ^ Suc deg =\n    inverse b * (b ^ (2 * (x + 1)) * of_nat (2 * (x + 1)) ^ Suc deg)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  b ^ (2 * x + 2) * inverse b * of_nat (2 * x + 2) ^ Suc deg =\n  inverse b * (b ^ (2 * (x + 1)) * of_nat (2 * (x + 1)) ^ Suc deg)\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "also"], ["proof (state)\nthis:\n  b ^ (2 * x + 2) * inverse b * of_nat (2 * x + 2) ^ Suc deg =\n  inverse b * (b ^ (2 * (x + 1)) * of_nat (2 * (x + 1)) ^ Suc deg)\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"\\<dots> \\<le> inverse b * ((2 ^ Suc deg) * (p * p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse b * (b ^ (2 * (x + 1)) * of_nat (2 * (x + 1)) ^ Suc deg)\n    \\<le> inverse b * ((2::'a) ^ Suc deg * (p * p))", "by (rule mult_left_mono[OF even], insert b, auto)"], ["proof (state)\nthis:\n  inverse b * (b ^ (2 * (x + 1)) * of_nat (2 * (x + 1)) ^ Suc deg)\n  \\<le> inverse b * ((2::'a) ^ Suc deg * (p * p))\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "also"], ["proof (state)\nthis:\n  inverse b * (b ^ (2 * (x + 1)) * of_nat (2 * (x + 1)) ^ Suc deg)\n  \\<le> inverse b * ((2::'a) ^ Suc deg * (p * p))\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "have \"\\<dots> = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse b * ((2::'a) ^ Suc deg * (p * p)) = p'", "unfolding p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse b * ((2::'a) ^ Suc deg * (p * p)) =\n    p * p * (2::'a) ^ Suc deg * inverse b", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  inverse b * ((2::'a) ^ Suc deg * (p * p)) = p'\n\ngoal (1 subgoal):\n 1. odd y \\<Longrightarrow> b ^ y * of_nat y ^ Suc deg \\<le> p'", "finally"], ["proof (chain)\npicking this:\n  b ^ y * of_nat y ^ Suc deg \\<le> p'", "show \"?f y \\<le> p'\""], ["proof (prove)\nusing this:\n  b ^ y * of_nat y ^ Suc deg \\<le> p'\n\ngoal (1 subgoal):\n 1. b ^ y * of_nat y ^ Suc deg \\<le> p'", "."], ["proof (state)\nthis:\n  b ^ y * of_nat y ^ Suc deg \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b ^ y * of_nat y ^ Suc deg \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ Suc deg \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma prod_list_replicate[simp]: \"prod_list (replicate n a) = a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate n a) = a ^ n", "by (induct n, auto)"], ["", "lemma prod_list_power: fixes xs :: \"'a :: comm_monoid_mult list\"\n  shows \"prod_list xs ^ n = (\\<Prod>x\\<leftarrow>xs. x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list xs ^ n = (\\<Prod>x\\<leftarrow>xs. x ^ n)", "by (induct xs, auto simp: power_mult_distrib)"], ["", "lemma set_upt_Suc: \"{0 ..< Suc i} = insert i {0 ..< i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc i} = insert i {0..<i}", "by (fact atLeast0_lessThan_Suc)"], ["", "lemma prod_pow[simp]: \"(\\<Prod>i = 0..<n. p) = (p :: 'a :: comm_monoid_mult) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. p) = p ^ n", "by (induct n, auto simp: set_upt_Suc)"], ["", "(* GCD and LCM part *)"], ["", "lemma dvd_abs_mult_left_int [simp]:\n  \"\\<bar>a\\<bar> * y dvd x \\<longleftrightarrow> a * y dvd x\" for x y a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>a\\<bar> * y dvd x) = (a * y dvd x)", "using abs_dvd_iff [of \"a * y\"] abs_dvd_iff [of \"\\<bar>a\\<bar> * y\"]"], ["proof (prove)\nusing this:\n  (\\<bar>a * y\\<bar> dvd ?k) = (a * y dvd ?k)\n  (\\<bar>\\<bar>a\\<bar> * y\\<bar> dvd ?k) = (\\<bar>a\\<bar> * y dvd ?k)\n\ngoal (1 subgoal):\n 1. (\\<bar>a\\<bar> * y dvd x) = (a * y dvd x)", "by (simp add: abs_mult)"], ["", "lemma gcd_abs_mult_right_int [simp]:\n  \"gcd x (\\<bar>a\\<bar> * y) = gcd x (a * y)\" for x y a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd x (\\<bar>a\\<bar> * y) = gcd x (a * y)", "using gcd_abs2_int [of _ \"a * y\"] gcd_abs2_int [of _ \"\\<bar>a\\<bar> * y\"]"], ["proof (prove)\nusing this:\n  gcd ?x \\<bar>a * y\\<bar> = gcd ?x (a * y)\n  gcd ?x \\<bar>\\<bar>a\\<bar> * y\\<bar> = gcd ?x (\\<bar>a\\<bar> * y)\n\ngoal (1 subgoal):\n 1. gcd x (\\<bar>a\\<bar> * y) = gcd x (a * y)", "by (simp add: abs_mult)"], ["", "lemma lcm_abs_mult_right_int [simp]:\n  \"lcm x (\\<bar>a\\<bar> * y) = lcm x (a * y)\" for x y a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcm x (\\<bar>a\\<bar> * y) = lcm x (a * y)", "using lcm_abs2_int [of _ \"a * y\"] lcm_abs2_int [of _ \"\\<bar>a\\<bar> * y\"]"], ["proof (prove)\nusing this:\n  lcm ?x \\<bar>a * y\\<bar> = lcm ?x (a * y)\n  lcm ?x \\<bar>\\<bar>a\\<bar> * y\\<bar> = lcm ?x (\\<bar>a\\<bar> * y)\n\ngoal (1 subgoal):\n 1. lcm x (\\<bar>a\\<bar> * y) = lcm x (a * y)", "by (simp add: abs_mult)"], ["", "lemma gcd_abs_mult_left_int [simp]:\n  \"gcd x (a * \\<bar>y\\<bar>) = gcd x (a * y)\" for x y a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd x (a * \\<bar>y\\<bar>) = gcd x (a * y)", "using gcd_abs2_int [of _ \"a * \\<bar>y\\<bar>\"] gcd_abs2_int [of _ \"a * y\"]"], ["proof (prove)\nusing this:\n  gcd ?x \\<bar>a * \\<bar>y\\<bar>\\<bar> = gcd ?x (a * \\<bar>y\\<bar>)\n  gcd ?x \\<bar>a * y\\<bar> = gcd ?x (a * y)\n\ngoal (1 subgoal):\n 1. gcd x (a * \\<bar>y\\<bar>) = gcd x (a * y)", "by (simp add: abs_mult)"], ["", "lemma lcm_abs_mult_left_int [simp]:\n  \"lcm x (a * \\<bar>y\\<bar>) = lcm x (a * y)\" for x y a :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcm x (a * \\<bar>y\\<bar>) = lcm x (a * y)", "using lcm_abs2_int [of _ \"a * \\<bar>y\\<bar>\"] lcm_abs2_int [of _ \"a * y\"]"], ["proof (prove)\nusing this:\n  lcm ?x \\<bar>a * \\<bar>y\\<bar>\\<bar> = lcm ?x (a * \\<bar>y\\<bar>)\n  lcm ?x \\<bar>a * y\\<bar> = lcm ?x (a * y)\n\ngoal (1 subgoal):\n 1. lcm x (a * \\<bar>y\\<bar>) = lcm x (a * y)", "by (simp add: abs_mult)"], ["", "abbreviation (input) list_gcd :: \"'a :: semiring_gcd list \\<Rightarrow> 'a\" where\n  \"list_gcd \\<equiv> gcd_list\""], ["", "abbreviation (input) list_lcm :: \"'a :: semiring_gcd list \\<Rightarrow> 'a\" where\n  \"list_lcm \\<equiv> lcm_list\""], ["", "lemma list_gcd_simps: \"list_gcd [] = 0\" \"list_gcd (x # xs) = gcd x (list_gcd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_list [] = (0::'a) &&& gcd_list (x # xs) = gcd x (gcd_list xs)", "by simp_all"], ["", "lemma list_gcd: \"x \\<in> set xs \\<Longrightarrow> list_gcd xs dvd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> gcd_list xs dvd x", "by (fact Gcd_fin_dvd)"], ["", "lemma list_gcd_greatest: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> y dvd x) \\<Longrightarrow> y dvd (list_gcd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> y dvd x) \\<Longrightarrow>\n    y dvd gcd_list xs", "by (fact gcd_list_greatest)"], ["", "lemma list_gcd_mult_int [simp]: \n  fixes xs :: \"int list\"\n  shows \"list_gcd (map (times a) xs) = \\<bar>a\\<bar> * list_gcd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_list (map ((*) a) xs) = \\<bar>a\\<bar> * gcd_list xs", "by (simp add: Gcd_mult abs_mult)"], ["", "lemma list_lcm_simps: \"list_lcm [] = 1\" \"list_lcm (x # xs) = lcm x (list_lcm xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcm_list [] = (1::'a) &&& lcm_list (x # xs) = lcm x (lcm_list xs)", "by simp_all"], ["", "lemma list_lcm: \"x \\<in> set xs \\<Longrightarrow> x dvd list_lcm xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x dvd lcm_list xs", "by (fact dvd_Lcm_fin)"], ["", "lemma list_lcm_least: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> x dvd y) \\<Longrightarrow> list_lcm xs dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> x dvd y) \\<Longrightarrow>\n    lcm_list xs dvd y", "by (fact lcm_list_least)"], ["", "lemma lcm_mult_distrib_nat: \"(k :: nat) * lcm m n = lcm (k * m) (k * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * lcm m n = lcm (k * m) (k * n)", "by (simp add: lcm_mult_left)"], ["", "lemma lcm_mult_distrib_int: \"abs (k::int) * lcm m n = lcm (k * m) (k * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>k\\<bar> * lcm m n = lcm (k * m) (k * n)", "by (simp add: lcm_mult_left abs_mult)"], ["", "lemma list_lcm_mult_int [simp]:\n  fixes xs :: \"int list\"\n  shows \"list_lcm (map (times a) xs) = (if xs = [] then 1 else \\<bar>a\\<bar> * list_lcm xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcm_list (map ((*) a) xs) =\n    (if xs = [] then 1 else \\<bar>a\\<bar> * lcm_list xs)", "by (simp add: Lcm_mult abs_mult)"], ["", "lemma list_lcm_pos:\n  \"list_lcm xs \\<ge> (0 :: int)\"\n  \"0 \\<notin> set xs \\<Longrightarrow> list_lcm xs \\<noteq> 0\"\n  \"0 \\<notin> set xs \\<Longrightarrow> list_lcm xs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> lcm_list xs &&&\n    (0 \\<notin> set xs \\<Longrightarrow> lcm_list xs \\<noteq> 0) &&&\n    (0 \\<notin> set xs \\<Longrightarrow> 0 < lcm_list xs)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> lcm_list xs\n 2. 0 \\<notin> set xs \\<Longrightarrow> lcm_list xs \\<noteq> 0\n 3. 0 \\<notin> set xs \\<Longrightarrow> 0 < lcm_list xs", "have \"0 \\<le> \\<bar>Lcm (set xs)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<bar>Lcm (set xs)\\<bar>", "by (simp only: abs_ge_zero)"], ["proof (state)\nthis:\n  0 \\<le> \\<bar>Lcm (set xs)\\<bar>\n\ngoal (3 subgoals):\n 1. 0 \\<le> lcm_list xs\n 2. 0 \\<notin> set xs \\<Longrightarrow> lcm_list xs \\<noteq> 0\n 3. 0 \\<notin> set xs \\<Longrightarrow> 0 < lcm_list xs", "then"], ["proof (chain)\npicking this:\n  0 \\<le> \\<bar>Lcm (set xs)\\<bar>", "have \"0 \\<le> Lcm (set xs)\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<bar>Lcm (set xs)\\<bar>\n\ngoal (1 subgoal):\n 1. 0 \\<le> Lcm (set xs)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> Lcm (set xs)\n\ngoal (3 subgoals):\n 1. 0 \\<le> lcm_list xs\n 2. 0 \\<notin> set xs \\<Longrightarrow> lcm_list xs \\<noteq> 0\n 3. 0 \\<notin> set xs \\<Longrightarrow> 0 < lcm_list xs", "then"], ["proof (chain)\npicking this:\n  0 \\<le> Lcm (set xs)", "show \"list_lcm xs \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> Lcm (set xs)\n\ngoal (1 subgoal):\n 1. 0 \\<le> lcm_list xs", "by simp"], ["proof (state)\nthis:\n  0 \\<le> lcm_list xs\n\ngoal (2 subgoals):\n 1. 0 \\<notin> set xs \\<Longrightarrow> lcm_list xs \\<noteq> 0\n 2. 0 \\<notin> set xs \\<Longrightarrow> 0 < lcm_list xs", "assume \"0 \\<notin> set xs\""], ["proof (state)\nthis:\n  0 \\<notin> set xs\n\ngoal (2 subgoals):\n 1. 0 \\<notin> set xs \\<Longrightarrow> lcm_list xs \\<noteq> 0\n 2. 0 \\<notin> set xs \\<Longrightarrow> 0 < lcm_list xs", "then"], ["proof (chain)\npicking this:\n  0 \\<notin> set xs", "show \"list_lcm xs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 \\<notin> set xs\n\ngoal (1 subgoal):\n 1. lcm_list xs \\<noteq> 0", "by (simp add: Lcm_0_iff)"], ["proof (state)\nthis:\n  lcm_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set xs \\<Longrightarrow> 0 < lcm_list xs", "with \\<open>list_lcm xs \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> lcm_list xs\n  lcm_list xs \\<noteq> 0", "show \"list_lcm xs > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> lcm_list xs\n  lcm_list xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lcm_list xs", "by (simp add: le_less)"], ["proof (state)\nthis:\n  0 < lcm_list xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quotient_of_nonzero: \"snd (quotient_of r) > 0\" \"snd (quotient_of r) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < snd (quotient_of r) &&& snd (quotient_of r) \\<noteq> 0", "using quotient_of_denom_pos' [of r]"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of r)\n\ngoal (1 subgoal):\n 1. 0 < snd (quotient_of r) &&& snd (quotient_of r) \\<noteq> 0", "by simp_all"], ["", "lemma quotient_of_int_div: assumes q: \"quotient_of (of_int x / of_int y) = (a, b)\"\n  and y: \"y \\<noteq> 0\" \n  shows \"\\<exists> z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "define z where \"z = gcd x y\""], ["proof (state)\nthis:\n  z = gcd x y\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "define x' where \"x' = x div z\""], ["proof (state)\nthis:\n  x' = x div z\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "define y' where \"y' = y div z\""], ["proof (state)\nthis:\n  y' = y div z\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "have id: \"x = z * x'\" \"y = z * y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = z * x' &&& y = z * y'", "unfolding x'_def y'_def z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = gcd x y * (x div gcd x y) &&& y = gcd x y * (y div gcd x y)", "by auto"], ["proof (state)\nthis:\n  x = z * x'\n  y = z * y'\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from y"], ["proof (chain)\npicking this:\n  y \\<noteq> 0", "have y': \"y' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0", "unfolding id"], ["proof (prove)\nusing this:\n  z * y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "have z: \"z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "unfolding z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd x y \\<noteq> 0", "using y"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd x y \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "have cop: \"coprime x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime x' y'", "unfolding x'_def y'_def z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (x div gcd x y) (y div gcd x y)", "using div_gcd_coprime y"], ["proof (prove)\nusing this:\n  ?a \\<noteq> (0::?'a) \\<or> ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  coprime (?a div gcd ?a ?b) (?b div gcd ?a ?b)\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime (x div gcd x y) (y div gcd x y)", "by blast"], ["proof (state)\nthis:\n  coprime x' y'\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "have \"?r x / ?r y = ?r x' / ?r y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int x / rat_of_int y = rat_of_int x' / rat_of_int y'", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (z * x') / rat_of_int (z * y') =\n    rat_of_int x' / rat_of_int y'", "using z y y'"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  y \\<noteq> 0\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (z * x') / rat_of_int (z * y') =\n    rat_of_int x' / rat_of_int y'", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  rat_of_int x / rat_of_int y = rat_of_int x' / rat_of_int y'\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from assms[unfolded this]"], ["proof (chain)\npicking this:\n  quotient_of (rat_of_int x' / rat_of_int y') = (a, b)\n  y \\<noteq> 0", "have quot: \"quotient_of (?r x' / ?r y') = (a, b)\""], ["proof (prove)\nusing this:\n  quotient_of (rat_of_int x' / rat_of_int y') = (a, b)\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. quotient_of (rat_of_int x' / rat_of_int y') = (a, b)", "by auto"], ["proof (state)\nthis:\n  quotient_of (rat_of_int x' / rat_of_int y') = (a, b)\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from quotient_of_coprime[OF quot]"], ["proof (chain)\npicking this:\n  coprime a b", "have cop': \"coprime a b\""], ["proof (prove)\nusing this:\n  coprime a b\n\ngoal (1 subgoal):\n 1. coprime a b", "."], ["proof (state)\nthis:\n  coprime a b\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "hence cop: \"coprime b a\""], ["proof (prove)\nusing this:\n  coprime a b\n\ngoal (1 subgoal):\n 1. coprime b a", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  coprime b a\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < b", "have b: \"b > 0\" \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 < b &&& b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  0 < b\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from quotient_of_div[OF quot] quotient_of_denom_pos[OF quot] y'"], ["proof (chain)\npicking this:\n  rat_of_int x' / rat_of_int y' = rat_of_int a / rat_of_int b\n  0 < b\n  y' \\<noteq> 0", "have \"?r x' * ?r b = ?r a * ?r y'\""], ["proof (prove)\nusing this:\n  rat_of_int x' / rat_of_int y' = rat_of_int a / rat_of_int b\n  0 < b\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int x' * rat_of_int b = rat_of_int a * rat_of_int y'", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  rat_of_int x' * rat_of_int b = rat_of_int a * rat_of_int y'\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "hence id': \"x' * b = a * y'\""], ["proof (prove)\nusing this:\n  rat_of_int x' * rat_of_int b = rat_of_int a * rat_of_int y'\n\ngoal (1 subgoal):\n 1. x' * b = a * y'", "unfolding of_int_mult[symmetric]"], ["proof (prove)\nusing this:\n  rat_of_int (x' * b) = rat_of_int (a * y')\n\ngoal (1 subgoal):\n 1. x' * b = a * y'", "by linarith"], ["proof (state)\nthis:\n  x' * b = a * y'\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from id'[symmetric]"], ["proof (chain)\npicking this:\n  a * y' = x' * b", "have \"b dvd y' * a\""], ["proof (prove)\nusing this:\n  a * y' = x' * b\n\ngoal (1 subgoal):\n 1. b dvd y' * a", "unfolding mult.commute[of y']"], ["proof (prove)\nusing this:\n  a * y' = x' * b\n\ngoal (1 subgoal):\n 1. b dvd a * y'", "by auto"], ["proof (state)\nthis:\n  b dvd y' * a\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "with cop y'"], ["proof (chain)\npicking this:\n  coprime b a\n  y' \\<noteq> 0\n  b dvd y' * a", "have \"b dvd y'\""], ["proof (prove)\nusing this:\n  coprime b a\n  y' \\<noteq> 0\n  b dvd y' * a\n\ngoal (1 subgoal):\n 1. b dvd y'", "by (simp add: coprime_dvd_mult_left_iff)"], ["proof (state)\nthis:\n  b dvd y'\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "then"], ["proof (chain)\npicking this:\n  b dvd y'", "obtain z' where ybz: \"y' = b * z'\""], ["proof (prove)\nusing this:\n  b dvd y'\n\ngoal (1 subgoal):\n 1. (\\<And>z'. y' = b * z' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. y' = b * k\n\ngoal (1 subgoal):\n 1. (\\<And>z'. y' = b * z' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y' = b * z'\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from id[unfolded y' this]"], ["proof (chain)\npicking this:\n  x = z * x'\n  y = z * (b * z')", "have y: \"y = b * (z * z')\""], ["proof (prove)\nusing this:\n  x = z * x'\n  y = z * (b * z')\n\ngoal (1 subgoal):\n 1. y = b * (z * z')", "by auto"], ["proof (state)\nthis:\n  y = b * (z * z')\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "with \\<open>y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  y \\<noteq> 0\n  y = b * (z * z')", "have zz: \"z * z' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  y = b * (z * z')\n\ngoal (1 subgoal):\n 1. z * z' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  z * z' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from quotient_of_div[OF q] \\<open>y \\<noteq> 0\\<close> \\<open>b \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  rat_of_int x / rat_of_int y = rat_of_int a / rat_of_int b\n  y \\<noteq> 0\n  b \\<noteq> 0", "have \"?r x * ?r b = ?r y * ?r a\""], ["proof (prove)\nusing this:\n  rat_of_int x / rat_of_int y = rat_of_int a / rat_of_int b\n  y \\<noteq> 0\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int x * rat_of_int b = rat_of_int y * rat_of_int a", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  rat_of_int x * rat_of_int b = rat_of_int y * rat_of_int a\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "hence id': \"x * b = y * a\""], ["proof (prove)\nusing this:\n  rat_of_int x * rat_of_int b = rat_of_int y * rat_of_int a\n\ngoal (1 subgoal):\n 1. x * b = y * a", "unfolding of_int_mult[symmetric]"], ["proof (prove)\nusing this:\n  rat_of_int (x * b) = rat_of_int (y * a)\n\ngoal (1 subgoal):\n 1. x * b = y * a", "by linarith"], ["proof (state)\nthis:\n  x * b = y * a\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "from this[unfolded y] b"], ["proof (chain)\npicking this:\n  x * b = b * (z * z') * a\n  0 < b\n  b \\<noteq> 0", "have x: \"x = a * (z * z')\""], ["proof (prove)\nusing this:\n  x * b = b * (z * z') * a\n  0 < b\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = a * (z * z')", "by auto"], ["proof (state)\nthis:\n  x = a * (z * z')\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z", "unfolding x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>za.\n       za \\<noteq> 0 \\<and>\n       a * (z * z') = a * za \\<and> b * (z * z') = b * za", "using zz"], ["proof (prove)\nusing this:\n  z * z' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>za.\n       za \\<noteq> 0 \\<and>\n       a * (z * z') = a * za \\<and> b * (z * z') = b * za", "by blast"], ["proof (state)\nthis:\n  \\<exists>z. z \\<noteq> 0 \\<and> x = a * z \\<and> y = b * z\n\ngoal:\nNo subgoals!", "qed"], ["", "fun max_list_non_empty :: \"('a :: linorder) list \\<Rightarrow> 'a\" where\n  \"max_list_non_empty [x] = x\"\n| \"max_list_non_empty (x # xs) = max x (max_list_non_empty xs)\""], ["", "lemma max_list_non_empty: \"x \\<in> set xs \\<Longrightarrow> x \\<le> max_list_non_empty xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> max_list_non_empty xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow> x \\<le> max_list_non_empty []\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                x \\<le> max_list_non_empty xs;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> max_list_non_empty (a # xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  x \\<in> set ys \\<Longrightarrow> x \\<le> max_list_non_empty ys\n  x \\<in> set (y # ys)\n\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow> x \\<le> max_list_non_empty []\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                x \\<le> max_list_non_empty xs;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> max_list_non_empty (a # xs)", "note oCons = this"], ["proof (state)\nthis:\n  x \\<in> set ys \\<Longrightarrow> x \\<le> max_list_non_empty ys\n  x \\<in> set (y # ys)\n\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow> x \\<le> max_list_non_empty []\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                x \\<le> max_list_non_empty xs;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> max_list_non_empty (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> max_list_non_empty (y # ys)", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> x \\<le> max_list_non_empty (y # ys)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow> x \\<le> max_list_non_empty (y # ys)", "case (Cons z zs)"], ["proof (state)\nthis:\n  ys = z # zs\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> x \\<le> max_list_non_empty (y # ys)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow> x \\<le> max_list_non_empty (y # ys)", "hence id: \"max_list_non_empty (y # ys) = max y (max_list_non_empty ys)\""], ["proof (prove)\nusing this:\n  ys = z # zs\n\ngoal (1 subgoal):\n 1. max_list_non_empty (y # ys) = max y (max_list_non_empty ys)", "by simp"], ["proof (state)\nthis:\n  max_list_non_empty (y # ys) = max y (max_list_non_empty ys)\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> x \\<le> max_list_non_empty (y # ys)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow> x \\<le> max_list_non_empty (y # ys)", "from oCons"], ["proof (chain)\npicking this:\n  x \\<in> set ys \\<Longrightarrow> x \\<le> max_list_non_empty ys\n  x \\<in> set (y # ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set ys \\<Longrightarrow> x \\<le> max_list_non_empty ys\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<le> max_list_non_empty (y # ys)", "unfolding id"], ["proof (prove)\nusing this:\n  x \\<in> set ys \\<Longrightarrow> x \\<le> max_list_non_empty ys\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<le> max y (max_list_non_empty ys)", "by (auto simp: max.coboundedI2)"], ["proof (state)\nthis:\n  x \\<le> max_list_non_empty (y # ys)\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow> x \\<le> max_list_non_empty (y # ys)", "qed (insert oCons, auto)"], ["proof (state)\nthis:\n  x \\<le> max_list_non_empty (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set [] \\<Longrightarrow> x \\<le> max_list_non_empty []", "qed simp"], ["", "lemma cnj_reals[simp]: \"(cnj c \\<in> \\<real>) = (c \\<in> \\<real>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj c \\<in> \\<real>) = (c \\<in> \\<real>)", "using Reals_cnj_iff"], ["proof (prove)\nusing this:\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n\ngoal (1 subgoal):\n 1. (cnj c \\<in> \\<real>) = (c \\<in> \\<real>)", "by fastforce"], ["", "lemma sgn_real_mono: \"x \\<le> y \\<Longrightarrow> sgn x \\<le> sgn (y :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> sgn x \\<le> sgn y", "unfolding sgn_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    (if x = 0 then 0 else if 0 < x then 1 else - 1)\n    \\<le> (if y = 0 then 0 else if 0 < y then 1 else - 1)", "by (auto split: if_splits)"], ["", "lemma sgn_minus_rat: \"sgn (- (x :: rat)) = - sgn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (- x) = - sgn x", "by (fact Rings.sgn_minus)"], ["", "lemma real_of_rat_sgn: \"sgn (of_rat x) = real_of_rat (sgn x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (real_of_rat x) = real_of_rat (sgn x)", "unfolding sgn_real_def sgn_rat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if real_of_rat x = 0 then 0\n     else if 0 < real_of_rat x then 1 else - 1) =\n    real_of_rat (if x = 0 then 0 else if 0 < x then 1 else - 1)", "by auto"], ["", "lemma inverse_le_iff_sgn: assumes sgn: \"sgn x = sgn y\"\n  shows \"(inverse (x :: real) \\<le> inverse y) = (y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse x \\<le> inverse y) = (y \\<le> x)", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "with sgn"], ["proof (chain)\npicking this:\n  sgn x = sgn y\n  x = 0", "have \"sgn y = 0\""], ["proof (prove)\nusing this:\n  sgn x = sgn y\n  x = 0\n\ngoal (1 subgoal):\n 1. sgn y = 0", "by simp"], ["proof (state)\nthis:\n  sgn y = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "hence \"y = 0\""], ["proof (prove)\nusing this:\n  sgn y = 0\n\ngoal (1 subgoal):\n 1. y = 0", "unfolding sgn_real_def"], ["proof (prove)\nusing this:\n  (if y = 0 then 0 else if 0 < y then 1 else - 1) = 0\n\ngoal (1 subgoal):\n 1. y = 0", "by (cases \"y = 0\"; cases \"y < 0\"; auto)"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = 0\n\ngoal (1 subgoal):\n 1. (inverse x \\<le> inverse y) = (y \\<le> x)", "using True"], ["proof (prove)\nusing this:\n  y = 0\n  x = 0\n\ngoal (1 subgoal):\n 1. (inverse x \\<le> inverse y) = (y \\<le> x)", "by simp"], ["proof (state)\nthis:\n  (inverse x \\<le> inverse y) = (y \\<le> x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "note x = this"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse x \\<le> inverse y) = (y \\<le> x)", "proof (cases \"x < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "case True"], ["proof (state)\nthis:\n  x < 0\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "with x sgn"], ["proof (chain)\npicking this:\n  x \\<noteq> 0\n  sgn x = sgn y\n  x < 0", "have \"sgn y = -1\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  sgn x = sgn y\n  x < 0\n\ngoal (1 subgoal):\n 1. sgn y = - 1", "by simp"], ["proof (state)\nthis:\n  sgn y = - 1\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "hence \"y < 0\""], ["proof (prove)\nusing this:\n  sgn y = - 1\n\ngoal (1 subgoal):\n 1. y < 0", "unfolding sgn_real_def"], ["proof (prove)\nusing this:\n  (if y = 0 then 0 else if 0 < y then 1 else - 1) = - 1\n\ngoal (1 subgoal):\n 1. y < 0", "by (cases \"y = 0\"; cases \"y < 0\", auto)"], ["proof (state)\nthis:\n  y < 0\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)\n 2. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse x \\<le> inverse y) = (y \\<le> x)", "by (rule inverse_le_iff_le_neg[OF True \\<open>y < 0\\<close>])"], ["proof (state)\nthis:\n  (inverse x \\<le> inverse y) = (y \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "case False"], ["proof (state)\nthis:\n  \\<not> x < 0\n\ngoal (1 subgoal):\n 1. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "with x"], ["proof (chain)\npicking this:\n  x \\<noteq> 0\n  \\<not> x < 0", "have x: \"x > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  \\<not> x < 0\n\ngoal (1 subgoal):\n 1. 0 < x", "by auto"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "with sgn"], ["proof (chain)\npicking this:\n  sgn x = sgn y\n  0 < x", "have \"sgn y = 1\""], ["proof (prove)\nusing this:\n  sgn x = sgn y\n  0 < x\n\ngoal (1 subgoal):\n 1. sgn y = 1", "by auto"], ["proof (state)\nthis:\n  sgn y = 1\n\ngoal (1 subgoal):\n 1. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "hence \"y > 0\""], ["proof (prove)\nusing this:\n  sgn y = 1\n\ngoal (1 subgoal):\n 1. 0 < y", "unfolding sgn_real_def"], ["proof (prove)\nusing this:\n  (if y = 0 then 0 else if 0 < y then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < y", "by (cases \"y = 0\"; cases \"y < 0\", auto)"], ["proof (state)\nthis:\n  0 < y\n\ngoal (1 subgoal):\n 1. \\<not> x < 0 \\<Longrightarrow> (inverse x \\<le> inverse y) = (y \\<le> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse x \\<le> inverse y) = (y \\<le> x)", "by (rule inverse_le_iff_le[OF x \\<open>y > 0\\<close>])"], ["proof (state)\nthis:\n  (inverse x \\<le> inverse y) = (y \\<le> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (inverse x \\<le> inverse y) = (y \\<le> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_le_sgn: assumes sgn: \"sgn x = sgn y\" and xy: \"x \\<le> (y :: real)\"\n  shows \"inverse y \\<le> inverse x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse y \\<le> inverse x", "using xy inverse_le_iff_sgn[OF sgn]"], ["proof (prove)\nusing this:\n  x \\<le> y\n  (inverse x \\<le> inverse y) = (y \\<le> x)\n\ngoal (1 subgoal):\n 1. inverse y \\<le> inverse x", "by auto"], ["", "lemma set_list_update: \"set (xs [i := k]) = \n  (if i < length xs then insert k (set (take i xs) \\<union> set (drop (Suc i) xs)) else set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs[i := k]) =\n    (if i < length xs\n     then insert k (set (take i xs) \\<union> set (drop (Suc i) xs))\n     else set xs)", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       set ([][i := k]) =\n       (if i < length []\n        then insert k (set (take i []) \\<union> set (drop (Suc i) []))\n        else set [])\n 2. \\<And>a xs i.\n       (\\<And>i.\n           set (xs[i := k]) =\n           (if i < length xs\n            then insert k (set (take i xs) \\<union> set (drop (Suc i) xs))\n            else set xs)) \\<Longrightarrow>\n       set ((a # xs)[i := k]) =\n       (if i < length (a # xs)\n        then insert k\n              (set (take i (a # xs)) \\<union> set (drop (Suc i) (a # xs)))\n        else set (a # xs))", "case (Cons x xs i)"], ["proof (state)\nthis:\n  set (xs[?i := k]) =\n  (if ?i < length xs\n   then insert k (set (take ?i xs) \\<union> set (drop (Suc ?i) xs))\n   else set xs)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       set ([][i := k]) =\n       (if i < length []\n        then insert k (set (take i []) \\<union> set (drop (Suc i) []))\n        else set [])\n 2. \\<And>a xs i.\n       (\\<And>i.\n           set (xs[i := k]) =\n           (if i < length xs\n            then insert k (set (take i xs) \\<union> set (drop (Suc i) xs))\n            else set xs)) \\<Longrightarrow>\n       set ((a # xs)[i := k]) =\n       (if i < length (a # xs)\n        then insert k\n              (set (take i (a # xs)) \\<union> set (drop (Suc i) (a # xs)))\n        else set (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  set (xs[?i := k]) =\n  (if ?i < length xs\n   then insert k (set (take ?i xs) \\<union> set (drop (Suc ?i) xs))\n   else set xs)\n\ngoal (1 subgoal):\n 1. set ((x # xs)[i := k]) =\n    (if i < length (x # xs)\n     then insert k\n           (set (take i (x # xs)) \\<union> set (drop (Suc i) (x # xs)))\n     else set (x # xs))", "by (cases i, auto)"], ["proof (state)\nthis:\n  set ((x # xs)[i := k]) =\n  (if i < length (x # xs)\n   then insert k\n         (set (take i (x # xs)) \\<union> set (drop (Suc i) (x # xs)))\n   else set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       set ([][i := k]) =\n       (if i < length []\n        then insert k (set (take i []) \\<union> set (drop (Suc i) []))\n        else set [])", "qed simp"], ["", "lemma prod_list_dvd: assumes \"(x :: 'a :: comm_monoid_mult) \\<in> set xs\"\n  shows \"x dvd prod_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd prod_list xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x dvd prod_list xs", "from assms[unfolded in_set_conv_decomp]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. xs = ys @ x # zs", "obtain ys zs where xs: \"xs = ys @ x # zs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ x # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. x dvd prod_list xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd prod_list xs", "unfolding xs dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. prod_list (ys @ x # zs) = x * k", "by (intro exI[of _ \"prod_list (ys @ zs)\"], simp add: ac_simps)"], ["proof (state)\nthis:\n  x dvd prod_list xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_prod: \nfixes A::\"'b set\" \nassumes \"\\<exists>b\\<in>A. a dvd f b\" \"finite A\"\nshows \"a dvd prod f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd prod f A", "using assms(2,1)"], ["proof (prove)\nusing this:\n  finite A\n  \\<exists>b\\<in>A. a dvd f b\n\ngoal (1 subgoal):\n 1. a dvd prod f A", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>b\\<in>{}. a dvd f b \\<Longrightarrow> a dvd prod f {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>b\\<in>F. a dvd f b \\<Longrightarrow> a dvd prod f F;\n        \\<exists>b\\<in>insert x F. a dvd f b\\<rbrakk>\n       \\<Longrightarrow> a dvd prod f (insert x F)", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<exists>b\\<in>A. a dvd f b \\<Longrightarrow> a dvd prod f A\n  \\<exists>b\\<in>insert x A. a dvd f b\n\ngoal (2 subgoals):\n 1. \\<exists>b\\<in>{}. a dvd f b \\<Longrightarrow> a dvd prod f {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>b\\<in>F. a dvd f b \\<Longrightarrow> a dvd prod f F;\n        \\<exists>b\\<in>insert x F. a dvd f b\\<rbrakk>\n       \\<Longrightarrow> a dvd prod f (insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<exists>b\\<in>A. a dvd f b \\<Longrightarrow> a dvd prod f A\n  \\<exists>b\\<in>insert x A. a dvd f b\n\ngoal (1 subgoal):\n 1. a dvd prod f (insert x A)", "using comm_monoid_mult_class.dvd_mult dvd_mult2 insert_iff prod.insert"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<exists>b\\<in>A. a dvd f b \\<Longrightarrow> a dvd prod f A\n  \\<exists>b\\<in>insert x A. a dvd f b\n  ?a dvd ?c \\<Longrightarrow> ?a dvd ?b * ?c\n  ?a dvd ?b \\<Longrightarrow> ?a dvd ?b * ?c\n  (?a \\<in> insert ?b ?A) = (?a = ?b \\<or> ?a \\<in> ?A)\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> prod ?g (insert ?x ?A) = ?g ?x * prod ?g ?A\n\ngoal (1 subgoal):\n 1. a dvd prod f (insert x A)", "by auto"], ["proof (state)\nthis:\n  a dvd prod f (insert x A)\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>{}. a dvd f b \\<Longrightarrow> a dvd prod f {}", "qed auto"], ["", "context\n  fixes xs :: \"'a :: comm_monoid_mult list\"\nbegin"], ["", "lemma prod_list_filter: \"prod_list (filter f xs) * prod_list (filter (\\<lambda> x. \\<not> f x) xs) = prod_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (filter f xs) *\n    prod_list (filter (\\<lambda>x. \\<not> f x) xs) =\n    prod_list xs", "by (induct xs, auto simp: ac_simps)"], ["", "lemma prod_list_partition: assumes \"partition f xs = (ys, zs)\"\n  shows \"prod_list xs = prod_list ys * prod_list zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list xs = prod_list ys * prod_list zs", "using assms"], ["proof (prove)\nusing this:\n  partition f xs = (ys, zs)\n\ngoal (1 subgoal):\n 1. prod_list xs = prod_list ys * prod_list zs", "by (subst prod_list_filter[symmetric, of f], auto simp: o_def)"], ["", "end"], ["", "lemma dvd_imp_mult_div_cancel_left[simp]:\n  assumes \"(a :: 'a :: semidom_divide) dvd b\"\n  shows \"a * (b div a) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (b div a) = b", "proof(cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow> a * (b div a) = b\n 2. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "case True"], ["proof (state)\nthis:\n  b = (0::'a)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow> a * (b div a) = b\n 2. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "then"], ["proof (chain)\npicking this:\n  b = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. a * (b div a) = b", "by auto"], ["proof (state)\nthis:\n  a * (b div a) = b\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "case False"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "with dvdE[OF assms]"], ["proof (chain)\npicking this:\n  (\\<And>k. b = a * k \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  b \\<noteq> (0::'a)", "obtain c where *: \"b = a * c\""], ["proof (prove)\nusing this:\n  (\\<And>k. b = a * k \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>c. b = a * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  b = a * c\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "also"], ["proof (state)\nthis:\n  b = a * c\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "with False"], ["proof (chain)\npicking this:\n  b \\<noteq> (0::'a)\n  b = a * c", "have \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  b = a * c\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)", "have \"a * c div a = c\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a * c div a = c", "by auto"], ["proof (state)\nthis:\n  a * c div a = c\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "also"], ["proof (state)\nthis:\n  a * c div a = c\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "note *[symmetric]"], ["proof (state)\nthis:\n  a * c = b\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> a * (b div a) = b", "finally"], ["proof (chain)\npicking this:\n  a * (b div a) = b", "show ?thesis"], ["proof (prove)\nusing this:\n  a * (b div a) = b\n\ngoal (1 subgoal):\n 1. a * (b div a) = b", "."], ["proof (state)\nthis:\n  a * (b div a) = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in semidom) prod_list_zero_iff[simp]: \n  \"prod_list xs = 0 \\<longleftrightarrow> 0 \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod_list xs = (0::'a)) = ((0::'a) \\<in> set xs)", "by (induction xs, auto)"], ["", "context comm_monoid_mult begin"], ["", "lemma unit_prod [intro]:\n  shows \"a dvd 1 \\<Longrightarrow> b dvd 1 \\<Longrightarrow> (a * b) dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a dvd (1::'a); b dvd (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a * b dvd (1::'a)", "by (subst mult_1_left [of 1, symmetric]) (rule mult_dvd_mono)"], ["", "lemma is_unit_mult_iff[simp]:\n  shows \"(a * b) dvd 1 \\<longleftrightarrow> a dvd 1 \\<and> b dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * b dvd (1::'a)) = (a dvd (1::'a) \\<and> b dvd (1::'a))", "by (auto dest: dvd_mult_left dvd_mult_right)"], ["", "end"], ["", "context comm_semiring_1\nbegin"], ["", "lemma irreducibleE[elim]:\n  assumes \"irreducible p\"\n      and \"p \\<noteq> 0 \\<Longrightarrow> \\<not> p dvd 1 \\<Longrightarrow> (\\<And>a b. p = a * b \\<Longrightarrow> a dvd 1 \\<or> b dvd 1) \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  irreducible p\n  \\<lbrakk>p \\<noteq> (0::'a); \\<not> p dvd (1::'a);\n   \\<And>a b.\n      p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: irreducible_def)"], ["", "lemma not_irreducibleE:\n  assumes \"\\<not> irreducible x\"\n      and \"x = 0 \\<Longrightarrow> thesis\"\n      and \"x dvd 1 \\<Longrightarrow> thesis\"\n      and \"\\<And>a b. x = a * b \\<Longrightarrow> \\<not> a dvd 1 \\<Longrightarrow> \\<not> b dvd 1 \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> irreducible x\n  x = (0::'a) \\<Longrightarrow> thesis\n  x dvd (1::'a) \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?a1 * ?b1; \\<not> ?a1 dvd (1::'a);\n   \\<not> ?b1 dvd (1::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> (x \\<noteq> (0::'a) \\<and>\n          \\<not> x dvd (1::'a) \\<and>\n          (\\<forall>a b.\n              x = a * b \\<longrightarrow>\n              a dvd (1::'a) \\<or> b dvd (1::'a)))\n  x = (0::'a) \\<Longrightarrow> thesis\n  x dvd (1::'a) \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?a1 * ?b1; \\<not> ?a1 dvd (1::'a);\n   \\<not> ?b1 dvd (1::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["", "lemma prime_elem_dvd_prod_list:\n  assumes p: \"prime_elem p\" and pA: \"p dvd prod_list A\" shows \"\\<exists>a \\<in> set A. p dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set A. p dvd a", "proof(insert pA, induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd prod_list [] \\<Longrightarrow> Bex (set []) ((dvd) p)\n 2. \\<And>a A.\n       \\<lbrakk>p dvd prod_list A \\<Longrightarrow> Bex (set A) ((dvd) p);\n        p dvd prod_list (a # A)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (a # A)) ((dvd) p)", "case Nil"], ["proof (state)\nthis:\n  p dvd prod_list []\n\ngoal (2 subgoals):\n 1. p dvd prod_list [] \\<Longrightarrow> Bex (set []) ((dvd) p)\n 2. \\<And>a A.\n       \\<lbrakk>p dvd prod_list A \\<Longrightarrow> Bex (set A) ((dvd) p);\n        p dvd prod_list (a # A)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (a # A)) ((dvd) p)", "with p"], ["proof (chain)\npicking this:\n  prime_elem p\n  p dvd prod_list []", "show ?case"], ["proof (prove)\nusing this:\n  prime_elem p\n  p dvd prod_list []\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set []. p dvd a", "by (simp add: prime_elem_not_unit)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set []. p dvd a\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>p dvd prod_list A \\<Longrightarrow> Bex (set A) ((dvd) p);\n        p dvd prod_list (a # A)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (a # A)) ((dvd) p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>p dvd prod_list A \\<Longrightarrow> Bex (set A) ((dvd) p);\n        p dvd prod_list (a # A)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (a # A)) ((dvd) p)", "case (Cons a A)"], ["proof (state)\nthis:\n  p dvd prod_list A \\<Longrightarrow> \\<exists>a\\<in>set A. p dvd a\n  p dvd prod_list (a # A)\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>p dvd prod_list A \\<Longrightarrow> Bex (set A) ((dvd) p);\n        p dvd prod_list (a # A)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (a # A)) ((dvd) p)", "then"], ["proof (chain)\npicking this:\n  p dvd prod_list A \\<Longrightarrow> \\<exists>a\\<in>set A. p dvd a\n  p dvd prod_list (a # A)", "show ?case"], ["proof (prove)\nusing this:\n  p dvd prod_list A \\<Longrightarrow> \\<exists>a\\<in>set A. p dvd a\n  p dvd prod_list (a # A)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (a # A). p dvd a", "by (auto simp: prime_elem_dvd_mult_iff[OF p])"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (a # A). p dvd a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_elem_dvd_prod_mset:\n  assumes p: \"prime_elem p\" and pA: \"p dvd prod_mset A\" shows \"\\<exists>a \\<in># A. p dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#A. p dvd a", "proof(insert pA, induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd \\<Prod>\\<^sub># {#} \\<Longrightarrow> Multiset.Bex {#} ((dvd) p)\n 2. \\<And>x A.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># A \\<Longrightarrow>\n                Multiset.Bex A ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x A)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x A) ((dvd) p)", "case empty"], ["proof (state)\nthis:\n  p dvd \\<Prod>\\<^sub># {#}\n\ngoal (2 subgoals):\n 1. p dvd \\<Prod>\\<^sub># {#} \\<Longrightarrow> Multiset.Bex {#} ((dvd) p)\n 2. \\<And>x A.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># A \\<Longrightarrow>\n                Multiset.Bex A ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x A)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x A) ((dvd) p)", "with p"], ["proof (chain)\npicking this:\n  prime_elem p\n  p dvd \\<Prod>\\<^sub># {#}", "show ?case"], ["proof (prove)\nusing this:\n  prime_elem p\n  p dvd \\<Prod>\\<^sub># {#}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#{#}. p dvd a", "by (simp add: prime_elem_not_unit)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>#{#}. p dvd a\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># A \\<Longrightarrow>\n                Multiset.Bex A ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x A)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x A) ((dvd) p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># A \\<Longrightarrow>\n                Multiset.Bex A ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x A)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x A) ((dvd) p)", "case (add a A)"], ["proof (state)\nthis:\n  p dvd \\<Prod>\\<^sub># A \\<Longrightarrow> \\<exists>a\\<in>#A. p dvd a\n  p dvd \\<Prod>\\<^sub># (add_mset a A)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># A \\<Longrightarrow>\n                Multiset.Bex A ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x A)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x A) ((dvd) p)", "then"], ["proof (chain)\npicking this:\n  p dvd \\<Prod>\\<^sub># A \\<Longrightarrow> \\<exists>a\\<in>#A. p dvd a\n  p dvd \\<Prod>\\<^sub># (add_mset a A)", "show ?case"], ["proof (prove)\nusing this:\n  p dvd \\<Prod>\\<^sub># A \\<Longrightarrow> \\<exists>a\\<in>#A. p dvd a\n  p dvd \\<Prod>\\<^sub># (add_mset a A)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#add_mset a A. p dvd a", "by (auto simp: prime_elem_dvd_mult_iff[OF p])"], ["proof (state)\nthis:\n  \\<exists>a\\<in>#add_mset a A. p dvd a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_unit_dvd_iff[simp]:\n  assumes \"b dvd 1\"\n  shows \"a * b dvd c \\<longleftrightarrow> a dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * b dvd c) = (a dvd c)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a * b dvd c \\<Longrightarrow> a dvd c\n 2. a dvd c \\<Longrightarrow> a * b dvd c", "assume \"a * b dvd c\""], ["proof (state)\nthis:\n  a * b dvd c\n\ngoal (2 subgoals):\n 1. a * b dvd c \\<Longrightarrow> a dvd c\n 2. a dvd c \\<Longrightarrow> a * b dvd c", "with assms"], ["proof (chain)\npicking this:\n  b dvd (1::'a)\n  a * b dvd c", "show \"a dvd c\""], ["proof (prove)\nusing this:\n  b dvd (1::'a)\n  a * b dvd c\n\ngoal (1 subgoal):\n 1. a dvd c", "using dvd_mult_left[of a b c]"], ["proof (prove)\nusing this:\n  b dvd (1::'a)\n  a * b dvd c\n  a * b dvd c \\<Longrightarrow> a dvd c\n\ngoal (1 subgoal):\n 1. a dvd c", "by simp"], ["proof (state)\nthis:\n  a dvd c\n\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> a * b dvd c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> a * b dvd c", "assume \"a dvd c\""], ["proof (state)\nthis:\n  a dvd c\n\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> a * b dvd c", "with assms mult_dvd_mono"], ["proof (chain)\npicking this:\n  b dvd (1::'a)\n  \\<lbrakk>?a dvd ?b; ?c dvd ?d\\<rbrakk>\n  \\<Longrightarrow> ?a * ?c dvd ?b * ?d\n  a dvd c", "show \"a * b dvd c\""], ["proof (prove)\nusing this:\n  b dvd (1::'a)\n  \\<lbrakk>?a dvd ?b; ?c dvd ?d\\<rbrakk>\n  \\<Longrightarrow> ?a * ?c dvd ?b * ?d\n  a dvd c\n\ngoal (1 subgoal):\n 1. a * b dvd c", "by fastforce"], ["proof (state)\nthis:\n  a * b dvd c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_unit_dvd_iff'[simp]: \"a dvd 1 \\<Longrightarrow> (a * b) dvd c \\<longleftrightarrow> b dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> (a * b dvd c) = (b dvd c)", "using mult_unit_dvd_iff [of a b c]"], ["proof (prove)\nusing this:\n  a dvd (1::'a) \\<Longrightarrow> (b * a dvd c) = (b dvd c)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> (a * b dvd c) = (b dvd c)", "by (simp add: ac_simps)"], ["", "lemma irreducibleD':\n  assumes \"irreducible a\" \"b dvd a\"\n  shows   \"a dvd b \\<or> b dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd b \\<or> b dvd (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a dvd b \\<or> b dvd (1::'a)", "from assms"], ["proof (chain)\npicking this:\n  irreducible a\n  b dvd a", "obtain c where c: \"a = b * c\""], ["proof (prove)\nusing this:\n  irreducible a\n  b dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>c. a = b * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  a = b * c\n\ngoal (1 subgoal):\n 1. a dvd b \\<or> b dvd (1::'a)", "from irreducibleD[OF assms(1) this]"], ["proof (chain)\npicking this:\n  b dvd (1::'a) \\<or> c dvd (1::'a)", "have \"b dvd 1 \\<or> c dvd 1\""], ["proof (prove)\nusing this:\n  b dvd (1::'a) \\<or> c dvd (1::'a)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<or> c dvd (1::'a)", "."], ["proof (state)\nthis:\n  b dvd (1::'a) \\<or> c dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd b \\<or> b dvd (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  b dvd (1::'a) \\<or> c dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd b \\<or> b dvd (1::'a)", "by (auto simp: c)"], ["proof (state)\nthis:\n  a dvd b \\<or> b dvd (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context idom\nbegin"], ["", "text \\<open>\n  Following lemmas are adapted and generalized so that they don't use \"algebraic\" classes.\n\\<close>"], ["", "lemma dvd_times_left_cancel_iff [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"a * b dvd a * c \\<longleftrightarrow> b dvd c\"\n    (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * b dvd a * c) = (b dvd c)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a * b dvd a * c \\<Longrightarrow> b dvd c\n 2. b dvd c \\<Longrightarrow> a * b dvd a * c", "assume ?lhs"], ["proof (state)\nthis:\n  a * b dvd a * c\n\ngoal (2 subgoals):\n 1. a * b dvd a * c \\<Longrightarrow> b dvd c\n 2. b dvd c \\<Longrightarrow> a * b dvd a * c", "then"], ["proof (chain)\npicking this:\n  a * b dvd a * c", "obtain d where \"a * c = a * b * d\""], ["proof (prove)\nusing this:\n  a * b dvd a * c\n\ngoal (1 subgoal):\n 1. (\\<And>d. a * c = a * b * d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  a * c = a * b * d\n\ngoal (2 subgoals):\n 1. a * b dvd a * c \\<Longrightarrow> b dvd c\n 2. b dvd c \\<Longrightarrow> a * b dvd a * c", "with assms"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  a * c = a * b * d", "have \"c = b * d\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  a * c = a * b * d\n\ngoal (1 subgoal):\n 1. c = b * d", "by (auto simp add: ac_simps)"], ["proof (state)\nthis:\n  c = b * d\n\ngoal (2 subgoals):\n 1. a * b dvd a * c \\<Longrightarrow> b dvd c\n 2. b dvd c \\<Longrightarrow> a * b dvd a * c", "then"], ["proof (chain)\npicking this:\n  c = b * d", "show ?rhs"], ["proof (prove)\nusing this:\n  c = b * d\n\ngoal (1 subgoal):\n 1. b dvd c", ".."], ["proof (state)\nthis:\n  b dvd c\n\ngoal (1 subgoal):\n 1. b dvd c \\<Longrightarrow> a * b dvd a * c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b dvd c \\<Longrightarrow> a * b dvd a * c", "assume ?rhs"], ["proof (state)\nthis:\n  b dvd c\n\ngoal (1 subgoal):\n 1. b dvd c \\<Longrightarrow> a * b dvd a * c", "then"], ["proof (chain)\npicking this:\n  b dvd c", "obtain d where \"c = b * d\""], ["proof (prove)\nusing this:\n  b dvd c\n\ngoal (1 subgoal):\n 1. (\\<And>d. c = b * d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  c = b * d\n\ngoal (1 subgoal):\n 1. b dvd c \\<Longrightarrow> a * b dvd a * c", "then"], ["proof (chain)\npicking this:\n  c = b * d", "have \"a * c = a * b * d\""], ["proof (prove)\nusing this:\n  c = b * d\n\ngoal (1 subgoal):\n 1. a * c = a * b * d", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  a * c = a * b * d\n\ngoal (1 subgoal):\n 1. b dvd c \\<Longrightarrow> a * b dvd a * c", "then"], ["proof (chain)\npicking this:\n  a * c = a * b * d", "show ?lhs"], ["proof (prove)\nusing this:\n  a * c = a * b * d\n\ngoal (1 subgoal):\n 1. a * b dvd a * c", ".."], ["proof (state)\nthis:\n  a * b dvd a * c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_times_right_cancel_iff [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"b * a dvd c * a \\<longleftrightarrow> b dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b * a dvd c * a) = (b dvd c)", "using dvd_times_left_cancel_iff [of a b c] assms"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<Longrightarrow> (a * b dvd a * c) = (b dvd c)\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (b * a dvd c * a) = (b dvd c)", "by (simp add: ac_simps)"], ["", "lemma irreducibleI':\n  assumes \"a \\<noteq> 0\" \"\\<not> a dvd 1\" \"\\<And>b. b dvd a \\<Longrightarrow> a dvd b \\<or> b dvd 1\"\n  shows   \"irreducible a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible a", "proof (rule irreducibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<not> a dvd (1::'a)\n 3. \\<And>aa b.\n       a = aa * b \\<Longrightarrow> aa dvd (1::'a) \\<or> b dvd (1::'a)", "fix b c"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<not> a dvd (1::'a)\n 3. \\<And>aa b.\n       a = aa * b \\<Longrightarrow> aa dvd (1::'a) \\<or> b dvd (1::'a)", "assume a_eq: \"a = b * c\""], ["proof (state)\nthis:\n  a = b * c\n\ngoal (3 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<not> a dvd (1::'a)\n 3. \\<And>aa b.\n       a = aa * b \\<Longrightarrow> aa dvd (1::'a) \\<or> b dvd (1::'a)", "hence \"a dvd b \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  a = b * c\n\ngoal (1 subgoal):\n 1. a dvd b \\<or> b dvd (1::'a)", "by (intro assms) simp_all"], ["proof (state)\nthis:\n  a dvd b \\<or> b dvd (1::'a)\n\ngoal (3 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<not> a dvd (1::'a)\n 3. \\<And>aa b.\n       a = aa * b \\<Longrightarrow> aa dvd (1::'a) \\<or> b dvd (1::'a)", "thus \"b dvd 1 \\<or> c dvd 1\""], ["proof (prove)\nusing this:\n  a dvd b \\<or> b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<or> c dvd (1::'a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a dvd b \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)\n 2. b dvd (1::'a) \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)", "assume \"a dvd b\""], ["proof (state)\nthis:\n  a dvd b\n\ngoal (2 subgoals):\n 1. a dvd b \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)\n 2. b dvd (1::'a) \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)", "hence \"b * c dvd b * 1\""], ["proof (prove)\nusing this:\n  a dvd b\n\ngoal (1 subgoal):\n 1. b * c dvd b * (1::'a)", "by (simp add: a_eq)"], ["proof (state)\nthis:\n  b * c dvd b * (1::'a)\n\ngoal (2 subgoals):\n 1. a dvd b \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)\n 2. b dvd (1::'a) \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)", "moreover"], ["proof (state)\nthis:\n  b * c dvd b * (1::'a)\n\ngoal (2 subgoals):\n 1. a dvd b \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)\n 2. b dvd (1::'a) \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)", "from \\<open>a \\<noteq> 0\\<close> a_eq"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  a = b * c", "have \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  a = b * c\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. a dvd b \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)\n 2. b dvd (1::'a) \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  b * c dvd b * (1::'a)\n  b \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  b * c dvd b * (1::'a)\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<or> c dvd (1::'a)", "using dvd_times_left_cancel_iff"], ["proof (prove)\nusing this:\n  b * c dvd b * (1::'a)\n  b \\<noteq> (0::'a)\n  ?a \\<noteq> (0::'a) \\<Longrightarrow> (?a * ?b dvd ?a * ?c) = (?b dvd ?c)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<or> c dvd (1::'a)", "by fastforce"], ["proof (state)\nthis:\n  b dvd (1::'a) \\<or> c dvd (1::'a)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow> b dvd (1::'a) \\<or> c dvd (1::'a)", "qed blast"], ["proof (state)\nthis:\n  b dvd (1::'a) \\<or> c dvd (1::'a)\n\ngoal (2 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<not> a dvd (1::'a)", "qed (simp_all add: assms(1,2))"], ["", "lemma irreducible_altdef:\n  shows \"irreducible x \\<longleftrightarrow> x \\<noteq> 0 \\<and> \\<not> x dvd 1 \\<and> (\\<forall>b. b dvd x \\<longrightarrow> x dvd b \\<or> b dvd 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible x =\n    (x \\<noteq> (0::'a) \\<and>\n     \\<not> x dvd (1::'a) \\<and>\n     (\\<forall>b. b dvd x \\<longrightarrow> x dvd b \\<or> b dvd (1::'a)))", "using irreducibleI'[of x] irreducibleD'[of x] irreducible_not_unit[of x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> (0::'a); \\<not> x dvd (1::'a);\n   \\<And>b. b dvd x \\<Longrightarrow> x dvd b \\<or> b dvd (1::'a)\\<rbrakk>\n  \\<Longrightarrow> irreducible x\n  \\<lbrakk>irreducible x; ?b dvd x\\<rbrakk>\n  \\<Longrightarrow> x dvd ?b \\<or> ?b dvd (1::'a)\n  irreducible x \\<Longrightarrow> \\<not> x dvd (1::'a)\n\ngoal (1 subgoal):\n 1. irreducible x =\n    (x \\<noteq> (0::'a) \\<and>\n     \\<not> x dvd (1::'a) \\<and>\n     (\\<forall>b. b dvd x \\<longrightarrow> x dvd b \\<or> b dvd (1::'a)))", "by auto"], ["", "lemma dvd_mult_unit_iff:\n  assumes b: \"b dvd 1\"\n  shows \"a dvd c * b \\<longleftrightarrow> a dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "from b"], ["proof (chain)\npicking this:\n  b dvd (1::'a)", "obtain b' where 1: \"b * b' = 1\""], ["proof (prove)\nusing this:\n  b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>b'. b * b' = (1::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  b * b' = (1::'a)\n\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "then"], ["proof (chain)\npicking this:\n  b * b' = (1::'a)", "have b0: \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  b * b' = (1::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "from 1"], ["proof (chain)\npicking this:\n  b * b' = (1::'a)", "have \"a = (a * b') * b\""], ["proof (prove)\nusing this:\n  b * b' = (1::'a)\n\ngoal (1 subgoal):\n 1. a = a * b' * b", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  a = a * b' * b\n\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "also"], ["proof (state)\nthis:\n  a = a * b' * b\n\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "have \"\\<dots> dvd c * b \\<longleftrightarrow> a * b' dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * b' * b dvd c * b) = (a * b' dvd c)", "using b0"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (a * b' * b dvd c * b) = (a * b' dvd c)", "by auto"], ["proof (state)\nthis:\n  (a * b' * b dvd c * b) = (a * b' dvd c)\n\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "finally"], ["proof (chain)\npicking this:\n  (a dvd c * b) = (a * b' dvd c)", "show ?thesis"], ["proof (prove)\nusing this:\n  (a dvd c * b) = (a * b' dvd c)\n\ngoal (1 subgoal):\n 1. (a dvd c * b) = (a dvd c)", "by (auto intro: dvd_mult_left)"], ["proof (state)\nthis:\n  (a dvd c * b) = (a dvd c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_mult_unit_iff': \"b dvd 1 \\<Longrightarrow> a dvd b * c \\<longleftrightarrow> a dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow> (a dvd b * c) = (a dvd c)", "using dvd_mult_unit_iff [of b a c]"], ["proof (prove)\nusing this:\n  b dvd (1::'a) \\<Longrightarrow> (a dvd c * b) = (a dvd c)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow> (a dvd b * c) = (a dvd c)", "by (simp add: ac_simps)"], ["", "lemma irreducible_mult_unit_left:\n  shows \"a dvd 1 \\<Longrightarrow> irreducible (a * p) \\<longleftrightarrow> irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> irreducible (a * p) = irreducible p", "by (auto simp: irreducible_altdef mult.commute[of a] dvd_mult_unit_iff)"], ["", "lemma irreducible_mult_unit_right:\n  shows \"a dvd 1 \\<Longrightarrow> irreducible (p * a) \\<longleftrightarrow> irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> irreducible (p * a) = irreducible p", "by (auto simp: irreducible_altdef mult.commute[of a] dvd_mult_unit_iff)"], ["", "lemma prime_elem_imp_irreducible:\n  assumes \"prime_elem p\"\n  shows   \"irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p", "proof (rule irreducibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)\n 3. \\<And>a b. p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)", "fix a b"], ["proof (state)\ngoal (3 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)\n 3. \\<And>a b. p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)", "assume p_eq: \"p = a * b\""], ["proof (state)\nthis:\n  p = a * b\n\ngoal (3 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)\n 3. \\<And>a b. p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)", "with assms"], ["proof (chain)\npicking this:\n  prime_elem p\n  p = a * b", "have nz: \"a \\<noteq> 0\" \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime_elem p\n  p = a * b\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) &&& b \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)\n 3. \\<And>a b. p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)", "from p_eq"], ["proof (chain)\npicking this:\n  p = a * b", "have \"p dvd a * b\""], ["proof (prove)\nusing this:\n  p = a * b\n\ngoal (1 subgoal):\n 1. p dvd a * b", "by simp"], ["proof (state)\nthis:\n  p dvd a * b\n\ngoal (3 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)\n 3. \\<And>a b. p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)", "with \\<open>prime_elem p\\<close>"], ["proof (chain)\npicking this:\n  prime_elem p\n  p dvd a * b", "have \"p dvd a \\<or> p dvd b\""], ["proof (prove)\nusing this:\n  prime_elem p\n  p dvd a * b\n\ngoal (1 subgoal):\n 1. p dvd a \\<or> p dvd b", "by (rule prime_elem_dvd_multD)"], ["proof (state)\nthis:\n  p dvd a \\<or> p dvd b\n\ngoal (3 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)\n 3. \\<And>a b. p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)", "with \\<open>p = a * b\\<close>"], ["proof (chain)\npicking this:\n  p = a * b\n  p dvd a \\<or> p dvd b", "have \"a * b dvd 1 * b \\<or> a * b dvd a * 1\""], ["proof (prove)\nusing this:\n  p = a * b\n  p dvd a \\<or> p dvd b\n\ngoal (1 subgoal):\n 1. a * b dvd (1::'a) * b \\<or> a * b dvd a * (1::'a)", "by auto"], ["proof (state)\nthis:\n  a * b dvd (1::'a) * b \\<or> a * b dvd a * (1::'a)\n\ngoal (3 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)\n 3. \\<And>a b. p = a * b \\<Longrightarrow> a dvd (1::'a) \\<or> b dvd (1::'a)", "thus \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  a * b dvd (1::'a) * b \\<or> a * b dvd a * (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<or> b dvd (1::'a)", "by (simp only: dvd_times_left_cancel_iff[OF nz(1)] dvd_times_right_cancel_iff[OF nz(2)])"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<or> b dvd (1::'a)\n\ngoal (2 subgoals):\n 1. p \\<noteq> (0::'a)\n 2. \\<not> p dvd (1::'a)", "qed (insert assms, simp_all add: prime_elem_def)"], ["", "lemma unit_imp_dvd [dest]: \"b dvd 1 \\<Longrightarrow> b dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow> b dvd a", "by (rule dvd_trans [of _ 1]) simp_all"], ["", "lemma unit_mult_left_cancel: \"a dvd 1 \\<Longrightarrow> a * b = a * c \\<longleftrightarrow> b = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> (a * b = a * c) = (b = c)", "using mult_cancel_left [of a b c]"], ["proof (prove)\nusing this:\n  (a * b = a * c) = (a = (0::'a) \\<or> b = c)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> (a * b = a * c) = (b = c)", "by auto"], ["", "lemma unit_mult_right_cancel: \"a dvd 1 \\<Longrightarrow> b * a = c * a \\<longleftrightarrow> b = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> (b * a = c * a) = (b = c)", "using unit_mult_left_cancel [of a b c]"], ["proof (prove)\nusing this:\n  a dvd (1::'a) \\<Longrightarrow> (a * b = a * c) = (b = c)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<Longrightarrow> (b * a = c * a) = (b = c)", "by (auto simp add: ac_simps)"], ["", "text \\<open>New parts from here\\<close>"], ["", "lemma irreducible_multD:\n  assumes l: \"irreducible (a*b)\"\n  shows \"a dvd 1 \\<and> irreducible b \\<or> b dvd 1 \\<and> irreducible a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "from l"], ["proof (chain)\npicking this:\n  irreducible (a * b)", "have \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  irreducible (a * b)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<or> b dvd (1::'a)", "using irreducibleD"], ["proof (prove)\nusing this:\n  irreducible (a * b)\n  \\<lbrakk>irreducible ?p; ?p = ?a * ?b\\<rbrakk>\n  \\<Longrightarrow> ?a dvd (1::'a) \\<or> ?b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<or> b dvd (1::'a)", "by auto"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<or> b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "then"], ["proof (chain)\npicking this:\n  a dvd (1::'a) \\<or> b dvd (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a dvd (1::'a) \\<or> b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "proof(elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. a dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a\n 2. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "assume a: \"a dvd 1\""], ["proof (state)\nthis:\n  a dvd (1::'a)\n\ngoal (2 subgoals):\n 1. a dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a\n 2. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with l"], ["proof (chain)\npicking this:\n  irreducible (a * b)\n  a dvd (1::'a)", "have \"irreducible b\""], ["proof (prove)\nusing this:\n  irreducible (a * b)\n  a dvd (1::'a)\n\ngoal (1 subgoal):\n 1. irreducible b", "unfolding irreducible_def"], ["proof (prove)\nusing this:\n  a * b \\<noteq> (0::'a) \\<and>\n  \\<not> a * b dvd (1::'a) \\<and>\n  (\\<forall>aa ba.\n      a * b = aa * ba \\<longrightarrow> aa dvd (1::'a) \\<or> ba dvd (1::'a))\n  a dvd (1::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<and>\n    \\<not> b dvd (1::'a) \\<and>\n    (\\<forall>a ba.\n        b = a * ba \\<longrightarrow> a dvd (1::'a) \\<or> ba dvd (1::'a))", "by (metis is_unit_mult_iff mult.left_commute mult_not_zero)"], ["proof (state)\nthis:\n  irreducible b\n\ngoal (2 subgoals):\n 1. a dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a\n 2. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with a"], ["proof (chain)\npicking this:\n  a dvd (1::'a)\n  irreducible b", "show ?thesis"], ["proof (prove)\nusing this:\n  a dvd (1::'a)\n  irreducible b\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "by auto"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<and> irreducible b \\<or>\n  b dvd (1::'a) \\<and> irreducible a\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "assume a: \"b dvd 1\""], ["proof (state)\nthis:\n  b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with l"], ["proof (chain)\npicking this:\n  irreducible (a * b)\n  b dvd (1::'a)", "have \"irreducible a\""], ["proof (prove)\nusing this:\n  irreducible (a * b)\n  b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. irreducible a", "unfolding irreducible_def"], ["proof (prove)\nusing this:\n  a * b \\<noteq> (0::'a) \\<and>\n  \\<not> a * b dvd (1::'a) \\<and>\n  (\\<forall>aa ba.\n      a * b = aa * ba \\<longrightarrow> aa dvd (1::'a) \\<or> ba dvd (1::'a))\n  b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<and>\n    \\<not> a dvd (1::'a) \\<and>\n    (\\<forall>aa b.\n        a = aa * b \\<longrightarrow> aa dvd (1::'a) \\<or> b dvd (1::'a))", "by (meson is_unit_mult_iff mult_not_zero semiring_normalization_rules(16))"], ["proof (state)\nthis:\n  irreducible a\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with a"], ["proof (chain)\npicking this:\n  b dvd (1::'a)\n  irreducible a", "show ?thesis"], ["proof (prove)\nusing this:\n  b dvd (1::'a)\n  irreducible a\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "by auto"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<and> irreducible b \\<or>\n  b dvd (1::'a) \\<and> irreducible a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<and> irreducible b \\<or>\n  b dvd (1::'a) \\<and> irreducible a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in field) irreducible_field[simp]:\n  \"irreducible x \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible x = False", "by (auto simp: dvd_field_iff irreducible_def)"], ["", "lemma (in idom) irreducible_mult:\n  shows \"irreducible (a*b) \\<longleftrightarrow> a dvd 1 \\<and> irreducible b \\<or> b dvd 1 \\<and> irreducible a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (a * b) =\n    (a dvd (1::'a) \\<and> irreducible b \\<or>\n     b dvd (1::'a) \\<and> irreducible a)", "by (auto dest: irreducible_multD simp: irreducible_mult_unit_left irreducible_mult_unit_right)"], ["", "end"]]}