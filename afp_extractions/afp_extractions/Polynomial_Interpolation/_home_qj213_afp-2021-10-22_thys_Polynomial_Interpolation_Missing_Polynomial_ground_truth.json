{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Missing_Polynomial.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma degree_0_id: assumes \"degree p = 0\"\n  shows \"[: coeff p 0 :] = p\"", "lemma degree0_coeffs: \"degree p = 0 \\<Longrightarrow>\n  \\<exists> a. p = [: a :]\"", "lemma degree1_coeffs: \"degree p = 1 \\<Longrightarrow>\n  \\<exists> a b. p = [: b, a :] \\<and> a \\<noteq> 0\"", "lemma degree2_coeffs: \"degree p = 2 \\<Longrightarrow>\n  \\<exists> a b c. p = [: c, b, a :] \\<and> a \\<noteq> 0\"", "lemma poly_zero:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  assumes x: \"poly p x = 0\" shows \"p = 0 \\<longleftrightarrow> degree p = 0\"", "lemma coeff_monom_Suc: \"coeff (monom a (Suc d) * p) (Suc i) = coeff (monom a d * p) i\"", "lemma coeff_sum_monom:\n  assumes n: \"n \\<le> d\"\n  shows \"coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n\" (is \"?l = _\")", "lemma linear_poly_root: \"(a :: 'a :: comm_ring_1) \\<in> set as \\<Longrightarrow> poly (\\<Prod> a \\<leftarrow> as. [: - a, 1:]) a = 0\"", "lemma degree_lcoeff_sum: assumes deg: \"degree (f q) = n\"\n  and fin: \"finite S\" and q: \"q \\<in> S\" and degle: \"\\<And> p . p \\<in> S - {q} \\<Longrightarrow> degree (f p) < n\"\n  and cong: \"coeff (f q) n = c\"\n  shows \"degree (sum f S) = n \\<and> coeff (sum f S) n = c\"", "lemma degree_sum_list_le: \"(\\<And> p . p \\<in> set ps \\<Longrightarrow> degree p \\<le> n)\n  \\<Longrightarrow> degree (sum_list ps) \\<le> n\"", "lemma degree_prod_list_le: \"degree (prod_list ps) \\<le> sum_list (map degree ps)\"", "lemma smult_sum: \"smult (\\<Sum>i \\<in> S. f i) p = (\\<Sum>i \\<in> S. smult (f i) p)\"", "lemma range_coeff: \"range (coeff p) = insert 0 (set (coeffs p))\"", "lemma smult_power: \"(smult a p) ^ n = smult (a ^ n) (p ^ n)\"", "lemma poly_sum_list: \"poly (sum_list ps) x = sum_list (map (\\<lambda> p. poly p x) ps)\"", "lemma poly_prod_list: \"poly (prod_list ps) x = prod_list (map (\\<lambda> p. poly p x) ps)\"", "lemma sum_list_neutral: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> x = 0) \\<Longrightarrow> sum_list xs = 0\"", "lemma prod_list_neutral: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> x = 1) \\<Longrightarrow> prod_list xs = 1\"", "lemma (in comm_monoid_mult) prod_list_map_remove1:\n  \"x \\<in> set xs \\<Longrightarrow> prod_list (map f xs) = f x * prod_list (map f (remove1 x xs))\"", "lemma poly_as_sum:\n  fixes p :: \"'a::comm_semiring_1 poly\"\n  shows \"poly p x = (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)\"", "lemma poly_prod_0: \"finite ps \\<Longrightarrow> poly (prod f ps) x = (0 :: 'a :: field) \\<longleftrightarrow> (\\<exists> p \\<in> ps. poly (f p) x = 0)\"", "lemma coeff_monom_mult:\n  shows \"coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i-d) else 0)\" (is \"?l = ?r\")", "lemma poly_eqI2:\n  assumes \"degree p = degree q\" and \"\\<And>i. i \\<le> degree p \\<Longrightarrow> coeff p i = coeff q i\"\n  shows \"p = q\"", "lemma poly_ext[intro]:\n  fixes p q :: \"'a :: {ring_char_0, idom} poly\"\n  assumes \"\\<And>x. poly p x = poly q x\" shows \"p = q\"", "lemma coeff_linear_power_neg[simp]:\n  fixes a :: \"'a::comm_ring_1\"\n  shows \"coeff ([:a, -1:] ^ n) n = (-1)^n\"", "lemma degree_linear_power_neg[simp]:\n  fixes a :: \"'a::{idom,comm_ring_1}\"\n  shows \"degree ([:a, -1:] ^ n) = n\"", "lemmas [simp] = pcompose_pCons", "lemma pcompose_eq_0: fixes q :: \"'a :: idom poly\"\n  assumes q: \"degree q \\<noteq> 0\"\n  shows \"p \\<circ>\\<^sub>p q = 0 \\<longleftrightarrow> p = 0\"", "lemma unit_factor_field [simp]: \n  \"unit_factor (x :: 'a :: {field,normalization_semidom}) = x\"", "lemma poly_gcd_monic: \n  fixes p :: \"'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes \"p \\<noteq> 0 \\<or> q \\<noteq> 0\"\n  shows   \"monic (gcd p q)\"", "lemma normalize_monic: \"monic p \\<Longrightarrow> normalize p = p\"", "lemma lcoeff_monic_mult: assumes monic: \"monic (p :: 'a :: comm_semiring_1 poly)\"\n  shows \"coeff (p * q) (degree p + degree q) = coeff q (degree q)\"", "lemma degree_monic_mult: assumes monic: \"monic (p :: 'a :: comm_semiring_1 poly)\"\n  and q: \"q \\<noteq> 0\"\n  shows \"degree (p * q) = degree p + degree q\"", "lemma degree_prod_sum_monic: assumes\n  S: \"finite S\"\n  and nzd: \"0 \\<notin> (degree o f) ` S\"\n  and monic: \"(\\<And> a . a \\<in> S \\<Longrightarrow> monic (f a))\"\n  shows \"degree (prod f S) = (sum (degree o f) S) \\<and> coeff (prod f S) (sum (degree o f) S) = 1\"", "lemma degree_prod_monic: \n  assumes \"\\<And> i. i < n \\<Longrightarrow> degree (f i :: 'a :: comm_semiring_1 poly) = 1\"\n    and \"\\<And> i. i < n \\<Longrightarrow> coeff (f i) 1 = 1\"\n  shows \"degree (prod f {0 ..< n}) = n \\<and> coeff (prod f {0 ..< n}) n = 1\"", "lemma degree_prod_sum_lt_n: assumes \"\\<And> i. i < n \\<Longrightarrow> degree (f i :: 'a :: comm_semiring_1 poly) \\<le> 1\"\n  and i: \"i < n\" and fi: \"degree (f i) = 0\"\n  shows \"degree (prod f {0 ..< n}) < n\"", "lemma degree_linear_factors: \"degree (\\<Prod> a \\<leftarrow> as. [: f a, 1:]) = length as\"", "lemma monic_mult:\n  fixes p q :: \"'a :: idom poly\"\n  assumes \"monic p\" \"monic q\"\n  shows \"monic (p * q)\"", "lemma monic_factor:\n  fixes p q :: \"'a :: idom poly\"\n  assumes \"monic (p * q)\" \"monic p\"\n  shows \"monic q\"", "lemma monic_prod:\n  fixes f :: \"'a \\<Rightarrow> 'b :: idom poly\"\n  assumes \"\\<And> a. a \\<in> as \\<Longrightarrow> monic (f a)\"\n  shows \"monic (prod f as)\"", "lemma monic_prod_list:\n  fixes as :: \"'a :: idom poly list\"\n  assumes \"\\<And> a. a \\<in> set as \\<Longrightarrow> monic a\"\n  shows \"monic (prod_list as)\"", "lemma monic_power:\n  assumes \"monic (p :: 'a :: idom poly)\"\n  shows \"monic (p ^ n)\"", "lemma monic_prod_list_pow: \"monic (\\<Prod>(x::'a::idom, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\"", "lemma monic_degree_0: \"monic p \\<Longrightarrow> (degree p = 0) = (p = 1)\"", "lemma poly_roots_degree:\n  fixes p :: \"'a::idom poly\"\n  shows \"p \\<noteq> 0 \\<Longrightarrow> card {x. poly p x = 0} \\<le> degree p\"", "lemma poly_root_factor: \"(poly ([: r, 1:] * q) (k :: 'a :: idom) = 0) = (k = -r \\<or> poly q k = 0)\" (is ?one)\n  \"(poly (q * [: r, 1:]) k = 0) = (k = -r \\<or> poly q k = 0)\" (is ?two)\n  \"(poly [: r, 1 :] k = 0) = (k = -r)\" (is ?three)", "lemma poly_root_constant: \"c \\<noteq> 0 \\<Longrightarrow> (poly (p * [:c:]) (k :: 'a :: idom) = 0) = (poly p k = 0)\"", "lemma poly_linear_exp_linear_factors_rev: \n  \"([:b,1:])^(length (filter ((=) b) as)) dvd (\\<Prod> (a :: 'a :: comm_ring_1) \\<leftarrow> as. [: a, 1:])\"", "lemma order_max: assumes dvd: \"[: -a, 1 :] ^ k dvd p\" and p: \"p \\<noteq> 0\"\n  shows \"k \\<le> order a p\"", "lemma poly_linear_linear_factor: assumes \n  dvd: \"[:b,1:] dvd (\\<Prod> (a :: 'a) \\<leftarrow> as. [: a, 1:])\"\n  shows \"b \\<in> set as\"", "lemma poly_linear_exp_linear_factors: \n  assumes dvd: \"([:b,1:])^n dvd (\\<Prod> (a :: 'a) \\<leftarrow> as. [: a, 1:])\"\n  shows \"length (filter ((=) b) as) \\<ge> n\"", "lemma const_poly_dvd: \"([:a:] dvd [:b:]) = (a dvd b)\"", "lemma const_poly_dvd_1 [simp]:\n  \"[:a:] dvd 1 \\<longleftrightarrow> a dvd 1\"", "lemma poly_dvd_1:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  shows \"p dvd 1 \\<longleftrightarrow> degree p = 0 \\<and> coeff p 0 dvd 1\"", "lemma irreducible\\<^sub>dI [intro]:\n  assumes 1: \"degree p > 0\"\n    and 2: \"\\<And>q r. degree q > 0 \\<Longrightarrow> degree q < degree p \\<Longrightarrow> degree r > 0 \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p = q * r \\<Longrightarrow> False\"\n  shows \"irreducible\\<^sub>d p\"", "lemma irreducible\\<^sub>dI2:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes deg: \"degree p > 0\" and ndvd: \"\\<And> q. degree q > 0 \\<Longrightarrow> degree q \\<le> degree p div 2 \\<Longrightarrow> \\<not> q dvd p\"\n  shows \"irreducible\\<^sub>d p\"", "lemma reducible\\<^sub>dI:\n  assumes \"degree p > 0 \\<Longrightarrow> \\<exists>q r. degree q < degree p \\<and> degree r < degree p \\<and> p = q * r\"\n  shows \"\\<not> irreducible\\<^sub>d p\"", "lemma irreducible\\<^sub>dE [elim]:\n  assumes \"irreducible\\<^sub>d p\"\n    and \"degree p > 0 \\<Longrightarrow> (\\<And>q r. degree q < degree p \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p \\<noteq> q * r) \\<Longrightarrow> thesis\"\n  shows thesis", "lemma reducible\\<^sub>dE [elim]:\n  assumes red: \"\\<not> irreducible\\<^sub>d p\"\n    and 1: \"degree p = 0 \\<Longrightarrow> thesis\"\n    and 2: \"\\<And>q r. degree q > 0 \\<Longrightarrow> degree q < degree p \\<Longrightarrow> degree r > 0 \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p = q * r \\<Longrightarrow> thesis\"\n  shows thesis", "lemma irreducible\\<^sub>dD:\n  assumes \"irreducible\\<^sub>d p\"\n  shows \"degree p > 0\" \"\\<And>q r. degree q < degree p \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p \\<noteq> q * r\"", "theorem irreducible\\<^sub>d_factorization_exists:\n  assumes \"degree p > 0\"\n  shows \"\\<exists>fs. fs \\<noteq> [] \\<and> (\\<forall>f \\<in> set fs. irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and> p = prod_list fs\"\n    and \"\\<not>irreducible\\<^sub>d p \\<Longrightarrow> \\<exists>fs. length fs > 1 \\<and> (\\<forall>f \\<in> set fs. irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and> p = prod_list fs\"", "lemma irreducible\\<^sub>d_factor:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"degree p > 0\"\n  shows \"\\<exists> q r. irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\"", "lemma zero_divisorI[intro]:\n  assumes \"b \\<noteq> 0\" and \"a * b = 0\" shows \"zero_divisor a\"", "lemma zero_divisorE[elim]:\n  assumes \"zero_divisor a\"\n    and \"\\<And>b. b \\<noteq> 0 \\<Longrightarrow> a * b = 0 \\<Longrightarrow> thesis\"\n  shows thesis", "lemma zero_divisor_0[simp]:\n  \"zero_divisor (0::'a::{mult_zero,zero_neq_one})\"", "lemma not_zero_divisor_1:\n  \"\\<not> zero_divisor (1 :: 'a :: {monoid_mult,mult_zero})\"", "lemma zero_divisor_iff_eq_0[simp]:\n  fixes a :: \"'a :: {semiring_no_zero_divisors, zero_neq_one}\"\n  shows \"zero_divisor a \\<longleftrightarrow> a = 0\"", "lemma mult_eq_0_not_zero_divisor_left[simp]:\n  fixes a b :: \"'a :: mult_zero\"\n  assumes \"\\<not> zero_divisor a\"\n  shows \"a * b = 0 \\<longleftrightarrow> b = 0\"", "lemma mult_eq_0_not_zero_divisor_right[simp]:\n  fixes a b :: \"'a :: {ab_semigroup_mult,mult_zero}\" (* No need for associativity! *)\n  assumes \"\\<not> zero_divisor b\"\n  shows \"a * b = 0 \\<longleftrightarrow> a = 0\"", "lemma degree_smult_not_zero_divisor_left[simp]:\n  assumes \"\\<not> zero_divisor c\"\n  shows \"degree (smult c p) = degree p\"", "lemma degree_smult_not_zero_divisor_right[simp]:\n  assumes \"\\<not> zero_divisor (lead_coeff p)\"\n  shows \"degree (smult c p) = (if c = 0 then 0 else degree p)\"", "lemma irreducible\\<^sub>d_smult_not_zero_divisor_left:\n  assumes c0: \"\\<not> zero_divisor c\"\n  assumes L: \"irreducible\\<^sub>d (smult c p)\"\n  shows \"irreducible\\<^sub>d p\"", "lemmas irreducible\\<^sub>d_smultI =\n  irreducible\\<^sub>d_smult_not_zero_divisor_left\n  [where 'a = \"'a :: {comm_semiring_1,semiring_no_zero_divisors}\", simplified]", "lemma irreducible\\<^sub>d_smult_not_zero_divisor_right:\n  assumes p0: \"\\<not> zero_divisor (lead_coeff p)\" and L: \"irreducible\\<^sub>d (smult c p)\"\n  shows \"irreducible\\<^sub>d p\"", "lemma zero_divisor_mult_left:\n  fixes a b :: \"'a :: {ab_semigroup_mult, mult_zero}\"\n  assumes \"zero_divisor a\"\n  shows \"zero_divisor (a * b)\"", "lemma zero_divisor_mult_right:\n  fixes a b :: \"'a :: {semigroup_mult, mult_zero}\"\n  assumes \"zero_divisor b\"\n  shows \"zero_divisor (a * b)\"", "lemma not_zero_divisor_mult:\n  fixes a b :: \"'a :: {ab_semigroup_mult, mult_zero}\"\n  assumes \"\\<not> zero_divisor (a * b)\"\n  shows \"\\<not> zero_divisor a\" and \"\\<not> zero_divisor b\"", "lemma zero_divisor_smult_left:\n  assumes \"zero_divisor a\"\n  shows \"zero_divisor (smult a f)\"", "lemma unit_not_zero_divisor:\n  fixes a :: \"'a :: {comm_monoid_mult, mult_zero}\"\n  assumes \"a dvd 1\"\n  shows \"\\<not>zero_divisor a\"", "lemma linear_irreducible\\<^sub>d: assumes \"degree p = 1\"\n  shows \"irreducible\\<^sub>d p\"", "lemma irreducible\\<^sub>d_dvd_smult:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"degree p > 0\" \"irreducible\\<^sub>d q\" \"p dvd q\"\n  shows \"\\<exists> c. c \\<noteq> 0 \\<and> q = smult c p\"", "lemma map_poly_simps:\n  shows \"map_poly f (pCons c p) =\n    (if c = 0 \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\"", "lemma map_poly_pCons[simp]:\n  assumes \"c \\<noteq> 0 \\<or> p \\<noteq> 0\"\n  shows \"map_poly f (pCons c p) = pCons (f c) (map_poly f p)\"", "lemma map_poly_map_poly:\n  assumes f0: \"f 0 = 0\"\n  shows \"map_poly f (map_poly g p) = map_poly (f \\<circ> g) p\"", "lemma map_poly_zero:\n  assumes f: \"\\<forall>c. f c = 0 \\<longrightarrow> c = 0\"\n  shows [simp]: \"map_poly f p = 0 \\<longleftrightarrow> p = 0\"", "lemma map_poly_add:\n  assumes h0: \"h 0 = 0\"\n      and h_add: \"\\<forall>p q. h (p + q) = h p + h q\"\n  shows \"map_poly h (p + q) = map_poly h p + map_poly h q\"", "lemma monom_pCons_0_monom:\n  \"monom (pCons 0 (monom a n)) d = map_poly (pCons 0) (monom (monom a n) d)\"", "lemma pCons_0_add: \"pCons 0 (p + q) = pCons 0 p + pCons 0 q\"", "lemma sum_pCons_0_commute:\n  \"sum (\\<lambda>i. pCons 0 (f i)) S = pCons 0 (sum f S)\"", "lemma pCons_0_as_mult:\n  fixes p:: \"'a :: comm_semiring_1 poly\"\n  shows \"pCons 0 p = [:0,1:] * p\"", "lemma expand_powers: fixes f :: \"'a \\<Rightarrow> 'b :: comm_ring_1\"\n  shows \"(\\<Prod> (n,a) \\<leftarrow> n_as. f a ^ n) = (\\<Prod> a \\<leftarrow> expand_powers n_as. f a)\"", "lemma poly_smult_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (smult a p) x = 0) = (a = 0 \\<or> poly p x = 0)\"", "lemma poly_prod_list_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (prod_list ps) x = 0) = (\\<exists> p \\<in> set ps. poly p x = 0)\"", "lemma poly_mult_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (p * q) x = 0) = (poly p x = 0 \\<or> poly q x = 0)\"", "lemma poly_power_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (p^n) x = 0) = (n \\<noteq> 0 \\<and> poly p x = 0)\"", "lemma sum_monom_0_iff: assumes fin: \"finite S\"\n  and g: \"\\<And> i j. g i = g j \\<Longrightarrow> i = j\"\n  shows \"sum (\\<lambda> i. monom (f i) (g i)) S = 0 \\<longleftrightarrow> (\\<forall> i \\<in> S. f i = 0)\" (is \"?l = ?r\")", "lemma degree_prod_list_eq: assumes \"\\<And> p. p \\<in> set ps \\<Longrightarrow> (p :: 'a :: idom poly) \\<noteq> 0\"\n  shows \"degree (prod_list ps) = sum_list (map degree ps)\"", "lemma degree_power_eq: assumes p: \"p \\<noteq> 0\"\n  shows \"degree (p ^ n) = degree (p :: 'a :: idom poly) * n\"", "lemma coeff_Poly: \"coeff (Poly xs) i = (nth_default 0 xs i)\"", "lemma rsquarefree_def': \"rsquarefree p = (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))\"", "lemma order_prod_list: \"(\\<And> p. p \\<in> set ps \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow> order x (prod_list ps) = sum_list (map (order x) ps)\"", "lemma irreducible\\<^sub>d_dvd_eq:\n  fixes a b :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"irreducible\\<^sub>d a\" and \"irreducible\\<^sub>d b\"\n    and \"a dvd b\"\n    and \"monic a\" and \"monic b\" \n  shows \"a = b\"", "lemma monic_gcd_dvd:\n  assumes fg: \"f dvd g\" and mon: \"monic f\" and gcd: \"gcd g h \\<in> {1, g}\"\n  shows \"gcd f h \\<in> {1, f}\"", "lemma monom_power: \"(monom a b)^n = monom (a^n) (b*n)\"", "lemma poly_const_pow: \"[:a:]^b = [:a^b:]\"", "lemma degree_pderiv_le: \"degree (pderiv f) \\<le> degree f - 1\"", "lemma map_div_is_smult_inverse: \"map_poly (\\<lambda>x. x / (a :: 'a :: field)) p = smult (inverse a) p\"", "lemma normalize_poly_old_def:\n  \"normalize (f :: 'a :: {normalization_semidom,field} poly) = smult (inverse (unit_factor (lead_coeff f))) f\"", "lemma poly_dvd_antisym:\n  fixes p q :: \"'b::idom poly\"\n  assumes coeff: \"coeff p (degree p) = coeff q (degree q)\"\n  assumes dvd1: \"p dvd q\" and dvd2: \"q dvd p\" shows \"p = q\"", "lemma coeff_f_0_code[code_unfold]: \"coeff f 0 = (case coeffs f of [] \\<Rightarrow> 0 | x # _ \\<Rightarrow> x)\"", "lemma poly_compare_0_code[code_unfold]: \"(f = 0) = (case coeffs f of [] \\<Rightarrow> True | _ \\<Rightarrow> False)\"", "lemma leading_coeff_code [code]:\n  \"leading_coeff f = (let xs = coeffs f in if xs = [] then 0 else last xs)\"", "lemma nth_coeffs_coeff: \"i < length (coeffs f) \\<Longrightarrow> coeffs f ! i = coeff f i\"", "lemma monom_mult_unfold [code_unfold]:\n  \"monom 1 n * f = monom_mult n f\"\n  \"f * monom 1 n = monom_mult n f\"", "lemma monom_mult_code [code abstract]:\n  \"coeffs (monom_mult n f) = (let xs = coeffs f in\n    if xs = [] then xs else replicate n 0 @ xs)\"", "lemma coeff_pcompose_monom: fixes f :: \"'a :: comm_ring_1 poly\" \n  assumes n: \"j < n\" \n  shows \"coeff (f \\<circ>\\<^sub>p monom 1 n) (n * i + j) = (if j = 0 then coeff f i else 0)\"", "lemma coeff_pcompose_x_pow_n: fixes f :: \"'a :: comm_ring_1 poly\" \n  assumes n: \"n \\<noteq> 0\" \n  shows \"coeff (f \\<circ>\\<^sub>p monom 1 n) (n * i) = coeff f i\"", "lemma dvd_dvd_smult: \"a dvd b \\<Longrightarrow> f dvd g \\<Longrightarrow> smult a f dvd smult b g\"", "lemma smult_map_poly: \"smult a = map_poly ((*) a)\"", "lemma smult_exact_sdiv_poly: assumes \"\\<And> c. c \\<in> set (coeffs p) \\<Longrightarrow> a dvd c\"\n  shows \"smult a (sdiv_poly p a) = p\"", "lemma coeff_sdiv_poly: \"coeff (sdiv_poly f a) n = coeff f n div a\"", "lemma poly_pinfty_ge:\n  fixes p :: \"real poly\"\n  assumes \"lead_coeff p > 0\" \"degree p \\<noteq> 0\" \n  shows \"\\<exists>n. \\<forall> x \\<ge> n. poly p x \\<ge> b\"", "lemma pderiv_sum: \"pderiv (sum f I) = sum (\\<lambda> i. (pderiv (f i))) I\"", "lemma smult_sum2: \"smult m (\\<Sum>i \\<in> S. f i) = (\\<Sum>i \\<in> S. smult m (f i))\"", "lemma degree_mult_not_eq:\n  \"degree (f * g) \\<noteq> degree f + degree g \\<Longrightarrow> lead_coeff f * lead_coeff g = 0\"", "lemma irreducible\\<^sub>d_multD:\n  fixes a b :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes l: \"irreducible\\<^sub>d (a*b)\"\n  shows \"degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or> degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\"", "lemma irreducible_connect_field[simp]:\n  fixes f :: \"'a :: field poly\"\n  shows \"irreducible\\<^sub>d f = irreducible f\" (is \"?l = ?r\")", "lemma is_unit_field_poly[simp]:\n  fixes p :: \"'a::field poly\"\n  shows \"is_unit p \\<longleftrightarrow> p \\<noteq> 0 \\<and> degree p = 0\"", "lemma irreducible_smult_field[simp]:\n  fixes c :: \"'a :: field\"\n  shows \"irreducible (smult c p) \\<longleftrightarrow> c \\<noteq> 0 \\<and> irreducible p\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma irreducible_monic_factor: fixes p :: \"'a :: field poly\" \n  assumes \"degree p > 0\" \n  shows \"\\<exists> q r. irreducible q \\<and> p = q * r \\<and> monic q\"", "lemma monic_irreducible_factorization: fixes p :: \"'a :: field poly\" \n  shows \"monic p \\<Longrightarrow> \n  \\<exists> as f. finite as \\<and> p = prod (\\<lambda> a. a ^ Suc (f a)) as \\<and> as \\<subseteq> {q. irreducible q \\<and> monic q}\"", "lemma monic_irreducible_gcd: \n  \"monic (f::'a::{field,euclidean_ring_gcd,semiring_gcd_mult_normalize,\n                  normalization_euclidean_semiring_multiplicative} poly) \\<Longrightarrow>\n   irreducible f \\<Longrightarrow> gcd f u \\<in> {1,f}\""], "translations": [["", "lemma degree_0_id: assumes \"degree p = 0\"\n  shows \"[: coeff p 0 :] = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:coeff p 0:] = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [:coeff p 0:] = p", "have \"\\<And> x. 0 \\<noteq> Suc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<noteq> Suc x", "by auto"], ["proof (state)\nthis:\n  0 \\<noteq> Suc ?x\n\ngoal (1 subgoal):\n 1. [:coeff p 0:] = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<noteq> Suc ?x\n\ngoal (1 subgoal):\n 1. [:coeff p 0:] = p", "using assms"], ["proof (prove)\nusing this:\n  0 \\<noteq> Suc ?x\n  degree p = 0\n\ngoal (1 subgoal):\n 1. [:coeff p 0:] = p", "by (metis coeff_pCons_0 degree_pCons_eq_if pCons_cases)"], ["proof (state)\nthis:\n  [:coeff p 0:] = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree0_coeffs: \"degree p = 0 \\<Longrightarrow>\n  \\<exists> a. p = [: a :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow> \\<exists>a. p = [:a:]", "by (metis degree_pCons_eq_if old.nat.distinct(2) pCons_cases)"], ["", "lemma degree1_coeffs: \"degree p = 1 \\<Longrightarrow>\n  \\<exists> a b. p = [: b, a :] \\<and> a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow>\n    \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> (0::'a)", "by (metis One_nat_def degree_pCons_eq_if nat.inject old.nat.distinct(2) pCons_0_0 pCons_cases)"], ["", "lemma degree2_coeffs: \"degree p = 2 \\<Longrightarrow>\n  \\<exists> a b c. p = [: c, b, a :] \\<and> a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 2 \\<Longrightarrow>\n    \\<exists>a b c. p = [:c, b, a:] \\<and> a \\<noteq> (0::'a)", "by (metis Suc_1 Suc_neq_Zero degree1_coeffs degree_pCons_eq_if nat.inject pCons_cases)"], ["", "lemma poly_zero:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  assumes x: \"poly p x = 0\" shows \"p = 0 \\<longleftrightarrow> degree p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = 0) = (degree p = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p = 0", "assume degp: \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p = 0", "hence \"poly p x = coeff p (degree p)\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. poly p x = lead_coeff p", "by(subst degree_0_id[OF degp,symmetric], simp)"], ["proof (state)\nthis:\n  poly p x = lead_coeff p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p = 0", "hence \"coeff p (degree p) = 0\""], ["proof (prove)\nusing this:\n  poly p x = lead_coeff p\n\ngoal (1 subgoal):\n 1. lead_coeff p = (0::'a)", "using x"], ["proof (prove)\nusing this:\n  poly p x = lead_coeff p\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff p = (0::'a)", "by auto"], ["proof (state)\nthis:\n  lead_coeff p = (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p = 0", "thus \"p = 0\""], ["proof (prove)\nusing this:\n  lead_coeff p = (0::'a)\n\ngoal (1 subgoal):\n 1. p = 0", "by auto"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> degree p = 0", "qed auto"], ["", "lemma coeff_monom_Suc: \"coeff (monom a (Suc d) * p) (Suc i) = coeff (monom a d * p) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (monom a (Suc d) * p) (Suc i) = coeff (monom a d * p) i", "by (simp add: monom_Suc)"], ["", "lemma coeff_sum_monom:\n  assumes n: \"n \\<le> d\"\n  shows \"coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n\" (is \"?l = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "have \"?l = (\\<Sum>i\\<le>d. coeff (monom (f i) i) n)\" (is \"_ = sum ?cmf _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n =\n    (\\<Sum>i\\<le>d. coeff (monom (f i) i) n)", "using coeff_sum"], ["proof (prove)\nusing this:\n  coeff (sum ?p ?A) ?i = (\\<Sum>x\\<in>?A. coeff (?p x) ?i)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n =\n    (\\<Sum>i\\<le>d. coeff (monom (f i) i) n)", "."], ["proof (state)\nthis:\n  coeff (\\<Sum>i\\<le>d. monom (f i) i) n =\n  (\\<Sum>i\\<le>d. coeff (monom (f i) i) n)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "also"], ["proof (state)\nthis:\n  coeff (\\<Sum>i\\<le>d. monom (f i) i) n =\n  (\\<Sum>i\\<le>d. coeff (monom (f i) i) n)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "have \"{..d} = insert n ({..d}-{n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..d} = insert n ({..d} - {n})", "using n"], ["proof (prove)\nusing this:\n  n \\<le> d\n\ngoal (1 subgoal):\n 1. {..d} = insert n ({..d} - {n})", "by auto"], ["proof (state)\nthis:\n  {..d} = insert n ({..d} - {n})\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "hence \"sum ?cmf {..d} = sum ?cmf ...\""], ["proof (prove)\nusing this:\n  {..d} = insert n ({..d} - {n})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>d. coeff (monom (f i) i) n) =\n    (\\<Sum>i\\<in>insert n ({..d} - {n}). coeff (monom (f i) i) n)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>d. coeff (monom (f i) i) n) =\n  (\\<Sum>i\\<in>insert n ({..d} - {n}). coeff (monom (f i) i) n)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>d. coeff (monom (f i) i) n) =\n  (\\<Sum>i\\<in>insert n ({..d} - {n}). coeff (monom (f i) i) n)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "have \"... = sum ?cmf ({..d}-{n}) + ?cmf n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert n ({..d} - {n}). coeff (monom (f i) i) n) =\n    (\\<Sum>i\\<in>{..d} - {n}. coeff (monom (f i) i) n) +\n    coeff (monom (f n) n) n", "by (subst sum.insert,auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert n ({..d} - {n}). coeff (monom (f i) i) n) =\n  (\\<Sum>i\\<in>{..d} - {n}. coeff (monom (f i) i) n) +\n  coeff (monom (f n) n) n\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert n ({..d} - {n}). coeff (monom (f i) i) n) =\n  (\\<Sum>i\\<in>{..d} - {n}. coeff (monom (f i) i) n) +\n  coeff (monom (f n) n) n\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "have \"sum ?cmf ({..d}-{n}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..d} - {n}. coeff (monom (f i) i) n) = (0::'a)", "by (subst sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..d} - {n}. coeff (monom (f i) i) n) = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "finally"], ["proof (chain)\npicking this:\n  coeff (\\<Sum>i\\<le>d. monom (f i) i) n = (0::'a) + coeff (monom (f n) n) n", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (\\<Sum>i\\<le>d. monom (f i) i) n = (0::'a) + coeff (monom (f n) n) n\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n", "by simp"], ["proof (state)\nthis:\n  coeff (\\<Sum>i\\<le>d. monom (f i) i) n = f n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_poly_root: \"(a :: 'a :: comm_ring_1) \\<in> set as \\<Longrightarrow> poly (\\<Prod> a \\<leftarrow> as. [: - a, 1:]) a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set as \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a)", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>[]. [:- a, 1::'a:]) a = (0::'a)\n 2. \\<And>aa as.\n       \\<lbrakk>a \\<in> set as \\<Longrightarrow>\n                poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a);\n        a \\<in> set (aa # as)\\<rbrakk>\n       \\<Longrightarrow> poly (\\<Prod>a\\<leftarrow>aa # as. [:- a, 1::'a:])\n                          a =\n                         (0::'a)", "case (Cons b as)"], ["proof (state)\nthis:\n  a \\<in> set as \\<Longrightarrow>\n  poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a)\n  a \\<in> set (b # as)\n\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>[]. [:- a, 1::'a:]) a = (0::'a)\n 2. \\<And>aa as.\n       \\<lbrakk>a \\<in> set as \\<Longrightarrow>\n                poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a);\n        a \\<in> set (aa # as)\\<rbrakk>\n       \\<Longrightarrow> poly (\\<Prod>a\\<leftarrow>aa # as. [:- a, 1::'a:])\n                          a =\n                         (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)", "proof (cases \"a = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)\n 2. a \\<noteq> b \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)\n 2. a \\<noteq> b \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)", "with Cons"], ["proof (chain)\npicking this:\n  a \\<in> set as \\<Longrightarrow>\n  poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a)\n  a \\<in> set (b # as)\n  a \\<noteq> b", "have \"a \\<in> set as\""], ["proof (prove)\nusing this:\n  a \\<in> set as \\<Longrightarrow>\n  poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a)\n  a \\<in> set (b # as)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<in> set as", "by auto"], ["proof (state)\nthis:\n  a \\<in> set as\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)\n 2. a \\<noteq> b \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)", "from Cons(1)[OF this]"], ["proof (chain)\npicking this:\n  poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) a = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)", "qed simp"], ["proof (state)\nthis:\n  poly (\\<Prod>a\\<leftarrow>b # as. [:- a, 1::'a:]) a = (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<in> set [] \\<Longrightarrow>\n    poly (\\<Prod>a\\<leftarrow>[]. [:- a, 1::'a:]) a = (0::'a)", "qed simp"], ["", "lemma degree_lcoeff_sum: assumes deg: \"degree (f q) = n\"\n  and fin: \"finite S\" and q: \"q \\<in> S\" and degle: \"\\<And> p . p \\<in> S - {q} \\<Longrightarrow> degree (f p) < n\"\n  and cong: \"coeff (f q) n = c\"\n  shows \"degree (sum f S) = n \\<and> coeff (sum f S) n = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (sum f S) = n \\<and> coeff (sum f S) n = c", "proof (cases \"S = {q}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S = {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c\n 2. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "case True"], ["proof (state)\nthis:\n  S = {q}\n\ngoal (2 subgoals):\n 1. S = {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c\n 2. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "thus ?thesis"], ["proof (prove)\nusing this:\n  S = {q}\n\ngoal (1 subgoal):\n 1. degree (sum f S) = n \\<and> coeff (sum f S) n = c", "using deg cong"], ["proof (prove)\nusing this:\n  S = {q}\n  degree (f q) = n\n  coeff (f q) n = c\n\ngoal (1 subgoal):\n 1. degree (sum f S) = n \\<and> coeff (sum f S) n = c", "by simp"], ["proof (state)\nthis:\n  degree (sum f S) = n \\<and> coeff (sum f S) n = c\n\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "case False"], ["proof (state)\nthis:\n  S \\<noteq> {q}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "with q"], ["proof (chain)\npicking this:\n  q \\<in> S\n  S \\<noteq> {q}", "obtain p where \"p \\<in> S - {q}\""], ["proof (prove)\nusing this:\n  q \\<in> S\n  S \\<noteq> {q}\n\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<in> S - {q} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in> S - {q}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "from degle[OF this]"], ["proof (chain)\npicking this:\n  degree (f p) < n", "have n: \"n > 0\""], ["proof (prove)\nusing this:\n  degree (f p) < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "have \"degree (sum f S) = degree (f q + sum f (S - {q}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (sum f S) = degree (f q + sum f (S - {q}))", "unfolding sum.remove[OF fin q]"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f q + sum f (S - {q})) = degree (f q + sum f (S - {q}))", ".."], ["proof (state)\nthis:\n  degree (sum f S) = degree (f q + sum f (S - {q}))\n\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "also"], ["proof (state)\nthis:\n  degree (sum f S) = degree (f q + sum f (S - {q}))\n\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "have \"\\<dots> = degree (f q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f q + sum f (S - {q})) = degree (f q)", "proof (rule degree_add_eq_left)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (sum f (S - {q})) < degree (f q)", "have \"degree (sum f (S - {q})) \\<le> n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (sum f (S - {q})) \\<le> n - 1", "proof (rule degree_sum_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (S - {q})\n 2. \\<And>p. p \\<in> S - {q} \\<Longrightarrow> degree (f p) \\<le> n - 1", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (S - {q})\n 2. \\<And>p. p \\<in> S - {q} \\<Longrightarrow> degree (f p) \\<le> n - 1", "show \"p \\<in> S - {q} \\<Longrightarrow> degree (f p) \\<le> n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> S - {q} \\<Longrightarrow> degree (f p) \\<le> n - 1", "using degle[of p]"], ["proof (prove)\nusing this:\n  p \\<in> S - {q} \\<Longrightarrow> degree (f p) < n\n\ngoal (1 subgoal):\n 1. p \\<in> S - {q} \\<Longrightarrow> degree (f p) \\<le> n - 1", "by auto"], ["proof (state)\nthis:\n  p \\<in> S - {q} \\<Longrightarrow> degree (f p) \\<le> n - 1\n\ngoal (1 subgoal):\n 1. finite (S - {q})", "qed (insert fin, auto)"], ["proof (state)\nthis:\n  degree (sum f (S - {q})) \\<le> n - 1\n\ngoal (1 subgoal):\n 1. degree (sum f (S - {q})) < degree (f q)", "also"], ["proof (state)\nthis:\n  degree (sum f (S - {q})) \\<le> n - 1\n\ngoal (1 subgoal):\n 1. degree (sum f (S - {q})) < degree (f q)", "have \"\\<dots> < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 1 < n", "using n"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n - 1 < n", "by simp"], ["proof (state)\nthis:\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. degree (sum f (S - {q})) < degree (f q)", "finally"], ["proof (chain)\npicking this:\n  degree (sum f (S - {q})) < n", "show \"degree (sum f (S - {q})) < degree (f q)\""], ["proof (prove)\nusing this:\n  degree (sum f (S - {q})) < n\n\ngoal (1 subgoal):\n 1. degree (sum f (S - {q})) < degree (f q)", "unfolding deg"], ["proof (prove)\nusing this:\n  degree (sum f (S - {q})) < n\n\ngoal (1 subgoal):\n 1. degree (sum f (S - {q})) < n", "."], ["proof (state)\nthis:\n  degree (sum f (S - {q})) < degree (f q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (f q + sum f (S - {q})) = degree (f q)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {q} \\<Longrightarrow>\n    degree (sum f S) = n \\<and> coeff (sum f S) n = c", "finally"], ["proof (chain)\npicking this:\n  degree (sum f S) = degree (f q)", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (sum f S) = degree (f q)\n\ngoal (1 subgoal):\n 1. degree (sum f S) = n \\<and> coeff (sum f S) n = c", "unfolding deg[symmetric] cong[symmetric]"], ["proof (prove)\nusing this:\n  degree (sum f S) = degree (f q)\n\ngoal (1 subgoal):\n 1. degree (sum f S) = degree (f q) \\<and>\n    coeff (sum f S) (degree (f q)) = lead_coeff (f q)", "proof (rule conjI)"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (sum f S) (degree (f q)) = lead_coeff (f q)", "have id: \"(\\<Sum>x\\<in>S - {q}. coeff (f x) (degree (f q))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S - {q}. coeff (f x) (degree (f q))) = (0::'a)", "by (rule sum.neutral, rule ballI, rule coeff_eq_0[OF degle[folded deg]])"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S - {q}. coeff (f x) (degree (f q))) = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (sum f S) (degree (f q)) = lead_coeff (f q)", "show \"coeff (sum f S) (degree (f q)) = coeff (f q) (degree (f q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (sum f S) (degree (f q)) = lead_coeff (f q)", "unfolding coeff_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. coeff (f x) (degree (f q))) = lead_coeff (f q)", "by (subst sum.remove[OF _ q], unfold id, insert fin, auto)"], ["proof (state)\nthis:\n  coeff (sum f S) (degree (f q)) = lead_coeff (f q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (sum f S) = n \\<and> coeff (sum f S) n = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_sum_list_le: \"(\\<And> p . p \\<in> set ps \\<Longrightarrow> degree p \\<le> n)\n  \\<Longrightarrow> degree (sum_list ps) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set ps \\<Longrightarrow> degree p \\<le> n) \\<Longrightarrow>\n    degree (sum_list ps) \\<le> n", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>p.\n        p \\<in> set [] \\<Longrightarrow> degree p \\<le> n) \\<Longrightarrow>\n    degree (sum_list []) \\<le> n\n 2. \\<And>a ps.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set ps \\<Longrightarrow>\n                    degree p \\<le> n) \\<Longrightarrow>\n                degree (sum_list ps) \\<le> n;\n        \\<And>p.\n           p \\<in> set (a # ps) \\<Longrightarrow> degree p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> degree (sum_list (a # ps)) \\<le> n", "case (Cons p ps)"], ["proof (state)\nthis:\n  (\\<And>p.\n      p \\<in> set ps \\<Longrightarrow> degree p \\<le> n) \\<Longrightarrow>\n  degree (sum_list ps) \\<le> n\n  ?p \\<in> set (p # ps) \\<Longrightarrow> degree ?p \\<le> n\n\ngoal (2 subgoals):\n 1. (\\<And>p.\n        p \\<in> set [] \\<Longrightarrow> degree p \\<le> n) \\<Longrightarrow>\n    degree (sum_list []) \\<le> n\n 2. \\<And>a ps.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set ps \\<Longrightarrow>\n                    degree p \\<le> n) \\<Longrightarrow>\n                degree (sum_list ps) \\<le> n;\n        \\<And>p.\n           p \\<in> set (a # ps) \\<Longrightarrow> degree p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> degree (sum_list (a # ps)) \\<le> n", "hence \"degree (sum_list ps) \\<le> n\" \"degree p \\<le> n\""], ["proof (prove)\nusing this:\n  (\\<And>p.\n      p \\<in> set ps \\<Longrightarrow> degree p \\<le> n) \\<Longrightarrow>\n  degree (sum_list ps) \\<le> n\n  ?p \\<in> set (p # ps) \\<Longrightarrow> degree ?p \\<le> n\n\ngoal (1 subgoal):\n 1. degree (sum_list ps) \\<le> n &&& degree p \\<le> n", "by auto"], ["proof (state)\nthis:\n  degree (sum_list ps) \\<le> n\n  degree p \\<le> n\n\ngoal (2 subgoals):\n 1. (\\<And>p.\n        p \\<in> set [] \\<Longrightarrow> degree p \\<le> n) \\<Longrightarrow>\n    degree (sum_list []) \\<le> n\n 2. \\<And>a ps.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set ps \\<Longrightarrow>\n                    degree p \\<le> n) \\<Longrightarrow>\n                degree (sum_list ps) \\<le> n;\n        \\<And>p.\n           p \\<in> set (a # ps) \\<Longrightarrow> degree p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> degree (sum_list (a # ps)) \\<le> n", "thus ?case"], ["proof (prove)\nusing this:\n  degree (sum_list ps) \\<le> n\n  degree p \\<le> n\n\ngoal (1 subgoal):\n 1. degree (sum_list (p # ps)) \\<le> n", "unfolding sum_list.Cons"], ["proof (prove)\nusing this:\n  degree (sum_list ps) \\<le> n\n  degree p \\<le> n\n\ngoal (1 subgoal):\n 1. degree (p + sum_list ps) \\<le> n", "by (metis degree_add_le)"], ["proof (state)\nthis:\n  degree (sum_list (p # ps)) \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set [] \\<Longrightarrow> degree p \\<le> n) \\<Longrightarrow>\n    degree (sum_list []) \\<le> n", "qed simp"], ["", "lemma degree_prod_list_le: \"degree (prod_list ps) \\<le> sum_list (map degree ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list ps) \\<le> sum_list (map degree ps)", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree (prod_list []) \\<le> sum_list (map degree [])\n 2. \\<And>a ps.\n       degree (prod_list ps)\n       \\<le> sum_list (map degree ps) \\<Longrightarrow>\n       degree (prod_list (a # ps)) \\<le> sum_list (map degree (a # ps))", "case (Cons p ps)"], ["proof (state)\nthis:\n  degree (prod_list ps) \\<le> sum_list (map degree ps)\n\ngoal (2 subgoals):\n 1. degree (prod_list []) \\<le> sum_list (map degree [])\n 2. \\<And>a ps.\n       degree (prod_list ps)\n       \\<le> sum_list (map degree ps) \\<Longrightarrow>\n       degree (prod_list (a # ps)) \\<le> sum_list (map degree (a # ps))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list (p # ps)) \\<le> sum_list (map degree (p # ps))", "unfolding prod_list.Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p * prod_list ps) \\<le> sum_list (map degree (p # ps))", "by (rule order.trans[OF degree_mult_le], insert Cons, auto)"], ["proof (state)\nthis:\n  degree (prod_list (p # ps)) \\<le> sum_list (map degree (p # ps))\n\ngoal (1 subgoal):\n 1. degree (prod_list []) \\<le> sum_list (map degree [])", "qed simp"], ["", "lemma smult_sum: \"smult (\\<Sum>i \\<in> S. f i) p = (\\<Sum>i \\<in> S. smult (f i) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (sum f S) p = (\\<Sum>i\\<in>S. smult (f i) p)", "by (induct S rule: infinite_finite_induct, auto simp: smult_add_left)"], ["", "lemma range_coeff: \"range (coeff p) = insert 0 (set (coeffs p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (coeff p) = insert (0::'a) (set (coeffs p))", "by (metis nth_default_coeffs_eq range_nth_default)"], ["", "lemma smult_power: \"(smult a p) ^ n = smult (a ^ n) (p ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a p ^ n = smult (a ^ n) (p ^ n)", "by (induct n, auto simp: field_simps)"], ["", "lemma poly_sum_list: \"poly (sum_list ps) x = sum_list (map (\\<lambda> p. poly p x) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (sum_list ps) x = (\\<Sum>p\\<leftarrow>ps. poly p x)", "by (induct ps, auto)"], ["", "lemma poly_prod_list: \"poly (prod_list ps) x = prod_list (map (\\<lambda> p. poly p x) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list ps) x = (\\<Prod>p\\<leftarrow>ps. poly p x)", "by (induct ps, auto)"], ["", "lemma sum_list_neutral: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> x = 0) \\<Longrightarrow> sum_list xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> x = (0::'a)) \\<Longrightarrow>\n    sum_list xs = (0::'a)", "by (induct xs, auto)"], ["", "lemma prod_list_neutral: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> x = 1) \\<Longrightarrow> prod_list xs = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> x = (1::'a)) \\<Longrightarrow>\n    prod_list xs = (1::'a)", "by (induct xs, auto)"], ["", "lemma (in comm_monoid_mult) prod_list_map_remove1:\n  \"x \\<in> set xs \\<Longrightarrow> prod_list (map f xs) = f x * prod_list (map f (remove1 x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow>\n    prod_list (map f xs) = f x * prod_list (map f (remove1 x xs))", "by (induct xs) (auto simp add: ac_simps)"], ["", "lemma poly_as_sum:\n  fixes p :: \"'a::comm_semiring_1 poly\"\n  shows \"poly p x = (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)", "unfolding poly_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. coeff p i * x ^ i) =\n    (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)", "by (simp add: ac_simps)"], ["", "lemma poly_prod_0: \"finite ps \\<Longrightarrow> poly (prod f ps) x = (0 :: 'a :: field) \\<longleftrightarrow> (\\<exists> p \\<in> ps. poly (f p) x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ps \\<Longrightarrow>\n    (poly (prod f ps) x = (0::'a)) =\n    (\\<exists>p\\<in>ps. poly (f p) x = (0::'a))", "by (induct ps rule: finite_induct, auto)"], ["", "lemma coeff_monom_mult:\n  shows \"coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i-d) else 0)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "proof (cases \"d \\<le> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))\n 2. \\<not> d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> d \\<le> i\n\ngoal (2 subgoals):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))\n 2. \\<not> d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> d \\<le> i\n\ngoal (1 subgoal):\n 1. coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "unfolding coeff_mult"], ["proof (prove)\nusing this:\n  \\<not> d \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i. coeff (monom a d) ia * coeff p (i - ia)) =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "by simp"], ["proof (state)\nthis:\n  coeff (monom a d * p) i =\n  (if d \\<le> i then a * coeff p (i - d) else (0::'a))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "case True"], ["proof (state)\nthis:\n  d \\<le> i\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "let ?f = \"\\<lambda>j. coeff (monom a d) j * coeff p (i - j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "have \"\\<And>j. j \\<in> {0..i} - {d} \\<Longrightarrow> ?f j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> {0..i} - {d} \\<Longrightarrow>\n       coeff (monom a d) j * coeff p (i - j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?j \\<in> {0..i} - {d} \\<Longrightarrow>\n  coeff (monom a d) ?j * coeff p (i - ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "hence \"0 = (\\<Sum>j \\<in> {0..i} - {d}. ?f j)\""], ["proof (prove)\nusing this:\n  ?j \\<in> {0..i} - {d} \\<Longrightarrow>\n  coeff (monom a d) ?j * coeff p (i - ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>j\\<in>{0..i} - {d}. coeff (monom a d) j * coeff p (i - j))", "by auto"], ["proof (state)\nthis:\n  (0::'a) =\n  (\\<Sum>j\\<in>{0..i} - {d}. coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "also"], ["proof (state)\nthis:\n  (0::'a) =\n  (\\<Sum>j\\<in>{0..i} - {d}. coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "have \"... + ?f d = (\\<Sum>j \\<in> insert d ({0..i} - {d}). ?f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{0..i} - {d}. coeff (monom a d) j * coeff p (i - j)) +\n    coeff (monom a d) d * coeff p (i - d) =\n    (\\<Sum>j\\<in>insert d ({0..i} - {d}).\n       coeff (monom a d) j * coeff p (i - j))", "by(subst sum.insert, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..i} - {d}. coeff (monom a d) j * coeff p (i - j)) +\n  coeff (monom a d) d * coeff p (i - d) =\n  (\\<Sum>j\\<in>insert d ({0..i} - {d}).\n     coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..i} - {d}. coeff (monom a d) j * coeff p (i - j)) +\n  coeff (monom a d) d * coeff p (i - d) =\n  (\\<Sum>j\\<in>insert d ({0..i} - {d}).\n     coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "have \"... = (\\<Sum>j \\<in> {0..i}. ?f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>insert d ({0..i} - {d}).\n       coeff (monom a d) j * coeff p (i - j)) =\n    (\\<Sum>j = 0..i. coeff (monom a d) j * coeff p (i - j))", "by (subst insert_Diff, insert True, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>insert d ({0..i} - {d}).\n     coeff (monom a d) j * coeff p (i - j)) =\n  (\\<Sum>j = 0..i. coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>insert d ({0..i} - {d}).\n     coeff (monom a d) j * coeff p (i - j)) =\n  (\\<Sum>j = 0..i. coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "have \"... = (\\<Sum>j\\<le>i. ?f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..i. coeff (monom a d) j * coeff p (i - j)) =\n    (\\<Sum>j\\<le>i. coeff (monom a d) j * coeff p (i - j))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..i. coeff (monom a d) j * coeff p (i - j)) =\n  (\\<Sum>j\\<le>i. coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..i. coeff (monom a d) j * coeff p (i - j)) =\n  (\\<Sum>j\\<le>i. coeff (monom a d) j * coeff p (i - j))\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "have \"... = ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>i. coeff (monom a d) j * coeff p (i - j)) =\n    coeff (monom a d * p) i", "unfolding coeff_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>i. coeff (monom a d) j * coeff p (i - j)) =\n    (\\<Sum>ia\\<le>i. coeff (monom a d) ia * coeff p (i - ia))", ".."], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>i. coeff (monom a d) j * coeff p (i - j)) =\n  coeff (monom a d * p) i\n\ngoal (1 subgoal):\n 1. d \\<le> i \\<Longrightarrow>\n    coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "finally"], ["proof (chain)\npicking this:\n  (0::'a) + coeff (monom a d) d * coeff p (i - d) = coeff (monom a d * p) i", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) + coeff (monom a d) d * coeff p (i - d) = coeff (monom a d * p) i\n\ngoal (1 subgoal):\n 1. coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "using True"], ["proof (prove)\nusing this:\n  (0::'a) + coeff (monom a d) d * coeff p (i - d) = coeff (monom a d * p) i\n  d \\<le> i\n\ngoal (1 subgoal):\n 1. coeff (monom a d * p) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "by auto"], ["proof (state)\nthis:\n  coeff (monom a d * p) i =\n  (if d \\<le> i then a * coeff p (i - d) else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_eqI2:\n  assumes \"degree p = degree q\" and \"\\<And>i. i \\<le> degree p \\<Longrightarrow> coeff p i = coeff q i\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "apply(rule poly_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff q n", "by (metis assms le_degree)"], ["", "text \\<open>A nice extension rule for polynomials.\\<close>"], ["", "lemma poly_ext[intro]:\n  fixes p q :: \"'a :: {ring_char_0, idom} poly\"\n  assumes \"\\<And>x. poly p x = poly q x\" shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "unfolding poly_eq_poly_eq_iff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p = poly q", "using assms"], ["proof (prove)\nusing this:\n  poly p ?x = poly q ?x\n\ngoal (1 subgoal):\n 1. poly p = poly q", "by (rule ext)"], ["", "text \\<open>Copied from non-negative variants.\\<close>"], ["", "lemma coeff_linear_power_neg[simp]:\n  fixes a :: \"'a::comm_ring_1\"\n  shows \"coeff ([:a, -1:] ^ n) n = (-1)^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff ([:a, - (1::'a):] ^ n) n = (- (1::'a)) ^ n", "apply (induct n, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff ([:a, - (1::'a):] ^ n) n = (- (1::'a)) ^ n \\<Longrightarrow>\n       a * coeff ([:a, - (1::'a):] ^ n) (Suc n) = (0::'a)", "apply (subst coeff_eq_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       coeff ([:a, - (1::'a):] ^ n) n = (- (1::'a)) ^ n \\<Longrightarrow>\n       degree ([:a, - (1::'a):] ^ n) < Suc n\n 2. \\<And>n.\n       coeff ([:a, - (1::'a):] ^ n) n = (- (1::'a)) ^ n \\<Longrightarrow>\n       a * (0::'a) = (0::'a)", "apply (auto intro: le_less_trans degree_power_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_linear_power_neg[simp]:\n  fixes a :: \"'a::{idom,comm_ring_1}\"\n  shows \"degree ([:a, -1:] ^ n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:a, - (1::'a):] ^ n) = n", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree ([:a, - (1::'a):] ^ n) \\<le> n\n 2. n \\<le> degree ([:a, - (1::'a):] ^ n)", "apply (rule ord_le_eq_trans [OF degree_power_le], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> degree ([:a, - (1::'a):] ^ n)", "apply (rule le_degree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff ([:a, - (1::'a):] ^ n) n \\<noteq> (0::'a)", "unfolding coeff_linear_power_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ n \\<noteq> (0::'a)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Polynomial Composition\\<close>"], ["", "lemmas [simp] = pcompose_pCons"], ["", "lemma pcompose_eq_0: fixes q :: \"'a :: idom poly\"\n  assumes q: \"degree q \\<noteq> 0\"\n  shows \"p \\<circ>\\<^sub>p q = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<circ>\\<^sub>p q = 0) = (p = 0)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0 \\<circ>\\<^sub>p q = 0) = (0 = 0)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        (p \\<circ>\\<^sub>p q = 0) = (p = 0)\\<rbrakk>\n       \\<Longrightarrow> (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (0 \\<circ>\\<^sub>p q = 0) = (0 = 0)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        (p \\<circ>\\<^sub>p q = 0) = (p = 0)\\<rbrakk>\n       \\<Longrightarrow> (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<circ>\\<^sub>p q = 0) = (0 = 0)", "by auto"], ["proof (state)\nthis:\n  (0 \\<circ>\\<^sub>p q = 0) = (0 = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        (p \\<circ>\\<^sub>p q = 0) = (p = 0)\\<rbrakk>\n       \\<Longrightarrow> (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        (p \\<circ>\\<^sub>p q = 0) = (p = 0)\\<rbrakk>\n       \\<Longrightarrow> (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  (p \\<circ>\\<^sub>p q = 0) = (p = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        (p \\<circ>\\<^sub>p q = 0) = (p = 0)\\<rbrakk>\n       \\<Longrightarrow> (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "have id: \"(pCons a p) \\<circ>\\<^sub>p q = [:a:] + q * (p \\<circ>\\<^sub>p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons a p \\<circ>\\<^sub>p q = [:a:] + q * p \\<circ>\\<^sub>p q", "by simp"], ["proof (state)\nthis:\n  pCons a p \\<circ>\\<^sub>p q = [:a:] + q * p \\<circ>\\<^sub>p q\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        (p \\<circ>\\<^sub>p q = 0) = (p = 0)\\<rbrakk>\n       \\<Longrightarrow> (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:a:] + q * p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:a:] + q * 0 \\<circ>\\<^sub>p q = 0) = ([:a:] = 0)", "by simp"], ["proof (state)\nthis:\n  (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "with pCons(2)"], ["proof (chain)\npicking this:\n  (p \\<circ>\\<^sub>p q = 0) = (p = 0)\n  p \\<noteq> 0", "have \"p \\<circ>\\<^sub>p q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (p \\<circ>\\<^sub>p q = 0) = (p = 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "from degree_mult_eq[OF _ this, of q] q"], ["proof (chain)\npicking this:\n  q \\<noteq> 0 \\<Longrightarrow>\n  degree (q * p \\<circ>\\<^sub>p q) = degree q + degree (p \\<circ>\\<^sub>p q)\n  degree q \\<noteq> 0", "have \"degree (q * (p \\<circ>\\<^sub>p q)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0 \\<Longrightarrow>\n  degree (q * p \\<circ>\\<^sub>p q) = degree q + degree (p \\<circ>\\<^sub>p q)\n  degree q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (q * p \\<circ>\\<^sub>p q) \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  degree (q * p \\<circ>\\<^sub>p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "hence deg: \"degree ([:a:] + q * (p \\<circ>\\<^sub>p q)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (q * p \\<circ>\\<^sub>p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree ([:a:] + q * p \\<circ>\\<^sub>p q) \\<noteq> 0", "by (subst degree_add_eq_right, auto)"], ["proof (state)\nthis:\n  degree ([:a:] + q * p \\<circ>\\<^sub>p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:a:] + q * p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "using False deg"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree ([:a:] + q * p \\<circ>\\<^sub>p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ([:a:] + q * p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)", "by auto"], ["proof (state)\nthis:\n  (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (pCons a p \\<circ>\\<^sub>p q = 0) = (pCons a p = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare degree_pcompose[simp]"], ["", "subsection \\<open>Monic Polynomials\\<close>"], ["", "abbreviation monic where \"monic p \\<equiv> coeff p (degree p) = 1\""], ["", "lemma unit_factor_field [simp]: \n  \"unit_factor (x :: 'a :: {field,normalization_semidom}) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor x = x", "by (cases \"is_unit x\") (auto simp: is_unit_unit_factor dvd_field_iff)"], ["", "lemma poly_gcd_monic: \n  fixes p :: \"'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes \"p \\<noteq> 0 \\<or> q \\<noteq> 0\"\n  shows   \"monic (gcd p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (gcd p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monic (gcd p q)", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<or> q \\<noteq> 0", "have \"1 = unit_factor (gcd p q)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<or> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 = unit_factor (gcd p q)", "by (auto simp: unit_factor_gcd)"], ["proof (state)\nthis:\n  1 = unit_factor (gcd p q)\n\ngoal (1 subgoal):\n 1. monic (gcd p q)", "also"], ["proof (state)\nthis:\n  1 = unit_factor (gcd p q)\n\ngoal (1 subgoal):\n 1. monic (gcd p q)", "have \"\\<dots> = [:lead_coeff (gcd p q):]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor (gcd p q) = [:lead_coeff (gcd p q):]", "unfolding unit_factor_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:unit_factor (lead_coeff (gcd p q)):] = [:lead_coeff (gcd p q):]", "by (simp add: monom_0)"], ["proof (state)\nthis:\n  unit_factor (gcd p q) = [:lead_coeff (gcd p q):]\n\ngoal (1 subgoal):\n 1. monic (gcd p q)", "finally"], ["proof (chain)\npicking this:\n  1 = [:lead_coeff (gcd p q):]", "show ?thesis"], ["proof (prove)\nusing this:\n  1 = [:lead_coeff (gcd p q):]\n\ngoal (1 subgoal):\n 1. monic (gcd p q)", "by (metis coeff_pCons_0 degree_1 lead_coeff_1)"], ["proof (state)\nthis:\n  monic (gcd p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_monic: \"monic p \\<Longrightarrow> normalize p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic p \\<Longrightarrow> normalize p = p", "by (simp add: normalize_poly_eq_map_poly is_unit_unit_factor)"], ["", "lemma lcoeff_monic_mult: assumes monic: \"monic (p :: 'a :: comm_semiring_1 poly)\"\n  shows \"coeff (p * q) (degree p + degree q) = coeff q (degree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "let ?pqi = \"\\<lambda> i. coeff p i * coeff q (degree p + degree q - i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "have \"coeff (p * q) (degree p + degree q) = \n    (\\<Sum>i\\<le>degree p + degree q. ?pqi i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) =\n    (\\<Sum>i\\<le>degree p + degree q.\n        coeff p i * coeff q (degree p + degree q - i))", "unfolding coeff_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        coeff p i * coeff q (degree p + degree q - i)) =\n    (\\<Sum>i\\<le>degree p + degree q.\n        coeff p i * coeff q (degree p + degree q - i))", "by simp"], ["proof (state)\nthis:\n  coeff (p * q) (degree p + degree q) =\n  (\\<Sum>i\\<le>degree p + degree q.\n      coeff p i * coeff q (degree p + degree q - i))\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "also"], ["proof (state)\nthis:\n  coeff (p * q) (degree p + degree q) =\n  (\\<Sum>i\\<le>degree p + degree q.\n      coeff p i * coeff q (degree p + degree q - i))\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "have \"\\<dots> = ?pqi (degree p) + (sum ?pqi ({.. degree p + degree q} - {degree p}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        coeff p i * coeff q (degree p + degree q - i)) =\n    lead_coeff p * coeff q (degree p + degree q - degree p) +\n    (\\<Sum>i\\<in>{..degree p + degree q} - {degree p}.\n       coeff p i * coeff q (degree p + degree q - i))", "by (subst sum.remove[of _ \"degree p\"], auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p + degree q.\n      coeff p i * coeff q (degree p + degree q - i)) =\n  lead_coeff p * coeff q (degree p + degree q - degree p) +\n  (\\<Sum>i\\<in>{..degree p + degree q} - {degree p}.\n     coeff p i * coeff q (degree p + degree q - i))\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p + degree q.\n      coeff p i * coeff q (degree p + degree q - i)) =\n  lead_coeff p * coeff q (degree p + degree q - degree p) +\n  (\\<Sum>i\\<in>{..degree p + degree q} - {degree p}.\n     coeff p i * coeff q (degree p + degree q - i))\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "have \"?pqi (degree p) = coeff q (degree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff p * coeff q (degree p + degree q - degree p) = lead_coeff q", "unfolding monic"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) * coeff q (degree p + degree q - degree p) = lead_coeff q", "by simp"], ["proof (state)\nthis:\n  lead_coeff p * coeff q (degree p + degree q - degree p) = lead_coeff q\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "also"], ["proof (state)\nthis:\n  lead_coeff p * coeff q (degree p + degree q - degree p) = lead_coeff q\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "have \"(sum ?pqi ({.. degree p + degree q} - {degree p})) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..degree p + degree q} - {degree p}.\n       coeff p i * coeff q (degree p + degree q - i)) =\n    (0::'a)", "proof (rule sum.neutral, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree p + degree q} - {degree p} \\<Longrightarrow>\n       coeff p x * coeff q (degree p + degree q - x) = (0::'a)", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree p + degree q} - {degree p} \\<Longrightarrow>\n       coeff p x * coeff q (degree p + degree q - x) = (0::'a)", "assume d: \"d \\<in> {.. degree p + degree q} - {degree p}\""], ["proof (state)\nthis:\n  d \\<in> {..degree p + degree q} - {degree p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree p + degree q} - {degree p} \\<Longrightarrow>\n       coeff p x * coeff q (degree p + degree q - x) = (0::'a)", "show \"?pqi d = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "proof (cases \"d < degree p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)\n 2. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "case True"], ["proof (state)\nthis:\n  d < degree p\n\ngoal (2 subgoals):\n 1. d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)\n 2. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "hence \"degree p + degree q - d > degree q\""], ["proof (prove)\nusing this:\n  d < degree p\n\ngoal (1 subgoal):\n 1. degree q < degree p + degree q - d", "by auto"], ["proof (state)\nthis:\n  degree q < degree p + degree q - d\n\ngoal (2 subgoals):\n 1. d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)\n 2. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "hence \"coeff q (degree p + degree q - d) = 0\""], ["proof (prove)\nusing this:\n  degree q < degree p + degree q - d\n\ngoal (1 subgoal):\n 1. coeff q (degree p + degree q - d) = (0::'a)", "by (rule coeff_eq_0)"], ["proof (state)\nthis:\n  coeff q (degree p + degree q - d) = (0::'a)\n\ngoal (2 subgoals):\n 1. d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)\n 2. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff q (degree p + degree q - d) = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  coeff p d * coeff q (degree p + degree q - d) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> d < degree p\n\ngoal (1 subgoal):\n 1. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "with d"], ["proof (chain)\npicking this:\n  d \\<in> {..degree p + degree q} - {degree p}\n  \\<not> d < degree p", "have \"d > degree p\""], ["proof (prove)\nusing this:\n  d \\<in> {..degree p + degree q} - {degree p}\n  \\<not> d < degree p\n\ngoal (1 subgoal):\n 1. degree p < d", "by auto"], ["proof (state)\nthis:\n  degree p < d\n\ngoal (1 subgoal):\n 1. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "hence \"coeff p d = 0\""], ["proof (prove)\nusing this:\n  degree p < d\n\ngoal (1 subgoal):\n 1. coeff p d = (0::'a)", "by (rule coeff_eq_0)"], ["proof (state)\nthis:\n  coeff p d = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> d < degree p \\<Longrightarrow>\n    coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff p d = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff p d * coeff q (degree p + degree q - d) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  coeff p d * coeff q (degree p + degree q - d) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff p d * coeff q (degree p + degree q - d) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..degree p + degree q} - {degree p}.\n     coeff p i * coeff q (degree p + degree q - i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "finally"], ["proof (chain)\npicking this:\n  coeff (p * q) (degree p + degree q) = lead_coeff q + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (p * q) (degree p + degree q) = lead_coeff q + (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) = lead_coeff q", "by simp"], ["proof (state)\nthis:\n  coeff (p * q) (degree p + degree q) = lead_coeff q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_monic_mult: assumes monic: \"monic (p :: 'a :: comm_semiring_1 poly)\"\n  and q: \"q \\<noteq> 0\"\n  shows \"degree (p * q) = degree p + degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "have \"degree p + degree q \\<ge> degree (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p * q) \\<le> degree p + degree q", "by (rule degree_mult_le)"], ["proof (state)\nthis:\n  degree (p * q) \\<le> degree p + degree q\n\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "also"], ["proof (state)\nthis:\n  degree (p * q) \\<le> degree p + degree q\n\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "have \"degree p + degree q \\<le> degree (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p + degree q \\<le> degree (p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p + degree q \\<le> degree (p * q)", "from q"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have cq: \"coeff q (degree q) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff q \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  lead_coeff q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree p + degree q \\<le> degree (p * q)", "hence \"coeff (p * q) (degree p + degree q) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lead_coeff q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (p * q) (degree p + degree q) \\<noteq> (0::'a)", "unfolding lcoeff_monic_mult[OF monic]"], ["proof (prove)\nusing this:\n  lead_coeff q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff q \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  coeff (p * q) (degree p + degree q) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree p + degree q \\<le> degree (p * q)", "thus \"degree (p * q) \\<ge> degree p + degree q\""], ["proof (prove)\nusing this:\n  coeff (p * q) (degree p + degree q) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree p + degree q \\<le> degree (p * q)", "by (rule le_degree)"], ["proof (state)\nthis:\n  degree p + degree q \\<le> degree (p * q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree p + degree q \\<le> degree (p * q)\n\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "finally"], ["proof (chain)\npicking this:\n  degree (p * q) = degree p + degree q", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (p * q) = degree p + degree q\n\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "."], ["proof (state)\nthis:\n  degree (p * q) = degree p + degree q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_prod_sum_monic: assumes\n  S: \"finite S\"\n  and nzd: \"0 \\<notin> (degree o f) ` S\"\n  and monic: \"(\\<And> a . a \\<in> S \\<Longrightarrow> monic (f a))\"\n  shows \"degree (prod f S) = (sum (degree o f) S) \\<and> coeff (prod f S) (sum (degree o f) S) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)", "from S nzd monic"], ["proof (chain)\npicking this:\n  finite S\n  0 \\<notin> (degree \\<circ> f) ` S\n  ?a \\<in> S \\<Longrightarrow> monic (f ?a)", "have \"degree (prod f S) = sum (degree \\<circ> f) S \n  \\<and> (S \\<noteq> {} \\<longrightarrow> degree (prod f S) \\<noteq> 0 \\<and> prod f S \\<noteq> 0) \\<and> coeff (prod f S) (sum (degree o f) S) = 1\""], ["proof (prove)\nusing this:\n  finite S\n  0 \\<notin> (degree \\<circ> f) ` S\n  ?a \\<in> S \\<Longrightarrow> monic (f ?a)\n\ngoal (1 subgoal):\n 1. degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n    (S \\<noteq> {} \\<longrightarrow>\n     degree (prod f S) \\<noteq> 0 \\<and> prod f S \\<noteq> 0) \\<and>\n    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)", "proof (induct S rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` {};\n     \\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)\\<rbrakk>\n    \\<Longrightarrow> degree (prod f {}) = sum (degree \\<circ> f) {} \\<and>\n                      ({} \\<noteq> {} \\<longrightarrow>\n                       degree (prod f {}) \\<noteq> 0 \\<and>\n                       prod f {} \\<noteq> 0) \\<and>\n                      coeff (prod f {}) (sum (degree \\<circ> f) {}) =\n                      (1::'b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` F;\n         \\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)\\<rbrakk>\n        \\<Longrightarrow> degree (prod f F) =\n                          sum (degree \\<circ> f) F \\<and>\n                          (F \\<noteq> {} \\<longrightarrow>\n                           degree (prod f F) \\<noteq> 0 \\<and>\n                           prod f F \\<noteq> 0) \\<and>\n                          coeff (prod f F) (sum (degree \\<circ> f) F) =\n                          (1::'b);\n        0 \\<notin> (degree \\<circ> f) ` insert x F;\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         sum (degree \\<circ> f) (insert x F) \\<and>\n                         (insert x F \\<noteq> {} \\<longrightarrow>\n                          degree (prod f (insert x F)) \\<noteq> 0 \\<and>\n                          prod f (insert x F) \\<noteq> 0) \\<and>\n                         coeff (prod f (insert x F))\n                          (sum (degree \\<circ> f) (insert x F)) =\n                         (1::'b)", "case (insert a S)"], ["proof (state)\nthis:\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` {};\n     \\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)\\<rbrakk>\n    \\<Longrightarrow> degree (prod f {}) = sum (degree \\<circ> f) {} \\<and>\n                      ({} \\<noteq> {} \\<longrightarrow>\n                       degree (prod f {}) \\<noteq> 0 \\<and>\n                       prod f {} \\<noteq> 0) \\<and>\n                      coeff (prod f {}) (sum (degree \\<circ> f) {}) =\n                      (1::'b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` F;\n         \\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)\\<rbrakk>\n        \\<Longrightarrow> degree (prod f F) =\n                          sum (degree \\<circ> f) F \\<and>\n                          (F \\<noteq> {} \\<longrightarrow>\n                           degree (prod f F) \\<noteq> 0 \\<and>\n                           prod f F \\<noteq> 0) \\<and>\n                          coeff (prod f F) (sum (degree \\<circ> f) F) =\n                          (1::'b);\n        0 \\<notin> (degree \\<circ> f) ` insert x F;\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         sum (degree \\<circ> f) (insert x F) \\<and>\n                         (insert x F \\<noteq> {} \\<longrightarrow>\n                          degree (prod f (insert x F)) \\<noteq> 0 \\<and>\n                          prod f (insert x F) \\<noteq> 0) \\<and>\n                         coeff (prod f (insert x F))\n                          (sum (degree \\<circ> f) (insert x F)) =\n                         (1::'b)", "have IH1: \"degree (prod f S) = sum (degree o f) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f S) = sum (degree \\<circ> f) S", "using insert"], ["proof (prove)\nusing this:\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)\n\ngoal (1 subgoal):\n 1. degree (prod f S) = sum (degree \\<circ> f) S", "by auto"], ["proof (state)\nthis:\n  degree (prod f S) = sum (degree \\<circ> f) S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` {};\n     \\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)\\<rbrakk>\n    \\<Longrightarrow> degree (prod f {}) = sum (degree \\<circ> f) {} \\<and>\n                      ({} \\<noteq> {} \\<longrightarrow>\n                       degree (prod f {}) \\<noteq> 0 \\<and>\n                       prod f {} \\<noteq> 0) \\<and>\n                      coeff (prod f {}) (sum (degree \\<circ> f) {}) =\n                      (1::'b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` F;\n         \\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)\\<rbrakk>\n        \\<Longrightarrow> degree (prod f F) =\n                          sum (degree \\<circ> f) F \\<and>\n                          (F \\<noteq> {} \\<longrightarrow>\n                           degree (prod f F) \\<noteq> 0 \\<and>\n                           prod f F \\<noteq> 0) \\<and>\n                          coeff (prod f F) (sum (degree \\<circ> f) F) =\n                          (1::'b);\n        0 \\<notin> (degree \\<circ> f) ` insert x F;\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         sum (degree \\<circ> f) (insert x F) \\<and>\n                         (insert x F \\<noteq> {} \\<longrightarrow>\n                          degree (prod f (insert x F)) \\<noteq> 0 \\<and>\n                          prod f (insert x F) \\<noteq> 0) \\<and>\n                         coeff (prod f (insert x F))\n                          (sum (degree \\<circ> f) (insert x F)) =\n                         (1::'b)", "have IH2: \"coeff (prod f S) (degree (prod f S)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (prod f S)", "using insert"], ["proof (prove)\nusing this:\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)\n\ngoal (1 subgoal):\n 1. monic (prod f S)", "by auto"], ["proof (state)\nthis:\n  monic (prod f S)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` {};\n     \\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)\\<rbrakk>\n    \\<Longrightarrow> degree (prod f {}) = sum (degree \\<circ> f) {} \\<and>\n                      ({} \\<noteq> {} \\<longrightarrow>\n                       degree (prod f {}) \\<noteq> 0 \\<and>\n                       prod f {} \\<noteq> 0) \\<and>\n                      coeff (prod f {}) (sum (degree \\<circ> f) {}) =\n                      (1::'b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` F;\n         \\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)\\<rbrakk>\n        \\<Longrightarrow> degree (prod f F) =\n                          sum (degree \\<circ> f) F \\<and>\n                          (F \\<noteq> {} \\<longrightarrow>\n                           degree (prod f F) \\<noteq> 0 \\<and>\n                           prod f F \\<noteq> 0) \\<and>\n                          coeff (prod f F) (sum (degree \\<circ> f) F) =\n                          (1::'b);\n        0 \\<notin> (degree \\<circ> f) ` insert x F;\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         sum (degree \\<circ> f) (insert x F) \\<and>\n                         (insert x F \\<noteq> {} \\<longrightarrow>\n                          degree (prod f (insert x F)) \\<noteq> 0 \\<and>\n                          prod f (insert x F) \\<noteq> 0) \\<and>\n                         coeff (prod f (insert x F))\n                          (sum (degree \\<circ> f) (insert x F)) =\n                         (1::'b)", "have id: \"degree (prod f (insert a S)) = sum (degree \\<circ> f) (insert a S)\n      \\<and> coeff (prod f (insert a S)) (sum (degree o f) (insert a S)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "proof (cases \"S = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)\n 2. S \\<noteq> {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "case False"], ["proof (state)\nthis:\n  S \\<noteq> {}\n\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)\n 2. S \\<noteq> {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "with insert"], ["proof (chain)\npicking this:\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)\n  S \\<noteq> {}", "have nz: \"prod f S \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. prod f S \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  prod f S \\<noteq> 0\n\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)\n 2. S \\<noteq> {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "from insert"], ["proof (chain)\npicking this:\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)", "have monic: \"coeff (f a) (degree (f a)) = 1\""], ["proof (prove)\nusing this:\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)\n\ngoal (1 subgoal):\n 1. monic (f a)", "by auto"], ["proof (state)\nthis:\n  monic (f a)\n\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)\n 2. S \\<noteq> {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "have id: \"(degree \\<circ> f) a = degree (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degree \\<circ> f) a = degree (f a)", "by simp"], ["proof (state)\nthis:\n  (degree \\<circ> f) a = degree (f a)\n\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)\n 2. S \\<noteq> {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "unfolding prod.insert[OF insert(1-2)] sum.insert[OF insert(1-2)] id"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f a * prod f S) = degree (f a) + sum (degree \\<circ> f) S \\<and>\n    coeff (f a * prod f S) (degree (f a) + sum (degree \\<circ> f) S) =\n    (1::'b)", "unfolding degree_monic_mult[OF monic nz]"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f a) + degree (prod f S) =\n    degree (f a) + sum (degree \\<circ> f) S \\<and>\n    coeff (f a * prod f S) (degree (f a) + sum (degree \\<circ> f) S) =\n    (1::'b)", "unfolding IH1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f a) + degree (prod f S) =\n    degree (f a) + degree (prod f S) \\<and>\n    coeff (f a * prod f S) (degree (f a) + degree (prod f S)) = (1::'b)", "unfolding lcoeff_monic_mult[OF monic] IH2"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f a) + degree (prod f S) =\n    degree (f a) + degree (prod f S) \\<and>\n    (1::'b) = (1::'b)", "by simp"], ["proof (state)\nthis:\n  degree (prod f (insert a S)) = sum (degree \\<circ> f) (insert a S) \\<and>\n  coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. S = {} \\<Longrightarrow>\n    degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "qed (insert insert, auto)"], ["proof (state)\nthis:\n  degree (prod f (insert a S)) = sum (degree \\<circ> f) (insert a S) \\<and>\n  coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n  (1::'b)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` {};\n     \\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)\\<rbrakk>\n    \\<Longrightarrow> degree (prod f {}) = sum (degree \\<circ> f) {} \\<and>\n                      ({} \\<noteq> {} \\<longrightarrow>\n                       degree (prod f {}) \\<noteq> 0 \\<and>\n                       prod f {} \\<noteq> 0) \\<and>\n                      coeff (prod f {}) (sum (degree \\<circ> f) {}) =\n                      (1::'b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` F;\n         \\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)\\<rbrakk>\n        \\<Longrightarrow> degree (prod f F) =\n                          sum (degree \\<circ> f) F \\<and>\n                          (F \\<noteq> {} \\<longrightarrow>\n                           degree (prod f F) \\<noteq> 0 \\<and>\n                           prod f F \\<noteq> 0) \\<and>\n                          coeff (prod f F) (sum (degree \\<circ> f) F) =\n                          (1::'b);\n        0 \\<notin> (degree \\<circ> f) ` insert x F;\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         sum (degree \\<circ> f) (insert x F) \\<and>\n                         (insert x F \\<noteq> {} \\<longrightarrow>\n                          degree (prod f (insert x F)) \\<noteq> 0 \\<and>\n                          prod f (insert x F) \\<noteq> 0) \\<and>\n                         coeff (prod f (insert x F))\n                          (sum (degree \\<circ> f) (insert x F)) =\n                         (1::'b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    (insert a S \\<noteq> {} \\<longrightarrow>\n     degree (prod f (insert a S)) \\<noteq> 0 \\<and>\n     prod f (insert a S) \\<noteq> 0) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "using id"], ["proof (prove)\nusing this:\n  degree (prod f (insert a S)) = sum (degree \\<circ> f) (insert a S) \\<and>\n  coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. degree (prod f (insert a S)) =\n    sum (degree \\<circ> f) (insert a S) \\<and>\n    (insert a S \\<noteq> {} \\<longrightarrow>\n     degree (prod f (insert a S)) \\<noteq> 0 \\<and>\n     prod f (insert a S) \\<noteq> 0) \\<and>\n    coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n    (1::'b)", "unfolding sum.insert[OF insert(1-2)]"], ["proof (prove)\nusing this:\n  degree (prod f (insert a S)) =\n  (degree \\<circ> f) a + sum (degree \\<circ> f) S \\<and>\n  coeff (prod f (insert a S))\n   ((degree \\<circ> f) a + sum (degree \\<circ> f) S) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. degree (prod f (insert a S)) =\n    (degree \\<circ> f) a + sum (degree \\<circ> f) S \\<and>\n    (insert a S \\<noteq> {} \\<longrightarrow>\n     degree (prod f (insert a S)) \\<noteq> 0 \\<and>\n     prod f (insert a S) \\<noteq> 0) \\<and>\n    coeff (prod f (insert a S))\n     ((degree \\<circ> f) a + sum (degree \\<circ> f) S) =\n    (1::'b)", "using insert"], ["proof (prove)\nusing this:\n  degree (prod f (insert a S)) =\n  (degree \\<circ> f) a + sum (degree \\<circ> f) S \\<and>\n  coeff (prod f (insert a S))\n   ((degree \\<circ> f) a + sum (degree \\<circ> f) S) =\n  (1::'b)\n  finite S\n  a \\<notin> S\n  \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` S;\n   \\<And>a. a \\<in> S \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n                    (S \\<noteq> {} \\<longrightarrow>\n                     degree (prod f S) \\<noteq> 0 \\<and>\n                     prod f S \\<noteq> 0) \\<and>\n                    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n  0 \\<notin> (degree \\<circ> f) ` insert a S\n  ?a \\<in> insert a S \\<Longrightarrow> monic (f ?a)\n\ngoal (1 subgoal):\n 1. degree (prod f (insert a S)) =\n    (degree \\<circ> f) a + sum (degree \\<circ> f) S \\<and>\n    (insert a S \\<noteq> {} \\<longrightarrow>\n     degree (prod f (insert a S)) \\<noteq> 0 \\<and>\n     prod f (insert a S) \\<noteq> 0) \\<and>\n    coeff (prod f (insert a S))\n     ((degree \\<circ> f) a + sum (degree \\<circ> f) S) =\n    (1::'b)", "by auto"], ["proof (state)\nthis:\n  degree (prod f (insert a S)) = sum (degree \\<circ> f) (insert a S) \\<and>\n  (insert a S \\<noteq> {} \\<longrightarrow>\n   degree (prod f (insert a S)) \\<noteq> 0 \\<and>\n   prod f (insert a S) \\<noteq> 0) \\<and>\n  coeff (prod f (insert a S)) (sum (degree \\<circ> f) (insert a S)) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> (degree \\<circ> f) ` {};\n     \\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)\\<rbrakk>\n    \\<Longrightarrow> degree (prod f {}) = sum (degree \\<circ> f) {} \\<and>\n                      ({} \\<noteq> {} \\<longrightarrow>\n                       degree (prod f {}) \\<noteq> 0 \\<and>\n                       prod f {} \\<noteq> 0) \\<and>\n                      coeff (prod f {}) (sum (degree \\<circ> f) {}) =\n                      (1::'b)", "qed simp"], ["proof (state)\nthis:\n  degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n  (S \\<noteq> {} \\<longrightarrow>\n   degree (prod f S) \\<noteq> 0 \\<and> prod f S \\<noteq> 0) \\<and>\n  coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n\ngoal (1 subgoal):\n 1. degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n  (S \\<noteq> {} \\<longrightarrow>\n   degree (prod f S) \\<noteq> 0 \\<and> prod f S \\<noteq> 0) \\<and>\n  coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n\ngoal (1 subgoal):\n 1. degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n    coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)", "by auto"], ["proof (state)\nthis:\n  degree (prod f S) = sum (degree \\<circ> f) S \\<and>\n  coeff (prod f S) (sum (degree \\<circ> f) S) = (1::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_prod_monic: \n  assumes \"\\<And> i. i < n \\<Longrightarrow> degree (f i :: 'a :: comm_semiring_1 poly) = 1\"\n    and \"\\<And> i. i < n \\<Longrightarrow> coeff (f i) 1 = 1\"\n  shows \"degree (prod f {0 ..< n}) = n \\<and> coeff (prod f {0 ..< n}) n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) = n \\<and> coeff (prod f {0..<n}) n = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) = n \\<and> coeff (prod f {0..<n}) n = (1::'a)", "from degree_prod_sum_monic[of \"{0 ..< n}\" f]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite {0..<n}; 0 \\<notin> (degree \\<circ> f) ` {0..<n};\n   \\<And>a. a \\<in> {0..<n} \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f {0..<n}) =\n                    sum (degree \\<circ> f) {0..<n} \\<and>\n                    coeff (prod f {0..<n})\n                     (sum (degree \\<circ> f) {0..<n}) =\n                    (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {0..<n}; 0 \\<notin> (degree \\<circ> f) ` {0..<n};\n   \\<And>a. a \\<in> {0..<n} \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f {0..<n}) =\n                    sum (degree \\<circ> f) {0..<n} \\<and>\n                    coeff (prod f {0..<n})\n                     (sum (degree \\<circ> f) {0..<n}) =\n                    (1::'a)\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) = n \\<and> coeff (prod f {0..<n}) n = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {0..<n}; 0 \\<notin> (degree \\<circ> f) ` {0..<n};\n   \\<And>a. a \\<in> {0..<n} \\<Longrightarrow> monic (f a)\\<rbrakk>\n  \\<Longrightarrow> degree (prod f {0..<n}) =\n                    sum (degree \\<circ> f) {0..<n} \\<and>\n                    coeff (prod f {0..<n})\n                     (sum (degree \\<circ> f) {0..<n}) =\n                    (1::'a)\n  ?i < n \\<Longrightarrow> degree (f ?i) = 1\n  ?i < n \\<Longrightarrow> coeff (f ?i) 1 = (1::'a)\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) = n \\<and> coeff (prod f {0..<n}) n = (1::'a)", "by force"], ["proof (state)\nthis:\n  degree (prod f {0..<n}) = n \\<and> coeff (prod f {0..<n}) n = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_prod_sum_lt_n: assumes \"\\<And> i. i < n \\<Longrightarrow> degree (f i :: 'a :: comm_semiring_1 poly) \\<le> 1\"\n  and i: \"i < n\" and fi: \"degree (f i) = 0\"\n  shows \"degree (prod f {0 ..< n}) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "have \"degree (prod f {0 ..< n}) \\<le> sum (degree o f) {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) \\<le> sum (degree \\<circ> f) {0..<n}", "by (rule degree_prod_sum_le, auto)"], ["proof (state)\nthis:\n  degree (prod f {0..<n}) \\<le> sum (degree \\<circ> f) {0..<n}\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "also"], ["proof (state)\nthis:\n  degree (prod f {0..<n}) \\<le> sum (degree \\<circ> f) {0..<n}\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "have \"sum (degree o f) {0 ..< n} = (degree o f) i + sum (degree o f) ({0 ..< n} - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (degree \\<circ> f) {0..<n} =\n    (degree \\<circ> f) i + sum (degree \\<circ> f) ({0..<n} - {i})", "by (rule sum.remove, insert i, auto)"], ["proof (state)\nthis:\n  sum (degree \\<circ> f) {0..<n} =\n  (degree \\<circ> f) i + sum (degree \\<circ> f) ({0..<n} - {i})\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "also"], ["proof (state)\nthis:\n  sum (degree \\<circ> f) {0..<n} =\n  (degree \\<circ> f) i + sum (degree \\<circ> f) ({0..<n} - {i})\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "have \"(degree o f) i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degree \\<circ> f) i = 0", "using fi"], ["proof (prove)\nusing this:\n  degree (f i) = 0\n\ngoal (1 subgoal):\n 1. (degree \\<circ> f) i = 0", "by simp"], ["proof (state)\nthis:\n  (degree \\<circ> f) i = 0\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "also"], ["proof (state)\nthis:\n  (degree \\<circ> f) i = 0\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "have \"sum (degree o f) ({0 ..< n} - {i}) \\<le> sum (\\<lambda> _. 1) ({0 ..< n} - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (degree \\<circ> f) ({0..<n} - {i})\n    \\<le> (\\<Sum>_\\<in>{0..<n} - {i}. 1)", "by (rule sum_mono, insert assms, auto)"], ["proof (state)\nthis:\n  sum (degree \\<circ> f) ({0..<n} - {i})\n  \\<le> (\\<Sum>_\\<in>{0..<n} - {i}. 1)\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "also"], ["proof (state)\nthis:\n  sum (degree \\<circ> f) ({0..<n} - {i})\n  \\<le> (\\<Sum>_\\<in>{0..<n} - {i}. 1)\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "have \"\\<dots> = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>{0..<n} - {i}. 1) = n - 1", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>{0..<n} - {i}. 1) = n - 1", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>{0..<n} - {i}. 1) = n - 1\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "also"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>{0..<n} - {i}. 1) = n - 1\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "have \"\\<dots> < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 1 < n", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. n - 1 < n", "by simp"], ["proof (state)\nthis:\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> 0 + x \\<le> 0 + y;\n   \\<And>x y. x < y \\<Longrightarrow> 0 + x < 0 + y\\<rbrakk>\n  \\<Longrightarrow> degree (prod f {0..<n}) < 0 + n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> 0 + x \\<le> 0 + y;\n   \\<And>x y. x < y \\<Longrightarrow> 0 + x < 0 + y\\<rbrakk>\n  \\<Longrightarrow> degree (prod f {0..<n}) < 0 + n\n\ngoal (1 subgoal):\n 1. degree (prod f {0..<n}) < n", "by simp"], ["proof (state)\nthis:\n  degree (prod f {0..<n}) < n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_linear_factors: \"degree (\\<Prod> a \\<leftarrow> as. [: f a, 1:]) = length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:]) = length as", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree (\\<Prod>a\\<leftarrow>[]. [:f a, 1::'a:]) = length []\n 2. \\<And>a as.\n       degree (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:]) =\n       length as \\<Longrightarrow>\n       degree (\\<Prod>a\\<leftarrow>a # as. [:f a, 1::'a:]) = length (a # as)", "case (Cons b as)"], ["proof (state)\nthis:\n  degree (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:]) = length as\n\ngoal (2 subgoals):\n 1. degree (\\<Prod>a\\<leftarrow>[]. [:f a, 1::'a:]) = length []\n 2. \\<And>a as.\n       degree (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:]) =\n       length as \\<Longrightarrow>\n       degree (\\<Prod>a\\<leftarrow>a # as. [:f a, 1::'a:]) = length (a # as)", "note IH = this"], ["proof (state)\nthis:\n  degree (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:]) = length as\n\ngoal (2 subgoals):\n 1. degree (\\<Prod>a\\<leftarrow>[]. [:f a, 1::'a:]) = length []\n 2. \\<And>a as.\n       degree (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:]) =\n       length as \\<Longrightarrow>\n       degree (\\<Prod>a\\<leftarrow>a # as. [:f a, 1::'a:]) = length (a # as)", "have id: \"(\\<Prod>a\\<leftarrow>b # as. [:f a, 1:]) = [:f b,1 :] * (\\<Prod>a\\<leftarrow>as. [:f a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>b # as. [:f a, 1::'a:]) =\n    [:f b, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>b # as. [:f a, 1::'a:]) =\n  [:f b, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:])\n\ngoal (2 subgoals):\n 1. degree (\\<Prod>a\\<leftarrow>[]. [:f a, 1::'a:]) = length []\n 2. \\<And>a as.\n       degree (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:]) =\n       length as \\<Longrightarrow>\n       degree (\\<Prod>a\\<leftarrow>a # as. [:f a, 1::'a:]) = length (a # as)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>a\\<leftarrow>b # as. [:f a, 1::'a:]) = length (b # as)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:f b, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:f a, 1::'a:])) =\n    length (b # as)", "by (subst degree_monic_mult, insert IH, auto)"], ["proof (state)\nthis:\n  degree (\\<Prod>a\\<leftarrow>b # as. [:f a, 1::'a:]) = length (b # as)\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>a\\<leftarrow>[]. [:f a, 1::'a:]) = length []", "qed simp"], ["", "lemma monic_mult:\n  fixes p q :: \"'a :: idom poly\"\n  assumes \"monic p\" \"monic q\"\n  shows \"monic (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monic (p * q)", "from assms"], ["proof (chain)\npicking this:\n  monic p\n  monic q", "have nz: \"p \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic p\n  monic q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (p * q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (p * q)", "unfolding degree_mult_eq[OF nz] coeff_mult_degree_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  monic p\n  monic q\n\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (1::'a)", "by simp"], ["proof (state)\nthis:\n  monic (p * q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_factor:\n  fixes p q :: \"'a :: idom poly\"\n  assumes \"monic (p * q)\" \"monic p\"\n  shows \"monic q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monic q", "from assms"], ["proof (chain)\npicking this:\n  monic (p * q)\n  monic p", "have nz: \"p \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic (p * q)\n  monic p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic q", "from assms[unfolded degree_mult_eq[OF nz] coeff_mult_degree_sum \\<open>monic p\\<close>]"], ["proof (chain)\npicking this:\n  (1::'a) * lead_coeff q = (1::'a)\n  (1::'a) = (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (1::'a) * lead_coeff q = (1::'a)\n  (1::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. monic q", "by simp"], ["proof (state)\nthis:\n  monic q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_prod:\n  fixes f :: \"'a \\<Rightarrow> 'b :: idom poly\"\n  assumes \"\\<And> a. a \\<in> as \\<Longrightarrow> monic (f a)\"\n  shows \"monic (prod f as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (prod f as)", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> as \\<Longrightarrow> monic (f ?a)\n\ngoal (1 subgoal):\n 1. monic (prod f as)", "proof (induct as rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>a. a \\<in> A \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> monic (prod f A)\n 2. (\\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n    monic (prod f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n        monic (prod f F);\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> monic (prod f (insert x F))", "case (insert a as)"], ["proof (state)\nthis:\n  finite as\n  a \\<notin> as\n  (\\<And>a. a \\<in> as \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n  monic (prod f as)\n  ?a \\<in> insert a as \\<Longrightarrow> monic (f ?a)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>a. a \\<in> A \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> monic (prod f A)\n 2. (\\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n    monic (prod f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n        monic (prod f F);\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> monic (prod f (insert x F))", "hence id: \"prod f (insert a as) = f a * prod f as\" \n    and *: \"monic (f a)\" \"monic (prod f as)\""], ["proof (prove)\nusing this:\n  finite as\n  a \\<notin> as\n  (\\<And>a. a \\<in> as \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n  monic (prod f as)\n  ?a \\<in> insert a as \\<Longrightarrow> monic (f ?a)\n\ngoal (1 subgoal):\n 1. prod f (insert a as) = f a * prod f as &&&\n    monic (f a) &&& monic (prod f as)", "by auto"], ["proof (state)\nthis:\n  prod f (insert a as) = f a * prod f as\n  monic (f a)\n  monic (prod f as)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>a. a \\<in> A \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> monic (prod f A)\n 2. (\\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n    monic (prod f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a. a \\<in> F \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n        monic (prod f F);\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> monic (prod f (insert x F))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (prod f (insert a as))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (f a * prod f as)", "by (rule monic_mult[OF *])"], ["proof (state)\nthis:\n  monic (prod f (insert a as))\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>a. a \\<in> A \\<Longrightarrow> monic (f a)\\<rbrakk>\n       \\<Longrightarrow> monic (prod f A)\n 2. (\\<And>a. a \\<in> {} \\<Longrightarrow> monic (f a)) \\<Longrightarrow>\n    monic (prod f {})", "qed auto"], ["", "lemma monic_prod_list:\n  fixes as :: \"'a :: idom poly list\"\n  assumes \"\\<And> a. a \\<in> set as \\<Longrightarrow> monic a\"\n  shows \"monic (prod_list as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (prod_list as)", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> set as \\<Longrightarrow> monic ?a\n\ngoal (1 subgoal):\n 1. monic (prod_list as)", "by (induct as, auto intro: monic_mult)"], ["", "lemma monic_power:\n  assumes \"monic (p :: 'a :: idom poly)\"\n  shows \"monic (p ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (p ^ n)", "by (induct n, insert assms, auto intro: monic_mult)"], ["", "lemma monic_prod_list_pow: \"monic (\\<Prod>(x::'a::idom, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1::'a:] ^ Suc i)", "proof (rule monic_prod_list, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (map (\\<lambda>(x, i). [:- x, 1::'a:] ^ Suc i)\n                     xis) \\<Longrightarrow>\n       monic a", "case (1 a)"], ["proof (state)\nthis:\n  a \\<in> set (map (\\<lambda>(x, i). [:- x, 1::'a:] ^ Suc i) xis)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (map (\\<lambda>(x, i). [:- x, 1::'a:] ^ Suc i)\n                     xis) \\<Longrightarrow>\n       monic a", "then"], ["proof (chain)\npicking this:\n  a \\<in> set (map (\\<lambda>(x, i). [:- x, 1::'a:] ^ Suc i) xis)", "obtain x i where a: \"a = [:-x, 1:]^Suc i\""], ["proof (prove)\nusing this:\n  a \\<in> set (map (\\<lambda>(x, i). [:- x, 1::'a:] ^ Suc i) xis)\n\ngoal (1 subgoal):\n 1. (\\<And>x i.\n        a = [:- x, 1::'a:] ^ Suc i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  a = [:- x, 1::'a:] ^ Suc i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (map (\\<lambda>(x, i). [:- x, 1::'a:] ^ Suc i)\n                     xis) \\<Longrightarrow>\n       monic a", "show \"monic a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic a", "unfolding a"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic ([:- x, 1::'a:] ^ Suc i)", "by (rule monic_power, auto)"], ["proof (state)\nthis:\n  monic a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_degree_0: \"monic p \\<Longrightarrow> (degree p = 0) = (p = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic p \\<Longrightarrow> (degree p = 0) = (p = 1)", "using le_degree poly_eq_iff"], ["proof (prove)\nusing this:\n  coeff ?p ?n \\<noteq> (0::?'a) \\<Longrightarrow> ?n \\<le> degree ?p\n  (?p = ?q) = (\\<forall>n. coeff ?p n = coeff ?q n)\n\ngoal (1 subgoal):\n 1. monic p \\<Longrightarrow> (degree p = 0) = (p = 1)", "by force"], ["", "subsection \\<open>Roots\\<close>"], ["", "text \\<open>The following proof structure is completely similar to the one\n  of @{thm poly_roots_finite}.\\<close>"], ["", "lemma poly_roots_degree:\n  fixes p :: \"'a::idom poly\"\n  shows \"p \\<noteq> 0 \\<Longrightarrow> card {x. poly p x = 0} \\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "proof (induct n \\<equiv> \"degree p\" arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n = degree p; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly p x = (0::'a)}\n                                     \\<le> degree p;\n        Suc n = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "case (0 p)"], ["proof (state)\nthis:\n  0 = degree p\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n = degree p; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly p x = (0::'a)}\n                                     \\<le> degree p;\n        Suc n = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  0 = degree p\n  p \\<noteq> 0", "obtain a where \"a \\<noteq> 0\" and \"p = [:a:]\""], ["proof (prove)\nusing this:\n  0 = degree p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<noteq> (0::'a); p = [:a:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p, simp split: if_splits)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n  p = [:a:]\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n = degree p; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly p x = (0::'a)}\n                                     \\<le> degree p;\n        Suc n = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  p = [:a:]", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "by simp"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n = degree p; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly p x = (0::'a)}\n                                     \\<le> degree p;\n        Suc n = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n = degree p; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly p x = (0::'a)}\n                                     \\<le> degree p;\n        Suc n = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "case (Suc n p)"], ["proof (state)\nthis:\n  \\<lbrakk>n = degree ?p; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> card {x. poly ?p x = (0::'a)} \\<le> degree ?p\n  Suc n = degree p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n = degree p; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly p x = (0::'a)}\n                                     \\<le> degree p;\n        Suc n = degree p; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "proof (cases \"\\<exists>x. poly p x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "case True"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. poly p x = (0::'a)", "obtain a where a: \"poly p a = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a. poly p a = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  poly p a = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  poly p a = (0::'a)", "have \"[:-a, 1:] dvd p\""], ["proof (prove)\nusing this:\n  poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] dvd p", "by (simp only: poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] dvd p\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  [:- a, 1::'a:] dvd p", "obtain k where k: \"p = [:-a, 1:] * k\""], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        p = [:- a, 1::'a:] * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = [:- a, 1::'a:] * k\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "with \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = [:- a, 1::'a:] * k", "have \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = [:- a, 1::'a:] * k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "with k"], ["proof (chain)\npicking this:\n  p = [:- a, 1::'a:] * k\n  k \\<noteq> 0", "have \"degree p = Suc (degree k)\""], ["proof (prove)\nusing this:\n  p = [:- a, 1::'a:] * k\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = Suc (degree k)", "by (simp add: degree_mult_eq del: mult_pCons_left)"], ["proof (state)\nthis:\n  degree p = Suc (degree k)\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "with \\<open>Suc n = degree p\\<close>"], ["proof (chain)\npicking this:\n  Suc n = degree p\n  degree p = Suc (degree k)", "have \"n = degree k\""], ["proof (prove)\nusing this:\n  Suc n = degree p\n  degree p = Suc (degree k)\n\ngoal (1 subgoal):\n 1. n = degree k", "by simp"], ["proof (state)\nthis:\n  n = degree k\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "from Suc.hyps(1)[OF this \\<open>k \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  card {x. poly k x = (0::'a)} \\<le> degree k", "have le: \"card {x. poly k x = 0} \\<le> degree k\""], ["proof (prove)\nusing this:\n  card {x. poly k x = (0::'a)} \\<le> degree k\n\ngoal (1 subgoal):\n 1. card {x. poly k x = (0::'a)} \\<le> degree k", "."], ["proof (state)\nthis:\n  card {x. poly k x = (0::'a)} \\<le> degree k\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"card {x. poly p x = 0} = card {x. poly ([:-a, 1:] * k) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} =\n    card {x. poly ([:- a, 1::'a:] * k) x = (0::'a)}", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly ([:- a, 1::'a:] * k) x = (0::'a)} =\n    card {x. poly ([:- a, 1::'a:] * k) x = (0::'a)}", ".."], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} =\n  card {x. poly ([:- a, 1::'a:] * k) x = (0::'a)}\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} =\n  card {x. poly ([:- a, 1::'a:] * k) x = (0::'a)}\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"{x. poly ([:-a, 1:] * k) x = 0} = insert a {x. poly k x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly ([:- a, 1::'a:] * k) x = (0::'a)} =\n    insert a {x. poly k x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. poly ([:- a, 1::'a:] * k) x = (0::'a)} =\n  insert a {x. poly k x = (0::'a)}\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  {x. poly ([:- a, 1::'a:] * k) x = (0::'a)} =\n  insert a {x. poly k x = (0::'a)}\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"card \\<dots> \\<le> Suc (card {x. poly k x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert a {x. poly k x = (0::'a)})\n    \\<le> Suc (card {x. poly k x = (0::'a)})", "unfolding card_insert_if[OF poly_roots_finite[OF \\<open>k \\<noteq> 0\\<close>]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a \\<in> {x. poly k x = (0::'a)} then card {x. poly k x = (0::'a)}\n     else Suc (card {x. poly k x = (0::'a)}))\n    \\<le> Suc (card {x. poly k x = (0::'a)})", "by simp"], ["proof (state)\nthis:\n  card (insert a {x. poly k x = (0::'a)})\n  \\<le> Suc (card {x. poly k x = (0::'a)})\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card (insert a {x. poly k x = (0::'a)})\n  \\<le> Suc (card {x. poly k x = (0::'a)})\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"\\<dots> \\<le> Suc (degree k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card {x. poly k x = (0::'a)}) \\<le> Suc (degree k)", "using le"], ["proof (prove)\nusing this:\n  card {x. poly k x = (0::'a)} \\<le> degree k\n\ngoal (1 subgoal):\n 1. Suc (card {x. poly k x = (0::'a)}) \\<le> Suc (degree k)", "by auto"], ["proof (state)\nthis:\n  Suc (card {x. poly k x = (0::'a)}) \\<le> Suc (degree k)\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "finally"], ["proof (chain)\npicking this:\n  card {x. poly p x = (0::'a)} \\<le> Suc (degree k)", "show ?thesis"], ["proof (prove)\nusing this:\n  card {x. poly p x = (0::'a)} \\<le> Suc (degree k)\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "using \\<open>degree p = Suc (degree k)\\<close>"], ["proof (prove)\nusing this:\n  card {x. poly p x = (0::'a)} \\<le> Suc (degree k)\n  degree p = Suc (degree k)\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "by simp"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "qed simp"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_root_factor: \"(poly ([: r, 1:] * q) (k :: 'a :: idom) = 0) = (k = -r \\<or> poly q k = 0)\" (is ?one)\n  \"(poly (q * [: r, 1:]) k = 0) = (k = -r \\<or> poly q k = 0)\" (is ?two)\n  \"(poly [: r, 1 :] k = 0) = (k = -r)\" (is ?three)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly ([:r, 1::'a:] * q) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a)) &&&\n    (poly (q * [:r, 1::'a:]) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a)) &&&\n    (poly [:r, 1::'a:] k = (0::'a)) = (k = - r)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (poly ([:r, 1::'a:] * q) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))\n 2. (poly (q * [:r, 1::'a:]) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))\n 3. (poly [:r, 1::'a:] k = (0::'a)) = (k = - r)", "have [simp]: \"r + k = 0 \\<Longrightarrow> k = - r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r + k = (0::'a) \\<Longrightarrow> k = - r", "by (simp add: minus_unique)"], ["proof (state)\nthis:\n  r + k = (0::'a) \\<Longrightarrow> k = - r\n\ngoal (3 subgoals):\n 1. (poly ([:r, 1::'a:] * q) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))\n 2. (poly (q * [:r, 1::'a:]) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))\n 3. (poly [:r, 1::'a:] k = (0::'a)) = (k = - r)", "show ?one"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly ([:r, 1::'a:] * q) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))", "unfolding poly_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly [:r, 1::'a:] k * poly q k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (poly ([:r, 1::'a:] * q) k = (0::'a)) = (k = - r \\<or> poly q k = (0::'a))\n\ngoal (2 subgoals):\n 1. (poly (q * [:r, 1::'a:]) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))\n 2. (poly [:r, 1::'a:] k = (0::'a)) = (k = - r)", "show ?two"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (q * [:r, 1::'a:]) k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))", "unfolding poly_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly q k * poly [:r, 1::'a:] k = (0::'a)) =\n    (k = - r \\<or> poly q k = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (poly (q * [:r, 1::'a:]) k = (0::'a)) = (k = - r \\<or> poly q k = (0::'a))\n\ngoal (1 subgoal):\n 1. (poly [:r, 1::'a:] k = (0::'a)) = (k = - r)", "show ?three"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly [:r, 1::'a:] k = (0::'a)) = (k = - r)", "by auto"], ["proof (state)\nthis:\n  (poly [:r, 1::'a:] k = (0::'a)) = (k = - r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_root_constant: \"c \\<noteq> 0 \\<Longrightarrow> (poly (p * [:c:]) (k :: 'a :: idom) = 0) = (poly p k = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    (poly (p * [:c:]) k = (0::'a)) = (poly p k = (0::'a))", "unfolding poly_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    (poly p k * poly [:c:] k = (0::'a)) = (poly p k = (0::'a))", "by auto"], ["", "lemma poly_linear_exp_linear_factors_rev: \n  \"([:b,1:])^(length (filter ((=) b) as)) dvd (\\<Prod> (a :: 'a :: comm_ring_1) \\<leftarrow> as. [: a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n    (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) []) dvd\n    (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:])\n 2. \\<And>a as.\n       [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n       (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "case (Cons a as)"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n  (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) []) dvd\n    (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:])\n 2. \\<And>a as.\n       [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n       (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "let ?ls = \"length (filter ((=) b) (a # as))\""], ["proof (state)\ngoal (2 subgoals):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) []) dvd\n    (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:])\n 2. \\<And>a as.\n       [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n       (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "let ?l = \"length (filter ((=) b) as)\""], ["proof (state)\ngoal (2 subgoals):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) []) dvd\n    (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:])\n 2. \\<And>a as.\n       [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n       (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "have prod: \"(\\<Prod> a \\<leftarrow> Cons a as. [: a, 1:]) = [: a, 1 :] * (\\<Prod> a \\<leftarrow> as. [: a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) =\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) =\n  [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) []) dvd\n    (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:])\n 2. \\<And>a as.\n       [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n       (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "proof (cases \"a = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])\n 2. a \\<noteq> b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])\n 2. a \\<noteq> b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "hence len: \"?ls = ?l\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. length (filter ((=) b) (a # as)) = length (filter ((=) b) as)", "by simp"], ["proof (state)\nthis:\n  length (filter ((=) b) (a # as)) = length (filter ((=) b) as)\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])\n 2. a \\<noteq> b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "unfolding prod len"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "using Cons"], ["proof (prove)\nusing this:\n  [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n  (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "by (rule dvd_mult)"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n  (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "case True"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "hence len: \"[: b, 1 :] ^ ?ls = [: a, 1 :] * [: b, 1 :] ^ ?l\""], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) =\n    [:a, 1::'a:] * [:b, 1::'a:] ^ length (filter ((=) b) as)", "by simp"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) =\n  [:a, 1::'a:] * [:b, 1::'a:] ^ length (filter ((=) b) as)\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow>\n    [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n    (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])", "unfolding prod len"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, 1::'a:] * [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "using Cons"], ["proof (prove)\nusing this:\n  [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n  (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. [:a, 1::'a:] * [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "using dvd_refl mult_dvd_mono"], ["proof (prove)\nusing this:\n  [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n  (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n  ?a dvd ?a\n  \\<lbrakk>?a dvd ?b; ?c dvd ?d\\<rbrakk>\n  \\<Longrightarrow> ?a * ?c dvd ?b * ?d\n\ngoal (1 subgoal):\n 1. [:a, 1::'a:] * [:b, 1::'a:] ^ length (filter ((=) b) as) dvd\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "by blast"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n  (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ length (filter ((=) b) (a # as)) dvd\n  (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ length (filter ((=) b) []) dvd\n    (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:])", "qed simp"], ["", "lemma order_max: assumes dvd: \"[: -a, 1 :] ^ k dvd p\" and p: \"p \\<noteq> 0\"\n  shows \"k \\<le> order a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> order a p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> order a p \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> k \\<le> order a p\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> order a p \\<Longrightarrow> False", "hence \"\\<exists> j. k = Suc (order a p + j)\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> order a p\n\ngoal (1 subgoal):\n 1. \\<exists>j. k = Suc (order a p + j)", "by arith"], ["proof (state)\nthis:\n  \\<exists>j. k = Suc (order a p + j)\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> order a p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>j. k = Suc (order a p + j)", "obtain j where k: \"k = Suc (order a p + j)\""], ["proof (prove)\nusing this:\n  \\<exists>j. k = Suc (order a p + j)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        k = Suc (order a p + j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = Suc (order a p + j)\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> order a p \\<Longrightarrow> False", "have \"[: -a, 1 :] ^ Suc (order a p) dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] ^ Suc (order a p) dvd p", "by (rule power_le_dvd[OF dvd[unfolded k]], simp)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ Suc (order a p) dvd p\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> order a p \\<Longrightarrow> False", "with order_2[OF p, of a]"], ["proof (chain)\npicking this:\n  \\<not> [:- a, 1::'a:] ^ Suc (order a p) dvd p\n  [:- a, 1::'a:] ^ Suc (order a p) dvd p", "show False"], ["proof (prove)\nusing this:\n  \\<not> [:- a, 1::'a:] ^ Suc (order a p) dvd p\n  [:- a, 1::'a:] ^ Suc (order a p) dvd p\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Divisibility\\<close>"], ["", "context\n  assumes \"SORT_CONSTRAINT('a :: idom)\"\nbegin"], ["", "lemma poly_linear_linear_factor: assumes \n  dvd: \"[:b,1:] dvd (\\<Prod> (a :: 'a) \\<leftarrow> as. [: a, 1:])\"\n  shows \"b \\<in> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> set as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> set as", "let ?p = \"\\<lambda> as. (\\<Prod> a \\<leftarrow> as. [: a, 1:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> set as", "let ?b = \"[:b,1:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> set as", "from assms[unfolded dvd_def]"], ["proof (chain)\npicking this:\n  \\<exists>k. (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) = [:b, 1::'a:] * k", "obtain p where id: \"?p as = ?b * p\""], ["proof (prove)\nusing this:\n  \\<exists>k. (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) = [:b, 1::'a:] * k\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) =\n        [:b, 1::'a:] * p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) = [:b, 1::'a:] * p\n\ngoal (1 subgoal):\n 1. b \\<in> set as", "from arg_cong[OF id, of \"\\<lambda> p. poly p (-b)\"]"], ["proof (chain)\npicking this:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n  poly ([:b, 1::'a:] * p) (- b)", "have \"poly (?p as) (-b) = 0\""], ["proof (prove)\nusing this:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n  poly ([:b, 1::'a:] * p) (- b)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) = (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<in> set as", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) = (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<in> set as", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:]) (- b) =\n    (0::'a) \\<Longrightarrow>\n    b \\<in> set []\n 2. \\<And>a as.\n       \\<lbrakk>poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n                (0::'a) \\<Longrightarrow>\n                b \\<in> set as;\n        poly (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) (- b) =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> b \\<in> set (a # as)", "case (Cons a as)"], ["proof (state)\nthis:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n  (0::'a) \\<Longrightarrow>\n  b \\<in> set as\n  poly (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) (- b) = (0::'a)\n\ngoal (2 subgoals):\n 1. poly (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:]) (- b) =\n    (0::'a) \\<Longrightarrow>\n    b \\<in> set []\n 2. \\<And>a as.\n       \\<lbrakk>poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n                (0::'a) \\<Longrightarrow>\n                b \\<in> set as;\n        poly (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) (- b) =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> b \\<in> set (a # as)", "have \"?p (a # as) = [:a,1:] * ?p as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) =\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) =\n  [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. poly (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:]) (- b) =\n    (0::'a) \\<Longrightarrow>\n    b \\<in> set []\n 2. \\<And>a as.\n       \\<lbrakk>poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n                (0::'a) \\<Longrightarrow>\n                b \\<in> set as;\n        poly (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) (- b) =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> b \\<in> set (a # as)", "from Cons(2)[unfolded this]"], ["proof (chain)\npicking this:\n  poly ([:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])) (- b) =\n  (0::'a)", "have \"poly (?p as) (-b) = 0 \\<or> (a - b) = 0\""], ["proof (prove)\nusing this:\n  poly ([:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])) (- b) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) = (0::'a) \\<or>\n    a - b = (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) = (0::'a) \\<or>\n  a - b = (0::'a)\n\ngoal (2 subgoals):\n 1. poly (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:]) (- b) =\n    (0::'a) \\<Longrightarrow>\n    b \\<in> set []\n 2. \\<And>a as.\n       \\<lbrakk>poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n                (0::'a) \\<Longrightarrow>\n                b \\<in> set as;\n        poly (\\<Prod>a\\<leftarrow>a # as. [:a, 1::'a:]) (- b) =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> b \\<in> set (a # as)", "with Cons(1)"], ["proof (chain)\npicking this:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n  (0::'a) \\<Longrightarrow>\n  b \\<in> set as\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) = (0::'a) \\<or>\n  a - b = (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) =\n  (0::'a) \\<Longrightarrow>\n  b \\<in> set as\n  poly (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) (- b) = (0::'a) \\<or>\n  a - b = (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<in> set (a # as)", "by auto"], ["proof (state)\nthis:\n  b \\<in> set (a # as)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>a\\<leftarrow>[]. [:a, 1::'a:]) (- b) =\n    (0::'a) \\<Longrightarrow>\n    b \\<in> set []", "qed simp"], ["proof (state)\nthis:\n  b \\<in> set as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_linear_exp_linear_factors: \n  assumes dvd: \"([:b,1:])^n dvd (\\<Prod> (a :: 'a) \\<leftarrow> as. [: a, 1:])\"\n  shows \"length (filter ((=) b) as) \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length (filter ((=) b) as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> length (filter ((=) b) as)", "let ?p = \"\\<lambda> as. (\\<Prod> a \\<leftarrow> as. [: a, 1:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> length (filter ((=) b) as)", "let ?b = \"[:b,1:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> length (filter ((=) b) as)", "from dvd"], ["proof (chain)\npicking this:\n  [:b, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])", "show ?thesis"], ["proof (prove)\nusing this:\n  [:b, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. n \\<le> length (filter ((=) b) as)", "proof (induct n arbitrary: as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as.\n       [:b, 1::'a:] ^ 0 dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       0 \\<le> length (filter ((=) b) as)\n 2. \\<And>n as.\n       \\<lbrakk>\\<And>as.\n                   [:b, 1::'a:] ^ n dvd\n                   (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n                   n \\<le> length (filter ((=) b) as);\n        [:b, 1::'a:] ^ Suc n dvd\n        (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\\<rbrakk>\n       \\<Longrightarrow> Suc n \\<le> length (filter ((=) b) as)", "case (Suc n as)"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ n dvd\n  (\\<Prod>a\\<leftarrow>?as1. [:a, 1::'a:]) \\<Longrightarrow>\n  n \\<le> length (filter ((=) b) ?as1)\n  [:b, 1::'a:] ^ Suc n dvd (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. \\<And>as.\n       [:b, 1::'a:] ^ 0 dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       0 \\<le> length (filter ((=) b) as)\n 2. \\<And>n as.\n       \\<lbrakk>\\<And>as.\n                   [:b, 1::'a:] ^ n dvd\n                   (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n                   n \\<le> length (filter ((=) b) as);\n        [:b, 1::'a:] ^ Suc n dvd\n        (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\\<rbrakk>\n       \\<Longrightarrow> Suc n \\<le> length (filter ((=) b) as)", "have bs: \"?b ^ Suc n = ?b * ?b ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ Suc n = [:b, 1::'a:] * [:b, 1::'a:] ^ n", "by simp"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ Suc n = [:b, 1::'a:] * [:b, 1::'a:] ^ n\n\ngoal (2 subgoals):\n 1. \\<And>as.\n       [:b, 1::'a:] ^ 0 dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       0 \\<le> length (filter ((=) b) as)\n 2. \\<And>n as.\n       \\<lbrakk>\\<And>as.\n                   [:b, 1::'a:] ^ n dvd\n                   (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n                   n \\<le> length (filter ((=) b) as);\n        [:b, 1::'a:] ^ Suc n dvd\n        (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\\<rbrakk>\n       \\<Longrightarrow> Suc n \\<le> length (filter ((=) b) as)", "from poly_linear_linear_factor[OF dvd_mult_left[OF Suc(2)[unfolded bs]], \n      unfolded in_set_conv_decomp]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. as = ys @ b # zs", "obtain as1 as2 where as: \"as = as1 @ b # as2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. as = ys @ b # zs\n\ngoal (1 subgoal):\n 1. (\\<And>as1 as2.\n        as = as1 @ b # as2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as1 @ b # as2\n\ngoal (2 subgoals):\n 1. \\<And>as.\n       [:b, 1::'a:] ^ 0 dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       0 \\<le> length (filter ((=) b) as)\n 2. \\<And>n as.\n       \\<lbrakk>\\<And>as.\n                   [:b, 1::'a:] ^ n dvd\n                   (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n                   n \\<le> length (filter ((=) b) as);\n        [:b, 1::'a:] ^ Suc n dvd\n        (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\\<rbrakk>\n       \\<Longrightarrow> Suc n \\<le> length (filter ((=) b) as)", "have \"?p as = [:b,1:] * ?p (as1 @ as2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])", "unfolding as"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])", "proof (induct as1)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])\n 2. \\<And>a as1.\n       (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "case (Cons a as1)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n  [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])\n 2. \\<And>a as1.\n       (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "have \"?p (a # as1 @ b # as2) = [:a,1:] * ?p (as1 @ b # as2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>a # as1 @ b # as2. [:a, 1::'a:]) =\n    [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>a # as1 @ b # as2. [:a, 1::'a:]) =\n  [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])\n 2. \\<And>a as1.\n       (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>a # as1 @ b # as2. [:a, 1::'a:]) =\n  [:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])\n 2. \\<And>a as1.\n       (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "have \"?p (as1 @ b # as2) = [:b,1:] * ?p (as1 @ as2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n  [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])\n 2. \\<And>a as1.\n       (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n  [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])\n 2. \\<And>a as1.\n       (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "have \"[:a,1:] * \\<dots> = [:b,1:] * ([:a,1:] * ?p (as1 @ as2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, 1::'a:] *\n    ([:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])) =\n    [:b, 1::'a:] *\n    ([:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]))", "by (metis (no_types, lifting) mult.left_commute)"], ["proof (state)\nthis:\n  [:a, 1::'a:] *\n  ([:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])) =\n  [:b, 1::'a:] *\n  ([:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]))\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])\n 2. \\<And>a as1.\n       (\\<Prod>a\\<leftarrow>as1 @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]) \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n       [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<leftarrow>a # as1 @ b # as2. [:a, 1::'a:]) =\n  [:b, 1::'a:] *\n  ([:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>a # as1 @ b # as2. [:a, 1::'a:]) =\n  [:b, 1::'a:] *\n  ([:a, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:]))\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>(a # as1) @ b # as2. [:a, 1::'a:]) =\n  [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>(a # as1) @ as2. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>[] @ b # as2. [:a, 1::'a:]) =\n    [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>[] @ as2. [:a, 1::'a:])", "qed simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) =\n  [:b, 1::'a:] * (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. \\<And>as.\n       [:b, 1::'a:] ^ 0 dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       0 \\<le> length (filter ((=) b) as)\n 2. \\<And>n as.\n       \\<lbrakk>\\<And>as.\n                   [:b, 1::'a:] ^ n dvd\n                   (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n                   n \\<le> length (filter ((=) b) as);\n        [:b, 1::'a:] ^ Suc n dvd\n        (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\\<rbrakk>\n       \\<Longrightarrow> Suc n \\<le> length (filter ((=) b) as)", "from Suc(2)[unfolded bs this dvd_mult_cancel_left]"], ["proof (chain)\npicking this:\n  [:b, 1::'a:] = 0 \\<or>\n  [:b, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])", "have \"?b ^ n dvd ?p (as1 @ as2)\""], ["proof (prove)\nusing this:\n  [:b, 1::'a:] = 0 \\<or>\n  [:b, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as1 @ as2. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. \\<And>as.\n       [:b, 1::'a:] ^ 0 dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       0 \\<le> length (filter ((=) b) as)\n 2. \\<And>n as.\n       \\<lbrakk>\\<And>as.\n                   [:b, 1::'a:] ^ n dvd\n                   (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n                   n \\<le> length (filter ((=) b) as);\n        [:b, 1::'a:] ^ Suc n dvd\n        (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:])\\<rbrakk>\n       \\<Longrightarrow> Suc n \\<le> length (filter ((=) b) as)", "from Suc(1)[OF this]"], ["proof (chain)\npicking this:\n  n \\<le> length (filter ((=) b) (as1 @ as2))", "show ?case"], ["proof (prove)\nusing this:\n  n \\<le> length (filter ((=) b) (as1 @ as2))\n\ngoal (1 subgoal):\n 1. Suc n \\<le> length (filter ((=) b) as)", "unfolding as"], ["proof (prove)\nusing this:\n  n \\<le> length (filter ((=) b) (as1 @ as2))\n\ngoal (1 subgoal):\n 1. Suc n \\<le> length (filter ((=) b) (as1 @ b # as2))", "by simp"], ["proof (state)\nthis:\n  Suc n \\<le> length (filter ((=) b) as)\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       [:b, 1::'a:] ^ 0 dvd\n       (\\<Prod>a\\<leftarrow>as. [:a, 1::'a:]) \\<Longrightarrow>\n       0 \\<le> length (filter ((=) b) as)", "qed simp"], ["proof (state)\nthis:\n  n \\<le> length (filter ((=) b) as)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma const_poly_dvd: \"([:a:] dvd [:b:]) = (a dvd b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:a:] dvd [:b:]) = (a dvd b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b\n 2. a dvd b \\<Longrightarrow> [:a:] dvd [:b:]", "assume \"a dvd b\""], ["proof (state)\nthis:\n  a dvd b\n\ngoal (2 subgoals):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b\n 2. a dvd b \\<Longrightarrow> [:a:] dvd [:b:]", "then"], ["proof (chain)\npicking this:\n  a dvd b", "obtain c where \"b = a * c\""], ["proof (prove)\nusing this:\n  a dvd b\n\ngoal (1 subgoal):\n 1. (\\<And>c. b = a * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. b = a * k\n\ngoal (1 subgoal):\n 1. (\\<And>c. b = a * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  b = a * c\n\ngoal (2 subgoals):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b\n 2. a dvd b \\<Longrightarrow> [:a:] dvd [:b:]", "hence \"[:b:] = [:a:] * [: c:]\""], ["proof (prove)\nusing this:\n  b = a * c\n\ngoal (1 subgoal):\n 1. [:b:] = [:a:] * [:c:]", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  [:b:] = [:a:] * [:c:]\n\ngoal (2 subgoals):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b\n 2. a dvd b \\<Longrightarrow> [:a:] dvd [:b:]", "thus \"[:a:] dvd [:b:]\""], ["proof (prove)\nusing this:\n  [:b:] = [:a:] * [:c:]\n\ngoal (1 subgoal):\n 1. [:a:] dvd [:b:]", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  [:b:] = [:a:] * [:c:]\n\ngoal (1 subgoal):\n 1. \\<exists>k. [:b:] = [:a:] * k", "by blast"], ["proof (state)\nthis:\n  [:a:] dvd [:b:]\n\ngoal (1 subgoal):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b", "assume \"[:a:] dvd [:b:]\""], ["proof (state)\nthis:\n  [:a:] dvd [:b:]\n\ngoal (1 subgoal):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b", "then"], ["proof (chain)\npicking this:\n  [:a:] dvd [:b:]", "obtain pc where \"[:b:] =  [:a:] * pc\""], ["proof (prove)\nusing this:\n  [:a:] dvd [:b:]\n\ngoal (1 subgoal):\n 1. (\\<And>pc.\n        [:b:] = [:a:] * pc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. [:b:] = [:a:] * k\n\ngoal (1 subgoal):\n 1. (\\<And>pc.\n        [:b:] = [:a:] * pc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [:b:] = [:a:] * pc\n\ngoal (1 subgoal):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b", "from arg_cong[OF this, of \"\\<lambda> p. coeff p 0\", unfolded coeff_mult]"], ["proof (chain)\npicking this:\n  coeff [:b:] 0 = (\\<Sum>i\\<le>0. coeff [:a:] i * coeff pc (0 - i))", "have \"b = a * coeff pc 0\""], ["proof (prove)\nusing this:\n  coeff [:b:] 0 = (\\<Sum>i\\<le>0. coeff [:a:] i * coeff pc (0 - i))\n\ngoal (1 subgoal):\n 1. b = a * coeff pc 0", "by auto"], ["proof (state)\nthis:\n  b = a * coeff pc 0\n\ngoal (1 subgoal):\n 1. [:a:] dvd [:b:] \\<Longrightarrow> a dvd b", "thus \"a dvd b\""], ["proof (prove)\nusing this:\n  b = a * coeff pc 0\n\ngoal (1 subgoal):\n 1. a dvd b", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  b = a * coeff pc 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. b = a * k", "by blast"], ["proof (state)\nthis:\n  a dvd b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_poly_dvd_1 [simp]:\n  \"[:a:] dvd 1 \\<longleftrightarrow> a dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:a:] dvd 1) = (a dvd (1::'a))", "by (metis const_poly_dvd one_poly_eq_simps(2))"], ["", "lemma poly_dvd_1:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  shows \"p dvd 1 \\<longleftrightarrow> degree p = 0 \\<and> coeff p 0 dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "proof (cases \"degree p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "with divides_degree[of p 1]"], ["proof (chain)\npicking this:\n  p dvd 1 \\<Longrightarrow> degree p \\<le> degree 1 \\<or> 1 = 0\n  degree p \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p dvd 1 \\<Longrightarrow> degree p \\<le> degree 1 \\<or> 1 = 0\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "by auto"], ["proof (state)\nthis:\n  (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "case True"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "from degree0_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a. p = [:a:]", "obtain a where p: \"p = [:a:]\""], ["proof (prove)\nusing this:\n  \\<exists>a. p = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow>\n    (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:a:] dvd 1) = (degree [:a:] = 0 \\<and> coeff [:a:] 0 dvd (1::'a))", "by auto"], ["proof (state)\nthis:\n  (p dvd 1) = (degree p = 0 \\<and> coeff p 0 dvd (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Degree based version of irreducibility.\\<close>"], ["", "definition irreducible\\<^sub>d :: \"'a :: comm_semiring_1 poly \\<Rightarrow> bool\" where\n  \"irreducible\\<^sub>d p = (degree p > 0 \\<and> (\\<forall> q r. degree q < degree p \\<longrightarrow> degree r < degree p \\<longrightarrow> p \\<noteq> q * r))\""], ["", "lemma irreducible\\<^sub>dI [intro]:\n  assumes 1: \"degree p > 0\"\n    and 2: \"\\<And>q r. degree q > 0 \\<Longrightarrow> degree q < degree p \\<Longrightarrow> degree r > 0 \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p = q * r \\<Longrightarrow> False\"\n  shows \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof (unfold irreducible\\<^sub>d_def, intro conjI allI impI notI 1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>degree q < degree p; degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>degree q < degree p; degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"degree q < degree p\" and \"degree r < degree p\" and \"p = q * r\""], ["proof (state)\nthis:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>degree q < degree p; degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with degree_mult_le[of q r]"], ["proof (chain)\npicking this:\n  degree (q * r) \\<le> degree q + degree r\n  degree q < degree p\n  degree r < degree p\n  p = q * r", "show False"], ["proof (prove)\nusing this:\n  degree (q * r) \\<le> degree q + degree r\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. False", "by (intro 2, auto)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible\\<^sub>dI2:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes deg: \"degree p > 0\" and ndvd: \"\\<And> q. degree q > 0 \\<Longrightarrow> degree q \\<le> degree p div 2 \\<Longrightarrow> \\<not> q dvd p\"\n  shows \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow> False", "from this[unfolded irreducible\\<^sub>d_def] deg"], ["proof (chain)\npicking this:\n  \\<not> (0 < degree p \\<and>\n          (\\<forall>q r.\n              degree q < degree p \\<longrightarrow>\n              degree r < degree p \\<longrightarrow> p \\<noteq> q * r))\n  0 < degree p", "obtain q r where dq: \"degree q < degree p\" and dr: \"degree r < degree p\"\n    and p: \"p = q * r\""], ["proof (prove)\nusing this:\n  \\<not> (0 < degree p \\<and>\n          (\\<forall>q r.\n              degree q < degree p \\<longrightarrow>\n              degree r < degree p \\<longrightarrow> p \\<noteq> q * r))\n  0 < degree p\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>degree q < degree p; degree r < degree p;\n         p = q * r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow> False", "from deg"], ["proof (chain)\npicking this:\n  0 < degree p", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  p = q * r\n  p \\<noteq> 0", "have \"q \\<noteq> 0\" \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = q * r\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow> False", "from degree_mult_eq[OF this] p"], ["proof (chain)\npicking this:\n  degree (q * r) = degree q + degree r\n  p = q * r", "have dp: \"degree p = degree q + degree r\""], ["proof (prove)\nusing this:\n  degree (q * r) = degree q + degree r\n  p = q * r\n\ngoal (1 subgoal):\n 1. degree p = degree q + degree r", "by simp"], ["proof (state)\nthis:\n  degree p = degree q + degree r\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"degree q \\<le> degree p div 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree q \\<le> degree p div 2 \\<Longrightarrow> False\n 2. \\<not> degree q \\<le> degree p div 2 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  degree q \\<le> degree p div 2\n\ngoal (2 subgoals):\n 1. degree q \\<le> degree p div 2 \\<Longrightarrow> False\n 2. \\<not> degree q \\<le> degree p div 2 \\<Longrightarrow> False", "from ndvd[OF _ True] dq dr dp p"], ["proof (chain)\npicking this:\n  0 < degree q \\<Longrightarrow> \\<not> q dvd p\n  degree q < degree p\n  degree r < degree p\n  degree p = degree q + degree r\n  p = q * r", "show False"], ["proof (prove)\nusing this:\n  0 < degree q \\<Longrightarrow> \\<not> q dvd p\n  degree q < degree p\n  degree r < degree p\n  degree p = degree q + degree r\n  p = q * r\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> degree q \\<le> degree p div 2 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree q \\<le> degree p div 2 \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> degree q \\<le> degree p div 2\n\ngoal (1 subgoal):\n 1. \\<not> degree q \\<le> degree p div 2 \\<Longrightarrow> False", "with dp"], ["proof (chain)\npicking this:\n  degree p = degree q + degree r\n  \\<not> degree q \\<le> degree p div 2", "have dr: \"degree r \\<le> degree p div 2\""], ["proof (prove)\nusing this:\n  degree p = degree q + degree r\n  \\<not> degree q \\<le> degree p div 2\n\ngoal (1 subgoal):\n 1. degree r \\<le> degree p div 2", "by auto"], ["proof (state)\nthis:\n  degree r \\<le> degree p div 2\n\ngoal (1 subgoal):\n 1. \\<not> degree q \\<le> degree p div 2 \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  p = q * r", "have dvd: \"r dvd p\""], ["proof (prove)\nusing this:\n  p = q * r\n\ngoal (1 subgoal):\n 1. r dvd p", "by auto"], ["proof (state)\nthis:\n  r dvd p\n\ngoal (1 subgoal):\n 1. \\<not> degree q \\<le> degree p div 2 \\<Longrightarrow> False", "from ndvd[OF _ dr] dvd dp dq"], ["proof (chain)\npicking this:\n  0 < degree r \\<Longrightarrow> \\<not> r dvd p\n  r dvd p\n  degree p = degree q + degree r\n  degree q < degree p", "show False"], ["proof (prove)\nusing this:\n  0 < degree r \\<Longrightarrow> \\<not> r dvd p\n  r dvd p\n  degree p = degree q + degree r\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reducible\\<^sub>dI:\n  assumes \"degree p > 0 \\<Longrightarrow> \\<exists>q r. degree q < degree p \\<and> degree r < degree p \\<and> p = q * r\"\n  shows \"\\<not> irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p", "using assms"], ["proof (prove)\nusing this:\n  0 < degree p \\<Longrightarrow>\n  \\<exists>q r.\n     degree q < degree p \\<and> degree r < degree p \\<and> p = q * r\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p", "by (auto simp: irreducible\\<^sub>d_def)"], ["", "lemma irreducible\\<^sub>dE [elim]:\n  assumes \"irreducible\\<^sub>d p\"\n    and \"degree p > 0 \\<Longrightarrow> (\\<And>q r. degree q < degree p \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p \\<noteq> q * r) \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d p\n  \\<lbrakk>0 < degree p;\n   \\<And>q r.\n      \\<lbrakk>degree q < degree p; degree r < degree p\\<rbrakk>\n      \\<Longrightarrow> p \\<noteq> q * r\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: irreducible\\<^sub>d_def)"], ["", "lemma reducible\\<^sub>dE [elim]:\n  assumes red: \"\\<not> irreducible\\<^sub>d p\"\n    and 1: \"degree p = 0 \\<Longrightarrow> thesis\"\n    and 2: \"\\<And>q r. degree q > 0 \\<Longrightarrow> degree q < degree p \\<Longrightarrow> degree r > 0 \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p = q * r \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using red[unfolded irreducible\\<^sub>d_def de_Morgan_conj not_not not_all not_imp]"], ["proof (prove)\nusing this:\n  \\<not> 0 < degree p \\<or>\n  (\\<exists>x xa.\n      degree x < degree p \\<and> degree xa < degree p \\<and> p = x * xa)\n\ngoal (1 subgoal):\n 1. thesis", "proof (elim disjE exE conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> 0 < degree p \\<Longrightarrow> thesis\n 2. \\<And>x xa.\n       \\<lbrakk>degree x < degree p; degree xa < degree p;\n        p = x * xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"\\<not>degree p > 0 \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 0 < degree p \\<Longrightarrow> thesis", "using 1"], ["proof (prove)\nusing this:\n  degree p = 0 \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<not> 0 < degree p \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> 0 < degree p \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>degree x < degree p; degree xa < degree p;\n        p = x * xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>degree x < degree p; degree xa < degree p;\n        p = x * xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>degree x < degree p; degree xa < degree p;\n        p = x * xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"degree q < degree p\" and \"degree r < degree p\" and \"p = q * r\""], ["proof (state)\nthis:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>degree x < degree p; degree xa < degree p;\n        p = x * xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "with degree_mult_le[of q r]"], ["proof (chain)\npicking this:\n  degree (q * r) \\<le> degree q + degree r\n  degree q < degree p\n  degree r < degree p\n  p = q * r", "show thesis"], ["proof (prove)\nusing this:\n  degree (q * r) \\<le> degree q + degree r\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. thesis", "by (intro 2, auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible\\<^sub>dD:\n  assumes \"irreducible\\<^sub>d p\"\n  shows \"degree p > 0\" \"\\<And>q r. degree q < degree p \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p \\<noteq> q * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p &&&\n    (\\<And>q r.\n        \\<lbrakk>degree q < degree p; degree r < degree p\\<rbrakk>\n        \\<Longrightarrow> p \\<noteq> q * r)", "using assms"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. 0 < degree p &&&\n    (\\<And>q r.\n        \\<lbrakk>degree q < degree p; degree r < degree p\\<rbrakk>\n        \\<Longrightarrow> p \\<noteq> q * r)", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  0 < degree p \\<and>\n  (\\<forall>q r.\n      degree q < degree p \\<longrightarrow>\n      degree r < degree p \\<longrightarrow> p \\<noteq> q * r)\n\ngoal (1 subgoal):\n 1. 0 < degree p &&&\n    (\\<And>q r.\n        \\<lbrakk>degree q < degree p; degree r < degree p\\<rbrakk>\n        \\<Longrightarrow> p \\<noteq> q * r)", "by auto"], ["", "theorem irreducible\\<^sub>d_factorization_exists:\n  assumes \"degree p > 0\"\n  shows \"\\<exists>fs. fs \\<noteq> [] \\<and> (\\<forall>f \\<in> set fs. irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and> p = prod_list fs\"\n    and \"\\<not>irreducible\\<^sub>d p \\<Longrightarrow> \\<exists>fs. length fs > 1 \\<and> (\\<forall>f \\<in> set fs. irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and> p = prod_list fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs.\n       fs \\<noteq> [] \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n       p = prod_list fs &&&\n    (\\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n     \\<exists>fs.\n        1 < length fs \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n        p = prod_list fs)", "proof (atomize(full), insert assms, induct \"degree p\" arbitrary:p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; 0 < degree pa\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>fs.\n   fs \\<noteq> [] \\<and>\n   (\\<forall>f\\<in>set fs.\n       irreducible\\<^sub>d f \\<and> degree f \\<le> degree pa) \\<and>\n   pa = prod_list fs) \\<and>\n                                     (\\<not> irreducible\\<^sub>d\n        pa \\<longrightarrow>\n(\\<exists>fs.\n    1 < length fs \\<and>\n    (\\<forall>f\\<in>set fs.\n        irreducible\\<^sub>d f \\<and> degree f < degree pa) \\<and>\n    pa = prod_list fs));\n        0 < degree p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>fs.\n                             fs \\<noteq> [] \\<and>\n                             (\\<forall>f\\<in>set fs.\n                                 irreducible\\<^sub>d f \\<and>\n                                 degree f \\<le> degree p) \\<and>\n                             p = prod_list fs) \\<and>\n                         (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n                          (\\<exists>fs.\n                              1 < length fs \\<and>\n                              (\\<forall>f\\<in>set fs.\n                                  irreducible\\<^sub>d f \\<and>\n                                  degree f < degree p) \\<and>\n                              p = prod_list fs))", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>degree ?p < degree p; 0 < degree ?p\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>fs.\n                        fs \\<noteq> [] \\<and>\n                        (\\<forall>f\\<in>set fs.\n                            irreducible\\<^sub>d f \\<and>\n                            degree f \\<le> degree ?p) \\<and>\n                        ?p = prod_list fs) \\<and>\n                    (\\<not> irreducible\\<^sub>d ?p \\<longrightarrow>\n                     (\\<exists>fs.\n                         1 < length fs \\<and>\n                         (\\<forall>f\\<in>set fs.\n                             irreducible\\<^sub>d f \\<and>\n                             degree f < degree ?p) \\<and>\n                         ?p = prod_list fs))\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; 0 < degree pa\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>fs.\n   fs \\<noteq> [] \\<and>\n   (\\<forall>f\\<in>set fs.\n       irreducible\\<^sub>d f \\<and> degree f \\<le> degree pa) \\<and>\n   pa = prod_list fs) \\<and>\n                                     (\\<not> irreducible\\<^sub>d\n        pa \\<longrightarrow>\n(\\<exists>fs.\n    1 < length fs \\<and>\n    (\\<forall>f\\<in>set fs.\n        irreducible\\<^sub>d f \\<and> degree f < degree pa) \\<and>\n    pa = prod_list fs));\n        0 < degree p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>fs.\n                             fs \\<noteq> [] \\<and>\n                             (\\<forall>f\\<in>set fs.\n                                 irreducible\\<^sub>d f \\<and>\n                                 degree f \\<le> degree p) \\<and>\n                             p = prod_list fs) \\<and>\n                         (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n                          (\\<exists>fs.\n                              1 < length fs \\<and>\n                              (\\<forall>f\\<in>set fs.\n                                  irreducible\\<^sub>d f \\<and>\n                                  degree f < degree p) \\<and>\n                              p = prod_list fs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>degree ?p < degree p; 0 < degree ?p\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>fs.\n                        fs \\<noteq> [] \\<and>\n                        (\\<forall>f\\<in>set fs.\n                            irreducible\\<^sub>d f \\<and>\n                            degree f \\<le> degree ?p) \\<and>\n                        ?p = prod_list fs) \\<and>\n                    (\\<not> irreducible\\<^sub>d ?p \\<longrightarrow>\n                     (\\<exists>fs.\n                         1 < length fs \\<and>\n                         (\\<forall>f\\<in>set fs.\n                             irreducible\\<^sub>d f \\<and>\n                             degree f < degree ?p) \\<and>\n                         ?p = prod_list fs))\n  0 < degree p", "have deg_f: \"degree p > 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>degree ?p < degree p; 0 < degree ?p\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>fs.\n                        fs \\<noteq> [] \\<and>\n                        (\\<forall>f\\<in>set fs.\n                            irreducible\\<^sub>d f \\<and>\n                            degree f \\<le> degree ?p) \\<and>\n                        ?p = prod_list fs) \\<and>\n                    (\\<not> irreducible\\<^sub>d ?p \\<longrightarrow>\n                     (\\<exists>fs.\n                         1 < length fs \\<and>\n                         (\\<forall>f\\<in>set fs.\n                             irreducible\\<^sub>d f \\<and>\n                             degree f < degree ?p) \\<and>\n                         ?p = prod_list fs))\n  0 < degree p\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; 0 < degree pa\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>fs.\n   fs \\<noteq> [] \\<and>\n   (\\<forall>f\\<in>set fs.\n       irreducible\\<^sub>d f \\<and> degree f \\<le> degree pa) \\<and>\n   pa = prod_list fs) \\<and>\n                                     (\\<not> irreducible\\<^sub>d\n        pa \\<longrightarrow>\n(\\<exists>fs.\n    1 < length fs \\<and>\n    (\\<forall>f\\<in>set fs.\n        irreducible\\<^sub>d f \\<and> degree f < degree pa) \\<and>\n    pa = prod_list fs));\n        0 < degree p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>fs.\n                             fs \\<noteq> [] \\<and>\n                             (\\<forall>f\\<in>set fs.\n                                 irreducible\\<^sub>d f \\<and>\n                                 degree f \\<le> degree p) \\<and>\n                             p = prod_list fs) \\<and>\n                         (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n                          (\\<exists>fs.\n                              1 < length fs \\<and>\n                              (\\<forall>f\\<in>set fs.\n                                  irreducible\\<^sub>d f \\<and>\n                                  degree f < degree p) \\<and>\n                              p = prod_list fs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "proof (cases \"irreducible\\<^sub>d p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "case True"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "then"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d p", "have \"set [p] \\<subseteq> Collect irreducible\\<^sub>d\" \"p = prod_list [p]\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. set [p] \\<subseteq> Collect irreducible\\<^sub>d &&& p = prod_list [p]", "by auto"], ["proof (state)\nthis:\n  set [p] \\<subseteq> Collect irreducible\\<^sub>d\n  p = prod_list [p]\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "with True"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d p\n  set [p] \\<subseteq> Collect irreducible\\<^sub>d\n  p = prod_list [p]", "show ?thesis"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d p\n  set [p] \\<subseteq> Collect irreducible\\<^sub>d\n  p = prod_list [p]\n\ngoal (1 subgoal):\n 1. (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "by (auto intro: exI[of _ \"[p]\"])"], ["proof (state)\nthis:\n  (\\<exists>fs.\n      fs \\<noteq> [] \\<and>\n      (\\<forall>f\\<in>set fs.\n          irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n      p = prod_list fs) \\<and>\n  (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n   (\\<exists>fs.\n       1 < length fs \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n       p = prod_list fs))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "case False"], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "with deg_f"], ["proof (chain)\npicking this:\n  0 < degree p\n  \\<not> irreducible\\<^sub>d p", "obtain g h\n    where deg_g: \"degree g < degree p\" \"degree g > 0\"\n      and deg_h: \"degree h < degree p\" \"degree h > 0\"\n      and f_gh: \"p = g * h\""], ["proof (prove)\nusing this:\n  0 < degree p\n  \\<not> irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>degree g < degree p; 0 < degree g; degree h < degree p;\n         0 < degree h; p = g * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree g < degree p\n  0 < degree g\n  degree h < degree p\n  0 < degree h\n  p = g * h\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "from less.hyps[OF deg_g] less.hyps[OF deg_h]"], ["proof (chain)\npicking this:\n  (\\<exists>fs.\n      fs \\<noteq> [] \\<and>\n      (\\<forall>f\\<in>set fs.\n          irreducible\\<^sub>d f \\<and> degree f \\<le> degree g) \\<and>\n      g = prod_list fs) \\<and>\n  (\\<not> irreducible\\<^sub>d g \\<longrightarrow>\n   (\\<exists>fs.\n       1 < length fs \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f < degree g) \\<and>\n       g = prod_list fs))\n  (\\<exists>fs.\n      fs \\<noteq> [] \\<and>\n      (\\<forall>f\\<in>set fs.\n          irreducible\\<^sub>d f \\<and> degree f \\<le> degree h) \\<and>\n      h = prod_list fs) \\<and>\n  (\\<not> irreducible\\<^sub>d h \\<longrightarrow>\n   (\\<exists>fs.\n       1 < length fs \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f < degree h) \\<and>\n       h = prod_list fs))", "obtain gs hs\n    where emp: \"length gs > 0\" \"length hs > 0\"\n      and \"\\<forall>f \\<in> set gs. irreducible\\<^sub>d f \\<and> degree f \\<le> degree g\" \"g = prod_list gs\"\n      and \"\\<forall>f \\<in> set hs. irreducible\\<^sub>d f \\<and> degree f \\<le> degree h\" \"h = prod_list hs\""], ["proof (prove)\nusing this:\n  (\\<exists>fs.\n      fs \\<noteq> [] \\<and>\n      (\\<forall>f\\<in>set fs.\n          irreducible\\<^sub>d f \\<and> degree f \\<le> degree g) \\<and>\n      g = prod_list fs) \\<and>\n  (\\<not> irreducible\\<^sub>d g \\<longrightarrow>\n   (\\<exists>fs.\n       1 < length fs \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f < degree g) \\<and>\n       g = prod_list fs))\n  (\\<exists>fs.\n      fs \\<noteq> [] \\<and>\n      (\\<forall>f\\<in>set fs.\n          irreducible\\<^sub>d f \\<and> degree f \\<le> degree h) \\<and>\n      h = prod_list fs) \\<and>\n  (\\<not> irreducible\\<^sub>d h \\<longrightarrow>\n   (\\<exists>fs.\n       1 < length fs \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f < degree h) \\<and>\n       h = prod_list fs))\n\ngoal (1 subgoal):\n 1. (\\<And>gs hs.\n        \\<lbrakk>0 < length gs; 0 < length hs;\n         \\<forall>f\\<in>set gs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree g;\n         g = prod_list gs;\n         \\<forall>f\\<in>set hs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree h;\n         h = prod_list hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < length gs\n  0 < length hs\n  \\<forall>f\\<in>set gs.\n     irreducible\\<^sub>d f \\<and> degree f \\<le> degree g\n  g = prod_list gs\n  \\<forall>f\\<in>set hs.\n     irreducible\\<^sub>d f \\<and> degree f \\<le> degree h\n  h = prod_list hs\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "with f_gh deg_g deg_h"], ["proof (chain)\npicking this:\n  p = g * h\n  degree g < degree p\n  0 < degree g\n  degree h < degree p\n  0 < degree h\n  0 < length gs\n  0 < length hs\n  \\<forall>f\\<in>set gs.\n     irreducible\\<^sub>d f \\<and> degree f \\<le> degree g\n  g = prod_list gs\n  \\<forall>f\\<in>set hs.\n     irreducible\\<^sub>d f \\<and> degree f \\<le> degree h\n  h = prod_list hs", "have len: \"length (gs@hs) > 1\"\n     and mem: \"\\<forall>f \\<in> set (gs@hs). irreducible\\<^sub>d f \\<and> degree f < degree p\"\n     and p: \"p = prod_list (gs@hs)\""], ["proof (prove)\nusing this:\n  p = g * h\n  degree g < degree p\n  0 < degree g\n  degree h < degree p\n  0 < degree h\n  0 < length gs\n  0 < length hs\n  \\<forall>f\\<in>set gs.\n     irreducible\\<^sub>d f \\<and> degree f \\<le> degree g\n  g = prod_list gs\n  \\<forall>f\\<in>set hs.\n     irreducible\\<^sub>d f \\<and> degree f \\<le> degree h\n  h = prod_list hs\n\ngoal (1 subgoal):\n 1. 1 < length (gs @ hs) &&&\n    \\<forall>f\\<in>set (gs @ hs).\n       irreducible\\<^sub>d f \\<and> degree f < degree p &&&\n    p = prod_list (gs @ hs)", "by (auto simp del: length_greater_0_conv)"], ["proof (state)\nthis:\n  1 < length (gs @ hs)\n  \\<forall>f\\<in>set (gs @ hs).\n     irreducible\\<^sub>d f \\<and> degree f < degree p\n  p = prod_list (gs @ hs)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "with False"], ["proof (chain)\npicking this:\n  \\<not> irreducible\\<^sub>d p\n  1 < length (gs @ hs)\n  \\<forall>f\\<in>set (gs @ hs).\n     irreducible\\<^sub>d f \\<and> degree f < degree p\n  p = prod_list (gs @ hs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> irreducible\\<^sub>d p\n  1 < length (gs @ hs)\n  \\<forall>f\\<in>set (gs @ hs).\n     irreducible\\<^sub>d f \\<and> degree f < degree p\n  p = prod_list (gs @ hs)\n\ngoal (1 subgoal):\n 1. (\\<exists>fs.\n        fs \\<noteq> [] \\<and>\n        (\\<forall>f\\<in>set fs.\n            irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n        p = prod_list fs) \\<and>\n    (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n     (\\<exists>fs.\n         1 < length fs \\<and>\n         (\\<forall>f\\<in>set fs.\n             irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n         p = prod_list fs))", "by (auto intro!: exI[of _ \"gs@hs\"] simp: less_imp_le)"], ["proof (state)\nthis:\n  (\\<exists>fs.\n      fs \\<noteq> [] \\<and>\n      (\\<forall>f\\<in>set fs.\n          irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n      p = prod_list fs) \\<and>\n  (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n   (\\<exists>fs.\n       1 < length fs \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n       p = prod_list fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>fs.\n      fs \\<noteq> [] \\<and>\n      (\\<forall>f\\<in>set fs.\n          irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n      p = prod_list fs) \\<and>\n  (\\<not> irreducible\\<^sub>d p \\<longrightarrow>\n   (\\<exists>fs.\n       1 < length fs \\<and>\n       (\\<forall>f\\<in>set fs.\n           irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n       p = prod_list fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible\\<^sub>d_factor:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"degree p > 0\"\n  shows \"\\<exists> q r. irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "using assms"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "proof (induct \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; 0 < degree pa\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q r.\n  irreducible\\<^sub>d q \\<and> pa = q * r \\<and> degree r < degree pa;\n        0 < degree p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            irreducible\\<^sub>d q \\<and>\n                            p = q * r \\<and> degree r < degree p", "case (less p)"], ["proof (state)\nthis:\n  \\<lbrakk>degree ?p < degree p; 0 < degree ?p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q r.\n                       irreducible\\<^sub>d q \\<and>\n                       ?p = q * r \\<and> degree r < degree ?p\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; 0 < degree pa\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q r.\n  irreducible\\<^sub>d q \\<and> pa = q * r \\<and> degree r < degree pa;\n        0 < degree p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            irreducible\\<^sub>d q \\<and>\n                            p = q * r \\<and> degree r < degree p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "proof (cases \"irreducible\\<^sub>d p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "case False"], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d p\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "with less(2)"], ["proof (chain)\npicking this:\n  0 < degree p\n  \\<not> irreducible\\<^sub>d p", "obtain q r\n    where q: \"degree q < degree p\" \"degree q > 0\"\n      and r: \"degree r < degree p\" \"degree r > 0\"\n      and p: \"p = q * r\""], ["proof (prove)\nusing this:\n  0 < degree p\n  \\<not> irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>degree q < degree p; 0 < degree q; degree r < degree p;\n         0 < degree r; p = q * r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree q < degree p\n  0 < degree q\n  degree r < degree p\n  0 < degree r\n  p = q * r\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "from less(1)[OF q]"], ["proof (chain)\npicking this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q", "obtain s t where IH: \"irreducible\\<^sub>d s\" \"q = s * t\""], ["proof (prove)\nusing this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q\n\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>irreducible\\<^sub>d s; q = s * t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d s\n  q = s * t\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "from p"], ["proof (chain)\npicking this:\n  p = q * r", "have p: \"p = s * (t * r)\""], ["proof (prove)\nusing this:\n  p = q * r\n\ngoal (1 subgoal):\n 1. p = s * (t * r)", "unfolding IH"], ["proof (prove)\nusing this:\n  p = s * t * r\n\ngoal (1 subgoal):\n 1. p = s * (t * r)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  p = s * (t * r)\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "from less(2)"], ["proof (chain)\npicking this:\n  0 < degree p", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "hence \"degree p = degree s + (degree (t * r))\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = degree s + degree (t * r)", "unfolding p"], ["proof (prove)\nusing this:\n  s * (t * r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (s * (t * r)) = degree s + degree (t * r)", "by (subst degree_mult_eq, insert p, auto)"], ["proof (state)\nthis:\n  degree p = degree s + degree (t * r)\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "with irreducible\\<^sub>dD[OF IH(1)]"], ["proof (chain)\npicking this:\n  0 < degree s\n  \\<lbrakk>degree ?q < degree s; degree ?r < degree s\\<rbrakk>\n  \\<Longrightarrow> s \\<noteq> ?q * ?r\n  degree p = degree s + degree (t * r)", "have \"degree p > degree (t * r)\""], ["proof (prove)\nusing this:\n  0 < degree s\n  \\<lbrakk>degree ?q < degree s; degree ?r < degree s\\<rbrakk>\n  \\<Longrightarrow> s \\<noteq> ?q * ?r\n  degree p = degree s + degree (t * r)\n\ngoal (1 subgoal):\n 1. degree (t * r) < degree p", "by auto"], ["proof (state)\nthis:\n  degree (t * r) < degree p\n\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n 2. \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "with p IH"], ["proof (chain)\npicking this:\n  p = s * (t * r)\n  irreducible\\<^sub>d s\n  q = s * t\n  degree (t * r) < degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  p = s * (t * r)\n  irreducible\\<^sub>d s\n  q = s * t\n  degree (t * r) < degree p\n\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "by auto"], ["proof (state)\nthis:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "case True"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "by (rule exI[of _ p], rule exI[of _ 1], insert True less(2), auto)"], ["proof (state)\nthis:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "context mult_zero begin"], ["", "(* least class with times and zero *)"], ["", "definition zero_divisor where \"zero_divisor a \\<equiv> \\<exists>b. b \\<noteq> 0 \\<and> a * b = 0\""], ["", "lemma zero_divisorI[intro]:\n  assumes \"b \\<noteq> 0\" and \"a * b = 0\" shows \"zero_divisor a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_divisor a", "using assms"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  a * b = (0::'a)\n\ngoal (1 subgoal):\n 1. zero_divisor a", "by (auto simp: zero_divisor_def)"], ["", "lemma zero_divisorE[elim]:\n  assumes \"zero_divisor a\"\n    and \"\\<And>b. b \\<noteq> 0 \\<Longrightarrow> a * b = 0 \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  zero_divisor a\n  \\<lbrakk>?b \\<noteq> (0::'a); a * ?b = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: zero_divisor_def)"], ["", "end"], ["", "lemma zero_divisor_0[simp]:\n  \"zero_divisor (0::'a::{mult_zero,zero_neq_one})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_divisor (0::'a)", "(* No need for one! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_divisor (0::'a)", "by (auto intro!: zero_divisorI[of 1])"], ["", "lemma not_zero_divisor_1:\n  \"\\<not> zero_divisor (1 :: 'a :: {monoid_mult,mult_zero})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> zero_divisor (1::'a)", "(* No need for associativity! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> zero_divisor (1::'a)", "by auto"], ["", "lemma zero_divisor_iff_eq_0[simp]:\n  fixes a :: \"'a :: {semiring_no_zero_divisors, zero_neq_one}\"\n  shows \"zero_divisor a \\<longleftrightarrow> a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_divisor a = (a = (0::'a))", "by auto"], ["", "lemma mult_eq_0_not_zero_divisor_left[simp]:\n  fixes a b :: \"'a :: mult_zero\"\n  assumes \"\\<not> zero_divisor a\"\n  shows \"a * b = 0 \\<longleftrightarrow> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * b = (0::'a)) = (b = (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> zero_divisor a\n\ngoal (1 subgoal):\n 1. (a * b = (0::'a)) = (b = (0::'a))", "unfolding zero_divisor_def"], ["proof (prove)\nusing this:\n  \\<nexists>b. b \\<noteq> (0::'a) \\<and> a * b = (0::'a)\n\ngoal (1 subgoal):\n 1. (a * b = (0::'a)) = (b = (0::'a))", "by force"], ["", "lemma mult_eq_0_not_zero_divisor_right[simp]:\n  fixes a b :: \"'a :: {ab_semigroup_mult,mult_zero}\" (* No need for associativity! *)\n  assumes \"\\<not> zero_divisor b\"\n  shows \"a * b = 0 \\<longleftrightarrow> a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * b = (0::'a)) = (a = (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> zero_divisor b\n\ngoal (1 subgoal):\n 1. (a * b = (0::'a)) = (a = (0::'a))", "unfolding zero_divisor_def"], ["proof (prove)\nusing this:\n  \\<nexists>ba. ba \\<noteq> (0::'a) \\<and> b * ba = (0::'a)\n\ngoal (1 subgoal):\n 1. (a * b = (0::'a)) = (a = (0::'a))", "by (force simp: ac_simps)"], ["", "lemma degree_smult_not_zero_divisor_left[simp]:\n  assumes \"\\<not> zero_divisor c\"\n  shows \"degree (smult c p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (smult c p) = degree p", "proof(cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree (smult c p) = degree p\n 2. p \\<noteq> 0 \\<Longrightarrow> degree (smult c p) = degree p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree (smult c p) = degree p\n 2. p \\<noteq> 0 \\<Longrightarrow> degree (smult c p) = degree p", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"coeff (smult c p) (degree p) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff (smult c p) (degree p) \\<noteq> (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<not> zero_divisor c\n\ngoal (1 subgoal):\n 1. coeff (smult c p) (degree p) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  coeff (smult c p) (degree p) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree (smult c p) = degree p\n 2. p \\<noteq> 0 \\<Longrightarrow> degree (smult c p) = degree p", "from le_degree[OF this] degree_smult_le[of c p]"], ["proof (chain)\npicking this:\n  degree p \\<le> degree (smult c p)\n  degree (smult c p) \\<le> degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p \\<le> degree (smult c p)\n  degree (smult c p) \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree (smult c p) = degree p", "by auto"], ["proof (state)\nthis:\n  degree (smult c p) = degree p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> degree (smult c p) = degree p", "qed auto"], ["", "lemma degree_smult_not_zero_divisor_right[simp]:\n  assumes \"\\<not> zero_divisor (lead_coeff p)\"\n  shows \"degree (smult c p) = (if c = 0 then 0 else degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (smult c p) = (if c = (0::'a) then 0 else degree p)", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow>\n    degree (smult c p) = (if c = (0::'a) then 0 else degree p)\n 2. c \\<noteq> (0::'a) \\<Longrightarrow>\n    degree (smult c p) = (if c = (0::'a) then 0 else degree p)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow>\n    degree (smult c p) = (if c = (0::'a) then 0 else degree p)\n 2. c \\<noteq> (0::'a) \\<Longrightarrow>\n    degree (smult c p) = (if c = (0::'a) then 0 else degree p)", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "have \"coeff (smult c p) (degree p) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (smult c p) (degree p) \\<noteq> (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  \\<not> zero_divisor (lead_coeff p)\n\ngoal (1 subgoal):\n 1. coeff (smult c p) (degree p) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  coeff (smult c p) (degree p) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow>\n    degree (smult c p) = (if c = (0::'a) then 0 else degree p)\n 2. c \\<noteq> (0::'a) \\<Longrightarrow>\n    degree (smult c p) = (if c = (0::'a) then 0 else degree p)", "from le_degree[OF this] degree_smult_le[of c p]"], ["proof (chain)\npicking this:\n  degree p \\<le> degree (smult c p)\n  degree (smult c p) \\<le> degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p \\<le> degree (smult c p)\n  degree (smult c p) \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree (smult c p) = (if c = (0::'a) then 0 else degree p)", "by auto"], ["proof (state)\nthis:\n  degree (smult c p) = (if c = (0::'a) then 0 else degree p)\n\ngoal (1 subgoal):\n 1. c = (0::'a) \\<Longrightarrow>\n    degree (smult c p) = (if c = (0::'a) then 0 else degree p)", "qed auto"], ["", "lemma irreducible\\<^sub>d_smult_not_zero_divisor_left:\n  assumes c0: \"\\<not> zero_divisor c\"\n  assumes L: \"irreducible\\<^sub>d (smult c p)\"\n  shows \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof (intro irreducible\\<^sub>dI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from L"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (smult c p)", "have \"degree (smult c p) > 0\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (smult c p)\n\ngoal (1 subgoal):\n 1. 0 < degree (smult c p)", "by auto"], ["proof (state)\nthis:\n  0 < degree (smult c p)\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 < degree (smult c p)\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "note degree_smult_le"], ["proof (state)\nthis:\n  degree (smult ?a ?p) \\<le> degree ?p\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 < degree p", "show \"degree p > 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg_q: \"degree q < degree p\"\n    and deg_r: \"degree r < degree p\"\n    and p_qr: \"p = q * r\""], ["proof (state)\nthis:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  degree q < degree p\n  degree r < degree p\n  p = q * r", "have 1: \"smult c p = smult c q * r\""], ["proof (prove)\nusing this:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. smult c p = smult c q * r", "by auto"], ["proof (state)\nthis:\n  smult c p = smult c q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "note degree_smult_le[of c q]"], ["proof (state)\nthis:\n  degree (smult c q) \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (smult c q) \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "note deg_q"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (smult c q) < degree p", "have 2: \"degree (smult c q) < degree (smult c p)\""], ["proof (prove)\nusing this:\n  degree (smult c q) < degree p\n\ngoal (1 subgoal):\n 1. degree (smult c q) < degree (smult c p)", "using c0"], ["proof (prove)\nusing this:\n  degree (smult c q) < degree p\n  \\<not> zero_divisor c\n\ngoal (1 subgoal):\n 1. degree (smult c q) < degree (smult c p)", "by auto"], ["proof (state)\nthis:\n  degree (smult c q) < degree (smult c p)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from deg_r"], ["proof (chain)\npicking this:\n  degree r < degree p", "have 3: \"degree r < \\<dots>\""], ["proof (prove)\nusing this:\n  degree r < degree p\n\ngoal (1 subgoal):\n 1. degree r < degree (smult c p)", "using c0"], ["proof (prove)\nusing this:\n  degree r < degree p\n  \\<not> zero_divisor c\n\ngoal (1 subgoal):\n 1. degree r < degree (smult c p)", "by auto"], ["proof (state)\nthis:\n  degree r < degree (smult c p)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible\\<^sub>dD(2)[OF L 2 3] 1"], ["proof (chain)\npicking this:\n  smult c p \\<noteq> smult c q * r\n  smult c p = smult c q * r", "show False"], ["proof (prove)\nusing this:\n  smult c p \\<noteq> smult c q * r\n  smult c p = smult c q * r\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas irreducible\\<^sub>d_smultI =\n  irreducible\\<^sub>d_smult_not_zero_divisor_left\n  [where 'a = \"'a :: {comm_semiring_1,semiring_no_zero_divisors}\", simplified]"], ["", "lemma irreducible\\<^sub>d_smult_not_zero_divisor_right:\n  assumes p0: \"\\<not> zero_divisor (lead_coeff p)\" and L: \"irreducible\\<^sub>d (smult c p)\"\n  shows \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "from L"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (smult c p)", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (smult c p)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "with p0"], ["proof (chain)\npicking this:\n  \\<not> zero_divisor (lead_coeff p)\n  c \\<noteq> (0::'a)", "have [simp]: \"degree (smult c p) = degree p\""], ["proof (prove)\nusing this:\n  \\<not> zero_divisor (lead_coeff p)\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree (smult c p) = degree p", "by simp"], ["proof (state)\nthis:\n  degree (smult c p) = degree p\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "show \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof (intro iffI irreducible\\<^sub>dI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from L"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (smult c p)", "show \"degree p > 0\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (smult c p)\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg_q: \"degree q < degree p\"\n      and deg_r: \"degree r < degree p\"\n      and p_qr: \"p = q * r\""], ["proof (state)\nthis:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  degree q < degree p\n  degree r < degree p\n  p = q * r", "have 1: \"smult c p = smult c q * r\""], ["proof (prove)\nusing this:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. smult c p = smult c q * r", "by auto"], ["proof (state)\nthis:\n  smult c p = smult c q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "note degree_smult_le[of c q]"], ["proof (state)\nthis:\n  degree (smult c q) \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (smult c q) \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "note deg_q"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (smult c q) < degree p", "have 2: \"degree (smult c q) < degree (smult c p)\""], ["proof (prove)\nusing this:\n  degree (smult c q) < degree p\n\ngoal (1 subgoal):\n 1. degree (smult c q) < degree (smult c p)", "by simp"], ["proof (state)\nthis:\n  degree (smult c q) < degree (smult c p)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from deg_r"], ["proof (chain)\npicking this:\n  degree r < degree p", "have 3: \"degree r < \\<dots>\""], ["proof (prove)\nusing this:\n  degree r < degree p\n\ngoal (1 subgoal):\n 1. degree r < degree (smult c p)", "by simp"], ["proof (state)\nthis:\n  degree r < degree (smult c p)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible\\<^sub>dD(2)[OF L 2 3] 1"], ["proof (chain)\npicking this:\n  smult c p \\<noteq> smult c q * r\n  smult c p = smult c q * r", "show False"], ["proof (prove)\nusing this:\n  smult c p \\<noteq> smult c q * r\n  smult c p = smult c q * r\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_divisor_mult_left:\n  fixes a b :: \"'a :: {ab_semigroup_mult, mult_zero}\"\n  assumes \"zero_divisor a\"\n  shows \"zero_divisor (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "from assms"], ["proof (chain)\npicking this:\n  zero_divisor a", "obtain c where c0: \"c \\<noteq> 0\" and [simp]: \"a * c = 0\""], ["proof (prove)\nusing this:\n  zero_divisor a\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> (0::'a); a * c = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  a * c = (0::'a)\n\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "have \"a * b * c = a * c * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * c * b", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  a * b * c = a * c * b\n\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "with c0"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  a * b * c = a * c * b", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  a * b * c = a * c * b\n\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "by auto"], ["proof (state)\nthis:\n  zero_divisor (a * b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_divisor_mult_right:\n  fixes a b :: \"'a :: {semigroup_mult, mult_zero}\"\n  assumes \"zero_divisor b\"\n  shows \"zero_divisor (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "from assms"], ["proof (chain)\npicking this:\n  zero_divisor b", "obtain c where c0: \"c \\<noteq> 0\" and [simp]: \"b * c = 0\""], ["proof (prove)\nusing this:\n  zero_divisor b\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> (0::'a); b * c = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  b * c = (0::'a)\n\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "have \"a * b * c = a * (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  a * b * c = a * (b * c)\n\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "with c0"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  a * b * c = a * (b * c)", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  a * b * c = a * (b * c)\n\ngoal (1 subgoal):\n 1. zero_divisor (a * b)", "by auto"], ["proof (state)\nthis:\n  zero_divisor (a * b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_zero_divisor_mult:\n  fixes a b :: \"'a :: {ab_semigroup_mult, mult_zero}\"\n  assumes \"\\<not> zero_divisor (a * b)\"\n  shows \"\\<not> zero_divisor a\" and \"\\<not> zero_divisor b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> zero_divisor a &&& \\<not> zero_divisor b", "using assms"], ["proof (prove)\nusing this:\n  \\<not> zero_divisor (a * b)\n\ngoal (1 subgoal):\n 1. \\<not> zero_divisor a &&& \\<not> zero_divisor b", "by (auto dest: zero_divisor_mult_right zero_divisor_mult_left)"], ["", "lemma zero_divisor_smult_left:\n  assumes \"zero_divisor a\"\n  shows \"zero_divisor (smult a f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_divisor (smult a f)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. zero_divisor (smult a f)", "from assms"], ["proof (chain)\npicking this:\n  zero_divisor a", "obtain b where b0: \"b \\<noteq> 0\" and \"a * b = 0\""], ["proof (prove)\nusing this:\n  zero_divisor a\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<noteq> (0::'a); a * b = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n  a * b = (0::'a)\n\ngoal (1 subgoal):\n 1. zero_divisor (smult a f)", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> (0::'a)\n  a * b = (0::'a)", "have \"smult a f * [:b:] = 0\""], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  a * b = (0::'a)\n\ngoal (1 subgoal):\n 1. smult a f * [:b:] = 0", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  smult a f * [:b:] = 0\n\ngoal (1 subgoal):\n 1. zero_divisor (smult a f)", "with b0"], ["proof (chain)\npicking this:\n  b \\<noteq> (0::'a)\n  smult a f * [:b:] = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  smult a f * [:b:] = 0\n\ngoal (1 subgoal):\n 1. zero_divisor (smult a f)", "by (auto intro!: zero_divisorI[of \"[:b:]\"])"], ["proof (state)\nthis:\n  zero_divisor (smult a f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unit_not_zero_divisor:\n  fixes a :: \"'a :: {comm_monoid_mult, mult_zero}\"\n  assumes \"a dvd 1\"\n  shows \"\\<not>zero_divisor a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> zero_divisor a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. zero_divisor a \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  a dvd (1::'a)", "obtain b where ab: \"1 = a * b\""], ["proof (prove)\nusing this:\n  a dvd (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>b. (1::'a) = a * b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  (1::'a) = a * b\n\ngoal (1 subgoal):\n 1. zero_divisor a \\<Longrightarrow> False", "assume \"zero_divisor a\""], ["proof (state)\nthis:\n  zero_divisor a\n\ngoal (1 subgoal):\n 1. zero_divisor a \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  zero_divisor a", "have \"zero_divisor (1::'a)\""], ["proof (prove)\nusing this:\n  zero_divisor a\n\ngoal (1 subgoal):\n 1. zero_divisor (1::'a)", "by (unfold ab, intro zero_divisor_mult_left)"], ["proof (state)\nthis:\n  zero_divisor (1::'a)\n\ngoal (1 subgoal):\n 1. zero_divisor a \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  zero_divisor (1::'a)", "show False"], ["proof (prove)\nusing this:\n  zero_divisor (1::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_irreducible\\<^sub>d: assumes \"degree p = 1\"\n  shows \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by (rule irreducible\\<^sub>dI, insert assms, auto)"], ["", "lemma irreducible\\<^sub>d_dvd_smult:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"degree p > 0\" \"irreducible\\<^sub>d q\" \"p dvd q\"\n  shows \"\\<exists> c. c \\<noteq> 0 \\<and> q = smult c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "from assms"], ["proof (chain)\npicking this:\n  0 < degree p\n  irreducible\\<^sub>d q\n  p dvd q", "obtain r where q: \"q = p * r\""], ["proof (prove)\nusing this:\n  0 < degree p\n  irreducible\\<^sub>d q\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>r. q = p * r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  q = p * r\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "from degree_mult_eq[of p r] assms(1) q"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<noteq> 0; r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree (p * r) = degree p + degree r\n  0 < degree p\n  q = p * r", "have \"\\<not> degree p < degree q\" and nz: \"p \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree (p * r) = degree p + degree r\n  0 < degree p\n  q = p * r\n\ngoal (1 subgoal):\n 1. \\<not> degree p < degree q &&& p \\<noteq> 0 &&& q \\<noteq> 0", "apply (metis assms(2) degree_mult_eq_0 gr_implies_not_zero irreducible\\<^sub>dD(2) less_add_same_cancel2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. q \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  0 < degree p\n  irreducible\\<^sub>d q\n  p dvd q\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<not> degree p < degree q\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "hence deg: \"degree p \\<ge> degree q\""], ["proof (prove)\nusing this:\n  \\<not> degree p < degree q\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree q \\<le> degree p", "by auto"], ["proof (state)\nthis:\n  degree q \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "from \\<open>p dvd q\\<close>"], ["proof (chain)\npicking this:\n  p dvd q", "obtain k where q: \"q = k * p\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = k * p \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. q = p * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = k * p \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  q = k * p\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "with nz"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  q = k * p", "have \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  q = k * p\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "from deg[unfolded q degree_mult_eq[OF \\<open>k \\<noteq> 0\\<close> \\<open>p \\<noteq> 0\\<close> ]]"], ["proof (chain)\npicking this:\n  degree k + degree p \\<le> degree p", "have \"degree k = 0\""], ["proof (prove)\nusing this:\n  degree k + degree p \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree k = 0", "unfolding q"], ["proof (prove)\nusing this:\n  degree k + degree p \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree k = 0", "by auto"], ["proof (state)\nthis:\n  degree k = 0\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "then"], ["proof (chain)\npicking this:\n  degree k = 0", "obtain c where k: \"k = [: c :]\""], ["proof (prove)\nusing this:\n  degree k = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c. k = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis degree_0_id)"], ["proof (state)\nthis:\n  k = [:c:]\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "with \\<open>k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k = [:c:]", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k = [:c:]\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "have \"q = smult c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = smult c p", "unfolding q k"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] * p = smult c p", "by simp"], ["proof (state)\nthis:\n  q = smult c p\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  q = smult c p", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  q = smult c p\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p", "by auto"], ["proof (state)\nthis:\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> q = smult c p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Map over Polynomial Coefficients\\<close>"], ["", "lemma map_poly_simps:\n  shows \"map_poly f (pCons c p) =\n    (if c = 0 \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n 2. c \\<noteq> (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "case True"], ["proof (state)\nthis:\n  c = (0::'b)\n\ngoal (2 subgoals):\n 1. c = (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n 2. c \\<noteq> (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "note c0 = this"], ["proof (state)\nthis:\n  c = (0::'b)\n\ngoal (2 subgoals):\n 1. c = (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n 2. c \\<noteq> (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "using c0"], ["proof (prove)\nusing this:\n  p = 0\n  c = (0::'b)\n\ngoal (1 subgoal):\n 1. map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "unfolding map_poly_def"], ["proof (prove)\nusing this:\n  p = 0\n  c = (0::'b)\n\ngoal (1 subgoal):\n 1. Poly (map f (coeffs (pCons c p))) =\n    (if c = (0::'b) \\<and> p = 0 then 0\n     else pCons (f c) (Poly (map f (coeffs p))))", "by simp"], ["proof (state)\nthis:\n  map_poly f (pCons c p) =\n  (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "unfolding map_poly_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Poly (map f (coeffs (pCons c p))) =\n    (if c = (0::'b) \\<and> p = 0 then 0\n     else pCons (f c) (Poly (map f (coeffs p))))", "by auto"], ["proof (state)\nthis:\n  map_poly f (pCons c p) =\n  (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_poly f (pCons c p) =\n  (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "case False"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow>\n    map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "thus ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. map_poly f (pCons c p) =\n    (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))", "unfolding map_poly_def"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. Poly (map f (coeffs (pCons c p))) =\n    (if c = (0::'b) \\<and> p = 0 then 0\n     else pCons (f c) (Poly (map f (coeffs p))))", "by auto"], ["proof (state)\nthis:\n  map_poly f (pCons c p) =\n  (if c = (0::'b) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_pCons[simp]:\n  assumes \"c \\<noteq> 0 \\<or> p \\<noteq> 0\"\n  shows \"map_poly f (pCons c p) = pCons (f c) (map_poly f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (pCons c p) = pCons (f c) (map_poly f p)", "unfolding map_poly_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if c = (0::'a) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p)) =\n    pCons (f c) (map_poly f p)", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if c = (0::'a) \\<and> p = 0 then 0 else pCons (f c) (map_poly f p)) =\n    pCons (f c) (map_poly f p)", "by auto"], ["", "lemma map_poly_map_poly:\n  assumes f0: \"f 0 = 0\"\n  shows \"map_poly f (map_poly g p) = map_poly (f \\<circ> g) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (map_poly g p) = map_poly (f \\<circ> g) p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_poly f (map_poly g 0) = map_poly (f \\<circ> g) 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'c) \\<or> p \\<noteq> 0;\n        map_poly f (map_poly g p) = map_poly (f \\<circ> g) p\\<rbrakk>\n       \\<Longrightarrow> map_poly f (map_poly g (pCons a p)) =\n                         map_poly (f \\<circ> g) (pCons a p)", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'c) \\<or> p \\<noteq> 0\n  map_poly f (map_poly g p) = map_poly (f \\<circ> g) p\n\ngoal (2 subgoals):\n 1. map_poly f (map_poly g 0) = map_poly (f \\<circ> g) 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'c) \\<or> p \\<noteq> 0;\n        map_poly f (map_poly g p) = map_poly (f \\<circ> g) p\\<rbrakk>\n       \\<Longrightarrow> map_poly f (map_poly g (pCons a p)) =\n                         map_poly (f \\<circ> g) (pCons a p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "proof(cases \"g a \\<noteq> 0 \\<or> map_poly g p \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0 \\<Longrightarrow>\n    map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)\n 2. \\<not> (g a \\<noteq> (0::'b) \\<or>\n            map_poly g p \\<noteq> 0) \\<Longrightarrow>\n    map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "case True"], ["proof (state)\nthis:\n  g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0 \\<Longrightarrow>\n    map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)\n 2. \\<not> (g a \\<noteq> (0::'b) \\<or>\n            map_poly g p \\<noteq> 0) \\<Longrightarrow>\n    map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "unfolding map_poly_pCons[OF pCons(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (pCons (g a) (map_poly g p)) =\n    pCons ((f \\<circ> g) a) (map_poly (f \\<circ> g) p)", "unfolding map_poly_pCons[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons (f (g a)) (map_poly f (map_poly g p)) =\n    pCons ((f \\<circ> g) a) (map_poly (f \\<circ> g) p)", "unfolding pCons(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons (f (g a)) (map_poly (f \\<circ> g) p) =\n    pCons ((f \\<circ> g) a) (map_poly (f \\<circ> g) p)", "by simp"], ["proof (state)\nthis:\n  map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)\n\ngoal (1 subgoal):\n 1. \\<not> (g a \\<noteq> (0::'b) \\<or>\n            map_poly g p \\<noteq> 0) \\<Longrightarrow>\n    map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (g a \\<noteq> (0::'b) \\<or>\n            map_poly g p \\<noteq> 0) \\<Longrightarrow>\n    map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "case False"], ["proof (state)\nthis:\n  \\<not> (g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (g a \\<noteq> (0::'b) \\<or>\n            map_poly g p \\<noteq> 0) \\<Longrightarrow>\n    map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "then"], ["proof (chain)\npicking this:\n  \\<not> (g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)", "unfolding map_poly_pCons[OF pCons(1)]"], ["proof (prove)\nusing this:\n  \\<not> (g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. map_poly f (pCons (g a) (map_poly g p)) =\n    pCons ((f \\<circ> g) a) (map_poly (f \\<circ> g) p)", "unfolding pCons(2)[symmetric]"], ["proof (prove)\nusing this:\n  \\<not> (g a \\<noteq> (0::'b) \\<or> map_poly g p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. map_poly f (pCons (g a) (map_poly g p)) =\n    pCons ((f \\<circ> g) a) (map_poly f (map_poly g p))", "by (simp add: f0)"], ["proof (state)\nthis:\n  map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_poly f (map_poly g (pCons a p)) = map_poly (f \\<circ> g) (pCons a p)\n\ngoal (1 subgoal):\n 1. map_poly f (map_poly g 0) = map_poly (f \\<circ> g) 0", "qed simp"], ["", "lemma map_poly_zero:\n  assumes f: \"\\<forall>c. f c = 0 \\<longrightarrow> c = 0\"\n  shows [simp]: \"map_poly f p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_poly f p = 0) = (p = 0)", "by (induct p; auto simp: map_poly_simps f)"], ["", "lemma map_poly_add:\n  assumes h0: \"h 0 = 0\"\n      and h_add: \"\\<forall>p q. h (p + q) = h p + h q\"\n  shows \"map_poly h (p + q) = map_poly h p + map_poly h q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (p + q) = map_poly h p + map_poly h q", "proof (induct p arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. map_poly h (0 + q) = map_poly h 0 + map_poly h q\n 2. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        \\<And>q. map_poly h (p + q) = map_poly h p + map_poly h q\\<rbrakk>\n       \\<Longrightarrow> map_poly h (pCons a p + q) =\n                         map_poly h (pCons a p) + map_poly h q", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'b) \\<or> p \\<noteq> 0\n  map_poly h (p + ?q) = map_poly h p + map_poly h ?q\n\ngoal (2 subgoals):\n 1. \\<And>q. map_poly h (0 + q) = map_poly h 0 + map_poly h q\n 2. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        \\<And>q. map_poly h (p + q) = map_poly h p + map_poly h q\\<rbrakk>\n       \\<Longrightarrow> map_poly h (pCons a p + q) =\n                         map_poly h (pCons a p) + map_poly h q", "note pIH = this"], ["proof (state)\nthis:\n  a \\<noteq> (0::'b) \\<or> p \\<noteq> 0\n  map_poly h (p + ?q) = map_poly h p + map_poly h ?q\n\ngoal (2 subgoals):\n 1. \\<And>q. map_poly h (0 + q) = map_poly h 0 + map_poly h q\n 2. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        \\<And>q. map_poly h (p + q) = map_poly h p + map_poly h q\\<rbrakk>\n       \\<Longrightarrow> map_poly h (pCons a p + q) =\n                         map_poly h (pCons a p) + map_poly h q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (pCons a p + q) = map_poly h (pCons a p) + map_poly h q", "proof(induct \"q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_poly h (pCons a p + 0) = map_poly h (pCons a p) + map_poly h 0\n 2. \\<And>aa q.\n       \\<lbrakk>aa \\<noteq> (0::'b) \\<or> q \\<noteq> 0;\n        map_poly h (pCons a p + q) =\n        map_poly h (pCons a p) + map_poly h q\\<rbrakk>\n       \\<Longrightarrow> map_poly h (pCons a p + pCons aa q) =\n                         map_poly h (pCons a p) + map_poly h (pCons aa q)", "case (pCons b q)"], ["proof (state)\nthis:\n  b \\<noteq> (0::'b) \\<or> q \\<noteq> 0\n  map_poly h (pCons a p + q) = map_poly h (pCons a p) + map_poly h q\n\ngoal (2 subgoals):\n 1. map_poly h (pCons a p + 0) = map_poly h (pCons a p) + map_poly h 0\n 2. \\<And>aa q.\n       \\<lbrakk>aa \\<noteq> (0::'b) \\<or> q \\<noteq> 0;\n        map_poly h (pCons a p + q) =\n        map_poly h (pCons a p) + map_poly h q\\<rbrakk>\n       \\<Longrightarrow> map_poly h (pCons a p + pCons aa q) =\n                         map_poly h (pCons a p) + map_poly h (pCons aa q)", "note qIH = this"], ["proof (state)\nthis:\n  b \\<noteq> (0::'b) \\<or> q \\<noteq> 0\n  map_poly h (pCons a p + q) = map_poly h (pCons a p) + map_poly h q\n\ngoal (2 subgoals):\n 1. map_poly h (pCons a p + 0) = map_poly h (pCons a p) + map_poly h 0\n 2. \\<And>aa q.\n       \\<lbrakk>aa \\<noteq> (0::'b) \\<or> q \\<noteq> 0;\n        map_poly h (pCons a p + q) =\n        map_poly h (pCons a p) + map_poly h q\\<rbrakk>\n       \\<Longrightarrow> map_poly h (pCons a p + pCons aa q) =\n                         map_poly h (pCons a p) + map_poly h (pCons aa q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (pCons a p + pCons b q) =\n    map_poly h (pCons a p) + map_poly h (pCons b q)", "unfolding map_poly_pCons[OF qIH(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (pCons a p + pCons b q) =\n    map_poly h (pCons a p) + pCons (h b) (map_poly h q)", "unfolding map_poly_pCons[OF pIH(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (pCons a p + pCons b q) =\n    pCons (h a) (map_poly h p) + pCons (h b) (map_poly h q)", "unfolding add_pCons"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (pCons (a + b) (p + q)) =\n    pCons (h a + h b) (map_poly h p + map_poly h q)", "unfolding pIH(2)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (pCons (a + b) (p + q)) =\n    pCons (h a + h b) (map_poly h (p + q))", "unfolding h_add[rule_format,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly h (pCons (a + b) (p + q)) =\n    pCons (h (a + b)) (map_poly h (p + q))", "unfolding map_poly_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a + b = (0::'b) \\<and> p + q = 0 then 0\n     else pCons (h (a + b)) (map_poly h (p + q))) =\n    pCons (h (a + b)) (map_poly h (p + q))", "using h0"], ["proof (prove)\nusing this:\n  h (0::'b) = (0::'a)\n\ngoal (1 subgoal):\n 1. (if a + b = (0::'b) \\<and> p + q = 0 then 0\n     else pCons (h (a + b)) (map_poly h (p + q))) =\n    pCons (h (a + b)) (map_poly h (p + q))", "by auto"], ["proof (state)\nthis:\n  map_poly h (pCons a p + pCons b q) =\n  map_poly h (pCons a p) + map_poly h (pCons b q)\n\ngoal (1 subgoal):\n 1. map_poly h (pCons a p + 0) = map_poly h (pCons a p) + map_poly h 0", "qed auto"], ["proof (state)\nthis:\n  map_poly h (pCons a p + q) = map_poly h (pCons a p) + map_poly h q\n\ngoal (1 subgoal):\n 1. \\<And>q. map_poly h (0 + q) = map_poly h 0 + map_poly h q", "qed auto"], ["", "subsection \\<open>Morphismic properties of @{term \"pCons 0\"}\\<close>"], ["", "lemma monom_pCons_0_monom:\n  \"monom (pCons 0 (monom a n)) d = map_poly (pCons 0) (monom (monom a n) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (pCons (0::'a) (monom a n)) d =\n    map_poly (pCons (0::'a)) (monom (monom a n) d)", "apply (induct d)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monom (pCons (0::'a) (monom a n)) 0 =\n    map_poly (pCons (0::'a)) (monom (monom a n) 0)\n 2. \\<And>d.\n       monom (pCons (0::'a) (monom a n)) d =\n       map_poly (pCons (0::'a)) (monom (monom a n) d) \\<Longrightarrow>\n       monom (pCons (0::'a) (monom a n)) (Suc d) =\n       map_poly (pCons (0::'a)) (monom (monom a n) (Suc d))", "unfolding monom_0"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:pCons (0::'a) (monom a n):] = map_poly (pCons (0::'a)) [:monom a n:]\n 2. \\<And>d.\n       monom (pCons (0::'a) (monom a n)) d =\n       map_poly (pCons (0::'a)) (monom (monom a n) d) \\<Longrightarrow>\n       monom (pCons (0::'a) (monom a n)) (Suc d) =\n       map_poly (pCons (0::'a)) (monom (monom a n) (Suc d))", "unfolding map_poly_simps"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:pCons (0::'a) (monom a n):] =\n    (if monom a n = 0 \\<and> 0 = 0 then 0\n     else pCons (pCons (0::'a) (monom a n)) (map_poly (pCons (0::'a)) 0))\n 2. \\<And>d.\n       monom (pCons (0::'a) (monom a n)) d =\n       map_poly (pCons (0::'a)) (monom (monom a n) d) \\<Longrightarrow>\n       monom (pCons (0::'a) (monom a n)) (Suc d) =\n       map_poly (pCons (0::'a)) (monom (monom a n) (Suc d))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       monom (pCons (0::'a) (monom a n)) d =\n       map_poly (pCons (0::'a)) (monom (monom a n) d) \\<Longrightarrow>\n       monom (pCons (0::'a) (monom a n)) (Suc d) =\n       map_poly (pCons (0::'a)) (monom (monom a n) (Suc d))", "unfolding monom_Suc map_poly_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       monom (pCons (0::'a) (monom a n)) d =\n       map_poly (pCons (0::'a)) (monom (monom a n) d) \\<Longrightarrow>\n       pCons 0 (monom (pCons (0::'a) (monom a n)) d) =\n       (if 0 = 0 \\<and> monom (monom a n) d = 0 then 0\n        else pCons [:0::'a:]\n              (map_poly (pCons (0::'a)) (monom (monom a n) d)))", "by auto"], ["", "lemma pCons_0_add: \"pCons 0 (p + q) = pCons 0 p + pCons 0 q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons (0::'a) (p + q) = pCons (0::'a) p + pCons (0::'a) q", "by auto"], ["", "lemma sum_pCons_0_commute:\n  \"sum (\\<lambda>i. pCons 0 (f i)) S = pCons 0 (sum f S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. pCons (0::'a) (f i)) = pCons (0::'a) (sum f S)", "by(induct S rule: infinite_finite_induct;simp)"], ["", "lemma pCons_0_as_mult:\n  fixes p:: \"'a :: comm_semiring_1 poly\"\n  shows \"pCons 0 p = [:0,1:] * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons (0::'a) p = [:0::'a, 1::'a:] * p", "by auto"], ["", "subsection \\<open>Misc\\<close>"], ["", "fun expand_powers :: \"(nat \\<times> 'a)list \\<Rightarrow> 'a list\" where\n  \"expand_powers [] = []\"\n| \"expand_powers ((Suc n, a) # ps) = a # expand_powers ((n,a) # ps)\"\n| \"expand_powers ((0,a) # ps) = expand_powers ps\""], ["", "lemma expand_powers: fixes f :: \"'a \\<Rightarrow> 'b :: comm_ring_1\"\n  shows \"(\\<Prod> (n,a) \\<leftarrow> n_as. f a ^ n) = (\\<Prod> a \\<leftarrow> expand_powers n_as. f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(n, a)\\<leftarrow>n_as. f a ^ n) =\n    prod_list (map f (expand_powers n_as))", "by (rule sym, induct n_as rule: expand_powers.induct, auto)"], ["", "lemma poly_smult_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (smult a p) x = 0) = (a = 0 \\<or> poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (smult a p) x = (0::'a)) = (a = (0::'a) \\<or> poly p x = (0::'a))", "by simp"], ["", "lemma poly_prod_list_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (prod_list ps) x = 0) = (\\<exists> p \\<in> set ps. poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (prod_list ps) x = (0::'a)) =\n    (\\<exists>p\\<in>set ps. poly p x = (0::'a))", "by (induct ps, auto)"], ["", "lemma poly_mult_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (p * q) x = 0) = (poly p x = 0 \\<or> poly q x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (p * q) x = (0::'a)) =\n    (poly p x = (0::'a) \\<or> poly q x = (0::'a))", "by simp"], ["", "lemma poly_power_zero_iff: fixes x :: \"'a :: idom\" \n  shows \"(poly (p^n) x = 0) = (n \\<noteq> 0 \\<and> poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (p ^ n) x = (0::'a)) = (n \\<noteq> 0 \\<and> poly p x = (0::'a))", "by (cases n, auto)"], ["", "lemma sum_monom_0_iff: assumes fin: \"finite S\"\n  and g: \"\\<And> i j. g i = g j \\<Longrightarrow> i = j\"\n  shows \"sum (\\<lambda> i. monom (f i) (g i)) S = 0 \\<longleftrightarrow> (\\<forall> i \\<in> S. f i = 0)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "assume \"\\<not> ?r\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>i\\<in>S. f i = (0::'b))\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i\\<in>S. f i = (0::'b))", "obtain i where i: \"i \\<in> S\" and fi: \"f i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i\\<in>S. f i = (0::'b))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> S; f i \\<noteq> (0::'b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> S\n  f i \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "let ?g = \"\\<lambda> i. monom (f i) (g i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "have \"coeff (sum ?g S) (g i) = f i + sum (\\<lambda> j. coeff (?g j) (g i)) (S - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) =\n    f i + (\\<Sum>j\\<in>S - {i}. coeff (monom (f j) (g j)) (g i))", "by (unfold sum.remove[OF fin i], simp add: coeff_sum)"], ["proof (state)\nthis:\n  coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) =\n  f i + (\\<Sum>j\\<in>S - {i}. coeff (monom (f j) (g j)) (g i))\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "also"], ["proof (state)\nthis:\n  coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) =\n  f i + (\\<Sum>j\\<in>S - {i}. coeff (monom (f j) (g j)) (g i))\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "have \"sum (\\<lambda> j. coeff (?g j) (g i)) (S - {i}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>S - {i}. coeff (monom (f j) (g j)) (g i)) = (0::'b)", "by (rule sum.neutral, insert g, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>S - {i}. coeff (monom (f j) (g j)) (g i)) = (0::'b)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "finally"], ["proof (chain)\npicking this:\n  coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) = f i + (0::'b)", "have \"coeff (sum ?g S) (g i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) = f i + (0::'b)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) \\<noteq> (0::'b)", "using fi"], ["proof (prove)\nusing this:\n  coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) = f i + (0::'b)\n  f i \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "hence \"\\<not> ?l\""], ["proof (prove)\nusing this:\n  coeff (\\<Sum>i\\<in>S. monom (f i) (g i)) (g i) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. monom (f i) (g i)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>S. monom (f i) (g i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "}"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i\\<in>S. f i = (0::'b)) \\<Longrightarrow>\n  (\\<Sum>i\\<in>S. monom (f i) (g i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i\\<in>S. f i = (0::'b)) \\<Longrightarrow>\n  (\\<Sum>i\\<in>S. monom (f i) (g i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n    (\\<forall>i\\<in>S. f i = (0::'b))", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i\\<in>S. monom (f i) (g i)) = 0) =\n  (\\<forall>i\\<in>S. f i = (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_prod_list_eq: assumes \"\\<And> p. p \\<in> set ps \\<Longrightarrow> (p :: 'a :: idom poly) \\<noteq> 0\"\n  shows \"degree (prod_list ps) = sum_list (map degree ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list ps) = sum_list (map degree ps)", "using assms"], ["proof (prove)\nusing this:\n  ?p \\<in> set ps \\<Longrightarrow> ?p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (prod_list ps) = sum_list (map degree ps)", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>p.\n        p \\<in> set [] \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow>\n    degree (prod_list []) = sum_list (map degree [])\n 2. \\<And>a ps.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set ps \\<Longrightarrow>\n                    p \\<noteq> 0) \\<Longrightarrow>\n                degree (prod_list ps) = sum_list (map degree ps);\n        \\<And>p.\n           p \\<in> set (a # ps) \\<Longrightarrow> p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod_list (a # ps)) =\n                         sum_list (map degree (a # ps))", "case (Cons p ps)"], ["proof (state)\nthis:\n  (\\<And>p. p \\<in> set ps \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow>\n  degree (prod_list ps) = sum_list (map degree ps)\n  ?p \\<in> set (p # ps) \\<Longrightarrow> ?p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (\\<And>p.\n        p \\<in> set [] \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow>\n    degree (prod_list []) = sum_list (map degree [])\n 2. \\<And>a ps.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set ps \\<Longrightarrow>\n                    p \\<noteq> 0) \\<Longrightarrow>\n                degree (prod_list ps) = sum_list (map degree ps);\n        \\<And>p.\n           p \\<in> set (a # ps) \\<Longrightarrow> p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod_list (a # ps)) =\n                         sum_list (map degree (a # ps))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list (p # ps)) = sum_list (map degree (p # ps))", "unfolding prod_list.Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p * prod_list ps) = sum_list (map degree (p # ps))", "by (subst degree_mult_eq, insert Cons, auto simp: prod_list_zero_iff)"], ["proof (state)\nthis:\n  degree (prod_list (p # ps)) = sum_list (map degree (p # ps))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set [] \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow>\n    degree (prod_list []) = sum_list (map degree [])", "qed simp"], ["", "lemma degree_power_eq: assumes p: \"p \\<noteq> 0\"\n  shows \"degree (p ^ n) = degree (p :: 'a :: idom poly) * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p ^ n) = degree p * n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree (p ^ 0) = degree p * 0\n 2. \\<And>n.\n       degree (p ^ n) = degree p * n \\<Longrightarrow>\n       degree (p ^ Suc n) = degree p * Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  degree (p ^ n) = degree p * n\n\ngoal (2 subgoals):\n 1. degree (p ^ 0) = degree p * 0\n 2. \\<And>n.\n       degree (p ^ n) = degree p * n \\<Longrightarrow>\n       degree (p ^ Suc n) = degree p * Suc n", "from p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have pn: \"p ^ n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p ^ n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p ^ n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree (p ^ 0) = degree p * 0\n 2. \\<And>n.\n       degree (p ^ n) = degree p * n \\<Longrightarrow>\n       degree (p ^ Suc n) = degree p * Suc n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p ^ Suc n) = degree p * Suc n", "using degree_mult_eq[OF p pn] Suc"], ["proof (prove)\nusing this:\n  degree (p * p ^ n) = degree p + degree (p ^ n)\n  degree (p ^ n) = degree p * n\n\ngoal (1 subgoal):\n 1. degree (p ^ Suc n) = degree p * Suc n", "by auto"], ["proof (state)\nthis:\n  degree (p ^ Suc n) = degree p * Suc n\n\ngoal (1 subgoal):\n 1. degree (p ^ 0) = degree p * 0", "qed simp"], ["", "lemma coeff_Poly: \"coeff (Poly xs) i = (nth_default 0 xs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Poly xs) i = nth_default (0::'a) xs i", "unfolding nth_default_coeffs_eq[of \"Poly xs\", symmetric] coeffs_Poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (strip_while ((=) (0::'a)) xs) i =\n    nth_default (0::'a) xs i", "by simp"], ["", "lemma rsquarefree_def': \"rsquarefree p = (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree p = (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rsquarefree p = (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))", "have \"\\<And> a. order a p \\<le> 1 \\<longleftrightarrow> order a p = 0 \\<or> order a p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (order a p \\<le> 1) = (order a p = 0 \\<or> order a p = 1)", "by linarith"], ["proof (state)\nthis:\n  (order ?a p \\<le> 1) = (order ?a p = 0 \\<or> order ?a p = 1)\n\ngoal (1 subgoal):\n 1. rsquarefree p = (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (order ?a p \\<le> 1) = (order ?a p = 0 \\<or> order ?a p = 1)\n\ngoal (1 subgoal):\n 1. rsquarefree p = (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))", "unfolding rsquarefree_def"], ["proof (prove)\nusing this:\n  (order ?a p \\<le> 1) = (order ?a p = 0 \\<or> order ?a p = 1)\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<and> (\\<forall>a. order a p = 0 \\<or> order a p = 1)) =\n    (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))", "by auto"], ["proof (state)\nthis:\n  rsquarefree p = (p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_prod_list: \"(\\<And> p. p \\<in> set ps \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow> order x (prod_list ps) = sum_list (map (order x) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set ps \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow>\n    order x (prod_list ps) = sum_list (map (order x) ps)", "by (induct ps, auto, subst order_mult, auto simp: prod_list_zero_iff)"], ["", "lemma irreducible\\<^sub>d_dvd_eq:\n  fixes a b :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"irreducible\\<^sub>d a\" and \"irreducible\\<^sub>d b\"\n    and \"a dvd b\"\n    and \"monic a\" and \"monic b\" \n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "using assms"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d a\n  irreducible\\<^sub>d b\n  a dvd b\n  monic a\n  monic b\n\ngoal (1 subgoal):\n 1. a = b", "by (metis (no_types, lifting) coeff_smult degree_smult_eq irreducible\\<^sub>dD(1) irreducible\\<^sub>d_dvd_smult \n    mult.right_neutral smult_1_left)"], ["", "lemma monic_gcd_dvd:\n  assumes fg: \"f dvd g\" and mon: \"monic f\" and gcd: \"gcd g h \\<in> {1, g}\"\n  shows \"gcd f h \\<in> {1, f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f h \\<in> {1, f}", "proof (cases \"coprime g h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}\n 2. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "case True"], ["proof (state)\nthis:\n  coprime g h\n\ngoal (2 subgoals):\n 1. coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}\n 2. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "with dvd_refl"], ["proof (chain)\npicking this:\n  ?a dvd ?a\n  coprime g h", "have \"coprime f h\""], ["proof (prove)\nusing this:\n  ?a dvd ?a\n  coprime g h\n\ngoal (1 subgoal):\n 1. coprime f h", "using fg"], ["proof (prove)\nusing this:\n  ?a dvd ?a\n  coprime g h\n  f dvd g\n\ngoal (1 subgoal):\n 1. coprime f h", "by (blast intro: coprime_divisors)"], ["proof (state)\nthis:\n  coprime f h\n\ngoal (2 subgoals):\n 1. coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}\n 2. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "then"], ["proof (chain)\npicking this:\n  coprime f h", "show ?thesis"], ["proof (prove)\nusing this:\n  coprime f h\n\ngoal (1 subgoal):\n 1. gcd f h \\<in> {1, f}", "by simp"], ["proof (state)\nthis:\n  gcd f h \\<in> {1, f}\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "case False"], ["proof (state)\nthis:\n  \\<not> coprime g h\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "with gcd"], ["proof (chain)\npicking this:\n  gcd g h \\<in> {1, g}\n  \\<not> coprime g h", "have gcd: \"gcd g h = g\""], ["proof (prove)\nusing this:\n  gcd g h \\<in> {1, g}\n  \\<not> coprime g h\n\ngoal (1 subgoal):\n 1. gcd g h = g", "by (simp add: coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  gcd g h = g\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "with fg"], ["proof (chain)\npicking this:\n  f dvd g\n  gcd g h = g", "have \"f dvd gcd g h\""], ["proof (prove)\nusing this:\n  f dvd g\n  gcd g h = g\n\ngoal (1 subgoal):\n 1. f dvd gcd g h", "by simp"], ["proof (state)\nthis:\n  f dvd gcd g h\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "then"], ["proof (chain)\npicking this:\n  f dvd gcd g h", "have \"f dvd h\""], ["proof (prove)\nusing this:\n  f dvd gcd g h\n\ngoal (1 subgoal):\n 1. f dvd h", "by simp"], ["proof (state)\nthis:\n  f dvd h\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "then"], ["proof (chain)\npicking this:\n  f dvd h", "have \"gcd f h = normalize f\""], ["proof (prove)\nusing this:\n  f dvd h\n\ngoal (1 subgoal):\n 1. gcd f h = normalize f", "by (simp add: gcd_proj1_iff)"], ["proof (state)\nthis:\n  gcd f h = normalize f\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "also"], ["proof (state)\nthis:\n  gcd f h = normalize f\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "have \"normalize f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize f = f", "using mon"], ["proof (prove)\nusing this:\n  monic f\n\ngoal (1 subgoal):\n 1. normalize f = f", "by (rule normalize_monic)"], ["proof (state)\nthis:\n  normalize f = f\n\ngoal (1 subgoal):\n 1. \\<not> coprime g h \\<Longrightarrow> gcd f h \\<in> {1, f}", "finally"], ["proof (chain)\npicking this:\n  gcd f h = f", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd f h = f\n\ngoal (1 subgoal):\n 1. gcd f h \\<in> {1, f}", "by simp"], ["proof (state)\nthis:\n  gcd f h \\<in> {1, f}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_power: \"(monom a b)^n = monom (a^n) (b*n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom a b ^ n = monom (a ^ n) (b * n)", "by (induct n, auto simp add: mult_monom)"], ["", "lemma poly_const_pow: \"[:a:]^b = [:a^b:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a:] ^ b = [:a ^ b:]", "by (metis Groups.mult_ac(2) monom_0 monom_power mult_zero_right)"], ["", "lemma degree_pderiv_le: \"degree (pderiv f) \\<le> degree f - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv f) \\<le> degree f - 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> degree (pderiv f) \\<le> degree f - 1\n\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "hence ge: \"degree (pderiv f) \\<ge> Suc (degree f - 1)\""], ["proof (prove)\nusing this:\n  \\<not> degree (pderiv f) \\<le> degree f - 1\n\ngoal (1 subgoal):\n 1. Suc (degree f - 1) \\<le> degree (pderiv f)", "by auto"], ["proof (state)\nthis:\n  Suc (degree f - 1) \\<le> degree (pderiv f)\n\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "hence \"pderiv f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Suc (degree f - 1) \\<le> degree (pderiv f)\n\ngoal (1 subgoal):\n 1. pderiv f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pderiv f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "hence \"coeff (pderiv f) (degree (pderiv f)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pderiv f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (pderiv f) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  lead_coeff (pderiv f) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "from this[unfolded coeff_pderiv]"], ["proof (chain)\npicking this:\n  of_nat (Suc (degree (pderiv f))) *\n  coeff f (Suc (degree (pderiv f))) \\<noteq>\n  (0::'a)", "have \"coeff f (Suc (degree (pderiv f))) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_nat (Suc (degree (pderiv f))) *\n  coeff f (Suc (degree (pderiv f))) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. coeff f (Suc (degree (pderiv f))) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  coeff f (Suc (degree (pderiv f))) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  coeff f (Suc (degree (pderiv f))) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "have \"Suc (degree (pderiv f)) > degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f < Suc (degree (pderiv f))", "using ge"], ["proof (prove)\nusing this:\n  Suc (degree f - 1) \\<le> degree (pderiv f)\n\ngoal (1 subgoal):\n 1. degree f < Suc (degree (pderiv f))", "by auto"], ["proof (state)\nthis:\n  degree f < Suc (degree (pderiv f))\n\ngoal (1 subgoal):\n 1. \\<not> degree (pderiv f) \\<le> degree f - 1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  coeff f (Suc (degree (pderiv f))) \\<noteq> (0::'a)\n  degree f < Suc (degree (pderiv f))", "show False"], ["proof (prove)\nusing this:\n  coeff f (Suc (degree (pderiv f))) \\<noteq> (0::'a)\n  degree f < Suc (degree (pderiv f))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: coeff_eq_0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_div_is_smult_inverse: \"map_poly (\\<lambda>x. x / (a :: 'a :: field)) p = smult (inverse a) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>x. x / a) p = smult (inverse a) p", "unfolding smult_conv_map_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>x. x / a) p = map_poly ((*) (inverse a)) p", "by (simp add: divide_inverse_commute)"], ["", "lemma normalize_poly_old_def:\n  \"normalize (f :: 'a :: {normalization_semidom,field} poly) = smult (inverse (unit_factor (lead_coeff f))) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize f = smult (inverse (unit_factor (lead_coeff f))) f", "by (simp add: normalize_poly_eq_map_poly map_div_is_smult_inverse)"], ["", "(* was in Euclidean_Algorithm in Number_Theory before, but has been removed *)"], ["", "lemma poly_dvd_antisym:\n  fixes p q :: \"'b::idom poly\"\n  assumes coeff: \"coeff p (degree p) = coeff q (degree q)\"\n  assumes dvd1: \"p dvd q\" and dvd2: \"q dvd p\" shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> p = q\n 2. p \\<noteq> 0 \\<Longrightarrow> p = q", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> p = q\n 2. p \\<noteq> 0 \\<Longrightarrow> p = q", "with coeff"], ["proof (chain)\npicking this:\n  lead_coeff p = lead_coeff q\n  p = 0", "show \"p = q\""], ["proof (prove)\nusing this:\n  lead_coeff p = lead_coeff q\n  p = 0\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "with coeff"], ["proof (chain)\npicking this:\n  lead_coeff p = lead_coeff q\n  p \\<noteq> 0", "have \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lead_coeff p = lead_coeff q\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "have degree: \"degree p = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = degree q", "using \\<open>p dvd q\\<close> \\<open>q dvd p\\<close> \\<open>p \\<noteq> 0\\<close> \\<open>q \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  p dvd q\n  q dvd p\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = degree q", "by (intro order_antisym dvd_imp_degree_le)"], ["proof (state)\nthis:\n  degree p = degree q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "from \\<open>p dvd q\\<close>"], ["proof (chain)\npicking this:\n  p dvd q", "obtain a where a: \"q = p * a\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>a. q = p * a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  q = p * a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "with \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  q = p * a", "have \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q = p * a\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "with degree a \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  degree p = degree q\n  q = p * a\n  p \\<noteq> 0\n  a \\<noteq> 0", "have \"degree a = 0\""], ["proof (prove)\nusing this:\n  degree p = degree q\n  q = p * a\n  p \\<noteq> 0\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree a = 0", "by (simp add: degree_mult_eq)"], ["proof (state)\nthis:\n  degree a = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> p = q", "with coeff a"], ["proof (chain)\npicking this:\n  lead_coeff p = lead_coeff q\n  q = p * a\n  degree a = 0", "show \"p = q\""], ["proof (prove)\nusing this:\n  lead_coeff p = lead_coeff q\n  q = p * a\n  degree a = 0\n\ngoal (1 subgoal):\n 1. p = q", "by (cases a, auto split: if_splits)"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_f_0_code[code_unfold]: \"coeff f 0 = (case coeffs f of [] \\<Rightarrow> 0 | x # _ \\<Rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff f 0 =\n    (case coeffs f of [] \\<Rightarrow> 0::'a | x # xa \\<Rightarrow> x)", "by (cases f, auto simp: cCons_def)"], ["", "lemma poly_compare_0_code[code_unfold]: \"(f = 0) = (case coeffs f of [] \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = 0) =\n    (case coeffs f of [] \\<Rightarrow> True | a # list \\<Rightarrow> False)", "using coeffs_eq_Nil list.disc_eq_case(1)"], ["proof (prove)\nusing this:\n  (coeffs ?p = []) = (?p = 0)\n  (?list = []) =\n  (case ?list of [] \\<Rightarrow> True | uu_ # uua_ \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. (f = 0) =\n    (case coeffs f of [] \\<Rightarrow> True | a # list \\<Rightarrow> False)", "by blast"], ["", "text \\<open>Getting more efficient code for abbreviation @{term lead_coeff}\"\\<close>"], ["", "definition leading_coeff\n  where [code_abbrev, simp]: \"leading_coeff = lead_coeff\""], ["", "lemma leading_coeff_code [code]:\n  \"leading_coeff f = (let xs = coeffs f in if xs = [] then 0 else last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leading_coeff f =\n    (let xs = coeffs f in if xs = [] then 0::'a else last xs)", "by (simp add: last_coeffs_eq_coeff_degree)"], ["", "lemma nth_coeffs_coeff: \"i < length (coeffs f) \\<Longrightarrow> coeffs f ! i = coeff f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (coeffs f) \\<Longrightarrow> coeffs f ! i = coeff f i", "by (metis nth_default_coeffs_eq nth_default_def)"], ["", "definition monom_mult :: \"nat \\<Rightarrow> 'a :: comm_semiring_1 poly \\<Rightarrow> 'a poly\"\n  where \"monom_mult n f = monom 1 n * f\""], ["", "lemma monom_mult_unfold [code_unfold]:\n  \"monom 1 n * f = monom_mult n f\"\n  \"f * monom 1 n = monom_mult n f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) n * f = monom_mult n f &&&\n    f * monom (1::'a) n = monom_mult n f", "by (auto simp: monom_mult_def ac_simps)"], ["", "lemma monom_mult_code [code abstract]:\n  \"coeffs (monom_mult n f) = (let xs = coeffs f in\n    if xs = [] then xs else replicate n 0 @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (monom_mult n f) =\n    (let xs = coeffs f in if xs = [] then xs else replicate n (0::'a) @ xs)", "by (rule coeffs_eqI)\n    (auto simp add: Let_def monom_mult_def coeff_monom_mult nth_default_append nth_default_coeffs_eq)"], ["", "lemma coeff_pcompose_monom: fixes f :: \"'a :: comm_ring_1 poly\" \n  assumes n: \"j < n\" \n  shows \"coeff (f \\<circ>\\<^sub>p monom 1 n) (n * i + j) = (if j = 0 then coeff f i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n    (if j = 0 then coeff f i else (0::'a))", "proof (induct f arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       coeff (0 \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff 0 i else (0::'a))\n 2. \\<And>a f i.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> f \\<noteq> 0;\n        \\<And>i.\n           coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n           (if j = 0 then coeff f i else (0::'a))\\<rbrakk>\n       \\<Longrightarrow> coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n)\n                          (n * i + j) =\n                         (if j = 0 then coeff (pCons a f) i else (0::'a))", "case (pCons a f i)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> f \\<noteq> 0\n  coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * ?i + j) =\n  (if j = 0 then coeff f ?i else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       coeff (0 \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff 0 i else (0::'a))\n 2. \\<And>a f i.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> f \\<noteq> 0;\n        \\<And>i.\n           coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n           (if j = 0 then coeff f i else (0::'a))\\<rbrakk>\n       \\<Longrightarrow> coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n)\n                          (n * i + j) =\n                         (if j = 0 then coeff (pCons a f) i else (0::'a))", "note d = pcompose_pCons coeff_add coeff_monom_mult coeff_pCons"], ["proof (state)\nthis:\n  pCons ?a ?p \\<circ>\\<^sub>p ?q = [:?a:] + ?q * ?p \\<circ>\\<^sub>p ?q\n  coeff (?p + ?q) ?n = coeff ?p ?n + coeff ?q ?n\n  coeff (monom ?a ?d * ?p) ?i =\n  (if ?d \\<le> ?i then ?a * coeff ?p (?i - ?d) else (0::?'a))\n  coeff (pCons ?x ?xa) = case_nat ?x (coeff ?xa)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       coeff (0 \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff 0 i else (0::'a))\n 2. \\<And>a f i.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> f \\<noteq> 0;\n        \\<And>i.\n           coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n           (if j = 0 then coeff f i else (0::'a))\\<rbrakk>\n       \\<Longrightarrow> coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n)\n                          (n * i + j) =\n                         (if j = 0 then coeff (pCons a f) i else (0::'a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n    (if j = 0 then coeff (pCons a f) i else (0::'a))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n    (if j = 0 then coeff (pCons a f) i else (0::'a))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n    (if j = 0 then coeff (pCons a f) i else (0::'a))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n    (if j = 0 then coeff (pCons a f) i else (0::'a))", "unfolding d 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case n * 0 + j of 0 \\<Rightarrow> a | Suc x \\<Rightarrow> coeff 0 x) +\n    (if n \\<le> n * 0 + j\n     then (1::'a) *\n          coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * 0 + j - n)\n     else (0::'a)) =\n    (if j = 0\n     then case 0 of 0 \\<Rightarrow> a | Suc x \\<Rightarrow> coeff f x\n     else (0::'a))", "using n"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. (case n * 0 + j of 0 \\<Rightarrow> a | Suc x \\<Rightarrow> coeff 0 x) +\n    (if n \\<le> n * 0 + j\n     then (1::'a) *\n          coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * 0 + j - n)\n     else (0::'a)) =\n    (if j = 0\n     then case 0 of 0 \\<Rightarrow> a | Suc x \\<Rightarrow> coeff f x\n     else (0::'a))", "by (cases j, auto)"], ["proof (state)\nthis:\n  coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n  (if j = 0 then coeff (pCons a f) i else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "case (Suc ii)"], ["proof (state)\nthis:\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "have id: \"n * Suc ii + j - n = n * ii + j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * Suc ii + j - n = n * ii + j", "using n"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. n * Suc ii + j - n = n * ii + j", "by (simp add: diff_mult_distrib2)"], ["proof (state)\nthis:\n  n * Suc ii + j - n = n * ii + j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "have id1: \"(n \\<le> n * Suc ii + j) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<le> n * Suc ii + j) = True", "by auto"], ["proof (state)\nthis:\n  (n \\<le> n * Suc ii + j) = True\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "have id2: \"(case n * Suc ii + j of 0 \\<Rightarrow> a | Suc x \\<Rightarrow> coeff 0 x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case n * Suc ii + j of 0 \\<Rightarrow> a\n     | Suc x \\<Rightarrow> coeff 0 x) =\n    (0::'a)", "using n"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. (case n * Suc ii + j of 0 \\<Rightarrow> a\n     | Suc x \\<Rightarrow> coeff 0 x) =\n    (0::'a)", "by (cases \"n * Suc ii + j\", auto)"], ["proof (state)\nthis:\n  (case n * Suc ii + j of 0 \\<Rightarrow> a\n   | Suc x \\<Rightarrow> coeff 0 x) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff (pCons a f) i else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n    (if j = 0 then coeff (pCons a f) i else (0::'a))", "unfolding d Suc id id1 id2 pCons(2) if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) + (1::'a) * (if j = 0 then coeff f ii else (0::'a)) =\n    (if j = 0\n     then case Suc ii of 0 \\<Rightarrow> a | Suc x \\<Rightarrow> coeff f x\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n  (if j = 0 then coeff (pCons a f) i else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (pCons a f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n  (if j = 0 then coeff (pCons a f) i else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       coeff (0 \\<circ>\\<^sub>p monom (1::'a) n) (n * i + j) =\n       (if j = 0 then coeff 0 i else (0::'a))", "qed auto"], ["", "lemma coeff_pcompose_x_pow_n: fixes f :: \"'a :: comm_ring_1 poly\" \n  assumes n: \"n \\<noteq> 0\" \n  shows \"coeff (f \\<circ>\\<^sub>p monom 1 n) (n * i) = coeff f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * i) = coeff f i", "using coeff_pcompose_monom[of 0 n f i] n"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * i + 0) =\n  (if 0 = 0 then coeff f i else (0::'a))\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff (f \\<circ>\\<^sub>p monom (1::'a) n) (n * i) = coeff f i", "by auto"], ["", "lemma dvd_dvd_smult: \"a dvd b \\<Longrightarrow> f dvd g \\<Longrightarrow> smult a f dvd smult b g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a dvd b; f dvd g\\<rbrakk>\n    \\<Longrightarrow> smult a f dvd smult b g", "unfolding dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>k. b = a * k; \\<exists>k. g = f * k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k. smult b g = smult a f * k", "by (metis mult_smult_left mult_smult_right smult_smult)"], ["", "definition sdiv_poly :: \"'a :: idom_divide poly \\<Rightarrow> 'a \\<Rightarrow> 'a poly\" where\n  \"sdiv_poly p a = (map_poly (\\<lambda> c. c div a) p)\""], ["", "lemma smult_map_poly: \"smult a = map_poly ((*) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a = map_poly ((*) a)", "by (rule ext, rule poly_eqI, subst coeff_map_poly, auto)"], ["", "lemma smult_exact_sdiv_poly: assumes \"\\<And> c. c \\<in> set (coeffs p) \\<Longrightarrow> a dvd c\"\n  shows \"smult a (sdiv_poly p a) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a (sdiv_poly p a) = p", "unfolding smult_map_poly sdiv_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly ((*) a) (map_poly (\\<lambda>c. c div a) p) = p", "by (subst map_poly_map_poly,simp,rule map_poly_idI, insert assms, auto)"], ["", "lemma coeff_sdiv_poly: \"coeff (sdiv_poly f a) n = coeff f n div a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (sdiv_poly f a) n = coeff f n div a", "unfolding sdiv_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (map_poly (\\<lambda>c. c div a) f) n = coeff f n div a", "by (rule coeff_map_poly, auto)"], ["", "lemma poly_pinfty_ge:\n  fixes p :: \"real poly\"\n  assumes \"lead_coeff p > 0\" \"degree p \\<noteq> 0\" \n  shows \"\\<exists>n. \\<forall> x \\<ge> n. poly p x \\<ge> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x", "let ?p = \"p - [:b - lead_coeff p :]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x", "have id: \"lead_coeff ?p = lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (p - [:b - lead_coeff p:]) = lead_coeff p", "using assms(2)"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (p - [:b - lead_coeff p:]) = lead_coeff p", "by (cases p, auto)"], ["proof (state)\nthis:\n  lead_coeff (p - [:b - lead_coeff p:]) = lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x", "with assms(1)"], ["proof (chain)\npicking this:\n  0 < lead_coeff p\n  lead_coeff (p - [:b - lead_coeff p:]) = lead_coeff p", "have \"lead_coeff ?p > 0\""], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n  lead_coeff (p - [:b - lead_coeff p:]) = lead_coeff p\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (p - [:b - lead_coeff p:])", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff (p - [:b - lead_coeff p:])\n\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x", "from poly_pinfty_gt_lc[OF this, unfolded id]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     \\<forall>x\\<ge>n. lead_coeff p \\<le> poly (p - [:b - lead_coeff p:]) x", "obtain n\n    where \"\\<And> x. x \\<ge> n \\<Longrightarrow> 0 \\<le> poly p x - b\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     \\<forall>x\\<ge>n. lead_coeff p \\<le> poly (p - [:b - lead_coeff p:]) x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>x.\n            n \\<le> x \\<Longrightarrow>\n            0 \\<le> poly p x - b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n \\<le> ?x \\<Longrightarrow> 0 \\<le> poly p ?x - b\n\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> ?x \\<Longrightarrow> 0 \\<le> poly p ?x - b\n\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pderiv_sum: \"pderiv (sum f I) = sum (\\<lambda> i. (pderiv (f i))) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (sum f I) = (\\<Sum>i\\<in>I. pderiv (f i))", "by (induct I rule: infinite_finite_induct, auto simp: pderiv_add)"], ["", "lemma smult_sum2: \"smult m (\\<Sum>i \\<in> S. f i) = (\\<Sum>i \\<in> S. smult m (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult m (sum f S) = (\\<Sum>i\\<in>S. smult m (f i))", "by (induct S rule: infinite_finite_induct, auto simp add: smult_add_right)"], ["", "lemma degree_mult_not_eq:\n  \"degree (f * g) \\<noteq> degree f + degree g \\<Longrightarrow> lead_coeff f * lead_coeff g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f * g) \\<noteq> degree f + degree g \\<Longrightarrow>\n    lead_coeff f * lead_coeff g = (0::'a)", "by (rule ccontr, auto simp: coeff_mult_degree_sum degree_mult_le le_antisym le_degree)"], ["", "lemma irreducible\\<^sub>d_multD:\n  fixes a b :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes l: \"irreducible\\<^sub>d (a*b)\"\n  shows \"degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or> degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "from l"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (a * b)", "have a0: \"a \\<noteq> 0\" and b0: \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (a * b)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "note [simp] = degree_mult_eq[OF this]"], ["proof (state)\nthis:\n  degree (a * b) = degree a + degree b\n\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "from l"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (a * b)", "have \"degree a = 0 \\<or> degree b = 0\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (a * b)\n\ngoal (1 subgoal):\n 1. degree a = 0 \\<or> degree b = 0", "apply (unfold irreducible\\<^sub>d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (a * b) \\<and>\n    (\\<forall>q r.\n        degree q < degree (a * b) \\<longrightarrow>\n        degree r < degree (a * b) \\<longrightarrow>\n        a * b \\<noteq> q * r) \\<Longrightarrow>\n    degree a = 0 \\<or> degree b = 0", "by force"], ["proof (state)\nthis:\n  degree a = 0 \\<or> degree b = 0\n\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "then"], ["proof (chain)\npicking this:\n  degree a = 0 \\<or> degree b = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  degree a = 0 \\<or> degree b = 0\n\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "proof(elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree a = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\n 2. degree b = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "assume a: \"degree a = 0\""], ["proof (state)\nthis:\n  degree a = 0\n\ngoal (2 subgoals):\n 1. degree a = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\n 2. degree b = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "with l a0"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (a * b)\n  a \\<noteq> 0\n  degree a = 0", "have \"irreducible\\<^sub>d b\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (a * b)\n  a \\<noteq> 0\n  degree a = 0\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d b", "by (simp add: irreducible\\<^sub>d_def)\n        (metis degree_mult_eq degree_mult_eq_0 mult.left_commute plus_nat.add_0)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d b\n\ngoal (2 subgoals):\n 1. degree a = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\n 2. degree b = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "with a a0"], ["proof (chain)\npicking this:\n  degree a = 0\n  a \\<noteq> 0\n  irreducible\\<^sub>d b", "show ?thesis"], ["proof (prove)\nusing this:\n  degree a = 0\n  a \\<noteq> 0\n  irreducible\\<^sub>d b\n\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "by auto"], ["proof (state)\nthis:\n  degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n  degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\n\ngoal (1 subgoal):\n 1. degree b = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree b = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "assume b: \"degree b = 0\""], ["proof (state)\nthis:\n  degree b = 0\n\ngoal (1 subgoal):\n 1. degree b = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "with l b0"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (a * b)\n  b \\<noteq> 0\n  degree b = 0", "have \"irreducible\\<^sub>d a\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (a * b)\n  b \\<noteq> 0\n  degree b = 0\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d a", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  0 < degree (a * b) \\<and>\n  (\\<forall>q r.\n      degree q < degree (a * b) \\<longrightarrow>\n      degree r < degree (a * b) \\<longrightarrow> a * b \\<noteq> q * r)\n  b \\<noteq> 0\n  degree b = 0\n\ngoal (1 subgoal):\n 1. 0 < degree a \\<and>\n    (\\<forall>q r.\n        degree q < degree a \\<longrightarrow>\n        degree r < degree a \\<longrightarrow> a \\<noteq> q * r)", "by (smt add_cancel_left_right degree_mult_eq degree_mult_eq_0 neq0_conv semiring_normalization_rules(16))"], ["proof (state)\nthis:\n  irreducible\\<^sub>d a\n\ngoal (1 subgoal):\n 1. degree b = 0 \\<Longrightarrow>\n    degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "with b b0"], ["proof (chain)\npicking this:\n  degree b = 0\n  b \\<noteq> 0\n  irreducible\\<^sub>d a", "show ?thesis"], ["proof (prove)\nusing this:\n  degree b = 0\n  b \\<noteq> 0\n  irreducible\\<^sub>d a\n\ngoal (1 subgoal):\n 1. degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n    degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a", "by auto"], ["proof (state)\nthis:\n  degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n  degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree a = 0 \\<and> a \\<noteq> 0 \\<and> irreducible\\<^sub>d b \\<or>\n  degree b = 0 \\<and> b \\<noteq> 0 \\<and> irreducible\\<^sub>d a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_connect_field[simp]:\n  fixes f :: \"'a :: field poly\"\n  shows \"irreducible\\<^sub>d f = irreducible f\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f = irreducible f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. irreducible\\<^sub>d f \\<Longrightarrow> irreducible f\n 2. irreducible f \\<Longrightarrow> irreducible\\<^sub>d f", "show \"?r \\<Longrightarrow> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible f \\<Longrightarrow> irreducible\\<^sub>d f", "apply (intro irreducible\\<^sub>dI, force simp:is_unit_iff_degree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>irreducible f; 0 < degree q; degree q < degree f;\n        0 < degree r; degree r < degree f; f = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto dest!: irreducible_multD simp: poly_dvd_1)"], ["proof (state)\nthis:\n  irreducible f \\<Longrightarrow> irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f \\<Longrightarrow> irreducible f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f \\<Longrightarrow> irreducible f", "assume l: ?l"], ["proof (state)\nthis:\n  irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f \\<Longrightarrow> irreducible f", "show ?r"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible f", "proof (rule irreducibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. f \\<noteq> 0\n 2. \\<not> is_unit f\n 3. \\<And>a b. f = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from l"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d f", "show \"f \\<noteq> 0\" \"\\<not> is_unit f\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 &&& \\<not> is_unit f", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  f \\<noteq> 0\n  \\<not> is_unit f\n\ngoal (1 subgoal):\n 1. \\<And>a b. f = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. f = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "assume \"f = a * b\""], ["proof (state)\nthis:\n  f = a * b\n\ngoal (1 subgoal):\n 1. \\<And>a b. f = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from l[unfolded this]"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (a * b)", "show \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (a * b)\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "by (auto dest!: irreducible\\<^sub>d_multD simp:is_unit_iff_degree)"], ["proof (state)\nthis:\n  is_unit a \\<or> is_unit b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_unit_field_poly[simp]:\n  fixes p :: \"'a::field poly\"\n  shows \"is_unit p \\<longleftrightarrow> p \\<noteq> 0 \\<and> degree p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit p = (p \\<noteq> 0 \\<and> degree p = 0)", "by (cases \"p=0\", auto simp: is_unit_iff_degree)"], ["", "lemma irreducible_smult_field[simp]:\n  fixes c :: \"'a :: field\"\n  shows \"irreducible (smult c p) \\<longleftrightarrow> c \\<noteq> 0 \\<and> irreducible p\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (smult c p) = (c \\<noteq> (0::'a) \\<and> irreducible p)", "proof (intro iffI conjI irreducible\\<^sub>d_smult_not_zero_divisor_left[of c p, simplified])"], ["proof (state)\ngoal (4 subgoals):\n 1. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 2. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 3. irreducible (smult c p) \\<Longrightarrow> irreducible (smult c p)\n 4. c \\<noteq> (0::'a) \\<and> irreducible p \\<Longrightarrow>\n    irreducible (smult c p)", "assume \"irreducible (smult c p)\""], ["proof (state)\nthis:\n  irreducible (smult c p)\n\ngoal (4 subgoals):\n 1. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 2. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 3. irreducible (smult c p) \\<Longrightarrow> irreducible (smult c p)\n 4. c \\<noteq> (0::'a) \\<and> irreducible p \\<Longrightarrow>\n    irreducible (smult c p)", "then"], ["proof (chain)\npicking this:\n  irreducible (smult c p)", "show \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible (smult c p)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 2. irreducible (smult c p) \\<Longrightarrow> irreducible (smult c p)\n 3. c \\<noteq> (0::'a) \\<and> irreducible p \\<Longrightarrow>\n    irreducible (smult c p)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 2. irreducible (smult c p) \\<Longrightarrow> irreducible (smult c p)\n 3. c \\<noteq> (0::'a) \\<and> irreducible p \\<Longrightarrow>\n    irreducible (smult c p)", "assume ?R"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a) \\<and> irreducible p\n\ngoal (3 subgoals):\n 1. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 2. irreducible (smult c p) \\<Longrightarrow> irreducible (smult c p)\n 3. c \\<noteq> (0::'a) \\<and> irreducible p \\<Longrightarrow>\n    irreducible (smult c p)", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a) \\<and> irreducible p", "have c0: \"c \\<noteq> 0\" and irr: \"irreducible p\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a) \\<and> irreducible p\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) &&& irreducible p", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  irreducible p\n\ngoal (3 subgoals):\n 1. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 2. irreducible (smult c p) \\<Longrightarrow> irreducible (smult c p)\n 3. c \\<noteq> (0::'a) \\<and> irreducible p \\<Longrightarrow>\n    irreducible (smult c p)", "show ?L"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (smult c p)", "proof (fold irreducible_connect_field, intro irreducible\\<^sub>dI, unfold degree_smult_eq if_not_P[OF c0])"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "show \"degree p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p", "using irr"], ["proof (prove)\nusing this:\n  irreducible p\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from c0"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "have \"p = smult (1/c) (smult c p)\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p = smult ((1::'a) / c) (smult c p)", "by simp"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) (smult c p)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) (smult c p)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"smult c p = q * r\""], ["proof (state)\nthis:\n  smult c p = q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  p = smult ((1::'a) / c) (q * r)", "have [simp]: \"p = smult (1/c) \\<dots>\""], ["proof (prove)\nusing this:\n  p = smult ((1::'a) / c) (q * r)\n\ngoal (1 subgoal):\n 1. p = smult ((1::'a) / c) (q * r)", "."], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) (q * r)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume main: \"degree q < degree p\" \"degree r < degree p\""], ["proof (state)\nthis:\n  degree q < degree p\n  degree r < degree p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<not>irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d p", "by (rule reducible\\<^sub>dI, rule exI[of _ \"smult (1/c) q\"], rule exI[of _ r], insert irr c0 main, simp)"], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; smult c p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with irr"], ["proof (chain)\npicking this:\n  irreducible p\n  \\<not> irreducible\\<^sub>d p", "show False"], ["proof (prove)\nusing this:\n  irreducible p\n  \\<not> irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible (smult c p)\n\ngoal (2 subgoals):\n 1. irreducible (smult c p) \\<Longrightarrow> c \\<noteq> (0::'a)\n 2. irreducible (smult c p) \\<Longrightarrow> irreducible (smult c p)", "qed auto"], ["", "lemma irreducible_monic_factor: fixes p :: \"'a :: field poly\" \n  assumes \"degree p > 0\" \n  shows \"\\<exists> q r. irreducible q \\<and> p = q * r \\<and> monic q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q", "from irreducible\\<^sub>d_factorization_exists[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>fs.\n     fs \\<noteq> [] \\<and>\n     (\\<forall>f\\<in>set fs.\n         irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n     p = prod_list fs\n  \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n  \\<exists>fs.\n     1 < length fs \\<and>\n     (\\<forall>f\\<in>set fs.\n         irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n     p = prod_list fs", "obtain fs where \"fs \\<noteq> []\" and \"set fs \\<subseteq> Collect irreducible\" and \"p = prod_list fs\""], ["proof (prove)\nusing this:\n  \\<exists>fs.\n     fs \\<noteq> [] \\<and>\n     (\\<forall>f\\<in>set fs.\n         irreducible\\<^sub>d f \\<and> degree f \\<le> degree p) \\<and>\n     p = prod_list fs\n  \\<not> irreducible\\<^sub>d p \\<Longrightarrow>\n  \\<exists>fs.\n     1 < length fs \\<and>\n     (\\<forall>f\\<in>set fs.\n         irreducible\\<^sub>d f \\<and> degree f < degree p) \\<and>\n     p = prod_list fs\n\ngoal (1 subgoal):\n 1. (\\<And>fs.\n        \\<lbrakk>fs \\<noteq> []; set fs \\<subseteq> Collect irreducible;\n         p = prod_list fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fs \\<noteq> []\n  set fs \\<subseteq> Collect irreducible\n  p = prod_list fs\n\ngoal (1 subgoal):\n 1. \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q", "then"], ["proof (chain)\npicking this:\n  fs \\<noteq> []\n  set fs \\<subseteq> Collect irreducible\n  p = prod_list fs", "have q: \"irreducible (hd fs)\" and p: \"p = hd fs * prod_list (tl fs)\""], ["proof (prove)\nusing this:\n  fs \\<noteq> []\n  set fs \\<subseteq> Collect irreducible\n  p = prod_list fs\n\ngoal (1 subgoal):\n 1. irreducible (hd fs) &&& p = hd fs * prod_list (tl fs)", "by (atomize(full), cases fs, auto)"], ["proof (state)\nthis:\n  irreducible (hd fs)\n  p = hd fs * prod_list (tl fs)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q", "define c where \"c = coeff (hd fs) (degree (hd fs))\""], ["proof (state)\nthis:\n  c = lead_coeff (hd fs)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q", "from q"], ["proof (chain)\npicking this:\n  irreducible (hd fs)", "have c: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible (hd fs)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "unfolding c_def irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  irreducible (hd fs)\n\ngoal (1 subgoal):\n 1. lead_coeff (hd fs) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q", "by (rule exI[of _ \"smult (1/c) (hd fs)\"], rule exI[of _ \"smult c (prod_list (tl fs))\"], unfold p,\n    insert q c, auto simp: c_def)"], ["proof (state)\nthis:\n  \\<exists>q r. irreducible q \\<and> p = q * r \\<and> monic q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_irreducible_factorization: fixes p :: \"'a :: field poly\" \n  shows \"monic p \\<Longrightarrow> \n  \\<exists> as f. finite as \\<and> p = prod (\\<lambda> a. a ^ Suc (f a)) as \\<and> as \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "proof (induct \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; monic pa\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as f.\n  finite as \\<and>\n  pa = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n  as \\<subseteq> {q. irreducible q \\<and> monic q};\n        monic p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as f.\n                            finite as \\<and>\n                            p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n                            as \\<subseteq> {q. irreducible q \\<and> monic q}", "case (less p)"], ["proof (state)\nthis:\n  \\<lbrakk>degree ?p < degree p; monic ?p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as f.\n                       finite as \\<and>\n                       ?p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n                       as \\<subseteq> {q. irreducible q \\<and> monic q}\n  monic p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; monic pa\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as f.\n  finite as \\<and>\n  pa = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n  as \\<subseteq> {q. irreducible q \\<and> monic q};\n        monic p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as f.\n                            finite as \\<and>\n                            p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n                            as \\<subseteq> {q. irreducible q \\<and> monic q}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "proof (cases \"degree p > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < degree p\n\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "with less(2)"], ["proof (chain)\npicking this:\n  monic p\n  \\<not> 0 < degree p", "have \"p = 1\""], ["proof (prove)\nusing this:\n  monic p\n  \\<not> 0 < degree p\n\ngoal (1 subgoal):\n 1. p = 1", "by (simp add: coeff_eq_0 poly_eq_iff)"], ["proof (state)\nthis:\n  p = 1\n\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 1\n\ngoal (1 subgoal):\n 1. \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "by (intro exI[of _ \"{}\"], auto)"], ["proof (state)\nthis:\n  \\<exists>as f.\n     finite as \\<and>\n     p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "case True"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from irreducible\\<^sub>d_factor[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p", "obtain q r where p: \"p = q * r\"\n      and q: \"irreducible q\" and deg: \"degree r < degree p\""], ["proof (prove)\nusing this:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> p = q * r \\<and> degree r < degree p\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q * r; irreducible q; degree r < degree p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = q * r\n  irreducible q\n  degree r < degree p\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "hence q0: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = q * r\n  irreducible q\n  degree r < degree p\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "define c where \"c = coeff q (degree q)\""], ["proof (state)\nthis:\n  c = lead_coeff q\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "let ?q = \"smult (1/c) q\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "let ?r = \"smult c r\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from q0"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have c: \"c \\<noteq> 0\" \"1 / c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) &&& (1::'a) / c \\<noteq> (0::'a)", "unfolding c_def"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff q \\<noteq> (0::'a) &&&\n    (1::'a) / lead_coeff q \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  (1::'a) / c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "hence p: \"p = ?q * ?r\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  (1::'a) / c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p = smult ((1::'a) / c) q * smult c r", "unfolding p"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  (1::'a) / c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. q * r = smult ((1::'a) / c) q * smult c r", "by auto"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) q * smult c r\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have deg: \"degree ?r < degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (smult c r) < degree p", "using c deg"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  (1::'a) / c \\<noteq> (0::'a)\n  degree r < degree p\n\ngoal (1 subgoal):\n 1. degree (smult c r) < degree p", "by auto"], ["proof (state)\nthis:\n  degree (smult c r) < degree p\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "let ?Q = \"{q. irreducible q \\<and> monic (q :: 'a poly)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have mon: \"monic ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (smult ((1::'a) / c) q)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (smult ((1::'a) / lead_coeff q) q)", "using q0"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (smult ((1::'a) / lead_coeff q) q)", "by auto"], ["proof (state)\nthis:\n  monic (smult ((1::'a) / c) q)\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from monic_factor[OF \\<open>monic p\\<close>[unfolded p] this]"], ["proof (chain)\npicking this:\n  monic (smult c r)", "have \"monic ?r\""], ["proof (prove)\nusing this:\n  monic (smult c r)\n\ngoal (1 subgoal):\n 1. monic (smult c r)", "."], ["proof (state)\nthis:\n  monic (smult c r)\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from less(1)[OF deg this]"], ["proof (chain)\npicking this:\n  \\<exists>as f.\n     finite as \\<and>\n     smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}", "obtain f as\n      where as: \"finite as\" \"?r = (\\<Prod> a \\<in>as. a ^ Suc (f a))\"\n        \"as \\<subseteq> ?Q\""], ["proof (prove)\nusing this:\n  \\<exists>as f.\n     finite as \\<and>\n     smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>as f.\n        \\<lbrakk>finite as; smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a));\n         as \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite as\n  smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a))\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from q c"], ["proof (chain)\npicking this:\n  irreducible q\n  c \\<noteq> (0::'a)\n  (1::'a) / c \\<noteq> (0::'a)", "have irred: \"irreducible ?q\""], ["proof (prove)\nusing this:\n  irreducible q\n  c \\<noteq> (0::'a)\n  (1::'a) / c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. irreducible (smult ((1::'a) / c) q)", "by simp"], ["proof (state)\nthis:\n  irreducible (smult ((1::'a) / c) q)\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "proof (cases \"?q \\<in> as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "case False"], ["proof (state)\nthis:\n  smult ((1::'a) / c) q \\<notin> as\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "let ?as = \"insert ?q as\""], ["proof (state)\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "let ?f = \"\\<lambda> a. if a = ?q then 0 else f a\""], ["proof (state)\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"p = ?q * (\\<Prod> a \\<in>as. a ^ Suc (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))", "unfolding p as"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n    smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))", "by simp"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "also"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"(\\<Prod> a \\<in>as. a ^ Suc (f a)) = (\\<Prod> a \\<in>as. a ^ Suc (?f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n    (\\<Prod>a\\<in>as.\n       a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))", "by (rule prod.cong, insert False, auto)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n  (\\<Prod>a\\<in>as. a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n  (\\<Prod>a\\<in>as. a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"?q * \\<dots> = (\\<Prod> a \\<in> ?as. a ^ Suc (?f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q *\n    (\\<Prod>a\\<in>as.\n       a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a)) =\n    (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n       a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))", "by (subst prod.insert, insert as False, auto)"], ["proof (state)\nthis:\n  smult ((1::'a) / c) q *\n  (\\<Prod>a\\<in>as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a)) =\n  (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "finally"], ["proof (chain)\npicking this:\n  p =\n  (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))", "have p: \"p = (\\<Prod> a \\<in> ?as. a ^ Suc (?f a))\""], ["proof (prove)\nusing this:\n  p =\n  (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n       a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))", "."], ["proof (state)\nthis:\n  p =\n  (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from as(1)"], ["proof (chain)\npicking this:\n  finite as", "have fin: \"finite ?as\""], ["proof (prove)\nusing this:\n  finite as\n\ngoal (1 subgoal):\n 1. finite (insert (smult ((1::'a) / c) q) as)", "by auto"], ["proof (state)\nthis:\n  finite (insert (smult ((1::'a) / c) q) as)\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from as mon irred"], ["proof (chain)\npicking this:\n  finite as\n  smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a))\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n  monic (smult ((1::'a) / c) q)\n  irreducible (smult ((1::'a) / c) q)", "have Q: \"?as \\<subseteq> ?Q\""], ["proof (prove)\nusing this:\n  finite as\n  smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a))\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n  monic (smult ((1::'a) / c) q)\n  irreducible (smult ((1::'a) / c) q)\n\ngoal (1 subgoal):\n 1. insert (smult ((1::'a) / c) q) as\n    \\<subseteq> {q. irreducible q \\<and> monic q}", "by auto"], ["proof (state)\nthis:\n  insert (smult ((1::'a) / c) q) as\n  \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (2 subgoals):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}\n 2. smult ((1::'a) / c) q \\<notin> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "from fin p Q"], ["proof (chain)\npicking this:\n  finite (insert (smult ((1::'a) / c) q) as)\n  p =\n  (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))\n  insert (smult ((1::'a) / c) q) as\n  \\<subseteq> {q. irreducible q \\<and> monic q}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (insert (smult ((1::'a) / c) q) as)\n  p =\n  (\\<Prod>a\\<in>insert (smult ((1::'a) / c) q) as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then 0 else f a))\n  insert (smult ((1::'a) / c) q) as\n  \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "by(intro exI[of _ ?as] exI[of _ ?f], auto)"], ["proof (state)\nthis:\n  \\<exists>as f.\n     finite as \\<and>\n     p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "case True"], ["proof (state)\nthis:\n  smult ((1::'a) / c) q \\<in> as\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "let ?f = \"\\<lambda> a. if a = ?q then Suc (f a) else f a\""], ["proof (state)\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"p = ?q * (\\<Prod> a \\<in>as. a ^ Suc (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))", "unfolding p as"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n    smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))", "by simp"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "also"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) q * (\\<Prod>a\\<in>as. a ^ Suc (f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"(\\<Prod> a \\<in>as. a ^ Suc (f a)) = ?q ^ Suc (f ?q) * (\\<Prod> a \\<in>(as - {?q}). a ^ Suc (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n    smult ((1::'a) / c) q ^ Suc (f (smult ((1::'a) / c) q)) *\n    (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}. a ^ Suc (f a))", "by (subst prod.remove[OF _ True], insert as, auto)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n  smult ((1::'a) / c) q ^ Suc (f (smult ((1::'a) / c) q)) *\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}. a ^ Suc (f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n  smult ((1::'a) / c) q ^ Suc (f (smult ((1::'a) / c) q)) *\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}. a ^ Suc (f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"(\\<Prod> a \\<in>(as - {?q}). a ^ Suc (f a)) = (\\<Prod> a \\<in>(as - {?q}). a ^ Suc (?f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}. a ^ Suc (f a)) =\n    (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n       a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))", "by (rule prod.cong, auto)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}. a ^ Suc (f a)) =\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}. a ^ Suc (f a)) =\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"?q * (?q ^ Suc (f ?q) * \\<dots> ) = ?q ^ Suc (?f ?q) * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q *\n    (smult ((1::'a) / c) q ^ Suc (f (smult ((1::'a) / c) q)) *\n     (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n        a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))) =\n    smult ((1::'a) / c) q ^\n    Suc (if smult ((1::'a) / c) q = smult ((1::'a) / c) q\n         then Suc (f (smult ((1::'a) / c) q))\n         else f (smult ((1::'a) / c) q)) *\n    (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n       a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  smult ((1::'a) / c) q *\n  (smult ((1::'a) / c) q ^ Suc (f (smult ((1::'a) / c) q)) *\n   (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n      a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))) =\n  smult ((1::'a) / c) q ^\n  Suc (if smult ((1::'a) / c) q = smult ((1::'a) / c) q\n       then Suc (f (smult ((1::'a) / c) q))\n       else f (smult ((1::'a) / c) q)) *\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "also"], ["proof (state)\nthis:\n  smult ((1::'a) / c) q *\n  (smult ((1::'a) / c) q ^ Suc (f (smult ((1::'a) / c) q)) *\n   (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n      a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))) =\n  smult ((1::'a) / c) q ^\n  Suc (if smult ((1::'a) / c) q = smult ((1::'a) / c) q\n       then Suc (f (smult ((1::'a) / c) q))\n       else f (smult ((1::'a) / c) q)) *\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"\\<dots> = (\\<Prod> a \\<in> as. a ^ Suc (?f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q ^\n    Suc (if smult ((1::'a) / c) q = smult ((1::'a) / c) q\n         then Suc (f (smult ((1::'a) / c) q))\n         else f (smult ((1::'a) / c) q)) *\n    (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n       a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a)) =\n    (\\<Prod>a\\<in>as.\n       a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))", "by (subst prod.remove[OF _ True], insert as, auto)"], ["proof (state)\nthis:\n  smult ((1::'a) / c) q ^\n  Suc (if smult ((1::'a) / c) q = smult ((1::'a) / c) q\n       then Suc (f (smult ((1::'a) / c) q))\n       else f (smult ((1::'a) / c) q)) *\n  (\\<Prod>a\\<in>as - {smult ((1::'a) / c) q}.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a)) =\n  (\\<Prod>a\\<in>as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "finally"], ["proof (chain)\npicking this:\n  p =\n  (\\<Prod>a\\<in>as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))", "have \"p = (\\<Prod> a \\<in> as. a ^ Suc (?f a))\""], ["proof (prove)\nusing this:\n  p =\n  (\\<Prod>a\\<in>as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Prod>a\\<in>as.\n       a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))", "."], ["proof (state)\nthis:\n  p =\n  (\\<Prod>a\\<in>as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. smult ((1::'a) / c) q \\<in> as \\<Longrightarrow>\n    \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "with as"], ["proof (chain)\npicking this:\n  finite as\n  smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a))\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n  p =\n  (\\<Prod>a\\<in>as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite as\n  smult c r = (\\<Prod>a\\<in>as. a ^ Suc (f a))\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n  p =\n  (\\<Prod>a\\<in>as.\n     a ^ Suc (if a = smult ((1::'a) / c) q then Suc (f a) else f a))\n\ngoal (1 subgoal):\n 1. \\<exists>as f.\n       finite as \\<and>\n       p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n       as \\<subseteq> {q. irreducible q \\<and> monic q}", "by (intro exI[of _ as] exI[of _ ?f], auto)"], ["proof (state)\nthis:\n  \\<exists>as f.\n     finite as \\<and>\n     p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as f.\n     finite as \\<and>\n     p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as f.\n     finite as \\<and>\n     p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_irreducible_gcd: \n  \"monic (f::'a::{field,euclidean_ring_gcd,semiring_gcd_mult_normalize,\n                  normalization_euclidean_semiring_multiplicative} poly) \\<Longrightarrow>\n   irreducible f \\<Longrightarrow> gcd f u \\<in> {1,f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monic f; irreducible f\\<rbrakk>\n    \\<Longrightarrow> gcd f u \\<in> {1, f}", "by (metis gcd_dvd1 irreducible_altdef insertCI is_unit_gcd_iff poly_dvd_antisym poly_gcd_monic)"], ["", "end"]]}