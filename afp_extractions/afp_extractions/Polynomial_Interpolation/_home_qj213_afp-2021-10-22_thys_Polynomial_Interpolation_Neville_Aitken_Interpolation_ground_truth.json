{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Neville_Aitken_Interpolation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma neville_aitken_main: assumes dist: \"\\<And> i j. i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> x i \\<noteq> x j\"\n  shows \"i \\<le> k \\<Longrightarrow> k \\<le> j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> poly (neville_aitken_main i j) (x k) = (f k)\"", "lemma degree_neville_aitken_main: \"degree (neville_aitken_main i j) \\<le> j - i\"", "lemma degree_neville_aitken: \"degree (neville_aitken n) \\<le> n\"", "lemma length_neville_aitken_merge[termination_simp]: \"length (neville_aitken_merge xs) = length xs - 1\"", "lemma neville_aitken_merge: \n  \"xs = map (\\<lambda> i. (x i, x (i + j), neville_aitken_main i (i + j)))  [l ..< Suc (l + k)] \n   \\<Longrightarrow> neville_aitken_merge xs\n       = (map (\\<lambda> i. (x i, x (i + Suc j), neville_aitken_main i (i + Suc j))) [l ..< l + k])\"", "lemma neville_aitken_impl_main: \n  \"xs = map (\\<lambda> i. (x i, x (i + j), neville_aitken_main i (i + j)))  [l ..< Suc (l + k)] \n   \\<Longrightarrow> neville_aitken_impl_main xs = neville_aitken_main l (l + j + k)\"", "lemma neville_aitken_impl:\n  \"xs = map (\\<lambda> i. (x i, x i, [:f i:]))  [0 ..< Suc k] \n   \\<Longrightarrow> neville_aitken_impl_main xs = neville_aitken k\"", "lemma neville_aitken: assumes \"\\<And> i j. i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> x i \\<noteq> x j\"\n  shows \"j \\<le> n \\<Longrightarrow> poly (neville_aitken x f n) (x j) = (f j)\"", "lemma neville_aitken_interpolation_impl: assumes \"x_fs \\<noteq> []\"\n  shows \"neville_aitken_interpolation_poly x_fs =\n  neville_aitken (\\<lambda> i. fst (x_fs ! i)) (\\<lambda> i. snd (x_fs ! i)) (length x_fs - 1)\"", "lemma neville_aitken_interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = neville_aitken_interpolation_poly xs_ys\"\n  and xy: \"(x,y) \\<in> set xs_ys\"\n  shows \"poly p x = y\"", "lemma degree_neville_aitken_interpolation_poly:  \n  shows \"degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\""], "translations": [["", "lemma neville_aitken_main: assumes dist: \"\\<And> i j. i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> x i \\<noteq> x j\"\n  shows \"i \\<le> k \\<Longrightarrow> k \\<le> j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> poly (neville_aitken_main i j) (x k) = (f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> k; k \\<le> j; j \\<le> n\\<rbrakk>\n    \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "proof (induct i j arbitrary: k rule: neville_aitken_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>i < j; i + 1 \\<le> k; k \\<le> j;\n                    j \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> poly\n(local.neville_aitken_main (i + 1) j) (x k) =\n                                     f k;\n        \\<And>k.\n           \\<lbrakk>i < j; i \\<le> k; k \\<le> j - 1; j - 1 \\<le> n\\<rbrakk>\n           \\<Longrightarrow> poly (local.neville_aitken_main i (j - 1))\n                              (x k) =\n                             f k;\n        i \\<le> k; k \\<le> j; j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "case (1 i j k)"], ["proof (state)\nthis:\n  \\<lbrakk>i < j; i + 1 \\<le> ?k; ?k \\<le> j; j \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main (i + 1) j) (x ?k) = f ?k\n  \\<lbrakk>i < j; i \\<le> ?k; ?k \\<le> j - 1; j - 1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main i (j - 1)) (x ?k) = f ?k\n  i \\<le> k\n  k \\<le> j\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>i < j; i + 1 \\<le> k; k \\<le> j;\n                    j \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> poly\n(local.neville_aitken_main (i + 1) j) (x k) =\n                                     f k;\n        \\<And>k.\n           \\<lbrakk>i < j; i \\<le> k; k \\<le> j - 1; j - 1 \\<le> n\\<rbrakk>\n           \\<Longrightarrow> poly (local.neville_aitken_main i (j - 1))\n                              (x k) =\n                             f k;\n        i \\<le> k; k \\<le> j; j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "note neville_aitken_main.simps[of i j, simp]"], ["proof (state)\nthis:\n  local.neville_aitken_main i j =\n  (if i < j\n   then smult (inverse (x j - x i))\n         (X i * local.neville_aitken_main (i + 1) j -\n          X j * local.neville_aitken_main i (j - 1))\n   else [:f i:])\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>i < j; i + 1 \\<le> k; k \\<le> j;\n                    j \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> poly\n(local.neville_aitken_main (i + 1) j) (x k) =\n                                     f k;\n        \\<And>k.\n           \\<lbrakk>i < j; i \\<le> k; k \\<le> j - 1; j - 1 \\<le> n\\<rbrakk>\n           \\<Longrightarrow> poly (local.neville_aitken_main i (j - 1))\n                              (x k) =\n                             f k;\n        i \\<le> k; k \\<le> j; j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.neville_aitken_main i j) (x k) = f k", "proof (cases \"i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k\n 2. \\<not> i < j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "case False"], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k\n 2. \\<not> i < j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "with 1(3-)"], ["proof (chain)\npicking this:\n  i \\<le> k\n  k \\<le> j\n  j \\<le> n\n  \\<not> i < j", "have \"k = i\""], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n  j \\<le> n\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. k = i", "by auto"], ["proof (state)\nthis:\n  k = i\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k\n 2. \\<not> i < j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "with False"], ["proof (chain)\npicking this:\n  \\<not> i < j\n  k = i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < j\n  k = i\n\ngoal (1 subgoal):\n 1. poly (local.neville_aitken_main i j) (x k) = f k", "by auto"], ["proof (state)\nthis:\n  poly (local.neville_aitken_main i j) (x k) = f k\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "note ij = this"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "from dist[OF True 1(5)]"], ["proof (chain)\npicking this:\n  x i \\<noteq> x j", "have diff: \"x i \\<noteq> x j\""], ["proof (prove)\nusing this:\n  x i \\<noteq> x j\n\ngoal (1 subgoal):\n 1. x i \\<noteq> x j", "by auto"], ["proof (state)\nthis:\n  x i \\<noteq> x j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "from True"], ["proof (chain)\npicking this:\n  i < j", "have id: \"neville_aitken_main i j = \n      (smult (inverse (x j - x i)) (X i * neville_aitken_main (i + 1) j - X j \n        * neville_aitken_main i (j - 1)))\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. local.neville_aitken_main i j =\n    smult (inverse (x j - x i))\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))", "by simp"], ["proof (state)\nthis:\n  local.neville_aitken_main i j =\n  smult (inverse (x j - x i))\n   (X i * local.neville_aitken_main (i + 1) j -\n    X j * local.neville_aitken_main i (j - 1))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "note IH = 1(1-2)[OF True]"], ["proof (state)\nthis:\n  \\<lbrakk>i + 1 \\<le> ?k; ?k \\<le> j; j \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main (i + 1) j) (x ?k) = f ?k\n  \\<lbrakk>i \\<le> ?k; ?k \\<le> j - 1; j - 1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main i (j - 1)) (x ?k) = f ?k\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.neville_aitken_main i j) (x k) = f k", "proof (cases \"k = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k\n 2. k \\<noteq> i \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "case True"], ["proof (state)\nthis:\n  k = i\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k\n 2. k \\<noteq> i \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.neville_aitken_main i j) (x k) = f k", "unfolding id True poly_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (x j - x i) *\n    poly\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))\n     (x i) =\n    f i", "using IH(2)[of i] ij 1(3-) diff"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> i; i \\<le> j - 1; j - 1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main i (j - 1)) (x i) = f i\n  i < j\n  i \\<le> k\n  k \\<le> j\n  j \\<le> n\n  x i \\<noteq> x j\n\ngoal (1 subgoal):\n 1. inverse (x j - x i) *\n    poly\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))\n     (x i) =\n    f i", "by (simp add: X_def field_simps)"], ["proof (state)\nthis:\n  poly (local.neville_aitken_main i j) (x k) = f k\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "note ki = this"], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.neville_aitken_main i j) (x k) = f k", "proof (cases \"k = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k\n 2. k \\<noteq> j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "case True"], ["proof (state)\nthis:\n  k = j\n\ngoal (2 subgoals):\n 1. k = j \\<Longrightarrow> poly (local.neville_aitken_main i j) (x k) = f k\n 2. k \\<noteq> j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (local.neville_aitken_main i j) (x k) = f k", "unfolding id True poly_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (x j - x i) *\n    poly\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))\n     (x j) =\n    f j", "using IH(1)[of j] ij 1(3-) diff"], ["proof (prove)\nusing this:\n  \\<lbrakk>i + 1 \\<le> j; j \\<le> j; j \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main (i + 1) j) (x j) = f j\n  i < j\n  i \\<le> k\n  k \\<le> j\n  j \\<le> n\n  x i \\<noteq> x j\n\ngoal (1 subgoal):\n 1. inverse (x j - x i) *\n    poly\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))\n     (x j) =\n    f j", "by (simp add: X_def field_simps)"], ["proof (state)\nthis:\n  poly (local.neville_aitken_main i j) (x k) = f k\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> j\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    poly (local.neville_aitken_main i j) (x k) = f k", "with ki"], ["proof (chain)\npicking this:\n  k \\<noteq> i\n  k \\<noteq> j", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  k \\<noteq> j\n\ngoal (1 subgoal):\n 1. poly (local.neville_aitken_main i j) (x k) = f k", "unfolding id poly_smult"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  k \\<noteq> j\n\ngoal (1 subgoal):\n 1. inverse (x j - x i) *\n    poly\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))\n     (x k) =\n    f k", "using IH(1-2)[of k] ij 1(3-) diff"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  k \\<noteq> j\n  \\<lbrakk>i + 1 \\<le> k; k \\<le> j; j \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main (i + 1) j) (x k) = f k\n  \\<lbrakk>i \\<le> k; k \\<le> j - 1; j - 1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> poly (local.neville_aitken_main i (j - 1)) (x k) = f k\n  i < j\n  i \\<le> k\n  k \\<le> j\n  j \\<le> n\n  x i \\<noteq> x j\n\ngoal (1 subgoal):\n 1. inverse (x j - x i) *\n    poly\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))\n     (x k) =\n    f k", "by (simp add: X_def field_simps)"], ["proof (state)\nthis:\n  poly (local.neville_aitken_main i j) (x k) = f k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (local.neville_aitken_main i j) (x k) = f k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (local.neville_aitken_main i j) (x k) = f k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (local.neville_aitken_main i j) (x k) = f k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_neville_aitken_main: \"degree (neville_aitken_main i j) \\<le> j - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (local.neville_aitken_main i j) \\<le> j - i", "proof (induct i j rule: neville_aitken_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j \\<Longrightarrow>\n                degree (local.neville_aitken_main (i + 1) j)\n                \\<le> j - (i + 1);\n        i < j \\<Longrightarrow>\n        degree (local.neville_aitken_main i (j - 1))\n        \\<le> j - 1 - i\\<rbrakk>\n       \\<Longrightarrow> degree (local.neville_aitken_main i j) \\<le> j - i", "case (1 i j)"], ["proof (state)\nthis:\n  i < j \\<Longrightarrow>\n  degree (local.neville_aitken_main (i + 1) j) \\<le> j - (i + 1)\n  i < j \\<Longrightarrow>\n  degree (local.neville_aitken_main i (j - 1)) \\<le> j - 1 - i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j \\<Longrightarrow>\n                degree (local.neville_aitken_main (i + 1) j)\n                \\<le> j - (i + 1);\n        i < j \\<Longrightarrow>\n        degree (local.neville_aitken_main i (j - 1))\n        \\<le> j - 1 - i\\<rbrakk>\n       \\<Longrightarrow> degree (local.neville_aitken_main i j) \\<le> j - i", "note simp = neville_aitken_main.simps[of i j]"], ["proof (state)\nthis:\n  local.neville_aitken_main i j =\n  (if i < j\n   then smult (inverse (x j - x i))\n         (X i * local.neville_aitken_main (i + 1) j -\n          X j * local.neville_aitken_main i (j - 1))\n   else [:f i:])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j \\<Longrightarrow>\n                degree (local.neville_aitken_main (i + 1) j)\n                \\<le> j - (i + 1);\n        i < j \\<Longrightarrow>\n        degree (local.neville_aitken_main i (j - 1))\n        \\<le> j - 1 - i\\<rbrakk>\n       \\<Longrightarrow> degree (local.neville_aitken_main i j) \\<le> j - i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (local.neville_aitken_main i j) \\<le> j - i", "proof (cases \"i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i\n 2. \\<not> i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "case False"], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i\n 2. \\<not> i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. degree (local.neville_aitken_main i j) \\<le> j - i", "unfolding simp"], ["proof (prove)\nusing this:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. degree\n     (if i < j\n      then smult (inverse (x j - x i))\n            (X i * local.neville_aitken_main (i + 1) j -\n             X j * local.neville_aitken_main i (j - 1))\n      else [:f i:])\n    \\<le> j - i", "by simp"], ["proof (state)\nthis:\n  degree (local.neville_aitken_main i j) \\<le> j - i\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "note IH = 1[OF this]"], ["proof (state)\nthis:\n  degree (local.neville_aitken_main (i + 1) j) \\<le> j - (i + 1)\n  degree (local.neville_aitken_main i (j - 1)) \\<le> j - 1 - i\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "let ?n = neville_aitken_main"], ["proof (state)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have X: \"\\<And> i. degree (X i) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. degree (X i) = Suc 0", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. degree [:- x i, 1::'a:] = Suc 0", "by auto"], ["proof (state)\nthis:\n  degree (X ?i) = Suc 0\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have \"degree (X i * ?n (i + 1) j) \\<le> Suc (degree (?n (i+1) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (X i * local.neville_aitken_main (i + 1) j)\n    \\<le> Suc (degree (local.neville_aitken_main (i + 1) j))", "by (rule order.trans[OF degree_mult_le], simp add: X)"], ["proof (state)\nthis:\n  degree (X i * local.neville_aitken_main (i + 1) j)\n  \\<le> Suc (degree (local.neville_aitken_main (i + 1) j))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "also"], ["proof (state)\nthis:\n  degree (X i * local.neville_aitken_main (i + 1) j)\n  \\<le> Suc (degree (local.neville_aitken_main (i + 1) j))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have \"\\<dots> \\<le> Suc (j - (i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (degree (local.neville_aitken_main (i + 1) j))\n    \\<le> Suc (j - (i + 1))", "using IH(1)"], ["proof (prove)\nusing this:\n  degree (local.neville_aitken_main (i + 1) j) \\<le> j - (i + 1)\n\ngoal (1 subgoal):\n 1. Suc (degree (local.neville_aitken_main (i + 1) j))\n    \\<le> Suc (j - (i + 1))", "by simp"], ["proof (state)\nthis:\n  Suc (degree (local.neville_aitken_main (i + 1) j)) \\<le> Suc (j - (i + 1))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "finally"], ["proof (chain)\npicking this:\n  degree (X i * local.neville_aitken_main (i + 1) j) \\<le> Suc (j - (i + 1))", "have 1: \"degree (X i * ?n (i + 1) j) \\<le> j - i\""], ["proof (prove)\nusing this:\n  degree (X i * local.neville_aitken_main (i + 1) j) \\<le> Suc (j - (i + 1))\n\ngoal (1 subgoal):\n 1. degree (X i * local.neville_aitken_main (i + 1) j) \\<le> j - i", "using True"], ["proof (prove)\nusing this:\n  degree (X i * local.neville_aitken_main (i + 1) j) \\<le> Suc (j - (i + 1))\n  i < j\n\ngoal (1 subgoal):\n 1. degree (X i * local.neville_aitken_main (i + 1) j) \\<le> j - i", "by auto"], ["proof (state)\nthis:\n  degree (X i * local.neville_aitken_main (i + 1) j) \\<le> j - i\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have \"degree (X j * ?n i (j - 1)) \\<le> Suc (degree (?n i (j - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (X j * local.neville_aitken_main i (j - 1))\n    \\<le> Suc (degree (local.neville_aitken_main i (j - 1)))", "by (rule order.trans[OF degree_mult_le], simp add: X)"], ["proof (state)\nthis:\n  degree (X j * local.neville_aitken_main i (j - 1))\n  \\<le> Suc (degree (local.neville_aitken_main i (j - 1)))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "also"], ["proof (state)\nthis:\n  degree (X j * local.neville_aitken_main i (j - 1))\n  \\<le> Suc (degree (local.neville_aitken_main i (j - 1)))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have \"\\<dots> \\<le> Suc ((j - 1) - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (degree (local.neville_aitken_main i (j - 1))) \\<le> Suc (j - 1 - i)", "using IH(2)"], ["proof (prove)\nusing this:\n  degree (local.neville_aitken_main i (j - 1)) \\<le> j - 1 - i\n\ngoal (1 subgoal):\n 1. Suc (degree (local.neville_aitken_main i (j - 1))) \\<le> Suc (j - 1 - i)", "by simp"], ["proof (state)\nthis:\n  Suc (degree (local.neville_aitken_main i (j - 1))) \\<le> Suc (j - 1 - i)\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "finally"], ["proof (chain)\npicking this:\n  degree (X j * local.neville_aitken_main i (j - 1)) \\<le> Suc (j - 1 - i)", "have 2: \"degree (X j * ?n i (j - 1)) \\<le> j - i\""], ["proof (prove)\nusing this:\n  degree (X j * local.neville_aitken_main i (j - 1)) \\<le> Suc (j - 1 - i)\n\ngoal (1 subgoal):\n 1. degree (X j * local.neville_aitken_main i (j - 1)) \\<le> j - i", "using True"], ["proof (prove)\nusing this:\n  degree (X j * local.neville_aitken_main i (j - 1)) \\<le> Suc (j - 1 - i)\n  i < j\n\ngoal (1 subgoal):\n 1. degree (X j * local.neville_aitken_main i (j - 1)) \\<le> j - i", "by auto"], ["proof (state)\nthis:\n  degree (X j * local.neville_aitken_main i (j - 1)) \\<le> j - i\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have id: \"?n i j = smult (inverse (x j - x i))\n            (X i * ?n (i + 1) j - X j * ?n i (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.neville_aitken_main i j =\n    smult (inverse (x j - x i))\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))", "unfolding simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < j\n     then smult (inverse (x j - x i))\n           (X i * local.neville_aitken_main (i + 1) j -\n            X j * local.neville_aitken_main i (j - 1))\n     else [:f i:]) =\n    smult (inverse (x j - x i))\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))", "using True"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (if i < j\n     then smult (inverse (x j - x i))\n           (X i * local.neville_aitken_main (i + 1) j -\n            X j * local.neville_aitken_main i (j - 1))\n     else [:f i:]) =\n    smult (inverse (x j - x i))\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))", "by simp"], ["proof (state)\nthis:\n  local.neville_aitken_main i j =\n  smult (inverse (x j - x i))\n   (X i * local.neville_aitken_main (i + 1) j -\n    X j * local.neville_aitken_main i (j - 1))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have \"degree (?n i j) \\<le> degree (X i * ?n (i + 1) j - X j * ?n i (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (local.neville_aitken_main i j)\n    \\<le> degree\n           (X i * local.neville_aitken_main (i + 1) j -\n            X j * local.neville_aitken_main i (j - 1))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (smult (inverse (x j - x i))\n       (X i * local.neville_aitken_main (i + 1) j -\n        X j * local.neville_aitken_main i (j - 1)))\n    \\<le> degree\n           (X i * local.neville_aitken_main (i + 1) j -\n            X j * local.neville_aitken_main i (j - 1))", "by simp"], ["proof (state)\nthis:\n  degree (local.neville_aitken_main i j)\n  \\<le> degree\n         (X i * local.neville_aitken_main (i + 1) j -\n          X j * local.neville_aitken_main i (j - 1))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "also"], ["proof (state)\nthis:\n  degree (local.neville_aitken_main i j)\n  \\<le> degree\n         (X i * local.neville_aitken_main (i + 1) j -\n          X j * local.neville_aitken_main i (j - 1))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have \"\\<dots> \\<le> max (degree (X i * ?n (i + 1) j)) (degree (X j * ?n i (j - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (X i * local.neville_aitken_main (i + 1) j -\n      X j * local.neville_aitken_main i (j - 1))\n    \\<le> max (degree (X i * local.neville_aitken_main (i + 1) j))\n           (degree (X j * local.neville_aitken_main i (j - 1)))", "by (rule degree_diff_le_max)"], ["proof (state)\nthis:\n  degree\n   (X i * local.neville_aitken_main (i + 1) j -\n    X j * local.neville_aitken_main i (j - 1))\n  \\<le> max (degree (X i * local.neville_aitken_main (i + 1) j))\n         (degree (X j * local.neville_aitken_main i (j - 1)))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "also"], ["proof (state)\nthis:\n  degree\n   (X i * local.neville_aitken_main (i + 1) j -\n    X j * local.neville_aitken_main i (j - 1))\n  \\<le> max (degree (X i * local.neville_aitken_main (i + 1) j))\n         (degree (X j * local.neville_aitken_main i (j - 1)))\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "have \"\\<dots> \\<le> j - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (degree (X i * local.neville_aitken_main (i + 1) j))\n     (degree (X j * local.neville_aitken_main i (j - 1)))\n    \\<le> j - i", "using 1 2"], ["proof (prove)\nusing this:\n  degree (X i * local.neville_aitken_main (i + 1) j) \\<le> j - i\n  degree (X j * local.neville_aitken_main i (j - 1)) \\<le> j - i\n\ngoal (1 subgoal):\n 1. max (degree (X i * local.neville_aitken_main (i + 1) j))\n     (degree (X j * local.neville_aitken_main i (j - 1)))\n    \\<le> j - i", "by auto"], ["proof (state)\nthis:\n  max (degree (X i * local.neville_aitken_main (i + 1) j))\n   (degree (X j * local.neville_aitken_main i (j - 1)))\n  \\<le> j - i\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    degree (local.neville_aitken_main i j) \\<le> j - i", "finally"], ["proof (chain)\npicking this:\n  degree (local.neville_aitken_main i j) \\<le> j - i", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (local.neville_aitken_main i j) \\<le> j - i\n\ngoal (1 subgoal):\n 1. degree (local.neville_aitken_main i j) \\<le> j - i", "."], ["proof (state)\nthis:\n  degree (local.neville_aitken_main i j) \\<le> j - i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (local.neville_aitken_main i j) \\<le> j - i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_neville_aitken: \"degree (neville_aitken n) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (local.neville_aitken n) \\<le> n", "unfolding neville_aitken_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (local.neville_aitken_main 0 n) \\<le> n", "using degree_neville_aitken_main[of 0 n]"], ["proof (prove)\nusing this:\n  degree (local.neville_aitken_main 0 n) \\<le> n - 0\n\ngoal (1 subgoal):\n 1. degree (local.neville_aitken_main 0 n) \\<le> n", "by simp"], ["", "fun neville_aitken_merge :: \"('a \\<times> 'a \\<times> 'a poly) list \\<Rightarrow> ('a \\<times> 'a \\<times> 'a poly) list\" where\n  \"neville_aitken_merge ((xi,xj,p_ij) # (xsi,xsj,p_sisj) # rest) = \n     (xi,xsj, smult (inverse (xsj - xi)) ([:-xi,1:] * p_sisj\n      + [:xsj,-1:] * p_ij)) # neville_aitken_merge ((xsi,xsj,p_sisj) # rest)\"\n| \"neville_aitken_merge [_] = []\"\n| \"neville_aitken_merge [] = []\""], ["", "lemma length_neville_aitken_merge[termination_simp]: \"length (neville_aitken_merge xs) = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (local.neville_aitken_merge xs) = length xs - 1", "by (induct xs rule: neville_aitken_merge.induct, auto)"], ["", "fun neville_aitken_impl_main :: \"('a \\<times> 'a \\<times> 'a poly) list \\<Rightarrow> 'a poly\" where\n  \"neville_aitken_impl_main (e1 # e2 # es) = \n     neville_aitken_impl_main (neville_aitken_merge (e1 # e2 # es))\"\n| \"neville_aitken_impl_main [(_,_,p)] = p\"\n| \"neville_aitken_impl_main [] = 0\""], ["", "lemma neville_aitken_merge: \n  \"xs = map (\\<lambda> i. (x i, x (i + j), neville_aitken_main i (i + j)))  [l ..< Suc (l + k)] \n   \\<Longrightarrow> neville_aitken_merge xs\n       = (map (\\<lambda> i. (x i, x (i + Suc j), neville_aitken_main i (i + Suc j))) [l ..< l + k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n     [l..<Suc (l + k)] \\<Longrightarrow>\n    local.neville_aitken_merge xs =\n    map (\\<lambda>i.\n            (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n     [l..<l + k]", "proof (induct xs arbitrary: l k rule: neville_aitken_merge.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "case (1 xi xj p_ij xsi xsj p_sisj rest l k)"], ["proof (state)\nthis:\n  (xsi, xsj, p_sisj) # rest =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [?l..<Suc (?l + ?k)] \\<Longrightarrow>\n  local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n  map (\\<lambda>i.\n          (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n   [?l..<?l + ?k]\n  (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [l..<Suc (l + k)]\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "let ?n = neville_aitken_main"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "let ?f = \"\\<lambda> j i. (x i, x (i + j), ?n i (i + j))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "define f where \"f = ?f\""], ["proof (state)\nthis:\n  f = (\\<lambda>j i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "let ?map = \"\\<lambda> j. map (?f j)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "note res = 1(2)"], ["proof (state)\nthis:\n  (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [l..<Suc (l + k)]\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "from arg_cong[OF res, of length]"], ["proof (chain)\npicking this:\n  length ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n  length\n   (map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n     [l..<Suc (l + k)])", "obtain kk where k: \"k = Suc kk\""], ["proof (prove)\nusing this:\n  length ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n  length\n   (map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n     [l..<Suc (l + k)])\n\ngoal (1 subgoal):\n 1. (\\<And>kk. k = Suc kk \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases k, auto)"], ["proof (state)\nthis:\n  k = Suc kk\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "hence id: \"[l..<Suc (l + k)] = l # [Suc l ..< Suc (Suc l + kk)]\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. [l..<Suc (l + k)] = l # [Suc l..<Suc (Suc l + kk)]", "by (simp add: upt_rec)"], ["proof (state)\nthis:\n  [l..<Suc (l + k)] = l # [Suc l..<Suc (Suc l + kk)]\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "from res[unfolded id]"], ["proof (chain)\npicking this:\n  (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   (l # [Suc l..<Suc (Suc l + kk)])", "have id2: \"(xsi, xsj, p_sisj) # rest =\n    ?map j [Suc l..< Suc (Suc l + kk)]\" \n    and id3: \"xi = x l\" \"xj = x (l + j)\" \"p_ij = ?n l (l + j)\" \n        \"xsi = x (Suc l)\" \"xsj = x (Suc (l + j))\" \"p_sisj = ?n (Suc l) (Suc (l + j))\""], ["proof (prove)\nusing this:\n  (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   (l # [Suc l..<Suc (Suc l + kk)])\n\ngoal (1 subgoal):\n 1. (xsi, xsj, p_sisj) # rest =\n    map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n     [Suc l..<Suc (Suc l + kk)] &&&\n    (xi = x l &&&\n     xj = x (l + j) &&& p_ij = local.neville_aitken_main l (l + j)) &&&\n    xsi = x (Suc l) &&&\n    xsj = x (Suc (l + j)) &&&\n    p_sisj = local.neville_aitken_main (Suc l) (Suc (l + j))", "by (auto simp: upt_rec)"], ["proof (state)\nthis:\n  (xsi, xsj, p_sisj) # rest =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [Suc l..<Suc (Suc l + kk)]\n  xi = x l\n  xj = x (l + j)\n  p_ij = local.neville_aitken_main l (l + j)\n  xsi = x (Suc l)\n  xsj = x (Suc (l + j))\n  p_sisj = local.neville_aitken_main (Suc l) (Suc (l + j))\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "note IH = 1(1)[OF id2]"], ["proof (state)\nthis:\n  local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n  map (\\<lambda>i.\n          (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n   [Suc l..<Suc l + kk]\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "have X: \"[:x (Suc (l + j)), - 1:] = - X (Suc l + j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:x (Suc (l + j)), - (1::'a):] = - X (Suc l + j)", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:x (Suc (l + j)), - (1::'a):] = - [:- x (Suc l + j), 1::'a:]", "by simp"], ["proof (state)\nthis:\n  [:x (Suc (l + j)), - (1::'a):] = - X (Suc l + j)\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "have id4: \"(xi, xsj, smult (inverse (xsj - xi)) ([:- xi, 1:] * p_sisj +\n     [:xsj, - 1:] * p_ij)) = (x l, x (l + Suc j), ?n l (l + Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xi, xsj,\n     smult (inverse (xsj - xi))\n      ([:- xi, 1::'a:] * p_sisj + [:xsj, - (1::'a):] * p_ij)) =\n    (x l, x (l + Suc j), local.neville_aitken_main l (l + Suc j))", "unfolding id3 neville_aitken_main.simps[of l \"l + Suc j\"] \n      X_def[symmetric] X"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x l, x (Suc (l + j)),\n     smult (inverse (x (Suc (l + j)) - x l))\n      (X l * local.neville_aitken_main (Suc l) (Suc (l + j)) +\n       - X (Suc l + j) * local.neville_aitken_main l (l + j))) =\n    (x l, x (l + Suc j),\n     if l < l + Suc j\n     then smult (inverse (x (l + Suc j) - x l))\n           (X l * local.neville_aitken_main (l + 1) (l + Suc j) -\n            X (l + Suc j) * local.neville_aitken_main l (l + Suc j - 1))\n     else [:f l:])", "by simp"], ["proof (state)\nthis:\n  (xi, xsj,\n   smult (inverse (xsj - xi))\n    ([:- xi, 1::'a:] * p_sisj + [:xsj, - (1::'a):] * p_ij)) =\n  (x l, x (l + Suc j), local.neville_aitken_main l (l + Suc j))\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "have id5: \"[l..<l + k] = l # [Suc l ..< Suc l + kk]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [l..<l + k] = l # [Suc l..<Suc l + kk]", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. [l..<l + Suc kk] = l # [Suc l..<Suc l + kk]", "by (simp add: upt_rec)"], ["proof (state)\nthis:\n  [l..<l + k] = l # [Suc l..<Suc l + kk]\n\ngoal (3 subgoals):\n 1. \\<And>xi xj p_ij xsi xsj p_sisj rest l k.\n       \\<lbrakk>\\<And>l k.\n                   (xsi, xsj, p_sisj) # rest =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_merge ((xsi, xsj, p_sisj) # rest) =\n                   map (\\<lambda>i.\n                           (x i, x (i + Suc j),\n                            local.neville_aitken_main i (i + Suc j)))\n                    [l..<l + k];\n        (xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_merge\n                          ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n                         map (\\<lambda>i.\n                                 (x i, x (i + Suc j),\n                                  local.neville_aitken_main i (i + Suc j)))\n                          [l..<l + k]\n 2. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 3. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.neville_aitken_merge\n     ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n    map (\\<lambda>i.\n            (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n     [l..<l + k]", "unfolding neville_aitken_merge.simps IH id4"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x l, x (l + Suc j), local.neville_aitken_main l (l + Suc j)) #\n    map (\\<lambda>i.\n            (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n     [Suc l..<Suc l + kk] =\n    map (\\<lambda>i.\n            (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n     [l..<l + k]", "unfolding id5"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x l, x (l + Suc j), local.neville_aitken_main l (l + Suc j)) #\n    map (\\<lambda>i.\n            (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n     [Suc l..<Suc l + kk] =\n    map (\\<lambda>i.\n            (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n     (l # [Suc l..<Suc l + kk])", "by simp"], ["proof (state)\nthis:\n  local.neville_aitken_merge ((xi, xj, p_ij) # (xsi, xsj, p_sisj) # rest) =\n  map (\\<lambda>i.\n          (x i, x (i + Suc j), local.neville_aitken_main i (i + Suc j)))\n   [l..<l + k]\n\ngoal (2 subgoals):\n 1. \\<And>uu_ l k.\n       [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [uu_] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]\n 2. \\<And>l k.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_merge [] =\n       map (\\<lambda>i.\n               (x i, x (i + Suc j),\n                local.neville_aitken_main i (i + Suc j)))\n        [l..<l + k]", "qed auto"], ["", "lemma neville_aitken_impl_main: \n  \"xs = map (\\<lambda> i. (x i, x (i + j), neville_aitken_main i (i + j)))  [l ..< Suc (l + k)] \n   \\<Longrightarrow> neville_aitken_impl_main xs = neville_aitken_main l (l + j + k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n     [l..<Suc (l + k)] \\<Longrightarrow>\n    local.neville_aitken_impl_main xs =\n    local.neville_aitken_main l (l + j + k)", "proof (induct xs arbitrary: l k j rule: neville_aitken_impl_main.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e1 e2 es l k j.\n       \\<lbrakk>\\<And>l k j.\n                   local.neville_aitken_merge (e1 # e2 # es) =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_impl_main\n                    (local.neville_aitken_merge (e1 # e2 # es)) =\n                   local.neville_aitken_main l (l + j + k);\n        e1 # e2 # es =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_impl_main (e1 # e2 # es) =\n                         local.neville_aitken_main l (l + j + k)\n 2. \\<And>uu_ uv_ p l k j.\n       [(uu_, uv_, p)] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [(uu_, uv_, p)] =\n       local.neville_aitken_main l (l + j + k)\n 3. \\<And>l k j.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [] =\n       local.neville_aitken_main l (l + j + k)", "case (1 e1 e2 es l k j)"], ["proof (state)\nthis:\n  local.neville_aitken_merge (e1 # e2 # es) =\n  map (\\<lambda>i. (x i, x (i + ?j), local.neville_aitken_main i (i + ?j)))\n   [?l..<Suc (?l + ?k)] \\<Longrightarrow>\n  local.neville_aitken_impl_main\n   (local.neville_aitken_merge (e1 # e2 # es)) =\n  local.neville_aitken_main ?l (?l + ?j + ?k)\n  e1 # e2 # es =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [l..<Suc (l + k)]\n\ngoal (3 subgoals):\n 1. \\<And>e1 e2 es l k j.\n       \\<lbrakk>\\<And>l k j.\n                   local.neville_aitken_merge (e1 # e2 # es) =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_impl_main\n                    (local.neville_aitken_merge (e1 # e2 # es)) =\n                   local.neville_aitken_main l (l + j + k);\n        e1 # e2 # es =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_impl_main (e1 # e2 # es) =\n                         local.neville_aitken_main l (l + j + k)\n 2. \\<And>uu_ uv_ p l k j.\n       [(uu_, uv_, p)] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [(uu_, uv_, p)] =\n       local.neville_aitken_main l (l + j + k)\n 3. \\<And>l k j.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [] =\n       local.neville_aitken_main l (l + j + k)", "note res = 1(2)"], ["proof (state)\nthis:\n  e1 # e2 # es =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [l..<Suc (l + k)]\n\ngoal (3 subgoals):\n 1. \\<And>e1 e2 es l k j.\n       \\<lbrakk>\\<And>l k j.\n                   local.neville_aitken_merge (e1 # e2 # es) =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_impl_main\n                    (local.neville_aitken_merge (e1 # e2 # es)) =\n                   local.neville_aitken_main l (l + j + k);\n        e1 # e2 # es =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_impl_main (e1 # e2 # es) =\n                         local.neville_aitken_main l (l + j + k)\n 2. \\<And>uu_ uv_ p l k j.\n       [(uu_, uv_, p)] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [(uu_, uv_, p)] =\n       local.neville_aitken_main l (l + j + k)\n 3. \\<And>l k j.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [] =\n       local.neville_aitken_main l (l + j + k)", "from res"], ["proof (chain)\npicking this:\n  e1 # e2 # es =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [l..<Suc (l + k)]", "obtain kk where k: \"k = Suc kk\""], ["proof (prove)\nusing this:\n  e1 # e2 # es =\n  map (\\<lambda>i. (x i, x (i + j), local.neville_aitken_main i (i + j)))\n   [l..<Suc (l + k)]\n\ngoal (1 subgoal):\n 1. (\\<And>kk. k = Suc kk \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases k, auto)"], ["proof (state)\nthis:\n  k = Suc kk\n\ngoal (3 subgoals):\n 1. \\<And>e1 e2 es l k j.\n       \\<lbrakk>\\<And>l k j.\n                   local.neville_aitken_merge (e1 # e2 # es) =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_impl_main\n                    (local.neville_aitken_merge (e1 # e2 # es)) =\n                   local.neville_aitken_main l (l + j + k);\n        e1 # e2 # es =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_impl_main (e1 # e2 # es) =\n                         local.neville_aitken_main l (l + j + k)\n 2. \\<And>uu_ uv_ p l k j.\n       [(uu_, uv_, p)] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [(uu_, uv_, p)] =\n       local.neville_aitken_main l (l + j + k)\n 3. \\<And>l k j.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [] =\n       local.neville_aitken_main l (l + j + k)", "hence id1: \"l + k = Suc (l + kk)\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. l + k = Suc (l + kk)", "by auto"], ["proof (state)\nthis:\n  l + k = Suc (l + kk)\n\ngoal (3 subgoals):\n 1. \\<And>e1 e2 es l k j.\n       \\<lbrakk>\\<And>l k j.\n                   local.neville_aitken_merge (e1 # e2 # es) =\n                   map (\\<lambda>i.\n                           (x i, x (i + j),\n                            local.neville_aitken_main i (i + j)))\n                    [l..<Suc (l + k)] \\<Longrightarrow>\n                   local.neville_aitken_impl_main\n                    (local.neville_aitken_merge (e1 # e2 # es)) =\n                   local.neville_aitken_main l (l + j + k);\n        e1 # e2 # es =\n        map (\\<lambda>i.\n                (x i, x (i + j), local.neville_aitken_main i (i + j)))\n         [l..<Suc (l + k)]\\<rbrakk>\n       \\<Longrightarrow> local.neville_aitken_impl_main (e1 # e2 # es) =\n                         local.neville_aitken_main l (l + j + k)\n 2. \\<And>uu_ uv_ p l k j.\n       [(uu_, uv_, p)] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [(uu_, uv_, p)] =\n       local.neville_aitken_main l (l + j + k)\n 3. \\<And>l k j.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [] =\n       local.neville_aitken_main l (l + j + k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.neville_aitken_impl_main (e1 # e2 # es) =\n    local.neville_aitken_main l (l + j + k)", "unfolding neville_aitken_impl_main.simps 1(1)[OF neville_aitken_merge[OF 1(2), unfolded id1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.neville_aitken_main l (l + Suc j + kk) =\n    local.neville_aitken_main l (l + j + k)", "by (simp add: k)"], ["proof (state)\nthis:\n  local.neville_aitken_impl_main (e1 # e2 # es) =\n  local.neville_aitken_main l (l + j + k)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ p l k j.\n       [(uu_, uv_, p)] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [(uu_, uv_, p)] =\n       local.neville_aitken_main l (l + j + k)\n 2. \\<And>l k j.\n       [] =\n       map (\\<lambda>i.\n               (x i, x (i + j), local.neville_aitken_main i (i + j)))\n        [l..<Suc (l + k)] \\<Longrightarrow>\n       local.neville_aitken_impl_main [] =\n       local.neville_aitken_main l (l + j + k)", "qed auto"], ["", "lemma neville_aitken_impl:\n  \"xs = map (\\<lambda> i. (x i, x i, [:f i:]))  [0 ..< Suc k] \n   \\<Longrightarrow> neville_aitken_impl_main xs = neville_aitken k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. (x i, x i, [:f i:])) [0..<Suc k] \\<Longrightarrow>\n    local.neville_aitken_impl_main xs = local.neville_aitken k", "unfolding neville_aitken_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. (x i, x i, [:f i:])) [0..<Suc k] \\<Longrightarrow>\n    local.neville_aitken_impl_main xs = local.neville_aitken_main 0 k", "using neville_aitken_impl_main[of xs 0 0 k]"], ["proof (prove)\nusing this:\n  xs =\n  map (\\<lambda>i. (x i, x (i + 0), local.neville_aitken_main i (i + 0)))\n   [0..<Suc (0 + k)] \\<Longrightarrow>\n  local.neville_aitken_impl_main xs =\n  local.neville_aitken_main 0 (0 + 0 + k)\n\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. (x i, x i, [:f i:])) [0..<Suc k] \\<Longrightarrow>\n    local.neville_aitken_impl_main xs = local.neville_aitken_main 0 k", "by (simp add: neville_aitken_main.simps)"], ["", "end"], ["", "lemma neville_aitken: assumes \"\\<And> i j. i < j \\<Longrightarrow> j \\<le> n \\<Longrightarrow> x i \\<noteq> x j\"\n  shows \"j \\<le> n \\<Longrightarrow> poly (neville_aitken x f n) (x j) = (f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> n \\<Longrightarrow> poly (neville_aitken x f n) (x j) = f j", "unfolding neville_aitken_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> n \\<Longrightarrow>\n    poly (neville_aitken_main x f 0 n) (x j) = f j", "by (rule neville_aitken_main[OF assms, of n], auto)"], ["", "definition neville_aitken_interpolation_poly :: \"('a :: field \\<times> 'a)list \\<Rightarrow> 'a poly\" where\n  \"neville_aitken_interpolation_poly x_fs = (let \n    start = map (\\<lambda> (xi,fi). (xi,xi,[:fi:])) x_fs in \n    neville_aitken_impl_main start)\""], ["", "lemma neville_aitken_interpolation_impl: assumes \"x_fs \\<noteq> []\"\n  shows \"neville_aitken_interpolation_poly x_fs =\n  neville_aitken (\\<lambda> i. fst (x_fs ! i)) (\\<lambda> i. snd (x_fs ! i)) (length x_fs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neville_aitken_interpolation_poly x_fs =\n    neville_aitken (\\<lambda>i. fst (x_fs ! i)) (\\<lambda>i. snd (x_fs ! i))\n     (length x_fs - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. neville_aitken_interpolation_poly x_fs =\n    neville_aitken (\\<lambda>i. fst (x_fs ! i)) (\\<lambda>i. snd (x_fs ! i))\n     (length x_fs - 1)", "from assms"], ["proof (chain)\npicking this:\n  x_fs \\<noteq> []", "have id: \"Suc (length x_fs - 1) = length x_fs\""], ["proof (prove)\nusing this:\n  x_fs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Suc (length x_fs - 1) = length x_fs", "by auto"], ["proof (state)\nthis:\n  Suc (length x_fs - 1) = length x_fs\n\ngoal (1 subgoal):\n 1. neville_aitken_interpolation_poly x_fs =\n    neville_aitken (\\<lambda>i. fst (x_fs ! i)) (\\<lambda>i. snd (x_fs ! i))\n     (length x_fs - 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. neville_aitken_interpolation_poly x_fs =\n    neville_aitken (\\<lambda>i. fst (x_fs ! i)) (\\<lambda>i. snd (x_fs ! i))\n     (length x_fs - 1)", "unfolding neville_aitken_interpolation_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. neville_aitken_impl_main\n     (map (\\<lambda>(xi, fi). (xi, xi, [:fi:])) x_fs) =\n    neville_aitken (\\<lambda>i. fst (x_fs ! i)) (\\<lambda>i. snd (x_fs ! i))\n     (length x_fs - 1)", "by (rule neville_aitken_impl, unfold id, rule nth_equalityI, auto split: prod.splits)"], ["proof (state)\nthis:\n  neville_aitken_interpolation_poly x_fs =\n  neville_aitken (\\<lambda>i. fst (x_fs ! i)) (\\<lambda>i. snd (x_fs ! i))\n   (length x_fs - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neville_aitken_interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = neville_aitken_interpolation_poly xs_ys\"\n  and xy: \"(x,y) \\<in> set xs_ys\"\n  shows \"poly p x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p x = y", "have p: \"p = neville_aitken (\\<lambda> i. fst (xs_ys ! i)) (\\<lambda> i. snd (xs_ys ! i)) (length xs_ys - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    neville_aitken (\\<lambda>i. fst (xs_ys ! i))\n     (\\<lambda>i. snd (xs_ys ! i)) (length xs_ys - 1)", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. neville_aitken_interpolation_poly xs_ys =\n    neville_aitken (\\<lambda>i. fst (xs_ys ! i))\n     (\\<lambda>i. snd (xs_ys ! i)) (length xs_ys - 1)", "by (rule neville_aitken_interpolation_impl, insert xy, auto)"], ["proof (state)\nthis:\n  p =\n  neville_aitken (\\<lambda>i. fst (xs_ys ! i)) (\\<lambda>i. snd (xs_ys ! i))\n   (length xs_ys - 1)\n\ngoal (1 subgoal):\n 1. poly p x = y", "from xy"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set xs_ys", "obtain i where i: \"i < length xs_ys\" and x: \"x = fst (xs_ys ! i)\" and y: \"y = snd (xs_ys ! i)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs_ys; x = fst (xs_ys ! i);\n         y = snd (xs_ys ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {xs_ys ! i |i. i < length xs_ys}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs_ys; x = fst (xs_ys ! i);\n         y = snd (xs_ys ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis fst_conv in_set_conv_nth snd_conv xy)"], ["proof (state)\nthis:\n  i < length xs_ys\n  x = fst (xs_ys ! i)\n  y = snd (xs_ys ! i)\n\ngoal (1 subgoal):\n 1. poly p x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "unfolding p x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (neville_aitken (\\<lambda>i. fst (xs_ys ! i))\n       (\\<lambda>i. snd (xs_ys ! i)) (length xs_ys - 1))\n     (fst (xs_ys ! i)) =\n    snd (xs_ys ! i)", "proof (rule neville_aitken)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j \\<le> length xs_ys - 1\\<rbrakk>\n       \\<Longrightarrow> fst (xs_ys ! i) \\<noteq> fst (xs_ys ! j)\n 2. i \\<le> length xs_ys - 1", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j \\<le> length xs_ys - 1\\<rbrakk>\n       \\<Longrightarrow> fst (xs_ys ! i) \\<noteq> fst (xs_ys ! j)\n 2. i__ \\<le> length xs_ys - 1", "show \"i < j \\<Longrightarrow> j \\<le> length xs_ys - 1 \\<Longrightarrow> fst (xs_ys ! i) \\<noteq> fst (xs_ys ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<le> length xs_ys - 1\\<rbrakk>\n    \\<Longrightarrow> fst (xs_ys ! i) \\<noteq> fst (xs_ys ! j)", "using dist"], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<le> length xs_ys - 1\\<rbrakk>\n    \\<Longrightarrow> fst (xs_ys ! i) \\<noteq> fst (xs_ys ! j)", "by (metis (mono_tags, lifting) One_nat_def diff_less dual_order.strict_trans2 length_map \n        length_pos_if_in_set lessI less_or_eq_imp_le neq_iff nth_eq_iff_index_eq nth_map xy)"], ["proof (state)\nthis:\n  \\<lbrakk>i < j; j \\<le> length xs_ys - 1\\<rbrakk>\n  \\<Longrightarrow> fst (xs_ys ! i) \\<noteq> fst (xs_ys ! j)\n\ngoal (1 subgoal):\n 1. i__ \\<le> length xs_ys - 1", "qed (insert i, auto)"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_neville_aitken_interpolation_poly:  \n  shows \"degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "proof (cases \"length xs_ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow>\n    degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n 2. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (neville_aitken_interpolation_poly xs_ys)\n       \\<le> length xs_ys - 1", "case 0"], ["proof (state)\nthis:\n  length xs_ys = 0\n\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow>\n    degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n 2. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (neville_aitken_interpolation_poly xs_ys)\n       \\<le> length xs_ys - 1", "hence id: \"xs_ys = []\""], ["proof (prove)\nusing this:\n  length xs_ys = 0\n\ngoal (1 subgoal):\n 1. xs_ys = []", "by (cases xs_ys, auto)"], ["proof (state)\nthis:\n  xs_ys = []\n\ngoal (2 subgoals):\n 1. length xs_ys = 0 \\<Longrightarrow>\n    degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n 2. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (neville_aitken_interpolation_poly xs_ys)\n       \\<le> length xs_ys - 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "unfolding id neville_aitken_interpolation_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (neville_aitken_impl_main\n       (map (\\<lambda>(xi, fi). (xi, xi, [:fi:])) []))\n    \\<le> length [] - 1", "by simp"], ["proof (state)\nthis:\n  degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (neville_aitken_interpolation_poly xs_ys)\n       \\<le> length xs_ys - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (neville_aitken_interpolation_poly xs_ys)\n       \\<le> length xs_ys - 1", "case (Suc nn)"], ["proof (state)\nthis:\n  length xs_ys = Suc nn\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (neville_aitken_interpolation_poly xs_ys)\n       \\<le> length xs_ys - 1", "have id: \"neville_aitken_interpolation_poly xs_ys = \n    neville_aitken (\\<lambda> i. fst (xs_ys ! i)) (\\<lambda> i. snd (xs_ys ! i)) (length xs_ys - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neville_aitken_interpolation_poly xs_ys =\n    neville_aitken (\\<lambda>i. fst (xs_ys ! i))\n     (\\<lambda>i. snd (xs_ys ! i)) (length xs_ys - 1)", "by (rule neville_aitken_interpolation_impl, insert Suc, auto)"], ["proof (state)\nthis:\n  neville_aitken_interpolation_poly xs_ys =\n  neville_aitken (\\<lambda>i. fst (xs_ys ! i)) (\\<lambda>i. snd (xs_ys ! i))\n   (length xs_ys - 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs_ys = Suc nat \\<Longrightarrow>\n       degree (neville_aitken_interpolation_poly xs_ys)\n       \\<le> length xs_ys - 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (neville_aitken (\\<lambda>i. fst (xs_ys ! i))\n       (\\<lambda>i. snd (xs_ys ! i)) (length xs_ys - 1))\n    \\<le> length xs_ys - 1", "by (rule degree_neville_aitken)"], ["proof (state)\nthis:\n  degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}