{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Ring_Hom.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma hom_prod_list: \"hom (prod_list xs) = prod_list (map hom xs)\"", "lemmas prod_list_map_hom[simp] = hom_prod_list[symmetric]", "lemma hom_power[hom_distribs]: \"hom (x ^ n) = hom x ^ n\"", "lemma hom_sum_list: \"hom (sum_list xs) = sum_list (map hom xs)\"", "lemmas sum_list_map_hom[simp] = hom_sum_list[symmetric]", "lemma hom_add_eq_zero: assumes \"x + y = 0\" shows \"hom x + hom y = 0\"", "lemma hom_uminus[hom_distribs]: \"hom (-x) = - hom x\"", "lemma hom_minus [hom_distribs]: \"hom (x - y) = hom x - hom y\"", "lemma hom_prod[hom_distribs]: \"hom (prod f X) = (\\<Prod>x \\<in> X. hom (f x))\"", "lemma hom_prod_mset: \"hom (prod_mset X) = prod_mset (image_mset hom X)\"", "lemmas prod_mset_image[simp] = hom_prod_mset[symmetric]", "lemma hom_dvd[intro,simp]: assumes \"p dvd q\" shows \"hom p dvd hom q\"", "lemma hom_dvd_1[simp]: \"x dvd 1 \\<Longrightarrow> hom x dvd 1\"", "lemma hom_sum[hom_distribs]: \"hom (sum f X) = (\\<Sum>x \\<in> X. hom (f x))\"", "lemma hom_sum_mset[hom_distribs,simp]: \"hom (sum_mset X) = sum_mset (image_mset hom X)\"", "lemma hom_mult_eq_zero: assumes \"x * y = 0\" shows \"hom x * hom y = 0\"", "lemma hom_inverse[hom_distribs]: \"hom (inverse x) = inverse (hom x)\"", "lemma hom_0_iff[iff]: \"hom x = 0 \\<longleftrightarrow> x = 0\"", "lemma hom_1_iff[iff]: \"hom x = 1 \\<longleftrightarrow> x = 1\"", "lemma eq_iff[simp]: \"f x = f y \\<longleftrightarrow> x = y\"", "lemma inj_f: \"inj f\"", "lemma inv_f_f[simp]: \"inv f (f x) = x\"", "lemma f_inv_f[simp]: \"f (inv f x) = x\"", "lemma bijective_eq_bij: \"bijective f = bij f\"", "lemmas bij = bijective_axioms[unfolded bijective_eq_bij]", "lemma inv_inv_f_eq[simp]: \"inv (inv f) = f\"", "lemma f_eq_iff[simp]: \"f x = y \\<longleftrightarrow> x = inv f y\"", "lemma inv_f_eq_iff[simp]: \"inv f x = y \\<longleftrightarrow> x = f y\"", "lemma hom_dvd_hom[simp]: \"hom x dvd hom y \\<longleftrightarrow> x dvd y\"", "lemma hom_dvd_simp[simp]:\n    shows \"hom x dvd y' \\<longleftrightarrow> x dvd inv hom y'\"", "lemma hom_dvd_iff[simp]: \"(hom p dvd hom q) = (p dvd q)\""], "translations": [["", "lemma hom_prod_list: \"hom (prod_list xs) = prod_list (map hom xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (prod_list xs) = prod_list (map hom xs)", "by (induct xs, auto simp: hom_distribs)"], ["", "text \\<open>but since it introduces unapplied @{term hom}, the reverse direction would be simp.\\<close>"], ["", "lemmas prod_list_map_hom[simp] = hom_prod_list[symmetric]"], ["", "lemma hom_power[hom_distribs]: \"hom (x ^ n) = hom x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (x ^ n) = hom x ^ n", "by (induct n, auto simp: hom_distribs)"], ["", "end"], ["", "locale monoid_add_hom = zero_hom hom + semigroup_add_hom hom\n  for hom :: \"'a :: monoid_add \\<Rightarrow> 'b :: monoid_add\"\nbegin"], ["", "lemma hom_sum_list: \"hom (sum_list xs) = sum_list (map hom xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (sum_list xs) = sum_list (map hom xs)", "by (induct xs, auto simp: hom_distribs)"], ["", "lemmas sum_list_map_hom[simp] = hom_sum_list[symmetric]"], ["", "lemma hom_add_eq_zero: assumes \"x + y = 0\" shows \"hom x + hom y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom x + hom y = (0::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom x + hom y = (0::'b)", "have \"0 = x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = x + y", "using assms"], ["proof (prove)\nusing this:\n  x + y = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) = x + y", ".."], ["proof (state)\nthis:\n  (0::'a) = x + y\n\ngoal (1 subgoal):\n 1. hom x + hom y = (0::'b)", "hence \"hom 0 = hom (x + y)\""], ["proof (prove)\nusing this:\n  (0::'a) = x + y\n\ngoal (1 subgoal):\n 1. hom (0::'a) = hom (x + y)", "by simp"], ["proof (state)\nthis:\n  hom (0::'a) = hom (x + y)\n\ngoal (1 subgoal):\n 1. hom x + hom y = (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hom (0::'a) = hom (x + y)\n\ngoal (1 subgoal):\n 1. hom x + hom y = (0::'b)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  hom x + hom y = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale group_add_hom = monoid_add_hom hom\n  for hom :: \"'a :: group_add \\<Rightarrow> 'b :: group_add\"\nbegin"], ["", "lemma hom_uminus[hom_distribs]: \"hom (-x) = - hom x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (- x) = - hom x", "by (simp add: eq_neg_iff_add_eq_0 hom_add_eq_zero)"], ["", "lemma hom_minus [hom_distribs]: \"hom (x - y) = hom x - hom y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (x - y) = hom x - hom y", "unfolding diff_conv_add_uminus hom_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom x + - hom y = hom x + - hom y", ".."], ["", "end"], ["", "subsection \\<open>Commutativity\\<close>"], ["", "locale ab_semigroup_mult_hom = semigroup_mult_hom hom\n  for hom :: \"'a :: ab_semigroup_mult \\<Rightarrow> 'b :: ab_semigroup_mult\""], ["", "locale ab_semigroup_add_hom = semigroup_add_hom hom\n  for hom :: \"'a :: ab_semigroup_add \\<Rightarrow> 'b :: ab_semigroup_add\""], ["", "locale comm_monoid_mult_hom = monoid_mult_hom hom\n  for hom :: \"'a :: comm_monoid_mult \\<Rightarrow> 'b :: comm_monoid_mult\"\nbegin"], ["", "sublocale ab_semigroup_mult_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. ab_semigroup_mult_hom hom", ".."], ["", "lemma hom_prod[hom_distribs]: \"hom (prod f X) = (\\<Prod>x \\<in> X. hom (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (prod f X) = (\\<Prod>x\\<in>X. hom (f x))", "by (cases \"finite X\", induct rule:finite_induct; simp add: hom_distribs)"], ["", "lemma hom_prod_mset: \"hom (prod_mset X) = prod_mset (image_mset hom X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<Prod>\\<^sub># X) = \\<Prod>\\<^sub># (image_mset hom X)", "by (induct X, auto simp: hom_distribs)"], ["", "lemmas prod_mset_image[simp] = hom_prod_mset[symmetric]"], ["", "lemma hom_dvd[intro,simp]: assumes \"p dvd q\" shows \"hom p dvd hom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom p dvd hom q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom p dvd hom q", "from assms"], ["proof (chain)\npicking this:\n  p dvd q", "obtain r where \"q = p * r\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>r. q = p * r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. q = p * k\n\ngoal (1 subgoal):\n 1. (\\<And>r. q = p * r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  q = p * r\n\ngoal (1 subgoal):\n 1. hom p dvd hom q", "from arg_cong[OF this, of hom]"], ["proof (chain)\npicking this:\n  hom q = hom (p * r)", "show ?thesis"], ["proof (prove)\nusing this:\n  hom q = hom (p * r)\n\ngoal (1 subgoal):\n 1. hom p dvd hom q", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  hom q = hom (p * r)\n\ngoal (1 subgoal):\n 1. \\<exists>k. hom q = hom p * k", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  hom p dvd hom q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_dvd_1[simp]: \"x dvd 1 \\<Longrightarrow> hom x dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd (1::'a) \\<Longrightarrow> hom x dvd (1::'b)", "using hom_dvd[of x 1]"], ["proof (prove)\nusing this:\n  x dvd (1::'a) \\<Longrightarrow> hom x dvd hom (1::'a)\n\ngoal (1 subgoal):\n 1. x dvd (1::'a) \\<Longrightarrow> hom x dvd (1::'b)", "by simp"], ["", "end"], ["", "locale comm_monoid_add_hom = monoid_add_hom hom\n  for hom :: \"'a :: comm_monoid_add \\<Rightarrow> 'b :: comm_monoid_add\"\nbegin"], ["", "sublocale ab_semigroup_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. ab_semigroup_add_hom hom", ".."], ["", "lemma hom_sum[hom_distribs]: \"hom (sum f X) = (\\<Sum>x \\<in> X. hom (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (sum f X) = (\\<Sum>x\\<in>X. hom (f x))", "by (cases \"finite X\", induct rule:finite_induct; simp add: hom_distribs)"], ["", "lemma hom_sum_mset[hom_distribs,simp]: \"hom (sum_mset X) = sum_mset (image_mset hom X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<Sum>\\<^sub># X) = \\<Sum>\\<^sub># (image_mset hom X)", "by (induct X, auto simp: hom_distribs)"], ["", "end"], ["", "locale ab_group_add_hom = group_add_hom hom\n  for hom :: \"'a :: ab_group_add \\<Rightarrow> 'b :: ab_group_add\"\nbegin"], ["", "sublocale comm_monoid_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_add_hom hom", ".."], ["", "end"], ["", "locale semiring_hom = comm_monoid_add_hom hom + monoid_mult_hom hom\n  for hom :: \"'a :: semiring_1 \\<Rightarrow> 'b :: semiring_1\"\nbegin"], ["", "lemma hom_mult_eq_zero: assumes \"x * y = 0\" shows \"hom x * hom y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom x * hom y = (0::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom x * hom y = (0::'b)", "have \"0 = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = x * y", "using assms"], ["proof (prove)\nusing this:\n  x * y = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) = x * y", ".."], ["proof (state)\nthis:\n  (0::'a) = x * y\n\ngoal (1 subgoal):\n 1. hom x * hom y = (0::'b)", "hence \"hom 0 = hom (x * y)\""], ["proof (prove)\nusing this:\n  (0::'a) = x * y\n\ngoal (1 subgoal):\n 1. hom (0::'a) = hom (x * y)", "by simp"], ["proof (state)\nthis:\n  hom (0::'a) = hom (x * y)\n\ngoal (1 subgoal):\n 1. hom x * hom y = (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hom (0::'a) = hom (x * y)\n\ngoal (1 subgoal):\n 1. hom x * hom y = (0::'b)", "by (auto simp:hom_distribs)"], ["proof (state)\nthis:\n  hom x * hom y = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale ring_hom = semiring_hom hom\n  for hom :: \"'a :: ring_1 \\<Rightarrow> 'b :: ring_1\"\nbegin"], ["", "sublocale ab_group_add_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. ab_group_add_hom hom", ".."], ["", "end"], ["", "locale comm_semiring_hom = semiring_hom hom\n  for hom :: \"'a :: comm_semiring_1 \\<Rightarrow> 'b :: comm_semiring_1\"\nbegin"], ["", "sublocale comm_monoid_mult_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_hom hom", ".."], ["", "end"], ["", "locale comm_ring_hom = ring_hom hom\n  for hom :: \"'a :: comm_ring_1 \\<Rightarrow> 'b :: comm_ring_1\"\nbegin"], ["", "sublocale comm_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_hom hom", ".."], ["", "end"], ["", "locale idom_hom = comm_ring_hom hom\n  for hom :: \"'a :: idom \\<Rightarrow> 'b :: idom\""], ["", "subsection \\<open>Division\\<close>"], ["", "locale idom_divide_hom = idom_hom hom\n  for hom :: \"'a :: idom_divide \\<Rightarrow> 'b :: idom_divide\" +\n  assumes hom_div[hom_distribs]: \"hom (x div y) = hom x div hom y\"\nbegin"], ["", "end"], ["", "locale field_hom = idom_hom hom\n  for hom :: \"'a :: field \\<Rightarrow> 'b :: field\"\nbegin"], ["", "lemma hom_inverse[hom_distribs]: \"hom (inverse x) = inverse (hom x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (inverse x) = inverse (hom x)", "by (metis hom_mult hom_one hom_zero inverse_unique inverse_zero right_inverse)"], ["", "sublocale idom_divide_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_divide_hom hom", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. hom (x / y) = hom x / hom y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. hom (x / y) = hom x / hom y", "have \"hom (x / y) = hom (x * inverse y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (x / y) = hom (x * inverse y)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  hom (x / y) = hom (x * inverse y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. hom (x / y) = hom x / hom y", "thus \"hom (x / y) = hom x / hom y\""], ["proof (prove)\nusing this:\n  hom (x / y) = hom (x * inverse y)\n\ngoal (1 subgoal):\n 1. hom (x / y) = hom x / hom y", "unfolding hom_distribs"], ["proof (prove)\nusing this:\n  hom (x / y) = hom x * inverse (hom y)\n\ngoal (1 subgoal):\n 1. hom (x / y) = hom x / hom y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  hom (x / y) = hom x / hom y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale field_char_0_hom = field_hom hom\n  for hom :: \"'a :: field_char_0 \\<Rightarrow> 'b :: field_char_0\""], ["", "subsection \\<open>(Partial) Injectivitiy\\<close>"], ["", "locale zero_hom_0 = zero_hom +\n  assumes hom_0: \"\\<And>x. hom x = 0 \\<Longrightarrow> x = 0\"\nbegin"], ["", "lemma hom_0_iff[iff]: \"hom x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom x = (0::'b)) = (x = (0::'a))", "using hom_0"], ["proof (prove)\nusing this:\n  hom ?x = (0::'b) \\<Longrightarrow> ?x = (0::'a)\n\ngoal (1 subgoal):\n 1. (hom x = (0::'b)) = (x = (0::'a))", "by auto"], ["", "end"], ["", "locale one_hom_1 = one_hom +\n  assumes hom_1: \"\\<And>x. hom x = 1 \\<Longrightarrow> x = 1\"\nbegin"], ["", "lemma hom_1_iff[iff]: \"hom x = 1 \\<longleftrightarrow> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom x = (1::'b)) = (x = (1::'a))", "using hom_1"], ["proof (prove)\nusing this:\n  hom ?x = (1::'b) \\<Longrightarrow> ?x = (1::'a)\n\ngoal (1 subgoal):\n 1. (hom x = (1::'b)) = (x = (1::'a))", "by auto"], ["", "end"], ["", "text \\<open>Next locales are at this point not interesting.\n  They will retain some results when we think of polynomials.\n\\<close>"], ["", "locale monoid_mult_hom_1 = monoid_mult_hom + one_hom_1"], ["", "locale monoid_add_hom_0 = monoid_add_hom + zero_hom_0"], ["", "locale comm_monoid_mult_hom_1 = monoid_mult_hom_1 hom\n  for hom :: \"'a :: comm_monoid_mult \\<Rightarrow> 'b :: comm_monoid_mult\""], ["", "locale comm_monoid_add_hom_0 = monoid_add_hom_0 hom\n  for hom :: \"'a :: comm_monoid_add \\<Rightarrow> 'b :: comm_monoid_add\""], ["", "locale injective =\n  fixes f :: \"'a \\<Rightarrow> 'b\" assumes injectivity: \"\\<And>x y. f x = f y \\<Longrightarrow> x = y\"\nbegin"], ["", "lemma eq_iff[simp]: \"f x = f y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x = f y) = (x = y)", "using injectivity"], ["proof (prove)\nusing this:\n  f ?x = f ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. (f x = f y) = (x = y)", "by auto"], ["", "lemma inj_f: \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f", "by (auto intro: injI)"], ["", "lemma inv_f_f[simp]: \"inv f (f x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f (f x) = x", "by (fact inv_f_f[OF inj_f])"], ["", "end"], ["", "locale inj_zero_hom = zero_hom + injective hom\nbegin"], ["", "sublocale zero_hom_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom_0 hom", "by (unfold_locales, auto intro: injectivity)"], ["", "end"], ["", "locale inj_one_hom = one_hom + injective hom\nbegin"], ["", "sublocale one_hom_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_hom_1 hom", "by (unfold_locales, auto intro: injectivity)"], ["", "end"], ["", "locale inj_semigroup_mult_hom = semigroup_mult_hom + injective hom"], ["", "locale inj_semigroup_add_hom = semigroup_add_hom + injective hom"], ["", "locale inj_monoid_mult_hom = monoid_mult_hom + inj_semigroup_mult_hom\nbegin"], ["", "sublocale inj_one_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_one_hom hom", ".."], ["", "sublocale monoid_mult_hom_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_mult_hom_1 hom", ".."], ["", "end"], ["", "locale inj_monoid_add_hom = monoid_add_hom + inj_semigroup_add_hom\nbegin"], ["", "sublocale inj_zero_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_zero_hom hom", ".."], ["", "sublocale monoid_add_hom_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_add_hom_0 hom", ".."], ["", "end"], ["", "locale inj_comm_monoid_mult_hom = comm_monoid_mult_hom + inj_monoid_mult_hom\nbegin"], ["", "sublocale comm_monoid_mult_hom_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_hom_1 hom", ".."], ["", "end"], ["", "locale inj_comm_monoid_add_hom = comm_monoid_add_hom + inj_monoid_add_hom\nbegin"], ["", "sublocale comm_monoid_add_hom_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_add_hom_0 hom", ".."], ["", "end"], ["", "locale inj_semiring_hom = semiring_hom + injective hom\nbegin"], ["", "sublocale inj_comm_monoid_add_hom + inj_monoid_mult_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_add_hom hom &&& inj_monoid_mult_hom hom", ".."], ["", "end"], ["", "locale inj_comm_semiring_hom = comm_semiring_hom + inj_semiring_hom\nbegin"], ["", "sublocale inj_comm_monoid_mult_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_mult_hom hom", ".."], ["", "end"], ["", "text \\<open>For groups, injectivity is easily ensured.\\<close>"], ["", "locale inj_group_add_hom = group_add_hom + zero_hom_0\nbegin"], ["", "sublocale injective hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. injective hom", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. hom x = hom y \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. hom x = hom y \\<Longrightarrow> x = y", "assume \"hom x = hom y\""], ["proof (state)\nthis:\n  hom x = hom y\n\ngoal (1 subgoal):\n 1. \\<And>x y. hom x = hom y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  hom x = hom y", "have \"hom (x-y) = 0\""], ["proof (prove)\nusing this:\n  hom x = hom y\n\ngoal (1 subgoal):\n 1. hom (x - y) = (0::'b)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  hom (x - y) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x y. hom x = hom y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  hom (x - y) = (0::'b)", "show \"x = y\""], ["proof (prove)\nusing this:\n  hom (x - y) = (0::'b)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale inj_monoid_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_monoid_add_hom hom", ".."], ["", "end"], ["", "locale inj_ab_group_add_hom = ab_group_add_hom + inj_group_add_hom\nbegin"], ["", "sublocale inj_comm_monoid_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_add_hom hom", ".."], ["", "end"], ["", "locale inj_ring_hom = ring_hom + zero_hom_0\nbegin"], ["", "sublocale inj_ab_group_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ab_group_add_hom hom", ".."], ["", "sublocale inj_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_semiring_hom hom", ".."], ["", "end"], ["", "locale inj_comm_ring_hom = comm_ring_hom + zero_hom_0\nbegin"], ["", "sublocale inj_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ring_hom hom", ".."], ["", "sublocale inj_comm_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_semiring_hom hom", ".."], ["", "end"], ["", "locale inj_idom_hom = idom_hom + zero_hom_0\nbegin"], ["", "sublocale inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom hom", ".."], ["", "end"], ["", "text \\<open>Field homomorphism is always injective.\\<close>"], ["", "context field_hom begin"], ["", "sublocale zero_hom_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom_0 hom", "proof (unfold_locales, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"hom x = 0\" and x0: \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  hom x = (0::'b)\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hom x = (0::'b)\n  x \\<noteq> (0::'a)", "have \"inverse (hom x) = 0\""], ["proof (prove)\nusing this:\n  hom x = (0::'b)\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse (hom x) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  inverse (hom x) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  inverse (hom x) = (0::'b)", "have \"hom (inverse x) = 0\""], ["proof (prove)\nusing this:\n  inverse (hom x) = (0::'b)\n\ngoal (1 subgoal):\n 1. hom (inverse x) = (0::'b)", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  hom (inverse x) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hom (inverse x) = (0::'b)", "have \"hom (inverse x * x) = 0\""], ["proof (prove)\nusing this:\n  hom (inverse x) = (0::'b)\n\ngoal (1 subgoal):\n 1. hom (inverse x * x) = (0::'b)", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  hom (inverse x * x) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "with x0"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)\n  hom (inverse x * x) = (0::'b)", "have \"hom 1 = hom 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  hom (inverse x * x) = (0::'b)\n\ngoal (1 subgoal):\n 1. hom (1::'a) = hom (0::'a)", "by simp"], ["proof (state)\nthis:\n  hom (1::'a) = hom (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hom (1::'a) = hom (0::'a)", "have \"(1 :: 'b) = 0\""], ["proof (prove)\nusing this:\n  hom (1::'a) = hom (0::'a)\n\ngoal (1 subgoal):\n 1. (1::'b) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (1::'b) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>hom x = (0::'b); x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (1::'b) = (0::'b)", "show False"], ["proof (prove)\nusing this:\n  (1::'b) = (0::'b)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale inj_idom_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom hom", ".."], ["", "end"], ["", "subsection \\<open>Surjectivity and Isomorphisms\\<close>"], ["", "locale surjective =\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes surj: \"surj f\"\nbegin"], ["", "lemma f_inv_f[simp]: \"f (inv f x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (inv f x) = x", "by (rule cong, auto simp: surj[unfolded surj_iff o_def id_def])"], ["", "end"], ["", "locale bijective = injective + surjective"], ["", "lemma bijective_eq_bij: \"bijective f = bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective f = bij f", "proof(intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. bijective f \\<Longrightarrow> bij f\n 2. bij f \\<Longrightarrow> bijective f", "assume \"bijective f\""], ["proof (state)\nthis:\n  bijective f\n\ngoal (2 subgoals):\n 1. bijective f \\<Longrightarrow> bij f\n 2. bij f \\<Longrightarrow> bijective f", "then"], ["proof (chain)\npicking this:\n  bijective f", "interpret bijective f"], ["proof (prove)\nusing this:\n  bijective f\n\ngoal (1 subgoal):\n 1. bijective f", "."], ["proof (state)\ngoal (2 subgoals):\n 1. bijective f \\<Longrightarrow> bij f\n 2. bij f \\<Longrightarrow> bijective f", "show \"bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f", "using injectivity surj"], ["proof (prove)\nusing this:\n  f ?x = f ?y \\<Longrightarrow> ?x = ?y\n  surj f\n\ngoal (1 subgoal):\n 1. bij f", "by (auto intro!: bijI injI)"], ["proof (state)\nthis:\n  bij f\n\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow> bijective f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow> bijective f", "assume \"bij f\""], ["proof (state)\nthis:\n  bij f\n\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow> bijective f", "from this[unfolded bij_def]"], ["proof (chain)\npicking this:\n  inj f \\<and> surj f", "show \"bijective f\""], ["proof (prove)\nusing this:\n  inj f \\<and> surj f\n\ngoal (1 subgoal):\n 1. bijective f", "by (unfold_locales, auto dest: injD)"], ["proof (state)\nthis:\n  bijective f\n\ngoal:\nNo subgoals!", "qed"], ["", "context bijective\nbegin"], ["", "lemmas bij = bijective_axioms[unfolded bijective_eq_bij]"], ["", "interpretation inv: bijective \"inv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (inv f)", "using bijective_axioms bij_imp_bij_inv"], ["proof (prove)\nusing this:\n  bijective f\n  bij ?f \\<Longrightarrow> bij (inv ?f)\n\ngoal (1 subgoal):\n 1. bijective (inv f)", "by (unfold bijective_eq_bij)"], ["", "sublocale inv: surjective \"inv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective (inv f)", ".."], ["", "sublocale inv: injective \"inv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (inv f)", ".."], ["", "lemma inv_inv_f_eq[simp]: \"inv (inv f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (inv f) = f", "using inv_inv_eq[OF bij]"], ["proof (prove)\nusing this:\n  inv (inv f) = f\n\ngoal (1 subgoal):\n 1. inv (inv f) = f", "."], ["", "lemma f_eq_iff[simp]: \"f x = y \\<longleftrightarrow> x = inv f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x = y) = (x = inv f y)", "by auto"], ["", "lemma inv_f_eq_iff[simp]: \"inv f x = y \\<longleftrightarrow> x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv f x = y) = (x = f y)", "by auto"], ["", "end"], ["", "locale monoid_mult_isom = inj_monoid_mult_hom + bijective hom\nbegin"], ["", "sublocale inv: bijective \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (inv hom)", ".."], ["", "sublocale inv: inj_monoid_mult_hom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_monoid_mult_hom (inv hom)", "proof (unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. inv hom (1::'b) = (1::'a)\n 2. \\<And>x y. inv hom (x * y) = inv hom x * inv hom y", "fix hx hy :: 'b"], ["proof (state)\ngoal (2 subgoals):\n 1. inv hom (1::'b) = (1::'a)\n 2. \\<And>x y. inv hom (x * y) = inv hom x * inv hom y", "from bij"], ["proof (chain)\npicking this:\n  bij hom", "obtain x y where hx: \"hx = hom x\" and hy: \"hy = hom y\""], ["proof (prove)\nusing this:\n  bij hom\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>hx = hom x; hy = hom y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson bij_pointE)"], ["proof (state)\nthis:\n  hx = hom x\n  hy = hom y\n\ngoal (2 subgoals):\n 1. inv hom (1::'b) = (1::'a)\n 2. \\<And>x y. inv hom (x * y) = inv hom x * inv hom y", "show \"inv hom (hx*hy) = inv hom hx * inv hom hy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv hom (hx * hy) = inv hom hx * inv hom hy", "by (unfold hx hy, fold hom_mult, simp)"], ["proof (state)\nthis:\n  inv hom (hx * hy) = inv hom hx * inv hom hy\n\ngoal (1 subgoal):\n 1. inv hom (1::'b) = (1::'a)", "have \"inv hom (hom 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv hom (hom (1::'a)) = (1::'a)", "by (unfold inv_f_f, simp)"], ["proof (state)\nthis:\n  inv hom (hom (1::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. inv hom (1::'b) = (1::'a)", "then"], ["proof (chain)\npicking this:\n  inv hom (hom (1::'a)) = (1::'a)", "show \"inv hom 1 = 1\""], ["proof (prove)\nusing this:\n  inv hom (hom (1::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. inv hom (1::'b) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  inv hom (1::'b) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale monoid_add_isom = inj_monoid_add_hom + bijective hom\nbegin"], ["", "sublocale inv: bijective \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (inv hom)", ".."], ["", "sublocale inv: inj_monoid_add_hom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_monoid_add_hom (inv hom)", "proof (unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. inv hom (0::'b) = (0::'a)\n 2. \\<And>x y. inv hom (x + y) = inv hom x + inv hom y", "fix hx hy :: 'b"], ["proof (state)\ngoal (2 subgoals):\n 1. inv hom (0::'b) = (0::'a)\n 2. \\<And>x y. inv hom (x + y) = inv hom x + inv hom y", "from bij"], ["proof (chain)\npicking this:\n  bij hom", "obtain x y where hx: \"hx = hom x\" and hy: \"hy = hom y\""], ["proof (prove)\nusing this:\n  bij hom\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>hx = hom x; hy = hom y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson bij_pointE)"], ["proof (state)\nthis:\n  hx = hom x\n  hy = hom y\n\ngoal (2 subgoals):\n 1. inv hom (0::'b) = (0::'a)\n 2. \\<And>x y. inv hom (x + y) = inv hom x + inv hom y", "show \"inv hom (hx+hy) = inv hom hx + inv hom hy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv hom (hx + hy) = inv hom hx + inv hom hy", "by (unfold hx hy, fold hom_add, simp)"], ["proof (state)\nthis:\n  inv hom (hx + hy) = inv hom hx + inv hom hy\n\ngoal (1 subgoal):\n 1. inv hom (0::'b) = (0::'a)", "have \"inv hom (hom 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv hom (hom (0::'a)) = (0::'a)", "by (unfold inv_f_f, simp)"], ["proof (state)\nthis:\n  inv hom (hom (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. inv hom (0::'b) = (0::'a)", "then"], ["proof (chain)\npicking this:\n  inv hom (hom (0::'a)) = (0::'a)", "show \"inv hom 0 = 0\""], ["proof (prove)\nusing this:\n  inv hom (hom (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. inv hom (0::'b) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  inv hom (0::'b) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale comm_monoid_mult_isom = monoid_mult_isom hom\n  for hom :: \"'a :: comm_monoid_mult \\<Rightarrow> 'b :: comm_monoid_mult\"\nbegin"], ["", "sublocale inv: monoid_mult_isom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_mult_isom (inv hom)", ".."], ["", "sublocale inj_comm_monoid_mult_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_mult_hom hom", ".."], ["", "lemma hom_dvd_hom[simp]: \"hom x dvd hom y \\<longleftrightarrow> x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom x dvd hom y) = (x dvd y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "assume \"hom x dvd hom y\""], ["proof (state)\nthis:\n  hom x dvd hom y\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "then"], ["proof (chain)\npicking this:\n  hom x dvd hom y", "obtain hz where \"hom y = hom x * hz\""], ["proof (prove)\nusing this:\n  hom x dvd hom y\n\ngoal (1 subgoal):\n 1. (\\<And>hz.\n        hom y = hom x * hz \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  hom y = hom x * hz\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "moreover"], ["proof (state)\nthis:\n  hom y = hom x * hz\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "obtain z where \"hz = hom z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. hz = hom z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using bij"], ["proof (prove)\nusing this:\n  bij hom\n\ngoal (1 subgoal):\n 1. (\\<And>z. hz = hom z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim bij_pointE)"], ["proof (state)\nthis:\n  hz = hom z\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "ultimately"], ["proof (chain)\npicking this:\n  hom y = hom x * hz\n  hz = hom z", "have \"hom y = hom (x * z)\""], ["proof (prove)\nusing this:\n  hom y = hom x * hz\n  hz = hom z\n\ngoal (1 subgoal):\n 1. hom y = hom (x * z)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  hom y = hom (x * z)\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "from this[unfolded eq_iff]"], ["proof (chain)\npicking this:\n  y = x * z", "have \"y = x * z\""], ["proof (prove)\nusing this:\n  y = x * z\n\ngoal (1 subgoal):\n 1. y = x * z", "."], ["proof (state)\nthis:\n  y = x * z\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "then"], ["proof (chain)\npicking this:\n  y = x * z", "show \"x dvd y\""], ["proof (prove)\nusing this:\n  y = x * z\n\ngoal (1 subgoal):\n 1. x dvd y", "by (intro dvdI)"], ["proof (state)\nthis:\n  x dvd y\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> hom x dvd hom y", "qed (rule hom_dvd)"], ["", "lemma hom_dvd_simp[simp]:\n    shows \"hom x dvd y' \\<longleftrightarrow> x dvd inv hom y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom x dvd y') = (x dvd inv hom y')", "using hom_dvd_hom[of x \"inv hom y'\"]"], ["proof (prove)\nusing this:\n  (hom x dvd hom (inv hom y')) = (x dvd inv hom y')\n\ngoal (1 subgoal):\n 1. (hom x dvd y') = (x dvd inv hom y')", "by simp"], ["", "end"], ["", "locale comm_monoid_add_isom = monoid_add_isom hom\n  for hom :: \"'a :: comm_monoid_add \\<Rightarrow> 'b :: comm_monoid_add\"\nbegin"], ["", "sublocale inv: monoid_add_isom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_add_isom (inv hom)", "by (unfold_locales; simp add: hom_distribs)"], ["", "sublocale inj_comm_monoid_add_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_add_hom hom", ".."], ["", "end"], ["", "locale semiring_isom = inj_semiring_hom hom + bijective hom for hom\nbegin"], ["", "sublocale inv: inj_semiring_hom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_semiring_hom (inv hom)", "by (unfold_locales; simp add: hom_distribs)"], ["", "sublocale inv: bijective \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (inv hom)", ".."], ["", "sublocale monoid_mult_isom"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_mult_isom hom", ".."], ["", "sublocale comm_monoid_add_isom"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_add_isom hom", ".."], ["", "end"], ["", "locale comm_semiring_isom = semiring_isom hom\n  for hom :: \"'a :: comm_semiring_1 \\<Rightarrow> 'b :: comm_semiring_1\"\nbegin"], ["", "sublocale inv: semiring_isom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_isom (inv hom)", "by (unfold_locales; simp add: hom_distribs)"], ["", "sublocale comm_monoid_mult_isom"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_isom hom", ".."], ["", "sublocale inj_comm_semiring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_semiring_hom hom", ".."], ["", "end"], ["", "locale ring_isom = inj_ring_hom + surjective hom\nbegin"], ["", "sublocale semiring_isom"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_isom hom", ".."], ["", "sublocale inv: inj_ring_hom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ring_hom (inv hom)", "by (unfold_locales; simp add: hom_distribs)"], ["", "end"], ["", "locale comm_ring_isom = ring_isom hom\n  for hom :: \"'a :: comm_ring_1 \\<Rightarrow> 'b :: comm_ring_1\"\nbegin"], ["", "sublocale comm_semiring_isom"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_isom hom", ".."], ["", "sublocale inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom hom", ".."], ["", "sublocale inv: ring_isom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_isom (inv hom)", "by (unfold_locales; simp add: hom_distribs)"], ["", "end"], ["", "locale idom_isom = comm_ring_isom + inj_idom_hom\nbegin"], ["", "sublocale inv: comm_ring_isom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_isom (inv hom)", "by (unfold_locales; simp add: hom_distribs)"], ["", "sublocale inv: inj_idom_hom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom (inv hom)", ".."], ["", "end"], ["", "locale field_isom = field_hom + surjective hom\nbegin"], ["", "sublocale idom_isom"], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_isom hom", ".."], ["", "sublocale inv: field_hom \"inv hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom (inv hom)", "by (unfold_locales; simp add: hom_distribs)"], ["", "end"], ["", "locale inj_idom_divide_hom = idom_divide_hom hom + inj_idom_hom hom\n  for hom :: \"'a :: idom_divide \\<Rightarrow> 'b :: idom_divide\" \nbegin"], ["", "lemma hom_dvd_iff[simp]: \"(hom p dvd hom q) = (p dvd q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom p dvd hom q) = (p dvd q)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow> (hom p dvd hom q) = (p dvd q)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow> (hom p dvd hom q) = (p dvd q)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow> (hom p dvd hom q) = (p dvd q)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow> (hom p dvd hom q) = (p dvd q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom p dvd hom q) = (p dvd q)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "assume \"hom p dvd hom q\""], ["proof (state)\nthis:\n  hom p dvd hom q\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "from this[unfolded dvd_def]"], ["proof (chain)\npicking this:\n  \\<exists>k. hom q = hom p * k", "obtain k where \n      id: \"hom q = hom p * k\""], ["proof (prove)\nusing this:\n  \\<exists>k. hom q = hom p * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. hom q = hom p * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hom q = hom p * k\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "hence \"(hom q div hom p) = (hom p * k) div hom p\""], ["proof (prove)\nusing this:\n  hom q = hom p * k\n\ngoal (1 subgoal):\n 1. hom q div hom p = hom p * k div hom p", "by simp"], ["proof (state)\nthis:\n  hom q div hom p = hom p * k div hom p\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "also"], ["proof (state)\nthis:\n  hom q div hom p = hom p * k div hom p\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "have \"\\<dots> = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom p * k div hom p = k", "by (rule nonzero_mult_div_cancel_left, insert False, simp)"], ["proof (state)\nthis:\n  hom p * k div hom p = k\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "also"], ["proof (state)\nthis:\n  hom p * k div hom p = k\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "have \"hom q div hom p = hom (q div p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom q div hom p = hom (q div p)", "by (simp add: hom_div)"], ["proof (state)\nthis:\n  hom q div hom p = hom (q div p)\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "finally"], ["proof (chain)\npicking this:\n  hom (q div p) = k", "have \"k = hom (q div p)\""], ["proof (prove)\nusing this:\n  hom (q div p) = k\n\ngoal (1 subgoal):\n 1. k = hom (q div p)", "by auto"], ["proof (state)\nthis:\n  k = hom (q div p)\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "from id[unfolded this]"], ["proof (chain)\npicking this:\n  hom q = hom p * hom (q div p)", "have \"hom q = hom (p * (q div p))\""], ["proof (prove)\nusing this:\n  hom q = hom p * hom (q div p)\n\ngoal (1 subgoal):\n 1. hom q = hom (p * (q div p))", "by (simp add: hom_mult)"], ["proof (state)\nthis:\n  hom q = hom (p * (q div p))\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "hence \"q = p * (q div p)\""], ["proof (prove)\nusing this:\n  hom q = hom (p * (q div p))\n\ngoal (1 subgoal):\n 1. q = p * (q div p)", "by simp"], ["proof (state)\nthis:\n  q = p * (q div p)\n\ngoal (2 subgoals):\n 1. hom p dvd hom q \\<Longrightarrow> p dvd q\n 2. p dvd q \\<Longrightarrow> hom p dvd hom q", "thus \"p dvd q\""], ["proof (prove)\nusing this:\n  q = p * (q div p)\n\ngoal (1 subgoal):\n 1. p dvd q", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  q = p * (q div p)\n\ngoal (1 subgoal):\n 1. \\<exists>k. q = p * k", ".."], ["proof (state)\nthis:\n  p dvd q\n\ngoal (1 subgoal):\n 1. p dvd q \\<Longrightarrow> hom p dvd hom q", "qed simp"], ["proof (state)\nthis:\n  (hom p dvd hom q) = (p dvd q)\n\ngoal (1 subgoal):\n 1. p = (0::'a) \\<Longrightarrow> (hom p dvd hom q) = (p dvd q)", "qed simp"], ["", "end"], ["", "context field_hom\nbegin"], ["", "sublocale inj_idom_divide_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_divide_hom hom", ".."], ["", "end"], ["", "subsection \\<open>Example Interpretations\\<close>"], ["", "interpretation of_int_hom: ring_hom of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_hom of_int", "by (unfold_locales, auto)"], ["", "interpretation of_int_hom: comm_ring_hom of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_hom of_int", "by (unfold_locales, auto)"], ["", "interpretation of_int_hom: idom_hom of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_hom of_int", "by (unfold_locales, auto)"], ["", "interpretation of_int_hom: inj_ring_hom \"of_int :: int \\<Rightarrow> 'a :: {ring_1,ring_char_0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ring_hom of_int", "by (unfold_locales, auto)"], ["", "interpretation of_int_hom: inj_comm_ring_hom \"of_int :: int \\<Rightarrow> 'a :: {comm_ring_1,ring_char_0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom of_int", "by (unfold_locales, auto)"], ["", "interpretation of_int_hom: inj_idom_hom \"of_int :: int \\<Rightarrow> 'a :: {idom,ring_char_0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom of_int", "by (unfold_locales, auto)"], ["", "text \\<open>Somehow @{const of_rat} is defined only on \\<open>char_0\\<close>.\\<close>"], ["", "interpretation of_rat_hom: field_char_0_hom \"of_rat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field_char_0_hom of_rat", "by (unfold_locales, auto simp: of_rat_add of_rat_mult of_rat_inverse of_rat_minus)"], ["", "interpretation of_real_hom: inj_ring_hom of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ring_hom of_real", "by (unfold_locales, auto)"], ["", "interpretation of_real_hom: inj_comm_ring_hom of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom of_real", "by (unfold_locales, auto)"], ["", "interpretation of_real_hom: inj_idom_hom of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom of_real", "by (unfold_locales, auto)"], ["", "interpretation of_real_hom: field_hom of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom of_real", "by (unfold_locales, auto)"], ["", "interpretation of_real_hom: field_char_0_hom \"of_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field_char_0_hom of_real", "by (unfold_locales, auto)"], ["", "text \\<open>Constant multiplication in a semiring is only a monoid homomorphism.\\<close>"], ["", "interpretation mult_hom: comm_monoid_add_hom \"\\<lambda>x. c * x\" for c :: \"'a :: semiring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_add_hom ((*) c)", "by (unfold_locales, auto simp: field_simps)"], ["", "end"]]}