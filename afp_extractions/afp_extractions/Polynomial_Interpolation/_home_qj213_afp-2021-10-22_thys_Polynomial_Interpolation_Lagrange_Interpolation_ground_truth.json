{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Lagrange_Interpolation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma [code]: \n  \"lagrange_basis_poly xs xj = (let ys = filter (\\<lambda> x. x \\<noteq> xj) xs\n    in prod_list (map (\\<lambda> xi. let ii = inverse (xj - xi) in [: - ii * xi, ii :]) ys))\"", "lemma degree_lagrange_basis_poly: \"degree (lagrange_basis_poly xs xj) \\<le> length (filter (\\<lambda> x. x \\<noteq> xj) xs)\"", "lemma degree_lagrange_interpolation_poly:  \n  shows \"degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1\"", "lemma lagrange_basis_poly_1: \n  \"poly (lagrange_basis_poly (map fst xs_ys) x) x = 1\"", "lemma lagrange_basis_poly_0: assumes \"x' \\<in> set (map fst xs_ys)\" and \"x' \\<noteq> x\" \n  shows \"poly (lagrange_basis_poly (map fst xs_ys) x) x' = 0\"", "lemma lagrange_interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = lagrange_interpolation_poly xs_ys\"\n  shows \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\""], "translations": [["", "lemma [code]: \n  \"lagrange_basis_poly xs xj = (let ys = filter (\\<lambda> x. x \\<noteq> xj) xs\n    in prod_list (map (\\<lambda> xi. let ii = inverse (xj - xi) in [: - ii * xi, ii :]) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lagrange_basis_poly xs xj =\n    (let ys = filter (\\<lambda>x. x \\<noteq> xj) xs\n     in \\<Prod>xi\\<leftarrow>ys. let ii = inverse (xj - xi)\n                                 in [:- ii * xi, ii:])", "unfolding lagrange_basis_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>xi\\<leftarrow>filter (\\<lambda>x. x \\<noteq> xj)\n                           xs. smult (inverse (xj - xi)) [:- xi, 1::'a:]) =\n    (\\<Prod>xi\\<leftarrow>filter (\\<lambda>x. x \\<noteq> xj)\n                           xs. [:- inverse (xj - xi) * xi,\n                                 inverse (xj - xi):])", "by simp"], ["", "lemma degree_lagrange_basis_poly: \"degree (lagrange_basis_poly xs xj) \\<le> length (filter (\\<lambda> x. x \\<noteq> xj) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (lagrange_basis_poly xs xj)\n    \\<le> length (filter (\\<lambda>x. x \\<noteq> xj) xs)", "unfolding lagrange_basis_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>xi\\<leftarrow>filter (\\<lambda>x. x \\<noteq> xj)\n                            xs. smult (inverse (xj - xi)) [:- xi, 1::'a:])\n    \\<le> length (filter (\\<lambda>x. x \\<noteq> xj) xs)", "by (rule order.trans[OF degree_prod_list_le], rule order_trans[OF sum_list_mono[of _ _ \"\\<lambda> _. 1\"]], \n  auto simp: o_def, induct xs, auto)"], ["", "lemma degree_lagrange_interpolation_poly:  \n  shows \"degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "assume ab: \"(a,b) \\<in> set xs_ys\""], ["proof (state)\nthis:\n  (a, b) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "let ?xs = \"filter (\\<lambda>x. x\\<noteq>a) (map fst xs_ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "from ab"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set xs_ys", "have \"a \\<in> set (map fst xs_ys)\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. a \\<in> set (map fst xs_ys)", "by force"], ["proof (state)\nthis:\n  a \\<in> set (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "hence \"Suc (length ?xs) \\<le> length xs_ys\""], ["proof (prove)\nusing this:\n  a \\<in> set (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. Suc (length (filter (\\<lambda>x. x \\<noteq> a) (map fst xs_ys)))\n    \\<le> length xs_ys", "by (induct xs_ys, auto)"], ["proof (state)\nthis:\n  Suc (length (filter (\\<lambda>x. x \\<noteq> a) (map fst xs_ys)))\n  \\<le> length xs_ys\n\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "hence \"length ?xs \\<le> length xs_ys - 1\""], ["proof (prove)\nusing this:\n  Suc (length (filter (\\<lambda>x. x \\<noteq> a) (map fst xs_ys)))\n  \\<le> length xs_ys\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<noteq> a) (map fst xs_ys))\n    \\<le> length xs_ys - 1", "by auto"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x. x \\<noteq> a) (map fst xs_ys))\n  \\<le> length xs_ys - 1\n\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "}"], ["proof (state)\nthis:\n  (?a2, ?b2) \\<in> set xs_ys \\<Longrightarrow>\n  length (filter (\\<lambda>x. x \\<noteq> ?a2) (map fst xs_ys))\n  \\<le> length xs_ys - 1\n\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "note main = this"], ["proof (state)\nthis:\n  (?a2, ?b2) \\<in> set xs_ys \\<Longrightarrow>\n  length (filter (\\<lambda>x. x \\<noteq> ?a2) (map fst xs_ys))\n  \\<le> length xs_ys - 1\n\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1", "unfolding lagrange_interpolation_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Sum>(xj,\n         yj)\\<leftarrow>xs_ys. smult yj\n                                (lagrange_basis_poly (map fst xs_ys) xj))\n    \\<le> length xs_ys - 1", "by (rule degree_sum_list_le, auto, rule order_trans[OF degree_lagrange_basis_poly], insert main, auto)"], ["proof (state)\nthis:\n  degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lagrange_basis_poly_1: \n  \"poly (lagrange_basis_poly (map fst xs_ys) x) x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x) x = (1::'a)", "unfolding lagrange_basis_poly_def Let_def poly_prod_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<leftarrow>map (\\<lambda>xi.\n                                 smult (inverse (x - xi)) [:- xi, 1::'a:])\n                          (filter (\\<lambda>xa. xa \\<noteq> x)\n                            (map fst xs_ys)). poly p x) =\n    (1::'a)", "by (rule prod_list_neutral, auto)\n  (metis field_class.field_inverse mult.commute right_diff_distrib right_minus_eq)"], ["", "lemma lagrange_basis_poly_0: assumes \"x' \\<in> set (map fst xs_ys)\" and \"x' \\<noteq> x\" \n  shows \"poly (lagrange_basis_poly (map fst xs_ys) x) x' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x) x' = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x) x' = (0::'a)", "let ?f = \"\\<lambda>xi. smult (inverse (x - xi)) [:- xi, 1:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x) x' = (0::'a)", "let ?xs = \"filter (\\<lambda>c. c\\<noteq>x) (map fst xs_ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x) x' = (0::'a)", "have mem: \"?f x' \\<in> set (map ?f ?xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (inverse (x - x')) [:- x', 1::'a:]\n    \\<in> set (map (\\<lambda>xi. smult (inverse (x - xi)) [:- xi, 1::'a:])\n                (filter (\\<lambda>c. c \\<noteq> x) (map fst xs_ys)))", "using assms"], ["proof (prove)\nusing this:\n  x' \\<in> set (map fst xs_ys)\n  x' \\<noteq> x\n\ngoal (1 subgoal):\n 1. smult (inverse (x - x')) [:- x', 1::'a:]\n    \\<in> set (map (\\<lambda>xi. smult (inverse (x - xi)) [:- xi, 1::'a:])\n                (filter (\\<lambda>c. c \\<noteq> x) (map fst xs_ys)))", "by auto"], ["proof (state)\nthis:\n  smult (inverse (x - x')) [:- x', 1::'a:]\n  \\<in> set (map (\\<lambda>xi. smult (inverse (x - xi)) [:- xi, 1::'a:])\n              (filter (\\<lambda>c. c \\<noteq> x) (map fst xs_ys)))\n\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x) x' = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x) x' = (0::'a)", "unfolding lagrange_basis_poly_def Let_def poly_prod_list prod_list_map_remove1[OF mem]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (smult (inverse (x - x')) [:- x', 1::'a:]) x' *\n    (\\<Prod>p\\<leftarrow>remove1 (smult (inverse (x - x')) [:- x', 1::'a:])\n                          (map (\\<lambda>xi.\n                                   smult (inverse (x - xi)) [:- xi, 1::'a:])\n                            (filter (\\<lambda>xa. xa \\<noteq> x)\n                              (map fst xs_ys))). poly p x') =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly (lagrange_basis_poly (map fst xs_ys) x) x' = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lagrange_interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = lagrange_interpolation_poly xs_ys\"\n  shows \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y", "let ?xs = \"map fst xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y", "assume xy: \"(x,y) \\<in> set xs_ys\""], ["proof (state)\nthis:\n  (x, y) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y", "show \"poly p x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "unfolding p lagrange_interpolation_poly_def Let_def poly_sum_list map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<leftarrow>xs_ys. poly\n                                 (case xa of\n                                  (xj, yj) \\<Rightarrow>\n                                    smult yj\n                                     (lagrange_basis_poly (map fst xs_ys)\n xj))\n                                 x) =\n    y", "proof (subst sum_list_map_remove1[OF xy], unfold split poly_smult lagrange_basis_poly_1,\n      subst sum_list_neutral)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "assume \"v \\<in> set (map (\\<lambda>xa. poly (case xa of (xj, yj) \\<Rightarrow> smult yj (lagrange_basis_poly ?xs xj))\n                               x)\n                 (remove1 (x, y) xs_ys))\" (is \"_ \\<in> set (map ?f ?xy)\")"], ["proof (state)\nthis:\n  v \\<in> set (map (\\<lambda>xa.\n                       poly\n                        (case xa of\n                         (xj, yj) \\<Rightarrow>\n                           smult yj\n                            (lagrange_basis_poly (map fst xs_ys) xj))\n                        x)\n                (remove1 (x, y) xs_ys))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (map (\\<lambda>xa.\n                       poly\n                        (case xa of\n                         (xj, yj) \\<Rightarrow>\n                           smult yj\n                            (lagrange_basis_poly (map fst xs_ys) xj))\n                        x)\n                (remove1 (x, y) xs_ys))", "obtain xy' where mem: \"xy' \\<in> set ?xy\" and v: \"v = ?f xy'\""], ["proof (prove)\nusing this:\n  v \\<in> set (map (\\<lambda>xa.\n                       poly\n                        (case xa of\n                         (xj, yj) \\<Rightarrow>\n                           smult yj\n                            (lagrange_basis_poly (map fst xs_ys) xj))\n                        x)\n                (remove1 (x, y) xs_ys))\n\ngoal (1 subgoal):\n 1. (\\<And>xy'.\n        \\<lbrakk>xy' \\<in> set (remove1 (x, y) xs_ys);\n         v =\n         poly\n          (case xy' of\n           (xj, yj) \\<Rightarrow>\n             smult yj (lagrange_basis_poly (map fst xs_ys) xj))\n          x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xy' \\<in> set (remove1 (x, y) xs_ys)\n  v =\n  poly\n   (case xy' of\n    (xj, yj) \\<Rightarrow>\n      smult yj (lagrange_basis_poly (map fst xs_ys) xj))\n   x\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "obtain x' y' where xy': \"xy' = (x',y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' y'. xy' = (x', y') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xy' = (x', y')\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "from v[unfolded this split]"], ["proof (chain)\npicking this:\n  v = poly (smult y' (lagrange_basis_poly (map fst xs_ys) x')) x", "have v: \"v = poly (smult y' (lagrange_basis_poly ?xs x')) x\""], ["proof (prove)\nusing this:\n  v = poly (smult y' (lagrange_basis_poly (map fst xs_ys) x')) x\n\ngoal (1 subgoal):\n 1. v = poly (smult y' (lagrange_basis_poly (map fst xs_ys) x')) x", "."], ["proof (state)\nthis:\n  v = poly (smult y' (lagrange_basis_poly (map fst xs_ys) x')) x\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "have neq: \"x' \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<noteq> x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "assume \"x' = x\""], ["proof (state)\nthis:\n  x' = x\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "with mem[unfolded xy']"], ["proof (chain)\npicking this:\n  (x', y') \\<in> set (remove1 (x, y) xs_ys)\n  x' = x", "have mem: \"(x,y') \\<in> set (remove1 (x,y) xs_ys)\""], ["proof (prove)\nusing this:\n  (x', y') \\<in> set (remove1 (x, y) xs_ys)\n  x' = x\n\ngoal (1 subgoal):\n 1. (x, y') \\<in> set (remove1 (x, y) xs_ys)", "by auto"], ["proof (state)\nthis:\n  (x, y') \\<in> set (remove1 (x, y) xs_ys)\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "hence mem': \"(x,y') \\<in> set xs_ys\""], ["proof (prove)\nusing this:\n  (x, y') \\<in> set (remove1 (x, y) xs_ys)\n\ngoal (1 subgoal):\n 1. (x, y') \\<in> set xs_ys", "by (meson notin_set_remove1)"], ["proof (state)\nthis:\n  (x, y') \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "from dist[unfolded distinct_map]"], ["proof (chain)\npicking this:\n  distinct xs_ys \\<and> inj_on fst (set xs_ys)", "have inj: \"inj_on fst (set xs_ys)\""], ["proof (prove)\nusing this:\n  distinct xs_ys \\<and> inj_on fst (set xs_ys)\n\ngoal (1 subgoal):\n 1. inj_on fst (set xs_ys)", "by auto"], ["proof (state)\nthis:\n  inj_on fst (set xs_ys)\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "with mem' xy"], ["proof (chain)\npicking this:\n  (x, y') \\<in> set xs_ys\n  (x, y) \\<in> set xs_ys\n  inj_on fst (set xs_ys)", "have y': \"y' = y\""], ["proof (prove)\nusing this:\n  (x, y') \\<in> set xs_ys\n  (x, y) \\<in> set xs_ys\n  inj_on fst (set xs_ys)\n\ngoal (1 subgoal):\n 1. y' = y", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  (x, y') \\<in> set xs_ys\n  (x, y) \\<in> set xs_ys\n  \\<forall>x\\<in>set xs_ys.\n     \\<forall>y\\<in>set xs_ys. fst x = fst y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. y' = y", "by force"], ["proof (state)\nthis:\n  y' = y\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "from dist"], ["proof (chain)\npicking this:\n  distinct (map fst xs_ys)", "have \"distinct xs_ys\""], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. distinct xs_ys", "using distinct_map"], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. distinct xs_ys", "by blast"], ["proof (state)\nthis:\n  distinct xs_ys\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "hence \"(x,y) \\<notin> set (remove1 (x,y) xs_ys)\""], ["proof (prove)\nusing this:\n  distinct xs_ys\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> set (remove1 (x, y) xs_ys)", "by simp"], ["proof (state)\nthis:\n  (x, y) \\<notin> set (remove1 (x, y) xs_ys)\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "with mem[unfolded y']"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (remove1 (x, y) xs_ys)\n  (x, y) \\<notin> set (remove1 (x, y) xs_ys)", "show False"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (remove1 (x, y) xs_ys)\n  (x, y) \\<notin> set (remove1 (x, y) xs_ys)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x' \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "have \"poly (lagrange_basis_poly ?xs x') x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (lagrange_basis_poly (map fst xs_ys) x') x = (0::'a)", "by (rule lagrange_basis_poly_0, insert xy mem[unfolded xy'] dist neq, force+)"], ["proof (state)\nthis:\n  poly (lagrange_basis_poly (map fst xs_ys) x') x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map (\\<lambda>xa.\n                             poly\n                              (case xa of\n                               (xj, yj) \\<Rightarrow>\n                                 smult yj\n                                  (lagrange_basis_poly (map fst xs_ys) xj))\n                              x)\n                      (remove1 (x, y) xs_ys)) \\<Longrightarrow>\n       xa = (0::'a)\n 2. y * (1::'a) + (0::'a) = y", "thus \"v = 0\""], ["proof (prove)\nusing this:\n  poly (lagrange_basis_poly (map fst xs_ys) x') x = (0::'a)\n\ngoal (1 subgoal):\n 1. v = (0::'a)", "unfolding v"], ["proof (prove)\nusing this:\n  poly (lagrange_basis_poly (map fst xs_ys) x') x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (smult y' (lagrange_basis_poly (map fst xs_ys) x')) x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  v = (0::'a)\n\ngoal (1 subgoal):\n 1. y * (1::'a) + (0::'a) = y", "qed simp"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> set xs_ys \\<Longrightarrow> poly p ?x2 = ?y2\n\ngoal:\nNo subgoals!", "note sound = this"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> set xs_ys \\<Longrightarrow> poly p ?x2 = ?y2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}