{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation/Polynomial_Interpolation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Interpolation", "problem_names": ["lemma interpolation_poly_int_def: \"distinct (map fst xs_ys) \\<Longrightarrow>\n  interpolation_poly_int alg xs_ys = (let \n     rxs_ys = map (\\<lambda> (x,y). (of_int x, of_int y)) xs_ys;\n     rp = interpolation_poly alg rxs_ys\n     in if (\\<forall> x \\<in> set (coeffs rp). is_int_rat x) then\n       Some (map_poly int_of_rat rp) else None)\"", "lemma interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = interpolation_poly alg xs_ys\"\n  and xy: \"(x,y) \\<in> set xs_ys\"\n  shows \"poly p x = y\"", "lemma degree_interpolation_poly:  \n  shows \"degree (interpolation_poly alg xs_ys) \\<le> length xs_ys - 1\"", "lemma uniqueness_of_interpolation: fixes p :: \"'a :: idom poly\" \n  assumes cS: \"card S = Suc n\"\n  and \"degree p \\<le> n\" and \"degree q \\<le> n\" and\n   id: \"\\<And> x. x \\<in> S \\<Longrightarrow> poly p x = poly q x\"\n  shows \"p = q\"", "lemma uniqueness_of_interpolation_point_list: fixes p :: \"'a :: idom poly\" \n  assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\" \"degree p < length xs_ys\" \n  and q: \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly q x = y\" \"degree q < length xs_ys\" \n  shows \"p = q\"", "lemma exactly_one_poly_interpolation: assumes xs: \"xs_ys \\<noteq> []\" and dist: \"distinct (map fst xs_ys)\"\n  shows \"\\<exists>! p. degree p < length xs_ys \\<and> (\\<forall> x y. (x,y) \\<in> set xs_ys \\<longrightarrow> poly p x = (y :: 'a :: field))\"", "lemma interpolation_poly_int_Some: assumes dist': \"distinct (map fst xs_ys)\"\n  and p: \"interpolation_poly_int alg xs_ys = Some p\"\n  shows \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\" \"degree p \\<le> length xs_ys - 1\"", "lemma interpolation_poly_int_None: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"interpolation_poly_int alg xs_ys = None\"\n  and q: \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly q x = y\"\n  and dq: \"degree q < length xs_ys\"\n  shows False", "lemmas newton_interpolation_poly_int_Some = \n  interpolation_poly_int_Some[where alg = Newton, unfolded interpolation_poly_int.simps]", "lemmas newton_interpolation_poly_int_None = \n  interpolation_poly_int_None[where alg = Newton, unfolded interpolation_poly_int.simps]", "lemma impossible_p_0_is_0_and_p_2_is_1: \"\\<not> (\\<exists> p. poly p 0 = 0 \\<and> poly p 2 = (1 :: int))\""], "translations": [["", "lemma interpolation_poly_int_def: \"distinct (map fst xs_ys) \\<Longrightarrow>\n  interpolation_poly_int alg xs_ys = (let \n     rxs_ys = map (\\<lambda> (x,y). (of_int x, of_int y)) xs_ys;\n     rp = interpolation_poly alg rxs_ys\n     in if (\\<forall> x \\<in> set (coeffs rp). is_int_rat x) then\n       Some (map_poly int_of_rat rp) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs_ys) \\<Longrightarrow>\n    interpolation_poly_int alg xs_ys =\n    (let rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys;\n         rp = interpolation_poly alg rxs_ys\n     in if \\<forall>x\\<in>set (coeffs rp). is_int_rat x\n        then Some (map_poly int_of_rat rp) else None)", "by (cases alg, auto simp: newton_interpolation_poly_int)"], ["", "lemma interpolation_poly: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"p = interpolation_poly alg xs_ys\"\n  and xy: \"(x,y) \\<in> set xs_ys\"\n  shows \"poly p x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "proof (cases alg)"], ["proof (state)\ngoal (3 subgoals):\n 1. alg = Newton \\<Longrightarrow> poly p x = y\n 2. alg = Lagrange \\<Longrightarrow> poly p x = y\n 3. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "case Newton"], ["proof (state)\nthis:\n  alg = Newton\n\ngoal (3 subgoals):\n 1. alg = Newton \\<Longrightarrow> poly p x = y\n 2. alg = Lagrange \\<Longrightarrow> poly p x = y\n 3. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  alg = Newton\n\ngoal (1 subgoal):\n 1. poly p x = y", "using newton_interpolation_poly[OF dist _ xy] p"], ["proof (prove)\nusing this:\n  alg = Newton\n  ?p = newton_interpolation_poly xs_ys \\<Longrightarrow> poly ?p x = y\n  p = interpolation_poly alg xs_ys\n\ngoal (1 subgoal):\n 1. poly p x = y", "by simp"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal (2 subgoals):\n 1. alg = Lagrange \\<Longrightarrow> poly p x = y\n 2. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. alg = Lagrange \\<Longrightarrow> poly p x = y\n 2. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "case Lagrange"], ["proof (state)\nthis:\n  alg = Lagrange\n\ngoal (2 subgoals):\n 1. alg = Lagrange \\<Longrightarrow> poly p x = y\n 2. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  alg = Lagrange\n\ngoal (1 subgoal):\n 1. poly p x = y", "using lagrange_interpolation_poly[OF dist _ xy] p"], ["proof (prove)\nusing this:\n  alg = Lagrange\n  ?p = lagrange_interpolation_poly xs_ys \\<Longrightarrow> poly ?p x = y\n  p = interpolation_poly alg xs_ys\n\ngoal (1 subgoal):\n 1. poly p x = y", "by simp"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal (1 subgoal):\n 1. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "case Neville_Aitken"], ["proof (state)\nthis:\n  alg = Neville_Aitken\n\ngoal (1 subgoal):\n 1. alg = Neville_Aitken \\<Longrightarrow> poly p x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  alg = Neville_Aitken\n\ngoal (1 subgoal):\n 1. poly p x = y", "using neville_aitken_interpolation_poly[OF dist _ xy] p"], ["proof (prove)\nusing this:\n  alg = Neville_Aitken\n  ?p = neville_aitken_interpolation_poly xs_ys \\<Longrightarrow>\n  poly ?p x = y\n  p = interpolation_poly alg xs_ys\n\ngoal (1 subgoal):\n 1. poly p x = y", "by simp"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_interpolation_poly:  \n  shows \"degree (interpolation_poly alg xs_ys) \\<le> length xs_ys - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (interpolation_poly alg xs_ys) \\<le> length xs_ys - 1", "using degree_lagrange_interpolation_poly[of xs_ys]\n    degree_newton_interpolation_poly[of xs_ys]\n    degree_neville_aitken_interpolation_poly[of xs_ys]"], ["proof (prove)\nusing this:\n  degree (lagrange_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n  degree (newton_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n  degree (neville_aitken_interpolation_poly xs_ys) \\<le> length xs_ys - 1\n\ngoal (1 subgoal):\n 1. degree (interpolation_poly alg xs_ys) \\<le> length xs_ys - 1", "by (cases alg, auto)"], ["", "lemma uniqueness_of_interpolation: fixes p :: \"'a :: idom poly\" \n  assumes cS: \"card S = Suc n\"\n  and \"degree p \\<le> n\" and \"degree q \\<le> n\" and\n   id: \"\\<And> x. x \\<in> S \\<Longrightarrow> poly p x = poly q x\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "define f where \"f = p - q\""], ["proof (state)\nthis:\n  f = p - q\n\ngoal (1 subgoal):\n 1. p = q", "let ?R = \"{x. poly f x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "have sub: \"S \\<subseteq> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> {x. poly f x = (0::'a)}", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> {x. poly (p - q) x = (0::'a)}", "using id"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> poly p ?x = poly q ?x\n\ngoal (1 subgoal):\n 1. S \\<subseteq> {x. poly (p - q) x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> {x. poly f x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p = q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> p = q\n 2. f \\<noteq> 0 \\<Longrightarrow> p = q", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> p = q\n 2. f \\<noteq> 0 \\<Longrightarrow> p = q", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. p = q", "unfolding f_def"], ["proof (prove)\nusing this:\n  p - q = 0\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "note f = this"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "let ?R = \"{x. poly f x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "from poly_roots_finite[OF f]"], ["proof (chain)\npicking this:\n  finite {x. poly f x = (0::'a)}", "have \"finite ?R\""], ["proof (prove)\nusing this:\n  finite {x. poly f x = (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {x. poly f x = (0::'a)}", "."], ["proof (state)\nthis:\n  finite {x. poly f x = (0::'a)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "from card_mono[OF this sub] poly_roots_degree[OF f]"], ["proof (chain)\npicking this:\n  card S \\<le> card {x. poly f x = (0::'a)}\n  card {x. poly f x = (0::'a)} \\<le> degree f", "have \"Suc n \\<le> degree f\""], ["proof (prove)\nusing this:\n  card S \\<le> card {x. poly f x = (0::'a)}\n  card {x. poly f x = (0::'a)} \\<le> degree f\n\ngoal (1 subgoal):\n 1. Suc n \\<le> degree f", "unfolding cS"], ["proof (prove)\nusing this:\n  Suc n \\<le> card {x. poly f x = (0::'a)}\n  card {x. poly f x = (0::'a)} \\<le> degree f\n\ngoal (1 subgoal):\n 1. Suc n \\<le> degree f", "by auto"], ["proof (state)\nthis:\n  Suc n \\<le> degree f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "also"], ["proof (state)\nthis:\n  Suc n \\<le> degree f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "have \"\\<dots> \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f \\<le> n", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p - q) \\<le> n", "by (rule degree_diff_le, insert assms, auto)"], ["proof (state)\nthis:\n  degree f \\<le> n\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> p = q", "finally"], ["proof (chain)\npicking this:\n  Suc n \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc n \\<le> n\n\ngoal (1 subgoal):\n 1. p = q", "by auto"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniqueness_of_interpolation_point_list: fixes p :: \"'a :: idom poly\" \n  assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\" \"degree p < length xs_ys\" \n  and q: \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly q x = y\" \"degree q < length xs_ys\" \n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "let ?xs = \"map fst xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "from q"], ["proof (chain)\npicking this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly q ?x = ?y\n  degree q < length xs_ys", "obtain n where len: \"length xs_ys = Suc n\" and dq: \"degree q \\<le> n\""], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly q ?x = ?y\n  degree q < length xs_ys\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>length xs_ys = Suc n; degree q \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs_ys, auto)"], ["proof (state)\nthis:\n  length xs_ys = Suc n\n  degree q \\<le> n\n\ngoal (1 subgoal):\n 1. p = q", "from p"], ["proof (chain)\npicking this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly p ?x = ?y\n  degree p < length xs_ys", "have dp: \"degree p \\<le> n\""], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly p ?x = ?y\n  degree p < length xs_ys\n\ngoal (1 subgoal):\n 1. degree p \\<le> n", "unfolding len"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly p ?x = ?y\n  degree p < Suc n\n\ngoal (1 subgoal):\n 1. degree p \\<le> n", "by auto"], ["proof (state)\nthis:\n  degree p \\<le> n\n\ngoal (1 subgoal):\n 1. p = q", "from dist"], ["proof (chain)\npicking this:\n  distinct (map fst xs_ys)", "have card: \"card (set ?xs) = Suc n\""], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. card (set (map fst xs_ys)) = Suc n", "unfolding len[symmetric]"], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. card (set (map fst xs_ys)) = length xs_ys", "using distinct_card"], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. card (set (map fst xs_ys)) = length xs_ys", "by fastforce"], ["proof (state)\nthis:\n  card (set (map fst xs_ys)) = Suc n\n\ngoal (1 subgoal):\n 1. p = q", "show \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule uniqueness_of_interpolation[OF card dp dq])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map fst xs_ys) \\<Longrightarrow> poly p x = poly q x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map fst xs_ys) \\<Longrightarrow> poly p x = poly q x", "assume \"x \\<in> set ?xs\""], ["proof (state)\nthis:\n  x \\<in> set (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map fst xs_ys) \\<Longrightarrow> poly p x = poly q x", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (map fst xs_ys)", "obtain y where \"(x,y) \\<in> set xs_ys\""], ["proof (prove)\nusing this:\n  x \\<in> set (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (x, y) \\<in> set xs_ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map fst xs_ys) \\<Longrightarrow> poly p x = poly q x", "from p(1)[OF this] q(1)[OF this]"], ["proof (chain)\npicking this:\n  poly p x = y\n  poly q x = y", "show \"poly p x = poly q x\""], ["proof (prove)\nusing this:\n  poly p x = y\n  poly q x = y\n\ngoal (1 subgoal):\n 1. poly p x = poly q x", "by simp"], ["proof (state)\nthis:\n  poly p x = poly q x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exactly_one_poly_interpolation: assumes xs: \"xs_ys \\<noteq> []\" and dist: \"distinct (map fst xs_ys)\"\n  shows \"\\<exists>! p. degree p < length xs_ys \\<and> (\\<forall> x y. (x,y) \\<in> set xs_ys \\<longrightarrow> poly p x = (y :: 'a :: field))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly p x = y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly p x = y)", "let ?alg = \"undefined\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly p x = y)", "let ?p = \"interpolation_poly ?alg xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly p x = y)", "note inter = interpolation_poly[OF dist refl]"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow>\n  poly (interpolation_poly ?alg xs_ys) ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly p x = y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly p x = y)", "proof (rule ex1I[of _ ?p], intro conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. degree (interpolation_poly undefined xs_ys) < length xs_ys\n 2. \\<And>x y.\n       (x, y) \\<in> set xs_ys \\<Longrightarrow>\n       poly (interpolation_poly undefined xs_ys) x = y\n 3. \\<And>p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y.\n           (x, y) \\<in> set xs_ys \\<longrightarrow>\n           poly p x = y) \\<Longrightarrow>\n       p = interpolation_poly undefined xs_ys", "show dp: \"degree ?p < length xs_ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (interpolation_poly undefined xs_ys) < length xs_ys", "using degree_interpolation_poly[of ?alg xs_ys] xs"], ["proof (prove)\nusing this:\n  degree (interpolation_poly undefined xs_ys) \\<le> length xs_ys - 1\n  xs_ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. degree (interpolation_poly undefined xs_ys) < length xs_ys", "by (cases xs_ys, auto)"], ["proof (state)\nthis:\n  degree (interpolation_poly undefined xs_ys) < length xs_ys\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (x, y) \\<in> set xs_ys \\<Longrightarrow>\n       poly (interpolation_poly undefined xs_ys) x = y\n 2. \\<And>p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y.\n           (x, y) \\<in> set xs_ys \\<longrightarrow>\n           poly p x = y) \\<Longrightarrow>\n       p = interpolation_poly undefined xs_ys", "show \"\\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly (interpolation_poly ?alg xs_ys) x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> set xs_ys \\<Longrightarrow>\n       poly (interpolation_poly undefined xs_ys) x = y", "by (rule inter)"], ["proof (state)\nthis:\n  (?x1, ?y1) \\<in> set xs_ys \\<Longrightarrow>\n  poly (interpolation_poly undefined xs_ys) ?x1 = ?y1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y.\n           (x, y) \\<in> set xs_ys \\<longrightarrow>\n           poly p x = y) \\<Longrightarrow>\n       p = interpolation_poly undefined xs_ys", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y.\n           (x, y) \\<in> set xs_ys \\<longrightarrow>\n           poly p x = y) \\<Longrightarrow>\n       p = interpolation_poly undefined xs_ys", "assume q: \"degree q < length xs_ys \\<and> (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly q x = y)\""], ["proof (state)\nthis:\n  degree q < length xs_ys \\<and>\n  (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly q x = y)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       degree p < length xs_ys \\<and>\n       (\\<forall>x y.\n           (x, y) \\<in> set xs_ys \\<longrightarrow>\n           poly p x = y) \\<Longrightarrow>\n       p = interpolation_poly undefined xs_ys", "show \"q = ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = interpolation_poly undefined xs_ys", "by (rule uniqueness_of_interpolation_point_list[OF dist _ _ inter dp], insert q, auto)"], ["proof (state)\nthis:\n  q = interpolation_poly undefined xs_ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!p.\n     degree p < length xs_ys \\<and>\n     (\\<forall>x y. (x, y) \\<in> set xs_ys \\<longrightarrow> poly p x = y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interpolation_poly_int_Some: assumes dist': \"distinct (map fst xs_ys)\"\n  and p: \"interpolation_poly_int alg xs_ys = Some p\"\n  shows \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\" \"degree p \\<le> length xs_ys - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y) &&&\n    degree p \\<le> length xs_ys - 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "define rxs_ys where \"rxs_ys = map (\\<lambda>(x, y). (?r x, ?r y)) xs_ys\""], ["proof (state)\nthis:\n  rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "have dist: \"distinct (map fst rxs_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst rxs_ys)", "using dist'"], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst rxs_ys)", "unfolding distinct_map rxs_ys_def inj_on_def"], ["proof (prove)\nusing this:\n  distinct xs_ys \\<and>\n  (\\<forall>x\\<in>set xs_ys.\n      \\<forall>y\\<in>set xs_ys. fst x = fst y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. (distinct xs_ys \\<and>\n     (\\<forall>x\\<in>set xs_ys.\n         \\<forall>y\\<in>set xs_ys.\n            (case x of (x, y) \\<Rightarrow> (rat_of_int x, rat_of_int y)) =\n            (case y of\n             (x, y) \\<Rightarrow>\n               (rat_of_int x, rat_of_int y)) \\<longrightarrow>\n            x = y)) \\<and>\n    (\\<forall>x\\<in>set (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y))\n                          xs_ys).\n        \\<forall>y\\<in>set (map (\\<lambda>(x, y).\n                                    (rat_of_int x, rat_of_int y))\n                             xs_ys).\n           fst x = fst y \\<longrightarrow> x = y)", "by force"], ["proof (state)\nthis:\n  distinct (map fst rxs_ys)\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "obtain rp where rp: \"rp = interpolation_poly alg rxs_ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rp.\n        rp = interpolation_poly alg rxs_ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rp = interpolation_poly alg rxs_ys\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "from p[unfolded interpolation_poly_int_def[OF dist'] Let_def, folded rxs_ys_def rp]"], ["proof (chain)\npicking this:\n  (if Ball (set (coeffs rp)) is_int_rat then Some (map_poly int_of_rat rp)\n   else None) =\n  Some p", "have p: \"p = map_poly int_of_rat rp\" and ball: \"Ball (set (coeffs rp)) is_int_rat\""], ["proof (prove)\nusing this:\n  (if Ball (set (coeffs rp)) is_int_rat then Some (map_poly int_of_rat rp)\n   else None) =\n  Some p\n\ngoal (1 subgoal):\n 1. p = map_poly int_of_rat rp &&& Ball (set (coeffs rp)) is_int_rat", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  p = map_poly int_of_rat rp\n  Ball (set (coeffs rp)) is_int_rat\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "have id: \"rp = map_poly ?r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rp = of_int_poly p", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. rp = of_int_poly (map_poly int_of_rat rp)", "by (rule sym, subst map_poly_map_poly, force, rule map_poly_idI, insert ball, auto)"], ["proof (state)\nthis:\n  rp = of_int_poly p\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "note inter = interpolation_poly[OF dist rp]"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set rxs_ys \\<Longrightarrow> poly rp ?x = ?y\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "{"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set rxs_ys \\<Longrightarrow> poly rp ?x = ?y\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "assume \"(x,y) \\<in> set xs_ys\""], ["proof (state)\nthis:\n  (x, y) \\<in> set xs_ys\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "hence \"(?r x, ?r y) \\<in> set rxs_ys\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. (rat_of_int x, rat_of_int y) \\<in> set rxs_ys", "unfolding rxs_ys_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set xs_ys\n\ngoal (1 subgoal):\n 1. (rat_of_int x, rat_of_int y)\n    \\<in> set (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys)", "by auto"], ["proof (state)\nthis:\n  (rat_of_int x, rat_of_int y) \\<in> set rxs_ys\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "from inter[OF this]"], ["proof (chain)\npicking this:\n  poly rp (rat_of_int x) = rat_of_int y", "have \"poly rp (?r x) = ?r y\""], ["proof (prove)\nusing this:\n  poly rp (rat_of_int x) = rat_of_int y\n\ngoal (1 subgoal):\n 1. poly rp (rat_of_int x) = rat_of_int y", "by auto"], ["proof (state)\nthis:\n  poly rp (rat_of_int x) = rat_of_int y\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<in> set xs_ys \\<Longrightarrow> poly p x = y\n 2. degree p \\<le> length xs_ys - 1", "from this[unfolded id of_int_hom.poly_map_poly]"], ["proof (chain)\npicking this:\n  rat_of_int (poly p x) = rat_of_int y", "show \"poly p x = y\""], ["proof (prove)\nusing this:\n  rat_of_int (poly p x) = rat_of_int y\n\ngoal (1 subgoal):\n 1. poly p x = y", "by auto"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal (1 subgoal):\n 1. degree p \\<le> length xs_ys - 1", "}"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> set xs_ys \\<Longrightarrow> poly p ?x2 = ?y2\n\ngoal (1 subgoal):\n 1. degree p \\<le> length xs_ys - 1", "show \"degree p \\<le> length xs_ys - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<le> length xs_ys - 1", "using degree_interpolation_poly[of alg rxs_ys, folded rp]"], ["proof (prove)\nusing this:\n  degree rp \\<le> length rxs_ys - 1\n\ngoal (1 subgoal):\n 1. degree p \\<le> length xs_ys - 1", "unfolding id rxs_ys_def"], ["proof (prove)\nusing this:\n  degree (of_int_poly p)\n  \\<le> length (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys) -\n        1\n\ngoal (1 subgoal):\n 1. degree p \\<le> length xs_ys - 1", "by simp"], ["proof (state)\nthis:\n  degree p \\<le> length xs_ys - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interpolation_poly_int_None: assumes dist: \"distinct (map fst xs_ys)\"\n  and p: \"interpolation_poly_int alg xs_ys = None\"\n  and q: \"\\<And> x y. (x,y) \\<in> set xs_ys \\<Longrightarrow> poly q x = y\"\n  and dq: \"degree q < length xs_ys\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define rxs_ys where \"rxs_ys = map (\\<lambda>(x, y). (?r x, ?r y)) xs_ys\""], ["proof (state)\nthis:\n  rxs_ys = map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y)) xs_ys\n\ngoal (1 subgoal):\n 1. False", "have dist': \"distinct (map fst rxs_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst rxs_ys)", "using dist"], ["proof (prove)\nusing this:\n  distinct (map fst xs_ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst rxs_ys)", "unfolding distinct_map rxs_ys_def inj_on_def"], ["proof (prove)\nusing this:\n  distinct xs_ys \\<and>\n  (\\<forall>x\\<in>set xs_ys.\n      \\<forall>y\\<in>set xs_ys. fst x = fst y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. (distinct xs_ys \\<and>\n     (\\<forall>x\\<in>set xs_ys.\n         \\<forall>y\\<in>set xs_ys.\n            (case x of (x, y) \\<Rightarrow> (rat_of_int x, rat_of_int y)) =\n            (case y of\n             (x, y) \\<Rightarrow>\n               (rat_of_int x, rat_of_int y)) \\<longrightarrow>\n            x = y)) \\<and>\n    (\\<forall>x\\<in>set (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y))\n                          xs_ys).\n        \\<forall>y\\<in>set (map (\\<lambda>(x, y).\n                                    (rat_of_int x, rat_of_int y))\n                             xs_ys).\n           fst x = fst y \\<longrightarrow> x = y)", "by force"], ["proof (state)\nthis:\n  distinct (map fst rxs_ys)\n\ngoal (1 subgoal):\n 1. False", "obtain rp where rp: \"rp = interpolation_poly alg rxs_ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rp.\n        rp = interpolation_poly alg rxs_ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rp = interpolation_poly alg rxs_ys\n\ngoal (1 subgoal):\n 1. False", "note degrp = degree_interpolation_poly[of alg rxs_ys, folded rp]"], ["proof (state)\nthis:\n  degree rp \\<le> length rxs_ys - 1\n\ngoal (1 subgoal):\n 1. False", "from q"], ["proof (chain)\npicking this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly q ?x = ?y", "have q': \"\\<And> x y. (x,y) \\<in> set rxs_ys \\<Longrightarrow> poly (?rp q) x = y\""], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly q ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> set rxs_ys \\<Longrightarrow> poly (of_int_poly q) x = y", "unfolding rxs_ys_def"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set xs_ys \\<Longrightarrow> poly q ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> set (map (\\<lambda>(x, y). (rat_of_int x, rat_of_int y))\n                   xs_ys) \\<Longrightarrow>\n       poly (of_int_poly q) x = y", "by auto"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set rxs_ys \\<Longrightarrow> poly (of_int_poly q) ?x = ?y\n\ngoal (1 subgoal):\n 1. False", "have [simp]: \"degree (?rp q) = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (of_int_poly q) = degree q", "by simp"], ["proof (state)\nthis:\n  degree (of_int_poly q) = degree q\n\ngoal (1 subgoal):\n 1. False", "have id: \"rp = ?rp q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rp = of_int_poly q", "by (rule uniqueness_of_interpolation_point_list[OF dist' interpolation_poly[OF dist' rp]],\n    insert q' dq degrp, auto simp: rxs_ys_def)"], ["proof (state)\nthis:\n  rp = of_int_poly q\n\ngoal (1 subgoal):\n 1. False", "from p[unfolded interpolation_poly_int_def[OF dist] Let_def, folded rxs_ys_def rp]"], ["proof (chain)\npicking this:\n  (if Ball (set (coeffs rp)) is_int_rat then Some (map_poly int_of_rat rp)\n   else None) =\n  None", "have \"\\<exists> c \\<in> set (coeffs rp). c \\<notin> \\<int>\""], ["proof (prove)\nusing this:\n  (if Ball (set (coeffs rp)) is_int_rat then Some (map_poly int_of_rat rp)\n   else None) =\n  None\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>set (coeffs rp). c \\<notin> \\<int>", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  \\<exists>c\\<in>set (coeffs rp). c \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "from this[unfolded id]"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>set (coeffs (of_int_poly q)). c \\<notin> \\<int>", "show False"], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>set (coeffs (of_int_poly q)). c \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas newton_interpolation_poly_int_Some = \n  interpolation_poly_int_Some[where alg = Newton, unfolded interpolation_poly_int.simps]"], ["", "lemmas newton_interpolation_poly_int_None = \n  interpolation_poly_int_None[where alg = Newton, unfolded interpolation_poly_int.simps]"], ["", "text \\<open>We can also use Newton's improved algorithm for integer polynomials to show that\n    there is no polynomial $p$ over the integers such that $p(0) = 0$ and $p(2) = 1$.\n    The reason is that the intermediate result for computing the linear interpolant for these\n    two point fails, and so adding further points (which corresponds to increasing the degree)\n    will also fail. Of course, this can be generalized, showing that whenever you cannot\n    interpolate a set of $n$ points with an integer polynomial of degree $n-1$, then you\n    cannot interpolate this set of points with any integer polynomial. However, we did not\n    formally prove this more general fact.\\<close>"], ["", "lemma impossible_p_0_is_0_and_p_2_is_1: \"\\<not> (\\<exists> p. poly p 0 = 0 \\<and> poly p 2 = (1 :: int))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>p. poly p 0 = 0 \\<and> poly p 2 = 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "assume \"\\<exists> p. poly p 0 = 0 \\<and> poly p 2 = (1 :: int)\""], ["proof (state)\nthis:\n  \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1", "obtain p where p: \"poly p 0 = 0\" \"poly p 2 = (1 :: int)\""], ["proof (prove)\nusing this:\n  \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>poly p 0 = 0; poly p 2 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly p 0 = 0\n  poly p 2 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "define xs_ys where \"xs_ys = map (\\<lambda> i. (int i, poly p (int i))) [ 3 ..< 3 + degree p]\""], ["proof (state)\nthis:\n  xs_ys = map (\\<lambda>i. (int i, poly p (int i))) [3..<3 + degree p]\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "let ?l = \"\\<lambda> xs. (0,0) # (2 :: int,1 :: int) # xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "let ?xs_ys = \"?l xs_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "define list where \"list = map fst ?xs_ys\""], ["proof (state)\nthis:\n  list = map fst ((0, 0) # (2, 1) # xs_ys)\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "have dist: \"distinct (map fst ?xs_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ((0, 0) # (2, 1) # xs_ys))", "unfolding xs_ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       ((0, 0) #\n        (2, 1) #\n        map (\\<lambda>i. (int i, poly p (int i))) [3..<3 + degree p]))", "by (auto simp: o_def distinct_map inj_on_def)"], ["proof (state)\nthis:\n  distinct (map fst ((0, 0) # (2, 1) # xs_ys))\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "have p: \"\\<And> x y. (x,y) \\<in> set ?xs_ys \\<Longrightarrow> poly p x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> set ((0, 0) # (2, 1) # xs_ys) \\<Longrightarrow>\n       poly p x = y", "unfolding xs_ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> set ((0, 0) #\n                  (2, 1) #\n                  map (\\<lambda>i. (int i, poly p (int i)))\n                   [3..<3 + degree p]) \\<Longrightarrow>\n       poly p x = y", "using p"], ["proof (prove)\nusing this:\n  poly p 0 = 0\n  poly p 2 = 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> set ((0, 0) #\n                  (2, 1) #\n                  map (\\<lambda>i. (int i, poly p (int i)))\n                   [3..<3 + degree p]) \\<Longrightarrow>\n       poly p x = y", "by auto"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set ((0, 0) # (2, 1) # xs_ys) \\<Longrightarrow>\n  poly p ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "have deg: \"degree p < length ?xs_ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p < length ((0, 0) # (2, 1) # xs_ys)", "unfolding xs_ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p\n    < length\n       ((0, 0) #\n        (2, 1) #\n        map (\\<lambda>i. (int i, poly p (int i))) [3..<3 + degree p])", "by simp"], ["proof (state)\nthis:\n  degree p < length ((0, 0) # (2, 1) # xs_ys)\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "have \"newton_coefficients_main_int list (rev (map snd ?xs_ys)) (rev (map fst ?xs_ys)) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n     (rev (map fst ((0, 0) # (2, 1) # xs_ys))) =\n    None", "proof (induct xs_ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. newton_coefficients_main_int list (rev (map snd [(0, 0), (2, 1)]))\n     (rev (map fst [(0, 0), (2, 1)])) =\n    None\n 2. \\<And>x xs.\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs)))\n        (rev (map fst ((0, 0) # (2, 1) # xs))) =\n       None \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs @ [x])))\n        (rev (map fst ((0, 0) # (2, 1) # xs @ [x]))) =\n       None", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. newton_coefficients_main_int list (rev (map snd [(0, 0), (2, 1)]))\n     (rev (map fst [(0, 0), (2, 1)])) =\n    None\n 2. \\<And>x xs.\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs)))\n        (rev (map fst ((0, 0) # (2, 1) # xs))) =\n       None \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs @ [x])))\n        (rev (map fst ((0, 0) # (2, 1) # xs @ [x]))) =\n       None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list (rev (map snd [(0, 0), (2, 1)]))\n     (rev (map fst [(0, 0), (2, 1)])) =\n    None", "unfolding list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main_int (map fst ((0, 0) # (2, 1) # xs_ys))\n     (rev (map snd [(0, 0), (2, 1)])) (rev (map fst [(0, 0), (2, 1)])) =\n    None", "by (simp add: divmod_int_def)"], ["proof (state)\nthis:\n  newton_coefficients_main_int list (rev (map snd [(0, 0), (2, 1)]))\n   (rev (map fst [(0, 0), (2, 1)])) =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs)))\n        (rev (map fst ((0, 0) # (2, 1) # xs))) =\n       None \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs @ [x])))\n        (rev (map fst ((0, 0) # (2, 1) # xs @ [x]))) =\n       None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs)))\n        (rev (map fst ((0, 0) # (2, 1) # xs))) =\n       None \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs @ [x])))\n        (rev (map fst ((0, 0) # (2, 1) # xs @ [x]))) =\n       None", "case (snoc xy xs_ys)"], ["proof (state)\nthis:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys))) =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs)))\n        (rev (map fst ((0, 0) # (2, 1) # xs))) =\n       None \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs @ [x])))\n        (rev (map fst ((0, 0) # (2, 1) # xs @ [x]))) =\n       None", "note IH = this"], ["proof (state)\nthis:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys))) =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs)))\n        (rev (map fst ((0, 0) # (2, 1) # xs))) =\n       None \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs @ [x])))\n        (rev (map fst ((0, 0) # (2, 1) # xs @ [x]))) =\n       None", "obtain x y where xy: \"xy = (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. xy = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xy = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs)))\n        (rev (map fst ((0, 0) # (2, 1) # xs))) =\n       None \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs @ [x])))\n        (rev (map fst ((0, 0) # (2, 1) # xs @ [x]))) =\n       None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n     (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n    None", "proof (cases xs_ys rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs_ys = [] \\<Longrightarrow>\n    newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n     (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n    None\n 2. \\<And>ys y.\n       xs_ys = ys @ [y] \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n        (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n       None", "case Nil"], ["proof (state)\nthis:\n  xs_ys = []\n\ngoal (2 subgoals):\n 1. xs_ys = [] \\<Longrightarrow>\n    newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n     (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n    None\n 2. \\<And>ys y.\n       xs_ys = ys @ [y] \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n        (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n       None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n     (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n    None", "unfolding Nil xy"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # [] @ [(x, y)])))\n     (rev (map fst ((0, 0) # (2, 1) # [] @ [(x, y)]))) =\n    None", "by (simp add: list_def divmod_int_def)"], ["proof (state)\nthis:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs_ys = ys @ [y] \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n        (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n       None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs_ys = ys @ [y] \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n        (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n       None", "case (snoc xs_ys' xy')"], ["proof (state)\nthis:\n  xs_ys = xs_ys' @ [xy']\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs_ys = ys @ [y] \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n        (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n       None", "obtain x' y' where xy': \"xy' = (x',y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' y'. xy' = (x', y') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xy' = (x', y')\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs_ys = ys @ [y] \\<Longrightarrow>\n       newton_coefficients_main_int list\n        (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n        (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n       None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n     (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n    None", "using IH"], ["proof (prove)\nusing this:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys))) =\n  None\n\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n     (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n    None", "unfolding xy' snoc xy"], ["proof (prove)\nusing this:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys' @ [(x', y')])))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys' @ [(x', y')]))) =\n  None\n\ngoal (1 subgoal):\n 1. newton_coefficients_main_int list\n     (rev (map snd ((0, 0) # (2, 1) # (xs_ys' @ [(x', y')]) @ [(x, y)])))\n     (rev (map fst ((0, 0) # (2, 1) # (xs_ys' @ [(x', y')]) @ [(x, y)]))) =\n    None", "by simp"], ["proof (state)\nthis:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys @ [xy])))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys @ [xy]))) =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys))) =\n  None\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "hence newton: \"newton_interpolation_poly_int ?xs_ys = None\""], ["proof (prove)\nusing this:\n  newton_coefficients_main_int list\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys))) =\n  None\n\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int ((0, 0) # (2, 1) # xs_ys) = None", "unfolding newton_interpolation_poly_int_def Let_def newton_poly_impl_int_def\n      Newton_Interpolation.newton_coefficients_int_def list_def"], ["proof (prove)\nusing this:\n  newton_coefficients_main_int (map fst ((0, 0) # (2, 1) # xs_ys))\n   (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n   (rev (map fst ((0, 0) # (2, 1) # xs_ys))) =\n  None\n\ngoal (1 subgoal):\n 1. (case map_option (map hd)\n           (newton_coefficients_main_int (map fst ((0, 0) # (2, 1) # xs_ys))\n             (rev (map snd ((0, 0) # (2, 1) # xs_ys)))\n             (rev (map fst ((0, 0) # (2, 1) # xs_ys)))) of\n     None \\<Rightarrow> None\n     | Some nc \\<Rightarrow>\n         Some\n          (horner_composition (rev nc)\n            (map fst ((0, 0) # (2, 1) # xs_ys)))) =\n    None", "by simp"], ["proof (state)\nthis:\n  newton_interpolation_poly_int ((0, 0) # (2, 1) # xs_ys) = None\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly p 0 = 0 \\<and> poly p 2 = 1 \\<Longrightarrow> False", "from newton_interpolation_poly_int_None[OF dist newton p deg]"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      (x, y) \\<in> set ((0, 0) # (2, 1) # xs_ys) \\<Longrightarrow>\n      (x, y) \\<in> set ((0, 0) # (2, 1) # xs_ys)) \\<Longrightarrow>\n  False", "show False"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      (x, y) \\<in> set ((0, 0) # (2, 1) # xs_ys) \\<Longrightarrow>\n      (x, y) \\<in> set ((0, 0) # (2, 1) # xs_ys)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}