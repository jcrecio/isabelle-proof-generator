{"file_name": "/home/qj213/afp-2021-10-22/thys/BinarySearchTree/BinaryTree_TacticStyle.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BinarySearchTree", "problem_names": ["lemma member_set: \"sorted t --> memb e t = (e : set_of t)\"", "theorem set_of_binsert [simp]: \"set_of (binsert x t) = set_of t Un {x}\"", "theorem binsert_sorted: \"sorted t --> sorted (binsert x t)\"", "lemma rm_in_set_of: \"t ~= Tip ==> rm t : set_of t\"", "lemma set_of_rem: \"t ~= Tip ==> set_of t = set_of(rem t) Un {rm t}\"", "lemma [simp]: \"[| t ~= Tip; sorted t  |] ==> sorted(rem t)\"", "lemma sorted_rem: \"[| t ~= Tip; x \\<in> set_of(rem t); sorted t |] ==> x < rm t\"", "theorem set_of_remove [simp]: \"sorted t ==> set_of(remove x t) = set_of t - {x}\"", "theorem remove_sorted: \"sorted t ==> sorted(remove x t)\"", "lemma \"t ~= Tip ==> remrm t = (rem t, rm t)\""], "translations": [["", "lemma member_set: \"sorted t --> memb e t = (e : set_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinaryTree_TacticStyle.sorted t \\<longrightarrow>\n    memb e t = (e \\<in> set_of t)", "by (induct t) auto"], ["", "(*============================================================*)"], ["", "section \\<open>Insertion operation\\<close>"], ["", "(*============================================================*)"], ["", "primrec binsert :: \"nat => tree => tree\"\n\\<comment> \\<open>Insert a node into sorted tree.\\<close>\nwhere\n  \"binsert x Tip = (Nd Tip x Tip)\"\n| \"binsert x (Nd t1 y t2) = (if x < y then\n                                 (Nd (binsert x t1) y t2)\n                             else\n                               (if y < x then\n                                 (Nd t1 y (binsert x t2))\n                                else (Nd t1 y t2)))\""], ["", "theorem set_of_binsert [simp]: \"set_of (binsert x t) = set_of t Un {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (binsert x t) = set_of t \\<union> {x}", "by (induct t) auto"], ["", "theorem binsert_sorted: \"sorted t --> sorted (binsert x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinaryTree_TacticStyle.sorted t \\<longrightarrow>\n    BinaryTree_TacticStyle.sorted (binsert x t)", "by (induct t) (auto simp add: set_of_binsert)"], ["", "corollary binsert_spec:  (* summary specification of binsert *)\n\"sorted t ==>\n   sorted (binsert x t) & \n   set_of (binsert x t) = set_of t Un {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinaryTree_TacticStyle.sorted t \\<Longrightarrow>\n    BinaryTree_TacticStyle.sorted (binsert x t) \\<and>\n    set_of (binsert x t) = set_of t \\<union> {x}", "by (simp add: binsert_sorted)"], ["", "(*============================================================*)"], ["", "section \\<open>Remove operation\\<close>"], ["", "(*============================================================*)"], ["", "primrec\n  rm :: \"tree => nat\" \\<comment> \\<open>find the rightmost element in the tree\\<close>\nwhere\n  \"rm(Nd l x r) = (if r = Tip then x else rm r)\""], ["", "primrec\n  rem :: \"tree => tree\" \\<comment> \\<open>find the tree without the rightmost element\\<close>\nwhere\n  \"rem(Nd l x r) = (if r=Tip then l else Nd l x (rem r))\""], ["", "primrec\n  remove:: \"nat => tree => tree\" \\<comment> \\<open>remove a node from sorted tree\\<close>\nwhere\n  \"remove x Tip = Tip\"\n| \"remove x (Nd l y r) =\n    (if x < y then Nd (remove x l) y r else\n     if y < x then Nd l y (remove x r) else\n     if l = Tip then r\n     else Nd (rem l) (rm l) r)\""], ["", "lemma rm_in_set_of: \"t ~= Tip ==> rm t : set_of t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow> rm t \\<in> set_of t", "by (induct t) auto"], ["", "lemma set_of_rem: \"t ~= Tip ==> set_of t = set_of(rem t) Un {rm t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    set_of t = set_of (rem t) \\<union> {rm t}", "by (induct t) auto"], ["", "lemma [simp]: \"[| t ~= Tip; sorted t  |] ==> sorted(rem t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Tip; BinaryTree_TacticStyle.sorted t\\<rbrakk>\n    \\<Longrightarrow> BinaryTree_TacticStyle.sorted (rem t)", "by (induct t) (auto simp add:set_of_rem)"], ["", "lemma sorted_rem: \"[| t ~= Tip; x \\<in> set_of(rem t); sorted t |] ==> x < rm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Tip; x \\<in> set_of (rem t);\n     BinaryTree_TacticStyle.sorted t\\<rbrakk>\n    \\<Longrightarrow> x < rm t", "by (induct t) (auto simp add:set_of_rem split:if_splits)"], ["", "theorem set_of_remove [simp]: \"sorted t ==> set_of(remove x t) = set_of t - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinaryTree_TacticStyle.sorted t \\<Longrightarrow>\n    set_of (remove x t) = set_of t - {x}", "apply(induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BinaryTree_TacticStyle.sorted Tip \\<Longrightarrow>\n    set_of (remove x Tip) = set_of Tip - {x}\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>BinaryTree_TacticStyle.sorted t1 \\<Longrightarrow>\n                set_of (remove x t1) = set_of t1 - {x};\n        BinaryTree_TacticStyle.sorted t2 \\<Longrightarrow>\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted (Nd t1 x2 t2)\\<rbrakk>\n       \\<Longrightarrow> set_of (remove x (Nd t1 x2 t2)) =\n                         set_of (Nd t1 x2 t2) - {x}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>BinaryTree_TacticStyle.sorted t1 \\<Longrightarrow>\n                set_of (remove x t1) = set_of t1 - {x};\n        BinaryTree_TacticStyle.sorted t2 \\<Longrightarrow>\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted (Nd t1 x2 t2)\\<rbrakk>\n       \\<Longrightarrow> set_of (remove x (Nd t1 x2 t2)) =\n                         set_of (Nd t1 x2 t2) - {x}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z)\\<rbrakk>\n       \\<Longrightarrow> (t1 = Tip \\<longrightarrow>\n                          (x2 < x \\<longrightarrow>\n                           insert x2 (set_of t2 - {x}) =\n                           insert x2 (set_of t2) - {x}) \\<and>\n                          (\\<not> x2 < x \\<longrightarrow>\n                           (x < x2 \\<longrightarrow>\n                            insert x2 (set_of t2) =\n                            insert x2 (set_of t2) - {x}) \\<and>\n                           (x = x2 \\<longrightarrow>\n                            set_of t2 = set_of t2 - {x2}))) \\<and>\n                         (t1 \\<noteq> Tip \\<longrightarrow>\n                          (x2 < x \\<longrightarrow>\n                           insert x2\n                            (set_of t1 \\<union> (set_of t2 - {x})) =\n                           insert x2 (set_of t1 \\<union> set_of t2) -\n                           {x}) \\<and>\n                          (\\<not> x2 < x \\<longrightarrow>\n                           (x < x2 \\<longrightarrow>\n                            insert x2 (set_of t1 - {x} \\<union> set_of t2) =\n                            insert x2 (set_of t1 \\<union> set_of t2) -\n                            {x}) \\<and>\n                           (x = x2 \\<longrightarrow>\n                            insert (rm t1)\n                             (set_of (rem t1) \\<union> set_of t2) =\n                            set_of t1 \\<union> set_of t2 - {x2})))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z)\\<rbrakk>\n       \\<Longrightarrow> t1 = Tip \\<longrightarrow>\n                         (x2 < x \\<longrightarrow>\n                          insert x2 (set_of t2 - {x}) =\n                          insert x2 (set_of t2) - {x}) \\<and>\n                         (\\<not> x2 < x \\<longrightarrow>\n                          (x < x2 \\<longrightarrow>\n                           insert x2 (set_of t2) =\n                           insert x2 (set_of t2) - {x}) \\<and>\n                          (x = x2 \\<longrightarrow>\n                           set_of t2 = set_of t2 - {x2}))\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<noteq> Tip \\<longrightarrow>\n                         (x2 < x \\<longrightarrow>\n                          insert x2 (set_of t1 \\<union> (set_of t2 - {x})) =\n                          insert x2 (set_of t1 \\<union> set_of t2) -\n                          {x}) \\<and>\n                         (\\<not> x2 < x \\<longrightarrow>\n                          (x < x2 \\<longrightarrow>\n                           insert x2 (set_of t1 - {x} \\<union> set_of t2) =\n                           insert x2 (set_of t1 \\<union> set_of t2) -\n                           {x}) \\<and>\n                          (x = x2 \\<longrightarrow>\n                           insert (rm t1)\n                            (set_of (rem t1) \\<union> set_of t2) =\n                           set_of t1 \\<union> set_of t2 - {x2}))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<noteq> Tip \\<longrightarrow>\n                         (x2 < x \\<longrightarrow>\n                          insert x2 (set_of t1 \\<union> (set_of t2 - {x})) =\n                          insert x2 (set_of t1 \\<union> set_of t2) -\n                          {x}) \\<and>\n                         (\\<not> x2 < x \\<longrightarrow>\n                          (x < x2 \\<longrightarrow>\n                           insert x2 (set_of t1 - {x} \\<union> set_of t2) =\n                           insert x2 (set_of t1 \\<union> set_of t2) -\n                           {x}) \\<and>\n                          (x = x2 \\<longrightarrow>\n                           insert (rm t1)\n                            (set_of (rem t1) \\<union> set_of t2) =\n                           set_of t1 \\<union> set_of t2 - {x2}))", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z);\n        t1 \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (x2 < x \\<longrightarrow>\n                          insert x2 (set_of t1 \\<union> (set_of t2 - {x})) =\n                          insert x2 (set_of t1 \\<union> set_of t2) -\n                          {x}) \\<and>\n                         (\\<not> x2 < x \\<longrightarrow>\n                          (x < x2 \\<longrightarrow>\n                           insert x2 (set_of t1 - {x} \\<union> set_of t2) =\n                           insert x2 (set_of t1 \\<union> set_of t2) -\n                           {x}) \\<and>\n                          (x = x2 \\<longrightarrow>\n                           insert (rm t1)\n                            (set_of (rem t1) \\<union> set_of t2) =\n                           set_of t1 \\<union> set_of t2 - {x2}))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z);\n        t1 \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> x2 < x \\<longrightarrow>\n                         insert x2 (set_of t1 \\<union> (set_of t2 - {x})) =\n                         insert x2 (set_of t1 \\<union> set_of t2) - {x}\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z);\n        t1 \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> \\<not> x2 < x \\<longrightarrow>\n                         (x < x2 \\<longrightarrow>\n                          insert x2 (set_of t1 - {x} \\<union> set_of t2) =\n                          insert x2 (set_of t1 \\<union> set_of t2) -\n                          {x}) \\<and>\n                         (x = x2 \\<longrightarrow>\n                          insert (rm t1)\n                           (set_of (rem t1) \\<union> set_of t2) =\n                          set_of t1 \\<union> set_of t2 - {x2})", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>set_of (remove x t1) = set_of t1 - {x};\n        set_of (remove x t2) = set_of t2 - {x};\n        BinaryTree_TacticStyle.sorted t1 \\<and>\n        BinaryTree_TacticStyle.sorted t2 \\<and>\n        (\\<forall>x\\<in>set_of t1. x < x2) \\<and>\n        (\\<forall>z\\<in>set_of t2. x2 < z);\n        t1 \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> \\<not> x2 < x \\<longrightarrow>\n                         (x < x2 \\<longrightarrow>\n                          insert x2 (set_of t1 - {x} \\<union> set_of t2) =\n                          insert x2 (set_of t1 \\<union> set_of t2) -\n                          {x}) \\<and>\n                         (x = x2 \\<longrightarrow>\n                          insert (rm t1)\n                           (set_of (rem t1) \\<union> set_of t2) =\n                          set_of t1 \\<union> set_of t2 - {x2})", "apply(fastforce simp:set_of_rem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem remove_sorted: \"sorted t ==> sorted(remove x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinaryTree_TacticStyle.sorted t \\<Longrightarrow>\n    BinaryTree_TacticStyle.sorted (remove x t)", "by (induct t) (auto intro: less_trans rm_in_set_of sorted_rem)"], ["", "corollary remove_spec: \\<comment> \\<open>summary specification of remove\\<close>\n\"sorted t ==>\n   sorted (remove x t) &\n   set_of (remove x t) = set_of t - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinaryTree_TacticStyle.sorted t \\<Longrightarrow>\n    BinaryTree_TacticStyle.sorted (remove x t) \\<and>\n    set_of (remove x t) = set_of t - {x}", "by (simp add: remove_sorted)"], ["", "text \\<open>Finally, note that rem and rm can be computed\n        using a single tree traversal given by remrm.\\<close>"], ["", "primrec remrm :: \"tree => tree * nat\"\nwhere\n\"remrm(Nd l x r) = (if r=Tip then (l,x) else\n                    let (r',y) = remrm r in (Nd l x r',y))\""], ["", "lemma \"t ~= Tip ==> remrm t = (rem t, rm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow> remrm t = (rem t, rm t)", "by (induct t) (auto simp:Let_def)"], ["", "text \\<open>We can test this implementation by generating code.\\<close>"], ["", "definition \"test = memb 4 (remove (3::nat) (binsert 4 (binsert 3 Tip)))\""], ["", "export_code test\n  in SML module_name BinaryTree_TacticStyle_Code file \\<open>BinaryTree_TacticStyle_Code.ML\\<close>"], ["", "end"]]}