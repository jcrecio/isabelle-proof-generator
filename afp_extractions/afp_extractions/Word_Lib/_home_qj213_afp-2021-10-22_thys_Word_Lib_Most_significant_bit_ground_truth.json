{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Most_significant_bit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma msb_conv_bin_sign: \"msb x \\<longleftrightarrow> bin_sign x = -1\"", "lemma msb_bin_rest [simp]: \"msb (x div 2) = msb x\"\n  for x :: int", "lemma int_msb_and [simp]: \"msb ((x :: int) AND y) \\<longleftrightarrow> msb x \\<and> msb y\"", "lemma int_msb_or [simp]: \"msb ((x :: int) OR y) \\<longleftrightarrow> msb x \\<or> msb y\"", "lemma int_msb_xor [simp]: \"msb ((x :: int) XOR y) \\<longleftrightarrow> msb x \\<noteq> msb y\"", "lemma int_msb_not [simp]: \"msb (NOT (x :: int)) \\<longleftrightarrow> \\<not> msb x\"", "lemma msb_shiftl [simp]: \"msb ((x :: int) << n) \\<longleftrightarrow> msb x\"", "lemma msb_shiftr [simp]: \"msb ((x :: int) >> r) \\<longleftrightarrow> msb x\"", "lemma msb_bin_sc [simp]: \"msb (bin_sc n b x) \\<longleftrightarrow> msb x\"", "lemma msb_0 [simp]: \"msb (0 :: int) = False\"", "lemma msb_1 [simp]: \"msb (1 :: int) = False\"", "lemma msb_numeral [simp]:\n  \"msb (numeral n :: int) = False\"\n  \"msb (- numeral n :: int) = True\"", "lemma msb_word_eq:\n  \\<open>msb w \\<longleftrightarrow> bit w (LENGTH('a) - 1)\\<close> for w :: \\<open>'a::len word\\<close>", "lemma msb_word_iff_bit:\n  \\<open>msb w \\<longleftrightarrow> bit w (LENGTH('a) - Suc 0)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma word_msb_def:\n  \"msb a \\<longleftrightarrow> bin_sign (sint a) = - 1\"", "lemma word_msb_sint: \"msb w \\<longleftrightarrow> sint w < 0\"", "lemma msb_word_iff_sless_0:\n  \\<open>msb w \\<longleftrightarrow> w <s 0\\<close>", "lemma msb_word_of_int: \"msb (word_of_int x::'a::len word) = bin_nth x (LENGTH('a) - 1)\"", "lemma word_msb_numeral [simp]:\n  \"msb (numeral w::'a::len word) = bin_nth (numeral w) (LENGTH('a) - 1)\"", "lemma word_msb_neg_numeral [simp]:\n  \"msb (- numeral w::'a::len word) = bin_nth (- numeral w) (LENGTH('a) - 1)\"", "lemma word_msb_0 [simp]: \"\\<not> msb (0::'a::len word)\"", "lemma word_msb_1 [simp]: \"msb (1::'a::len word) \\<longleftrightarrow> LENGTH('a) = 1\"", "lemma word_msb_nth: \"msb w = bin_nth (uint w) (LENGTH('a) - 1)\"\n  for w :: \"'a::len word\"", "lemma msb_nth: \"msb w = w !! (LENGTH('a) - 1)\"\n  for w :: \"'a::len word\"", "lemma word_msb_n1 [simp]: \"msb (-1::'a::len word)\"", "lemma msb_shift: \"msb w \\<longleftrightarrow> w >> (LENGTH('a) - 1) \\<noteq> 0\"\n  for w :: \"'a::len word\"", "lemmas word_ops_msb = msb1 [unfolded msb_nth [symmetric, unfolded One_nat_def]]", "lemma word_sint_msb_eq: \"sint x = uint x - (if msb x then 2 ^ size x else 0)\"", "lemma word_sle_msb_le: \"x <=s y \\<longleftrightarrow> (msb y \\<longrightarrow> msb x) \\<and> ((msb x \\<and> \\<not> msb y) \\<or> x \\<le> y)\"", "lemma word_sless_msb_less: \"x <s y \\<longleftrightarrow> (msb y \\<longrightarrow> msb x) \\<and> ((msb x \\<and> \\<not> msb y) \\<or> x < y)\"", "lemma not_msb_from_less:\n  \"(v :: 'a word) < 2 ^ (LENGTH('a :: len) - 1) \\<Longrightarrow> \\<not> msb v\"", "lemma sint_eq_uint:\n  \"\\<not> msb x \\<Longrightarrow> sint x = uint x\"", "lemma scast_eq_ucast:\n  \"\\<not> msb x \\<Longrightarrow> scast x = ucast x\"", "lemma msb_ucast_eq:\n    \"LENGTH('a) = LENGTH('b) \\<Longrightarrow>\n         msb (ucast x :: ('a::len) word) = msb (x :: ('b::len) word)\"", "lemma msb_big:\n     \"msb (a :: ('a::len) word) = (a \\<ge> 2 ^ (LENGTH('a)  - Suc 0))\""], "translations": [["", "lemma msb_conv_bin_sign: \"msb x \\<longleftrightarrow> bin_sign x = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = (bin_sign x = - 1)", "by(simp add: bin_sign_def not_le msb_int_def)"], ["", "lemma msb_bin_rest [simp]: \"msb (x div 2) = msb x\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (x div 2) = msb x", "by (simp add: msb_int_def)"], ["", "lemma int_msb_and [simp]: \"msb ((x :: int) AND y) \\<longleftrightarrow> msb x \\<and> msb y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (x AND y) = (msb x \\<and> msb y)", "by(simp add: msb_int_def)"], ["", "lemma int_msb_or [simp]: \"msb ((x :: int) OR y) \\<longleftrightarrow> msb x \\<or> msb y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (x OR y) = (msb x \\<or> msb y)", "by(simp add: msb_int_def)"], ["", "lemma int_msb_xor [simp]: \"msb ((x :: int) XOR y) \\<longleftrightarrow> msb x \\<noteq> msb y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (x XOR y) = (msb x \\<noteq> msb y)", "by(simp add: msb_int_def)"], ["", "lemma int_msb_not [simp]: \"msb (NOT (x :: int)) \\<longleftrightarrow> \\<not> msb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (NOT x) = (\\<not> msb x)", "by(simp add: msb_int_def not_less)"], ["", "lemma msb_shiftl [simp]: \"msb ((x :: int) << n) \\<longleftrightarrow> msb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (x << n) = msb x", "by(simp add: msb_int_def)"], ["", "lemma msb_shiftr [simp]: \"msb ((x :: int) >> r) \\<longleftrightarrow> msb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (x >> r) = msb x", "by(simp add: msb_int_def)"], ["", "lemma msb_bin_sc [simp]: \"msb (bin_sc n b x) \\<longleftrightarrow> msb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (bin_sc n b x) = msb x", "by(simp add: msb_conv_bin_sign)"], ["", "lemma msb_0 [simp]: \"msb (0 :: int) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb 0 = False", "by(simp add: msb_int_def)"], ["", "lemma msb_1 [simp]: \"msb (1 :: int) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb 1 = False", "by(simp add: msb_int_def)"], ["", "lemma msb_numeral [simp]:\n  \"msb (numeral n :: int) = False\"\n  \"msb (- numeral n :: int) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (numeral n) = False &&& msb (- numeral n) = True", "by(simp_all add: msb_int_def)"], ["", "instantiation word :: (len) msb\nbegin"], ["", "definition msb_word :: \\<open>'a word \\<Rightarrow> bool\\<close>\n  where \\<open>msb a \\<longleftrightarrow> bin_sign (sbintrunc (LENGTH('a) - 1) (uint a)) = - 1\\<close>"], ["", "lemma msb_word_eq:\n  \\<open>msb w \\<longleftrightarrow> bit w (LENGTH('a) - 1)\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = bit w (LENGTH('a) - 1)", "by (simp add: msb_word_def bin_sign_lem bit_uint_iff)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a word, msb_class)", ".."], ["", "end"], ["", "lemma msb_word_iff_bit:\n  \\<open>msb w \\<longleftrightarrow> bit w (LENGTH('a) - Suc 0)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = bit w (LENGTH('a) - Suc 0)", "by (simp add: msb_word_def bin_sign_def bit_uint_iff)"], ["", "lemma word_msb_def:\n  \"msb a \\<longleftrightarrow> bin_sign (sint a) = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb a = (bin_sign (sint a) = - 1)", "by (simp add: msb_word_def sint_uint)"], ["", "lemma word_msb_sint: \"msb w \\<longleftrightarrow> sint w < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = (sint w < 0)", "by (simp add: msb_word_eq bit_last_iff)"], ["", "lemma msb_word_iff_sless_0:\n  \\<open>msb w \\<longleftrightarrow> w <s 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = (w <s 0)", "by (simp add: word_msb_sint word_sless_alt)"], ["", "lemma msb_word_of_int: \"msb (word_of_int x::'a::len word) = bin_nth x (LENGTH('a) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (word_of_int x) = bit x (LENGTH('a) - 1)", "by (simp add: word_msb_def bin_sign_lem)"], ["", "lemma word_msb_numeral [simp]:\n  \"msb (numeral w::'a::len word) = bin_nth (numeral w) (LENGTH('a) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (numeral w) = bit (numeral w) (LENGTH('a) - 1)", "unfolding word_numeral_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (word_of_int (numeral w)) = bit (numeral w) (LENGTH('a) - 1)", "by (rule msb_word_of_int)"], ["", "lemma word_msb_neg_numeral [simp]:\n  \"msb (- numeral w::'a::len word) = bin_nth (- numeral w) (LENGTH('a) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (- numeral w) = bit (- numeral w) (LENGTH('a) - 1)", "unfolding word_neg_numeral_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (word_of_int (- numeral w)) = bit (- numeral w) (LENGTH('a) - 1)", "by (rule msb_word_of_int)"], ["", "lemma word_msb_0 [simp]: \"\\<not> msb (0::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> msb 0", "by (simp add: word_msb_def bin_sign_def sint_uint sbintrunc_eq_take_bit)"], ["", "lemma word_msb_1 [simp]: \"msb (1::'a::len word) \\<longleftrightarrow> LENGTH('a) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb 1 = (LENGTH('a) = 1)", "unfolding word_1_wi msb_word_of_int eq_iff [where 'a=nat]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit 1 (LENGTH('a) - 1) = (LENGTH('a) \\<le> 1 \\<and> 1 \\<le> LENGTH('a))", "by (simp add: Suc_le_eq)"], ["", "lemma word_msb_nth: \"msb w = bin_nth (uint w) (LENGTH('a) - 1)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = bit (uint w) (LENGTH('a) - 1)", "by (simp add: word_msb_def sint_uint bin_sign_lem)"], ["", "lemma msb_nth: \"msb w = w !! (LENGTH('a) - 1)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = w !! (LENGTH('a) - 1)", "by (simp add: word_msb_nth word_test_bit_def)"], ["", "lemma word_msb_n1 [simp]: \"msb (-1::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (- 1)", "by (simp add: msb_word_eq not_le)"], ["", "lemma msb_shift: \"msb w \\<longleftrightarrow> w >> (LENGTH('a) - 1) \\<noteq> 0\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = (w >> LENGTH('a) - 1 \\<noteq> 0)", "by (simp add: msb_word_eq shiftr_word_eq bit_iff_odd_drop_bit drop_bit_eq_zero_iff_not_bit_last)"], ["", "lemmas word_ops_msb = msb1 [unfolded msb_nth [symmetric, unfolded One_nat_def]]"], ["", "lemma word_sint_msb_eq: \"sint x = uint x - (if msb x then 2 ^ size x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint x = uint x - (if msb x then 2 ^ size x else 0)", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) = 0 \\<Longrightarrow>\n    sint x = uint x - (if msb x then 2 ^ size x else 0)\n 2. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       sint x = uint x - (if msb x then 2 ^ size x else 0)", "apply (simp_all add: msb_word_def bin_sign_def bit_simps word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       (\\<not> bit x nat \\<longrightarrow> sint x = uint x) \\<and>\n       (bit x nat \\<longrightarrow> sint x = uint x - 2 * 2 ^ nat)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat x.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       (\\<not> (nat < LENGTH('a) \\<and> bit x nat) \\<longrightarrow>\n        signed_take_bit (LENGTH('a) - Suc 0) x =\n        take_bit LENGTH('a) x) \\<and>\n       (nat < LENGTH('a) \\<and> bit x nat \\<longrightarrow>\n        signed_take_bit (LENGTH('a) - Suc 0) x =\n        take_bit LENGTH('a) x - 2 * 2 ^ nat)", "apply (auto simp add: take_bit_Suc_from_most signed_take_bit_eq_if_positive signed_take_bit_eq_if_negative minus_exp_eq_not_mask ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat x.\n       \\<lbrakk>LENGTH('a) = Suc nat; bit x nat\\<rbrakk>\n       \\<Longrightarrow> NOT (mask nat) OR take_bit nat x =\n                         NOT (mask nat) + take_bit nat x", "apply (subst disjunctive_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat x n.\n       \\<lbrakk>LENGTH('a) = Suc nat; bit x nat\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit (NOT (mask nat)) n \\<or>\n                         \\<not> bit (take_bit nat x) n\n 2. \\<And>nat x.\n       \\<lbrakk>LENGTH('a) = Suc nat; bit x nat\\<rbrakk>\n       \\<Longrightarrow> NOT (mask nat) OR take_bit nat x =\n                         NOT (mask nat) OR take_bit nat x", "apply (simp_all add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sle_msb_le: \"x <=s y \\<longleftrightarrow> (msb y \\<longrightarrow> msb x) \\<and> ((msb x \\<and> \\<not> msb y) \\<or> x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le>s y) =\n    ((msb y \\<longrightarrow> msb x) \\<and>\n     (msb x \\<and> \\<not> msb y \\<or> x \\<le> y))", "apply (simp add: word_sle_eq word_sint_msb_eq word_size word_le_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (msb x \\<longrightarrow>\n     \\<not> msb y \\<longrightarrow>\n     uint x - 2 ^ LENGTH('a) \\<le> uint y) \\<and>\n    (\\<not> msb x \\<longrightarrow>\n     msb y \\<longrightarrow> \\<not> uint x \\<le> uint y - 2 ^ LENGTH('a))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>msb x; \\<not> msb y\\<rbrakk>\n    \\<Longrightarrow> uint x - 2 ^ LENGTH('a) \\<le> uint y\n 2. \\<lbrakk>\\<not> msb x; msb y;\n     uint x \\<le> uint y - 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule order_trans[OF _ uint_ge_0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>msb x; \\<not> msb y\\<rbrakk>\n    \\<Longrightarrow> uint x - 2 ^ LENGTH('a) \\<le> 0\n 2. \\<lbrakk>\\<not> msb x; msb y;\n     uint x \\<le> uint y - 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: order_less_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> msb x; msb y;\n     uint x \\<le> uint y - 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule notE[OF leD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> msb x; msb y\\<rbrakk>\n    \\<Longrightarrow> uint y - 2 ^ LENGTH('a) < uint x", "apply (rule order_less_le_trans[OF _ uint_ge_0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> msb x; msb y\\<rbrakk>\n    \\<Longrightarrow> uint y - 2 ^ LENGTH('a) < 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sless_msb_less: \"x <s y \\<longleftrightarrow> (msb y \\<longrightarrow> msb x) \\<and> ((msb x \\<and> \\<not> msb y) \\<or> x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x <s y) =\n    ((msb y \\<longrightarrow> msb x) \\<and>\n     (msb x \\<and> \\<not> msb y \\<or> x < y))", "by (auto simp add: word_sless_eq word_sle_msb_le)"], ["", "lemma not_msb_from_less:\n  \"(v :: 'a word) < 2 ^ (LENGTH('a :: len) - 1) \\<Longrightarrow> \\<not> msb v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> \\<not> msb v", "apply (clarsimp simp add: msb_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v < 2 ^ (LENGTH('a) - Suc 0);\n     v !! (LENGTH('a) - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule less_mask_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v !! (LENGTH('a) - Suc 0);\n     v AND mask (LENGTH('a) - Suc 0) = v\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule word_eqD, drule(1) iffD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v !! (LENGTH('a) - Suc 0);\n     (v AND mask (LENGTH('a) - Suc 0)) !! (LENGTH('a) - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sint_eq_uint:\n  \"\\<not> msb x \\<Longrightarrow> sint x = uint x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> msb x \\<Longrightarrow> sint x = uint x", "apply (simp add: msb_word_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bit x (LENGTH('a) - Suc 0) \\<Longrightarrow> sint x = uint x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> (LENGTH('a) - Suc 0 < LENGTH('a) \\<and>\n               bit x (LENGTH('a) - Suc 0)) \\<Longrightarrow>\n       signed_take_bit (LENGTH('a) - Suc 0) x = take_bit LENGTH('a) x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> bit x (LENGTH('a) - Suc 0) \\<Longrightarrow>\n       signed_take_bit (LENGTH('a) - Suc 0) x = take_bit LENGTH('a) x", "apply (smt One_nat_def bintrunc_bintrunc_l bintrunc_sbintrunc' diff_le_self len_gt_0 signed_take_bit_eq_if_positive)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scast_eq_ucast:\n  \"\\<not> msb x \\<Longrightarrow> scast x = ucast x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> msb x \\<Longrightarrow> scast x = ucast x", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> msb x; LENGTH('a) = 0\\<rbrakk>\n    \\<Longrightarrow> scast x = ucast x\n 2. \\<And>nat.\n       \\<lbrakk>\\<not> msb x; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> scast x = ucast x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<not> msb x; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> scast x = ucast x", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<not> msb x; LENGTH('a) = Suc nat; n < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (scast x) n = bit (ucast x) n", "apply (auto simp add: bit_signed_iff bit_unsigned_iff min_def msb_word_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<not> bit x nat; LENGTH('a) = Suc nat; n < LENGTH('b);\n        nat \\<le> n; bit x n\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>LENGTH('a) = Suc nat; n < LENGTH('b); nat \\<le> n;\n        bit x n\\<rbrakk>\n       \\<Longrightarrow> bit x nat", "apply (metis le_less_Suc_eq test_bit_bin test_bit_word_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma msb_ucast_eq:\n    \"LENGTH('a) = LENGTH('b) \\<Longrightarrow>\n         msb (ucast x :: ('a::len) word) = msb (x :: ('b::len) word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) = LENGTH('b) \\<Longrightarrow> msb (ucast x) = msb x", "by (simp add: msb_word_eq bit_simps)"], ["", "lemma msb_big:\n     \"msb (a :: ('a::len) word) = (a \\<ge> 2 ^ (LENGTH('a)  - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb a = (2 ^ (LENGTH('a) - Suc 0) \\<le> a)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. msb a \\<Longrightarrow> 2 ^ (LENGTH('a) - Suc 0) \\<le> a\n 2. 2 ^ (LENGTH('a) - Suc 0) \\<le> a \\<Longrightarrow> msb a", "apply (clarsimp simp: msb_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a !! (LENGTH('a) - Suc 0) \\<Longrightarrow>\n    2 ^ (LENGTH('a) - Suc 0) \\<le> a\n 2. 2 ^ (LENGTH('a) - Suc 0) \\<le> a \\<Longrightarrow> msb a", "apply (drule bang_is_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 ^ (LENGTH('a) - Suc 0) \\<le> a \\<Longrightarrow>\n    2 ^ (LENGTH('a) - Suc 0) \\<le> a\n 2. 2 ^ (LENGTH('a) - Suc 0) \\<le> a \\<Longrightarrow> msb a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('a) - Suc 0) \\<le> a \\<Longrightarrow> msb a", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subgoal_tac \"a = a AND mask (LENGTH('a) - Suc 0)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a;\n     a = a AND mask (LENGTH('a) - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a\\<rbrakk>\n    \\<Longrightarrow> a = a AND mask (LENGTH('a) - Suc 0)", "apply (cut_tac and_mask_less' [where w=a and n=\"LENGTH('a) - Suc 0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a;\n     a = a AND mask (LENGTH('a) - Suc 0);\n     a AND mask (LENGTH('a) - Suc 0) < 2 ^ (LENGTH('a) - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a;\n     a = a AND mask (LENGTH('a) - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> LENGTH('a) - Suc 0 < LENGTH('a)\n 3. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a\\<rbrakk>\n    \\<Longrightarrow> a = a AND mask (LENGTH('a) - Suc 0)", "apply (clarsimp simp: word_not_le [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a;\n     a = a AND mask (LENGTH('a) - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> LENGTH('a) - Suc 0 < LENGTH('a)\n 2. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a\\<rbrakk>\n    \\<Longrightarrow> a = a AND mask (LENGTH('a) - Suc 0)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a\\<rbrakk>\n    \\<Longrightarrow> a = a AND mask (LENGTH('a) - Suc 0)", "apply (rule sym, subst and_mask_eq_iff_shiftr_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ (LENGTH('a) - Suc 0) \\<le> a; \\<not> msb a\\<rbrakk>\n    \\<Longrightarrow> a >> LENGTH('a) - Suc 0 = 0", "apply (clarsimp simp: msb_shift)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}