{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Word_64.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma len64: \"len_of (x :: 64 itself) = 64\"", "lemma word_bits_conv[code]:\n  \"word_bits = 64\"", "lemma word_size_word_size_bits:\n  \"(word_size::nat) = 2 ^ word_size_bits\"", "lemma word_bits_word_size_conv:\n  \"word_bits = word_size * 8\"", "lemma ucast_8_64_inj:\n  \"inj (ucast ::  8 word \\<Rightarrow> 64 word)\"", "lemma upto_2_helper:\n  \"{0..<2 :: 64 word} = {0, 1}\"", "lemmas upper_bits_unset_is_l2p_64 = upper_bits_unset_is_l2p [where 'a=64, folded word_bits_def]", "lemmas le_2p_upper_bits_64 = le_2p_upper_bits [where 'a=64, folded word_bits_def]", "lemmas le2p_bits_unset_64 = le2p_bits_unset[where 'a=64, folded word_bits_def]", "lemma word_bits_len_of:\n  \"len_of TYPE (64) = word_bits\"", "lemmas unat_power_lower64' = unat_power_lower[where 'a=64]", "lemmas unat_power_lower64 [simp] = unat_power_lower64'[unfolded word_bits_len_of]", "lemmas word64_less_sub_le' = word_less_sub_le[where 'a = 64]", "lemmas word64_less_sub_le[simp] = word64_less_sub_le' [folded word_bits_def]", "lemma word_bits_size:\n  \"size (w::word64) = word_bits\"", "lemmas word64_power_less_1' = word_power_less_1[where 'a = 64]", "lemmas word64_power_less_1[simp] = word64_power_less_1'[folded word_bits_def]", "lemma of_nat64_0:\n  \"\\<lbrakk>of_nat n = (0::word64); n < 2 ^ word_bits\\<rbrakk> \\<Longrightarrow> n = 0\"", "lemma unat_mask_2_less_4:\n  \"unat (p && mask 2 :: word64) < 4\"", "lemmas unat_of_nat64' = unat_of_nat_eq[where 'a=64]", "lemmas unat_of_nat64 = unat_of_nat64'[unfolded word_bits_len_of]", "lemmas word_power_nonzero_64 = word_power_nonzero [where 'a=64, folded word_bits_def]", "lemmas unat_mult_simple = iffD1 [OF unat_mult_lem [where 'a = 64, unfolded word_bits_len_of]]", "lemmas div_power_helper_64 = div_power_helper [where 'a=64, folded word_bits_def]", "lemma n_less_word_bits:\n  \"(n < word_bits) = (n < 64)\"", "lemmas of_nat_less_pow_64 = of_nat_power [where 'a=64, folded word_bits_def]", "lemma lt_word_bits_lt_pow:\n  \"sz < word_bits \\<Longrightarrow> sz < 2 ^ word_bits\"", "lemma unat_less_word_bits:\n  fixes y :: word64\n  shows \"x < unat y \\<Longrightarrow> x < 2 ^ word_bits\"", "lemmas unat_mask_word64' = unat_mask[where 'a=64]", "lemmas unat_mask_word64 = unat_mask_word64'[folded word_bits_def]", "lemma unat_less_2p_word_bits:\n  \"unat (x :: 64 word) < 2 ^ word_bits\"", "lemma Suc_unat_mask_div:\n  \"Suc (unat (mask sz div word_size::word64)) = 2 ^ (min sz word_bits - 3)\"", "lemmas word64_minus_one_le' = word_minus_one_le[where 'a=64]", "lemmas word64_minus_one_le = word64_minus_one_le'[simplified]", "lemma ucast_not_helper:\n  fixes a::\"8 word\"\n  assumes a: \"a \\<noteq> 0xFF\"\n  shows \"ucast a \\<noteq> (0xFF::word64)\"", "lemma less_4_cases:\n  \"(x::word64) < 4 \\<Longrightarrow> x=0 \\<or> x=1 \\<or> x=2 \\<or> x=3\"", "lemma if_then_1_else_0:\n  \"((if P then 1 else 0) = (0 :: word64)) = (\\<not> P)\"", "lemma if_then_0_else_1:\n  \"((if P then 0 else 1) = (0 :: word64)) = (P)\"", "lemmas if_then_simps = if_then_0_else_1 if_then_1_else_0", "lemma ucast_le_ucast_8_64:\n  \"(ucast x \\<le> (ucast y :: word64)) = (x \\<le> (y :: 8 word))\"", "lemma in_16_range:\n  \"0 \\<in> S \\<Longrightarrow> r \\<in> (\\<lambda>x. r + x * (16 :: word64)) ` S\"\n  \"n - 1 \\<in> S \\<Longrightarrow> (r + (16 * n - 16)) \\<in> (\\<lambda>x :: word64. r + x * 16) ` S\"", "lemma eq_2_64_0:\n  \"(2 ^ 64 :: word64) = 0\"", "lemma x_less_2_0_1:\n  fixes x :: word64 shows\n  \"x < 2 \\<Longrightarrow> x = 0 \\<or> x = 1\"", "lemmas mask_64_max_word  = max_word_mask [symmetric, where 'a=64, simplified]", "lemma of_nat64_n_less_equal_power_2:\n \"n < 64 \\<Longrightarrow> ((of_nat n)::64 word) < 2 ^ n\"", "lemma word_rsplit_0:\n  \"word_rsplit (0 :: word64) = [0, 0, 0, 0, 0, 0, 0, 0 :: 8 word]\"", "lemma unat_ucast_10_64 :\n  fixes x :: \"10 word\"\n  shows \"unat (ucast x :: word64) = unat x\"", "lemma bool_mask [simp]:\n  fixes x :: word64\n  shows \"(0 < x && 1) = (x && 1 = 1)\"", "lemma word64_bounds:\n  \"- (2 ^ (size (x :: word64) - 1)) = (-9223372036854775808 :: int)\"\n  \"((2 ^ (size (x :: word64) - 1)) - 1) = (9223372036854775807 :: int)\"\n  \"- (2 ^ (size (y :: 64 signed word) - 1)) = (-9223372036854775808 :: int)\"\n  \"((2 ^ (size (y :: 64 signed word) - 1)) - 1) = (9223372036854775807 :: int)\"", "lemma word_ge_min:\"sint (x::64 word) \\<ge> -9223372036854775808\"", "lemmas signed_arith_ineq_checks_to_eq_word64'\n    = signed_arith_ineq_checks_to_eq[where 'a=64]\n      signed_arith_ineq_checks_to_eq[where 'a=\"64 signed\"]", "lemmas signed_arith_ineq_checks_to_eq_word64\n    = signed_arith_ineq_checks_to_eq_word64' [unfolded word64_bounds]", "lemmas signed_mult_eq_checks64_to_64'\n    = signed_mult_eq_checks_double_size[where 'a=64 and 'b=64]\n      signed_mult_eq_checks_double_size[where 'a=\"64 signed\" and 'b=64]", "lemmas signed_mult_eq_checks64_to_64 = signed_mult_eq_checks64_to_64'[simplified]", "lemmas sdiv_word64_max' = sdiv_word_max [where 'a=64] sdiv_word_max [where 'a=\"64 signed\"]", "lemmas sdiv_word64_max = sdiv_word64_max'[simplified word_size, simplified]", "lemmas sdiv_word64_min' = sdiv_word_min [where 'a=64] sdiv_word_min [where 'a=\"64 signed\"]", "lemmas sdiv_word64_min = sdiv_word64_min' [simplified word_size, simplified]", "lemmas sint64_of_int_eq' = sint_of_int_eq [where 'a=64]", "lemmas sint64_of_int_eq = sint64_of_int_eq' [simplified]", "lemma ucast_of_nats [simp]:\n  \"(ucast (of_nat x :: word64) :: sword64) = (of_nat x)\"\n  \"(ucast (of_nat x :: word64) :: 16 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: word64) :: 8 sword) = (of_nat x)\"", "lemmas signed_shift_guard_simpler_64'\n    = power_strict_increasing_iff[where b=\"2 :: nat\" and y=31]", "lemmas signed_shift_guard_simpler_64 = signed_shift_guard_simpler_64'[simplified]", "lemma word64_31_less:\n  \"31 < len_of TYPE (64 signed)\" \"31 > (0 :: nat)\"\n  \"31 < len_of TYPE (64)\" \"31 > (0 :: nat)\"", "lemmas signed_shift_guard_to_word_64\n    = signed_shift_guard_to_word[OF word64_31_less(1-2)]\n    signed_shift_guard_to_word[OF word64_31_less(3-4)]", "lemma le_step_down_word_3:\n  fixes x :: \"64 word\"\n  shows \"\\<lbrakk>x \\<le>  y; x \\<noteq> y; y < 2 ^ 64 - 1\\<rbrakk> \\<Longrightarrow> x \\<le> y - 1\"", "lemma shiftr_1:\n  \"(x::word64) >> 1 = 0 \\<Longrightarrow> x < 2\"", "lemma mask_step_down_64:\n  \\<open>\\<exists>x. mask x = b\\<close> if \\<open>b && 1 = 1\\<close>\n    and \\<open>\\<exists>x. x < 64 \\<and> mask x = b >> 1\\<close> for b :: \\<open>64word\\<close>", "lemma unat_of_int_64:\n  \"\\<lbrakk>i \\<ge> 0; i \\<le> 2 ^ 63\\<rbrakk> \\<Longrightarrow> (unat ((of_int i)::sword64)) = nat i\"", "lemmas word_ctz_not_minus_1_64 = word_ctz_not_minus_1[where 'a=64, simplified]", "lemma word64_and_max_simp:\n  \\<open>x AND 0xFFFFFFFFFFFFFFFF = x\\<close> for x :: \\<open>64 word\\<close>"], "translations": [["", "lemma len64: \"len_of (x :: 64 itself) = 64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len_of x = 64", "by simp"], ["", "type_synonym machine_word_len = 64"], ["", "type_synonym machine_word = \"machine_word_len word\""], ["", "definition word_bits :: nat\nwhere\n  \"word_bits = LENGTH(machine_word_len)\""], ["", "text \\<open>The following two are numerals so they can be used as nats and words.\\<close>"], ["", "definition word_size_bits :: \"'a :: numeral\"\nwhere\n  \"word_size_bits = 3\""], ["", "definition word_size :: \"'a :: numeral\"\nwhere\n  \"word_size = 8\""], ["", "lemma word_bits_conv[code]:\n  \"word_bits = 64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_bits = 64", "unfolding word_bits_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH(64) = 64", "by simp"], ["", "lemma word_size_word_size_bits:\n  \"(word_size::nat) = 2 ^ word_size_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_size = 2 ^ word_size_bits", "unfolding word_size_def word_size_bits_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 = 2 ^ 3", "by simp"], ["", "lemma word_bits_word_size_conv:\n  \"word_bits = word_size * 8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_bits = word_size * 8", "unfolding word_bits_def word_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH(64) = 8 * 8", "by simp"], ["", "lemma ucast_8_64_inj:\n  \"inj (ucast ::  8 word \\<Rightarrow> 64 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj UCAST(8 \\<rightarrow> 64)", "by (rule down_ucast_inj) (clarsimp simp: is_down_def target_size source_size)"], ["", "lemma upto_2_helper:\n  \"{0..<2 :: 64 word} = {0, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<2} = {0, 1}", "by (safe; simp) unat_arith"], ["", "lemmas upper_bits_unset_is_l2p_64 = upper_bits_unset_is_l2p [where 'a=64, folded word_bits_def]"], ["", "lemmas le_2p_upper_bits_64 = le_2p_upper_bits [where 'a=64, folded word_bits_def]"], ["", "lemmas le2p_bits_unset_64 = le2p_bits_unset[where 'a=64, folded word_bits_def]"], ["", "lemma word_bits_len_of:\n  \"len_of TYPE (64) = word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH(64) = word_bits", "by (simp add: word_bits_conv)"], ["", "lemmas unat_power_lower64' = unat_power_lower[where 'a=64]"], ["", "lemmas unat_power_lower64 [simp] = unat_power_lower64'[unfolded word_bits_len_of]"], ["", "lemmas word64_less_sub_le' = word_less_sub_le[where 'a = 64]"], ["", "lemmas word64_less_sub_le[simp] = word64_less_sub_le' [folded word_bits_def]"], ["", "lemma word_bits_size:\n  \"size (w::word64) = word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size w = word_bits", "by (simp add: word_bits_def word_size)"], ["", "lemmas word64_power_less_1' = word_power_less_1[where 'a = 64]"], ["", "lemmas word64_power_less_1[simp] = word64_power_less_1'[folded word_bits_def]"], ["", "lemma of_nat64_0:\n  \"\\<lbrakk>of_nat n = (0::word64); n < 2 ^ word_bits\\<rbrakk> \\<Longrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_of_nat n = 0; n < 2 ^ word_bits\\<rbrakk>\n    \\<Longrightarrow> n = 0", "by (erule of_nat_0, simp add: word_bits_def)"], ["", "lemma unat_mask_2_less_4:\n  \"unat (p && mask 2 :: word64) < 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (p && mask 2) < 4", "apply (rule unat_less_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p && mask 2 < word_of_nat 4", "apply (rule order_le_less_trans, rule word_and_le1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask 2 < word_of_nat 4", "apply (simp add: mask_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas unat_of_nat64' = unat_of_nat_eq[where 'a=64]"], ["", "lemmas unat_of_nat64 = unat_of_nat64'[unfolded word_bits_len_of]"], ["", "lemmas word_power_nonzero_64 = word_power_nonzero [where 'a=64, folded word_bits_def]"], ["", "lemmas unat_mult_simple = iffD1 [OF unat_mult_lem [where 'a = 64, unfolded word_bits_len_of]]"], ["", "lemmas div_power_helper_64 = div_power_helper [where 'a=64, folded word_bits_def]"], ["", "lemma n_less_word_bits:\n  \"(n < word_bits) = (n < 64)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < word_bits) = (n < 64)", "by (simp add: word_bits_def)"], ["", "lemmas of_nat_less_pow_64 = of_nat_power [where 'a=64, folded word_bits_def]"], ["", "lemma lt_word_bits_lt_pow:\n  \"sz < word_bits \\<Longrightarrow> sz < 2 ^ word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < word_bits \\<Longrightarrow> sz < 2 ^ word_bits", "by (simp add: word_bits_conv)"], ["", "lemma unat_less_word_bits:\n  fixes y :: word64\n  shows \"x < unat y \\<Longrightarrow> x < 2 ^ word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < unat y \\<Longrightarrow> x < 2 ^ word_bits", "unfolding word_bits_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < unat y \\<Longrightarrow> x < 2 ^ LENGTH(64)", "by (rule order_less_trans [OF _ unat_lt2p])"], ["", "lemmas unat_mask_word64' = unat_mask[where 'a=64]"], ["", "lemmas unat_mask_word64 = unat_mask_word64'[folded word_bits_def]"], ["", "lemma unat_less_2p_word_bits:\n  \"unat (x :: 64 word) < 2 ^ word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ word_bits", "apply (simp only: word_bits_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ LENGTH(64)", "apply (rule unat_lt2p)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Suc_unat_mask_div:\n  \"Suc (unat (mask sz div word_size::word64)) = 2 ^ (min sz word_bits - 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (case_tac \"sz < word_bits\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (case_tac \"3 \\<le> sz\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sz < word_bits; 3 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 3)\n 2. \\<lbrakk>sz < word_bits; \\<not> 3 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 3)\n 3. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (clarsimp simp: word_size_def word_bits_def min_def mask_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sz < 64; 3 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat ((2 ^ sz - 1) div 8)) = 2 ^ (sz - 3)\n 2. \\<lbrakk>sz < word_bits; \\<not> 3 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 3)\n 3. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (drule (2) Suc_div_unat_helper\n           [where 'a=64 and sz=sz and us=3, simplified, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sz < word_bits; \\<not> 3 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 3)\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (simp add: not_le word_size_def word_bits_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < 3 \\<Longrightarrow> unat (mask sz div 8) = 0\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (case_tac sz, simp add: unat_word_ariths)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>sz < 3; sz = Suc nat\\<rbrakk>\n       \\<Longrightarrow> unat (mask sz div 8) = 0\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (case_tac nat, simp add: unat_word_ariths\n                                  unat_mask_word64 min_def word_bits_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata.\n       \\<lbrakk>sz < 3; sz = Suc nat; nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> unat (mask sz div 8) = 0\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (case_tac nata, simp add: unat_word_ariths unat_mask_word64 word_bits_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata natb.\n       \\<lbrakk>sz < 3; sz = Suc nat; nat = Suc nata;\n        nata = Suc natb\\<rbrakk>\n       \\<Longrightarrow> unat (mask sz div 8) = 0\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 3)", "apply (simp add: unat_word_ariths\n                   unat_mask_word64 min_def word_bits_def word_size_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word64_minus_one_le' = word_minus_one_le[where 'a=64]"], ["", "lemmas word64_minus_one_le = word64_minus_one_le'[simplified]"], ["", "lemma ucast_not_helper:\n  fixes a::\"8 word\"\n  assumes a: \"a \\<noteq> 0xFF\"\n  shows \"ucast a \\<noteq> (0xFF::word64)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 64) a \\<noteq> 255", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 64) a = 255 \\<Longrightarrow> False", "assume \"ucast a = (0xFF::word64)\""], ["proof (state)\nthis:\n  UCAST(8 \\<rightarrow> 64) a = 255\n\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 64) a = 255 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  UCAST(8 \\<rightarrow> 64) a = 255\n\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 64) a = 255 \\<Longrightarrow> False", "have \"(0xFF::word64) = ucast (0xFF::8 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 255 = UCAST(8 \\<rightarrow> 64) 255", "by simp"], ["proof (state)\nthis:\n  255 = UCAST(8 \\<rightarrow> 64) 255\n\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 64) a = 255 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  UCAST(8 \\<rightarrow> 64) a = UCAST(8 \\<rightarrow> 64) 255", "show False"], ["proof (prove)\nusing this:\n  UCAST(8 \\<rightarrow> 64) a = UCAST(8 \\<rightarrow> 64) 255\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  UCAST(8 \\<rightarrow> 64) a = UCAST(8 \\<rightarrow> 64) 255\n  a \\<noteq> 255\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>UCAST(8 \\<rightarrow> 64) a = UCAST(8 \\<rightarrow> 64) 255;\n     a \\<noteq> 255\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule up_ucast_inj, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 255; a = 255\\<rbrakk> \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_4_cases:\n  \"(x::word64) < 4 \\<Longrightarrow> x=0 \\<or> x=1 \\<or> x=2 \\<or> x=3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 4 \\<Longrightarrow> x = 0 \\<or> x = 1 \\<or> x = 2 \\<or> x = 3", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 4; x \\<noteq> 0; x \\<noteq> 1; x \\<noteq> 3\\<rbrakk>\n    \\<Longrightarrow> x = 2", "apply (drule word_less_cases, erule disjE, simp, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_then_1_else_0:\n  \"((if P then 1 else 0) = (0 :: word64)) = (\\<not> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then 1 else 0) = 0) = (\\<not> P)", "by simp"], ["", "lemma if_then_0_else_1:\n  \"((if P then 0 else 1) = (0 :: word64)) = (P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then 0 else 1) = 0) = P", "by simp"], ["", "lemmas if_then_simps = if_then_0_else_1 if_then_1_else_0"], ["", "lemma ucast_le_ucast_8_64:\n  \"(ucast x \\<le> (ucast y :: word64)) = (x \\<le> (y :: 8 word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UCAST(8 \\<rightarrow> 64) x \\<le> UCAST(8 \\<rightarrow> 64) y) =\n    (x \\<le> y)", "by (simp add: ucast_le_ucast)"], ["", "lemma in_16_range:\n  \"0 \\<in> S \\<Longrightarrow> r \\<in> (\\<lambda>x. r + x * (16 :: word64)) ` S\"\n  \"n - 1 \\<in> S \\<Longrightarrow> (r + (16 * n - 16)) \\<in> (\\<lambda>x :: word64. r + x * 16) ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<in> S \\<Longrightarrow> r \\<in> (\\<lambda>x. r + x * 16) ` S) &&&\n    (n - 1 \\<in> S \\<Longrightarrow>\n     r + (16 * n - 16) \\<in> (\\<lambda>x. r + x * 16) ` S)", "by (clarsimp simp: image_def elim!: bexI[rotated])+"], ["", "lemma eq_2_64_0:\n  \"(2 ^ 64 :: word64) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 64 = 0", "by simp"], ["", "lemma x_less_2_0_1:\n  fixes x :: word64 shows\n  \"x < 2 \\<Longrightarrow> x = 0 \\<or> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 \\<Longrightarrow> x = 0 \\<or> x = 1", "by (rule x_less_2_0_1') auto"], ["", "lemmas mask_64_max_word  = max_word_mask [symmetric, where 'a=64, simplified]"], ["", "lemma of_nat64_n_less_equal_power_2:\n \"n < 64 \\<Longrightarrow> ((of_nat n)::64 word) < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 64 \\<Longrightarrow> word_of_nat n < 2 ^ n", "by (rule of_nat_n_less_equal_power_2, clarsimp simp: word_size)"], ["", "lemma word_rsplit_0:\n  \"word_rsplit (0 :: word64) = [0, 0, 0, 0, 0, 0, 0, 0 :: 8 word]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_rsplit 0 = [0, 0, 0, 0, 0, 0, 0, 0]", "by (simp add: word_rsplit_def bin_rsplit_def)"], ["", "lemma unat_ucast_10_64 :\n  fixes x :: \"10 word\"\n  shows \"unat (ucast x :: word64) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (UCAST(10 \\<rightarrow> 64) x) = unat x", "by transfer simp"], ["", "lemma bool_mask [simp]:\n  fixes x :: word64\n  shows \"(0 < x && 1) = (x && 1 = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x && 1) = (x && 1 = 1)", "by (rule bool_mask') auto"], ["", "lemma word64_bounds:\n  \"- (2 ^ (size (x :: word64) - 1)) = (-9223372036854775808 :: int)\"\n  \"((2 ^ (size (x :: word64) - 1)) - 1) = (9223372036854775807 :: int)\"\n  \"- (2 ^ (size (y :: 64 signed word) - 1)) = (-9223372036854775808 :: int)\"\n  \"((2 ^ (size (y :: 64 signed word) - 1)) - 1) = (9223372036854775807 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (2 ^ (size x - 1)) = - 9223372036854775808 &&&\n     2 ^ (size x - 1) - 1 = 9223372036854775807) &&&\n    - (2 ^ (size y - 1)) = - 9223372036854775808 &&&\n    2 ^ (size y - 1) - 1 = 9223372036854775807", "by (simp_all add: word_size)"], ["", "lemma word_ge_min:\"sint (x::64 word) \\<ge> -9223372036854775808\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 9223372036854775808 \\<le> sint x", "by (metis sint_ge word64_bounds(1) word_size)"], ["", "lemmas signed_arith_ineq_checks_to_eq_word64'\n    = signed_arith_ineq_checks_to_eq[where 'a=64]\n      signed_arith_ineq_checks_to_eq[where 'a=\"64 signed\"]"], ["", "lemmas signed_arith_ineq_checks_to_eq_word64\n    = signed_arith_ineq_checks_to_eq_word64' [unfolded word64_bounds]"], ["", "lemmas signed_mult_eq_checks64_to_64'\n    = signed_mult_eq_checks_double_size[where 'a=64 and 'b=64]\n      signed_mult_eq_checks_double_size[where 'a=\"64 signed\" and 'b=64]"], ["", "lemmas signed_mult_eq_checks64_to_64 = signed_mult_eq_checks64_to_64'[simplified]"], ["", "lemmas sdiv_word64_max' = sdiv_word_max [where 'a=64] sdiv_word_max [where 'a=\"64 signed\"]"], ["", "lemmas sdiv_word64_max = sdiv_word64_max'[simplified word_size, simplified]"], ["", "lemmas sdiv_word64_min' = sdiv_word_min [where 'a=64] sdiv_word_min [where 'a=\"64 signed\"]"], ["", "lemmas sdiv_word64_min = sdiv_word64_min' [simplified word_size, simplified]"], ["", "lemmas sint64_of_int_eq' = sint_of_int_eq [where 'a=64]"], ["", "lemmas sint64_of_int_eq = sint64_of_int_eq' [simplified]"], ["", "lemma ucast_of_nats [simp]:\n  \"(ucast (of_nat x :: word64) :: sword64) = (of_nat x)\"\n  \"(ucast (of_nat x :: word64) :: 16 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: word64) :: 8 sword) = (of_nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST(64 \\<rightarrow> 64 signed) (word_of_nat x) = word_of_nat x &&&\n    UCAST(64 \\<rightarrow> 16 signed) (word_of_nat x) = word_of_nat x &&&\n    UCAST(64 \\<rightarrow> 8 signed) (word_of_nat x) = word_of_nat x", "by (simp_all add: of_nat_take_bit take_bit_word_eq_self)"], ["", "lemmas signed_shift_guard_simpler_64'\n    = power_strict_increasing_iff[where b=\"2 :: nat\" and y=31]"], ["", "lemmas signed_shift_guard_simpler_64 = signed_shift_guard_simpler_64'[simplified]"], ["", "lemma word64_31_less:\n  \"31 < len_of TYPE (64 signed)\" \"31 > (0 :: nat)\"\n  \"31 < len_of TYPE (64)\" \"31 > (0 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (31 < LENGTH(64 signed) &&& 0 < 31) &&& 31 < LENGTH(64) &&& 0 < 31", "by auto"], ["", "lemmas signed_shift_guard_to_word_64\n    = signed_shift_guard_to_word[OF word64_31_less(1-2)]\n    signed_shift_guard_to_word[OF word64_31_less(3-4)]"], ["", "lemma le_step_down_word_3:\n  fixes x :: \"64 word\"\n  shows \"\\<lbrakk>x \\<le>  y; x \\<noteq> y; y < 2 ^ 64 - 1\\<rbrakk> \\<Longrightarrow> x \\<le> y - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x \\<noteq> y; y < 2 ^ 64 - 1\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 1", "by (rule le_step_down_word_2, assumption+)"], ["", "lemma shiftr_1:\n  \"(x::word64) >> 1 = 0 \\<Longrightarrow> x < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> 1 = 0 \\<Longrightarrow> x < 2", "by transfer (simp add: take_bit_drop_bit drop_bit_Suc)"], ["", "lemma mask_step_down_64:\n  \\<open>\\<exists>x. mask x = b\\<close> if \\<open>b && 1 = 1\\<close>\n    and \\<open>\\<exists>x. x < 64 \\<and> mask x = b >> 1\\<close> for b :: \\<open>64word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "from \\<open>b && 1 = 1\\<close>"], ["proof (chain)\npicking this:\n  b && 1 = 1", "have \\<open>odd b\\<close>"], ["proof (prove)\nusing this:\n  b && 1 = 1\n\ngoal (1 subgoal):\n 1. odd b", "by (auto simp add: mod_2_eq_odd and_one_eq)"], ["proof (state)\nthis:\n  odd b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "then"], ["proof (chain)\npicking this:\n  odd b", "have \\<open>b mod 2 = 1\\<close>"], ["proof (prove)\nusing this:\n  odd b\n\ngoal (1 subgoal):\n 1. b mod 2 = 1", "using odd_iff_mod_2_eq_one"], ["proof (prove)\nusing this:\n  odd b\n  odd ?a = (?a mod (2::?'a) = (1::?'a))\n\ngoal (1 subgoal):\n 1. b mod 2 = 1", "by blast"], ["proof (state)\nthis:\n  b mod 2 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "from \\<open>\\<exists>x. x < 64 \\<and> mask x = b >> 1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>x<64. mask x = b >> 1", "obtain x where \\<open>x < 64\\<close> \\<open>mask x = b >> 1\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x<64. mask x = b >> 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x < 64; mask x = b >> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x < 64\n  mask x = b >> 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "then"], ["proof (chain)\npicking this:\n  x < 64\n  mask x = b >> 1", "have \\<open>mask x = b div 2\\<close>"], ["proof (prove)\nusing this:\n  x < 64\n  mask x = b >> 1\n\ngoal (1 subgoal):\n 1. mask x = b div 2", "using shiftr1_is_div_2 [of b]"], ["proof (prove)\nusing this:\n  x < 64\n  mask x = b >> 1\n  b >> 1 = b div 2\n\ngoal (1 subgoal):\n 1. mask x = b div 2", "by simp"], ["proof (state)\nthis:\n  mask x = b div 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "with \\<open>b mod 2 = 1\\<close>"], ["proof (chain)\npicking this:\n  b mod 2 = 1\n  mask x = b div 2", "have \\<open>2 * mask x + 1 = 2 * (b div 2) + b mod 2\\<close>"], ["proof (prove)\nusing this:\n  b mod 2 = 1\n  mask x = b div 2\n\ngoal (1 subgoal):\n 1. 2 * mask x + 1 = 2 * (b div 2) + b mod 2", "by (simp only:)"], ["proof (state)\nthis:\n  2 * mask x + 1 = 2 * (b div 2) + b mod 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "also"], ["proof (state)\nthis:\n  2 * mask x + 1 = 2 * (b div 2) + b mod 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "have \\<open>\\<dots> = b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (b div 2) + b mod 2 = b", "by (simp add: mult_div_mod_eq)"], ["proof (state)\nthis:\n  2 * (b div 2) + b mod 2 = b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "finally"], ["proof (chain)\npicking this:\n  2 * mask x + 1 = b", "have \\<open>2 * mask x + 1 = b\\<close>"], ["proof (prove)\nusing this:\n  2 * mask x + 1 = b\n\ngoal (1 subgoal):\n 1. 2 * mask x + 1 = b", "."], ["proof (state)\nthis:\n  2 * mask x + 1 = b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "moreover"], ["proof (state)\nthis:\n  2 * mask x + 1 = b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "have \\<open>mask (Suc x) = 2 * mask x + (1 :: 'a::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc x) = 2 * mask x + 1", "by (simp add: mask_Suc_rec)"], ["proof (state)\nthis:\n  mask (Suc x) = 2 * mask x + 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "ultimately"], ["proof (chain)\npicking this:\n  2 * mask x + 1 = b\n  mask (Suc x) = 2 * mask x + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * mask x + 1 = b\n  mask (Suc x) = 2 * mask x + 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. mask x = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unat_of_int_64:\n  \"\\<lbrakk>i \\<ge> 0; i \\<le> 2 ^ 63\\<rbrakk> \\<Longrightarrow> (unat ((of_int i)::sword64)) = nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 63\\<rbrakk>\n    \\<Longrightarrow> unat (word_of_int i) = nat i", "unfolding unat_eq_nat_uint"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 63\\<rbrakk>\n    \\<Longrightarrow> nat (uint (word_of_int i)) = nat i", "apply (subst eq_nat_nat_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 63\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> uint (word_of_int i)\n 2. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 63\\<rbrakk> \\<Longrightarrow> 0 \\<le> i\n 3. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 63\\<rbrakk>\n    \\<Longrightarrow> uint (word_of_int i) = i", "apply (simp_all add: take_bit_int_eq_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_ctz_not_minus_1_64 = word_ctz_not_minus_1[where 'a=64, simplified]"], ["", "lemma word64_and_max_simp:\n  \\<open>x AND 0xFFFFFFFFFFFFFFFF = x\\<close> for x :: \\<open>64 word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x && 18446744073709551615 = x", "using word_and_full_mask_simp [of x]"], ["proof (prove)\nusing this:\n  x && mask LENGTH(64) = x\n\ngoal (1 subgoal):\n 1. x && 18446744073709551615 = x", "by (simp add: numeral_eq_Suc mask_Suc_exp)"], ["", "end"]]}