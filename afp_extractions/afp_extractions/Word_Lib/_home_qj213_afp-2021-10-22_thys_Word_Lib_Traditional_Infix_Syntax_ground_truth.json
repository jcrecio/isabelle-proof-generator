{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Traditional_Infix_Syntax.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma test_bit_word_transfer [transfer_rule]:\n  \\<open>(pcr_word ===> (=)) (\\<lambda>k n. n < LENGTH('a) \\<and> bit k n) (test_bit :: 'a::len word \\<Rightarrow> _)\\<close>", "lemma shiftl_word_transfer [transfer_rule]:\n  \\<open>(pcr_word ===> (=) ===> pcr_word) (\\<lambda>k n. push_bit n k) shiftl\\<close>", "lemma shiftr_word_transfer [transfer_rule]:\n  \\<open>(pcr_word ===> (=) ===> pcr_word) (\\<lambda>k n. (drop_bit n \\<circ> take_bit LENGTH('a)) k) (shiftr :: 'a::len word \\<Rightarrow> _)\\<close>", "lemma test_bit_word_eq:\n  \\<open>test_bit = (bit :: 'a::len word \\<Rightarrow> _)\\<close>", "lemma shiftl_word_eq:\n  \\<open>w << n = push_bit n w\\<close> for w :: \\<open>'a::len word\\<close>", "lemma shiftr_word_eq:\n  \\<open>w >> n = drop_bit n w\\<close> for w :: \\<open>'a::len word\\<close>", "lemma test_bit_eq_iff: \"test_bit u = test_bit v \\<longleftrightarrow> u = v\"\n  for u v :: \"'a::len word\"", "lemma test_bit_size: \"w !! n \\<Longrightarrow> n < size w\"\n  for w :: \"'a::len word\"", "lemma word_eq_iff: \"x = y \\<longleftrightarrow> (\\<forall>n<LENGTH('a). x !! n = y !! n)\" (is \\<open>?P \\<longleftrightarrow> ?Q\\<close>)\n  for x y :: \"'a::len word\"", "lemma word_eqI: \"(\\<And>n. n < size u \\<longrightarrow> u !! n = v !! n) \\<Longrightarrow> u = v\"\n  for u :: \"'a::len word\"", "lemma word_eqD: \"u = v \\<Longrightarrow> u !! x = v !! x\"\n  for u v :: \"'a::len word\"", "lemma test_bit_bin': \"w !! n \\<longleftrightarrow> n < size w \\<and> bit (uint w) n\"", "lemmas test_bit_bin = test_bit_bin' [unfolded word_size]", "lemma word_test_bit_def:\n  \\<open>test_bit a = bit (uint a)\\<close>", "lemmas test_bit_def' = word_test_bit_def [THEN fun_cong]", "lemma word_test_bit_transfer [transfer_rule]:\n  \"(rel_fun pcr_word (rel_fun (=) (=)))\n    (\\<lambda>x n. n < LENGTH('a) \\<and> bit x n) (test_bit :: 'a::len word \\<Rightarrow> _)\"", "lemma test_bit_wi [simp]:\n  \"(word_of_int x :: 'a::len word) !! n \\<longleftrightarrow> n < LENGTH('a) \\<and> bit x n\"", "lemma word_ops_nth_size:\n  \"n < size x \\<Longrightarrow>\n    (x OR y) !! n = (x !! n | y !! n) \\<and>\n    (x AND y) !! n = (x !! n \\<and> y !! n) \\<and>\n    (x XOR y) !! n = (x !! n \\<noteq> y !! n) \\<and>\n    (NOT x) !! n = (\\<not> x !! n)\"\n  for x :: \"'a::len word\"", "lemma word_ao_nth:\n  \"(x OR y) !! n = (x !! n | y !! n) \\<and>\n    (x AND y) !! n = (x !! n \\<and> y !! n)\"\n  for x :: \"'a::len word\"", "lemmas msb0 = len_gt_0 [THEN diff_Suc_less, THEN word_ops_nth_size [unfolded word_size]]", "lemmas msb1 = msb0 [where i = 0]", "lemma test_bit_numeral [simp]:\n  \"(numeral w :: 'a::len word) !! n \\<longleftrightarrow>\n    n < LENGTH('a) \\<and> bit (numeral w :: int) n\"", "lemma test_bit_neg_numeral [simp]:\n  \"(- numeral w :: 'a::len word) !! n \\<longleftrightarrow>\n    n < LENGTH('a) \\<and> bit (- numeral w :: int) n\"", "lemma test_bit_1 [iff]: \"(1 :: 'a::len word) !! n \\<longleftrightarrow> n = 0\"", "lemma nth_0 [simp]: \"\\<not> (0 :: 'a::len word) !! n\"", "lemma nth_minus1 [simp]: \"(-1 :: 'a::len word) !! n \\<longleftrightarrow> n < LENGTH('a)\"", "lemma shiftl1_code [code]:\n  \\<open>shiftl1 w = push_bit 1 w\\<close>", "lemma uint_shiftr_eq:\n  \\<open>uint (w >> n) = uint w div 2 ^ n\\<close>", "lemma shiftr1_code [code]:\n  \\<open>shiftr1 w = drop_bit 1 w\\<close>", "lemma shiftl_def:\n  \\<open>w << n = (shiftl1 ^^ n) w\\<close>", "lemma shiftr_def:\n  \\<open>w >> n = (shiftr1 ^^ n) w\\<close>", "lemma bit_shiftl_word_iff [bit_simps]:\n  \\<open>bit (w << m) n \\<longleftrightarrow> m \\<le> n \\<and> n < LENGTH('a) \\<and> bit w (n - m)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma bit_shiftr_word_iff [bit_simps]:\n  \\<open>bit (w >> m) n \\<longleftrightarrow> bit w (m + n)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma sshiftr_eq [code]:\n  \\<open>w >>> n = signed_drop_bit n w\\<close>", "lemma sshiftr_eq_funpow_sshiftr1:\n  \\<open>w >>> n = (sshiftr1 ^^ n) w\\<close>", "lemma uint_sshiftr_eq:\n  \\<open>uint (w >>> n) = take_bit LENGTH('a) (sint w div 2 ^  n)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma sshift1_code [code]:\n  \\<open>sshiftr1 w = signed_drop_bit 1 w\\<close>", "lemma sshiftr_0 [simp]: \"0 >>> n = 0\"", "lemma sshiftr_n1 [simp]: \"-1 >>> n = -1\"", "lemma bit_sshiftr_word_iff [bit_simps]:\n  \\<open>bit (w >>> m) n \\<longleftrightarrow> bit w (if LENGTH('a) - m \\<le> n \\<and> n < LENGTH('a) then LENGTH('a) - 1 else (m + n))\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma nth_sshiftr :\n  \"(w >>> m) !! n =\n    (n < size w \\<and> (if n + m \\<ge> size w then w !! (size w - 1) else w !! (n + m)))\"", "lemma sshiftr_numeral [simp]:\n  \\<open>(numeral k >>> numeral n :: 'a::len word) =\n    word_of_int (drop_bit (numeral n) (signed_take_bit (LENGTH('a) - 1) (numeral k)))\\<close>", "lemma revcast_down_us [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = ucast (w >>> n)\"\n  for w :: \"'a::len word\"", "lemma revcast_down_ss [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = scast (w >>> n)\"\n  for w :: \"'a::len word\"", "lemma sshiftr_div_2n: \"sint (w >>> n) = sint w div 2 ^ n\"", "lemmas lsb0 = len_gt_0 [THEN word_ops_nth_size [unfolded word_size]]", "lemma nth_sint:\n  fixes w :: \"'a::len word\"\n  defines \"l \\<equiv> LENGTH('a)\"\n  shows \"bit (sint w) n = (if n < l - 1 then w !! n else w !! (l - 1))\"", "lemma test_bit_2p: \"(word_of_int (2 ^ n)::'a::len word) !! m \\<longleftrightarrow> m = n \\<and> m < LENGTH('a)\"", "lemma nth_w2p: \"((2::'a::len word) ^ n) !! m \\<longleftrightarrow> m = n \\<and> m < LENGTH('a::len)\"", "lemma bang_is_le: \"x !! m \\<Longrightarrow> 2 ^ m \\<le> x\"\n  for x :: \"'a::len word\"", "lemma mask_eq:\n  \\<open>mask n = (1 << n) - (1 :: 'a::len word)\\<close>", "lemma nth_ucast:\n  \"(ucast w::'a::len word) !! n = (w !! n \\<and> n < LENGTH('a))\"", "lemma shiftl_0 [simp]: \"(0::'a::len word) << n = 0\"", "lemma shiftr_0 [simp]: \"(0::'a::len word) >> n = 0\"", "lemma nth_shiftl1: \"shiftl1 w !! n \\<longleftrightarrow> n < size w \\<and> n > 0 \\<and> w !! (n - 1)\"", "lemma nth_shiftl': \"(w << m) !! n \\<longleftrightarrow> n < size w \\<and> n >= m \\<and> w !! (n - m)\"\n  for w :: \"'a::len word\"", "lemmas nth_shiftl = nth_shiftl' [unfolded word_size]", "lemma nth_shiftr1: \"shiftr1 w !! n = w !! Suc n\"", "lemma nth_shiftr: \"(w >> m) !! n = w !! (n + m)\"\n  for w :: \"'a::len word\"", "lemma nth_sshiftr1: \"sshiftr1 w !! n = (if n = size w - 1 then w !! n else w !! Suc n)\"", "lemma shiftr_div_2n: \"uint (shiftr w n) = uint w div 2 ^ n\"", "lemma shiftl_rev: \"shiftl w n = word_reverse (shiftr (word_reverse w) n)\"", "lemma rev_shiftl: \"word_reverse w << n = word_reverse (w >> n)\"", "lemma shiftr_rev: \"w >> n = word_reverse (word_reverse w << n)\"", "lemma rev_shiftr: \"word_reverse w >> n = word_reverse (w << n)\"", "lemma shiftl_numeral [simp]:\n  \\<open>numeral k << numeral l = (push_bit (numeral l) (numeral k) :: 'a::len word)\\<close>", "lemma shiftl_zero_size: \"size x \\<le> n \\<Longrightarrow> x << n = 0\"\n  for x :: \"'a::len word\"", "lemma shiftl_t2n: \"shiftl w n = 2 ^ n * w\"\n  for w :: \"'a::len word\"", "lemma shiftr_numeral [simp]:\n  \\<open>(numeral k >> numeral n :: 'a::len word) = drop_bit (numeral n) (numeral k)\\<close>", "lemma shiftr_numeral_Suc [simp]:\n  \\<open>(numeral k >> Suc 0 :: 'a::len word) = drop_bit (Suc 0) (numeral k)\\<close>", "lemma drop_bit_numeral_bit0_1 [simp]:\n  \\<open>drop_bit (Suc 0) (numeral k) =\n    (word_of_int (drop_bit (Suc 0) (take_bit LENGTH('a) (numeral k))) :: 'a::len word)\\<close>", "lemma nth_mask [simp]:\n  \\<open>(mask n :: 'a::len word) !! i \\<longleftrightarrow> i < n \\<and> i < size (mask n :: 'a word)\\<close>", "lemma slice_shiftr: \"slice n w = ucast (w >> n)\"", "lemma nth_slice: \"(slice n w :: 'a::len word) !! m = (w !! (m + n) \\<and> m < LENGTH('a))\"", "lemma revcast_down_uu [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = ucast (w >> n)\"\n  for w :: \"'a::len word\"", "lemma revcast_down_su [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = scast (w >> n)\"\n  for w :: \"'a::len word\"", "lemma cast_down_rev [OF refl]:\n  \"uc = ucast \\<Longrightarrow> source_size uc = target_size uc + n \\<Longrightarrow> uc w = revcast (w << n)\"\n  for w :: \"'a::len word\"", "lemma revcast_up [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc + n = target_size rc \\<Longrightarrow>\n    rc w = (ucast w :: 'a::len word) << n\"", "lemmas rc1 = revcast_up [THEN\n  revcast_rev_ucast [symmetric, THEN trans, THEN word_rev_gal, symmetric]]", "lemmas rc2 = revcast_down_uu [THEN\n  revcast_rev_ucast [symmetric, THEN trans, THEN word_rev_gal, symmetric]]", "lemmas ucast_up =\n  rc1 [simplified rev_shiftr [symmetric] revcast_ucast [symmetric]]", "lemmas ucast_down =\n  rc2 [simplified rev_shiftr revcast_ucast [symmetric]]\n\n\\<comment> \\<open>problem posed by TPHOLs referee:\n      criterion for overflow of addition of signed integers\\<close>", "lemma sofl_test:\n  \\<open>sint x + sint y = sint (x + y) \\<longleftrightarrow>\n    (x + y XOR x) AND (x + y XOR y) >> (size x - 1) = 0\\<close>\n  for x y :: \\<open>'a::len word\\<close>", "lemma shiftr_zero_size: \"size x \\<le> n \\<Longrightarrow> x >> n = 0\"\n  for x :: \"'a :: len word\"", "lemma test_bit_cat [OF refl]:\n  \"wc = word_cat a b \\<Longrightarrow> wc !! n = (n < size wc \\<and>\n    (if n < size b then b !! n else a !! (n - size b)))\"", "lemma test_bit_split':\n  \"word_split c = (a, b) \\<longrightarrow>\n    (\\<forall>n m.\n      b !! n = (n < size b \\<and> c !! n) \\<and>\n      a !! m = (m < size a \\<and> c !! (m + size b)))\"", "lemma test_bit_split:\n  \"word_split c = (a, b) \\<Longrightarrow>\n    (\\<forall>n::nat. b !! n \\<longleftrightarrow> n < size b \\<and> c !! n) \\<and>\n    (\\<forall>m::nat. a !! m \\<longleftrightarrow> m < size a \\<and> c !! (m + size b))\"", "lemma test_bit_split_eq:\n  \"word_split c = (a, b) \\<longleftrightarrow>\n    ((\\<forall>n::nat. b !! n = (n < size b \\<and> c !! n)) \\<and>\n     (\\<forall>m::nat. a !! m = (m < size a \\<and> c !! (m + size b))))\"", "lemma test_bit_rcat:\n  \"sw = size (hd wl) \\<Longrightarrow> rc = word_rcat wl \\<Longrightarrow> rc !! n =\n    (n < size rc \\<and> n div sw < size wl \\<and> (rev wl) ! (n div sw) !! (n mod sw))\"\n  for wl :: \"'a::len word list\"", "lemmas test_bit_cong = arg_cong [where f = \"test_bit\", THEN fun_cong]", "lemma max_test_bit: \"(max_word::'a::len word) !! n \\<longleftrightarrow> n < LENGTH('a)\"", "lemma shiftr_x_0 [iff]: \"x >> 0 = x\"\n  for x :: \"'a::len word\"", "lemma shiftl_x_0 [simp]: \"x << 0 = x\"\n  for x :: \"'a::len word\"", "lemma shiftl_1 [simp]: \"(1::'a::len word) << n = 2^n\"", "lemma shiftr_1[simp]: \"(1::'a::len word) >> n = (if n = 0 then 1 else 0)\"", "lemma map_nth_0 [simp]: \"map ((!!) (0::'a::len word)) xs = replicate (length xs) False\"", "lemma word_and_1:\n  \"n AND 1 = (if n !! 0 then 1 else 0)\" for n :: \"_ word\"", "lemma test_bit_1' [simp]:\n  \"(1 :: 'a :: len word) !! n \\<longleftrightarrow> 0 < LENGTH('a) \\<and> n = 0\"", "lemma shiftl0:\n  \"x << 0 = (x :: 'a :: len word)\"", "lemma word_ops_nth [simp]:\n  fixes x y :: \\<open>'a::len word\\<close>\n  shows\n  word_or_nth:  \"(x OR y) !! n = (x !! n \\<or> y !! n)\" and\n  word_and_nth: \"(x AND y) !! n = (x !! n \\<and> y !! n)\" and\n  word_xor_nth: \"(x XOR y) !! n = (x !! n \\<noteq> y !! n)\"", "lemma and_not_mask:\n  \"w AND NOT (mask n) = (w >> n) << n\"\n  for w :: \\<open>'a::len word\\<close>", "lemma and_mask:\n  \"w AND mask n = (w << (size w - n)) >> (size w - n)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma nth_w2p_same:\n  \"(2^n :: 'a :: len word) !! n = (n < LENGTH('a))\"", "lemma shiftr_div_2n_w: \"n < size w \\<Longrightarrow> w >> n = w div (2^n :: 'a :: len word)\"", "lemma le_shiftr:\n  \"u \\<le> v \\<Longrightarrow> u >> (n :: nat) \\<le> (v :: 'a :: len word) >> n\"", "lemma shiftr_mask_le:\n  \"n <= m \\<Longrightarrow> mask n >> m = (0 :: 'a::len word)\"", "lemma shiftr_mask [simp]:\n  \\<open>mask m >> m = (0::'a::len word)\\<close>", "lemma word_leI:\n  \"(\\<And>n.  \\<lbrakk>n < size (u::'a::len word); u !! n \\<rbrakk> \\<Longrightarrow> (v::'a::len word) !! n) \\<Longrightarrow> u <= v\"", "lemma le_mask_iff:\n  \"(w \\<le> mask n) = (w >> n = 0)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma and_mask_eq_iff_shiftr_0:\n  \"(w AND mask n = w) = (w >> n = 0)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma mask_shiftl_decompose:\n  \"mask m << n = mask (m + n) AND NOT (mask n :: 'a::len word)\"", "lemma bang_eq:\n  fixes x :: \"'a::len word\"\n  shows \"(x = y) = (\\<forall>n. x !! n = y !! n)\"", "lemma shiftl_over_and_dist:\n  fixes a::\"'a::len word\"\n  shows \"(a AND b) << c = (a << c) AND (b << c)\"", "lemma shiftr_over_and_dist:\n  fixes a::\"'a::len word\"\n  shows \"a AND b >> c = (a >> c) AND (b >> c)\"", "lemma sshiftr_over_and_dist:\n  fixes a::\"'a::len word\"\n  shows \"a AND b >>> c = (a >>> c) AND (b >>> c)\"", "lemma shiftl_over_or_dist:\n  fixes a::\"'a::len word\"\n  shows \"a OR b << c = (a << c) OR (b << c)\"", "lemma shiftr_over_or_dist:\n  fixes a::\"'a::len word\"\n  shows \"a OR b >> c = (a >> c) OR (b >> c)\"", "lemma sshiftr_over_or_dist:\n  fixes a::\"'a::len word\"\n  shows \"a OR b >>> c = (a >>> c) OR (b >>> c)\"", "lemmas shift_over_ao_dists =\n  shiftl_over_or_dist shiftr_over_or_dist\n  sshiftr_over_or_dist shiftl_over_and_dist\n  shiftr_over_and_dist sshiftr_over_and_dist", "lemma shiftl_shiftl:\n  fixes a::\"'a::len word\"\n  shows \"a << b << c = a << (b + c)\"", "lemma shiftr_shiftr:\n  fixes a::\"'a::len word\"\n  shows \"a >> b >> c = a >> (b + c)\"", "lemma shiftl_shiftr1:\n  fixes a::\"'a::len word\"\n  shows \"c \\<le> b \\<Longrightarrow> a << b >> c = a AND (mask (size a - b)) << (b - c)\"", "lemma shiftl_shiftr2:\n  fixes a::\"'a::len word\"\n  shows \"b < c \\<Longrightarrow> a << b >> c = (a >> (c - b)) AND (mask (size a - c))\"", "lemma shiftr_shiftl1:\n  fixes a::\"'a::len word\"\n  shows \"c \\<le> b \\<Longrightarrow> a >> b << c = (a >> (b - c)) AND (NOT (mask c))\"", "lemma shiftr_shiftl2:\n  fixes a::\"'a::len word\"\n  shows \"b < c \\<Longrightarrow> a >> b << c = (a << (c - b)) AND (NOT (mask c))\"", "lemmas multi_shift_simps =\n  shiftl_shiftl shiftr_shiftr\n  shiftl_shiftr1 shiftl_shiftr2\n  shiftr_shiftl1 shiftr_shiftl2", "lemma shiftr_mask2:\n  \"n \\<le> LENGTH('a) \\<Longrightarrow> (mask n >> m :: ('a :: len) word) = mask (n - m)\"", "lemma word_shiftl_add_distrib:\n  fixes x :: \"'a :: len word\"\n  shows \"(x + y) << n = (x << n) + (y << n)\"", "lemma mask_shift:\n  \"(x AND NOT (mask y)) >> y = x >> y\"\n  for x :: \\<open>'a::len word\\<close>", "lemma shiftr_div_2n':\n  \"unat (w >> n) = unat w div 2 ^ n\"", "lemma shiftl_shiftr_id:\n  assumes nv: \"n < LENGTH('a)\"\n  and     xv: \"x < 2 ^ (LENGTH('a) - n)\"\n  shows \"x << n >> n = (x::'a::len word)\"", "lemma ucast_shiftl_eq_0:\n  fixes w :: \"'a :: len word\"\n  shows \"\\<lbrakk> n \\<ge> LENGTH('b) \\<rbrakk> \\<Longrightarrow> ucast (w << n) = (0 :: 'b :: len word)\"", "lemma word_shift_nonzero:\n  \"\\<lbrakk> (x::'a::len word) \\<le> 2 ^ m; m + n < LENGTH('a::len); x \\<noteq> 0\\<rbrakk>\n   \\<Longrightarrow> x << n \\<noteq> 0\"", "lemma word_shiftr_lt:\n  fixes w :: \"'a::len word\"\n  shows \"unat (w >> n) < (2 ^ (LENGTH('a) - n))\"", "lemma neg_mask_test_bit:\n  \"(NOT(mask n) :: 'a :: len word) !! m = (n \\<le> m \\<and> m < LENGTH('a))\"", "lemma upper_bits_unset_is_l2p:\n  \\<open>(\\<forall>n' \\<ge> n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n') \\<longleftrightarrow> (p < 2 ^ n)\\<close> (is \\<open>?P \\<longleftrightarrow> ?Q\\<close>)\n    if \\<open>n < LENGTH('a)\\<close>\n    for p :: \"'a :: len word\"", "lemma less_2p_is_upper_bits_unset:\n  \"p < 2 ^ n \\<longleftrightarrow> n < LENGTH('a) \\<and> (\\<forall>n' \\<ge> n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n')\" for p :: \"'a :: len word\"", "lemma test_bit_over:\n  \"n \\<ge> size (x::'a::len word) \\<Longrightarrow> (x !! n) = False\"", "lemma le_mask_high_bits:\n  \"w \\<le> mask n \\<longleftrightarrow> (\\<forall>i \\<in> {n ..< size w}. \\<not> w !! i)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma test_bit_conj_lt:\n  \"(x !! m \\<and> m < LENGTH('a)) = x !! m\" for x :: \"'a :: len word\"", "lemma neg_test_bit:\n  \"(NOT x) !! n = (\\<not> x !! n \\<and> n < LENGTH('a))\" for x :: \"'a::len word\"", "lemma shiftr_less_t2n':\n  \"\\<lbrakk> x AND mask (n + m) = x; m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> x >> n < 2 ^ m\" for x :: \"'a :: len word\"", "lemma shiftr_less_t2n:\n  \"x < 2 ^ (n + m) \\<Longrightarrow> x >> n < 2 ^ m\" for x :: \"'a :: len word\"", "lemma shiftr_eq_0:\n  \"n \\<ge> LENGTH('a) \\<Longrightarrow> ((w::'a::len word) >> n) = 0\"", "lemma shiftr_not_mask_0:\n  \"n+m \\<ge> LENGTH('a :: len) \\<Longrightarrow> ((w::'a::len word) >> n) AND NOT (mask m) = 0\"", "lemma shiftl_less_t2n:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> x < (2 ^ (m - n)); m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (x << n) < 2 ^ m\"", "lemma shiftl_less_t2n':\n  \"(x::'a::len word) < 2 ^ m \\<Longrightarrow> m+n < LENGTH('a) \\<Longrightarrow> x << n < 2 ^ (m + n)\"", "lemma nth_w2p_scast [simp]:\n  \"((scast ((2::'a::len signed word) ^ n) :: 'a word) !! m)\n         \\<longleftrightarrow> ((((2::'a::len  word) ^ n) :: 'a word) !! m)\"", "lemma scast_bit_test [simp]:\n    \"scast ((1 :: 'a::len signed word) << n) = (1 :: 'a word) << n\"", "lemma signed_shift_guard_to_word:\n  \"\\<lbrakk> n < len_of TYPE ('a); n > 0 \\<rbrakk>\n    \\<Longrightarrow> (unat (x :: 'a :: len word) * 2 ^ y < 2 ^ n)\n    = (x = 0 \\<or> x < (1 << n >> y))\"", "lemma nth_bounded:\n  \"\\<lbrakk>(x :: 'a :: len word) !! n; x < 2 ^ m; m \\<le> len_of TYPE ('a)\\<rbrakk> \\<Longrightarrow> n < m\"", "lemma shiftl_mask_is_0[simp]:\n  \"(x << n) AND mask n = 0\"\n  for x :: \\<open>'a::len word\\<close>", "lemma rshift_sub_mask_eq:\n  \"(a >> (size a - b)) AND mask b = a >> (size a - b)\"\n  for a :: \\<open>'a::len word\\<close>", "lemma shiftl_shiftr3:\n  \"b \\<le> c \\<Longrightarrow> a << b >> c = (a >> c - b) AND mask (size a - c)\"\n  for a :: \\<open>'a::len word\\<close>", "lemma and_mask_shiftr_comm:\n  \"m \\<le> size w \\<Longrightarrow> (w AND mask m) >> n = (w >> n) AND mask (m-n)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma and_mask_shiftl_comm:\n  \"m+n \\<le> size w \\<Longrightarrow> (w AND mask m) << n = (w << n) AND mask (m+n)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma le_mask_shiftl_le_mask: \"s = m + n \\<Longrightarrow> x \\<le> mask n \\<Longrightarrow> x << m \\<le> mask s\"\n  for x :: \\<open>'a::len word\\<close>", "lemma word_and_1_shiftl:\n  \"x AND (1 << n) = (if x !! n then (1 << n) else 0)\" for x :: \"'a :: len word\"", "lemmas word_and_1_shiftls'\n    = word_and_1_shiftl[where n=0]\n      word_and_1_shiftl[where n=1]\n      word_and_1_shiftl[where n=2]", "lemmas word_and_1_shiftls = word_and_1_shiftls' [simplified]", "lemma word_and_mask_shiftl:\n  \"x AND (mask n << m) = ((x >> m) AND mask n) << m\"\n  for x :: \\<open>'a::len word\\<close>", "lemma shift_times_fold:\n  \"(x :: 'a :: len word) * (2 ^ n) << m = x << (m + n)\"", "lemma of_bool_nth:\n  \"of_bool (x !! v) = (x >> v) AND 1\"\n  for x :: \\<open>'a::len word\\<close>", "lemma shiftr_mask_eq:\n  \"(x >> n) AND mask (size x - n) = x >> n\" for x :: \"'a :: len word\"", "lemma shiftr_mask_eq':\n  \"m = (size x - n) \\<Longrightarrow> (x >> n) AND mask m = x >> n\" for x :: \"'a :: len word\"", "lemma and_eq_0_is_nth:\n  fixes x :: \"'a :: len word\"\n  shows \"y = 1 << n \\<Longrightarrow> ((x AND y) = 0) = (\\<not> (x !! n))\"", "lemma and_neq_0_is_nth:\n  \\<open>x AND y \\<noteq> 0 \\<longleftrightarrow> x !! n\\<close> if \\<open>y = 2 ^ n\\<close> for x y :: \\<open>'a::len word\\<close>", "lemma nth_is_and_neq_0:\n  \"(x::'a::len word) !! n = (x AND 2 ^ n \\<noteq> 0)\"", "lemma word_shift_zero:\n  \"\\<lbrakk> x << n = 0; x \\<le> 2^m; m + n < LENGTH('a)\\<rbrakk> \\<Longrightarrow> (x::'a::len word) = 0\"", "lemma mask_shift_and_negate[simp]:\"(w AND mask n << m) AND NOT (mask n << m) = 0\"\n  for w :: \\<open>'a::len word\\<close>"], "translations": [["", "lemma test_bit_word_transfer [transfer_rule]:\n  \\<open>(pcr_word ===> (=)) (\\<lambda>k n. n < LENGTH('a) \\<and> bit k n) (test_bit :: 'a::len word \\<Rightarrow> _)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_word ===> (=)) (\\<lambda>k n. n < LENGTH('a) \\<and> bit k n) (!!)", "by (unfold test_bit_eq_bit) transfer_prover"], ["", "lemma shiftl_word_transfer [transfer_rule]:\n  \\<open>(pcr_word ===> (=) ===> pcr_word) (\\<lambda>k n. push_bit n k) shiftl\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_word ===> (=) ===> pcr_word) (\\<lambda>k n. push_bit n k) (<<)", "by (unfold shiftl_eq_push_bit) transfer_prover"], ["", "lemma shiftr_word_transfer [transfer_rule]:\n  \\<open>(pcr_word ===> (=) ===> pcr_word) (\\<lambda>k n. (drop_bit n \\<circ> take_bit LENGTH('a)) k) (shiftr :: 'a::len word \\<Rightarrow> _)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_word ===> (=) ===> pcr_word)\n     (\\<lambda>k n. (drop_bit n \\<circ> take_bit LENGTH('a)) k) (>>)", "by (unfold shiftr_eq_drop_bit) transfer_prover"], ["", "end"], ["", "lemma test_bit_word_eq:\n  \\<open>test_bit = (bit :: 'a::len word \\<Rightarrow> _)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (!!) = bit", "by (fact test_bit_eq_bit)"], ["", "lemma shiftl_word_eq:\n  \\<open>w << n = push_bit n w\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w << n = push_bit n w", "by (fact shiftl_eq_push_bit)"], ["", "lemma shiftr_word_eq:\n  \\<open>w >> n = drop_bit n w\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w >> n = drop_bit n w", "by (fact shiftr_eq_drop_bit)"], ["", "lemma test_bit_eq_iff: \"test_bit u = test_bit v \\<longleftrightarrow> u = v\"\n  for u v :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((!!) u = (!!) v) = (u = v)", "by (simp add: bit_eq_iff test_bit_eq_bit fun_eq_iff)"], ["", "lemma test_bit_size: \"w !! n \\<Longrightarrow> n < size w\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w !! n \\<Longrightarrow> n < size w", "by transfer simp"], ["", "lemma word_eq_iff: \"x = y \\<longleftrightarrow> (\\<forall>n<LENGTH('a). x !! n = y !! n)\" (is \\<open>?P \\<longleftrightarrow> ?Q\\<close>)\n  for x y :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (\\<forall>n<LENGTH('a). x !! n = y !! n)", "by transfer (auto simp add: bit_eq_iff bit_take_bit_iff)"], ["", "lemma word_eqI: \"(\\<And>n. n < size u \\<longrightarrow> u !! n = v !! n) \\<Longrightarrow> u = v\"\n  for u :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n < size u \\<longrightarrow> u !! n = v !! n) \\<Longrightarrow>\n    u = v", "by (simp add: word_size word_eq_iff)"], ["", "lemma word_eqD: \"u = v \\<Longrightarrow> u !! x = v !! x\"\n  for u v :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow> u !! x = v !! x", "by simp"], ["", "lemma test_bit_bin': \"w !! n \\<longleftrightarrow> n < size w \\<and> bit (uint w) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w !! n = (n < size w \\<and> bit (uint w) n)", "by transfer (simp add: bit_take_bit_iff)"], ["", "lemmas test_bit_bin = test_bit_bin' [unfolded word_size]"], ["", "lemma word_test_bit_def:\n  \\<open>test_bit a = bit (uint a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (!!) a = bit (uint a)", "by transfer (simp add: fun_eq_iff bit_take_bit_iff)"], ["", "lemmas test_bit_def' = word_test_bit_def [THEN fun_cong]"], ["", "lemma word_test_bit_transfer [transfer_rule]:\n  \"(rel_fun pcr_word (rel_fun (=) (=)))\n    (\\<lambda>x n. n < LENGTH('a) \\<and> bit x n) (test_bit :: 'a::len word \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun pcr_word (rel_fun (=) (=))\n     (\\<lambda>x n. n < LENGTH('a) \\<and> bit x n) (!!)", "by (simp only: test_bit_eq_bit) transfer_prover"], ["", "lemma test_bit_wi [simp]:\n  \"(word_of_int x :: 'a::len word) !! n \\<longleftrightarrow> n < LENGTH('a) \\<and> bit x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int x !! n = (n < LENGTH('a) \\<and> bit x n)", "by transfer simp"], ["", "lemma word_ops_nth_size:\n  \"n < size x \\<Longrightarrow>\n    (x OR y) !! n = (x !! n | y !! n) \\<and>\n    (x AND y) !! n = (x !! n \\<and> y !! n) \\<and>\n    (x XOR y) !! n = (x !! n \\<noteq> y !! n) \\<and>\n    (NOT x) !! n = (\\<not> x !! n)\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < size x \\<Longrightarrow>\n    (x OR y) !! n = (x !! n \\<or> y !! n) \\<and>\n    (x AND y) !! n = (x !! n \\<and> y !! n) \\<and>\n    (x XOR y) !! n = (x !! n \\<noteq> y !! n) \\<and>\n    NOT x !! n = (\\<not> x !! n)", "by transfer (simp add: bit_or_iff bit_and_iff bit_xor_iff bit_not_iff)"], ["", "lemma word_ao_nth:\n  \"(x OR y) !! n = (x !! n | y !! n) \\<and>\n    (x AND y) !! n = (x !! n \\<and> y !! n)\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR y) !! n = (x !! n \\<or> y !! n) \\<and>\n    (x AND y) !! n = (x !! n \\<and> y !! n)", "by transfer (auto simp add: bit_or_iff bit_and_iff)"], ["", "lemmas msb0 = len_gt_0 [THEN diff_Suc_less, THEN word_ops_nth_size [unfolded word_size]]"], ["", "lemmas msb1 = msb0 [where i = 0]"], ["", "lemma test_bit_numeral [simp]:\n  \"(numeral w :: 'a::len word) !! n \\<longleftrightarrow>\n    n < LENGTH('a) \\<and> bit (numeral w :: int) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral w !! n = (n < LENGTH('a) \\<and> bit (numeral w) n)", "by transfer (rule refl)"], ["", "lemma test_bit_neg_numeral [simp]:\n  \"(- numeral w :: 'a::len word) !! n \\<longleftrightarrow>\n    n < LENGTH('a) \\<and> bit (- numeral w :: int) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- numeral w) !! n = (n < LENGTH('a) \\<and> bit (- numeral w) n)", "by transfer (rule refl)"], ["", "lemma test_bit_1 [iff]: \"(1 :: 'a::len word) !! n \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 !! n = (n = 0)", "by transfer (auto simp add: bit_1_iff)"], ["", "lemma nth_0 [simp]: \"\\<not> (0 :: 'a::len word) !! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 0 !! n", "by transfer simp"], ["", "lemma nth_minus1 [simp]: \"(-1 :: 'a::len word) !! n \\<longleftrightarrow> n < LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) !! n = (n < LENGTH('a))", "by transfer simp"], ["", "lemma shiftl1_code [code]:\n  \\<open>shiftl1 w = push_bit 1 w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftl1 w = push_bit 1 w", "by transfer (simp add: ac_simps)"], ["", "lemma uint_shiftr_eq:\n  \\<open>uint (w >> n) = uint w div 2 ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (w >> n) = uint w div 2 ^ n", "by transfer (simp flip: drop_bit_eq_div add: drop_bit_take_bit min_def le_less less_diff_conv)"], ["", "lemma shiftr1_code [code]:\n  \\<open>shiftr1 w = drop_bit 1 w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftr1 w = drop_bit 1 w", "by transfer (simp add: drop_bit_Suc)"], ["", "lemma shiftl_def:\n  \\<open>w << n = (shiftl1 ^^ n) w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w << n = (shiftl1 ^^ n) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w << n = (shiftl1 ^^ n) w", "have \\<open>push_bit n = (((*) 2 ^^ n) :: int \\<Rightarrow> int)\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n = (*) 2 ^^ n", "by (induction n) (simp_all add: fun_eq_iff funpow_swap1, simp add: ac_simps)"], ["proof (state)\nthis:\n  push_bit ?n = (*) 2 ^^ ?n\n\ngoal (1 subgoal):\n 1. w << n = (shiftl1 ^^ n) w", "then"], ["proof (chain)\npicking this:\n  push_bit ?n = (*) 2 ^^ ?n", "show ?thesis"], ["proof (prove)\nusing this:\n  push_bit ?n = (*) 2 ^^ ?n\n\ngoal (1 subgoal):\n 1. w << n = (shiftl1 ^^ n) w", "by transfer simp"], ["proof (state)\nthis:\n  w << n = (shiftl1 ^^ n) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shiftr_def:\n  \\<open>w >> n = (shiftr1 ^^ n) w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w >> n = (shiftr1 ^^ n) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w >> n = (shiftr1 ^^ n) w", "have \\<open>shiftr1 ^^ n = (drop_bit n :: 'a word \\<Rightarrow> 'a word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftr1 ^^ n = drop_bit n", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. shiftr1 ^^ 0 = drop_bit 0\n 2. \\<And>n.\n       shiftr1 ^^ n = drop_bit n \\<Longrightarrow>\n       shiftr1 ^^ Suc n = drop_bit (Suc n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       shiftr1 ^^ n = drop_bit n \\<Longrightarrow>\n       shiftr1 ^^ Suc n = drop_bit (Suc n)", "apply (simp only: shiftr1_eq_div_2 [abs_def] drop_bit_eq_div [abs_def] funpow_Suc_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>a. a div 2) ^^ n =\n       (\\<lambda>a. a div 2 ^ n) \\<Longrightarrow>\n       (\\<lambda>a. a div 2 ^ n) \\<circ> (\\<lambda>a. a div 2) =\n       (\\<lambda>a. a div 2 ^ Suc n)", "apply (use div_exp_eq [of _ 1, where ?'a = \\<open>'a word\\<close>] in simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  shiftr1 ^^ n = drop_bit n\n\ngoal (1 subgoal):\n 1. w >> n = (shiftr1 ^^ n) w", "then"], ["proof (chain)\npicking this:\n  shiftr1 ^^ n = drop_bit n", "show ?thesis"], ["proof (prove)\nusing this:\n  shiftr1 ^^ n = drop_bit n\n\ngoal (1 subgoal):\n 1. w >> n = (shiftr1 ^^ n) w", "by (simp add: shiftr_eq_drop_bit)"], ["proof (state)\nthis:\n  w >> n = (shiftr1 ^^ n) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_shiftl_word_iff [bit_simps]:\n  \\<open>bit (w << m) n \\<longleftrightarrow> m \\<le> n \\<and> n < LENGTH('a) \\<and> bit w (n - m)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (w << m) n = (m \\<le> n \\<and> n < LENGTH('a) \\<and> bit w (n - m))", "by (simp add: shiftl_word_eq bit_push_bit_iff not_le)"], ["", "lemma bit_shiftr_word_iff [bit_simps]:\n  \\<open>bit (w >> m) n \\<longleftrightarrow> bit w (m + n)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (w >> m) n = bit w (m + n)", "by (simp add: shiftr_word_eq bit_drop_bit_eq)"], ["", "lift_definition sshiftr :: \\<open>'a::len word \\<Rightarrow> nat \\<Rightarrow> 'a word\\<close>  (infixl \\<open>>>>\\<close> 55)\n  is \\<open>\\<lambda>k n. take_bit LENGTH('a) (drop_bit n (signed_take_bit (LENGTH('a) - Suc 0) k))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int1 int2 nat.\n       take_bit LENGTH('a) int1 = take_bit LENGTH('a) int2 \\<Longrightarrow>\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a)\n          (drop_bit nat (signed_take_bit (LENGTH('a) - Suc 0) int1))) =\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a)\n          (drop_bit nat (signed_take_bit (LENGTH('a) - Suc 0) int2)))", "by (simp flip: signed_take_bit_decr_length_iff)"], ["", "lemma sshiftr_eq [code]:\n  \\<open>w >>> n = signed_drop_bit n w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w >>> n = signed_drop_bit n w", "by transfer simp"], ["", "lemma sshiftr_eq_funpow_sshiftr1:\n  \\<open>w >>> n = (sshiftr1 ^^ n) w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w >>> n = (sshiftr1 ^^ n) w", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sshiftr1 ^^ n) w = w >>> n", "apply (simp add: sshiftr1_eq_signed_drop_bit_Suc_0 sshiftr_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (signed_drop_bit (Suc 0) ^^ n) w = signed_drop_bit n w", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (signed_drop_bit (Suc 0) ^^ 0) w = signed_drop_bit 0 w\n 2. \\<And>n.\n       (signed_drop_bit (Suc 0) ^^ n) w =\n       signed_drop_bit n w \\<Longrightarrow>\n       (signed_drop_bit (Suc 0) ^^ Suc n) w = signed_drop_bit (Suc n) w", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma uint_sshiftr_eq:\n  \\<open>uint (w >>> n) = take_bit LENGTH('a) (sint w div 2 ^  n)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (w >>> n) = take_bit LENGTH('a) (sint w div 2 ^ n)", "by transfer (simp flip: drop_bit_eq_div)"], ["", "lemma sshift1_code [code]:\n  \\<open>sshiftr1 w = signed_drop_bit 1 w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sshiftr1 w = signed_drop_bit 1 w", "by transfer (simp add: drop_bit_Suc)"], ["", "lemma sshiftr_0 [simp]: \"0 >>> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 >>> n = 0", "by transfer simp"], ["", "lemma sshiftr_n1 [simp]: \"-1 >>> n = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 >>> n = - 1", "by transfer simp"], ["", "lemma bit_sshiftr_word_iff [bit_simps]:\n  \\<open>bit (w >>> m) n \\<longleftrightarrow> bit w (if LENGTH('a) - m \\<le> n \\<and> n < LENGTH('a) then LENGTH('a) - 1 else (m + n))\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (w >>> m) n =\n    bit w\n     (if LENGTH('a) - m \\<le> n \\<and> n < LENGTH('a) then LENGTH('a) - 1\n      else m + n)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w m n.\n       (n < LENGTH('a) \\<and>\n        bit (take_bit LENGTH('a)\n              (drop_bit m (signed_take_bit (LENGTH('a) - Suc 0) w)))\n         n) =\n       ((if LENGTH('a) - m \\<le> n \\<and> n < LENGTH('a) then LENGTH('a) - 1\n         else m + n)\n        < LENGTH('a) \\<and>\n        bit w\n         (if LENGTH('a) - m \\<le> n \\<and> n < LENGTH('a)\n          then LENGTH('a) - 1 else m + n))", "apply (auto simp add: bit_take_bit_iff bit_drop_bit_eq bit_signed_take_bit_iff min_def not_le simp flip: bit_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; n < LENGTH('a) - m;\n        n < LENGTH('a); bit w (LENGTH('a) - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> bit w (m + n)\n 2. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; n < LENGTH('a) - m;\n        m + n < LENGTH('a); bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "using le_less_Suc_eq"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> (?n < Suc ?m) = (?n = ?m)\n\ngoal (2 subgoals):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; n < LENGTH('a) - m;\n        n < LENGTH('a); bit w (LENGTH('a) - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> bit w (m + n)\n 2. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; n < LENGTH('a) - m;\n        m + n < LENGTH('a); bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; n < LENGTH('a) - m;\n        m + n < LENGTH('a); bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "using le_less_Suc_eq"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> (?n < Suc ?m) = (?n = ?m)\n\ngoal (1 subgoal):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; n < LENGTH('a) - m;\n        m + n < LENGTH('a); bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_sshiftr :\n  \"(w >>> m) !! n =\n    (n < size w \\<and> (if n + m \\<ge> size w then w !! (size w - 1) else w !! (n + m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w >>> m) !! n =\n    (n < size w \\<and>\n     (if size w \\<le> n + m then w !! (size w - 1) else w !! (n + m)))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w m n.\n       (n < LENGTH('a) \\<and>\n        bit (take_bit LENGTH('a)\n              (drop_bit m (signed_take_bit (LENGTH('a) - Suc 0) w)))\n         n) =\n       (n < LENGTH('a) \\<and>\n        (if LENGTH('a) \\<le> n + m\n         then LENGTH('a) - 1 < LENGTH('a) \\<and> bit w (LENGTH('a) - 1)\n         else n + m < LENGTH('a) \\<and> bit w (n + m)))", "apply (auto simp add: bit_take_bit_iff bit_drop_bit_eq bit_signed_take_bit_iff min_def not_le ac_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; m + n < LENGTH('a);\n        bit w (LENGTH('a) - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> bit w (m + n)\n 2. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; m + n < LENGTH('a);\n        bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "using le_less_Suc_eq"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> (?n < Suc ?m) = (?n = ?m)\n\ngoal (2 subgoals):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; m + n < LENGTH('a);\n        bit w (LENGTH('a) - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> bit w (m + n)\n 2. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; m + n < LENGTH('a);\n        bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; m + n < LENGTH('a);\n        bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "using le_less_Suc_eq"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> (?n < Suc ?m) = (?n = ?m)\n\ngoal (1 subgoal):\n 1. \\<And>w m n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> m + n; m + n < LENGTH('a);\n        bit w (m + n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sshiftr_numeral [simp]:\n  \\<open>(numeral k >>> numeral n :: 'a::len word) =\n    word_of_int (drop_bit (numeral n) (signed_take_bit (LENGTH('a) - 1) (numeral k)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral k >>> numeral n =\n    word_of_int\n     (drop_bit (numeral n) (signed_take_bit (LENGTH('a) - 1) (numeral k)))", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < size (numeral k >>> numeral n) \\<longrightarrow>\n       (numeral k >>> numeral n) !! na =\n       word_of_int\n        (drop_bit (numeral n)\n          (signed_take_bit (LENGTH('a) - 1) (numeral k))) !!\n       na", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       LENGTH('a) = 0 \\<Longrightarrow>\n       na < size (numeral k >>> numeral n) \\<longrightarrow>\n       (numeral k >>> numeral n) !! na =\n       word_of_int\n        (drop_bit (numeral n)\n          (signed_take_bit (LENGTH('a) - 1) (numeral k))) !!\n       na\n 2. \\<And>na nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       na < size (numeral k >>> numeral n) \\<longrightarrow>\n       (numeral k >>> numeral n) !! na =\n       word_of_int\n        (drop_bit (numeral n)\n          (signed_take_bit (LENGTH('a) - 1) (numeral k))) !!\n       na", "apply (simp_all add: word_size bit_drop_bit_eq nth_sshiftr bit_signed_take_bit_iff min_def not_le not_less less_Suc_eq_le ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "setup \\<open>\n  Context.theory_map (fold SMT_Word.add_word_shift' [\n    (\\<^term>\\<open>shiftl :: 'a::len word \\<Rightarrow> _\\<close>, \"bvshl\"),\n    (\\<^term>\\<open>shiftr :: 'a::len word \\<Rightarrow> _\\<close>, \"bvlshr\"),\n    (\\<^term>\\<open>sshiftr :: 'a::len word \\<Rightarrow> _\\<close>, \"bvashr\")\n  ])\n\\<close>"], ["", "lemma revcast_down_us [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = ucast (w >>> n)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; source_size rc = target_size rc + n\\<rbrakk>\n    \\<Longrightarrow> rc w = ucast (w >>> n)", "apply (simp add: source_size_def target_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n\\<rbrakk>\n    \\<Longrightarrow> revcast w = ucast (w >>> n)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n;\n        na < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (revcast w) na = bit (ucast (w >>> n)) na", "apply (simp add: bit_revcast_iff bit_ucast_iff bit_sshiftr_word_iff ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma revcast_down_ss [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = scast (w >>> n)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; source_size rc = target_size rc + n\\<rbrakk>\n    \\<Longrightarrow> rc w = scast (w >>> n)", "apply (simp add: source_size_def target_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n\\<rbrakk>\n    \\<Longrightarrow> revcast w = scast (w >>> n)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n;\n        na < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (revcast w) na = bit (scast (w >>> n)) na", "apply (simp add: bit_revcast_iff bit_word_scast_iff bit_sshiftr_word_iff ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sshiftr_div_2n: \"sint (w >>> n) = sint w div 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint (w >>> n) = sint w div 2 ^ n", "using sint_signed_drop_bit_eq [of n w]"], ["proof (prove)\nusing this:\n  sint (signed_drop_bit n w) = drop_bit n (sint w)\n\ngoal (1 subgoal):\n 1. sint (w >>> n) = sint w div 2 ^ n", "by (simp add: drop_bit_eq_div sshiftr_eq)"], ["", "lemmas lsb0 = len_gt_0 [THEN word_ops_nth_size [unfolded word_size]]"], ["", "lemma nth_sint:\n  fixes w :: \"'a::len word\"\n  defines \"l \\<equiv> LENGTH('a)\"\n  shows \"bit (sint w) n = (if n < l - 1 then w !! n else w !! (l - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (sint w) n = (if n < l - 1 then w !! n else w !! (l - 1))", "unfolding sint_uint l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (signed_take_bit (LENGTH('a) - Suc 0) (uint w)) n =\n    (if n < LENGTH('a) - 1 then w !! n else w !! (LENGTH('a) - 1))", "by (auto simp: bit_signed_take_bit_iff word_test_bit_def not_less min_def)"], ["", "lemma test_bit_2p: \"(word_of_int (2 ^ n)::'a::len word) !! m \\<longleftrightarrow> m = n \\<and> m < LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (2 ^ n) !! m = (m = n \\<and> m < LENGTH('a))", "by transfer (auto simp add: bit_exp_iff)"], ["", "lemma nth_w2p: \"((2::'a::len word) ^ n) !! m \\<longleftrightarrow> m = n \\<and> m < LENGTH('a::len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ n) !! m = (m = n \\<and> m < LENGTH('a))", "by transfer (auto simp add: bit_exp_iff)"], ["", "lemma bang_is_le: \"x !! m \\<Longrightarrow> 2 ^ m \\<le> x\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x !! m \\<Longrightarrow> 2 ^ m \\<le> x", "apply (rule xtrans(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. x !! m \\<Longrightarrow> x = ?b\n 2. x !! m \\<Longrightarrow> 2 ^ m \\<le> ?b", "apply (rule_tac [2] y = \"x\" in le_word_or2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x !! m \\<Longrightarrow> x = 2 ^ m OR x", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       x !! m \\<Longrightarrow>\n       n < size x \\<longrightarrow> x !! n = (2 ^ m OR x) !! n", "apply (auto simp add: word_ao_nth nth_w2p word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_eq:\n  \\<open>mask n = (1 << n) - (1 :: 'a::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n = (1 << n) - 1", "by transfer (simp add: mask_eq_exp_minus_1 push_bit_of_1)"], ["", "lemma nth_ucast:\n  \"(ucast w::'a::len word) !! n = (w !! n \\<and> n < LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ucast w !! n = (w !! n \\<and> n < LENGTH('a))", "by transfer (simp add: bit_take_bit_iff ac_simps)"], ["", "lemma shiftl_0 [simp]: \"(0::'a::len word) << n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 << n = 0", "by transfer simp"], ["", "lemma shiftr_0 [simp]: \"(0::'a::len word) >> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 >> n = 0", "by transfer simp"], ["", "lemma nth_shiftl1: \"shiftl1 w !! n \\<longleftrightarrow> n < size w \\<and> n > 0 \\<and> w !! (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftl1 w !! n = (n < size w \\<and> 0 < n \\<and> w !! (n - 1))", "by transfer (auto simp add: bit_double_iff)"], ["", "lemma nth_shiftl': \"(w << m) !! n \\<longleftrightarrow> n < size w \\<and> n >= m \\<and> w !! (n - m)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w << m) !! n = (n < size w \\<and> m \\<le> n \\<and> w !! (n - m))", "by transfer (auto simp add: bit_push_bit_iff)"], ["", "lemmas nth_shiftl = nth_shiftl' [unfolded word_size]"], ["", "lemma nth_shiftr1: \"shiftr1 w !! n = w !! Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftr1 w !! n = w !! Suc n", "by transfer (auto simp add: bit_take_bit_iff simp flip: bit_Suc)"], ["", "lemma nth_shiftr: \"(w >> m) !! n = w !! (n + m)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w >> m) !! n = w !! (n + m)", "apply (unfold shiftr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (shiftr1 ^^ m) w !! n = w !! (n + m)", "apply (induct \"m\" arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. (shiftr1 ^^ 0) w !! n = w !! (n + 0)\n 2. \\<And>m n.\n       (\\<And>n. (shiftr1 ^^ m) w !! n = w !! (n + m)) \\<Longrightarrow>\n       (shiftr1 ^^ Suc m) w !! n = w !! (n + Suc m)", "apply (auto simp add: nth_shiftr1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_sshiftr1: \"sshiftr1 w !! n = (if n = size w - 1 then w !! n else w !! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sshiftr1 w !! n = (if n = size w - 1 then w !! n else w !! Suc n)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w n.\n       (n < LENGTH('a) \\<and>\n        bit (take_bit LENGTH('a)\n              (signed_take_bit (LENGTH('a) - Suc 0) w div 2))\n         n) =\n       (if n = LENGTH('a) - 1 then n < LENGTH('a) \\<and> bit w n\n        else Suc n < LENGTH('a) \\<and> bit w (Suc n))", "apply (auto simp add: bit_take_bit_iff bit_signed_take_bit_iff min_def simp flip: bit_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> Suc n;\n        n \\<noteq> LENGTH('a) - Suc 0; n < LENGTH('a);\n        bit w (LENGTH('a) - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n)\n 2. \\<And>w n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> Suc n;\n        n \\<noteq> LENGTH('a) - Suc 0; Suc n < LENGTH('a);\n        bit w (Suc n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "using le_less_Suc_eq"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> (?n < Suc ?m) = (?n = ?m)\n\ngoal (2 subgoals):\n 1. \\<And>w n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> Suc n;\n        n \\<noteq> LENGTH('a) - Suc 0; n < LENGTH('a);\n        bit w (LENGTH('a) - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n)\n 2. \\<And>w n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> Suc n;\n        n \\<noteq> LENGTH('a) - Suc 0; Suc n < LENGTH('a);\n        bit w (Suc n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> Suc n;\n        n \\<noteq> LENGTH('a) - Suc 0; Suc n < LENGTH('a);\n        bit w (Suc n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "using le_less_Suc_eq"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> (?n < Suc ?m) = (?n = ?m)\n\ngoal (1 subgoal):\n 1. \\<And>w n.\n       \\<lbrakk>LENGTH('a) - Suc 0 \\<le> Suc n;\n        n \\<noteq> LENGTH('a) - Suc 0; Suc n < LENGTH('a);\n        bit w (Suc n)\\<rbrakk>\n       \\<Longrightarrow> bit w (LENGTH('a) - Suc 0)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_div_2n: \"uint (shiftr w n) = uint w div 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (w >> n) = uint w div 2 ^ n", "by (fact uint_shiftr_eq)"], ["", "lemma shiftl_rev: \"shiftl w n = word_reverse (shiftr (word_reverse w) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w << n = word_reverse (word_reverse w >> n)", "by (induct n) (auto simp add: shiftl_def shiftr_def shiftl1_rev)"], ["", "lemma rev_shiftl: \"word_reverse w << n = word_reverse (w >> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_reverse w << n = word_reverse (w >> n)", "by (simp add: shiftl_rev)"], ["", "lemma shiftr_rev: \"w >> n = word_reverse (word_reverse w << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w >> n = word_reverse (word_reverse w << n)", "by (simp add: rev_shiftl)"], ["", "lemma rev_shiftr: \"word_reverse w >> n = word_reverse (w << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_reverse w >> n = word_reverse (w << n)", "by (simp add: shiftr_rev)"], ["", "lemma shiftl_numeral [simp]:\n  \\<open>numeral k << numeral l = (push_bit (numeral l) (numeral k) :: 'a::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral k << numeral l = push_bit (numeral l) (numeral k)", "by (fact shiftl_word_eq)"], ["", "lemma shiftl_zero_size: \"size x \\<le> n \\<Longrightarrow> x << n = 0\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x \\<le> n \\<Longrightarrow> x << n = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       LENGTH('a) \\<le> n \\<Longrightarrow>\n       take_bit LENGTH('a) (push_bit n x) = take_bit LENGTH('a) 0", "apply (simp add: take_bit_push_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_t2n: \"shiftl w n = 2 ^ n * w\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w << n = 2 ^ n * w", "by (induct n) (auto simp: shiftl_def shiftl1_2t)"], ["", "lemma shiftr_numeral [simp]:\n  \\<open>(numeral k >> numeral n :: 'a::len word) = drop_bit (numeral n) (numeral k)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral k >> numeral n = drop_bit (numeral n) (numeral k)", "by (fact shiftr_word_eq)"], ["", "lemma shiftr_numeral_Suc [simp]:\n  \\<open>(numeral k >> Suc 0 :: 'a::len word) = drop_bit (Suc 0) (numeral k)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral k >> Suc 0 = drop_bit (Suc 0) (numeral k)", "by (fact shiftr_word_eq)"], ["", "lemma drop_bit_numeral_bit0_1 [simp]:\n  \\<open>drop_bit (Suc 0) (numeral k) =\n    (word_of_int (drop_bit (Suc 0) (take_bit LENGTH('a) (numeral k))) :: 'a::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit (Suc 0) (numeral k) =\n    word_of_int (drop_bit (Suc 0) (take_bit LENGTH('a) (numeral k)))", "by (metis Word_eq_word_of_int drop_bit_word.abs_eq of_int_numeral)"], ["", "lemma nth_mask [simp]:\n  \\<open>(mask n :: 'a::len word) !! i \\<longleftrightarrow> i < n \\<and> i < size (mask n :: 'a word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n !! i = (i < n \\<and> i < size (mask n))", "by (auto simp add: test_bit_word_eq word_size Word.bit_mask_iff)"], ["", "lemma slice_shiftr: \"slice n w = ucast (w >> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice n w = ucast (w >> n)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (slice n w) na = bit (ucast (w >> n)) na", "apply (cases \\<open>n \\<le> LENGTH('b)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>na < LENGTH('a); n \\<le> LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (slice n w) na = bit (ucast (w >> n)) na\n 2. \\<And>na.\n       \\<lbrakk>na < LENGTH('a); \\<not> n \\<le> LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (slice n w) na = bit (ucast (w >> n)) na", "apply (auto simp add: bit_slice_iff bit_ucast_iff bit_shiftr_word_iff ac_simps\n    dest: bit_imp_le_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_slice: \"(slice n w :: 'a::len word) !! m = (w !! (m + n) \\<and> m < LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice n w !! m = (w !! (m + n) \\<and> m < LENGTH('a))", "by (simp add: slice_shiftr nth_ucast nth_shiftr)"], ["", "lemma revcast_down_uu [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = ucast (w >> n)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; source_size rc = target_size rc + n\\<rbrakk>\n    \\<Longrightarrow> rc w = ucast (w >> n)", "apply (simp add: source_size_def target_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n\\<rbrakk>\n    \\<Longrightarrow> revcast w = ucast (w >> n)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n;\n        na < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (revcast w) na = bit (ucast (w >> n)) na", "apply (simp add: bit_revcast_iff bit_ucast_iff bit_shiftr_word_iff ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma revcast_down_su [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc = target_size rc + n \\<Longrightarrow> rc w = scast (w >> n)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; source_size rc = target_size rc + n\\<rbrakk>\n    \\<Longrightarrow> rc w = scast (w >> n)", "apply (simp add: source_size_def target_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n\\<rbrakk>\n    \\<Longrightarrow> revcast w = scast (w >> n)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('a) = LENGTH('b) + n;\n        na < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (revcast w) na = bit (scast (w >> n)) na", "apply (simp add: bit_revcast_iff bit_word_scast_iff bit_shiftr_word_iff ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cast_down_rev [OF refl]:\n  \"uc = ucast \\<Longrightarrow> source_size uc = target_size uc + n \\<Longrightarrow> uc w = revcast (w << n)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uc = ucast; source_size uc = target_size uc + n\\<rbrakk>\n    \\<Longrightarrow> uc w = revcast (w << n)", "apply (simp add: source_size_def target_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uc = ucast; LENGTH('a) = LENGTH('b) + n\\<rbrakk>\n    \\<Longrightarrow> ucast w = revcast (w << n)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>uc = ucast; LENGTH('a) = LENGTH('b) + n;\n        na < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit (ucast w) na = bit (revcast (w << n)) na", "apply (simp add: bit_revcast_iff bit_word_ucast_iff bit_shiftl_word_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma revcast_up [OF refl]:\n  \"rc = revcast \\<Longrightarrow> source_size rc + n = target_size rc \\<Longrightarrow>\n    rc w = (ucast w :: 'a::len word) << n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; source_size rc + n = target_size rc\\<rbrakk>\n    \\<Longrightarrow> rc w = ucast w << n", "apply (simp add: source_size_def target_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rc = revcast; LENGTH('b) + n = LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> revcast w = ucast w << n", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('b) + n = LENGTH('a);\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (revcast w) na = bit (ucast w << n) na", "apply (simp add: bit_revcast_iff bit_word_ucast_iff bit_shiftl_word_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('b) + n = LENGTH('a);\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> (LENGTH('a) - LENGTH('b) \\<le> na \\<and>\n                          bit w (na + LENGTH('b) - LENGTH('a))) =\n                         (n \\<le> na \\<and>\n                          na - n < LENGTH('b) \\<and>\n                          na - n < LENGTH('a) \\<and> bit w (na - n))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('b) + n = LENGTH('a); na < LENGTH('a);\n        LENGTH('a) - LENGTH('b) \\<le> na;\n        bit w (na + LENGTH('b) - LENGTH('a))\\<rbrakk>\n       \\<Longrightarrow> bit w (na - n)\n 2. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('b) + n = LENGTH('a); na < LENGTH('a);\n        n \\<le> na; na - n < LENGTH('b); bit w (na - n)\\<rbrakk>\n       \\<Longrightarrow> bit w (na + LENGTH('b) - LENGTH('a))", "apply (metis add.commute add_diff_cancel_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rc = revcast; LENGTH('b) + n = LENGTH('a); na < LENGTH('a);\n        n \\<le> na; na - n < LENGTH('b); bit w (na - n)\\<rbrakk>\n       \\<Longrightarrow> bit w (na + LENGTH('b) - LENGTH('a))", "apply (metis diff_add_inverse2 diff_diff_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas rc1 = revcast_up [THEN\n  revcast_rev_ucast [symmetric, THEN trans, THEN word_rev_gal, symmetric]]"], ["", "lemmas rc2 = revcast_down_uu [THEN\n  revcast_rev_ucast [symmetric, THEN trans, THEN word_rev_gal, symmetric]]"], ["", "lemmas ucast_up =\n  rc1 [simplified rev_shiftr [symmetric] revcast_ucast [symmetric]]"], ["", "lemmas ucast_down =\n  rc2 [simplified rev_shiftr revcast_ucast [symmetric]]\n\n\\<comment> \\<open>problem posed by TPHOLs referee:\n      criterion for overflow of addition of signed integers\\<close>"], ["", "lemma sofl_test:\n  \\<open>sint x + sint y = sint (x + y) \\<longleftrightarrow>\n    (x + y XOR x) AND (x + y XOR y) >> (size x - 1) = 0\\<close>\n  for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((x + y XOR x) AND (x + y XOR y) >> size x - 1 = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((x + y XOR x) AND (x + y XOR y) >> size x - 1 = 0)", "obtain n where n: \\<open>LENGTH('a) = Suc n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. LENGTH('a) = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<open>LENGTH('a)\\<close>) simp_all"], ["proof (state)\nthis:\n  LENGTH('a) = Suc n\n\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((x + y XOR x) AND (x + y XOR y) >> size x - 1 = 0)", "have *: \\<open>sint x + sint y + 2 ^ Suc n > signed_take_bit n (sint x + sint y) \\<Longrightarrow> sint x + sint y \\<ge> - (2 ^ n)\\<close>\n    \\<open>signed_take_bit n (sint x + sint y) > sint x + sint y - 2 ^ Suc n \\<Longrightarrow> 2 ^ n > sint x + sint y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (signed_take_bit n (sint x + sint y)\n     < sint x + sint y + 2 ^ Suc n \\<Longrightarrow>\n     - (2 ^ n) \\<le> sint x + sint y) &&&\n    (sint x + sint y - 2 ^ Suc n\n     < signed_take_bit n (sint x + sint y) \\<Longrightarrow>\n     sint x + sint y < 2 ^ n)", "using signed_take_bit_int_greater_eq [of \\<open>sint x + sint y\\<close> n] signed_take_bit_int_less_eq [of n \\<open>sint x + sint y\\<close>]"], ["proof (prove)\nusing this:\n  sint x + sint y < - (2 ^ n) \\<Longrightarrow>\n  sint x + sint y + 2 ^ Suc n \\<le> signed_take_bit n (sint x + sint y)\n  2 ^ n \\<le> sint x + sint y \\<Longrightarrow>\n  signed_take_bit n (sint x + sint y) \\<le> sint x + sint y - 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. (signed_take_bit n (sint x + sint y)\n     < sint x + sint y + 2 ^ Suc n \\<Longrightarrow>\n     - (2 ^ n) \\<le> sint x + sint y) &&&\n    (sint x + sint y - 2 ^ Suc n\n     < signed_take_bit n (sint x + sint y) \\<Longrightarrow>\n     sint x + sint y < 2 ^ n)", "by (auto intro: ccontr)"], ["proof (state)\nthis:\n  signed_take_bit n (sint x + sint y)\n  < sint x + sint y + 2 ^ Suc n \\<Longrightarrow>\n  - (2 ^ n) \\<le> sint x + sint y\n  sint x + sint y - 2 ^ Suc n\n  < signed_take_bit n (sint x + sint y) \\<Longrightarrow>\n  sint x + sint y < 2 ^ n\n\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((x + y XOR x) AND (x + y XOR y) >> size x - 1 = 0)", "have \\<open>sint x + sint y = sint (x + y) \\<longleftrightarrow>\n    (sint (x + y) < 0 \\<longleftrightarrow> sint x < 0) \\<or>\n    (sint (x + y) < 0 \\<longleftrightarrow> sint y < 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((sint (x + y) < 0) = (sint x < 0) \\<or>\n     (sint (x + y) < 0) = (sint y < 0))", "using sint_less [of x] sint_greater_eq [of x] sint_less [of y] sint_greater_eq [of y]\n    signed_take_bit_int_eq_self [of \\<open>LENGTH('a) - 1\\<close> \\<open>sint x + sint y\\<close>]"], ["proof (prove)\nusing this:\n  sint x < 2 ^ (LENGTH('a) - Suc 0)\n  - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x\n  sint y < 2 ^ (LENGTH('a) - Suc 0)\n  - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y\n  \\<lbrakk>- (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y;\n   sint x + sint y < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n  \\<Longrightarrow> signed_take_bit (LENGTH('a) - 1) (sint x + sint y) =\n                    sint x + sint y\n\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((sint (x + y) < 0) = (sint x < 0) \\<or>\n     (sint (x + y) < 0) = (sint y < 0))", "apply (auto simp add: not_less)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     sint (x + y) < 0; sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint (x + y)\n 2. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> sint (x + y); 0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint (x + y)\n 3. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     sint (x + y) < 0; sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint (x + y)\n 4. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> sint (x + y); 0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint (x + y)", "apply (unfold sint_word_ariths)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 2. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 3. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 4. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)", "apply (subst signed_take_bit_int_eq_self)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 2. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 3. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 4. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 5. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 6. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)", "prefer 4"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 2. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 3. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 4. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 5. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 6. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)", "apply (subst signed_take_bit_int_eq_self)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 2. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 3. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 4. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 5. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 6. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 7. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 8. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)", "prefer 7"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 2. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 3. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 4. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 5. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 6. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 7. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 8. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)", "apply (subst signed_take_bit_int_eq_self)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 2. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 3. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 4. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 5. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 6. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 7. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 8. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 9. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 10. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n      - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n      sint y < 2 ^ (LENGTH('a) - Suc 0);\n      sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n      signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n      sint x + sint y;\n      0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n      0 \\<le> sint y\\<rbrakk>\n     \\<Longrightarrow> sint x + sint y =\n                       signed_take_bit (LENGTH('a) - 1) (sint x + sint y)", "prefer 10"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y =\n                      signed_take_bit (LENGTH('a) - 1) (sint x + sint y)\n 2. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 3. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 4. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 5. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 6. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 7. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 8. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 9. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint x < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 10. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n      sint y < 2 ^ (LENGTH('a) - Suc 0);\n      - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n      - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n      signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n      sint x + sint y;\n      signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n      sint x < 0\\<rbrakk>\n     \\<Longrightarrow> sint x + sint y = sint x + sint y", "apply (subst signed_take_bit_int_eq_self)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 2. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 3. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint y\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 4. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 5. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 6. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n     sint y < 0\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 7. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\n 8. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y < 2 ^ (LENGTH('a) - 1)\n 9. \\<lbrakk>sint x < 2 ^ (LENGTH('a) - Suc 0);\n     sint y < 2 ^ (LENGTH('a) - Suc 0);\n     - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n     sint x + sint y < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n     signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n     sint x + sint y;\n     0 \\<le> signed_take_bit (LENGTH('a) - 1) (sint x + sint y);\n     0 \\<le> sint x\\<rbrakk>\n    \\<Longrightarrow> sint x + sint y = sint x + sint y\n 10. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x;\n      sint y < 2 ^ (LENGTH('a) - Suc 0);\n      - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint y;\n      - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x + sint y \\<Longrightarrow>\n      signed_take_bit (LENGTH('a) - Suc 0) (sint x + sint y) =\n      sint x + sint y;\n      signed_take_bit (LENGTH('a) - 1) (sint x + sint y) < 0;\n      sint x < 0\\<rbrakk>\n     \\<Longrightarrow> - (2 ^ (LENGTH('a) - 1)) \\<le> sint x + sint y\nA total of 12 subgoals...", "apply (auto simp add: signed_take_bit_int_eq_self signed_take_bit_eq_take_bit_minus take_bit_Suc_from_most n not_less intro!: *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sint x + sint y = sint (x + y)) =\n  ((sint (x + y) < 0) = (sint x < 0) \\<or>\n   (sint (x + y) < 0) = (sint y < 0))\n\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((x + y XOR x) AND (x + y XOR y) >> size x - 1 = 0)", "then"], ["proof (chain)\npicking this:\n  (sint x + sint y = sint (x + y)) =\n  ((sint (x + y) < 0) = (sint x < 0) \\<or>\n   (sint (x + y) < 0) = (sint y < 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  (sint x + sint y = sint (x + y)) =\n  ((sint (x + y) < 0) = (sint x < 0) \\<or>\n   (sint (x + y) < 0) = (sint y < 0))\n\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((x + y XOR x) AND (x + y XOR y) >> size x - 1 = 0)", "apply (simp only: One_nat_def word_size shiftr_word_eq drop_bit_eq_zero_iff_not_bit_last bit_and_iff bit_xor_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint x + sint y = sint (x + y)) =\n    ((sint (x + y) < 0) = (sint x < 0) \\<or>\n     (sint (x + y) < 0) = (sint y < 0)) \\<Longrightarrow>\n    ((sint (x + y) < 0) = (sint x < 0) \\<or>\n     (sint (x + y) < 0) = (sint y < 0)) =\n    (\\<not> (bit (x + y) (LENGTH('a) - Suc 0) \\<noteq>\n             bit x (LENGTH('a) - Suc 0) \\<and>\n             bit (x + y) (LENGTH('a) - Suc 0) \\<noteq>\n             bit y (LENGTH('a) - Suc 0)))", "apply (simp add: bit_last_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sint x + sint y = sint (x + y)) =\n  ((x + y XOR x) AND (x + y XOR y) >> size x - 1 = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shiftr_zero_size: \"size x \\<le> n \\<Longrightarrow> x >> n = 0\"\n  for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x \\<le> n \\<Longrightarrow> x >> n = 0", "by (rule word_eqI) (auto simp add: nth_shiftr dest: test_bit_size)"], ["", "lemma test_bit_cat [OF refl]:\n  \"wc = word_cat a b \\<Longrightarrow> wc !! n = (n < size wc \\<and>\n    (if n < size b then b !! n else a !! (n - size b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc = word_cat a b \\<Longrightarrow>\n    wc !! n =\n    (n < size wc \\<and> (if n < size b then b !! n else a !! (n - size b)))", "apply (simp add: word_size not_less; transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wc a b n.\n       take_bit LENGTH('a) wc =\n       take_bit LENGTH('a)\n        (concat_bit LENGTH('c) b (take_bit LENGTH('b) a)) \\<Longrightarrow>\n       (n < LENGTH('c) \\<longrightarrow>\n        (n < LENGTH('a) \\<and>\n         bit (concat_bit LENGTH('c) b (take_bit LENGTH('b) a)) n) =\n        (n < LENGTH('a) \\<and> n < LENGTH('c) \\<and> bit b n)) \\<and>\n       (LENGTH('c) \\<le> n \\<longrightarrow>\n        (n < LENGTH('a) \\<and>\n         bit (concat_bit LENGTH('c) b (take_bit LENGTH('b) a)) n) =\n        (n < LENGTH('a) \\<and>\n         n - LENGTH('c) < LENGTH('b) \\<and> bit a (n - LENGTH('c))))", "apply (auto simp add: bit_concat_bit_iff bit_take_bit_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>keep quantifiers for use in simplification\\<close>"], ["", "lemma test_bit_split':\n  \"word_split c = (a, b) \\<longrightarrow>\n    (\\<forall>n m.\n      b !! n = (n < size b \\<and> c !! n) \\<and>\n      a !! m = (m < size a \\<and> c !! (m + size b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_split c = (a, b) \\<longrightarrow>\n    (\\<forall>n m.\n        b !! n = (n < size b \\<and> c !! n) \\<and>\n        a !! m = (m < size a \\<and> c !! (m + size b)))", "by (auto simp add: word_split_bin' test_bit_bin bit_unsigned_iff word_size bit_drop_bit_eq ac_simps\n           dest: bit_imp_le_length)"], ["", "lemma test_bit_split:\n  \"word_split c = (a, b) \\<Longrightarrow>\n    (\\<forall>n::nat. b !! n \\<longleftrightarrow> n < size b \\<and> c !! n) \\<and>\n    (\\<forall>m::nat. a !! m \\<longleftrightarrow> m < size a \\<and> c !! (m + size b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_split c = (a, b) \\<Longrightarrow>\n    (\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n    (\\<forall>m. a !! m = (m < size a \\<and> c !! (m + size b)))", "by (simp add: test_bit_split')"], ["", "lemma test_bit_split_eq:\n  \"word_split c = (a, b) \\<longleftrightarrow>\n    ((\\<forall>n::nat. b !! n = (n < size b \\<and> c !! n)) \\<and>\n     (\\<forall>m::nat. a !! m = (m < size a \\<and> c !! (m + size b))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (word_split c = (a, b)) =\n    ((\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n     (\\<forall>m. a !! m = (m < size a \\<and> c !! (m + size b))))", "apply (rule_tac iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. word_split c = (a, b) \\<Longrightarrow>\n    (\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n    (\\<forall>m. a !! m = (m < size a \\<and> c !! (m + size b)))\n 2. (\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n    (\\<forall>m.\n        a !! m = (m < size a \\<and> c !! (m + size b))) \\<Longrightarrow>\n    word_split c = (a, b)", "apply (rule_tac conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. word_split c = (a, b) \\<Longrightarrow>\n    \\<forall>n. b !! n = (n < size b \\<and> c !! n)\n 2. word_split c = (a, b) \\<Longrightarrow>\n    \\<forall>m. a !! m = (m < size a \\<and> c !! (m + size b))\n 3. (\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n    (\\<forall>m.\n        a !! m = (m < size a \\<and> c !! (m + size b))) \\<Longrightarrow>\n    word_split c = (a, b)", "apply (erule test_bit_split [THEN conjunct1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. word_split c = (a, b) \\<Longrightarrow>\n    \\<forall>m. a !! m = (m < size a \\<and> c !! (m + size b))\n 2. (\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n    (\\<forall>m.\n        a !! m = (m < size a \\<and> c !! (m + size b))) \\<Longrightarrow>\n    word_split c = (a, b)", "apply (erule test_bit_split [THEN conjunct2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n    (\\<forall>m.\n        a !! m = (m < size a \\<and> c !! (m + size b))) \\<Longrightarrow>\n    word_split c = (a, b)", "apply (case_tac \"word_split c\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>(\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n                (\\<forall>m.\n                    a !! m = (m < size a \\<and> c !! (m + size b)));\n        word_split c = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> word_split c = (a, b)", "apply (frule test_bit_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>(\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n                (\\<forall>m.\n                    a !! m = (m < size a \\<and> c !! (m + size b)));\n        word_split c = (aa, ba);\n        (\\<forall>n. ba !! n = (n < size ba \\<and> c !! n)) \\<and>\n        (\\<forall>m.\n            aa !! m = (m < size aa \\<and> c !! (m + size ba)))\\<rbrakk>\n       \\<Longrightarrow> word_split c = (a, b)", "apply (erule trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>(\\<forall>n. b !! n = (n < size b \\<and> c !! n)) \\<and>\n                (\\<forall>m.\n                    a !! m = (m < size a \\<and> c !! (m + size b)));\n        (\\<forall>n. ba !! n = (n < size ba \\<and> c !! n)) \\<and>\n        (\\<forall>m.\n            aa !! m = (m < size aa \\<and> c !! (m + size ba)))\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) = (a, b)", "apply (fastforce intro!: word_eqI simp add: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma test_bit_rcat:\n  \"sw = size (hd wl) \\<Longrightarrow> rc = word_rcat wl \\<Longrightarrow> rc !! n =\n    (n < size rc \\<and> n div sw < size wl \\<and> (rev wl) ! (n div sw) !! (n mod sw))\"\n  for wl :: \"'a::len word list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sw = size (hd wl); rc = word_rcat wl\\<rbrakk>\n    \\<Longrightarrow> rc !! n =\n                      (n < size rc \\<and>\n                       n div sw < length wl \\<and>\n                       rev wl ! (n div sw) !! (n mod sw))", "by (simp add: word_size word_rcat_def foldl_map rev_map bit_horner_sum_uint_exp_iff)\n    (simp add: test_bit_eq_bit)"], ["", "lemmas test_bit_cong = arg_cong [where f = \"test_bit\", THEN fun_cong]"], ["", "lemma max_test_bit: \"(max_word::'a::len word) !! n \\<longleftrightarrow> n < LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) !! n = (n < LENGTH('a))", "by (fact nth_minus1)"], ["", "lemma shiftr_x_0 [iff]: \"x >> 0 = x\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> 0 = x", "by transfer simp"], ["", "lemma shiftl_x_0 [simp]: \"x << 0 = x\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x << 0 = x", "by (simp add: shiftl_t2n)"], ["", "lemma shiftl_1 [simp]: \"(1::'a::len word) << n = 2^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 << n = 2 ^ n", "by (simp add: shiftl_t2n)"], ["", "lemma shiftr_1[simp]: \"(1::'a::len word) >> n = (if n = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 >> n = (if n = 0 then 1 else 0)", "by (induct n) (auto simp: shiftr_def)"], ["", "lemma map_nth_0 [simp]: \"map ((!!) (0::'a::len word)) xs = replicate (length xs) False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!!) 0) xs = replicate (length xs) False", "by (induct xs) auto"], ["", "lemma word_and_1:\n  \"n AND 1 = (if n !! 0 then 1 else 0)\" for n :: \"_ word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n AND 1 = (if n !! 0 then 1 else 0)", "by (rule bit_word_eqI) (auto simp add: bit_and_iff test_bit_eq_bit bit_1_iff intro: gr0I)"], ["", "lemma test_bit_1' [simp]:\n  \"(1 :: 'a :: len word) !! n \\<longleftrightarrow> 0 < LENGTH('a) \\<and> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 !! n = (0 < LENGTH('a) \\<and> n = 0)", "by simp"], ["", "lemma shiftl0:\n  \"x << 0 = (x :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x << 0 = x", "by (fact shiftl_x_0)"], ["", "lemma word_ops_nth [simp]:\n  fixes x y :: \\<open>'a::len word\\<close>\n  shows\n  word_or_nth:  \"(x OR y) !! n = (x !! n \\<or> y !! n)\" and\n  word_and_nth: \"(x AND y) !! n = (x !! n \\<and> y !! n)\" and\n  word_xor_nth: \"(x XOR y) !! n = (x !! n \\<noteq> y !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR y) !! n = (x !! n \\<or> y !! n) &&&\n    (x AND y) !! n = (x !! n \\<and> y !! n) &&&\n    (x XOR y) !! n = (x !! n \\<noteq> y !! n)", "by ((cases \"n < size x\",\n      auto dest: test_bit_size simp: word_ops_nth_size word_size)[1])+"], ["", "lemma and_not_mask:\n  \"w AND NOT (mask n) = (w >> n) << n\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND NOT (mask n) = w >> n << n", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < size (w AND NOT (mask n)) \\<longrightarrow>\n       (w AND NOT (mask n)) !! na = (w >> n << n) !! na", "apply (simp add : word_ops_nth_size word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<longrightarrow>\n       (w !! na \\<and> \\<not> na < n) = (w >> n << n) !! na", "apply (simp add : nth_shiftr nth_shiftl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<longrightarrow>\n       (w !! na \\<and> \\<not> na < n) =\n       (n \\<le> na \\<and> w !! (na - n + n))", "by auto"], ["", "lemma and_mask:\n  \"w AND mask n = (w << (size w - n)) >> (size w - n)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND mask n = w << size w - n >> size w - n", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < size (w AND mask n) \\<longrightarrow>\n       (w AND mask n) !! na = (w << size w - n >> size w - n) !! na", "apply (simp add : word_ops_nth_size word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<longrightarrow>\n       (w !! na \\<and> na < n) =\n       (w << LENGTH('a) - n >> LENGTH('a) - n) !! na", "apply (simp add : nth_shiftr nth_shiftl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<longrightarrow>\n       (w !! na \\<and> na < n) =\n       (na + (LENGTH('a) - n) < LENGTH('a) \\<and> w !! na)", "by auto"], ["", "lemma nth_w2p_same:\n  \"(2^n :: 'a :: len word) !! n = (n < LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ n) !! n = (n < LENGTH('a))", "by (simp add : nth_w2p)"], ["", "lemma shiftr_div_2n_w: \"n < size w \\<Longrightarrow> w >> n = w div (2^n :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < size w \\<Longrightarrow> w >> n = w div 2 ^ n", "apply (unfold word_div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < size w \\<Longrightarrow>\n    w >> n = word_of_int (uint w div uint (2 ^ n))", "apply (simp add: uint_2p_alt word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> w >> n = word_of_int (uint w div 2 ^ n)", "apply (metis uint_shiftr_eq word_of_int_uint)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_shiftr:\n  \"u \\<le> v \\<Longrightarrow> u >> (n :: nat) \\<le> (v :: 'a :: len word) >> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> v \\<Longrightarrow> u >> n \\<le> v >> n", "apply (unfold shiftr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> v \\<Longrightarrow> (shiftr1 ^^ n) u \\<le> (shiftr1 ^^ n) v", "apply (induct_tac \"n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. u \\<le> v \\<Longrightarrow> (shiftr1 ^^ 0) u \\<le> (shiftr1 ^^ 0) v\n 2. \\<And>n.\n       \\<lbrakk>u \\<le> v; (shiftr1 ^^ n) u \\<le> (shiftr1 ^^ n) v\\<rbrakk>\n       \\<Longrightarrow> (shiftr1 ^^ Suc n) u \\<le> (shiftr1 ^^ Suc n) v", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>u \\<le> v; (shiftr1 ^^ n) u \\<le> (shiftr1 ^^ n) v\\<rbrakk>\n       \\<Longrightarrow> shiftr1 ((shiftr1 ^^ n) u)\n                         \\<le> shiftr1 ((shiftr1 ^^ n) v)", "apply (erule le_shiftr1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_mask_le:\n  \"n <= m \\<Longrightarrow> mask n >> m = (0 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> mask n >> m = 0", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n \\<le> m \\<Longrightarrow>\n       na < size (mask n >> m) \\<longrightarrow>\n       (mask n >> m) !! na = 0 !! na", "apply (simp add: word_size nth_shiftr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_mask [simp]:\n  \\<open>mask m >> m = (0::'a::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask m >> m = 0", "by (rule shiftr_mask_le) simp"], ["", "lemma word_leI:\n  \"(\\<And>n.  \\<lbrakk>n < size (u::'a::len word); u !! n \\<rbrakk> \\<Longrightarrow> (v::'a::len word) !! n) \\<Longrightarrow> u <= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < size u; u !! n\\<rbrakk>\n        \\<Longrightarrow> v !! n) \\<Longrightarrow>\n    u \\<le> v", "apply (rule xtrans(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>n.\n        \\<lbrakk>n < size u; u !! n\\<rbrakk>\n        \\<Longrightarrow> v !! n) \\<Longrightarrow>\n    ?b \\<le> v\n 2. (\\<And>n.\n        \\<lbrakk>n < size u; u !! n\\<rbrakk>\n        \\<Longrightarrow> v !! n) \\<Longrightarrow>\n    ?b = u", "apply (rule word_and_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < size u; u !! n\\<rbrakk>\n        \\<Longrightarrow> v !! n) \\<Longrightarrow>\n    v AND ?y3 = u", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<And>n.\n           \\<lbrakk>n < size u; u !! n\\<rbrakk>\n           \\<Longrightarrow> v !! n) \\<Longrightarrow>\n       n < size (v AND ?y3) \\<longrightarrow> (v AND ?y3) !! n = u !! n", "apply (simp add: word_ao_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<And>n.\n           \\<lbrakk>n < size u; u !! n\\<rbrakk>\n           \\<Longrightarrow> v !! n) \\<Longrightarrow>\n       n < size (v AND ?y3) \\<longrightarrow>\n       (v !! n \\<and> ?y3 !! n) = u !! n", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < size u; u !! n\\<rbrakk>\n                   \\<Longrightarrow> v !! n;\n        n < size (v AND ?y3); v !! n; ?y3 !! n\\<rbrakk>\n       \\<Longrightarrow> u !! n\n 2. \\<And>n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < size u; u !! n\\<rbrakk>\n                   \\<Longrightarrow> v !! n;\n        n < size (v AND ?y3); u !! n\\<rbrakk>\n       \\<Longrightarrow> v !! n\n 3. \\<And>n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < size u; u !! n\\<rbrakk>\n                   \\<Longrightarrow> v !! n;\n        n < size (v AND ?y3); u !! n\\<rbrakk>\n       \\<Longrightarrow> ?y3 !! n", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < size u; u !! n\\<rbrakk>\n                   \\<Longrightarrow> v !! n;\n        n < size (v AND u); u !! n\\<rbrakk>\n       \\<Longrightarrow> v !! n\n 2. \\<And>n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < size u; u !! n\\<rbrakk>\n                   \\<Longrightarrow> v !! n;\n        n < size (v AND u); u !! n\\<rbrakk>\n       \\<Longrightarrow> u !! n", "apply (erule_tac [2] asm_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < size u; u !! n\\<rbrakk>\n                   \\<Longrightarrow> v !! n;\n        n < size (v AND u); u !! n\\<rbrakk>\n       \\<Longrightarrow> v !! n", "apply (unfold word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < LENGTH('a); u !! n\\<rbrakk>\n                   \\<Longrightarrow> v !! n;\n        n < LENGTH('a); u !! n\\<rbrakk>\n       \\<Longrightarrow> v !! n", "by auto"], ["", "lemma le_mask_iff:\n  \"(w \\<le> mask n) = (w >> n = 0)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<le> mask n) = (w >> n = 0)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. w \\<le> mask n \\<Longrightarrow> w >> n = 0\n 2. w >> n = 0 \\<Longrightarrow> w \\<le> mask n", "apply (rule word_le_0_iff [THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. w \\<le> mask n \\<Longrightarrow> w >> n \\<le> 0\n 2. w >> n = 0 \\<Longrightarrow> w \\<le> mask n", "apply (rule xtrans(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. w \\<le> mask n \\<Longrightarrow> 0 = ?b4\n 2. w \\<le> mask n \\<Longrightarrow> w >> n \\<le> ?b4\n 3. w >> n = 0 \\<Longrightarrow> w \\<le> mask n", "apply (erule_tac [2] le_shiftr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. w \\<le> mask n \\<Longrightarrow> 0 = mask n >> n\n 2. w >> n = 0 \\<Longrightarrow> w \\<le> mask n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. w >> n = 0 \\<Longrightarrow> w \\<le> mask n", "apply (rule word_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>w >> n = 0; na < size w; w !! na\\<rbrakk>\n       \\<Longrightarrow> mask n !! na", "apply (rename_tac n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       \\<lbrakk>w >> n = 0; n' < size w; w !! n'\\<rbrakk>\n       \\<Longrightarrow> mask n !! n'", "apply (drule_tac x = \"n' - n\" in word_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       \\<lbrakk>n' < size w; w !! n';\n        (w >> n) !! (n' - n) = 0 !! (n' - n)\\<rbrakk>\n       \\<Longrightarrow> mask n !! n'", "apply (simp add : nth_shiftr word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       \\<lbrakk>n' < LENGTH('a); w !! n'; \\<not> w !! (n' - n + n)\\<rbrakk>\n       \\<Longrightarrow> n' < n", "apply (case_tac \"n <= n'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>n' < LENGTH('a); w !! n'; \\<not> w !! (n' - n + n);\n        n \\<le> n'\\<rbrakk>\n       \\<Longrightarrow> n' < n\n 2. \\<And>n'.\n       \\<lbrakk>n' < LENGTH('a); w !! n'; \\<not> w !! (n' - n + n);\n        \\<not> n \\<le> n'\\<rbrakk>\n       \\<Longrightarrow> n' < n", "by auto"], ["", "lemma and_mask_eq_iff_shiftr_0:\n  \"(w AND mask n = w) = (w >> n = 0)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND mask n = w) = (w >> n = 0)", "apply (unfold test_bit_eq_iff [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((!!) (w AND mask n) = (!!) w) = ((!!) (w >> n) = (!!) 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (!!) (w AND mask n) = (!!) w \\<Longrightarrow> (!!) (w >> n) = (!!) 0\n 2. (!!) (w >> n) = (!!) 0 \\<Longrightarrow> (!!) (w AND mask n) = (!!) w", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (!!) (w AND mask n) = (!!) w \\<Longrightarrow> (w >> n) !! x = 0 !! x\n 2. (!!) (w >> n) = (!!) 0 \\<Longrightarrow> (!!) (w AND mask n) = (!!) w", "apply (rule_tac [2] ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (!!) (w AND mask n) = (!!) w \\<Longrightarrow> (w >> n) !! x = 0 !! x\n 2. \\<And>x.\n       (!!) (w >> n) = (!!) 0 \\<Longrightarrow> (w AND mask n) !! x = w !! x", "apply (auto simp add : word_ao_nth nth_shiftr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(!!) (w AND mask n) = (!!) w; w !! (x + n)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < n\n 3. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < size (mask n)", "apply (drule arg_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>w !! (x + n);\n        ?f11 x ((!!) (w AND mask n)) = ?f11 x ((!!) w)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < n\n 3. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < size (mask n)", "apply (drule iffD2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. w !! (x + n) \\<Longrightarrow> ?f11 x ((!!) w)\n 2. \\<And>x.\n       \\<lbrakk>w !! (x + n); ?f11 x ((!!) (w AND mask n))\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < n\n 4. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < size (mask n)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>w !! (x + n); (w AND mask n) !! (x + n)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < n\n 3. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < size (mask n)", "apply (simp add : word_ao_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < n\n 2. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < size (mask n)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < size (mask n)\n 2. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < n", "apply (simp add : word_size test_bit_bin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(!!) (w >> n) = (!!) 0; w !! x\\<rbrakk>\n       \\<Longrightarrow> x < n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x w n.\n       \\<lbrakk>(\\<lambda>na.\n                    na < LENGTH('a) \\<and>\n                    bit ((drop_bit n \\<circ> take_bit LENGTH('a)) w) na) =\n                (\\<lambda>n. n < LENGTH('a) \\<and> bit 0 n);\n        x < LENGTH('a) \\<and> bit w x\\<rbrakk>\n       \\<Longrightarrow> x < n", "apply (auto simp add: fun_eq_iff bit_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x w n.\n       \\<lbrakk>\\<forall>x.\n                   n + x < LENGTH('a) \\<longrightarrow>\n                   \\<not> bit w (n + x);\n        x < LENGTH('a); bit w x\\<rbrakk>\n       \\<Longrightarrow> x < n", "apply (metis add_diff_inverse_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_shiftl_decompose:\n  \"mask m << n = mask (m + n) AND NOT (mask n :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask m << n = mask (m + n) AND NOT (mask n)", "by (auto intro!: word_eqI simp: and_not_mask nth_shiftl nth_shiftr word_size)"], ["", "lemma bang_eq:\n  fixes x :: \"'a::len word\"\n  shows \"(x = y) = (\\<forall>n. x !! n = y !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (\\<forall>n. x !! n = y !! n)", "by (subst test_bit_eq_iff[symmetric]) fastforce"], ["", "lemma shiftl_over_and_dist:\n  fixes a::\"'a::len word\"\n  shows \"(a AND b) << c = (a << c) AND (b << c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a AND b << c = (a << c) AND (b << c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a AND b << c) \\<longrightarrow>\n       (a AND b << c) !! n = ((a << c) AND (b << c)) !! n", "apply(simp add: word_ao_nth nth_shiftl, safe)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_over_and_dist:\n  fixes a::\"'a::len word\"\n  shows \"a AND b >> c = (a >> c) AND (b >> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a AND b >> c = (a >> c) AND (b >> c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a AND b >> c) \\<longrightarrow>\n       (a AND b >> c) !! n = ((a >> c) AND (b >> c)) !! n", "apply(simp add:nth_shiftr word_ao_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sshiftr_over_and_dist:\n  fixes a::\"'a::len word\"\n  shows \"a AND b >>> c = (a >>> c) AND (b >>> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a AND b >>> c = (a >>> c) AND (b >>> c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a AND b >>> c) \\<longrightarrow>\n       (a AND b >>> c) !! n = ((a >>> c) AND (b >>> c)) !! n", "apply(simp add:nth_sshiftr word_ao_nth word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_over_or_dist:\n  fixes a::\"'a::len word\"\n  shows \"a OR b << c = (a << c) OR (b << c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a OR b << c = (a << c) OR (b << c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a OR b << c) \\<longrightarrow>\n       (a OR b << c) !! n = ((a << c) OR (b << c)) !! n", "apply(simp add:nth_shiftl word_ao_nth, safe)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_over_or_dist:\n  fixes a::\"'a::len word\"\n  shows \"a OR b >> c = (a >> c) OR (b >> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a OR b >> c = (a >> c) OR (b >> c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a OR b >> c) \\<longrightarrow>\n       (a OR b >> c) !! n = ((a >> c) OR (b >> c)) !! n", "apply(simp add:nth_shiftr word_ao_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sshiftr_over_or_dist:\n  fixes a::\"'a::len word\"\n  shows \"a OR b >>> c = (a >>> c) OR (b >>> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a OR b >>> c = (a >>> c) OR (b >>> c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a OR b >>> c) \\<longrightarrow>\n       (a OR b >>> c) !! n = ((a >>> c) OR (b >>> c)) !! n", "apply(simp add:nth_sshiftr word_ao_nth word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas shift_over_ao_dists =\n  shiftl_over_or_dist shiftr_over_or_dist\n  sshiftr_over_or_dist shiftl_over_and_dist\n  shiftr_over_and_dist sshiftr_over_and_dist"], ["", "lemma shiftl_shiftl:\n  fixes a::\"'a::len word\"\n  shows \"a << b << c = a << (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a << b << c = a << b + c", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a << b << c) \\<longrightarrow>\n       (a << b << c) !! n = (a << b + c) !! n", "apply(auto simp:word_size nth_shiftl add.commute add.left_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_shiftr:\n  fixes a::\"'a::len word\"\n  shows \"a >> b >> c = a >> (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a >> b >> c = a >> b + c", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (a >> b >> c) \\<longrightarrow>\n       (a >> b >> c) !! n = (a >> b + c) !! n", "apply(simp add:word_size nth_shiftr add.left_commute add.commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_shiftr1:\n  fixes a::\"'a::len word\"\n  shows \"c \\<le> b \\<Longrightarrow> a << b >> c = a AND (mask (size a - b)) << (b - c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> b \\<Longrightarrow>\n    a << b >> c = a AND mask (size a - b) << b - c", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       c \\<le> b \\<Longrightarrow>\n       n < size (a << b >> c) \\<longrightarrow>\n       (a << b >> c) !! n = (a AND mask (size a - b) << b - c) !! n", "apply(auto simp:nth_shiftr nth_shiftl word_size word_ao_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_shiftr2:\n  fixes a::\"'a::len word\"\n  shows \"b < c \\<Longrightarrow> a << b >> c = (a >> (c - b)) AND (mask (size a - c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < c \\<Longrightarrow> a << b >> c = (a >> c - b) AND mask (size a - c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       b < c \\<Longrightarrow>\n       n < size (a << b >> c) \\<longrightarrow>\n       (a << b >> c) !! n = ((a >> c - b) AND mask (size a - c)) !! n", "apply(auto simp:nth_shiftr nth_shiftl word_size word_ao_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_shiftl1:\n  fixes a::\"'a::len word\"\n  shows \"c \\<le> b \\<Longrightarrow> a >> b << c = (a >> (b - c)) AND (NOT (mask c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> b \\<Longrightarrow> a >> b << c = (a >> b - c) AND NOT (mask c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       c \\<le> b \\<Longrightarrow>\n       n < size (a >> b << c) \\<longrightarrow>\n       (a >> b << c) !! n = ((a >> b - c) AND NOT (mask c)) !! n", "apply(auto simp:nth_shiftr nth_shiftl word_size word_ops_nth_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_shiftl2:\n  fixes a::\"'a::len word\"\n  shows \"b < c \\<Longrightarrow> a >> b << c = (a << (c - b)) AND (NOT (mask c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < c \\<Longrightarrow> a >> b << c = (a << c - b) AND NOT (mask c)", "apply(rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       b < c \\<Longrightarrow>\n       n < size (a >> b << c) \\<longrightarrow>\n       (a >> b << c) !! n = ((a << c - b) AND NOT (mask c)) !! n", "apply(auto simp:nth_shiftr nth_shiftl word_size word_ops_nth_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas multi_shift_simps =\n  shiftl_shiftl shiftr_shiftr\n  shiftl_shiftr1 shiftl_shiftr2\n  shiftr_shiftl1 shiftr_shiftl2"], ["", "lemma shiftr_mask2:\n  \"n \\<le> LENGTH('a) \\<Longrightarrow> (mask n >> m :: ('a :: len) word) = mask (n - m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> LENGTH('a) \\<Longrightarrow> mask n >> m = mask (n - m)", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n \\<le> LENGTH('a) \\<Longrightarrow>\n       na < size (mask n >> m) \\<longrightarrow>\n       (mask n >> m) !! na = mask (n - m) !! na", "apply (simp add: nth_shiftr word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n \\<le> LENGTH('a) \\<Longrightarrow>\n       na < LENGTH('a) \\<longrightarrow>\n       (na + m < n \\<and> na + m < LENGTH('a)) = (na < n - m)", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_shiftl_add_distrib:\n  fixes x :: \"'a :: len word\"\n  shows \"(x + y) << n = (x << n) + (y << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y << n = (x << n) + (y << n)", "by (simp add: shiftl_t2n ring_distribs)"], ["", "lemma mask_shift:\n  \"(x AND NOT (mask y)) >> y = x >> y\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND NOT (mask y) >> y = x >> y", "apply (rule bit_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       2 ^ n \\<noteq> 0 \\<Longrightarrow>\n       bit (x AND NOT (mask y) >> y) n = bit (x >> y) n", "apply (simp add: bit_and_iff bit_not_iff bit_shiftr_word_iff bit_mask_iff not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       (bit x (y + n) \\<and> y + n < LENGTH('a)) = bit x (y + n)", "using bit_imp_le_length"], ["proof (prove)\nusing this:\n  bit ?w ?n \\<Longrightarrow> ?n < LENGTH(?'a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       (bit x (y + n) \\<and> y + n < LENGTH('a)) = bit x (y + n)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_div_2n':\n  \"unat (w >> n) = unat w div 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (w >> n) = unat w div 2 ^ n", "apply (unfold unat_eq_nat_uint)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (uint (w >> n)) = nat (uint w) div 2 ^ n", "apply (subst shiftr_div_2n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (uint w div 2 ^ n) = nat (uint w) div 2 ^ n", "apply (subst nat_div_distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> uint w\n 2. nat (uint w) div nat (2 ^ n) = nat (uint w) div 2 ^ n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (uint w) div nat (2 ^ n) = nat (uint w) div 2 ^ n", "apply (simp add: nat_power_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_shiftr_id:\n  assumes nv: \"n < LENGTH('a)\"\n  and     xv: \"x < 2 ^ (LENGTH('a) - n)\"\n  shows \"x << n >> n = (x::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x << n >> n = x", "apply (simp add: shiftl_t2n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n * x >> n = x", "apply (rule word_eq_unatI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ n * x >> n) = unat x", "apply (subst shiftr_div_2n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ n * x) div 2 ^ n = unat x", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> unat (2 ^ n * x) div 2 ^ n = unat x\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> unat (2 ^ n * x) div 2 ^ n = unat x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> unat (2 ^ n * x) div 2 ^ n = unat x", "apply (subst iffD1 [OF unat_mult_lem])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> unat (2 ^ n) * unat x < 2 ^ LENGTH('a)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       unat (2 ^ n) * unat x div 2 ^ n = unat x", "apply (subst unat_power_lower[OF nv])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> 2 ^ n * unat x < 2 ^ LENGTH('a)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       unat (2 ^ n) * unat x div 2 ^ n = unat x", "apply (rule nat_less_power_trans [OF _ order_less_imp_le [OF nv]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> unat x < 2 ^ (LENGTH('a) - n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       unat (2 ^ n) * unat x div 2 ^ n = unat x", "apply (rule order_less_le_trans [OF unat_mono [OF xv] order_eq_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       unat (2 ^ (LENGTH('a) - n)) = 2 ^ (LENGTH('a) - n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       unat (2 ^ n) * unat x div 2 ^ n = unat x", "apply (rule unat_power_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> LENGTH('a) - n < LENGTH('a)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       unat (2 ^ n) * unat x div 2 ^ n = unat x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       unat (2 ^ n) * unat x div 2 ^ n = unat x", "apply (subst unat_power_lower[OF nv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> 2 ^ n * unat x div 2 ^ n = unat x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_shiftl_eq_0:\n  fixes w :: \"'a :: len word\"\n  shows \"\\<lbrakk> n \\<ge> LENGTH('b) \\<rbrakk> \\<Longrightarrow> ucast (w << n) = (0 :: 'b :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) \\<le> n \\<Longrightarrow> ucast (w << n) = 0", "by transfer (simp add: take_bit_push_bit)"], ["", "lemma word_shift_nonzero:\n  \"\\<lbrakk> (x::'a::len word) \\<le> 2 ^ m; m + n < LENGTH('a::len); x \\<noteq> 0\\<rbrakk>\n   \\<Longrightarrow> x << n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 2 ^ m; m + n < LENGTH('a); x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x << n \\<noteq> 0", "apply (simp only: word_neq_0_conv word_less_nat_alt\n                    shiftl_t2n mod_0 unat_word_ariths\n                    unat_power_lower word_le_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x mod 2 ^ LENGTH('a)", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * unat x < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x", "apply (rule order_le_less_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * unat x \\<le> ?y5\n 2. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> ?y5 < 2 ^ LENGTH('a)\n 3. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x", "apply (erule mult_le_mono2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * 2 ^ m < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x", "apply (subst power_add[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (n + m) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x", "apply (rule power_strict_increasing)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> n + m < LENGTH('a)\n 2. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 1 < 2\n 3. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 1 < 2\n 2. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x \\<le> 2 ^ m; m + n < LENGTH('a); 0 < unat x\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n * unat x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_shiftr_lt:\n  fixes w :: \"'a::len word\"\n  shows \"unat (w >> n) < (2 ^ (LENGTH('a) - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (w >> n) < 2 ^ (LENGTH('a) - n)", "apply (subst shiftr_div_2n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat w div 2 ^ n < 2 ^ (LENGTH('a) - n)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w n.\n       (nat \\<circ> take_bit LENGTH('a)) w div 2 ^ n < 2 ^ (LENGTH('a) - n)", "apply (simp flip: drop_bit_eq_div add: drop_bit_nat_eq drop_bit_take_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma neg_mask_test_bit:\n  \"(NOT(mask n) :: 'a :: len word) !! m = (n \\<le> m \\<and> m < LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (mask n) !! m = (n \\<le> m \\<and> m < LENGTH('a))", "by (metis not_le nth_mask test_bit_bin word_ops_nth_size word_size)"], ["", "lemma upper_bits_unset_is_l2p:\n  \\<open>(\\<forall>n' \\<ge> n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n') \\<longleftrightarrow> (p < 2 ^ n)\\<close> (is \\<open>?P \\<longleftrightarrow> ?Q\\<close>)\n    if \\<open>n < LENGTH('a)\\<close>\n    for p :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n') =\n    (p < 2 ^ n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>n'\\<ge>n.\n       n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n' \\<Longrightarrow>\n    p < 2 ^ n\n 2. p < 2 ^ n \\<Longrightarrow>\n    \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'", "assume ?Q"], ["proof (state)\nthis:\n  p < 2 ^ n\n\ngoal (2 subgoals):\n 1. \\<forall>n'\\<ge>n.\n       n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n' \\<Longrightarrow>\n    p < 2 ^ n\n 2. p < 2 ^ n \\<Longrightarrow>\n    \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'", "then"], ["proof (chain)\npicking this:\n  p < 2 ^ n", "show ?P"], ["proof (prove)\nusing this:\n  p < 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'", "by (meson bang_is_le le_less_trans not_le word_power_increasing)"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n' \\<Longrightarrow>\n    p < 2 ^ n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n' \\<Longrightarrow>\n    p < 2 ^ n", "assume ?P"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n' \\<Longrightarrow>\n    p < 2 ^ n", "have \\<open>take_bit n p = p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n p = p", "proof (rule bit_word_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow> bit (take_bit n p) na = bit p na", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow> bit (take_bit n p) na = bit p na", "assume \\<open>q < LENGTH('a)\\<close>"], ["proof (state)\nthis:\n  q < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow> bit (take_bit n p) na = bit p na", "show \\<open>bit (take_bit n p) q \\<longleftrightarrow> bit p q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (take_bit n p) q = bit p q", "proof (cases \\<open>q < n\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q\n 2. \\<not> q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q", "case True"], ["proof (state)\nthis:\n  q < n\n\ngoal (2 subgoals):\n 1. q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q\n 2. \\<not> q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q", "then"], ["proof (chain)\npicking this:\n  q < n", "show ?thesis"], ["proof (prove)\nusing this:\n  q < n\n\ngoal (1 subgoal):\n 1. bit (take_bit n p) q = bit p q", "by (auto simp add: bit_simps)"], ["proof (state)\nthis:\n  bit (take_bit n p) q = bit p q\n\ngoal (1 subgoal):\n 1. \\<not> q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q", "case False"], ["proof (state)\nthis:\n  \\<not> q < n\n\ngoal (1 subgoal):\n 1. \\<not> q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q", "then"], ["proof (chain)\npicking this:\n  \\<not> q < n", "have \\<open>n \\<le> q\\<close>"], ["proof (prove)\nusing this:\n  \\<not> q < n\n\ngoal (1 subgoal):\n 1. n \\<le> q", "by simp"], ["proof (state)\nthis:\n  n \\<le> q\n\ngoal (1 subgoal):\n 1. \\<not> q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q", "with \\<open>?P\\<close> \\<open>q < LENGTH('a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\n  q < LENGTH('a)\n  n \\<le> q", "have \\<open>\\<not> bit p q\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\n  q < LENGTH('a)\n  n \\<le> q\n\ngoal (1 subgoal):\n 1. \\<not> bit p q", "by (simp add: test_bit_eq_bit)"], ["proof (state)\nthis:\n  \\<not> bit p q\n\ngoal (1 subgoal):\n 1. \\<not> q < n \\<Longrightarrow> bit (take_bit n p) q = bit p q", "then"], ["proof (chain)\npicking this:\n  \\<not> bit p q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> bit p q\n\ngoal (1 subgoal):\n 1. bit (take_bit n p) q = bit p q", "by (simp add: bit_simps)"], ["proof (state)\nthis:\n  bit (take_bit n p) q = bit p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bit (take_bit n p) q = bit p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take_bit n p = p\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n' \\<Longrightarrow>\n    p < 2 ^ n", "with that"], ["proof (chain)\npicking this:\n  n < LENGTH('a)\n  take_bit n p = p", "show ?Q"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n  take_bit n p = p\n\ngoal (1 subgoal):\n 1. p < 2 ^ n", "using take_bit_word_eq_self_iff [of n p]"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n  take_bit n p = p\n  (take_bit n p = p) = (LENGTH('a) \\<le> n \\<or> p < 2 ^ n)\n\ngoal (1 subgoal):\n 1. p < 2 ^ n", "by auto"], ["proof (state)\nthis:\n  p < 2 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_2p_is_upper_bits_unset:\n  \"p < 2 ^ n \\<longleftrightarrow> n < LENGTH('a) \\<and> (\\<forall>n' \\<ge> n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n')\" for p :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p < 2 ^ n) =\n    (n < LENGTH('a) \\<and>\n     (\\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'))", "by (meson le_less_trans le_mask_iff_lt_2n upper_bits_unset_is_l2p word_zero_le)"], ["", "lemma test_bit_over:\n  \"n \\<ge> size (x::'a::len word) \\<Longrightarrow> (x !! n) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x \\<le> n \\<Longrightarrow> x !! n = False", "by transfer auto"], ["", "lemma le_mask_high_bits:\n  \"w \\<le> mask n \\<longleftrightarrow> (\\<forall>i \\<in> {n ..< size w}. \\<not> w !! i)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<le> mask n) = (\\<forall>i\\<in>{n..<size w}. \\<not> w !! i)", "by (auto simp: word_size and_mask_eq_iff_le_mask[symmetric] word_eq_iff)"], ["", "lemma test_bit_conj_lt:\n  \"(x !! m \\<and> m < LENGTH('a)) = x !! m\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x !! m \\<and> m < LENGTH('a)) = x !! m", "using test_bit_bin"], ["proof (prove)\nusing this:\n  ?w !! ?n = (?n < LENGTH(?'a) \\<and> bit (uint ?w) ?n)\n\ngoal (1 subgoal):\n 1. (x !! m \\<and> m < LENGTH('a)) = x !! m", "by blast"], ["", "lemma neg_test_bit:\n  \"(NOT x) !! n = (\\<not> x !! n \\<and> n < LENGTH('a))\" for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT x !! n = (\\<not> x !! n \\<and> n < LENGTH('a))", "by (cases \"n < LENGTH('a)\") (auto simp add: test_bit_over word_ops_nth_size word_size)"], ["", "lemma shiftr_less_t2n':\n  \"\\<lbrakk> x AND mask (n + m) = x; m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> x >> n < 2 ^ m\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND mask (n + m) = x; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x >> n < 2 ^ m", "apply (simp add: word_size mask_eq_iff_w2p [symmetric] flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take_bit (n + m) x = x; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> take_bit m (x >> n) = x >> n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m x.\n       \\<lbrakk>take_bit LENGTH('a) (take_bit (min LENGTH('a) (n + m)) x) =\n                take_bit LENGTH('a) x;\n        m < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a)\n                          (take_bit (min LENGTH('a) m)\n                            ((drop_bit n \\<circ> take_bit LENGTH('a)) x)) =\n                         take_bit LENGTH('a)\n                          ((drop_bit n \\<circ> take_bit LENGTH('a)) x)", "apply (simp add: take_bit_drop_bit ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_less_t2n:\n  \"x < 2 ^ (n + m) \\<Longrightarrow> x >> n < 2 ^ m\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ (n + m) \\<Longrightarrow> x >> n < 2 ^ m", "apply (rule shiftr_less_t2n')"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < 2 ^ (n + m) \\<Longrightarrow> x AND mask (n + m) = x\n 2. x < 2 ^ (n + m) \\<Longrightarrow> m < LENGTH('a)", "apply (erule less_mask_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ (n + m) \\<Longrightarrow> m < LENGTH('a)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (n + m); \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (n + m); LENGTH('a) \\<le> m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subst (asm) p2_eq_0[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (n + m); 2 ^ m = 0\\<rbrakk> \\<Longrightarrow> False", "apply (simp add: power_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_eq_0:\n  \"n \\<ge> LENGTH('a) \\<Longrightarrow> ((w::'a::len word) >> n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> w >> n = 0", "apply (cut_tac shiftr_less_t2n'[of w n 0], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> w AND mask (n + 0) = w\n 2. LENGTH('a) \\<le> n \\<Longrightarrow> 0 < LENGTH('a)", "apply (simp add: mask_eq_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> uint w < 2 ^ n\n 2. LENGTH('a) \\<le> n \\<Longrightarrow> 0 < LENGTH('a)", "apply (simp add: lt2p_lem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> 0 < LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_not_mask_0:\n  \"n+m \\<ge> LENGTH('a :: len) \\<Longrightarrow> ((w::'a::len word) >> n) AND NOT (mask m) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n + m \\<Longrightarrow> (w >> n) AND NOT (mask m) = 0", "by (rule bit_word_eqI) (auto simp add: bit_simps dest: bit_imp_le_length)"], ["", "lemma shiftl_less_t2n:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> x < (2 ^ (m - n)); m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (x << n) < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (m - n); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x << n < 2 ^ m", "apply (simp add: word_size mask_eq_iff_w2p [symmetric] flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take_bit (m - n) x = x; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> take_bit m (x << n) = x << n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n x.\n       \\<lbrakk>take_bit LENGTH('a) (take_bit (min LENGTH('a) (m - n)) x) =\n                take_bit LENGTH('a) x;\n        m < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a)\n                          (take_bit (min LENGTH('a) m) (push_bit n x)) =\n                         take_bit LENGTH('a) (push_bit n x)", "apply (simp add: take_bit_push_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_less_t2n':\n  \"(x::'a::len word) < 2 ^ m \\<Longrightarrow> m+n < LENGTH('a) \\<Longrightarrow> x << n < 2 ^ (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ m; m + n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x << n < 2 ^ (m + n)", "by (rule shiftl_less_t2n) simp_all"], ["", "lemma nth_w2p_scast [simp]:\n  \"((scast ((2::'a::len signed word) ^ n) :: 'a word) !! m)\n         \\<longleftrightarrow> ((((2::'a::len  word) ^ n) :: 'a word) !! m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scast (2 ^ n) !! m = (2 ^ n) !! m", "by transfer (auto simp add: bit_simps)"], ["", "lemma scast_bit_test [simp]:\n    \"scast ((1 :: 'a::len signed word) << n) = (1 :: 'a word) << n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scast (1 << n) = 1 << n", "by (clarsimp simp: word_eq_iff)"], ["", "lemma signed_shift_guard_to_word:\n  \"\\<lbrakk> n < len_of TYPE ('a); n > 0 \\<rbrakk>\n    \\<Longrightarrow> (unat (x :: 'a :: len word) * 2 ^ y < 2 ^ n)\n    = (x = 0 \\<or> x < (1 << n >> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> (unat x * 2 ^ y < 2 ^ n) =\n                      (x = 0 \\<or> x < 1 << n >> y)", "apply (simp only: nat_mult_power_less_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply (cases \"y \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply (simp only: shiftl_shiftr1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) =\n                      (x = 0 \\<or> x < 1 AND mask (size 1 - n) << n - y)\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply (subst less_mask_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> 1 < 2 ^ (size 1 - n)\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n - y)\n 3. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply (simp add: word_less_nat_alt word_size)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < 2 ^ (LENGTH('a) - n)\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n - y)\n 3. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply (rule order_less_le_trans[rotated], rule power_increasing[where n=1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> LENGTH('a) - n\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 2\n 3. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < 2 ^ 1\n 4. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n - y)\n 5. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 2\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < 2 ^ 1\n 3. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n - y)\n 4. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < 2 ^ 1\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n - y)\n 3. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n - y)\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply (simp add: nat_mult_power_less_eq word_less_nat_alt word_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) =\n                      (x = 0 \\<or> unat x < 2 ^ (n - y))\n 2. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); 0 < n; \\<not> y \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (unat x < 2 ^ (n - y)) = (x = 0 \\<or> x < 1 << n >> y)", "apply (simp only: shiftl_shiftr2, simp add: unat_eq_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_bounded:\n  \"\\<lbrakk>(x :: 'a :: len word) !! n; x < 2 ^ m; m \\<le> len_of TYPE ('a)\\<rbrakk> \\<Longrightarrow> n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x !! n; x < 2 ^ m; m \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n < m", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x !! n; x < 2 ^ m; m \\<le> LENGTH('a); \\<not> n < m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp add: not_less test_bit_word_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bit x n; x < 2 ^ m; m \\<le> LENGTH('a); m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (meson bit_imp_le_length bit_uint_iff less_2p_is_upper_bits_unset test_bit_bin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_mask_is_0[simp]:\n  \"(x << n) AND mask n = 0\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x << n) AND mask n = 0", "by (simp flip: take_bit_eq_mask add: shiftl_eq_push_bit take_bit_push_bit)"], ["", "lemma rshift_sub_mask_eq:\n  \"(a >> (size a - b)) AND mask b = a >> (size a - b)\"\n  for a :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a >> size a - b) AND mask b = a >> size a - b", "using shiftl_shiftr2[where a=a and b=0 and c=\"size a - b\"]"], ["proof (prove)\nusing this:\n  0 < size a - b \\<Longrightarrow>\n  a << 0 >> size a - b =\n  (a >> size a - b - 0) AND mask (size a - (size a - b))\n\ngoal (1 subgoal):\n 1. (a >> size a - b) AND mask b = a >> size a - b", "apply (cases \"b < size a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < size a - b \\<Longrightarrow>\n             a << 0 >> size a - b =\n             (a >> size a - b - 0) AND mask (size a - (size a - b));\n     b < size a\\<rbrakk>\n    \\<Longrightarrow> (a >> size a - b) AND mask b = a >> size a - b\n 2. \\<lbrakk>0 < size a - b \\<Longrightarrow>\n             a << 0 >> size a - b =\n             (a >> size a - b - 0) AND mask (size a - (size a - b));\n     \\<not> b < size a\\<rbrakk>\n    \\<Longrightarrow> (a >> size a - b) AND mask b = a >> size a - b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < size a - b \\<Longrightarrow>\n             a << 0 >> size a - b =\n             (a >> size a - b - 0) AND mask (size a - (size a - b));\n     \\<not> b < size a\\<rbrakk>\n    \\<Longrightarrow> (a >> size a - b) AND mask b = a >> size a - b", "apply (simp add: linorder_not_less mask_eq_decr_exp word_size\n                   p2_eq_0[THEN iffD2])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_shiftr3:\n  \"b \\<le> c \\<Longrightarrow> a << b >> c = (a >> c - b) AND mask (size a - c)\"\n  for a :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> c \\<Longrightarrow>\n    a << b >> c = (a >> c - b) AND mask (size a - c)", "apply (cases \"b = c\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<le> c; b = c\\<rbrakk>\n    \\<Longrightarrow> a << b >> c = (a >> c - b) AND mask (size a - c)\n 2. \\<lbrakk>b \\<le> c; b \\<noteq> c\\<rbrakk>\n    \\<Longrightarrow> a << b >> c = (a >> c - b) AND mask (size a - c)", "apply (simp add: shiftl_shiftr1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> c; b \\<noteq> c\\<rbrakk>\n    \\<Longrightarrow> a << b >> c = (a >> c - b) AND mask (size a - c)", "apply (simp add: shiftl_shiftr2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma and_mask_shiftr_comm:\n  \"m \\<le> size w \\<Longrightarrow> (w AND mask m) >> n = (w >> n) AND mask (m-n)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> size w \\<Longrightarrow>\n    w AND mask m >> n = (w >> n) AND mask (m - n)", "by (simp add: and_mask shiftr_shiftr) (simp add: word_size shiftl_shiftr3)"], ["", "lemma and_mask_shiftl_comm:\n  \"m+n \\<le> size w \\<Longrightarrow> (w AND mask m) << n = (w << n) AND mask (m+n)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m + n \\<le> size w \\<Longrightarrow>\n    w AND mask m << n = (w << n) AND mask (m + n)", "by (simp add: and_mask word_size shiftl_shiftl) (simp add: shiftl_shiftr1)"], ["", "lemma le_mask_shiftl_le_mask: \"s = m + n \\<Longrightarrow> x \\<le> mask n \\<Longrightarrow> x << m \\<le> mask s\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = m + n; x \\<le> mask n\\<rbrakk>\n    \\<Longrightarrow> x << m \\<le> mask s", "by (simp add: le_mask_iff shiftl_shiftr3)"], ["", "lemma word_and_1_shiftl:\n  \"x AND (1 << n) = (if x !! n then (1 << n) else 0)\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND (1 << n) = (if x !! n then 1 << n else 0)", "apply (rule bit_word_eqI; transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x na.\n       n < LENGTH('a) \\<Longrightarrow>\n       (n < LENGTH('a) \\<and> bit (x AND push_bit na 1) n) =\n       (n < LENGTH('a) \\<and>\n        bit (if na < LENGTH('a) \\<and> bit x na then push_bit na 1 else 0)\n         n)", "apply (auto simp add: bit_simps not_le ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_and_1_shiftls'\n    = word_and_1_shiftl[where n=0]\n      word_and_1_shiftl[where n=1]\n      word_and_1_shiftl[where n=2]"], ["", "lemmas word_and_1_shiftls = word_and_1_shiftls' [simplified]"], ["", "lemma word_and_mask_shiftl:\n  \"x AND (mask n << m) = ((x >> m) AND mask n) << m\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND (mask n << m) = (x >> m) AND mask n << m", "apply (rule bit_word_eqI; transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x na m.\n       n < LENGTH('a) \\<Longrightarrow>\n       (n < LENGTH('a) \\<and> bit (x AND push_bit m (mask na)) n) =\n       (n < LENGTH('a) \\<and>\n        bit (push_bit m\n              ((drop_bit m \\<circ> take_bit LENGTH('a)) x AND mask na))\n         n)", "apply (auto simp add: bit_simps not_le ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shift_times_fold:\n  \"(x :: 'a :: len word) * (2 ^ n) << m = x << (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 2 ^ n << m = x << m + n", "by (simp add: shiftl_t2n ac_simps power_add)"], ["", "lemma of_bool_nth:\n  \"of_bool (x !! v) = (x >> v) AND 1\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bool (x !! v) = (x >> v) AND 1", "by (simp add: test_bit_word_eq shiftr_word_eq bit_eq_iff)\n    (auto simp add: bit_1_iff bit_and_iff bit_drop_bit_eq intro: ccontr)"], ["", "lemma shiftr_mask_eq:\n  \"(x >> n) AND mask (size x - n) = x >> n\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x >> n) AND mask (size x - n) = x >> n", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit (size x - n) (x >> n) = x >> n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       take_bit LENGTH('a)\n        (take_bit (min LENGTH('a) (LENGTH('a) - n))\n          ((drop_bit n \\<circ> take_bit LENGTH('a)) x)) =\n       take_bit LENGTH('a) ((drop_bit n \\<circ> take_bit LENGTH('a)) x)", "apply (simp add: take_bit_drop_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_mask_eq':\n  \"m = (size x - n) \\<Longrightarrow> (x >> n) AND mask m = x >> n\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = size x - n \\<Longrightarrow> (x >> n) AND mask m = x >> n", "by (simp add: shiftr_mask_eq)"], ["", "lemma and_eq_0_is_nth:\n  fixes x :: \"'a :: len word\"\n  shows \"y = 1 << n \\<Longrightarrow> ((x AND y) = 0) = (\\<not> (x !! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = 1 << n \\<Longrightarrow> (x AND y = 0) = (\\<not> x !! n)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = 1 << n; x AND (1 << n) = 0; x !! n\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>y = 1 << n; \\<not> x !! n\\<rbrakk>\n    \\<Longrightarrow> x AND (1 << n) = 0", "apply (drule_tac u=\"(x AND (1 << n))\" and x=n in word_eqD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = 1 << n; x !! n; (x AND (1 << n)) !! n = 0 !! n\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>y = 1 << n; \\<not> x !! n\\<rbrakk>\n    \\<Longrightarrow> x AND (1 << n) = 0", "apply (simp add: nth_w2p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = 2 ^ n; x !! n; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>y = 1 << n; \\<not> x !! n\\<rbrakk>\n    \\<Longrightarrow> x AND (1 << n) = 0", "apply (simp add: test_bit_bin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = 1 << n; \\<not> x !! n\\<rbrakk>\n    \\<Longrightarrow> x AND (1 << n) = 0", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>y = 1 << n; \\<not> x !! n; na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (x AND (1 << n)) na = bit 0 na", "apply (auto simp add: bit_simps test_bit_eq_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma and_neq_0_is_nth:\n  \\<open>x AND y \\<noteq> 0 \\<longleftrightarrow> x !! n\\<close> if \\<open>y = 2 ^ n\\<close> for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND y \\<noteq> 0) = x !! n", "apply (simp add: bit_eq_iff bit_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n. bit x n \\<and> bit y n) = x !! n", "using that"], ["proof (prove)\nusing this:\n  y = 2 ^ n\n\ngoal (1 subgoal):\n 1. (\\<exists>n. bit x n \\<and> bit y n) = x !! n", "apply (simp add: bit_simps not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = 2 ^ n \\<Longrightarrow> (bit x n \\<and> n < LENGTH('a)) = x !! n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n x.\n       take_bit LENGTH('a) y = take_bit LENGTH('a) (2 ^ n) \\<Longrightarrow>\n       ((n < LENGTH('a) \\<and> bit x n) \\<and> n < LENGTH('a)) =\n       (n < LENGTH('a) \\<and> bit x n)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_is_and_neq_0:\n  \"(x::'a::len word) !! n = (x AND 2 ^ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x !! n = (x AND 2 ^ n \\<noteq> 0)", "by (subst and_neq_0_is_nth; rule refl)"], ["", "lemma word_shift_zero:\n  \"\\<lbrakk> x << n = 0; x \\<le> 2^m; m + n < LENGTH('a)\\<rbrakk> \\<Longrightarrow> (x::'a::len word) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x << n = 0; x \\<le> 2 ^ m; m + n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x = 0", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x << n = 0; x \\<le> 2 ^ m; m + n < LENGTH('a);\n     x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule (2) word_shift_nonzero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x << n = 0; m + n < LENGTH('a); x \\<noteq> 0;\n     x << n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_shift_and_negate[simp]:\"(w AND mask n << m) AND NOT (mask n << m) = 0\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND mask n << m) AND NOT (mask n << m) = 0", "by (clarsimp simp add: mask_eq_decr_exp Parity.bit_eq_iff bit_and_iff bit_not_iff shiftl_word_eq bit_push_bit_iff)"], ["", "end"]]}