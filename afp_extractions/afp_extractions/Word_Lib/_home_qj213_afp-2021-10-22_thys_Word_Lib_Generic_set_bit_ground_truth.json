{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Generic_set_bit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma set_bit_eq:\n  \\<open>set_bit a n b = (if b then Bit_Operations.set_bit else unset_bit) n a\\<close>\n  for a :: \\<open>'a::{ring_bit_operations, set_bit}\\<close>", "lemma int_set_bit_0 [simp]: fixes x :: int shows\n  \"set_bit x 0 b = of_bool b + 2 * (x div 2)\"", "lemma int_set_bit_Suc: fixes x :: int shows\n  \"set_bit x (Suc n) b = of_bool (odd x) + 2 * set_bit (x div 2) n b\"", "lemma bin_last_set_bit:\n  \"bin_last (set_bit x n b) = (if n > 0 then bin_last x else b)\"", "lemma bin_rest_set_bit:\n  \"bin_rest (set_bit x n b) = (if n > 0 then set_bit (x div 2) (n - 1) b else x div 2)\"", "lemma int_set_bit_numeral: fixes x :: int shows\n  \"set_bit x (numeral w) b = of_bool (odd x) + 2 * set_bit (x div 2) (pred_numeral w) b\"", "lemmas int_set_bit_numerals [simp] =\n  int_set_bit_numeral[where x=\"numeral w'\"]\n  int_set_bit_numeral[where x=\"- numeral w'\"]\n  int_set_bit_numeral[where x=\"Numeral1\"]\n  int_set_bit_numeral[where x=\"1\"]\n  int_set_bit_numeral[where x=\"0\"]\n  int_set_bit_Suc[where x=\"numeral w'\"]\n  int_set_bit_Suc[where x=\"- numeral w'\"]\n  int_set_bit_Suc[where x=\"Numeral1\"]\n  int_set_bit_Suc[where x=\"1\"]\n  int_set_bit_Suc[where x=\"0\"]\n  for w'", "lemma msb_set_bit [simp]: \"msb (set_bit (x :: int) n b) \\<longleftrightarrow> msb x\"", "lemma set_bit_unfold:\n  \\<open>set_bit w n b = (if b then Bit_Operations.set_bit n w else unset_bit n w)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma bit_set_bit_word_iff [bit_simps]:\n  \\<open>bit (set_bit w m b) n \\<longleftrightarrow> (if m = n then n < LENGTH('a) \\<and> b else bit w n)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma word_set_nth [simp]: \"set_bit w n (test_bit w n) = w\"\n  for w :: \"'a::len word\"", "lemma test_bit_set: \"(set_bit w n x) !! n \\<longleftrightarrow> n < size w \\<and> x\"\n  for w :: \"'a::len word\"", "lemma test_bit_set_gen:\n  \"test_bit (set_bit w n x) m = (if m = n then n < size w \\<and> x else test_bit w m)\"\n  for w :: \"'a::len word\"", "lemma word_set_set_same [simp]: \"set_bit (set_bit w n x) n y = set_bit w n y\"\n  for w :: \"'a::len word\"", "lemma word_set_set_diff:\n  fixes w :: \"'a::len word\"\n  assumes \"m \\<noteq> n\"\n  shows \"set_bit (set_bit w m x) n y = set_bit (set_bit w n y) m x\"", "lemma set_bit_word_of_int: \"set_bit (word_of_int x) n b = word_of_int (bin_sc n b x)\"", "lemma word_set_numeral [simp]:\n  \"set_bit (numeral bin::'a::len word) n b =\n    word_of_int (bin_sc n b (numeral bin))\"", "lemma word_set_neg_numeral [simp]:\n  \"set_bit (- numeral bin::'a::len word) n b =\n    word_of_int (bin_sc n b (- numeral bin))\"", "lemma word_set_bit_0 [simp]: \"set_bit 0 n b = word_of_int (bin_sc n b 0)\"", "lemma word_set_bit_1 [simp]: \"set_bit 1 n b = word_of_int (bin_sc n b 1)\"", "lemma word_set_nth_iff: \"set_bit w n b = w \\<longleftrightarrow> w !! n = b \\<or> n \\<ge> size w\"\n  for w :: \"'a::len word\"", "lemma word_clr_le: \"w \\<ge> set_bit w n False\"\n  for w :: \"'a::len word\"", "lemma word_set_ge: \"w \\<le> set_bit w n True\"\n  for w :: \"'a::len word\"", "lemma set_bit_beyond:\n  \"size x \\<le> n \\<Longrightarrow> set_bit x n b = x\" for x :: \"'a :: len word\"", "lemma one_bit_shiftl: \"set_bit 0 n True = (1 :: 'a :: len word) << n\"", "lemmas one_bit_pow = trans [OF one_bit_shiftl shiftl_1]"], "translations": [["", "lemma set_bit_eq:\n  \\<open>set_bit a n b = (if b then Bit_Operations.set_bit else unset_bit) n a\\<close>\n  for a :: \\<open>'a::{ring_bit_operations, set_bit}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit a n b =\n    (if b then ring_bit_operations_class.set_bit else unset_bit) n a", "by (rule bit_eqI) (simp add: bit_simps)"], ["", "instantiation int :: set_bit\nbegin"], ["", "definition set_bit_int :: \\<open>int \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> int\\<close>\n  where \\<open>set_bit i n b = bin_sc n b i\\<close>"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, set_bit_class)", "by standard\n    (simp_all add: set_bit_int_def bin_nth_sc_gen bit_simps)"], ["", "end"], ["", "lemma int_set_bit_0 [simp]: fixes x :: int shows\n  \"set_bit x 0 b = of_bool b + 2 * (x div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x 0 b = of_bool b + 2 * (x div 2)", "by (auto simp add: set_bit_int_def intro: bin_rl_eqI)"], ["", "lemma int_set_bit_Suc: fixes x :: int shows\n  \"set_bit x (Suc n) b = of_bool (odd x) + 2 * set_bit (x div 2) n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x (Suc n) b =\n    of_bool (odd x) + 2 * set_bit_class.set_bit (x div 2) n b", "by (auto simp add: set_bit_int_def intro: bin_rl_eqI)"], ["", "lemma bin_last_set_bit:\n  \"bin_last (set_bit x n b) = (if n > 0 then bin_last x else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (set_bit_class.set_bit x n b) = (if 0 < n then odd x else b)", "by (cases n) (simp_all add: int_set_bit_Suc)"], ["", "lemma bin_rest_set_bit:\n  \"bin_rest (set_bit x n b) = (if n > 0 then set_bit (x div 2) (n - 1) b else x div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b div 2 =\n    (if 0 < n then set_bit_class.set_bit (x div 2) (n - 1) b else x div 2)", "by (cases n) (simp_all add: int_set_bit_Suc)"], ["", "lemma int_set_bit_numeral: fixes x :: int shows\n  \"set_bit x (numeral w) b = of_bool (odd x) + 2 * set_bit (x div 2) (pred_numeral w) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x (numeral w) b =\n    of_bool (odd x) + 2 * set_bit_class.set_bit (x div 2) (pred_numeral w) b", "by (simp add: set_bit_int_def)"], ["", "lemmas int_set_bit_numerals [simp] =\n  int_set_bit_numeral[where x=\"numeral w'\"]\n  int_set_bit_numeral[where x=\"- numeral w'\"]\n  int_set_bit_numeral[where x=\"Numeral1\"]\n  int_set_bit_numeral[where x=\"1\"]\n  int_set_bit_numeral[where x=\"0\"]\n  int_set_bit_Suc[where x=\"numeral w'\"]\n  int_set_bit_Suc[where x=\"- numeral w'\"]\n  int_set_bit_Suc[where x=\"Numeral1\"]\n  int_set_bit_Suc[where x=\"1\"]\n  int_set_bit_Suc[where x=\"0\"]\n  for w'"], ["", "lemma msb_set_bit [simp]: \"msb (set_bit (x :: int) n b) \\<longleftrightarrow> msb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (set_bit_class.set_bit x n b) = msb x", "by(simp add: msb_conv_bin_sign set_bit_int_def)"], ["", "instantiation word :: (len) set_bit\nbegin"], ["", "definition set_bit_word :: \\<open>'a word \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> 'a word\\<close>\n  where word_set_bit_def: \\<open>set_bit a n x = word_of_int (bin_sc n x (uint a))\\<close>"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a word, set_bit_class)", "by standard\n    (auto simp add: word_set_bit_def bin_nth_sc_gen bit_simps)"], ["", "end"], ["", "lemma set_bit_unfold:\n  \\<open>set_bit w n b = (if b then Bit_Operations.set_bit n w else unset_bit n w)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit w n b =\n    (if b then ring_bit_operations_class.set_bit n w else unset_bit n w)", "by (simp add: set_bit_eq)"], ["", "lemma bit_set_bit_word_iff [bit_simps]:\n  \\<open>bit (set_bit w m b) n \\<longleftrightarrow> (if m = n then n < LENGTH('a) \\<and> b else bit w n)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (set_bit_class.set_bit w m b) n =\n    (if m = n then n < LENGTH('a) \\<and> b else bit w n)", "by (auto simp add: bit_simps dest: bit_imp_le_length)"], ["", "lemma word_set_nth [simp]: \"set_bit w n (test_bit w n) = w\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit w n (w !! n) = w", "by (auto simp: word_test_bit_def word_set_bit_def)"], ["", "lemma test_bit_set: \"(set_bit w n x) !! n \\<longleftrightarrow> n < size w \\<and> x\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit w n x !! n = (n < size w \\<and> x)", "by (auto simp: word_size word_test_bit_def word_set_bit_def nth_bintr)"], ["", "lemma test_bit_set_gen:\n  \"test_bit (set_bit w n x) m = (if m = n then n < size w \\<and> x else test_bit w m)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit w n x !! m =\n    (if m = n then n < size w \\<and> x else w !! m)", "apply (unfold word_size word_test_bit_def word_set_bit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (uint (word_of_int (bin_sc n x (uint w)))) m =\n    (if m = n then n < LENGTH('a) \\<and> x else bit (uint w) m)", "apply (clarsimp simp add: nth_bintr bin_nth_sc_gen)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow>\n    (m < LENGTH('a) \\<and> bit (uint w) m) = bit (uint w) m", "apply (auto elim!: test_bit_size [unfolded word_size]\n      simp add: word_test_bit_def [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_set_set_same [simp]: \"set_bit (set_bit w n x) n y = set_bit w n y\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (set_bit_class.set_bit w n x) n y =\n    set_bit_class.set_bit w n y", "by (rule word_eqI) (simp add : test_bit_set_gen word_size)"], ["", "lemma word_set_set_diff:\n  fixes w :: \"'a::len word\"\n  assumes \"m \\<noteq> n\"\n  shows \"set_bit (set_bit w m x) n y = set_bit (set_bit w n y) m x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (set_bit_class.set_bit w m x) n y =\n    set_bit_class.set_bit (set_bit_class.set_bit w n y) m x", "by (rule word_eqI) (auto simp: test_bit_set_gen word_size assms)"], ["", "lemma set_bit_word_of_int: \"set_bit (word_of_int x) n b = word_of_int (bin_sc n b x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (word_of_int x) n b = word_of_int (bin_sc n b x)", "unfolding word_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (bin_sc n b (uint (word_of_int x))) =\n    word_of_int (bin_sc n b x)", "by (rule word_eqI)(simp add: word_size bin_nth_sc_gen nth_bintr)"], ["", "lemma word_set_numeral [simp]:\n  \"set_bit (numeral bin::'a::len word) n b =\n    word_of_int (bin_sc n b (numeral bin))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (numeral bin) n b =\n    word_of_int (bin_sc n b (numeral bin))", "unfolding word_numeral_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (word_of_int (numeral bin)) n b =\n    word_of_int (bin_sc n b (numeral bin))", "by (rule set_bit_word_of_int)"], ["", "lemma word_set_neg_numeral [simp]:\n  \"set_bit (- numeral bin::'a::len word) n b =\n    word_of_int (bin_sc n b (- numeral bin))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (- numeral bin) n b =\n    word_of_int (bin_sc n b (- numeral bin))", "unfolding word_neg_numeral_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (word_of_int (- numeral bin)) n b =\n    word_of_int (bin_sc n b (- numeral bin))", "by (rule set_bit_word_of_int)"], ["", "lemma word_set_bit_0 [simp]: \"set_bit 0 n b = word_of_int (bin_sc n b 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit 0 n b = word_of_int (bin_sc n b 0)", "unfolding word_0_wi"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (word_of_int 0) n b = word_of_int (bin_sc n b 0)", "by (rule set_bit_word_of_int)"], ["", "lemma word_set_bit_1 [simp]: \"set_bit 1 n b = word_of_int (bin_sc n b 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit 1 n b = word_of_int (bin_sc n b 1)", "unfolding word_1_wi"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit (word_of_int 1) n b = word_of_int (bin_sc n b 1)", "by (rule set_bit_word_of_int)"], ["", "lemma word_set_nth_iff: \"set_bit w n b = w \\<longleftrightarrow> w !! n = b \\<or> n \\<ge> size w\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_bit_class.set_bit w n b = w) = (w !! n = b \\<or> size w \\<le> n)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set_bit_class.set_bit w n b = w \\<Longrightarrow>\n    w !! n = b \\<or> size w \\<le> n\n 2. w !! n = b \\<or> size w \\<le> n \\<Longrightarrow>\n    set_bit_class.set_bit w n b = w", "apply (rule disjCI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set_bit_class.set_bit w n b = w; \\<not> size w \\<le> n\\<rbrakk>\n    \\<Longrightarrow> w !! n = b\n 2. w !! n = b \\<or> size w \\<le> n \\<Longrightarrow>\n    set_bit_class.set_bit w n b = w", "apply (drule word_eqD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> size w \\<le> n;\n     set_bit_class.set_bit w n b !! ?x5 = w !! ?x5\\<rbrakk>\n    \\<Longrightarrow> w !! n = b\n 2. w !! n = b \\<or> size w \\<le> n \\<Longrightarrow>\n    set_bit_class.set_bit w n b = w", "apply (erule sym [THEN trans])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> size w \\<le> n \\<Longrightarrow>\n    set_bit_class.set_bit w n b !! n = b\n 2. w !! n = b \\<or> size w \\<le> n \\<Longrightarrow>\n    set_bit_class.set_bit w n b = w", "apply (simp add: test_bit_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. w !! n = b \\<or> size w \\<le> n \\<Longrightarrow>\n    set_bit_class.set_bit w n b = w", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. w !! n = b \\<Longrightarrow> set_bit_class.set_bit w n b = w\n 2. size w \\<le> n \\<Longrightarrow> set_bit_class.set_bit w n b = w", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. size w \\<le> n \\<Longrightarrow> set_bit_class.set_bit w n b = w", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       size w \\<le> n \\<Longrightarrow>\n       na < size (set_bit_class.set_bit w n b) \\<longrightarrow>\n       set_bit_class.set_bit w n b !! na = w !! na", "apply (clarsimp simp add : test_bit_set_gen)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size w \\<le> n; n < size (set_bit_class.set_bit w n b);\n     w !! n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule test_bit_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size w \\<le> n; n < size (set_bit_class.set_bit w n b);\n     n < size w\\<rbrakk>\n    \\<Longrightarrow> False", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_clr_le: \"w \\<ge> set_bit w n False\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit w n False \\<le> w", "apply (simp add: word_set_bit_def word_le_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) (bin_sc n False (uint w)) \\<le> uint w", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w.\n       take_bit LENGTH('a) (bin_sc n False (take_bit LENGTH('a) w))\n       \\<le> take_bit LENGTH('a) w", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       take_bit LENGTH('a) (bin_sc n False (take_bit LENGTH('a) w))\n       \\<le> ?y85 n w\n 2. \\<And>n w. ?y85 n w \\<le> take_bit LENGTH('a) w", "apply (rule bintr_bin_clr_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w.\n       take_bit LENGTH('a) (take_bit LENGTH('a) w)\n       \\<le> take_bit LENGTH('a) w", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_set_ge: \"w \\<le> set_bit w n True\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<le> set_bit_class.set_bit w n True", "apply (simp add: word_set_bit_def word_le_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint w \\<le> take_bit LENGTH('a) (bin_sc n True (uint w))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w n.\n       take_bit LENGTH('a) w\n       \\<le> take_bit LENGTH('a) (bin_sc n True (take_bit LENGTH('a) w))", "apply (rule order_trans [OF _ bintr_bin_set_ge])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w n.\n       take_bit LENGTH('a) w\n       \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) w)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_bit_beyond:\n  \"size x \\<le> n \\<Longrightarrow> set_bit x n b = x\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x \\<le> n \\<Longrightarrow> set_bit_class.set_bit x n b = x", "by (auto intro: word_eqI simp add: test_bit_set_gen word_size)"], ["", "lemma one_bit_shiftl: \"set_bit 0 n True = (1 :: 'a :: len word) << n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit 0 n True = 1 << n", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < size (set_bit_class.set_bit 0 n True) \\<longrightarrow>\n       set_bit_class.set_bit 0 n True !! na = (1 << n) !! na", "apply (auto simp add: test_bit_set_gen nth_shiftl word_size\n              simp del: word_set_bit_0 shiftl_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas one_bit_pow = trans [OF one_bit_shiftl shiftl_1]"], ["", "end"]]}