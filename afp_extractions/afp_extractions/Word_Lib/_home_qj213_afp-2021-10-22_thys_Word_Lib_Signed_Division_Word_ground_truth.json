{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Signed_Division_Word.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma sdiv_word_def [code]:\n  \\<open>v sdiv w = word_of_int (sint v sdiv sint w)\\<close>\n  for v w :: \\<open>'a::len word\\<close>", "lemma smod_word_def [code]:\n  \\<open>v smod w = word_of_int (sint v smod sint w)\\<close>\n  for v w :: \\<open>'a::len word\\<close>", "lemma sdiv_smod_id:\n  \\<open>(a sdiv b) * b + (a smod b) = a\\<close>\n  for a b :: \\<open>'a::len word\\<close>", "lemma signed_div_arith:\n    \"sint ((a::('a::len) word) sdiv b) = signed_take_bit (LENGTH('a) - 1) (sint a sdiv sint b)\"", "lemma signed_mod_arith:\n    \"sint ((a::('a::len) word) smod b) = signed_take_bit (LENGTH('a) - 1) (sint a smod sint b)\"", "lemma word_sdiv_div1 [simp]:\n    \"(a :: ('a::len) word) sdiv 1 = a\"", "lemma word_sdiv_div0 [simp]:\n    \"(a :: ('a::len) word) sdiv 0 = 0\"", "lemma word_sdiv_div_minus1 [simp]:\n    \"(a :: ('a::len) word) sdiv -1 = -a\"", "lemmas word_sdiv_0 = word_sdiv_div0", "lemma sdiv_word_min:\n    \"- (2 ^ (size a - 1)) \\<le> sint (a :: ('a::len) word) sdiv sint (b :: ('a::len) word)\"", "lemmas word_sdiv_numerals_lhs = sdiv_word_def[where v=\"numeral x\" for x]\n    sdiv_word_def[where v=0] sdiv_word_def[where v=1]", "lemmas word_sdiv_numerals = word_sdiv_numerals_lhs[where w=\"numeral y\" for y]\n    word_sdiv_numerals_lhs[where w=0] word_sdiv_numerals_lhs[where w=1]", "lemma smod_word_mod_0 [simp]:\n  \"x smod (0 :: ('a::len) word) = x\"", "lemma smod_word_0_mod [simp]:\n  \"0 smod (x :: ('a::len) word) = 0\"", "lemma smod_word_max:\n  \"sint (a::'a word) smod sint (b::'a word) < 2 ^ (LENGTH('a::len) - Suc 0)\"", "lemma smod_word_min:\n  \"- (2 ^ (LENGTH('a::len) - Suc 0)) \\<le> sint (a::'a word) smod sint (b::'a word)\"", "lemma smod_word_alt_def:\n  \"(a :: ('a::len) word) smod b = a - (a sdiv b) * b\"", "lemmas word_smod_numerals_lhs = smod_word_def[where v=\"numeral x\" for x]\n    smod_word_def[where v=0] smod_word_def[where v=1]", "lemmas word_smod_numerals = word_smod_numerals_lhs[where w=\"numeral y\" for y]\n    word_smod_numerals_lhs[where w=0] word_smod_numerals_lhs[where w=1]"], "translations": [["", "lemma sdiv_word_def [code]:\n  \\<open>v sdiv w = word_of_int (sint v sdiv sint w)\\<close>\n  for v w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. v sdiv w = word_of_int (sint v sdiv sint w)", "by transfer simp"], ["", "lemma smod_word_def [code]:\n  \\<open>v smod w = word_of_int (sint v smod sint w)\\<close>\n  for v w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. v smod w = word_of_int (sint v smod sint w)", "by transfer simp"], ["", "lemma sdiv_smod_id:\n  \\<open>(a sdiv b) * b + (a smod b) = a\\<close>\n  for a b :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "by (cases \\<open>sint a < 0\\<close>; cases \\<open>sint b < 0\\<close>) (simp_all add: signed_modulo_int_def sdiv_word_def smod_word_def)"], ["", "lemma signed_div_arith:\n    \"sint ((a::('a::len) word) sdiv b) = signed_take_bit (LENGTH('a) - 1) (sint a sdiv sint b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint (a sdiv b) = signed_take_bit (LENGTH('a) - 1) (sint a sdiv sint b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       signed_take_bit (LENGTH('a) - Suc 0)\n        (signed_take_bit (LENGTH('a) - Suc 0) a sdiv\n         signed_take_bit (LENGTH('a) - Suc 0) b) =\n       signed_take_bit (LENGTH('a) - 1)\n        (signed_take_bit (LENGTH('a) - Suc 0) a sdiv\n         signed_take_bit (LENGTH('a) - Suc 0) b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma signed_mod_arith:\n    \"sint ((a::('a::len) word) smod b) = signed_take_bit (LENGTH('a) - 1) (sint a smod sint b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint (a smod b) = signed_take_bit (LENGTH('a) - 1) (sint a smod sint b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       signed_take_bit (LENGTH('a) - Suc 0)\n        (signed_take_bit (LENGTH('a) - Suc 0) a smod\n         signed_take_bit (LENGTH('a) - Suc 0) b) =\n       signed_take_bit (LENGTH('a) - 1)\n        (signed_take_bit (LENGTH('a) - Suc 0) a smod\n         signed_take_bit (LENGTH('a) - Suc 0) b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sdiv_div1 [simp]:\n    \"(a :: ('a::len) word) sdiv 1 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv 1 = a", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) = 0 \\<Longrightarrow> a sdiv 1 = a\n 2. \\<And>nat. LENGTH('a) = Suc nat \\<Longrightarrow> a sdiv 1 = a", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat. LENGTH('a) = Suc nat \\<Longrightarrow> a sdiv 1 = a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       take_bit LENGTH('a)\n        (signed_take_bit (LENGTH('a) - Suc 0) a sdiv\n         signed_take_bit (LENGTH('a) - Suc 0) 1) =\n       take_bit LENGTH('a) a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       take_bit (Suc nat)\n        (signed_take_bit nat a sdiv signed_take_bit nat 1) =\n       take_bit (Suc nat) a", "apply (case_tac nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat a.\n       \\<lbrakk>LENGTH('a) = Suc nat; nat = 0\\<rbrakk>\n       \\<Longrightarrow> take_bit (Suc nat)\n                          (signed_take_bit nat a sdiv\n                           signed_take_bit nat 1) =\n                         take_bit (Suc nat) a\n 2. \\<And>nat a nata.\n       \\<lbrakk>LENGTH('a) = Suc nat; nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> take_bit (Suc nat)\n                          (signed_take_bit nat a sdiv\n                           signed_take_bit nat 1) =\n                         take_bit (Suc nat) a", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a nata.\n       \\<lbrakk>LENGTH('a) = Suc (Suc nata); nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> take_bit (Suc (Suc nata))\n                          (signed_take_bit (Suc nata) a) =\n                         take_bit (Suc (Suc nata)) a", "apply (simp add: take_bit_signed_take_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sdiv_div0 [simp]:\n    \"(a :: ('a::len) word) sdiv 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv 0 = 0", "apply (auto simp: sdiv_word_def signed_divide_int_def sgn_if)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sdiv_div_minus1 [simp]:\n    \"(a :: ('a::len) word) sdiv -1 = -a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv - 1 = - a", "apply (auto simp: sdiv_word_def signed_divide_int_def sgn_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a = 0 \\<Longrightarrow> a = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       signed_take_bit (LENGTH('a) - Suc 0) a = 0 \\<Longrightarrow>\n       take_bit LENGTH('a) a = take_bit LENGTH('a) 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       signed_take_bit (LENGTH('a) - Suc 0) a = 0 \\<Longrightarrow>\n       take_bit LENGTH('a) a = 0", "apply (metis Suc_pred len_gt_0 signed_take_bit_eq_iff_take_bit_eq signed_take_bit_of_0 take_bit_of_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_sdiv_0 = word_sdiv_div0"], ["", "lemma sdiv_word_min:\n    \"- (2 ^ (size a - 1)) \\<le> sint (a :: ('a::len) word) sdiv sint (b :: ('a::len) word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (size a - 1)) \\<le> sint a sdiv sint b", "using sdiv_int_range [where a=\"sint a\" and b=\"sint b\"]"], ["proof (prove)\nusing this:\n  sint a sdiv sint b \\<in> {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>}\n\ngoal (1 subgoal):\n 1. - (2 ^ (size a - 1)) \\<le> sint a sdiv sint b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- \\<bar>sint a\\<bar> \\<le> sint a sdiv sint b;\n     sint a sdiv sint b \\<le> \\<bar>sint a\\<bar>\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (size a - Suc 0)) \\<le> sint a sdiv sint b", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- \\<bar>sint a\\<bar> \\<le> sint a sdiv sint b;\n     sint a sdiv sint b \\<le> \\<bar>sint a\\<bar>; LENGTH('a) = 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (size a - Suc 0)) \\<le> sint a sdiv sint b\n 2. \\<And>nat.\n       \\<lbrakk>- \\<bar>sint a\\<bar> \\<le> sint a sdiv sint b;\n        sint a sdiv sint b \\<le> \\<bar>sint a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ (size a - Suc 0)) \\<le> sint a sdiv sint b", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>- \\<bar>sint a\\<bar> \\<le> sint a sdiv sint b;\n        sint a sdiv sint b \\<le> \\<bar>sint a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ (size a - Suc 0)) \\<le> sint a sdiv sint b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit (LENGTH('a) - Suc 0) a\\<bar>\n                \\<le> signed_take_bit (LENGTH('a) - Suc 0) a sdiv\n                      signed_take_bit (LENGTH('a) - Suc 0) b;\n        signed_take_bit (LENGTH('a) - Suc 0) a sdiv\n        signed_take_bit (LENGTH('a) - Suc 0) b\n        \\<le> \\<bar>signed_take_bit (LENGTH('a) - Suc 0) a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ (LENGTH('a) - Suc 0))\n                         \\<le> signed_take_bit (LENGTH('a) - Suc 0) a sdiv\n                               signed_take_bit (LENGTH('a) - Suc 0) b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit nat a\\<bar>\n                \\<le> signed_take_bit nat a sdiv signed_take_bit nat b;\n        signed_take_bit nat a sdiv signed_take_bit nat b\n        \\<le> \\<bar>signed_take_bit nat a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat)\n                         \\<le> signed_take_bit nat a sdiv\n                               signed_take_bit nat b", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit nat a\\<bar>\n                \\<le> signed_take_bit nat a sdiv signed_take_bit nat b;\n        signed_take_bit nat a sdiv signed_take_bit nat b\n        \\<le> \\<bar>signed_take_bit nat a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> ?y300 nat a b\n 2. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit nat a\\<bar>\n                \\<le> signed_take_bit nat a sdiv signed_take_bit nat b;\n        signed_take_bit nat a sdiv signed_take_bit nat b\n        \\<le> \\<bar>signed_take_bit nat a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ?y300 nat a b\n                         \\<le> signed_take_bit nat a sdiv\n                               signed_take_bit nat b", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit nat a\\<bar>\n                \\<le> signed_take_bit nat a sdiv signed_take_bit nat b;\n        signed_take_bit nat a sdiv signed_take_bit nat b\n        \\<le> \\<bar>signed_take_bit nat a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ?y300 nat a b\n                         \\<le> signed_take_bit nat a sdiv\n                               signed_take_bit nat b\n 2. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit nat a\\<bar>\n                \\<le> signed_take_bit nat a sdiv signed_take_bit nat b;\n        signed_take_bit nat a sdiv signed_take_bit nat b\n        \\<le> \\<bar>signed_take_bit nat a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> ?y300 nat a b", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit nat a\\<bar>\n                \\<le> signed_take_bit nat a sdiv signed_take_bit nat b;\n        signed_take_bit nat a sdiv signed_take_bit nat b\n        \\<le> \\<bar>signed_take_bit nat a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat)\n                         \\<le> - \\<bar>signed_take_bit nat a\\<bar>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat a b.\n       \\<lbrakk>- \\<bar>signed_take_bit nat a\\<bar>\n                \\<le> signed_take_bit nat a sdiv signed_take_bit nat b;\n        signed_take_bit nat a sdiv signed_take_bit nat b\n        \\<le> \\<bar>signed_take_bit nat a\\<bar>;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<bar>signed_take_bit nat a\\<bar> \\<le> 2 ^ nat", "apply (metis abs_le_iff add.inverse_inverse le_cases le_minus_iff not_le signed_take_bit_int_eq_self_iff signed_take_bit_minus)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_sdiv_numerals_lhs = sdiv_word_def[where v=\"numeral x\" for x]\n    sdiv_word_def[where v=0] sdiv_word_def[where v=1]"], ["", "lemmas word_sdiv_numerals = word_sdiv_numerals_lhs[where w=\"numeral y\" for y]\n    word_sdiv_numerals_lhs[where w=0] word_sdiv_numerals_lhs[where w=1]"], ["", "lemma smod_word_mod_0 [simp]:\n  \"x smod (0 :: ('a::len) word) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x smod 0 = x", "by (clarsimp simp: smod_word_def)"], ["", "lemma smod_word_0_mod [simp]:\n  \"0 smod (x :: ('a::len) word) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 smod x = 0", "by (clarsimp simp: smod_word_def)"], ["", "lemma smod_word_max:\n  \"sint (a::'a word) smod sint (b::'a word) < 2 ^ (LENGTH('a::len) - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a smod sint b < 2 ^ (LENGTH('a) - Suc 0)", "apply (cases \\<open>sint b = 0\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sint b = 0 \\<Longrightarrow>\n    sint a smod sint b < 2 ^ (LENGTH('a) - Suc 0)\n 2. sint b \\<noteq> 0 \\<Longrightarrow>\n    sint a smod sint b < 2 ^ (LENGTH('a) - Suc 0)", "apply (simp_all add: sint_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sint b \\<noteq> 0 \\<Longrightarrow>\n    sint a smod sint b < 2 ^ (LENGTH('a) - Suc 0)", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = 0\\<rbrakk>\n    \\<Longrightarrow> sint a smod sint b < 2 ^ (LENGTH('a) - Suc 0)\n 2. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> sint a smod sint b < 2 ^ (LENGTH('a) - Suc 0)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> sint a smod sint b < 2 ^ nat", "using smod_int_range [where a=\"sint a\" and b=\"sint b\"]"], ["proof (prove)\nusing this:\n  sint b \\<noteq> 0 \\<Longrightarrow>\n  sint a smod sint b\n  \\<in> {- \\<bar>sint b\\<bar> + 1..\\<bar>sint b\\<bar> - 1}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> sint a smod sint b < 2 ^ nat", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> sint a smod sint b < 2 ^ nat", "apply (rule less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> sint a smod sint b < ?y5 nat\n 2. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> ?y5 nat \\<le> 2 ^ nat", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> \\<bar>sint b\\<bar> \\<le> 2 ^ nat", "apply (auto simp add: abs_le_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> sint b \\<le> 2 ^ nat\n 2. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - sint b \\<le> 2 ^ nat", "apply (metis diff_Suc_1 le_cases linorder_not_le sint_lt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>sint b \\<noteq> 0; LENGTH('a) = Suc nat;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - sint b \\<le> 2 ^ nat", "apply (metis add.inverse_inverse diff_Suc_1 linorder_not_less neg_less_iff_less sint_ge)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma smod_word_min:\n  \"- (2 ^ (LENGTH('a::len) - Suc 0)) \\<le> sint (a::'a word) smod sint (b::'a word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint a smod sint b", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) = 0 \\<Longrightarrow>\n    - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint a smod sint b\n 2. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint a smod sint b", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       - (2 ^ nat) \\<le> sint a smod sint b", "apply (cases \\<open>sint b = 0\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b = 0\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> sint a smod sint b\n 2. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> sint a smod sint b", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b = 0\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> sint a\n 2. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> sint a smod sint b", "apply (metis diff_Suc_1 sint_ge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> sint a smod sint b", "using smod_int_range [where a=\"sint a\" and b=\"sint b\"]"], ["proof (prove)\nusing this:\n  sint b \\<noteq> 0 \\<Longrightarrow>\n  sint a smod sint b\n  \\<in> {- \\<bar>sint b\\<bar> + 1..\\<bar>sint b\\<bar> - 1}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> sint a smod sint b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> sint a smod sint b", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> ?y8 nat\n 2. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> ?y8 nat \\<le> sint a smod sint b", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> ?y8 nat \\<le> sint a smod sint b\n 2. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> ?y8 nat", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 - \\<bar>sint b\\<bar> \\<le> sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ nat) \\<le> 1 - \\<bar>sint b\\<bar>", "apply (auto simp add: algebra_simps abs_le_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 \\<le> \\<bar>sint b\\<bar> + sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> sint b \\<le> 1 + 2 ^ nat\n 2. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 \\<le> \\<bar>sint b\\<bar> + sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - sint b \\<le> 1 + 2 ^ nat", "apply (metis abs_zero add.left_neutral add_mono_thms_linordered_semiring(1) diff_Suc_1 le_cases linorder_not_less sint_lt zabs_less_one_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; sint b \\<noteq> 0;\n        1 \\<le> \\<bar>sint b\\<bar> + sint a smod sint b;\n        sint a smod sint b < \\<bar>sint b\\<bar>\\<rbrakk>\n       \\<Longrightarrow> - sint b \\<le> 1 + 2 ^ nat", "apply (metis abs_zero add.inverse_inverse add.left_neutral add_mono_thms_linordered_semiring(1) diff_Suc_1 le_cases le_minus_iff linorder_not_less sint_ge zabs_less_one_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma smod_word_alt_def:\n  \"(a :: ('a::len) word) smod b = a - (a sdiv b) * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a smod b = a - a sdiv b * b", "apply (cases \\<open>a \\<noteq> - (2 ^ (LENGTH('a) - 1)) \\<or> b \\<noteq> - 1\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> - (2 ^ (LENGTH('a) - 1)) \\<or>\n    b \\<noteq> - 1 \\<Longrightarrow>\n    a smod b = a - a sdiv b * b\n 2. \\<not> (a \\<noteq> - (2 ^ (LENGTH('a) - 1)) \\<or>\n            b \\<noteq> - 1) \\<Longrightarrow>\n    a smod b = a - a sdiv b * b", "apply (clarsimp simp: smod_word_def sdiv_word_def signed_modulo_int_def\n     simp flip: wi_hom_sub wi_hom_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (a \\<noteq> - (2 ^ (LENGTH('a) - 1)) \\<or>\n            b \\<noteq> - 1) \\<Longrightarrow>\n    a smod b = a - a sdiv b * b", "apply (clarsimp simp: smod_word_def signed_modulo_int_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_smod_numerals_lhs = smod_word_def[where v=\"numeral x\" for x]\n    smod_word_def[where v=0] smod_word_def[where v=1]"], ["", "lemmas word_smod_numerals = word_smod_numerals_lhs[where w=\"numeral y\" for y]\n    word_smod_numerals_lhs[where w=0] word_smod_numerals_lhs[where w=1]"], ["", "end"]]}