{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Typedef_Morphisms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma tdD1: \"type_definition Rep Abs A \\<Longrightarrow> \\<forall>x. Rep x \\<in> A\"\n  and tdD2: \"type_definition Rep Abs A \\<Longrightarrow> \\<forall>x. Abs (Rep x) = x\"\n  and tdD3: \"type_definition Rep Abs A \\<Longrightarrow> \\<forall>y. y \\<in> A \\<longrightarrow> Rep (Abs y) = y\"", "lemma td_nat_int: \"type_definition int nat (Collect ((\\<le>) 0))\"", "lemma Abs_eqD: \"Abs x = Abs y \\<Longrightarrow> x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x = y\"", "lemma Abs_inverse': \"r \\<in> A \\<Longrightarrow> Abs r = a \\<Longrightarrow> Rep a = r\"", "lemma Rep_comp_inverse: \"Rep \\<circ> f = g \\<Longrightarrow> Abs \\<circ> g = f\"", "lemma Rep_eqD [elim!]: \"Rep x = Rep y \\<Longrightarrow> x = y\"", "lemma Rep_inverse': \"Rep a = r \\<Longrightarrow> Abs r = a\"", "lemma comp_Abs_inverse: \"f \\<circ> Abs = g \\<Longrightarrow> g \\<circ> Rep = f\"", "lemma set_Rep: \"A = range Rep\"", "lemma set_Rep_Abs: \"A = range (Rep \\<circ> Abs)\"", "lemma Abs_inj_on: \"inj_on Abs A\"", "lemma image: \"Abs ` A = UNIV\"", "lemmas td_thm = type_definition_axioms", "lemma fns1: \"Rep \\<circ> fa = fr \\<circ> Rep \\<or> fa \\<circ> Abs = Abs \\<circ> fr \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep = fa\"", "lemmas fns1a = disjI1 [THEN fns1]", "lemmas fns1b = disjI2 [THEN fns1]", "lemma fns4: \"Rep \\<circ> fa \\<circ> Abs = fr \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep \\<and> fa \\<circ> Abs = Abs \\<circ> fr\"", "lemma td_conds:\n  \"norm \\<circ> norm = norm \\<Longrightarrow>\n    fr \\<circ> norm = norm \\<circ> fr \\<longleftrightarrow> norm \\<circ> fr \\<circ> norm = fr \\<circ> norm \\<and> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr\"", "lemma fn_comm_power: \"fa \\<circ> tr = tr \\<circ> fr \\<Longrightarrow> fa ^^ n \\<circ> tr = tr \\<circ> fr ^^ n\"", "lemmas fn_comm_power' =\n  ext [THEN fn_comm_power, THEN fun_cong, unfolded o_def]", "lemma Abs_norm [simp]: \"Abs (norm x) = Abs x\"", "lemma td_th: \"g \\<circ> Abs = f \\<Longrightarrow> f (Rep x) = g x\"", "lemma eq_norm': \"Rep \\<circ> Abs = norm\"", "lemma norm_Rep [simp]: \"norm (Rep x) = Rep x\"", "lemmas td = td_thm", "lemma set_iff_norm: \"w \\<in> A \\<longleftrightarrow> w = norm w\"", "lemma inverse_norm: \"Abs n = w \\<longleftrightarrow> Rep w = norm n\"", "lemma norm_eq_iff: \"norm x = norm y \\<longleftrightarrow> Abs x = Abs y\"", "lemma norm_comps:\n  \"Abs \\<circ> norm = Abs\"\n  \"norm \\<circ> Rep = Rep\"\n  \"norm \\<circ> norm = norm\"", "lemmas norm_norm [simp] = norm_comps", "lemma fns5: \"Rep \\<circ> fa \\<circ> Abs = fr \\<Longrightarrow> fr \\<circ> norm = fr \\<and> norm \\<circ> fr = fr\"", "lemma fns2: \"Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = fr \\<circ> norm \\<longleftrightarrow> Rep \\<circ> fa = fr \\<circ> Rep\"", "lemma fns3: \"Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr \\<longleftrightarrow> fa \\<circ> Abs = Abs \\<circ> fr\"", "lemma fns: \"fr \\<circ> norm = norm \\<circ> fr \\<Longrightarrow> fa \\<circ> Abs = Abs \\<circ> fr \\<longleftrightarrow> Rep \\<circ> fa = fr \\<circ> Rep\"", "lemma range_norm: \"range (Rep \\<circ> Abs) = A\"", "lemmas td_ext_def' =\n  td_ext_def [unfolded type_definition_def td_ext_axioms_def]", "lemma uints_num: \"uints n = {i. 0 \\<le> i \\<and> i < 2 ^ n}\"", "lemma sints_num: \"sints n = {i. - (2 ^ (n - 1)) \\<le> i \\<and> i < 2 ^ (n - 1)}\"", "lemma uints_unats: \"uints n = int ` unats n\"", "lemma unats_uints: \"unats n = nat ` uints n\"", "lemma td_ext_uint:\n  \"td_ext (uint :: 'a word \\<Rightarrow> int) word_of_int (uints (LENGTH('a::len)))\n    (\\<lambda>w::int. w mod 2 ^ LENGTH('a))\"", "lemmas td_uint = word_uint.td_thm", "lemmas int_word_uint = word_uint.eq_norm", "lemma td_ext_ubin:\n  \"td_ext (uint :: 'a word \\<Rightarrow> int) word_of_int (uints (LENGTH('a::len)))\n    (take_bit (LENGTH('a)))\"", "lemma td_ext_unat [OF refl]:\n  \"n = LENGTH('a::len) \\<Longrightarrow>\n    td_ext (unat :: 'a word \\<Rightarrow> nat) of_nat (unats n) (\\<lambda>i. i mod 2 ^ n)\"", "lemmas unat_of_nat = td_ext_unat [THEN td_ext.eq_norm]", "lemmas td_unat = word_unat.td_thm", "lemma unat_le: \"y \\<le> unat z \\<Longrightarrow> y \\<in> unats (LENGTH('a))\"\n  for z :: \"'a::len word\"", "lemma td_ext_sbin:\n  \"td_ext (sint :: 'a word \\<Rightarrow> int) word_of_int (sints (LENGTH('a::len)))\n    (signed_take_bit (LENGTH('a) - 1))\"", "lemma td_ext_sint:\n  \"td_ext (sint :: 'a word \\<Rightarrow> int) word_of_int (sints (LENGTH('a::len)))\n     (\\<lambda>w. (w + 2 ^ (LENGTH('a) - 1)) mod 2 ^ LENGTH('a) -\n         2 ^ (LENGTH('a) - 1))\"", "lemmas int_word_sint = td_ext_sint [THEN td_ext.eq_norm]", "lemmas td_sint = word_sint.td", "lemma uints_mod: \"uints n = range (\\<lambda>w. w mod 2 ^ n)\"", "lemmas bintr_num =\n  word_ubin.norm_eq_iff [of \"numeral a\" \"numeral b\", symmetric, folded word_numeral_alt] for a b", "lemmas sbintr_num =\n  word_sbin.norm_eq_iff [of \"numeral a\" \"numeral b\", symmetric, folded word_numeral_alt] for a b", "lemmas uint_div_alt = word_div_def [THEN trans [OF uint_cong int_word_uint]]", "lemmas uint_mod_alt = word_mod_def [THEN trans [OF uint_cong int_word_uint]]", "lemmas td_nth = test_bit.td_thm", "lemma sints_subset:\n  \"m \\<le> n \\<Longrightarrow> sints m \\<subseteq> sints n\""], "translations": [["", "lemma tdD1: \"type_definition Rep Abs A \\<Longrightarrow> \\<forall>x. Rep x \\<in> A\"\n  and tdD2: \"type_definition Rep Abs A \\<Longrightarrow> \\<forall>x. Abs (Rep x) = x\"\n  and tdD3: \"type_definition Rep Abs A \\<Longrightarrow> \\<forall>y. y \\<in> A \\<longrightarrow> Rep (Abs y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (type_definition Rep Abs A \\<Longrightarrow>\n     \\<forall>x. Rep x \\<in> A) &&&\n    (type_definition Rep Abs A \\<Longrightarrow>\n     \\<forall>x. Abs (Rep x) = x) &&&\n    (type_definition Rep Abs A \\<Longrightarrow>\n     \\<forall>y. y \\<in> A \\<longrightarrow> Rep (Abs y) = y)", "by (auto simp: type_definition_def)"], ["", "lemma td_nat_int: \"type_definition int nat (Collect ((\\<le>) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition int nat (Collect ((\\<le>) 0))", "unfolding type_definition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. int x \\<in> Collect ((\\<le>) 0)) \\<and>\n    (\\<forall>x. nat (int x) = x) \\<and>\n    (\\<forall>y.\n        y \\<in> Collect ((\\<le>) 0) \\<longrightarrow> int (nat y) = y)", "by auto"], ["", "context type_definition\nbegin"], ["", "declare Rep [iff] Rep_inverse [simp] Rep_inject [simp]"], ["", "lemma Abs_eqD: \"Abs x = Abs y \\<Longrightarrow> x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Abs x = Abs y; x \\<in> A; y \\<in> A\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (simp add: Abs_inject)"], ["", "lemma Abs_inverse': \"r \\<in> A \\<Longrightarrow> Abs r = a \\<Longrightarrow> Rep a = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> A; Abs r = a\\<rbrakk> \\<Longrightarrow> Rep a = r", "by (safe elim!: Abs_inverse)"], ["", "lemma Rep_comp_inverse: \"Rep \\<circ> f = g \\<Longrightarrow> Abs \\<circ> g = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep \\<circ> f = g \\<Longrightarrow> Abs \\<circ> g = f", "using Rep_inverse"], ["proof (prove)\nusing this:\n  Abs (Rep ?x) = ?x\n\ngoal (1 subgoal):\n 1. Rep \\<circ> f = g \\<Longrightarrow> Abs \\<circ> g = f", "by auto"], ["", "lemma Rep_eqD [elim!]: \"Rep x = Rep y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep x = Rep y \\<Longrightarrow> x = y", "by simp"], ["", "lemma Rep_inverse': \"Rep a = r \\<Longrightarrow> Abs r = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep a = r \\<Longrightarrow> Abs r = a", "by (safe intro!: Rep_inverse)"], ["", "lemma comp_Abs_inverse: \"f \\<circ> Abs = g \\<Longrightarrow> g \\<circ> Rep = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> Abs = g \\<Longrightarrow> g \\<circ> Rep = f", "using Rep_inverse"], ["proof (prove)\nusing this:\n  Abs (Rep ?x) = ?x\n\ngoal (1 subgoal):\n 1. f \\<circ> Abs = g \\<Longrightarrow> g \\<circ> Rep = f", "by auto"], ["", "lemma set_Rep: \"A = range Rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = range Rep", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> A) = (x \\<in> range Rep)", "show \"x \\<in> A \\<longleftrightarrow> x \\<in> range Rep\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> A) = (x \\<in> range Rep)", "by (auto dest: Abs_inverse [of x, symmetric])"], ["proof (state)\nthis:\n  (?x \\<in> A) = (?x \\<in> range Rep)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_Rep_Abs: \"A = range (Rep \\<circ> Abs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = range (Rep \\<circ> Abs)", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> A) = (x \\<in> range (Rep \\<circ> Abs))", "show \"x \\<in> A \\<longleftrightarrow> x \\<in> range (Rep \\<circ> Abs)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> A) = (x \\<in> range (Rep \\<circ> Abs))", "by (auto dest: Abs_inverse [of x, symmetric])"], ["proof (state)\nthis:\n  (?x \\<in> A) = (?x \\<in> range (Rep \\<circ> Abs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Abs_inj_on: \"inj_on Abs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Abs A", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. Abs x = Abs y \\<longrightarrow> x = y", "by (auto dest: Abs_inject [THEN iffD1])"], ["", "lemma image: \"Abs ` A = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs ` A = UNIV", "by (fact Abs_image)"], ["", "lemmas td_thm = type_definition_axioms"], ["", "lemma fns1: \"Rep \\<circ> fa = fr \\<circ> Rep \\<or> fa \\<circ> Abs = Abs \\<circ> fr \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep = fa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep \\<circ> fa = fr \\<circ> Rep \\<or>\n    fa \\<circ> Abs = Abs \\<circ> fr \\<Longrightarrow>\n    Abs \\<circ> fr \\<circ> Rep = fa", "by (auto dest: Rep_comp_inverse elim: comp_Abs_inverse simp: o_assoc)"], ["", "lemmas fns1a = disjI1 [THEN fns1]"], ["", "lemmas fns1b = disjI2 [THEN fns1]"], ["", "lemma fns4: \"Rep \\<circ> fa \\<circ> Abs = fr \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep \\<and> fa \\<circ> Abs = Abs \\<circ> fr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep \\<circ> fa \\<circ> Abs = fr \\<Longrightarrow>\n    Rep \\<circ> fa = fr \\<circ> Rep \\<and> fa \\<circ> Abs = Abs \\<circ> fr", "by auto"], ["", "end"], ["", "interpretation nat_int: type_definition int nat \"Collect ((\\<le>) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition int nat (Collect ((\\<le>) 0))", "by (rule td_nat_int)"], ["", "declare\n  nat_int.Rep_cases [cases del]\n  nat_int.Abs_cases [cases del]\n  nat_int.Rep_induct [induct del]\n  nat_int.Abs_induct [induct del]"], ["", "subsection \"Extended form of type definition predicate\""], ["", "lemma td_conds:\n  \"norm \\<circ> norm = norm \\<Longrightarrow>\n    fr \\<circ> norm = norm \\<circ> fr \\<longleftrightarrow> norm \\<circ> fr \\<circ> norm = fr \\<circ> norm \\<and> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<circ> norm = norm \\<Longrightarrow>\n    (fr \\<circ> norm = norm \\<circ> fr) =\n    (norm \\<circ> fr \\<circ> norm = fr \\<circ> norm \\<and>\n     norm \\<circ> fr \\<circ> norm = norm \\<circ> fr)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>norm \\<circ> norm = norm;\n     fr \\<circ> norm = norm \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = fr \\<circ> norm\n 2. \\<lbrakk>norm \\<circ> norm = norm;\n     fr \\<circ> norm = norm \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr\n 3. \\<lbrakk>norm \\<circ> norm = norm;\n     norm \\<circ> fr \\<circ> norm = fr \\<circ> norm;\n     norm \\<circ> fr \\<circ> norm = norm \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> fr \\<circ> norm = norm \\<circ> fr", "apply (simp_all add: comp_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>norm \\<circ> norm = norm;\n     fr \\<circ> norm = norm \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> (norm \\<circ> fr) = norm \\<circ> fr\n 2. \\<lbrakk>norm \\<circ> norm = norm;\n     fr \\<circ> norm = norm \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> (norm \\<circ> fr) = norm \\<circ> fr", "apply (simp_all add: o_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fn_comm_power: \"fa \\<circ> tr = tr \\<circ> fr \\<Longrightarrow> fa ^^ n \\<circ> tr = tr \\<circ> fr ^^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fa \\<circ> tr = tr \\<circ> fr \\<Longrightarrow>\n    fa ^^ n \\<circ> tr = tr \\<circ> fr ^^ n", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fa \\<circ> tr = tr \\<circ> fr \\<Longrightarrow>\n       (fa ^^ n \\<circ> tr) x = (tr \\<circ> fr ^^ n) x", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       fa \\<circ> tr = tr \\<circ> fr \\<Longrightarrow>\n       (fa ^^ 0 \\<circ> tr) x = (tr \\<circ> fr ^^ 0) x\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   fa \\<circ> tr = tr \\<circ> fr \\<Longrightarrow>\n                   (fa ^^ n \\<circ> tr) x = (tr \\<circ> fr ^^ n) x;\n        fa \\<circ> tr = tr \\<circ> fr\\<rbrakk>\n       \\<Longrightarrow> (fa ^^ Suc n \\<circ> tr) x =\n                         (tr \\<circ> fr ^^ Suc n) x", "apply (auto dest: fun_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas fn_comm_power' =\n  ext [THEN fn_comm_power, THEN fun_cong, unfolded o_def]"], ["", "locale td_ext = type_definition +\n  fixes norm\n  assumes eq_norm: \"\\<And>x. Rep (Abs x) = norm x\"\nbegin"], ["", "lemma Abs_norm [simp]: \"Abs (norm x) = Abs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (norm x) = Abs x", "using eq_norm [of x]"], ["proof (prove)\nusing this:\n  Rep (Abs x) = norm x\n\ngoal (1 subgoal):\n 1. Abs (norm x) = Abs x", "by (auto elim: Rep_inverse')"], ["", "lemma td_th: \"g \\<circ> Abs = f \\<Longrightarrow> f (Rep x) = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ> Abs = f \\<Longrightarrow> f (Rep x) = g x", "by (drule comp_Abs_inverse [symmetric]) simp"], ["", "lemma eq_norm': \"Rep \\<circ> Abs = norm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep \\<circ> Abs = norm", "by (auto simp: eq_norm)"], ["", "lemma norm_Rep [simp]: \"norm (Rep x) = Rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (Rep x) = Rep x", "by (auto simp: eq_norm' intro: td_th)"], ["", "lemmas td = td_thm"], ["", "lemma set_iff_norm: \"w \\<in> A \\<longleftrightarrow> w = norm w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> A) = (w = norm w)", "by (auto simp: set_Rep_Abs eq_norm' eq_norm [symmetric])"], ["", "lemma inverse_norm: \"Abs n = w \\<longleftrightarrow> Rep w = norm n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs n = w) = (Rep w = norm n)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs n = w \\<Longrightarrow> Rep w = norm n\n 2. Rep w = norm n \\<Longrightarrow> Abs n = w", "apply (clarsimp simp add: eq_norm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep w = norm n \\<Longrightarrow> Abs n = w", "apply (simp add: eq_norm' [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma norm_eq_iff: \"norm x = norm y \\<longleftrightarrow> Abs x = Abs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x = norm y) = (Abs x = Abs y)", "by (simp add: eq_norm' [symmetric])"], ["", "lemma norm_comps:\n  \"Abs \\<circ> norm = Abs\"\n  \"norm \\<circ> Rep = Rep\"\n  \"norm \\<circ> norm = norm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs \\<circ> norm = Abs &&&\n    norm \\<circ> Rep = Rep &&& norm \\<circ> norm = norm", "by (auto simp: eq_norm' [symmetric] o_def)"], ["", "lemmas norm_norm [simp] = norm_comps"], ["", "lemma fns5: \"Rep \\<circ> fa \\<circ> Abs = fr \\<Longrightarrow> fr \\<circ> norm = fr \\<and> norm \\<circ> fr = fr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep \\<circ> fa \\<circ> Abs = fr \\<Longrightarrow>\n    fr \\<circ> norm = fr \\<and> norm \\<circ> fr = fr", "by (fold eq_norm') auto"], ["", "text \\<open>\n  following give conditions for converses to \\<open>td_fns1\\<close>\n  \\<^item> the condition \\<open>norm \\<circ> fr \\<circ> norm = fr \\<circ> norm\\<close> says that\n    \\<open>fr\\<close> takes normalised arguments to normalised results\n  \\<^item> \\<open>norm \\<circ> fr \\<circ> norm = norm \\<circ> fr\\<close> says that \\<open>fr\\<close>\n    takes norm-equivalent arguments to norm-equivalent results\n  \\<^item> \\<open>fr \\<circ> norm = fr\\<close> says that \\<open>fr\\<close>\n    takes norm-equivalent arguments to the same result\n  \\<^item> \\<open>norm \\<circ> fr = fr\\<close> says that \\<open>fr\\<close> takes any argument to a normalised result\n\\<close>"], ["", "lemma fns2: \"Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = fr \\<circ> norm \\<longleftrightarrow> Rep \\<circ> fa = fr \\<circ> Rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow>\n    (norm \\<circ> fr \\<circ> norm = fr \\<circ> norm) =\n    (Rep \\<circ> fa = fr \\<circ> Rep)", "apply (fold eq_norm')"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow>\n    (Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     fr \\<circ> (Rep \\<circ> Abs)) =\n    (Rep \\<circ> fa = fr \\<circ> Rep)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     fr \\<circ> (Rep \\<circ> Abs)\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> (Abs \\<circ> fr \\<circ> Rep) =\n                      fr \\<circ> Rep\n 2. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> (Abs \\<circ> fr \\<circ> Rep) = fr \\<circ> Rep\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n                      fr \\<circ> (Rep \\<circ> Abs)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> (Abs \\<circ> fr \\<circ> Rep) = fr \\<circ> Rep\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n                      fr \\<circ> (Rep \\<circ> Abs)\n 2. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     fr \\<circ> (Rep \\<circ> Abs)\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> (Abs \\<circ> fr \\<circ> Rep) =\n                      fr \\<circ> Rep", "apply (simp add: o_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     fr \\<circ> (Rep \\<circ> Abs)\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> (Abs \\<circ> fr \\<circ> Rep) =\n                      fr \\<circ> Rep", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n        Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n        fr \\<circ> (Rep \\<circ> Abs)\\<rbrakk>\n       \\<Longrightarrow> (Rep \\<circ> (Abs \\<circ> fr \\<circ> Rep)) x =\n                         (fr \\<circ> Rep) x", "apply (drule_tac x=\"Rep x\" in fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n        (Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs)) (Rep x) =\n        (fr \\<circ> (Rep \\<circ> Abs)) (Rep x)\\<rbrakk>\n       \\<Longrightarrow> (Rep \\<circ> (Abs \\<circ> fr \\<circ> Rep)) x =\n                         (fr \\<circ> Rep) x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fns3: \"Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr \\<longleftrightarrow> fa \\<circ> Abs = Abs \\<circ> fr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow>\n    (norm \\<circ> fr \\<circ> norm = norm \\<circ> fr) =\n    (fa \\<circ> Abs = Abs \\<circ> fr)", "apply (fold eq_norm')"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs \\<circ> fr \\<circ> Rep = fa \\<Longrightarrow>\n    (Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     Rep \\<circ> Abs \\<circ> fr) =\n    (fa \\<circ> Abs = Abs \\<circ> fr)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     Rep \\<circ> Abs \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep \\<circ> Abs =\n                      Abs \\<circ> fr\n 2. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep \\<circ> Abs = Abs \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n                      Rep \\<circ> Abs \\<circ> fr", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep \\<circ> Abs = Abs \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n                      Rep \\<circ> Abs \\<circ> fr\n 2. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     Rep \\<circ> Abs \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep \\<circ> Abs =\n                      Abs \\<circ> fr", "apply (simp add: comp_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n     Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n     Rep \\<circ> Abs \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep \\<circ> Abs =\n                      Abs \\<circ> fr", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n        Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs) =\n        Rep \\<circ> Abs \\<circ> fr\\<rbrakk>\n       \\<Longrightarrow> (Abs \\<circ> fr \\<circ> Rep \\<circ> Abs) x =\n                         (Abs \\<circ> fr) x", "apply (drule_tac f=\"a \\<circ> b\" for a b in fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fa = Abs \\<circ> fr \\<circ> Rep;\n        (Rep \\<circ> Abs \\<circ> fr \\<circ> (Rep \\<circ> Abs)) (?x7 x) =\n        (Rep \\<circ> Abs \\<circ> fr) (?x7 x)\\<rbrakk>\n       \\<Longrightarrow> (Abs \\<circ> fr \\<circ> Rep \\<circ> Abs) x =\n                         (Abs \\<circ> fr) x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fns: \"fr \\<circ> norm = norm \\<circ> fr \\<Longrightarrow> fa \\<circ> Abs = Abs \\<circ> fr \\<longleftrightarrow> Rep \\<circ> fa = fr \\<circ> Rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fr \\<circ> norm = norm \\<circ> fr \\<Longrightarrow>\n    (fa \\<circ> Abs = Abs \\<circ> fr) = (Rep \\<circ> fa = fr \\<circ> Rep)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep\\<rbrakk>\n    \\<Longrightarrow> fa \\<circ> Abs = Abs \\<circ> fr", "apply (frule fns1b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep\\<rbrakk>\n    \\<Longrightarrow> fa \\<circ> Abs = Abs \\<circ> fr", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep\\<rbrakk>\n    \\<Longrightarrow> fa \\<circ> Abs = Abs \\<circ> fr\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep", "apply (frule fns1a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> fa \\<circ> Abs = Abs \\<circ> fr\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep", "apply (rule fns3 [THEN iffD1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep = fa\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr\n 3. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Rep \\<circ> fa = fr \\<circ> Rep\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep = fa\n 3. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr", "apply (rule fns2 [THEN iffD1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep = fa\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = fr \\<circ> norm\n 3. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> Abs \\<circ> fr \\<circ> Rep = fa\n 4. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> fr \\<circ> Rep = fa\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> fr \\<circ> norm = norm \\<circ> fr", "apply (simp_all add: comp_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     fa \\<circ> Abs = Abs \\<circ> fr;\n     Abs \\<circ> (fr \\<circ> Rep) = fa\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> (norm \\<circ> fr) = norm \\<circ> fr\n 2. \\<lbrakk>fr \\<circ> norm = norm \\<circ> fr;\n     Rep \\<circ> fa = fr \\<circ> Rep;\n     Abs \\<circ> (fr \\<circ> Rep) = fa\\<rbrakk>\n    \\<Longrightarrow> norm \\<circ> (norm \\<circ> fr) = norm \\<circ> fr", "apply (simp_all add: o_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_norm: \"range (Rep \\<circ> Abs) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (Rep \\<circ> Abs) = A", "by (simp add: set_Rep_Abs)"], ["", "end"], ["", "lemmas td_ext_def' =\n  td_ext_def [unfolded type_definition_def td_ext_axioms_def]"], ["", "subsection \\<open>Type-definition locale instantiations\\<close>"], ["", "definition uints :: \"nat \\<Rightarrow> int set\"\n  \\<comment> \\<open>the sets of integers representing the words\\<close>\n  where \"uints n = range (take_bit n)\""], ["", "definition sints :: \"nat \\<Rightarrow> int set\"\n  where \"sints n = range (signed_take_bit (n - 1))\""], ["", "lemma uints_num: \"uints n = {i. 0 \\<le> i \\<and> i < 2 ^ n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uints n = {i. 0 \\<le> i \\<and> i < 2 ^ n}", "by (simp add: uints_def range_bintrunc)"], ["", "lemma sints_num: \"sints n = {i. - (2 ^ (n - 1)) \\<le> i \\<and> i < 2 ^ (n - 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sints n = {i. - (2 ^ (n - 1)) \\<le> i \\<and> i < 2 ^ (n - 1)}", "by (simp add: sints_def range_sbintrunc)"], ["", "definition unats :: \"nat \\<Rightarrow> nat set\"\n  where \"unats n = {i. i < 2 ^ n}\"\n\n\\<comment> \\<open>naturals\\<close>"], ["", "lemma uints_unats: \"uints n = int ` unats n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uints n = int ` unats n", "apply (unfold unats_def uints_num)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. 0 \\<le> i \\<and> i < 2 ^ n} = int ` {i. i < 2 ^ n}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> int ` {i. i < 2 ^ n}\n 2. \\<And>x xa. xa < 2 ^ n \\<Longrightarrow> 0 \\<le> int xa\n 3. \\<And>x xa. xa < 2 ^ n \\<Longrightarrow> int xa < 2 ^ n", "apply (rule_tac image_eqI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> x = int (?x10 x)\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> ?x10 x \\<in> {i. i < 2 ^ n}\n 3. \\<And>x xa. xa < 2 ^ n \\<Longrightarrow> 0 \\<le> int xa\n 4. \\<And>x xa. xa < 2 ^ n \\<Longrightarrow> int xa < 2 ^ n", "apply (erule_tac nat_0_le [symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> nat x \\<in> {i. i < 2 ^ n}\n 2. \\<And>x xa. xa < 2 ^ n \\<Longrightarrow> 0 \\<le> int xa\n 3. \\<And>x xa. xa < 2 ^ n \\<Longrightarrow> int xa < 2 ^ n", "by auto"], ["", "lemma unats_uints: \"unats n = nat ` uints n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unats n = nat ` uints n", "by (auto simp: uints_unats image_iff)"], ["", "lemma td_ext_uint:\n  \"td_ext (uint :: 'a word \\<Rightarrow> int) word_of_int (uints (LENGTH('a::len)))\n    (\\<lambda>w::int. w mod 2 ^ LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext uint word_of_int (uints LENGTH('a))\n     (\\<lambda>w. w mod 2 ^ LENGTH('a))", "apply (unfold td_ext_def')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x. uint x \\<in> uints LENGTH('a)) \\<and>\n     (\\<forall>x. word_of_int (uint x) = x) \\<and>\n     (\\<forall>y.\n         y \\<in> uints LENGTH('a) \\<longrightarrow>\n         uint (word_of_int y) = y)) \\<and>\n    (\\<forall>x. uint (word_of_int x) = x mod 2 ^ LENGTH('a))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x. take_bit LENGTH('a) x \\<in> uints LENGTH('a)) \\<and>\n     (\\<forall>x.\n         take_bit LENGTH('a) (take_bit LENGTH('a) x) =\n         take_bit LENGTH('a) x) \\<and>\n     (\\<forall>y.\n         y \\<in> uints LENGTH('a) \\<longrightarrow>\n         take_bit LENGTH('a) y = y)) \\<and>\n    (\\<forall>x. take_bit LENGTH('a) x = x mod 2 ^ LENGTH('a))", "apply (simp add: uints_num take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation word_uint:\n  td_ext\n    \"uint::'a::len word \\<Rightarrow> int\"\n    word_of_int\n    \"uints (LENGTH('a::len))\"\n    \"\\<lambda>w. w mod 2 ^ LENGTH('a::len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext uint word_of_int (uints LENGTH('a))\n     (\\<lambda>w. w mod 2 ^ LENGTH('a))", "by (fact td_ext_uint)"], ["", "lemmas td_uint = word_uint.td_thm"], ["", "lemmas int_word_uint = word_uint.eq_norm"], ["", "lemma td_ext_ubin:\n  \"td_ext (uint :: 'a word \\<Rightarrow> int) word_of_int (uints (LENGTH('a::len)))\n    (take_bit (LENGTH('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext uint word_of_int (uints LENGTH('a)) (take_bit LENGTH('a))", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. uint (word_of_int x) = take_bit LENGTH('a) x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. take_bit LENGTH('a) x = take_bit LENGTH('a) x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation word_ubin:\n  td_ext\n    \"uint::'a::len word \\<Rightarrow> int\"\n    word_of_int\n    \"uints (LENGTH('a::len))\"\n    \"take_bit (LENGTH('a::len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext uint word_of_int (uints LENGTH('a)) (take_bit LENGTH('a))", "by (fact td_ext_ubin)"], ["", "lemma td_ext_unat [OF refl]:\n  \"n = LENGTH('a::len) \\<Longrightarrow>\n    td_ext (unat :: 'a word \\<Rightarrow> nat) of_nat (unats n) (\\<lambda>i. i mod 2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = LENGTH('a) \\<Longrightarrow>\n    td_ext unat word_of_nat (unats n) (\\<lambda>i. i mod 2 ^ n)", "apply (standard; transfer)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x n.\n       n = LENGTH('a) \\<Longrightarrow>\n       (nat \\<circ> take_bit LENGTH('a)) x \\<in> unats n\n 2. \\<And>x n.\n       n = LENGTH('a) \\<Longrightarrow>\n       take_bit LENGTH('a) (int ((nat \\<circ> take_bit LENGTH('a)) x)) =\n       take_bit LENGTH('a) x\n 3. \\<And>y n.\n       \\<lbrakk>n = LENGTH('a); y \\<in> unats n\\<rbrakk>\n       \\<Longrightarrow> (nat \\<circ> take_bit LENGTH('a)) (int y) = y\n 4. \\<And>x n.\n       n = LENGTH('a) \\<Longrightarrow>\n       (nat \\<circ> take_bit LENGTH('a)) (int x) = x mod 2 ^ n", "apply (simp_all add: unats_def take_bit_of_nat take_bit_nat_eq_self_iff\n      flip: take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas unat_of_nat = td_ext_unat [THEN td_ext.eq_norm]"], ["", "interpretation word_unat:\n  td_ext\n    \"unat::'a::len word \\<Rightarrow> nat\"\n    of_nat\n    \"unats (LENGTH('a::len))\"\n    \"\\<lambda>i. i mod 2 ^ LENGTH('a::len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext unat word_of_nat (unats LENGTH('a))\n     (\\<lambda>i. i mod 2 ^ LENGTH('a))", "by (rule td_ext_unat)"], ["", "lemmas td_unat = word_unat.td_thm"], ["", "lemma unat_le: \"y \\<le> unat z \\<Longrightarrow> y \\<in> unats (LENGTH('a))\"\n  for z :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> unat z \\<Longrightarrow> y \\<in> unats LENGTH('a)", "apply (unfold unats_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> unat z \\<Longrightarrow> y \\<in> {i. i < 2 ^ LENGTH('a)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> unat z \\<Longrightarrow> y < 2 ^ LENGTH('a)", "apply (rule xtrans, rule unat_lt2p, assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma td_ext_sbin:\n  \"td_ext (sint :: 'a word \\<Rightarrow> int) word_of_int (sints (LENGTH('a::len)))\n    (signed_take_bit (LENGTH('a) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext sint word_of_int (sints LENGTH('a))\n     (signed_take_bit (LENGTH('a) - 1))", "by (standard; transfer) (auto simp add: sints_def)"], ["", "lemma td_ext_sint:\n  \"td_ext (sint :: 'a word \\<Rightarrow> int) word_of_int (sints (LENGTH('a::len)))\n     (\\<lambda>w. (w + 2 ^ (LENGTH('a) - 1)) mod 2 ^ LENGTH('a) -\n         2 ^ (LENGTH('a) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext sint word_of_int (sints LENGTH('a))\n     (\\<lambda>w.\n         (w + 2 ^ (LENGTH('a) - 1)) mod 2 ^ LENGTH('a) -\n         2 ^ (LENGTH('a) - 1))", "using td_ext_sbin [where ?'a = 'a]"], ["proof (prove)\nusing this:\n  td_ext sint word_of_int (sints LENGTH('a))\n   (signed_take_bit (LENGTH('a) - 1))\n\ngoal (1 subgoal):\n 1. td_ext sint word_of_int (sints LENGTH('a))\n     (\\<lambda>w.\n         (w + 2 ^ (LENGTH('a) - 1)) mod 2 ^ LENGTH('a) -\n         2 ^ (LENGTH('a) - 1))", "by (simp add: no_sbintr_alt2)"], ["", "text \\<open>\n  We do \\<open>sint\\<close> before \\<open>sbin\\<close>, before \\<open>sint\\<close> is the user version\n  and interpretations do not produce thm duplicates. I.e.\n  we get the name \\<open>word_sint.Rep_eqD\\<close>, but not \\<open>word_sbin.Req_eqD\\<close>,\n  because the latter is the same thm as the former.\n\\<close>"], ["", "interpretation word_sint:\n  td_ext\n    \"sint ::'a::len word \\<Rightarrow> int\"\n    word_of_int\n    \"sints (LENGTH('a::len))\"\n    \"\\<lambda>w. (w + 2^(LENGTH('a::len) - 1)) mod 2^LENGTH('a::len) -\n      2 ^ (LENGTH('a::len) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext sint word_of_int (sints LENGTH('a))\n     (\\<lambda>w.\n         (w + 2 ^ (LENGTH('a) - 1)) mod 2 ^ LENGTH('a) -\n         2 ^ (LENGTH('a) - 1))", "by (rule td_ext_sint)"], ["", "interpretation word_sbin:\n  td_ext\n    \"sint ::'a::len word \\<Rightarrow> int\"\n    word_of_int\n    \"sints (LENGTH('a::len))\"\n    \"signed_take_bit (LENGTH('a::len) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext sint word_of_int (sints LENGTH('a))\n     (signed_take_bit (LENGTH('a) - 1))", "by (rule td_ext_sbin)"], ["", "lemmas int_word_sint = td_ext_sint [THEN td_ext.eq_norm]"], ["", "lemmas td_sint = word_sint.td"], ["", "lemma uints_mod: \"uints n = range (\\<lambda>w. w mod 2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uints n = range (\\<lambda>w. w mod 2 ^ n)", "by (fact uints_def [unfolded no_bintr_alt1])"], ["", "lemmas bintr_num =\n  word_ubin.norm_eq_iff [of \"numeral a\" \"numeral b\", symmetric, folded word_numeral_alt] for a b"], ["", "lemmas sbintr_num =\n  word_sbin.norm_eq_iff [of \"numeral a\" \"numeral b\", symmetric, folded word_numeral_alt] for a b"], ["", "lemmas uint_div_alt = word_div_def [THEN trans [OF uint_cong int_word_uint]]"], ["", "lemmas uint_mod_alt = word_mod_def [THEN trans [OF uint_cong int_word_uint]]"], ["", "interpretation test_bit:\n  td_ext\n    \"(!!) :: 'a::len word \\<Rightarrow> nat \\<Rightarrow> bool\"\n    set_bits\n    \"{f. \\<forall>i. f i \\<longrightarrow> i < LENGTH('a::len)}\"\n    \"(\\<lambda>h i. h i \\<and> i < LENGTH('a::len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td_ext (!!) set_bits\n     {f. \\<forall>i. f i \\<longrightarrow> i < LENGTH('a)}\n     (\\<lambda>h i. h i \\<and> i < LENGTH('a))", "by standard (auto simp add: test_bit_word_eq bit_imp_le_length bit_set_bits_word_iff set_bits_bit_eq)"], ["", "lemmas td_nth = test_bit.td_thm"], ["", "lemma sints_subset:\n  \"m \\<le> n \\<Longrightarrow> sints m \\<subseteq> sints n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> sints m \\<subseteq> sints n", "apply (simp add: sints_num)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    {i. - (2 ^ (m - Suc 0)) \\<le> i \\<and> i < 2 ^ (m - Suc 0)}\n    \\<subseteq> {i. - (2 ^ (n - Suc 0)) \\<le> i \\<and> i < 2 ^ (n - Suc 0)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> n; - (2 ^ (m - Suc 0)) \\<le> x;\n        x < 2 ^ (m - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ (n - Suc 0)) \\<le> x \\<and>\n                         x < 2 ^ (n - Suc 0)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> n; - (2 ^ (m - Suc 0)) \\<le> x;\n        x < 2 ^ (m - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ (n - Suc 0)) \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> n; - (2 ^ (m - Suc 0)) \\<le> x;\n        x < 2 ^ (m - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> x < 2 ^ (n - Suc 0)", "apply (erule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> n; x < 2 ^ (m - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> - (2 ^ (n - Suc 0)) \\<le> - (2 ^ (m - Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> n; - (2 ^ (m - Suc 0)) \\<le> x;\n        x < 2 ^ (m - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> x < 2 ^ (n - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> n; - (2 ^ (m - Suc 0)) \\<le> x;\n        x < 2 ^ (m - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> x < 2 ^ (n - Suc 0)", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> n; - (2 ^ (m - Suc 0)) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (m - Suc 0) \\<le> 2 ^ (n - Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}