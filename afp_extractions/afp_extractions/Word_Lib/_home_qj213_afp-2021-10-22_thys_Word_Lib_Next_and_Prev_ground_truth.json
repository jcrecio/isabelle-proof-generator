{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Next_and_Prev.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma word_next_unfold:\n  \\<open>word_next w = (if w = - 1 then - 1 else w + 1)\\<close>", "lemma word_prev_unfold:\n  \\<open>word_prev w = (if w = 0 then 0 else w - 1)\\<close>", "lemma [code]:\n  \\<open>Word.the_int (word_next w :: 'a::len word) =\n    (if w = - 1 then Word.the_int w else Word.the_int w + 1)\\<close>", "lemma [code]:\n  \\<open>Word.the_int (word_prev w :: 'a::len word) =\n    (if w = 0 then Word.the_int w else Word.the_int w - 1)\\<close>", "lemma word_adjacent_union:\n  \"word_next e = s' \\<Longrightarrow> s \\<le> e \\<Longrightarrow> s' \\<le> e' \\<Longrightarrow> {s..e} \\<union> {s'..e'} = {s .. e'}\""], "translations": [["", "lemma word_next_unfold:\n  \\<open>word_next w = (if w = - 1 then - 1 else w + 1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_next w = (if w = - 1 then - 1 else w + 1)", "by transfer (simp add: take_bit_minus_one_eq_mask flip: take_bit_eq_mask_iff_exp_dvd)"], ["", "lemma word_prev_unfold:\n  \\<open>word_prev w = (if w = 0 then 0 else w - 1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_prev w = (if w = 0 then 0 else w - 1)", "by transfer (simp flip: take_bit_eq_0_iff)"], ["", "lemma [code]:\n  \\<open>Word.the_int (word_next w :: 'a::len word) =\n    (if w = - 1 then Word.the_int w else Word.the_int w + 1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Word.the_int (word_next w) =\n    (if w = - 1 then Word.the_int w else Word.the_int w + 1)", "by transfer\n    (simp add: take_bit_minus_one_eq_mask mask_eq_exp_minus_1 take_bit_incr_eq flip: take_bit_eq_mask_iff_exp_dvd)"], ["", "lemma [code]:\n  \\<open>Word.the_int (word_prev w :: 'a::len word) =\n    (if w = 0 then Word.the_int w else Word.the_int w - 1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Word.the_int (word_prev w) =\n    (if w = 0 then Word.the_int w else Word.the_int w - 1)", "by transfer (simp add: take_bit_eq_0_iff take_bit_decr_eq)"], ["", "lemma word_adjacent_union:\n  \"word_next e = s' \\<Longrightarrow> s \\<le> e \\<Longrightarrow> s' \\<le> e' \\<Longrightarrow> {s..e} \\<union> {s'..e'} = {s .. e'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_next e = s'; s \\<le> e; s' \\<le> e'\\<rbrakk>\n    \\<Longrightarrow> {s..e} \\<union> {s'..e'} = {s..e'}", "apply (simp add: word_next_unfold ivl_disj_un_two_touch split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<le> e; s' \\<le> e'; e \\<noteq> - 1; e + 1 = s'\\<rbrakk>\n    \\<Longrightarrow> {s..e} \\<union> {s'..e'} = {s..e'}", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<le> e; s' \\<le> e'; e \\<noteq> - 1; s' = e + 1\\<rbrakk>\n    \\<Longrightarrow> {s..e} \\<union> {s'..e'} = {s..e'}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<le> e; e + 1 \\<le> e'; e \\<noteq> - 1; s' = e + 1\\<rbrakk>\n    \\<Longrightarrow> {s..e} \\<union> {e + 1..e'} = {s..e'}", "apply (subst word_atLeastLessThan_Suc_atLeastAtMost_union)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>s \\<le> e; e + 1 \\<le> e'; e \\<noteq> - 1; s' = e + 1\\<rbrakk>\n    \\<Longrightarrow> e \\<noteq> - 1\n 2. \\<lbrakk>s \\<le> e; e + 1 \\<le> e'; e \\<noteq> - 1; s' = e + 1\\<rbrakk>\n    \\<Longrightarrow> s \\<le> e\n 3. \\<lbrakk>s \\<le> e; e + 1 \\<le> e'; e \\<noteq> - 1; s' = e + 1\\<rbrakk>\n    \\<Longrightarrow> e \\<le> e'\n 4. \\<lbrakk>s \\<le> e; e + 1 \\<le> e'; e \\<noteq> - 1; s' = e + 1\\<rbrakk>\n    \\<Longrightarrow> {s..e'} = {s..e'}", "apply (simp_all add: word_Suc_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}