{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Reversed_Bit_Lists.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma horner_sum_of_bool_2_concat:\n  \\<open>horner_sum of_bool 2 (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) = horner_sum uint (2 ^ LENGTH('a)) ws\\<close>\n  for ws :: \\<open>'a::len word list\\<close>", "lemma nth_takefill: \"m < n \\<Longrightarrow> takefill fill n l ! m = (if m < length l then l ! m else fill)\"", "lemma takefill_alt: \"takefill fill n l = take n l @ replicate (n - length l) fill\"", "lemma takefill_replicate [simp]: \"takefill fill n (replicate m fill) = replicate n fill\"", "lemma takefill_le': \"n = m + k \\<Longrightarrow> takefill x m (takefill x n l) = takefill x m l\"", "lemma length_takefill [simp]: \"length (takefill fill n l) = n\"", "lemma take_takefill': \"n = k + m \\<Longrightarrow> take k (takefill fill n w) = takefill fill k w\"", "lemma drop_takefill: \"drop k (takefill fill (m + k) w) = takefill fill m (drop k w)\"", "lemma takefill_le [simp]: \"m \\<le> n \\<Longrightarrow> takefill x m (takefill x n l) = takefill x m l\"", "lemma take_takefill [simp]: \"m \\<le> n \\<Longrightarrow> take m (takefill fill n w) = takefill fill m w\"", "lemma takefill_append: \"takefill fill (m + length xs) (xs @ w) = xs @ (takefill fill m w)\"", "lemma takefill_same': \"l = length xs \\<Longrightarrow> takefill fill l xs = xs\"", "lemmas takefill_same [simp] = takefill_same' [OF refl]", "lemma tf_rev:\n  \"n + k = m + length bl \\<Longrightarrow> takefill x m (rev (takefill y n bl)) =\n    rev (takefill y m (rev (takefill x k (rev bl))))\"", "lemma takefill_minus: \"0 < n \\<Longrightarrow> takefill fill (Suc (n - 1)) w = takefill fill n w\"", "lemmas takefill_Suc_cases =\n  list.cases [THEN takefill.Suc [THEN trans]]", "lemmas takefill_Suc_Nil = takefill_Suc_cases (1)", "lemmas takefill_Suc_Cons = takefill_Suc_cases (2)", "lemmas takefill_minus_simps = takefill_Suc_cases [THEN [2]\n  takefill_minus [symmetric, THEN trans]]", "lemma takefill_numeral_Nil [simp]:\n  \"takefill fill (numeral k) [] = fill # takefill fill (pred_numeral k) []\"", "lemma takefill_numeral_Cons [simp]:\n  \"takefill fill (numeral k) (x # xs) = x # takefill fill (pred_numeral k) xs\"", "lemma bl_of_nth_simps [simp, code]:\n  \"bl_of_nth 0 f = []\"\n  \"bl_of_nth (Suc n) f = f n # bl_of_nth n f\"", "lemma length_bl_of_nth [simp]: \"length (bl_of_nth n f) = n\"", "lemma nth_bl_of_nth [simp]: \"m < n \\<Longrightarrow> rev (bl_of_nth n f) ! m = f m\"", "lemma bl_of_nth_inj: \"(\\<And>k. k < n \\<Longrightarrow> f k = g k) \\<Longrightarrow> bl_of_nth n f = bl_of_nth n g\"", "lemma bl_of_nth_nth_le: \"n \\<le> length xs \\<Longrightarrow> bl_of_nth n (nth (rev xs)) = drop (length xs - n) xs\"", "lemma bl_of_nth_nth [simp]: \"bl_of_nth (length xs) ((!) (rev xs)) = xs\"", "lemmas rotater_0' [simp] = rotater_def [where n = \"0\", simplified]", "lemma rotate1_rl': \"rotater1 (l @ [a]) = a # l\"", "lemma rotate1_rl [simp] : \"rotater1 (rotate1 l) = l\"", "lemma rotate1_lr [simp] : \"rotate1 (rotater1 l) = l\"", "lemma rotater1_rev': \"rotater1 (rev xs) = rev (rotate1 xs)\"", "lemma rotater_rev': \"rotater n (rev xs) = rev (rotate n xs)\"", "lemma rotater_rev: \"rotater n ys = rev (rotate n (rev ys))\"", "lemma rotater_drop_take:\n  \"rotater n xs =\n    drop (length xs - n mod length xs) xs @\n    take (length xs - n mod length xs) xs\"", "lemma rotater_Suc [simp]: \"rotater (Suc n) xs = rotater1 (rotater n xs)\"", "lemma nth_rotater:\n  \\<open>rotater m xs ! n = xs ! ((n + (length xs - m mod length xs)) mod length xs)\\<close> if \\<open>n < length xs\\<close>", "lemma nth_rotater1:\n  \\<open>rotater1 xs ! n = xs ! ((n + (length xs - 1)) mod length xs)\\<close> if \\<open>n < length xs\\<close>", "lemma rotate_inv_plus [rule_format]:\n  \"\\<forall>k. k = m + n \\<longrightarrow> rotater k (rotate n xs) = rotater m xs \\<and>\n    rotate k (rotater n xs) = rotate m xs \\<and>\n    rotater n (rotate k xs) = rotate m xs \\<and>\n    rotate n (rotater k xs) = rotater m xs\"", "lemmas rotate_inv_rel = le_add_diff_inverse2 [symmetric, THEN rotate_inv_plus]", "lemmas rotate_inv_eq = order_refl [THEN rotate_inv_rel, simplified]", "lemmas rotate_lr [simp] = rotate_inv_eq [THEN conjunct1]", "lemmas rotate_rl [simp] = rotate_inv_eq [THEN conjunct2, THEN conjunct1]", "lemma rotate_gal: \"rotater n xs = ys \\<longleftrightarrow> rotate n ys = xs\"", "lemma rotate_gal': \"ys = rotater n xs \\<longleftrightarrow> xs = rotate n ys\"", "lemma length_rotater [simp]: \"length (rotater n xs) = length xs\"", "lemma rotate_eq_mod: \"m mod length xs = n mod length xs \\<Longrightarrow> rotate m xs = rotate n xs\"", "lemma restrict_to_left: \"x = y \\<Longrightarrow> x = z \\<longleftrightarrow> y = z\"", "lemmas rotate_eqs =\n  trans [OF rotate0 [THEN fun_cong] id_apply]\n  rotate_rotate [symmetric]\n  rotate_id\n  rotate_conv_mod\n  rotate_eq_mod", "lemmas rrs0 = rotate_eqs [THEN restrict_to_left,\n  simplified rotate_gal [symmetric] rotate_gal' [symmetric]]", "lemmas rrs1 = rrs0 [THEN refl [THEN rev_iffD1]]", "lemmas rotater_eqs = rrs1 [simplified length_rotater]", "lemmas rotater_0 = rotater_eqs (1)", "lemmas rotater_add = rotater_eqs (2)", "lemma butlast_map: \"xs \\<noteq> [] \\<Longrightarrow> butlast (map f xs) = map f (butlast xs)\"", "lemma rotater1_map: \"rotater1 (map f xs) = map f (rotater1 xs)\"", "lemma rotater_map: \"rotater n (map f xs) = map f (rotater n xs)\"", "lemma but_last_zip [rule_format] :\n  \"\\<forall>ys. length xs = length ys \\<longrightarrow> xs \\<noteq> [] \\<longrightarrow>\n    last (zip xs ys) = (last xs, last ys) \\<and>\n    butlast (zip xs ys) = zip (butlast xs) (butlast ys)\"", "lemma but_last_map2 [rule_format] :\n  \"\\<forall>ys. length xs = length ys \\<longrightarrow> xs \\<noteq> [] \\<longrightarrow>\n    last (map2 f xs ys) = f (last xs) (last ys) \\<and>\n    butlast (map2 f xs ys) = map2 f (butlast xs) (butlast ys)\"", "lemma rotater1_zip:\n  \"length xs = length ys \\<Longrightarrow>\n    rotater1 (zip xs ys) = zip (rotater1 xs) (rotater1 ys)\"", "lemma rotater1_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotater1 (map2 f xs ys) = map2 f (rotater1 xs) (rotater1 ys)\"", "lemmas lrth =\n  box_equals [OF asm_rl length_rotater [symmetric]\n                 length_rotater [symmetric],\n              THEN rotater1_map2]", "lemma rotater_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotater n (map2 f xs ys) = map2 f (rotater n xs) (rotater n ys)\"", "lemma rotate1_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotate1 (map2 f xs ys) = map2 f (rotate1 xs) (rotate1 ys)\"", "lemmas lth = box_equals [OF asm_rl length_rotate [symmetric]\n  length_rotate [symmetric], THEN rotate1_map2]", "lemma rotate_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotate n (map2 f xs ys) = map2 f (rotate n xs) (rotate n ys)\"", "lemma bin_to_bl_aux_zero_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n 0 bl = bin_to_bl_aux (n - 1) 0 (False # bl)\"", "lemma bin_to_bl_aux_minus1_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n (- 1) bl = bin_to_bl_aux (n - 1) (- 1) (True # bl)\"", "lemma bin_to_bl_aux_one_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n 1 bl = bin_to_bl_aux (n - 1) 0 (True # bl)\"", "lemma bin_to_bl_aux_Bit0_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (numeral (Num.Bit0 w)) bl = bin_to_bl_aux (n - 1) (numeral w) (False # bl)\"", "lemma bin_to_bl_aux_Bit1_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (numeral (Num.Bit1 w)) bl = bin_to_bl_aux (n - 1) (numeral w) (True # bl)\"", "lemma bl_to_bin_aux_append: \"bl_to_bin_aux (bs @ cs) w = bl_to_bin_aux cs (bl_to_bin_aux bs w)\"", "lemma bin_to_bl_aux_append: \"bin_to_bl_aux n w bs @ cs = bin_to_bl_aux n w (bs @ cs)\"", "lemma bl_to_bin_append: \"bl_to_bin (bs @ cs) = bl_to_bin_aux cs (bl_to_bin bs)\"", "lemma bin_to_bl_aux_alt: \"bin_to_bl_aux n w bs = bin_to_bl n w @ bs\"", "lemma bin_to_bl_0 [simp]: \"bin_to_bl 0 bs = []\"", "lemma size_bin_to_bl_aux: \"length (bin_to_bl_aux n w bs) = n + length bs\"", "lemma size_bin_to_bl [simp]: \"length (bin_to_bl n w) = n\"", "lemma bl_bin_bl': \"bin_to_bl (n + length bs) (bl_to_bin_aux bs w) = bin_to_bl_aux n w bs\"", "lemma bl_bin_bl [simp]: \"bin_to_bl (length bs) (bl_to_bin bs) = bs\"", "lemma bl_to_bin_inj: \"bl_to_bin bs = bl_to_bin cs \\<Longrightarrow> length bs = length cs \\<Longrightarrow> bs = cs\"", "lemma bl_to_bin_False [simp]: \"bl_to_bin (False # bl) = bl_to_bin bl\"", "lemma bl_to_bin_Nil [simp]: \"bl_to_bin [] = 0\"", "lemma bin_to_bl_zero_aux: \"bin_to_bl_aux n 0 bl = replicate n False @ bl\"", "lemma bin_to_bl_zero: \"bin_to_bl n 0 = replicate n False\"", "lemma bin_to_bl_minus1_aux: \"bin_to_bl_aux n (- 1) bl = replicate n True @ bl\"", "lemma bin_to_bl_minus1: \"bin_to_bl n (- 1) = replicate n True\"", "lemma bin_bl_bin': \"bl_to_bin (bin_to_bl_aux n w bs) = bl_to_bin_aux bs (bintrunc n w)\"", "lemma bin_bl_bin [simp]: \"bl_to_bin (bin_to_bl n w) = bintrunc n w\"", "lemma bl_to_bin_rep_F: \"bl_to_bin (replicate n False @ bl) = bl_to_bin bl\"", "lemma bin_to_bl_trunc [simp]: \"n \\<le> m \\<Longrightarrow> bin_to_bl n (bintrunc m w) = bin_to_bl n w\"", "lemma bin_to_bl_aux_bintr:\n  \"bin_to_bl_aux n (bintrunc m bin) bl =\n    replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl\"", "lemma bin_to_bl_bintr:\n  \"bin_to_bl n (bintrunc m bin) = replicate (n - m) False @ bin_to_bl (min n m) bin\"", "lemma bl_to_bin_rep_False: \"bl_to_bin (replicate n False) = 0\"", "lemma len_bin_to_bl_aux: \"length (bin_to_bl_aux n w bs) = n + length bs\"", "lemma len_bin_to_bl: \"length (bin_to_bl n w) = n\"", "lemma sign_bl_bin': \"bin_sign (bl_to_bin_aux bs w) = bin_sign w\"", "lemma sign_bl_bin: \"bin_sign (bl_to_bin bs) = 0\"", "lemma bl_sbin_sign_aux: \"hd (bin_to_bl_aux (Suc n) w bs) = (bin_sign (sbintrunc n w) = -1)\"", "lemma bl_sbin_sign: \"hd (bin_to_bl (Suc n) w) = (bin_sign (sbintrunc n w) = -1)\"", "lemma bin_nth_of_bl_aux:\n  \"bin_nth (bl_to_bin_aux bl w) n =\n    (n < size bl \\<and> rev bl ! n \\<or> n \\<ge> length bl \\<and> bin_nth w (n - size bl))\"", "lemma bin_nth_of_bl: \"bin_nth (bl_to_bin bl) n = (n < length bl \\<and> rev bl ! n)\"", "lemma bin_nth_bl: \"n < m \\<Longrightarrow> bin_nth w n = nth (rev (bin_to_bl m w)) n\"", "lemma nth_bin_to_bl_aux:\n  \"n < m + length bl \\<Longrightarrow> (bin_to_bl_aux m w bl) ! n =\n    (if n < m then bit w (m - 1 - n) else bl ! (n - m))\"", "lemma nth_bin_to_bl: \"n < m \\<Longrightarrow> (bin_to_bl m w) ! n = bin_nth w (m - Suc n)\"", "lemma takefill_bintrunc: \"takefill False n bl = rev (bin_to_bl n (bl_to_bin (rev bl)))\"", "lemma bl_bin_bl_rtf: \"bin_to_bl n (bl_to_bin bl) = rev (takefill False n (rev bl))\"", "lemma bl_to_bin_lt2p_aux: \"bl_to_bin_aux bs w < (w + 1) * (2 ^ length bs)\"", "lemma bl_to_bin_lt2p_drop: \"bl_to_bin bs < 2 ^ length (dropWhile Not bs)\"", "lemma bl_to_bin_lt2p: \"bl_to_bin bs < 2 ^ length bs\"", "lemma bl_to_bin_ge2p_aux: \"bl_to_bin_aux bs w \\<ge> w * (2 ^ length bs)\"", "lemma bl_to_bin_ge0: \"bl_to_bin bs \\<ge> 0\"", "lemma butlast_rest_bin: \"butlast (bin_to_bl n w) = bin_to_bl (n - 1) (bin_rest w)\"", "lemma butlast_bin_rest: \"butlast bl = bin_to_bl (length bl - Suc 0) (bin_rest (bl_to_bin bl))\"", "lemma butlast_rest_bl2bin_aux:\n  \"bl \\<noteq> [] \\<Longrightarrow> bl_to_bin_aux (butlast bl) w = bin_rest (bl_to_bin_aux bl w)\"", "lemma butlast_rest_bl2bin: \"bl_to_bin (butlast bl) = bin_rest (bl_to_bin bl)\"", "lemma trunc_bl2bin_aux:\n  \"bintrunc m (bl_to_bin_aux bl w) =\n    bl_to_bin_aux (drop (length bl - m) bl) (bintrunc (m - length bl) w)\"", "lemma trunc_bl2bin: \"bintrunc m (bl_to_bin bl) = bl_to_bin (drop (length bl - m) bl)\"", "lemma trunc_bl2bin_len [simp]: \"bintrunc (length bl) (bl_to_bin bl) = bl_to_bin bl\"", "lemma bl2bin_drop: \"bl_to_bin (drop k bl) = bintrunc (length bl - k) (bl_to_bin bl)\"", "lemma take_rest_power_bin: \"m \\<le> n \\<Longrightarrow> take m (bin_to_bl n w) = bin_to_bl m ((bin_rest ^^ (n - m)) w)\"", "lemma last_bin_last': \"size xs > 0 \\<Longrightarrow> last xs \\<longleftrightarrow> bin_last (bl_to_bin_aux xs w)\"", "lemma last_bin_last: \"size xs > 0 \\<Longrightarrow> last xs \\<longleftrightarrow> bin_last (bl_to_bin xs)\"", "lemma bin_last_last: \"bin_last w \\<longleftrightarrow> last (bin_to_bl (Suc n) w)\"", "lemma drop_bin2bl_aux:\n  \"drop m (bin_to_bl_aux n bin bs) =\n    bin_to_bl_aux (n - m) bin (drop (m - n) bs)\"", "lemma drop_bin2bl: \"drop m (bin_to_bl n bin) = bin_to_bl (n - m) bin\"", "lemma take_bin2bl_lem1: \"take m (bin_to_bl_aux m w bs) = bin_to_bl m w\"", "lemma take_bin2bl_lem: \"take m (bin_to_bl_aux (m + n) w bs) = take m (bin_to_bl (m + n) w)\"", "lemma bin_split_take: \"bin_split n c = (a, b) \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl (m + n) c)\"", "lemma bin_to_bl_drop_bit:\n  \"k = m + n \\<Longrightarrow> bin_to_bl m (drop_bit n c) = take m (bin_to_bl k c)\"", "lemma bin_split_take1:\n  \"k = m + n \\<Longrightarrow> bin_split n c = (a, b) \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl k c)\"", "lemma bl_bin_bl_rep_drop:\n  \"bin_to_bl n (bl_to_bin bl) =\n    replicate (n - length bl) False @ drop (length bl - n) bl\"", "lemma bl_to_bin_aux_cat:\n  \"bl_to_bin_aux bs (bin_cat w nv v) =\n    bin_cat w (nv + length bs) (bl_to_bin_aux bs v)\"", "lemma bin_to_bl_aux_cat:\n  \"bin_to_bl_aux (nv + nw) (bin_cat v nw w) bs =\n    bin_to_bl_aux nv v (bin_to_bl_aux nw w bs)\"", "lemma bl_to_bin_aux_alt: \"bl_to_bin_aux bs w = bin_cat w (length bs) (bl_to_bin bs)\"", "lemma bin_to_bl_cat:\n  \"bin_to_bl (nv + nw) (bin_cat v nw w) =\n    bin_to_bl_aux nv v (bin_to_bl nw w)\"", "lemmas bl_to_bin_aux_app_cat =\n  trans [OF bl_to_bin_aux_append bl_to_bin_aux_alt]", "lemmas bin_to_bl_aux_cat_app =\n  trans [OF bin_to_bl_aux_cat bin_to_bl_aux_alt]", "lemma bl_to_bin_app_cat:\n  \"bl_to_bin (bsa @ bs) = bin_cat (bl_to_bin bsa) (length bs) (bl_to_bin bs)\"", "lemma bin_to_bl_cat_app:\n  \"bin_to_bl (n + nw) (bin_cat w nw wa) = bin_to_bl n w @ bin_to_bl nw wa\"", "lemma bl_to_bin_app_cat_alt: \"bin_cat (bl_to_bin cs) n w = bl_to_bin (cs @ bin_to_bl n w)\"", "lemma mask_lem: \"(bl_to_bin (True # replicate n False)) = bl_to_bin (replicate n True) + 1\"", "lemma bin_exhaust:\n  \"(\\<And>x b. bin = of_bool b + 2 * x \\<Longrightarrow> Q) \\<Longrightarrow> Q\" for bin :: int", "lemma size_rbl_pred: \"length (rbl_pred bl) = length bl\"", "lemma size_rbl_succ: \"length (rbl_succ bl) = length bl\"", "lemma size_rbl_add: \"length (rbl_add bl cl) = length bl\"", "lemma size_rbl_mult: \"length (rbl_mult bl cl) = length bl\"", "lemmas rbl_sizes [simp] =\n  size_rbl_pred size_rbl_succ size_rbl_add size_rbl_mult", "lemmas rbl_Nils =\n  rbl_pred.Nil rbl_succ.Nil rbl_add.Nil rbl_mult.Nil", "lemma rbl_add_app2: \"length blb \\<ge> length bla \\<Longrightarrow> rbl_add bla (blb @ blc) = rbl_add bla blb\"", "lemma rbl_add_take2:\n  \"length blb \\<ge> length bla \\<Longrightarrow> rbl_add bla (take (length bla) blb) = rbl_add bla blb\"", "lemma rbl_mult_app2: \"length blb \\<ge> length bla \\<Longrightarrow> rbl_mult bla (blb @ blc) = rbl_mult bla blb\"", "lemma rbl_mult_take2:\n  \"length blb \\<ge> length bla \\<Longrightarrow> rbl_mult bla (take (length bla) blb) = rbl_mult bla blb\"", "lemma rbl_add_split:\n  \"P (rbl_add (y # ys) (x # xs)) =\n    (\\<forall>ws. length ws = length ys \\<longrightarrow> ws = rbl_add ys xs \\<longrightarrow>\n      (y \\<longrightarrow> ((x \\<longrightarrow> P (False # rbl_succ ws)) \\<and> (\\<not> x \\<longrightarrow> P (True # ws)))) \\<and>\n      (\\<not> y \\<longrightarrow> P (x # ws)))\"", "lemma rbl_mult_split:\n  \"P (rbl_mult (y # ys) xs) =\n    (\\<forall>ws. length ws = Suc (length ys) \\<longrightarrow> ws = False # rbl_mult ys xs \\<longrightarrow>\n      (y \\<longrightarrow> P (rbl_add ws xs)) \\<and> (\\<not> y \\<longrightarrow> P ws))\"", "lemma rbl_pred: \"rbl_pred (rev (bin_to_bl n bin)) = rev (bin_to_bl n (bin - 1))\"", "lemma rbl_succ: \"rbl_succ (rev (bin_to_bl n bin)) = rev (bin_to_bl n (bin + 1))\"", "lemma rbl_add:\n  \"\\<And>bina binb. rbl_add (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n    rev (bin_to_bl n (bina + binb))\"", "lemma rbl_add_long:\n  \"m \\<ge> n \\<Longrightarrow> rbl_add (rev (bin_to_bl n bina)) (rev (bin_to_bl m binb)) =\n    rev (bin_to_bl n (bina + binb))\"", "lemma rbl_mult_gt1:\n  \"m \\<ge> length bl \\<Longrightarrow>\n    rbl_mult bl (rev (bin_to_bl m binb)) =\n    rbl_mult bl (rev (bin_to_bl (length bl) binb))\"", "lemma rbl_mult_gt:\n  \"m > n \\<Longrightarrow>\n    rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl m binb)) =\n    rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb))\"", "lemmas rbl_mult_Suc = lessI [THEN rbl_mult_gt]", "lemma rbbl_Cons: \"b # rev (bin_to_bl n x) = rev (bin_to_bl (Suc n) (of_bool b + 2 * x))\"", "lemma rbl_mult:\n  \"rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n    rev (bin_to_bl n (bina * binb))\"", "lemma sclem: \"size (concat (map (bin_to_bl n) xs)) = length xs * n\"", "lemma bin_cat_foldl_lem:\n  \"foldl (\\<lambda>u. bin_cat u n) x xs =\n    bin_cat x (size xs * n) (foldl (\\<lambda>u. bin_cat u n) y xs)\"", "lemma bin_rcat_bl: \"bin_rcat n wl = bl_to_bin (concat (map (bin_to_bl n) wl))\"", "lemma bin_last_bl_to_bin: \"bin_last (bl_to_bin bs) \\<longleftrightarrow> bs \\<noteq> [] \\<and> last bs\"", "lemma bin_rest_bl_to_bin: \"bin_rest (bl_to_bin bs) = bl_to_bin (butlast bs)\"", "lemma bl_xor_aux_bin:\n  \"map2 (\\<lambda>x y. x \\<noteq> y) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v XOR w) (map2 (\\<lambda>x y. x \\<noteq> y) bs cs)\"", "lemma bl_or_aux_bin:\n  \"map2 (\\<or>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v OR w) (map2 (\\<or>) bs cs)\"", "lemma bl_and_aux_bin:\n  \"map2 (\\<and>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v AND w) (map2 (\\<and>) bs cs)\"", "lemma bl_not_aux_bin: \"map Not (bin_to_bl_aux n w cs) = bin_to_bl_aux n (NOT w) (map Not cs)\"", "lemma bl_not_bin: \"map Not (bin_to_bl n w) = bin_to_bl n (NOT w)\"", "lemma bl_and_bin: \"map2 (\\<and>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v AND w)\"", "lemma bl_or_bin: \"map2 (\\<or>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v OR w)\"", "lemma bl_xor_bin: \"map2 (\\<noteq>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v XOR w)\"", "lemma to_bl_eq:\n  \\<open>to_bl w = bin_to_bl (LENGTH('a)) (uint w)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma bit_of_bl_iff [bit_simps]:\n  \\<open>bit (of_bl bs :: 'a word) n \\<longleftrightarrow> rev bs ! n \\<and> n < LENGTH('a::len) \\<and> n < length bs\\<close>", "lemma rev_to_bl_eq:\n  \\<open>rev (to_bl w) = map (bit w) [0..<LENGTH('a)]\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma to_bl_eq_rev:\n  \\<open>to_bl w = map (bit w) (rev [0..<LENGTH('a)])\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma of_bl_rev_eq:\n  \\<open>of_bl (rev bs) = horner_sum of_bool 2 bs\\<close>", "lemma of_bl_eq:\n  \\<open>of_bl bs = horner_sum of_bool 2 (rev bs)\\<close>", "lemma bshiftr1_eq:\n  \\<open>bshiftr1 b w = of_bl (b # butlast (to_bl w))\\<close>", "lemma length_to_bl_eq:\n  \\<open>length (to_bl w) = LENGTH('a)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma word_rotr_eq:\n  \\<open>word_rotr n w = of_bl (rotater n (to_bl w))\\<close>", "lemma word_rotl_eq:\n  \\<open>word_rotl n w = of_bl (rotate n (to_bl w))\\<close>", "lemma to_bl_def': \"(to_bl :: 'a::len word \\<Rightarrow> bool list) = bin_to_bl (LENGTH('a)) \\<circ> uint\"", "lemma td_bl:\n  \"type_definition\n    (to_bl :: 'a::len word \\<Rightarrow> bool list)\n    of_bl\n    {bl. length bl = LENGTH('a)}\"", "lemmas word_bl_Rep' = word_bl.Rep [unfolded mem_Collect_eq, iff]", "lemma word_size_bl: \"size w = size (to_bl w)\"", "lemma to_bl_use_of_bl: \"to_bl w = bl \\<longleftrightarrow> w = of_bl bl \\<and> length bl = length (to_bl w)\"", "lemma length_bl_gt_0 [iff]: \"0 < length (to_bl x)\"\n  for x :: \"'a::len word\"", "lemma bl_not_Nil [iff]: \"to_bl x \\<noteq> []\"\n  for x :: \"'a::len word\"", "lemma length_bl_neq_0 [iff]: \"length (to_bl x) \\<noteq> 0\"\n  for x :: \"'a::len word\"", "lemma hd_bl_sign_sint: \"hd (to_bl w) = (bin_sign (sint w) = -1)\"", "lemma of_bl_drop':\n  \"lend = length bl - LENGTH('a::len) \\<Longrightarrow>\n    of_bl (drop lend bl) = (of_bl bl :: 'a word)\"", "lemma test_bit_of_bl:\n  \"(of_bl bl::'a::len word) !! n = (rev bl ! n \\<and> n < LENGTH('a) \\<and> n < length bl)\"", "lemma no_of_bl: \"(numeral bin ::'a::len word) = of_bl (bin_to_bl (LENGTH('a)) (numeral bin))\"", "lemma uint_bl: \"to_bl w = bin_to_bl (size w) (uint w)\"", "lemma to_bl_bin: \"bl_to_bin (to_bl w) = uint w\"", "lemma to_bl_of_bin: \"to_bl (word_of_int bin::'a::len word) = bin_to_bl (LENGTH('a)) bin\"", "lemma to_bl_numeral [simp]:\n  \"to_bl (numeral bin::'a::len word) =\n    bin_to_bl (LENGTH('a)) (numeral bin)\"", "lemma to_bl_neg_numeral [simp]:\n  \"to_bl (- numeral bin::'a::len word) =\n    bin_to_bl (LENGTH('a)) (- numeral bin)\"", "lemma to_bl_to_bin [simp] : \"bl_to_bin (to_bl w) = uint w\"", "lemma uint_bl_bin: \"bl_to_bin (bin_to_bl (LENGTH('a)) (uint x)) = uint x\"\n  for x :: \"'a::len word\"", "lemma ucast_bl: \"ucast w = of_bl (to_bl w)\"", "lemma ucast_down_bl:\n  \\<open>(ucast :: 'a::len word \\<Rightarrow> 'b::len word) (of_bl bl) = of_bl bl\\<close>\n    if \\<open>is_down (ucast :: 'a::len word \\<Rightarrow> 'b::len word)\\<close>", "lemma of_bl_append_same: \"of_bl (X @ to_bl w) = w\"", "lemma ucast_of_bl_up:\n  \\<open>ucast (of_bl bl :: 'a::len word) = of_bl bl\\<close>\n  if \\<open>size bl \\<le> size (of_bl bl :: 'a::len word)\\<close>", "lemma word_rev_tf:\n  \"to_bl (of_bl bl::'a::len word) =\n    rev (takefill False (LENGTH('a)) (rev bl))\"", "lemma word_rep_drop:\n  \"to_bl (of_bl bl::'a::len word) =\n    replicate (LENGTH('a) - length bl) False @\n    drop (length bl - LENGTH('a)) bl\"", "lemma to_bl_ucast:\n  \"to_bl (ucast (w::'b::len word) ::'a::len word) =\n    replicate (LENGTH('a) - LENGTH('b)) False @\n    drop (LENGTH('b) - LENGTH('a)) (to_bl w)\"", "lemma ucast_up_app:\n  \\<open>to_bl (ucast w :: 'b::len word) = replicate n False @ (to_bl w)\\<close>\n    if \\<open>source_size (ucast :: 'a word \\<Rightarrow> 'b word) + n = target_size (ucast :: 'a word \\<Rightarrow> 'b word)\\<close>\n    for w :: \\<open>'a::len word\\<close>", "lemma ucast_down_drop [OF refl]:\n  \"uc = ucast \\<Longrightarrow> source_size uc = target_size uc + n \\<Longrightarrow>\n    to_bl (uc w) = drop n (to_bl w)\"", "lemma scast_down_drop [OF refl]:\n  \"sc = scast \\<Longrightarrow> source_size sc = target_size sc + n \\<Longrightarrow>\n    to_bl (sc w) = drop n (to_bl w)\"", "lemma word_0_bl [simp]: \"of_bl [] = 0\"", "lemma word_1_bl: \"of_bl [True] = 1\"", "lemma of_bl_0 [simp]: \"of_bl (replicate n False) = 0\"", "lemma to_bl_0 [simp]: \"to_bl (0::'a::len word) = replicate (LENGTH('a)) False\"", "lemma word_succ_rbl: \"to_bl w = bl \\<Longrightarrow> to_bl (word_succ w) = rev (rbl_succ (rev bl))\"", "lemma word_pred_rbl: \"to_bl w = bl \\<Longrightarrow> to_bl (word_pred w) = rev (rbl_pred (rev bl))\"", "lemma word_add_rbl:\n  \"to_bl v = vbl \\<Longrightarrow> to_bl w = wbl \\<Longrightarrow>\n    to_bl (v + w) = rev (rbl_add (rev vbl) (rev wbl))\"", "lemma word_mult_rbl:\n  \"to_bl v = vbl \\<Longrightarrow> to_bl w = wbl \\<Longrightarrow>\n    to_bl (v * w) = rev (rbl_mult (rev vbl) (rev wbl))\"", "lemma rtb_rbl_ariths:\n  \"rev (to_bl w) = ys \\<Longrightarrow> rev (to_bl (word_succ w)) = rbl_succ ys\"\n  \"rev (to_bl w) = ys \\<Longrightarrow> rev (to_bl (word_pred w)) = rbl_pred ys\"\n  \"rev (to_bl v) = ys \\<Longrightarrow> rev (to_bl w) = xs \\<Longrightarrow> rev (to_bl (v * w)) = rbl_mult ys xs\"\n  \"rev (to_bl v) = ys \\<Longrightarrow> rev (to_bl w) = xs \\<Longrightarrow> rev (to_bl (v + w)) = rbl_add ys xs\"", "lemma of_bl_length_less:\n  \\<open>(of_bl x :: 'a::len word) < 2 ^ k\\<close>\n    if \\<open>length x = k\\<close> \\<open>k < LENGTH('a)\\<close>", "lemma word_eq_rbl_eq: \"x = y \\<longleftrightarrow> rev (to_bl x) = rev (to_bl y)\"", "lemma bl_word_not: \"to_bl (NOT w) = map Not (to_bl w)\"", "lemma bl_word_xor: \"to_bl (v XOR w) = map2 (\\<noteq>) (to_bl v) (to_bl w)\"", "lemma bl_word_or: \"to_bl (v OR w) = map2 (\\<or>) (to_bl v) (to_bl w)\"", "lemma bl_word_and: \"to_bl (v AND w) = map2 (\\<and>) (to_bl v) (to_bl w)\"", "lemma bin_nth_uint': \"bin_nth (uint w) n \\<longleftrightarrow> rev (bin_to_bl (size w) (uint w)) ! n \\<and> n < size w\"", "lemmas bin_nth_uint = bin_nth_uint' [unfolded word_size]", "lemma test_bit_bl: \"w !! n \\<longleftrightarrow> rev (to_bl w) ! n \\<and> n < size w\"", "lemma to_bl_nth: \"n < size w \\<Longrightarrow> to_bl w ! n = w !! (size w - Suc n)\"", "lemma map_bit_interval_eq:\n  \\<open>map (bit w) [0..<n] = takefill False n (rev (to_bl w))\\<close> for w :: \\<open>'a::len word\\<close>", "lemma to_bl_unfold:\n  \\<open>to_bl w = rev (map (bit w) [0..<LENGTH('a)])\\<close> for w :: \\<open>'a::len word\\<close>", "lemma nth_rev_to_bl:\n  \\<open>rev (to_bl w) ! n \\<longleftrightarrow> bit w n\\<close>\n  if \\<open>n < LENGTH('a)\\<close> for w :: \\<open>'a::len word\\<close>", "lemma nth_to_bl:\n  \\<open>to_bl w ! n \\<longleftrightarrow> bit w (LENGTH('a) - Suc n)\\<close>\n  if \\<open>n < LENGTH('a)\\<close> for w :: \\<open>'a::len word\\<close>", "lemma of_bl_rep_False: \"of_bl (replicate n False @ bs) = of_bl bs\"", "lemma [code abstract]:\n  \\<open>Word.the_int (of_bl bs :: 'a word) = horner_sum of_bool 2 (take LENGTH('a::len) (rev bs))\\<close>", "lemma [code]:\n  \\<open>to_bl w = map (bit w) (rev [0..<LENGTH('a::len)])\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma word_reverse_eq_of_bl_rev_to_bl:\n  \\<open>word_reverse w = of_bl (rev (to_bl w))\\<close>", "lemmas word_reverse_no_def [simp] =\n  word_reverse_eq_of_bl_rev_to_bl [of \"numeral w\"] for w", "lemma to_bl_word_rev: \"to_bl (word_reverse w) = rev (to_bl w)\"", "lemma to_bl_n1 [simp]: \"to_bl (-1::'a::len word) = replicate (LENGTH('a)) True\"", "lemma rbl_word_or: \"rev (to_bl (x OR y)) = map2 (\\<or>) (rev (to_bl x)) (rev (to_bl y))\"", "lemma rbl_word_and: \"rev (to_bl (x AND y)) = map2 (\\<and>) (rev (to_bl x)) (rev (to_bl y))\"", "lemma rbl_word_xor: \"rev (to_bl (x XOR y)) = map2 (\\<noteq>) (rev (to_bl x)) (rev (to_bl y))\"", "lemma rbl_word_not: \"rev (to_bl (NOT x)) = map Not (rev (to_bl x))\"", "lemma bshiftr1_numeral [simp]:\n  \\<open>bshiftr1 b (numeral w :: 'a word) = of_bl (b # butlast (bin_to_bl LENGTH('a::len) (numeral w)))\\<close>", "lemma bshiftr1_bl: \"to_bl (bshiftr1 b w) = b # butlast (to_bl w)\"", "lemma shiftl1_of_bl: \"shiftl1 (of_bl bl) = of_bl (bl @ [False])\"", "lemma shiftl1_bl: \"shiftl1 w = of_bl (to_bl w @ [False])\"\n  for w :: \"'a::len word\"", "lemma bl_shiftl1: \"to_bl (shiftl1 w) = tl (to_bl w) @ [False]\"\n  for w :: \"'a::len word\"", "lemma bl_shiftl1': \"to_bl (shiftl1 w) = tl (to_bl w @ [False])\"", "lemma shiftr1_bl:\n  \\<open>shiftr1 w = of_bl (butlast (to_bl w))\\<close>", "lemma bl_shiftr1: \"to_bl (shiftr1 w) = False # butlast (to_bl w)\"\n  for w :: \"'a::len word\"", "lemma bl_shiftr1': \"to_bl (shiftr1 w) = butlast (False # to_bl w)\"", "lemma bl_sshiftr1: \"to_bl (sshiftr1 w) = hd (to_bl w) # butlast (to_bl w)\"\n  for w :: \"'a::len word\"", "lemma drop_shiftr: \"drop n (to_bl (w >> n)) = take (size w - n) (to_bl w)\"\n  for w :: \"'a::len word\"", "lemma drop_sshiftr: \"drop n (to_bl (w >>> n)) = take (size w - n) (to_bl w)\"\n  for w :: \"'a::len word\"", "lemma take_shiftr: \"n \\<le> size w \\<Longrightarrow> take n (to_bl (w >> n)) = replicate n False\"", "lemma take_sshiftr':\n  \"n \\<le> size w \\<Longrightarrow> hd (to_bl (w >>> n)) = hd (to_bl w) \\<and>\n    take n (to_bl (w >>> n)) = replicate n (hd (to_bl w))\"\n  for w :: \"'a::len word\"", "lemmas hd_sshiftr = take_sshiftr' [THEN conjunct1]", "lemmas take_sshiftr = take_sshiftr' [THEN conjunct2]", "lemma atd_lem: \"take n xs = t \\<Longrightarrow> drop n xs = d \\<Longrightarrow> xs = t @ d\"", "lemmas bl_shiftr = atd_lem [OF take_shiftr drop_shiftr]", "lemmas bl_sshiftr = atd_lem [OF take_sshiftr drop_sshiftr]", "lemma shiftl_of_bl: \"of_bl bl << n = of_bl (bl @ replicate n False)\"", "lemma shiftl_bl: \"w << n = of_bl (to_bl w @ replicate n False)\"\n  for w :: \"'a::len word\"", "lemma bl_shiftl: \"to_bl (w << n) = drop n (to_bl w) @ replicate (min (size w) n) False\"", "lemma shiftr1_bl_of:\n  \"length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    shiftr1 (of_bl bl::'a::len word) = of_bl (butlast bl)\"", "lemma shiftr_bl_of:\n  \"length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    (of_bl bl::'a::len word) >> n = of_bl (take (length bl - n) bl)\"", "lemma shiftr_bl: \"x >> n \\<equiv> of_bl (take (LENGTH('a) - n) (to_bl x))\"\n  for x :: \"'a::len word\"", "lemma aligned_bl_add_size [OF refl]:\n  \"size x - n = m \\<Longrightarrow> n \\<le> size x \\<Longrightarrow> drop m (to_bl x) = replicate n False \\<Longrightarrow>\n    take m (to_bl y) = replicate m False \\<Longrightarrow>\n    to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)\" for x :: \\<open>'a::len word\\<close>", "lemma mask_bl: \"mask n = of_bl (replicate n True)\"", "lemma bl_and_mask':\n  \"to_bl (w AND mask n :: 'a::len word) =\n    replicate (LENGTH('a) - n) False @\n    drop (LENGTH('a) - n) (to_bl w)\"", "lemma slice1_eq_of_bl:\n  \\<open>(slice1 n w :: 'b::len word) = of_bl (takefill False n (to_bl w))\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma slice1_no_bin [simp]:\n  \"slice1 n (numeral w :: 'b word) = of_bl (takefill False n (bin_to_bl (LENGTH('b::len)) (numeral w)))\"", "lemma slice_no_bin [simp]:\n  \"slice n (numeral w :: 'b word) = of_bl (takefill False (LENGTH('b::len) - n)\n    (bin_to_bl (LENGTH('b::len)) (numeral w)))\"", "lemma slice_take': \"slice n w = of_bl (take (size w - n) (to_bl w))\"", "lemmas slice_take = slice_take' [unfolded word_size]\n\n\\<comment> \\<open>shiftr to a word of the same size is just slice,\n    slice is just shiftr then ucast\\<close>", "lemmas shiftr_slice = trans [OF shiftr_bl [THEN meta_eq_to_obj_eq] slice_take [symmetric]]", "lemma slice1_down_alt':\n  \"sl = slice1 n w \\<Longrightarrow> fs = size sl \\<Longrightarrow> fs + k = n \\<Longrightarrow>\n    to_bl sl = takefill False fs (drop k (to_bl w))\"", "lemma slice1_up_alt':\n  \"sl = slice1 n w \\<Longrightarrow> fs = size sl \\<Longrightarrow> fs = n + k \\<Longrightarrow>\n    to_bl sl = takefill False fs (replicate k False @ (to_bl w))\"", "lemmas sd1 = slice1_down_alt' [OF refl refl, unfolded word_size]", "lemmas su1 = slice1_up_alt' [OF refl refl, unfolded word_size]", "lemmas slice1_down_alt = le_add_diff_inverse [THEN sd1]", "lemmas slice1_up_alts =\n  le_add_diff_inverse [symmetric, THEN su1]\n  le_add_diff_inverse2 [symmetric, THEN su1]", "lemma slice1_tf_tf':\n  \"to_bl (slice1 n w :: 'a::len word) =\n    rev (takefill False (LENGTH('a)) (rev (takefill False n (to_bl w))))\"", "lemmas slice1_tf_tf = slice1_tf_tf' [THEN word_bl.Rep_inverse', symmetric]", "lemma revcast_eq_of_bl:\n  \\<open>(revcast w :: 'b::len word) = of_bl (takefill False (LENGTH('b)) (to_bl w))\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemmas revcast_no_def [simp] = revcast_eq_of_bl [where w=\"numeral w\", unfolded word_size] for w", "lemma to_bl_revcast:\n  \"to_bl (revcast w :: 'a::len word) = takefill False (LENGTH('a)) (to_bl w)\"", "lemma word_cat_bl: \"word_cat a b = of_bl (to_bl a @ to_bl b)\"", "lemma of_bl_append:\n  \"(of_bl (xs @ ys) :: 'a::len word) = of_bl xs * 2^(length ys) + of_bl ys\"", "lemma of_bl_False [simp]: \"of_bl (False#xs) = of_bl xs\"", "lemma of_bl_True [simp]: \"(of_bl (True # xs) :: 'a::len word) = 2^length xs + of_bl xs\"", "lemma of_bl_Cons: \"of_bl (x#xs) = of_bool x * 2^length xs + of_bl xs\"", "lemma word_split_bl':\n  \"std = size c - size b \\<Longrightarrow> (word_split c = (a, b)) \\<Longrightarrow>\n    (a = of_bl (take std (to_bl c)) \\<and> b = of_bl (drop std (to_bl c)))\"", "lemma word_split_bl: \"std = size c - size b \\<Longrightarrow>\n    (a = of_bl (take std (to_bl c)) \\<and> b = of_bl (drop std (to_bl c))) \\<longleftrightarrow>\n    word_split c = (a, b)\"", "lemma word_split_bl_eq:\n  \"(word_split c :: ('c::len word \\<times> 'd::len word)) =\n    (of_bl (take (LENGTH('a::len) - LENGTH('d::len)) (to_bl c)),\n     of_bl (drop (LENGTH('a) - LENGTH('d)) (to_bl c)))\"\n  for c :: \"'a::len word\"", "lemma word_rcat_bl:\n  \\<open>word_rcat wl = of_bl (concat (map to_bl wl))\\<close>", "lemma size_rcat_lem': \"size (concat (map to_bl wl)) = length wl * size (hd wl)\"", "lemmas size_rcat_lem = size_rcat_lem' [unfolded word_size]", "lemma nth_rcat_lem:\n  \"n < length (wl::'a word list) * LENGTH('a::len) \\<Longrightarrow>\n    rev (concat (map to_bl wl)) ! n =\n    rev (to_bl (rev wl ! (n div LENGTH('a)))) ! (n mod LENGTH('a))\"", "lemma foldl_eq_foldr: \"foldl (+) x xs = foldr (+) (x # xs) 0\"\n  for x :: \"'a::comm_monoid_add\"", "lemmas word_cat_bl_no_bin [simp] =\n  word_cat_bl [where a=\"numeral a\" and b=\"numeral b\", unfolded to_bl_numeral]\n  for a b", "lemmas word_split_bl_no_bin [simp] =\n  word_split_bl_eq [where c=\"numeral c\", unfolded to_bl_numeral] for c", "lemmas word_rot_defs = word_roti_eq_word_rotr_word_rotl word_rotr_eq word_rotl_eq", "lemma to_bl_rotl: \"to_bl (word_rotl n w) = rotate n (to_bl w)\"", "lemmas blrs0 = rotate_eqs [THEN to_bl_rotl [THEN trans]]", "lemmas word_rotl_eqs =\n  blrs0 [simplified word_bl_Rep' word_bl.Rep_inject to_bl_rotl [symmetric]]", "lemma to_bl_rotr: \"to_bl (word_rotr n w) = rotater n (to_bl w)\"", "lemmas brrs0 = rotater_eqs [THEN to_bl_rotr [THEN trans]]", "lemmas word_rotr_eqs =\n  brrs0 [simplified word_bl_Rep' word_bl.Rep_inject to_bl_rotr [symmetric]]", "lemmas abl_cong = arg_cong [where f = \"of_bl\"]", "lemmas word_rot_defs' = to_bl_rotl to_bl_rotr", "lemmas blwl_syms [symmetric] = bl_word_not bl_word_and bl_word_or bl_word_xor", "lemmas lbl_lbl = trans [OF word_bl_Rep' word_bl_Rep' [symmetric]]", "lemmas ths_map2 [OF lbl_lbl] = rotate_map2 rotater_map2", "lemmas ths_map [where xs = \"to_bl v\"] = rotate_map rotater_map for v", "lemmas th1s [simplified word_rot_defs' [symmetric]] = ths_map2 ths_map", "lemmas bl_word_rotl_dt = trans [OF to_bl_rotl rotate_drop_take,\n  simplified word_bl_Rep']", "lemmas bl_word_rotr_dt = trans [OF to_bl_rotr rotater_drop_take,\n  simplified word_bl_Rep']", "lemma bl_word_roti_dt':\n  \"n = nat ((- i) mod int (size (w :: 'a::len word))) \\<Longrightarrow>\n    to_bl (word_roti i w) = drop n (to_bl w) @ take n (to_bl w)\"", "lemmas bl_word_roti_dt = bl_word_roti_dt' [unfolded word_size]", "lemmas word_rotl_dt = bl_word_rotl_dt [THEN word_bl.Rep_inverse' [symmetric]]", "lemmas word_rotr_dt = bl_word_rotr_dt [THEN word_bl.Rep_inverse' [symmetric]]", "lemmas word_roti_dt = bl_word_roti_dt [THEN word_bl.Rep_inverse' [symmetric]]", "lemmas word_rotr_dt_no_bin' [simp] =\n  word_rotr_dt [where w=\"numeral w\", unfolded to_bl_numeral] for w", "lemmas word_rotl_dt_no_bin' [simp] =\n  word_rotl_dt [where w=\"numeral w\", unfolded to_bl_numeral] for w", "lemma max_word_bl: \"to_bl (max_word::'a::len word) = replicate LENGTH('a) True\"", "lemma to_bl_mask:\n  \"to_bl (mask n :: 'a::len word) =\n  replicate (LENGTH('a) - n) False @\n    replicate (min (LENGTH('a)) n) True\"", "lemma map_replicate_True:\n  \"n = length xs \\<Longrightarrow>\n    map (\\<lambda>(x,y). x \\<and> y) (zip xs (replicate n True)) = xs\"", "lemma map_replicate_False:\n  \"n = length xs \\<Longrightarrow> map (\\<lambda>(x,y). x \\<and> y)\n    (zip xs (replicate n False)) = replicate n False\"", "lemma bl_and_mask:\n  fixes w :: \"'a::len word\"\n    and n :: nat\n  defines \"n' \\<equiv> LENGTH('a) - n\"\n  shows \"to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)\"", "lemma drop_rev_takefill:\n  \"length xs \\<le> n \\<Longrightarrow>\n    drop (n - length xs) (rev (takefill False n (rev xs))) = xs\"", "lemmas of_bl_reasoning = to_bl_use_of_bl of_bl_append", "lemma uint_of_bl_is_bl_to_bin_drop:\n  \"length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow> uint (of_bl l :: 'a::len word) = bl_to_bin l\"", "lemma bin_to_bl_or:\n  \"bin_to_bl n (a OR b) = map2 (\\<or>) (bin_to_bl n a) (bin_to_bl n b)\"", "lemma word_and_1_bl:\n  fixes x::\"'a::len word\"\n  shows \"(x AND 1) = of_bl [x !! 0]\"", "lemma word_1_and_bl:\n  fixes x::\"'a::len word\"\n  shows \"(1 AND x) = of_bl [x !! 0]\"", "lemma of_bl_drop:\n  \"of_bl (drop n xs) = (of_bl xs AND mask (length xs - n))\"", "lemma to_bl_1:\n  \"to_bl (1::'a::len word) = replicate (LENGTH('a) - 1) False @ [True]\"", "lemma eq_zero_set_bl:\n  \"(w = 0) = (True \\<notin> set (to_bl w))\"", "lemma of_drop_to_bl:\n  \"of_bl (drop n (to_bl x)) = (x AND mask (size x - n))\"", "lemma unat_of_bl_length:\n  \"unat (of_bl xs :: 'a::len word) < 2 ^ (length xs)\"", "lemma word_msb_alt: \"msb w \\<longleftrightarrow> hd (to_bl w)\"\n  for w :: \"'a::len word\"", "lemma word_lsb_last:\n  \\<open>lsb w \\<longleftrightarrow> last (to_bl w)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma is_aligned_to_bl:\n  \"is_aligned (w :: 'a :: len word) n = (True \\<notin> set (drop (size w - n) (to_bl w)))\"", "lemma is_aligned_replicate:\n  fixes w::\"'a::len word\"\n  assumes aligned: \"is_aligned w n\"\n  and          nv: \"n \\<le> LENGTH('a)\"\n  shows   \"to_bl w = (take (LENGTH('a) - n) (to_bl w)) @ replicate n False\"", "lemma is_aligned_drop:\n  fixes w::\"'a::len word\"\n  assumes \"is_aligned w n\" \"n \\<le> LENGTH('a)\"\n  shows \"drop (LENGTH('a) - n) (to_bl w) = replicate n False\"", "lemma less_is_drop_replicate:\n  fixes x::\"'a::len word\"\n  assumes lt: \"x < 2 ^ n\"\n  shows   \"to_bl x = replicate (LENGTH('a) - n) False @ drop (LENGTH('a) - n) (to_bl x)\"", "lemma is_aligned_add_conv:\n  fixes off::\"'a::len word\"\n  assumes aligned: \"is_aligned w n\"\n  and        offv: \"off < 2 ^ n\"\n  shows    \"to_bl (w + off) =\n   (take (LENGTH('a) - n) (to_bl w)) @ (drop (LENGTH('a) - n) (to_bl off))\"", "lemma is_aligned_replicateI:\n  \"to_bl p = addr @ replicate n False \\<Longrightarrow> is_aligned (p::'a::len word) n\"", "lemma to_bl_2p:\n  \"n < LENGTH('a) \\<Longrightarrow>\n   to_bl ((2::'a::len word) ^ n) =\n   replicate (LENGTH('a) - Suc n) False @ True # replicate n False\"", "lemma xor_2p_to_bl:\n  fixes x::\"'a::len word\"\n  shows \"to_bl (x XOR 2^n) =\n  (if n < LENGTH('a)\n   then take (LENGTH('a)-Suc n) (to_bl x) @ (\\<not>rev (to_bl x)!n) # drop (LENGTH('a)-n) (to_bl x)\n   else to_bl x)\"", "lemma is_aligned_replicateD:\n  \"\\<lbrakk> is_aligned (w::'a::len word) n; n \\<le> LENGTH('a) \\<rbrakk>\n     \\<Longrightarrow> \\<exists>xs. to_bl w = xs @ replicate n False\n               \\<and> length xs = size w - n\"", "lemma bl_pad_to_length:\n  assumes lbl: \"length bl \\<le> sz\"\n  shows   \"length (bl_pad_to bl sz) = sz\"", "lemma bl_pad_to_prefix:\n  \"prefix bl (bl_pad_to bl sz)\"", "lemma of_bl_length:\n  \"length xs < LENGTH('a) \\<Longrightarrow> of_bl xs < (2 :: 'a::len word) ^ length xs\"", "lemma of_bl_mult_and_not_mask_eq:\n  \"\\<lbrakk>is_aligned (a :: 'a::len word) n; length b + m \\<le> n\\<rbrakk>\n   \\<Longrightarrow> a + of_bl b * (2^m) AND NOT(mask n) = a\"", "lemma bin_to_bl_of_bl_eq:\n  \"\\<lbrakk>is_aligned (a::'a::len word) n; length b + c \\<le> n; length b + c < LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> bin_to_bl (length b) (uint ((a + of_bl b * 2^c) >> c)) = b\"", "lemma bin_nth_minus_Bit0[simp]:\n  \"0 < n \\<Longrightarrow> bin_nth (numeral (num.Bit0 w)) n = bin_nth (numeral w) (n - 1)\"", "lemma bin_nth_minus_Bit1[simp]:\n  \"0 < n \\<Longrightarrow> bin_nth (numeral (num.Bit1 w)) n = bin_nth (numeral w) (n - 1)\"", "lemma bl_cast_long_short_long_ingoreLeadingZero_generic:\n  \"\\<lbrakk> length (dropWhile Not (to_bl w)) \\<le> LENGTH('s); LENGTH('s) \\<le> LENGTH('l) \\<rbrakk> \\<Longrightarrow>\n   (of_bl :: _ \\<Rightarrow> 'l::len word) (to_bl ((of_bl::_ \\<Rightarrow> 's::len word) (to_bl w))) = w\"", "lemma length_drop_mask:\n  fixes w::\"'a::len word\"\n  shows \"length (dropWhile Not (to_bl (w AND mask n))) \\<le> n\"", "lemma map_bits_rev_to_bl:\n  \"map ((!!) x) [0..<size x] = rev (to_bl x)\"", "lemma of_bl_length2:\n  \"length xs + c < LENGTH('a) \\<Longrightarrow> of_bl xs * 2^c < (2::'a::len word) ^ (length xs + c)\"", "lemma of_bl_max:\n  \"(of_bl xs :: 'a::len word) \\<le> mask (length xs)\""], "translations": [["", "lemma horner_sum_of_bool_2_concat:\n  \\<open>horner_sum of_bool 2 (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) = horner_sum uint (2 ^ LENGTH('a)) ws\\<close>\n  for ws :: \\<open>'a::len word list\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_sum of_bool 2\n     (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n    horner_sum uint (2 ^ LENGTH('a)) ws", "proof (induction ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. horner_sum of_bool 2\n     (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) [])) =\n    horner_sum uint (2 ^ LENGTH('a)) []\n 2. \\<And>a ws.\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n       horner_sum uint (2 ^ LENGTH('a)) ws \\<Longrightarrow>\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (a # ws))) =\n       horner_sum uint (2 ^ LENGTH('a)) (a # ws)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. horner_sum of_bool 2\n     (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) [])) =\n    horner_sum uint (2 ^ LENGTH('a)) []\n 2. \\<And>a ws.\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n       horner_sum uint (2 ^ LENGTH('a)) ws \\<Longrightarrow>\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (a # ws))) =\n       horner_sum uint (2 ^ LENGTH('a)) (a # ws)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_sum of_bool 2\n     (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) [])) =\n    horner_sum uint (2 ^ LENGTH('a)) []", "by simp"], ["proof (state)\nthis:\n  horner_sum of_bool 2\n   (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) [])) =\n  horner_sum uint (2 ^ LENGTH('a)) []\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n       horner_sum uint (2 ^ LENGTH('a)) ws \\<Longrightarrow>\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (a # ws))) =\n       horner_sum uint (2 ^ LENGTH('a)) (a # ws)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n       horner_sum uint (2 ^ LENGTH('a)) ws \\<Longrightarrow>\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (a # ws))) =\n       horner_sum uint (2 ^ LENGTH('a)) (a # ws)", "case (Cons w ws)"], ["proof (state)\nthis:\n  horner_sum of_bool 2\n   (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n  horner_sum uint (2 ^ LENGTH('a)) ws\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n       horner_sum uint (2 ^ LENGTH('a)) ws \\<Longrightarrow>\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (a # ws))) =\n       horner_sum uint (2 ^ LENGTH('a)) (a # ws)", "moreover"], ["proof (state)\nthis:\n  horner_sum of_bool 2\n   (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n  horner_sum uint (2 ^ LENGTH('a)) ws\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n       horner_sum uint (2 ^ LENGTH('a)) ws \\<Longrightarrow>\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (a # ws))) =\n       horner_sum uint (2 ^ LENGTH('a)) (a # ws)", "have \\<open>horner_sum of_bool 2 (map (bit w) [0..<LENGTH('a)]) = uint w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. horner_sum of_bool 2 (map (bit w) [0..<LENGTH('a)]) = uint w", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       horner_sum of_bool 2\n        (map (\\<lambda>n. n < LENGTH('a) \\<and> bit w n) [0..<LENGTH('a)]) =\n       take_bit LENGTH('a) w", "fix k :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       horner_sum of_bool 2\n        (map (\\<lambda>n. n < LENGTH('a) \\<and> bit w n) [0..<LENGTH('a)]) =\n       take_bit LENGTH('a) w", "have \\<open>map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)]\n      = map (bit k) [0..<LENGTH('a)]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)] =\n    map (bit k) [0..<LENGTH('a)]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)] =\n  map (bit k) [0..<LENGTH('a)]\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       horner_sum of_bool 2\n        (map (\\<lambda>n. n < LENGTH('a) \\<and> bit w n) [0..<LENGTH('a)]) =\n       take_bit LENGTH('a) w", "then"], ["proof (chain)\npicking this:\n  map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)] =\n  map (bit k) [0..<LENGTH('a)]", "show \\<open>horner_sum of_bool 2 (map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)])\n      = take_bit LENGTH('a) k\\<close>"], ["proof (prove)\nusing this:\n  map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)] =\n  map (bit k) [0..<LENGTH('a)]\n\ngoal (1 subgoal):\n 1. horner_sum of_bool 2\n     (map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)]) =\n    take_bit LENGTH('a) k", "by (simp only: horner_sum_bit_eq_take_bit)"], ["proof (state)\nthis:\n  horner_sum of_bool 2\n   (map (\\<lambda>n. n < LENGTH('a) \\<and> bit k n) [0..<LENGTH('a)]) =\n  take_bit LENGTH('a) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  horner_sum of_bool 2 (map (bit w) [0..<LENGTH('a)]) = uint w\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n       horner_sum uint (2 ^ LENGTH('a)) ws \\<Longrightarrow>\n       horner_sum of_bool 2\n        (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (a # ws))) =\n       horner_sum uint (2 ^ LENGTH('a)) (a # ws)", "ultimately"], ["proof (chain)\npicking this:\n  horner_sum of_bool 2\n   (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n  horner_sum uint (2 ^ LENGTH('a)) ws\n  horner_sum of_bool 2 (map (bit w) [0..<LENGTH('a)]) = uint w", "show ?case"], ["proof (prove)\nusing this:\n  horner_sum of_bool 2\n   (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) ws)) =\n  horner_sum uint (2 ^ LENGTH('a)) ws\n  horner_sum of_bool 2 (map (bit w) [0..<LENGTH('a)]) = uint w\n\ngoal (1 subgoal):\n 1. horner_sum of_bool 2\n     (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (w # ws))) =\n    horner_sum uint (2 ^ LENGTH('a)) (w # ws)", "by (simp add: horner_sum_append)"], ["proof (state)\nthis:\n  horner_sum of_bool 2\n   (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('a)]) (w # ws))) =\n  horner_sum uint (2 ^ LENGTH('a)) (w # ws)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Implicit augmentation of list prefixes\\<close>"], ["", "primrec takefill :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n    Z: \"takefill fill 0 xs = []\"\n  | Suc: \"takefill fill (Suc n) xs =\n      (case xs of\n        [] \\<Rightarrow> fill # takefill fill n xs\n      | y # ys \\<Rightarrow> y # takefill fill n ys)\""], ["", "lemma nth_takefill: \"m < n \\<Longrightarrow> takefill fill n l ! m = (if m < length l then l ! m else fill)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow>\n    takefill fill n l ! m = (if m < length l then l ! m else fill)", "apply (induct n arbitrary: m l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m l.\n       m < 0 \\<Longrightarrow>\n       takefill fill 0 l ! m = (if m < length l then l ! m else fill)\n 2. \\<And>n m l.\n       \\<lbrakk>\\<And>m l.\n                   m < n \\<Longrightarrow>\n                   takefill fill n l ! m =\n                   (if m < length l then l ! m else fill);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> takefill fill (Suc n) l ! m =\n                         (if m < length l then l ! m else fill)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m l.\n       \\<lbrakk>\\<And>m l.\n                   m < n \\<Longrightarrow>\n                   takefill fill n l ! m =\n                   (if m < length l then l ! m else fill);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> takefill fill (Suc n) l ! m =\n                         (if m < length l then l ! m else fill)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m l.\n       \\<lbrakk>\\<And>m l.\n                   m < n \\<Longrightarrow>\n                   takefill fill n l ! m =\n                   (if m < length l then l ! m else fill);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> (m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          l ! m) \\<and>\n                         (\\<not> m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          fill)", "apply (case_tac m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m l.\n       \\<lbrakk>\\<And>m l.\n                   m < n \\<Longrightarrow>\n                   takefill fill n l ! m =\n                   (if m < length l then l ! m else fill);\n        m < Suc n; m = 0\\<rbrakk>\n       \\<Longrightarrow> (m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          l ! m) \\<and>\n                         (\\<not> m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          fill)\n 2. \\<And>n m l nat.\n       \\<lbrakk>\\<And>m l.\n                   m < n \\<Longrightarrow>\n                   takefill fill n l ! m =\n                   (if m < length l then l ! m else fill);\n        m < Suc n; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          l ! m) \\<and>\n                         (\\<not> m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          fill)", "apply (simp split: list.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m l nat.\n       \\<lbrakk>\\<And>m l.\n                   m < n \\<Longrightarrow>\n                   takefill fill n l ! m =\n                   (if m < length l then l ! m else fill);\n        m < Suc n; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          l ! m) \\<and>\n                         (\\<not> m < length l \\<longrightarrow>\n                          (case l of\n                           [] \\<Rightarrow> fill # takefill fill n l\n                           | y # ys \\<Rightarrow> y # takefill fill n ys) !\n                          m =\n                          fill)", "apply (simp split: list.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma takefill_alt: \"takefill fill n l = take n l @ replicate (n - length l) fill\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill fill n l = take n l @ replicate (n - length l) fill", "by (induct n arbitrary: l) (auto split: list.split)"], ["", "lemma takefill_replicate [simp]: \"takefill fill n (replicate m fill) = replicate n fill\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill fill n (replicate m fill) = replicate n fill", "by (simp add: takefill_alt replicate_add [symmetric])"], ["", "lemma takefill_le': \"n = m + k \\<Longrightarrow> takefill x m (takefill x n l) = takefill x m l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = m + k \\<Longrightarrow>\n    takefill x m (takefill x n l) = takefill x m l", "by (induct m arbitrary: l n) (auto split: list.split)"], ["", "lemma length_takefill [simp]: \"length (takefill fill n l) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takefill fill n l) = n", "by (simp add: takefill_alt)"], ["", "lemma take_takefill': \"n = k + m \\<Longrightarrow> take k (takefill fill n w) = takefill fill k w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = k + m \\<Longrightarrow>\n    take k (takefill fill n w) = takefill fill k w", "by (induct k arbitrary: w n) (auto split: list.split)"], ["", "lemma drop_takefill: \"drop k (takefill fill (m + k) w) = takefill fill m (drop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop k (takefill fill (m + k) w) = takefill fill m (drop k w)", "by (induct k arbitrary: w) (auto split: list.split)"], ["", "lemma takefill_le [simp]: \"m \\<le> n \\<Longrightarrow> takefill x m (takefill x n l) = takefill x m l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    takefill x m (takefill x n l) = takefill x m l", "by (auto simp: le_iff_add takefill_le')"], ["", "lemma take_takefill [simp]: \"m \\<le> n \\<Longrightarrow> take m (takefill fill n w) = takefill fill m w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    take m (takefill fill n w) = takefill fill m w", "by (auto simp: le_iff_add take_takefill')"], ["", "lemma takefill_append: \"takefill fill (m + length xs) (xs @ w) = xs @ (takefill fill m w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill fill (m + length xs) (xs @ w) = xs @ takefill fill m w", "by (induct xs) auto"], ["", "lemma takefill_same': \"l = length xs \\<Longrightarrow> takefill fill l xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = length xs \\<Longrightarrow> takefill fill l xs = xs", "by (induct xs arbitrary: l) auto"], ["", "lemmas takefill_same [simp] = takefill_same' [OF refl]"], ["", "lemma tf_rev:\n  \"n + k = m + length bl \\<Longrightarrow> takefill x m (rev (takefill y n bl)) =\n    rev (takefill y m (rev (takefill x k (rev bl))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + k = m + length bl \\<Longrightarrow>\n    takefill x m (rev (takefill y n bl)) =\n    rev (takefill y m (rev (takefill x k (rev bl))))", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + k = m + length bl \\<Longrightarrow>\n    length (takefill x m (rev (takefill y n bl))) =\n    length (rev (takefill y m (rev (takefill x k (rev bl)))))\n 2. \\<And>i.\n       \\<lbrakk>n + k = m + length bl;\n        i < length (takefill x m (rev (takefill y n bl)))\\<rbrakk>\n       \\<Longrightarrow> takefill x m (rev (takefill y n bl)) ! i =\n                         rev (takefill y m (rev (takefill x k (rev bl)))) !\n                         i", "apply (auto simp add: nth_takefill rev_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n + k = m + length bl; i < m; n - Suc i < length bl;\n        k + i - m < length bl; i < n; m - Suc i < k\\<rbrakk>\n       \\<Longrightarrow> bl ! (n - Suc i) =\n                         bl ! (length bl + m - Suc (k + i))", "apply (rule_tac f = \"\\<lambda>n. bl ! n\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n + k = m + length bl; i < m; n - Suc i < length bl;\n        k + i - m < length bl; i < n; m - Suc i < k\\<rbrakk>\n       \\<Longrightarrow> n - Suc i = length bl + m - Suc (k + i)", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma takefill_minus: \"0 < n \\<Longrightarrow> takefill fill (Suc (n - 1)) w = takefill fill n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    takefill fill (Suc (n - 1)) w = takefill fill n w", "by auto"], ["", "lemmas takefill_Suc_cases =\n  list.cases [THEN takefill.Suc [THEN trans]]"], ["", "lemmas takefill_Suc_Nil = takefill_Suc_cases (1)"], ["", "lemmas takefill_Suc_Cons = takefill_Suc_cases (2)"], ["", "lemmas takefill_minus_simps = takefill_Suc_cases [THEN [2]\n  takefill_minus [symmetric, THEN trans]]"], ["", "lemma takefill_numeral_Nil [simp]:\n  \"takefill fill (numeral k) [] = fill # takefill fill (pred_numeral k) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill fill (numeral k) [] = fill # takefill fill (pred_numeral k) []", "by (simp add: numeral_eq_Suc)"], ["", "lemma takefill_numeral_Cons [simp]:\n  \"takefill fill (numeral k) (x # xs) = x # takefill fill (pred_numeral k) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill fill (numeral k) (x # xs) =\n    x # takefill fill (pred_numeral k) xs", "by (simp add: numeral_eq_Suc)"], ["", "subsection \\<open>Range projection\\<close>"], ["", "definition bl_of_nth :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a list\"\n  where \"bl_of_nth n f = map f (rev [0..<n])\""], ["", "lemma bl_of_nth_simps [simp, code]:\n  \"bl_of_nth 0 f = []\"\n  \"bl_of_nth (Suc n) f = f n # bl_of_nth n f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_of_nth 0 f = [] &&& bl_of_nth (Suc n) f = f n # bl_of_nth n f", "by (simp_all add: bl_of_nth_def)"], ["", "lemma length_bl_of_nth [simp]: \"length (bl_of_nth n f) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bl_of_nth n f) = n", "by (simp add: bl_of_nth_def)"], ["", "lemma nth_bl_of_nth [simp]: \"m < n \\<Longrightarrow> rev (bl_of_nth n f) ! m = f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> rev (bl_of_nth n f) ! m = f m", "by (simp add: bl_of_nth_def rev_map)"], ["", "lemma bl_of_nth_inj: \"(\\<And>k. k < n \\<Longrightarrow> f k = g k) \\<Longrightarrow> bl_of_nth n f = bl_of_nth n g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. k < n \\<Longrightarrow> f k = g k) \\<Longrightarrow>\n    bl_of_nth n f = bl_of_nth n g", "by (simp add: bl_of_nth_def)"], ["", "lemma bl_of_nth_nth_le: \"n \\<le> length xs \\<Longrightarrow> bl_of_nth n (nth (rev xs)) = drop (length xs - n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs", "apply (induct n arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 \\<le> length xs \\<Longrightarrow>\n       bl_of_nth 0 ((!) (rev xs)) = drop (length xs - 0) xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> bl_of_nth (Suc n) ((!) (rev xs)) =\n                         drop (length xs - Suc n) xs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> bl_of_nth (Suc n) ((!) (rev xs)) =\n                         drop (length xs - Suc n) xs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> rev xs ! n # drop (length xs - n) xs =\n                         drop (length xs - Suc n) xs", "apply (rule trans [OF _ hd_Cons_tl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> rev xs ! n # drop (length xs - n) xs =\n                         hd (drop (length xs - Suc n) xs) #\n                         tl (drop (length xs - Suc n) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> drop (length xs - Suc n) xs \\<noteq> []", "apply (frule Suc_le_lessD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs; n < length xs\\<rbrakk>\n       \\<Longrightarrow> rev xs ! n # drop (length xs - n) xs =\n                         hd (drop (length xs - Suc n) xs) #\n                         tl (drop (length xs - Suc n) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> drop (length xs - Suc n) xs \\<noteq> []", "apply (simp add: rev_nth trans [OF drop_Suc drop_tl, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) =\n                         hd (drop (length xs - Suc n) xs) \\<and>\n                         drop (length xs - n) xs =\n                         drop (Suc (length xs - Suc n)) xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> drop (length xs - Suc n) xs \\<noteq> []", "apply (subst hd_drop_conv_nth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> length xs - Suc n < length xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) =\n                         xs ! (length xs - Suc n) \\<and>\n                         drop (length xs - n) xs =\n                         drop (Suc (length xs - Suc n)) xs\n 3. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> drop (length xs - Suc n) xs \\<noteq> []", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) =\n                         xs ! (length xs - Suc n) \\<and>\n                         drop (length xs - n) xs =\n                         drop (Suc (length xs - Suc n)) xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> drop (length xs - Suc n) xs \\<noteq> []", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> drop (length xs - n) xs =\n                         drop (Suc (length xs - Suc n)) xs", "apply (rule_tac f = \"\\<lambda>n. drop n xs\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n \\<le> length xs \\<Longrightarrow>\n                   bl_of_nth n ((!) (rev xs)) = drop (length xs - n) xs;\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> length xs - n = Suc (length xs - Suc n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_of_nth_nth [simp]: \"bl_of_nth (length xs) ((!) (rev xs)) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_of_nth (length xs) ((!) (rev xs)) = xs", "by (simp add: bl_of_nth_nth_le)"], ["", "subsection \\<open>More\\<close>"], ["", "definition rotater1 :: \"'a list \\<Rightarrow> 'a list\"\n  where \"rotater1 ys =\n    (case ys of [] \\<Rightarrow> [] | x # xs \\<Rightarrow> last ys # butlast ys)\""], ["", "definition rotater :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\n  where \"rotater n = rotater1 ^^ n\""], ["", "lemmas rotater_0' [simp] = rotater_def [where n = \"0\", simplified]"], ["", "lemma rotate1_rl': \"rotater1 (l @ [a]) = a # l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater1 (l @ [a]) = a # l", "by (cases l) (auto simp: rotater1_def)"], ["", "lemma rotate1_rl [simp] : \"rotater1 (rotate1 l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater1 (rotate1 l) = l", "apply (unfold rotater1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rotate1 l of [] \\<Rightarrow> []\n     | x # xs \\<Rightarrow> last (rotate1 l) # butlast (rotate1 l)) =\n    l", "apply (cases \"l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (case rotate1 l of [] \\<Rightarrow> []\n     | x # xs \\<Rightarrow> last (rotate1 l) # butlast (rotate1 l)) =\n    l\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       (case rotate1 l of [] \\<Rightarrow> []\n        | x # xs \\<Rightarrow> last (rotate1 l) # butlast (rotate1 l)) =\n       l", "apply (case_tac [2] \"list\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (case rotate1 l of [] \\<Rightarrow> []\n     | x # xs \\<Rightarrow> last (rotate1 l) # butlast (rotate1 l)) =\n    l\n 2. \\<And>a list.\n       \\<lbrakk>l = a # list; list = []\\<rbrakk>\n       \\<Longrightarrow> (case rotate1 l of [] \\<Rightarrow> []\n                          | x # xs \\<Rightarrow>\n                              last (rotate1 l) # butlast (rotate1 l)) =\n                         l\n 3. \\<And>a list aa lista.\n       \\<lbrakk>l = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> (case rotate1 l of [] \\<Rightarrow> []\n                          | x # xs \\<Rightarrow>\n                              last (rotate1 l) # butlast (rotate1 l)) =\n                         l", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rotate1_lr [simp] : \"rotate1 (rotater1 l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate1 (rotater1 l) = l", "by (cases l) (auto simp: rotater1_def)"], ["", "lemma rotater1_rev': \"rotater1 (rev xs) = rev (rotate1 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater1 (rev xs) = rev (rotate1 xs)", "by (cases \"xs\") (simp add: rotater1_def, simp add: rotate1_rl')"], ["", "lemma rotater_rev': \"rotater n (rev xs) = rev (rotate n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater n (rev xs) = rev (rotate n xs)", "by (induct n) (auto simp: rotater_def intro: rotater1_rev')"], ["", "lemma rotater_rev: \"rotater n ys = rev (rotate n (rev ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater n ys = rev (rotate n (rev ys))", "using rotater_rev' [where xs = \"rev ys\"]"], ["proof (prove)\nusing this:\n  rotater ?n (rev (rev ys)) = rev (rotate ?n (rev ys))\n\ngoal (1 subgoal):\n 1. rotater n ys = rev (rotate n (rev ys))", "by simp"], ["", "lemma rotater_drop_take:\n  \"rotater n xs =\n    drop (length xs - n mod length xs) xs @\n    take (length xs - n mod length xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater n xs =\n    drop (length xs - n mod length xs) xs @\n    take (length xs - n mod length xs) xs", "by (auto simp: rotater_rev rotate_drop_take rev_take rev_drop)"], ["", "lemma rotater_Suc [simp]: \"rotater (Suc n) xs = rotater1 (rotater n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater (Suc n) xs = rotater1 (rotater n xs)", "unfolding rotater_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rotater1 ^^ Suc n) xs = rotater1 ((rotater1 ^^ n) xs)", "by auto"], ["", "lemma nth_rotater:\n  \\<open>rotater m xs ! n = xs ! ((n + (length xs - m mod length xs)) mod length xs)\\<close> if \\<open>n < length xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater m xs ! n =\n    xs ! ((n + (length xs - m mod length xs)) mod length xs)", "using that"], ["proof (prove)\nusing this:\n  n < length xs\n\ngoal (1 subgoal):\n 1. rotater m xs ! n =\n    xs ! ((n + (length xs - m mod length xs)) mod length xs)", "by (simp add: rotater_drop_take nth_append not_less less_diff_conv ac_simps le_mod_geq)"], ["", "lemma nth_rotater1:\n  \\<open>rotater1 xs ! n = xs ! ((n + (length xs - 1)) mod length xs)\\<close> if \\<open>n < length xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater1 xs ! n = xs ! ((n + (length xs - 1)) mod length xs)", "using that nth_rotater [of n xs 1]"], ["proof (prove)\nusing this:\n  n < length xs\n  n < length xs \\<Longrightarrow>\n  rotater 1 xs ! n =\n  xs ! ((n + (length xs - 1 mod length xs)) mod length xs)\n\ngoal (1 subgoal):\n 1. rotater1 xs ! n = xs ! ((n + (length xs - 1)) mod length xs)", "by simp"], ["", "lemma rotate_inv_plus [rule_format]:\n  \"\\<forall>k. k = m + n \\<longrightarrow> rotater k (rotate n xs) = rotater m xs \\<and>\n    rotate k (rotater n xs) = rotate m xs \\<and>\n    rotater n (rotate k xs) = rotate m xs \\<and>\n    rotate n (rotater k xs) = rotater m xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       k = m + n \\<longrightarrow>\n       rotater k (rotate n xs) = rotater m xs \\<and>\n       rotate k (rotater n xs) = rotate m xs \\<and>\n       rotater n (rotate k xs) = rotate m xs \\<and>\n       rotate n (rotater k xs) = rotater m xs", "by (induct n) (auto simp: rotater_def rotate_def intro: funpow_swap1 [THEN trans])"], ["", "lemmas rotate_inv_rel = le_add_diff_inverse2 [symmetric, THEN rotate_inv_plus]"], ["", "lemmas rotate_inv_eq = order_refl [THEN rotate_inv_rel, simplified]"], ["", "lemmas rotate_lr [simp] = rotate_inv_eq [THEN conjunct1]"], ["", "lemmas rotate_rl [simp] = rotate_inv_eq [THEN conjunct2, THEN conjunct1]"], ["", "lemma rotate_gal: \"rotater n xs = ys \\<longleftrightarrow> rotate n ys = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rotater n xs = ys) = (rotate n ys = xs)", "by auto"], ["", "lemma rotate_gal': \"ys = rotater n xs \\<longleftrightarrow> xs = rotate n ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys = rotater n xs) = (xs = rotate n ys)", "by auto"], ["", "lemma length_rotater [simp]: \"length (rotater n xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rotater n xs) = length xs", "by (simp add : rotater_rev)"], ["", "lemma rotate_eq_mod: \"m mod length xs = n mod length xs \\<Longrightarrow> rotate m xs = rotate n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod length xs = n mod length xs \\<Longrightarrow>\n    rotate m xs = rotate n xs", "apply (rule box_equals)"], ["proof (prove)\ngoal (3 subgoals):\n 1. m mod length xs = n mod length xs \\<Longrightarrow> ?a = ?b\n 2. m mod length xs = n mod length xs \\<Longrightarrow> ?a = rotate m xs\n 3. m mod length xs = n mod length xs \\<Longrightarrow> ?b = rotate n xs", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. m mod length xs = n mod length xs \\<Longrightarrow> ?a = rotate m xs\n 2. m mod length xs = n mod length xs \\<Longrightarrow> ?b = rotate n xs\n 3. m mod length xs = n mod length xs \\<Longrightarrow> ?a = ?b", "apply (rule rotate_conv_mod [symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod length xs = n mod length xs \\<Longrightarrow>\n    rotate (m mod length xs) xs = rotate (n mod length xs) xs", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_to_left: \"x = y \\<Longrightarrow> x = z \\<longleftrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> (x = z) = (y = z)", "by simp"], ["", "lemmas rotate_eqs =\n  trans [OF rotate0 [THEN fun_cong] id_apply]\n  rotate_rotate [symmetric]\n  rotate_id\n  rotate_conv_mod\n  rotate_eq_mod"], ["", "lemmas rrs0 = rotate_eqs [THEN restrict_to_left,\n  simplified rotate_gal [symmetric] rotate_gal' [symmetric]]"], ["", "lemmas rrs1 = rrs0 [THEN refl [THEN rev_iffD1]]"], ["", "lemmas rotater_eqs = rrs1 [simplified length_rotater]"], ["", "lemmas rotater_0 = rotater_eqs (1)"], ["", "lemmas rotater_add = rotater_eqs (2)"], ["", "lemma butlast_map: \"xs \\<noteq> [] \\<Longrightarrow> butlast (map f xs) = map f (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> butlast (map f xs) = map f (butlast xs)", "by (induct xs) auto"], ["", "lemma rotater1_map: \"rotater1 (map f xs) = map f (rotater1 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater1 (map f xs) = map f (rotater1 xs)", "by (cases xs) (auto simp: rotater1_def last_map butlast_map)"], ["", "lemma rotater_map: \"rotater n (map f xs) = map f (rotater n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotater n (map f xs) = map f (rotater n xs)", "by (induct n) (auto simp: rotater_def rotater1_map)"], ["", "lemma but_last_zip [rule_format] :\n  \"\\<forall>ys. length xs = length ys \\<longrightarrow> xs \\<noteq> [] \\<longrightarrow>\n    last (zip xs ys) = (last xs, last ys) \\<and>\n    butlast (zip xs ys) = zip (butlast xs) (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys.\n       length xs = length ys \\<longrightarrow>\n       xs \\<noteq> [] \\<longrightarrow>\n       last (zip xs ys) = (last xs, last ys) \\<and>\n       butlast (zip xs ys) = zip (butlast xs) (butlast ys)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>ys.\n       length [] = length ys \\<longrightarrow>\n       [] \\<noteq> [] \\<longrightarrow>\n       last (zip [] ys) = (last [], last ys) \\<and>\n       butlast (zip [] ys) = zip (butlast []) (butlast ys)\n 2. \\<And>a xs.\n       \\<forall>ys.\n          length xs = length ys \\<longrightarrow>\n          xs \\<noteq> [] \\<longrightarrow>\n          last (zip xs ys) = (last xs, last ys) \\<and>\n          butlast (zip xs ys) =\n          zip (butlast xs) (butlast ys) \\<Longrightarrow>\n       \\<forall>ys.\n          length (a # xs) = length ys \\<longrightarrow>\n          a # xs \\<noteq> [] \\<longrightarrow>\n          last (zip (a # xs) ys) = (last (a # xs), last ys) \\<and>\n          butlast (zip (a # xs) ys) = zip (butlast (a # xs)) (butlast ys)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a ys.\n       Suc 0 = length ys \\<Longrightarrow> last (zip [a] ys) = (a, last ys)\n 2. \\<And>a ys.\n       Suc 0 = length ys \\<Longrightarrow> butlast (zip [a] ys) = []\n 3. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   length xs = length ys \\<longrightarrow>\n                   last (zip xs ys) = (last xs, last ys) \\<and>\n                   butlast (zip xs ys) = zip (butlast xs) (butlast ys);\n        xs \\<noteq> []; Suc (length xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> last (zip (a # xs) ys) = (last xs, last ys)\n 4. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   length xs = length ys \\<longrightarrow>\n                   last (zip xs ys) = (last xs, last ys) \\<and>\n                   butlast (zip xs ys) = zip (butlast xs) (butlast ys);\n        xs \\<noteq> []; Suc (length xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> butlast (zip (a # xs) ys) =\n                         zip (a # butlast xs) (butlast ys)", "apply ((case_tac ys, auto simp: neq_Nil_conv)[1])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma but_last_map2 [rule_format] :\n  \"\\<forall>ys. length xs = length ys \\<longrightarrow> xs \\<noteq> [] \\<longrightarrow>\n    last (map2 f xs ys) = f (last xs) (last ys) \\<and>\n    butlast (map2 f xs ys) = map2 f (butlast xs) (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys.\n       length xs = length ys \\<longrightarrow>\n       xs \\<noteq> [] \\<longrightarrow>\n       last (map2 f xs ys) = f (last xs) (last ys) \\<and>\n       butlast (map2 f xs ys) = map2 f (butlast xs) (butlast ys)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>ys.\n       length [] = length ys \\<longrightarrow>\n       [] \\<noteq> [] \\<longrightarrow>\n       last (map2 f [] ys) = f (last []) (last ys) \\<and>\n       butlast (map2 f [] ys) = map2 f (butlast []) (butlast ys)\n 2. \\<And>a xs.\n       \\<forall>ys.\n          length xs = length ys \\<longrightarrow>\n          xs \\<noteq> [] \\<longrightarrow>\n          last (map2 f xs ys) = f (last xs) (last ys) \\<and>\n          butlast (map2 f xs ys) =\n          map2 f (butlast xs) (butlast ys) \\<Longrightarrow>\n       \\<forall>ys.\n          length (a # xs) = length ys \\<longrightarrow>\n          a # xs \\<noteq> [] \\<longrightarrow>\n          last (map2 f (a # xs) ys) = f (last (a # xs)) (last ys) \\<and>\n          butlast (map2 f (a # xs) ys) =\n          map2 f (butlast (a # xs)) (butlast ys)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a ys.\n       Suc 0 = length ys \\<Longrightarrow>\n       last (map2 f [a] ys) = f a (last ys)\n 2. \\<And>a ys.\n       Suc 0 = length ys \\<Longrightarrow> butlast (map2 f [a] ys) = []\n 3. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   length xs = length ys \\<longrightarrow>\n                   last (map2 f xs ys) = f (last xs) (last ys) \\<and>\n                   butlast (map2 f xs ys) =\n                   map2 f (butlast xs) (butlast ys);\n        xs \\<noteq> []; Suc (length xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> last (map2 f (a # xs) ys) = f (last xs) (last ys)\n 4. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   length xs = length ys \\<longrightarrow>\n                   last (map2 f xs ys) = f (last xs) (last ys) \\<and>\n                   butlast (map2 f xs ys) =\n                   map2 f (butlast xs) (butlast ys);\n        xs \\<noteq> []; Suc (length xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> butlast (map2 f (a # xs) ys) =\n                         map2 f (a # butlast xs) (butlast ys)", "apply ((case_tac ys, auto simp: neq_Nil_conv)[1])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rotater1_zip:\n  \"length xs = length ys \\<Longrightarrow>\n    rotater1 (zip xs ys) = zip (rotater1 xs) (rotater1 ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rotater1 (zip xs ys) = zip (rotater1 xs) (rotater1 ys)", "apply (unfold rotater1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    (case zip xs ys of [] \\<Rightarrow> []\n     | x # xsa \\<Rightarrow> last (zip xs ys) # butlast (zip xs ys)) =\n    zip (case xs of [] \\<Rightarrow> []\n         | x # xsa \\<Rightarrow> last xs # butlast xs)\n     (case ys of [] \\<Rightarrow> []\n      | x # xs \\<Rightarrow> last ys # butlast ys)", "apply (cases xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = length ys; xs = []\\<rbrakk>\n    \\<Longrightarrow> (case zip xs ys of [] \\<Rightarrow> []\n                       | x # xsa \\<Rightarrow>\n                           last (zip xs ys) # butlast (zip xs ys)) =\n                      zip (case xs of [] \\<Rightarrow> []\n                           | x # xsa \\<Rightarrow> last xs # butlast xs)\n                       (case ys of [] \\<Rightarrow> []\n                        | x # xs \\<Rightarrow> last ys # butlast ys)\n 2. \\<And>a list.\n       \\<lbrakk>length xs = length ys; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (case zip xs ys of [] \\<Rightarrow> []\n                          | x # xsa \\<Rightarrow>\n                              last (zip xs ys) # butlast (zip xs ys)) =\n                         zip (case xs of [] \\<Rightarrow> []\n                              | x # xsa \\<Rightarrow> last xs # butlast xs)\n                          (case ys of [] \\<Rightarrow> []\n                           | x # xs \\<Rightarrow> last ys # butlast ys)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>Suc 0 = length ys; xs = [a]\\<rbrakk>\n       \\<Longrightarrow> (case zip [a] ys of [] \\<Rightarrow> []\n                          | x # xs \\<Rightarrow>\n                              last (zip [a] ys) # butlast (zip [a] ys)) =\n                         zip [a]\n                          (case ys of [] \\<Rightarrow> []\n                           | x # xs \\<Rightarrow> last ys # butlast ys)\n 2. \\<And>a list.\n       \\<lbrakk>Suc (length list) = length ys; xs = a # list;\n        list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case zip (a # list) ys of [] \\<Rightarrow> []\n                          | x # xs \\<Rightarrow>\n                              last (zip (a # list) ys) #\n                              butlast (zip (a # list) ys)) =\n                         zip (last list # a # butlast list)\n                          (case ys of [] \\<Rightarrow> []\n                           | x # xs \\<Rightarrow> last ys # butlast ys)", "apply ((case_tac ys, auto simp: neq_Nil_conv but_last_zip)[1])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rotater1_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotater1 (map2 f xs ys) = map2 f (rotater1 xs) (rotater1 ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rotater1 (map2 f xs ys) = map2 f (rotater1 xs) (rotater1 ys)", "by (simp add: rotater1_map rotater1_zip)"], ["", "lemmas lrth =\n  box_equals [OF asm_rl length_rotater [symmetric]\n                 length_rotater [symmetric],\n              THEN rotater1_map2]"], ["", "lemma rotater_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotater n (map2 f xs ys) = map2 f (rotater n xs) (rotater n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rotater n (map2 f xs ys) = map2 f (rotater n xs) (rotater n ys)", "by (induct n) (auto intro!: lrth)"], ["", "lemma rotate1_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotate1 (map2 f xs ys) = map2 f (rotate1 xs) (rotate1 ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rotate1 (map2 f xs ys) = map2 f (rotate1 xs) (rotate1 ys)", "by (cases xs; cases ys) auto"], ["", "lemmas lth = box_equals [OF asm_rl length_rotate [symmetric]\n  length_rotate [symmetric], THEN rotate1_map2]"], ["", "lemma rotate_map2:\n  \"length xs = length ys \\<Longrightarrow>\n    rotate n (map2 f xs ys) = map2 f (rotate n xs) (rotate n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rotate n (map2 f xs ys) = map2 f (rotate n xs) (rotate n ys)", "by (induct n) (auto intro!: lth)"], ["", "subsection \\<open>Explicit bit representation of \\<^typ>\\<open>int\\<close>\\<close>"], ["", "primrec bl_to_bin_aux :: \"bool list \\<Rightarrow> int \\<Rightarrow> int\"\n  where\n    Nil: \"bl_to_bin_aux [] w = w\"\n  | Cons: \"bl_to_bin_aux (b # bs) w = bl_to_bin_aux bs (of_bool b + 2 * w)\""], ["", "definition bl_to_bin :: \"bool list \\<Rightarrow> int\"\n  where \"bl_to_bin bs = bl_to_bin_aux bs 0\""], ["", "primrec bin_to_bl_aux :: \"nat \\<Rightarrow> int \\<Rightarrow> bool list \\<Rightarrow> bool list\"\n  where\n    Z: \"bin_to_bl_aux 0 w bl = bl\"\n  | Suc: \"bin_to_bl_aux (Suc n) w bl = bin_to_bl_aux n (bin_rest w) ((bin_last w) # bl)\""], ["", "definition bin_to_bl :: \"nat \\<Rightarrow> int \\<Rightarrow> bool list\"\n  where \"bin_to_bl n w = bin_to_bl_aux n w []\""], ["", "lemma bin_to_bl_aux_zero_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n 0 bl = bin_to_bl_aux (n - 1) 0 (False # bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bin_to_bl_aux n 0 bl = bin_to_bl_aux (n - 1) 0 (False # bl)", "by (cases n) auto"], ["", "lemma bin_to_bl_aux_minus1_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n (- 1) bl = bin_to_bl_aux (n - 1) (- 1) (True # bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (- 1) bl = bin_to_bl_aux (n - 1) (- 1) (True # bl)", "by (cases n) auto"], ["", "lemma bin_to_bl_aux_one_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n 1 bl = bin_to_bl_aux (n - 1) 0 (True # bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bin_to_bl_aux n 1 bl = bin_to_bl_aux (n - 1) 0 (True # bl)", "by (cases n) auto"], ["", "lemma bin_to_bl_aux_Bit0_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (numeral (Num.Bit0 w)) bl = bin_to_bl_aux (n - 1) (numeral w) (False # bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (numeral (num.Bit0 w)) bl =\n    bin_to_bl_aux (n - 1) (numeral w) (False # bl)", "by (cases n) simp_all"], ["", "lemma bin_to_bl_aux_Bit1_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (numeral (Num.Bit1 w)) bl = bin_to_bl_aux (n - 1) (numeral w) (True # bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (numeral (num.Bit1 w)) bl =\n    bin_to_bl_aux (n - 1) (numeral w) (True # bl)", "by (cases n) simp_all"], ["", "lemma bl_to_bin_aux_append: \"bl_to_bin_aux (bs @ cs) w = bl_to_bin_aux cs (bl_to_bin_aux bs w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin_aux (bs @ cs) w = bl_to_bin_aux cs (bl_to_bin_aux bs w)", "by (induct bs arbitrary: w) auto"], ["", "lemma bin_to_bl_aux_append: \"bin_to_bl_aux n w bs @ cs = bin_to_bl_aux n w (bs @ cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl_aux n w bs @ cs = bin_to_bl_aux n w (bs @ cs)", "by (induct n arbitrary: w bs) auto"], ["", "lemma bl_to_bin_append: \"bl_to_bin (bs @ cs) = bl_to_bin_aux cs (bl_to_bin bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (bs @ cs) = bl_to_bin_aux cs (bl_to_bin bs)", "unfolding bl_to_bin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin_aux (bs @ cs) 0 = bl_to_bin_aux cs (bl_to_bin_aux bs 0)", "by (rule bl_to_bin_aux_append)"], ["", "lemma bin_to_bl_aux_alt: \"bin_to_bl_aux n w bs = bin_to_bl n w @ bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl_aux n w bs = bin_to_bl n w @ bs", "by (simp add: bin_to_bl_def bin_to_bl_aux_append)"], ["", "lemma bin_to_bl_0 [simp]: \"bin_to_bl 0 bs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl 0 bs = []", "by (auto simp: bin_to_bl_def)"], ["", "lemma size_bin_to_bl_aux: \"length (bin_to_bl_aux n w bs) = n + length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bin_to_bl_aux n w bs) = n + length bs", "by (induct n arbitrary: w bs) auto"], ["", "lemma size_bin_to_bl [simp]: \"length (bin_to_bl n w) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bin_to_bl n w) = n", "by (simp add: bin_to_bl_def size_bin_to_bl_aux)"], ["", "lemma bl_bin_bl': \"bin_to_bl (n + length bs) (bl_to_bin_aux bs w) = bin_to_bl_aux n w bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl (n + length bs) (bl_to_bin_aux bs w) = bin_to_bl_aux n w bs", "apply (induct bs arbitrary: w n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w n.\n       bin_to_bl (n + length []) (bl_to_bin_aux [] w) = bin_to_bl_aux n w []\n 2. \\<And>a bs w n.\n       (\\<And>w n.\n           bin_to_bl (n + length bs) (bl_to_bin_aux bs w) =\n           bin_to_bl_aux n w bs) \\<Longrightarrow>\n       bin_to_bl (n + length (a # bs)) (bl_to_bin_aux (a # bs) w) =\n       bin_to_bl_aux n w (a # bs)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w n. bin_to_bl n w = bin_to_bl_aux n w []\n 2. \\<And>a bs w n.\n       \\<lbrakk>\\<And>w n.\n                   bin_to_bl (n + length bs) (bl_to_bin_aux bs w) =\n                   bin_to_bl_aux n w bs;\n        a\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl (Suc (n + length bs))\n                          (bl_to_bin_aux bs (1 + 2 * w)) =\n                         bin_to_bl_aux n w (True # bs)\n 3. \\<And>a bs w n.\n       \\<lbrakk>\\<And>w n.\n                   bin_to_bl (n + length bs) (bl_to_bin_aux bs w) =\n                   bin_to_bl_aux n w bs;\n        \\<not> a\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl (Suc (n + length bs))\n                          (bl_to_bin_aux bs (2 * w)) =\n                         bin_to_bl_aux n w (False # bs)", "apply (simp_all only: add_Suc [symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w n. bin_to_bl n w = bin_to_bl_aux n w []\n 2. \\<And>a bs w n.\n       \\<lbrakk>\\<And>w n.\n                   bin_to_bl (n + length bs) (bl_to_bin_aux bs w) =\n                   bin_to_bl_aux n w bs;\n        a\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux (Suc n) (1 + 2 * w) bs =\n                         bin_to_bl_aux n w (True # bs)\n 3. \\<And>a bs w n.\n       \\<lbrakk>\\<And>w n.\n                   bin_to_bl (n + length bs) (bl_to_bin_aux bs w) =\n                   bin_to_bl_aux n w bs;\n        \\<not> a\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux (Suc n) (2 * w) bs =\n                         bin_to_bl_aux n w (False # bs)", "apply (auto simp add: bin_to_bl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_bin_bl [simp]: \"bin_to_bl (length bs) (bl_to_bin bs) = bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl (length bs) (bl_to_bin bs) = bs", "unfolding bl_to_bin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl (length bs) (bl_to_bin_aux bs 0) = bs", "apply (rule box_equals)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?a = ?b\n 2. ?a = bin_to_bl (length bs) (bl_to_bin_aux bs 0)\n 3. ?b = bs", "apply (rule bl_bin_bl')"], ["proof (prove)\ngoal (2 subgoals):\n 1. bin_to_bl (?n4 + length ?bs4) (bl_to_bin_aux ?bs4 ?w4) =\n    bin_to_bl (length bs) (bl_to_bin_aux bs 0)\n 2. bin_to_bl_aux ?n4 ?w4 ?bs4 = bs", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. bin_to_bl_aux ?n4 ?w4 ?bs4 = bs\n 2. bin_to_bl (?n4 + length ?bs4) (bl_to_bin_aux ?bs4 ?w4) =\n    bin_to_bl (length bs) (bl_to_bin_aux bs 0)", "apply (rule bin_to_bl_aux.Z)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl (0 + length bs) (bl_to_bin_aux bs ?w4) =\n    bin_to_bl (length bs) (bl_to_bin_aux bs 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_to_bin_inj: \"bl_to_bin bs = bl_to_bin cs \\<Longrightarrow> length bs = length cs \\<Longrightarrow> bs = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> bs = cs", "apply (rule_tac box_equals)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> ?a = ?b\n 2. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> ?a = bs\n 3. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> ?b = cs", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> ?a = bs\n 2. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> ?b = cs\n 3. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> ?a = ?b", "apply (rule bl_bin_bl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> ?b = cs\n 2. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> bin_to_bl (length bs) (bl_to_bin bs) = ?b", "apply (rule bl_bin_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bl_to_bin bs = bl_to_bin cs; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> bin_to_bl (length bs) (bl_to_bin bs) =\n                      bin_to_bl (length cs) (bl_to_bin cs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_to_bin_False [simp]: \"bl_to_bin (False # bl) = bl_to_bin bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (False # bl) = bl_to_bin bl", "by (auto simp: bl_to_bin_def)"], ["", "lemma bl_to_bin_Nil [simp]: \"bl_to_bin [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin [] = 0", "by (auto simp: bl_to_bin_def)"], ["", "lemma bin_to_bl_zero_aux: \"bin_to_bl_aux n 0 bl = replicate n False @ bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl_aux n 0 bl = replicate n False @ bl", "by (induct n arbitrary: bl) (auto simp: replicate_app_Cons_same)"], ["", "lemma bin_to_bl_zero: \"bin_to_bl n 0 = replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl n 0 = replicate n False", "by (simp add: bin_to_bl_def bin_to_bl_zero_aux)"], ["", "lemma bin_to_bl_minus1_aux: \"bin_to_bl_aux n (- 1) bl = replicate n True @ bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl_aux n (- 1) bl = replicate n True @ bl", "by (induct n arbitrary: bl) (auto simp: replicate_app_Cons_same)"], ["", "lemma bin_to_bl_minus1: \"bin_to_bl n (- 1) = replicate n True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl n (- 1) = replicate n True", "by (simp add: bin_to_bl_def bin_to_bl_minus1_aux)"], ["", "subsection \\<open>Semantic interpretation of \\<^typ>\\<open>bool list\\<close> as \\<^typ>\\<open>int\\<close>\\<close>"], ["", "lemma bin_bl_bin': \"bl_to_bin (bin_to_bl_aux n w bs) = bl_to_bin_aux bs (bintrunc n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (bin_to_bl_aux n w bs) = bl_to_bin_aux bs (take_bit n w)", "by (induct n arbitrary: w bs) (auto simp: bl_to_bin_def take_bit_Suc ac_simps mod_2_eq_odd)"], ["", "lemma bin_bl_bin [simp]: \"bl_to_bin (bin_to_bl n w) = bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (bin_to_bl n w) = take_bit n w", "by (auto simp: bin_to_bl_def bin_bl_bin')"], ["", "lemma bl_to_bin_rep_F: \"bl_to_bin (replicate n False @ bl) = bl_to_bin bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (replicate n False @ bl) = bl_to_bin bl", "by (simp add: bin_to_bl_zero_aux [symmetric] bin_bl_bin') (simp add: bl_to_bin_def)"], ["", "lemma bin_to_bl_trunc [simp]: \"n \\<le> m \\<Longrightarrow> bin_to_bl n (bintrunc m w) = bin_to_bl n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> bin_to_bl n (take_bit m w) = bin_to_bl n w", "by (auto intro: bl_to_bin_inj)"], ["", "lemma bin_to_bl_aux_bintr:\n  \"bin_to_bl_aux n (bintrunc m bin) bl =\n    replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl_aux n (take_bit m bin) bl =\n    replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl", "apply (induct n arbitrary: m bin bl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m bin bl.\n       bin_to_bl_aux 0 (take_bit m bin) bl =\n       replicate (0 - m) False @ bin_to_bl_aux (min 0 m) bin bl\n 2. \\<And>n m bin bl.\n       (\\<And>m bin bl.\n           bin_to_bl_aux n (take_bit m bin) bl =\n           replicate (n - m) False @\n           bin_to_bl_aux (min n m) bin bl) \\<Longrightarrow>\n       bin_to_bl_aux (Suc n) (take_bit m bin) bl =\n       replicate (Suc n - m) False @ bin_to_bl_aux (min (Suc n) m) bin bl", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m bin bl.\n       (\\<And>m bin bl.\n           bin_to_bl_aux n (take_bit m bin) bl =\n           replicate (n - m) False @\n           bin_to_bl_aux (min n m) bin bl) \\<Longrightarrow>\n       bin_to_bl_aux (Suc n) (take_bit m bin) bl =\n       replicate (Suc n - m) False @ bin_to_bl_aux (min (Suc n) m) bin bl", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m bin bl.\n       (\\<And>m bin bl.\n           bin_to_bl_aux n (take_bit m bin) bl =\n           replicate (n - m) False @\n           bin_to_bl_aux (min n m) bin bl) \\<Longrightarrow>\n       bin_to_bl_aux n (take_bit m bin div 2)\n        ((0 < m \\<and> odd bin) # bl) =\n       replicate (Suc n - m) False @ bin_to_bl_aux (min (Suc n) m) bin bl", "apply (case_tac \"m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m bin bl.\n       \\<lbrakk>\\<And>m bin bl.\n                   bin_to_bl_aux n (take_bit m bin) bl =\n                   replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl;\n        m = 0\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux n (take_bit m bin div 2)\n                          ((0 < m \\<and> odd bin) # bl) =\n                         replicate (Suc n - m) False @\n                         bin_to_bl_aux (min (Suc n) m) bin bl\n 2. \\<And>n m bin bl nat.\n       \\<lbrakk>\\<And>m bin bl.\n                   bin_to_bl_aux n (take_bit m bin) bl =\n                   replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux n (take_bit m bin div 2)\n                          ((0 < m \\<and> odd bin) # bl) =\n                         replicate (Suc n - m) False @\n                         bin_to_bl_aux (min (Suc n) m) bin bl", "apply (clarsimp simp: bin_to_bl_zero_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       (\\<And>m bin bl.\n           bin_to_bl_aux n (take_bit m bin) bl =\n           replicate (n - m) False @\n           bin_to_bl_aux (min n m) bin bl) \\<Longrightarrow>\n       replicate n False @ [False] = False # replicate n False\n 2. \\<And>n m bin bl nat.\n       \\<lbrakk>\\<And>m bin bl.\n                   bin_to_bl_aux n (take_bit m bin) bl =\n                   replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux n (take_bit m bin div 2)\n                          ((0 < m \\<and> odd bin) # bl) =\n                         replicate (Suc n - m) False @\n                         bin_to_bl_aux (min (Suc n) m) bin bl", "apply (erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. replicate n False @ [False] = False # replicate n False\n 2. \\<And>n m bin bl nat.\n       \\<lbrakk>\\<And>m bin bl.\n                   bin_to_bl_aux n (take_bit m bin) bl =\n                   replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux n (take_bit m bin div 2)\n                          ((0 < m \\<and> odd bin) # bl) =\n                         replicate (Suc n - m) False @\n                         bin_to_bl_aux (min (Suc n) m) bin bl", "apply (induct_tac n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n. replicate 0 False @ [False] = False # replicate 0 False\n 2. \\<And>n na.\n       replicate na False @ [False] =\n       False # replicate na False \\<Longrightarrow>\n       replicate (Suc na) False @ [False] = False # replicate (Suc na) False\n 3. \\<And>n m bin bl nat.\n       \\<lbrakk>\\<And>m bin bl.\n                   bin_to_bl_aux n (take_bit m bin) bl =\n                   replicate (n - m) False @ bin_to_bl_aux (min n m) bin bl;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux n (take_bit m bin div 2)\n                          ((0 < m \\<and> odd bin) # bl) =\n                         replicate (Suc n - m) False @\n                         bin_to_bl_aux (min (Suc n) m) bin bl", "apply (auto simp add: take_bit_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_to_bl_bintr:\n  \"bin_to_bl n (bintrunc m bin) = replicate (n - m) False @ bin_to_bl (min n m) bin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl n (take_bit m bin) =\n    replicate (n - m) False @ bin_to_bl (min n m) bin", "unfolding bin_to_bl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl_aux n (take_bit m bin) [] =\n    replicate (n - m) False @ bin_to_bl_aux (min n m) bin []", "by (rule bin_to_bl_aux_bintr)"], ["", "lemma bl_to_bin_rep_False: \"bl_to_bin (replicate n False) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (replicate n False) = 0", "by (induct n) auto"], ["", "lemma len_bin_to_bl_aux: \"length (bin_to_bl_aux n w bs) = n + length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bin_to_bl_aux n w bs) = n + length bs", "by (fact size_bin_to_bl_aux)"], ["", "lemma len_bin_to_bl: \"length (bin_to_bl n w) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bin_to_bl n w) = n", "by (fact size_bin_to_bl)"], ["", "(* FIXME: duplicate *)"], ["", "lemma sign_bl_bin': \"bin_sign (bl_to_bin_aux bs w) = bin_sign w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (bl_to_bin_aux bs w) = bin_sign w", "by (induction bs arbitrary: w) (simp_all add: bin_sign_def)"], ["", "lemma sign_bl_bin: \"bin_sign (bl_to_bin bs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (bl_to_bin bs) = 0", "by (simp add: bl_to_bin_def sign_bl_bin')"], ["", "lemma bl_sbin_sign_aux: \"hd (bin_to_bl_aux (Suc n) w bs) = (bin_sign (sbintrunc n w) = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (bin_to_bl_aux (Suc n) w bs) = (bin_sign (signed_take_bit n w) = - 1)", "by (induction n arbitrary: w bs) (auto simp add: bin_sign_def even_iff_mod_2_eq_zero bit_Suc)"], ["", "lemma bl_sbin_sign: \"hd (bin_to_bl (Suc n) w) = (bin_sign (sbintrunc n w) = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (bin_to_bl (Suc n) w) = (bin_sign (signed_take_bit n w) = - 1)", "unfolding bin_to_bl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (bin_to_bl_aux (Suc n) w []) = (bin_sign (signed_take_bit n w) = - 1)", "by (rule bl_sbin_sign_aux)"], ["", "lemma bin_nth_of_bl_aux:\n  \"bin_nth (bl_to_bin_aux bl w) n =\n    (n < size bl \\<and> rev bl ! n \\<or> n \\<ge> length bl \\<and> bin_nth w (n - size bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (bl_to_bin_aux bl w) n =\n    (n < length bl \\<and> rev bl ! n \\<or>\n     length bl \\<le> n \\<and> bit w (n - length bl))", "apply (induction bl arbitrary: w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       bit (bl_to_bin_aux [] w) n =\n       (n < length [] \\<and> rev [] ! n \\<or>\n        length [] \\<le> n \\<and> bit w (n - length []))\n 2. \\<And>a bl w.\n       (\\<And>w.\n           bit (bl_to_bin_aux bl w) n =\n           (n < length bl \\<and> rev bl ! n \\<or>\n            length bl \\<le> n \\<and>\n            bit w (n - length bl))) \\<Longrightarrow>\n       bit (bl_to_bin_aux (a # bl) w) n =\n       (n < length (a # bl) \\<and> rev (a # bl) ! n \\<or>\n        length (a # bl) \\<le> n \\<and> bit w (n - length (a # bl)))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bl w.\n       (\\<And>w.\n           bit (bl_to_bin_aux bl w) n =\n           (n < length bl \\<and> rev bl ! n \\<or>\n            length bl \\<le> n \\<and>\n            bit w (n - length bl))) \\<Longrightarrow>\n       (a \\<longrightarrow>\n        (n < length bl \\<and> rev bl ! n \\<or>\n         length bl \\<le> n \\<and> bit (1 + 2 * w) (n - length bl)) =\n        (n < Suc (length bl) \\<and> (rev bl @ [True]) ! n \\<or>\n         Suc (length bl) \\<le> n \\<and> bit w (n - Suc (length bl)))) \\<and>\n       (\\<not> a \\<longrightarrow>\n        (n < length bl \\<and> rev bl ! n \\<or>\n         length bl \\<le> n \\<and> bit (2 * w) (n - length bl)) =\n        (n < Suc (length bl) \\<and> (rev bl @ [False]) ! n \\<or>\n         Suc (length bl) \\<le> n \\<and> bit w (n - Suc (length bl))))", "apply safe"], ["proof (prove)\ngoal (32 subgoals):\n 1. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; n < length bl; rev bl ! n;\n        \\<not> Suc (length bl) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n < Suc (length bl)\n 2. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; n < length bl; rev bl ! n;\n        \\<not> Suc (length bl) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (rev bl @ [True]) ! n\n 3. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; n < length bl; rev bl ! n;\n        \\<not> bit w (n - Suc (length bl))\\<rbrakk>\n       \\<Longrightarrow> n < Suc (length bl)\n 4. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; n < length bl; rev bl ! n;\n        \\<not> bit w (n - Suc (length bl))\\<rbrakk>\n       \\<Longrightarrow> (rev bl @ [True]) ! n\n 5. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; length bl \\<le> n; bit (1 + 2 * w) (n - length bl);\n        \\<not> Suc (length bl) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n < Suc (length bl)\n 6. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; length bl \\<le> n; bit (1 + 2 * w) (n - length bl);\n        \\<not> Suc (length bl) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (rev bl @ [True]) ! n\n 7. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; length bl \\<le> n; bit (1 + 2 * w) (n - length bl);\n        \\<not> bit w (n - Suc (length bl))\\<rbrakk>\n       \\<Longrightarrow> n < Suc (length bl)\n 8. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; length bl \\<le> n; bit (1 + 2 * w) (n - length bl);\n        \\<not> bit w (n - Suc (length bl))\\<rbrakk>\n       \\<Longrightarrow> (rev bl @ [True]) ! n\n 9. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   bit (bl_to_bin_aux bl w) n =\n                   (n < length bl \\<and> rev bl ! n \\<or>\n                    length bl \\<le> n \\<and> bit w (n - length bl));\n        a; n < Suc (length bl); (rev bl @ [True]) ! n;\n        \\<not> length bl \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n < length bl\n 10. \\<And>a bl w.\n        \\<lbrakk>\\<And>w.\n                    bit (bl_to_bin_aux bl w) n =\n                    (n < length bl \\<and> rev bl ! n \\<or>\n                     length bl \\<le> n \\<and> bit w (n - length bl));\n         a; n < Suc (length bl); (rev bl @ [True]) ! n;\n         \\<not> length bl \\<le> n\\<rbrakk>\n        \\<Longrightarrow> rev bl ! n\nA total of 32 subgoals...", "apply (simp_all add: not_le nth_append bit_double_iff even_bit_succ_iff split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_nth_of_bl: \"bin_nth (bl_to_bin bl) n = (n < length bl \\<and> rev bl ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (bl_to_bin bl) n = (n < length bl \\<and> rev bl ! n)", "by (simp add: bl_to_bin_def bin_nth_of_bl_aux)"], ["", "lemma bin_nth_bl: \"n < m \\<Longrightarrow> bin_nth w n = nth (rev (bin_to_bl m w)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow> bit w n = rev (bin_to_bl m w) ! n", "apply (induct n arbitrary: m w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m w. 0 < m \\<Longrightarrow> bit w 0 = rev (bin_to_bl m w) ! 0\n 2. \\<And>n m w.\n       \\<lbrakk>\\<And>m w.\n                   n < m \\<Longrightarrow>\n                   bit w n = rev (bin_to_bl m w) ! n;\n        Suc n < m\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n) = rev (bin_to_bl m w) ! Suc n", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m w. 0 < m \\<Longrightarrow> odd w = rev (bin_to_bl m w) ! 0\n 2. \\<And>n m w.\n       \\<lbrakk>\\<And>m w.\n                   n < m \\<Longrightarrow>\n                   bit w n = rev (bin_to_bl m w) ! n;\n        Suc n < m\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n) = rev (bin_to_bl m w) ! Suc n", "apply (case_tac m, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m w nat.\n       \\<lbrakk>0 < m; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> odd w = rev (bin_to_bl m w) ! 0\n 2. \\<And>n m w.\n       \\<lbrakk>\\<And>m w.\n                   n < m \\<Longrightarrow>\n                   bit w n = rev (bin_to_bl m w) ! n;\n        Suc n < m\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n) = rev (bin_to_bl m w) ! Suc n", "apply (clarsimp simp: bin_to_bl_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w nat. odd w = rev (bin_to_bl_aux nat (w div 2) [odd w]) ! 0\n 2. \\<And>n m w.\n       \\<lbrakk>\\<And>m w.\n                   n < m \\<Longrightarrow>\n                   bit w n = rev (bin_to_bl m w) ! n;\n        Suc n < m\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n) = rev (bin_to_bl m w) ! Suc n", "apply (simp add: bin_to_bl_aux_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m w.\n       \\<lbrakk>\\<And>m w.\n                   n < m \\<Longrightarrow>\n                   bit w n = rev (bin_to_bl m w) ! n;\n        Suc n < m\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n) = rev (bin_to_bl m w) ! Suc n", "apply (case_tac m, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m w nat.\n       \\<lbrakk>\\<And>m w.\n                   n < m \\<Longrightarrow>\n                   bit w n = rev (bin_to_bl m w) ! n;\n        Suc n < m; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n) = rev (bin_to_bl m w) ! Suc n", "apply (clarsimp simp: bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w nat.\n       \\<lbrakk>\\<And>m w.\n                   n < m \\<Longrightarrow>\n                   bit w n = rev (bin_to_bl_aux m w []) ! n;\n        n < nat\\<rbrakk>\n       \\<Longrightarrow> bit w (Suc n) =\n                         rev (bin_to_bl_aux nat (w div 2) [odd w]) ! Suc n", "apply (simp add: bin_to_bl_aux_alt bit_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_bin_to_bl_aux:\n  \"n < m + length bl \\<Longrightarrow> (bin_to_bl_aux m w bl) ! n =\n    (if n < m then bit w (m - 1 - n) else bl ! (n - m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m + length bl \\<Longrightarrow>\n    bin_to_bl_aux m w bl ! n =\n    (if n < m then bit w (m - 1 - n) else bl ! (n - m))", "apply (induction bl arbitrary: w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       n < m + length [] \\<Longrightarrow>\n       bin_to_bl_aux m w [] ! n =\n       (if n < m then bit w (m - 1 - n) else [] ! (n - m))\n 2. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   n < m + length bl \\<Longrightarrow>\n                   bin_to_bl_aux m w bl ! n =\n                   (if n < m then bit w (m - 1 - n) else bl ! (n - m));\n        n < m + length (a # bl)\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux m w (a # bl) ! n =\n                         (if n < m then bit w (m - 1 - n)\n                          else (a # bl) ! (n - m))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       n < m \\<Longrightarrow> bin_to_bl_aux m w [] ! n = bit w (m - Suc n)\n 2. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   n < m + length bl \\<Longrightarrow>\n                   bin_to_bl_aux m w bl ! n =\n                   (if n < m then bit w (m - 1 - n) else bl ! (n - m));\n        n < Suc (m + length bl)\\<rbrakk>\n       \\<Longrightarrow> (n < m \\<longrightarrow>\n                          bin_to_bl_aux m w (a # bl) ! n =\n                          bit w (m - Suc n)) \\<and>\n                         (\\<not> n < m \\<longrightarrow>\n                          bin_to_bl_aux m w (a # bl) ! n =\n                          (a # bl) ! (n - m))", "apply (simp add: bin_nth_bl [of \\<open>m - Suc n\\<close> m] rev_nth flip: bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bl w.\n       \\<lbrakk>\\<And>w.\n                   n < m + length bl \\<Longrightarrow>\n                   bin_to_bl_aux m w bl ! n =\n                   (if n < m then bit w (m - 1 - n) else bl ! (n - m));\n        n < Suc (m + length bl)\\<rbrakk>\n       \\<Longrightarrow> (n < m \\<longrightarrow>\n                          bin_to_bl_aux m w (a # bl) ! n =\n                          bit w (m - Suc n)) \\<and>\n                         (\\<not> n < m \\<longrightarrow>\n                          bin_to_bl_aux m w (a # bl) ! n =\n                          (a # bl) ! (n - m))", "apply (metis One_nat_def Suc_pred add_diff_cancel_left'\n     add_diff_cancel_right' bin_to_bl_aux_alt bin_to_bl_def\n     diff_Suc_Suc diff_is_0_eq diff_zero less_Suc_eq_0_disj\n     less_antisym less_imp_Suc_add list.size(3) nat_less_le nth_append size_bin_to_bl_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_bin_to_bl: \"n < m \\<Longrightarrow> (bin_to_bl m w) ! n = bin_nth w (m - Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow> bin_to_bl m w ! n = bit w (m - Suc n)", "by (simp add: bin_to_bl_def nth_bin_to_bl_aux)"], ["", "lemma takefill_bintrunc: \"takefill False n bl = rev (bin_to_bl n (bl_to_bin (rev bl)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill False n bl = rev (bin_to_bl n (bl_to_bin (rev bl)))", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (takefill False n bl) =\n    length (rev (bin_to_bl n (bl_to_bin (rev bl))))\n 2. \\<And>i.\n       i < length (takefill False n bl) \\<Longrightarrow>\n       takefill False n bl ! i = rev (bin_to_bl n (bl_to_bin (rev bl))) ! i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (takefill False n bl) \\<Longrightarrow>\n       takefill False n bl ! i = rev (bin_to_bl n (bl_to_bin (rev bl))) ! i", "apply (clarsimp simp: nth_takefill rev_nth nth_bin_to_bl bin_nth_of_bl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_bin_bl_rtf: \"bin_to_bl n (bl_to_bin bl) = rev (takefill False n (rev bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl n (bl_to_bin bl) = rev (takefill False n (rev bl))", "by (simp add: takefill_bintrunc)"], ["", "lemma bl_to_bin_lt2p_aux: \"bl_to_bin_aux bs w < (w + 1) * (2 ^ length bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin_aux bs w < (w + 1) * 2 ^ length bs", "proof (induction bs arbitrary: w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w. bl_to_bin_aux [] w < (w + 1) * 2 ^ length []\n 2. \\<And>a bs w.\n       (\\<And>w.\n           bl_to_bin_aux bs w < (w + 1) * 2 ^ length bs) \\<Longrightarrow>\n       bl_to_bin_aux (a # bs) w < (w + 1) * 2 ^ length (a # bs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>w. bl_to_bin_aux [] w < (w + 1) * 2 ^ length []\n 2. \\<And>a bs w.\n       (\\<And>w.\n           bl_to_bin_aux bs w < (w + 1) * 2 ^ length bs) \\<Longrightarrow>\n       bl_to_bin_aux (a # bs) w < (w + 1) * 2 ^ length (a # bs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin_aux [] w < (w + 1) * 2 ^ length []", "by simp"], ["proof (state)\nthis:\n  bl_to_bin_aux [] w < (w + 1) * 2 ^ length []\n\ngoal (1 subgoal):\n 1. \\<And>a bs w.\n       (\\<And>w.\n           bl_to_bin_aux bs w < (w + 1) * 2 ^ length bs) \\<Longrightarrow>\n       bl_to_bin_aux (a # bs) w < (w + 1) * 2 ^ length (a # bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs w.\n       (\\<And>w.\n           bl_to_bin_aux bs w < (w + 1) * 2 ^ length bs) \\<Longrightarrow>\n       bl_to_bin_aux (a # bs) w < (w + 1) * 2 ^ length (a # bs)", "case (Cons b bs)"], ["proof (state)\nthis:\n  bl_to_bin_aux bs ?w < (?w + 1) * 2 ^ length bs\n\ngoal (1 subgoal):\n 1. \\<And>a bs w.\n       (\\<And>w.\n           bl_to_bin_aux bs w < (w + 1) * 2 ^ length bs) \\<Longrightarrow>\n       bl_to_bin_aux (a # bs) w < (w + 1) * 2 ^ length (a # bs)", "from Cons.IH [of \\<open>1 + 2 * w\\<close>] Cons.IH [of \\<open>2 * w\\<close>]"], ["proof (chain)\npicking this:\n  bl_to_bin_aux bs (1 + 2 * w) < (1 + 2 * w + 1) * 2 ^ length bs\n  bl_to_bin_aux bs (2 * w) < (2 * w + 1) * 2 ^ length bs", "show ?case"], ["proof (prove)\nusing this:\n  bl_to_bin_aux bs (1 + 2 * w) < (1 + 2 * w + 1) * 2 ^ length bs\n  bl_to_bin_aux bs (2 * w) < (2 * w + 1) * 2 ^ length bs\n\ngoal (1 subgoal):\n 1. bl_to_bin_aux (b # bs) w < (w + 1) * 2 ^ length (b # bs)", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bl_to_bin_aux bs (1 + w * 2)\n             < 2 * 2 ^ length bs + w * (2 * 2 ^ length bs);\n     bl_to_bin_aux bs (w * 2) < 2 ^ length bs + w * (2 * 2 ^ length bs);\n     \\<not> b\\<rbrakk>\n    \\<Longrightarrow> bl_to_bin_aux bs (w * 2)\n                      < 2 * 2 ^ length bs + w * (2 * 2 ^ length bs)", "apply (subst mult_2 [of \\<open>2 ^ length bs\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bl_to_bin_aux bs (1 + w * 2)\n             < 2 * 2 ^ length bs + w * (2 * 2 ^ length bs);\n     bl_to_bin_aux bs (w * 2) < 2 ^ length bs + w * (2 * 2 ^ length bs);\n     \\<not> b\\<rbrakk>\n    \\<Longrightarrow> bl_to_bin_aux bs (w * 2)\n                      < 2 ^ length bs + 2 ^ length bs +\n                        w * (2 * 2 ^ length bs)", "apply (simp only: add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bl_to_bin_aux bs (1 + w * 2)\n             < 2 * 2 ^ length bs + w * (2 * 2 ^ length bs);\n     bl_to_bin_aux bs (w * 2) < 2 ^ length bs + w * (2 * 2 ^ length bs);\n     \\<not> b\\<rbrakk>\n    \\<Longrightarrow> bl_to_bin_aux bs (w * 2)\n                      < 2 ^ length bs +\n                        (2 ^ length bs + w * (2 * 2 ^ length bs))", "apply (rule pos_add_strict)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bl_to_bin_aux bs (1 + w * 2)\n             < 2 * 2 ^ length bs + w * (2 * 2 ^ length bs);\n     bl_to_bin_aux bs (w * 2) < 2 ^ length bs + w * (2 * 2 ^ length bs);\n     \\<not> b\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ length bs\n 2. \\<lbrakk>bl_to_bin_aux bs (1 + w * 2)\n             < 2 * 2 ^ length bs + w * (2 * 2 ^ length bs);\n     bl_to_bin_aux bs (w * 2) < 2 ^ length bs + w * (2 * 2 ^ length bs);\n     \\<not> b\\<rbrakk>\n    \\<Longrightarrow> bl_to_bin_aux bs (w * 2)\n                      < 2 ^ length bs + w * (2 * 2 ^ length bs)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bl_to_bin_aux (b # bs) w < (w + 1) * 2 ^ length (b # bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl_to_bin_lt2p_drop: \"bl_to_bin bs < 2 ^ length (dropWhile Not bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin bs < 2 ^ length (dropWhile Not bs)", "proof (induct bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. bl_to_bin [] < 2 ^ length (dropWhile Not [])\n 2. \\<And>a bs.\n       bl_to_bin bs < 2 ^ length (dropWhile Not bs) \\<Longrightarrow>\n       bl_to_bin (a # bs) < 2 ^ length (dropWhile Not (a # bs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. bl_to_bin [] < 2 ^ length (dropWhile Not [])\n 2. \\<And>a bs.\n       bl_to_bin bs < 2 ^ length (dropWhile Not bs) \\<Longrightarrow>\n       bl_to_bin (a # bs) < 2 ^ length (dropWhile Not (a # bs))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin [] < 2 ^ length (dropWhile Not [])", "by simp"], ["proof (state)\nthis:\n  bl_to_bin [] < 2 ^ length (dropWhile Not [])\n\ngoal (1 subgoal):\n 1. \\<And>a bs.\n       bl_to_bin bs < 2 ^ length (dropWhile Not bs) \\<Longrightarrow>\n       bl_to_bin (a # bs) < 2 ^ length (dropWhile Not (a # bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs.\n       bl_to_bin bs < 2 ^ length (dropWhile Not bs) \\<Longrightarrow>\n       bl_to_bin (a # bs) < 2 ^ length (dropWhile Not (a # bs))", "case (Cons b bs)"], ["proof (state)\nthis:\n  bl_to_bin bs < 2 ^ length (dropWhile Not bs)\n\ngoal (1 subgoal):\n 1. \\<And>a bs.\n       bl_to_bin bs < 2 ^ length (dropWhile Not bs) \\<Longrightarrow>\n       bl_to_bin (a # bs) < 2 ^ length (dropWhile Not (a # bs))", "with bl_to_bin_lt2p_aux[where w=1]"], ["proof (chain)\npicking this:\n  bl_to_bin_aux ?bs 1 < (1 + 1) * 2 ^ length ?bs\n  bl_to_bin bs < 2 ^ length (dropWhile Not bs)", "show ?case"], ["proof (prove)\nusing this:\n  bl_to_bin_aux ?bs 1 < (1 + 1) * 2 ^ length ?bs\n  bl_to_bin bs < 2 ^ length (dropWhile Not bs)\n\ngoal (1 subgoal):\n 1. bl_to_bin (b # bs) < 2 ^ length (dropWhile Not (b # bs))", "by (simp add: bl_to_bin_def)"], ["proof (state)\nthis:\n  bl_to_bin (b # bs) < 2 ^ length (dropWhile Not (b # bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl_to_bin_lt2p: \"bl_to_bin bs < 2 ^ length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin bs < 2 ^ length bs", "by (metis bin_bl_bin bintr_lt2p bl_bin_bl)"], ["", "lemma bl_to_bin_ge2p_aux: \"bl_to_bin_aux bs w \\<ge> w * (2 ^ length bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w * 2 ^ length bs \\<le> bl_to_bin_aux bs w", "proof (induction bs arbitrary: w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w. w * 2 ^ length [] \\<le> bl_to_bin_aux [] w\n 2. \\<And>a bs w.\n       (\\<And>w.\n           w * 2 ^ length bs \\<le> bl_to_bin_aux bs w) \\<Longrightarrow>\n       w * 2 ^ length (a # bs) \\<le> bl_to_bin_aux (a # bs) w", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>w. w * 2 ^ length [] \\<le> bl_to_bin_aux [] w\n 2. \\<And>a bs w.\n       (\\<And>w.\n           w * 2 ^ length bs \\<le> bl_to_bin_aux bs w) \\<Longrightarrow>\n       w * 2 ^ length (a # bs) \\<le> bl_to_bin_aux (a # bs) w", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. w * 2 ^ length [] \\<le> bl_to_bin_aux [] w", "by simp"], ["proof (state)\nthis:\n  w * 2 ^ length [] \\<le> bl_to_bin_aux [] w\n\ngoal (1 subgoal):\n 1. \\<And>a bs w.\n       (\\<And>w.\n           w * 2 ^ length bs \\<le> bl_to_bin_aux bs w) \\<Longrightarrow>\n       w * 2 ^ length (a # bs) \\<le> bl_to_bin_aux (a # bs) w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs w.\n       (\\<And>w.\n           w * 2 ^ length bs \\<le> bl_to_bin_aux bs w) \\<Longrightarrow>\n       w * 2 ^ length (a # bs) \\<le> bl_to_bin_aux (a # bs) w", "case (Cons b bs)"], ["proof (state)\nthis:\n  ?w * 2 ^ length bs \\<le> bl_to_bin_aux bs ?w\n\ngoal (1 subgoal):\n 1. \\<And>a bs w.\n       (\\<And>w.\n           w * 2 ^ length bs \\<le> bl_to_bin_aux bs w) \\<Longrightarrow>\n       w * 2 ^ length (a # bs) \\<le> bl_to_bin_aux (a # bs) w", "from Cons.IH [of \\<open>1 + 2 * w\\<close>] Cons.IH [of \\<open>2 * w\\<close>]"], ["proof (chain)\npicking this:\n  (1 + 2 * w) * 2 ^ length bs \\<le> bl_to_bin_aux bs (1 + 2 * w)\n  2 * w * 2 ^ length bs \\<le> bl_to_bin_aux bs (2 * w)", "show ?case"], ["proof (prove)\nusing this:\n  (1 + 2 * w) * 2 ^ length bs \\<le> bl_to_bin_aux bs (1 + 2 * w)\n  2 * w * 2 ^ length bs \\<le> bl_to_bin_aux bs (2 * w)\n\ngoal (1 subgoal):\n 1. w * 2 ^ length (b # bs) \\<le> bl_to_bin_aux (b # bs) w", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ length bs + w * (2 * 2 ^ length bs)\n             \\<le> bl_to_bin_aux bs (1 + w * 2);\n     w * (2 * 2 ^ length bs) \\<le> bl_to_bin_aux bs (w * 2); b\\<rbrakk>\n    \\<Longrightarrow> w * (2 * 2 ^ length bs)\n                      \\<le> bl_to_bin_aux bs (1 + w * 2)", "apply (rule add_le_imp_le_left [of \\<open>2 ^ length bs\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ length bs + w * (2 * 2 ^ length bs)\n             \\<le> bl_to_bin_aux bs (1 + w * 2);\n     w * (2 * 2 ^ length bs) \\<le> bl_to_bin_aux bs (w * 2); b\\<rbrakk>\n    \\<Longrightarrow> 2 ^ length bs + w * (2 * 2 ^ length bs)\n                      \\<le> 2 ^ length bs + bl_to_bin_aux bs (1 + w * 2)", "apply (rule add_increasing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ length bs + w * (2 * 2 ^ length bs)\n             \\<le> bl_to_bin_aux bs (1 + w * 2);\n     w * (2 * 2 ^ length bs) \\<le> bl_to_bin_aux bs (w * 2); b\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 2 ^ length bs\n 2. \\<lbrakk>2 ^ length bs + w * (2 * 2 ^ length bs)\n             \\<le> bl_to_bin_aux bs (1 + w * 2);\n     w * (2 * 2 ^ length bs) \\<le> bl_to_bin_aux bs (w * 2); b\\<rbrakk>\n    \\<Longrightarrow> 2 ^ length bs + w * (2 * 2 ^ length bs)\n                      \\<le> bl_to_bin_aux bs (1 + w * 2)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  w * 2 ^ length (b # bs) \\<le> bl_to_bin_aux (b # bs) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl_to_bin_ge0: \"bl_to_bin bs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bl_to_bin bs", "apply (unfold bl_to_bin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bl_to_bin_aux bs 0", "apply (rule xtrans(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?b \\<le> bl_to_bin_aux bs 0\n 2. ?b = 0", "apply (rule bl_to_bin_ge2p_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * 2 ^ length bs = 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma butlast_rest_bin: \"butlast (bin_to_bl n w) = bin_to_bl (n - 1) (bin_rest w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (bin_to_bl n w) = bin_to_bl (n - 1) (w div 2)", "apply (unfold bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (bin_to_bl_aux n w []) = bin_to_bl_aux (n - 1) (w div 2) []", "apply (cases n, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       butlast (bin_to_bl_aux n w []) = bin_to_bl_aux (n - 1) (w div 2) []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       butlast (bin_to_bl_aux nat (w div 2) [odd w]) =\n       bin_to_bl_aux nat (w div 2) []", "apply (auto simp add: bin_to_bl_aux_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma butlast_bin_rest: \"butlast bl = bin_to_bl (length bl - Suc 0) (bin_rest (bl_to_bin bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast bl = bin_to_bl (length bl - Suc 0) (bl_to_bin bl div 2)", "using butlast_rest_bin [where w=\"bl_to_bin bl\" and n=\"length bl\"]"], ["proof (prove)\nusing this:\n  butlast (bin_to_bl (length bl) (bl_to_bin bl)) =\n  bin_to_bl (length bl - 1) (bl_to_bin bl div 2)\n\ngoal (1 subgoal):\n 1. butlast bl = bin_to_bl (length bl - Suc 0) (bl_to_bin bl div 2)", "by simp"], ["", "lemma butlast_rest_bl2bin_aux:\n  \"bl \\<noteq> [] \\<Longrightarrow> bl_to_bin_aux (butlast bl) w = bin_rest (bl_to_bin_aux bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<noteq> [] \\<Longrightarrow>\n    bl_to_bin_aux (butlast bl) w = bl_to_bin_aux bl w div 2", "by (induct bl arbitrary: w) auto"], ["", "lemma butlast_rest_bl2bin: \"bl_to_bin (butlast bl) = bin_rest (bl_to_bin bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (butlast bl) = bl_to_bin bl div 2", "by (cases bl) (auto simp: bl_to_bin_def butlast_rest_bl2bin_aux)"], ["", "lemma trunc_bl2bin_aux:\n  \"bintrunc m (bl_to_bin_aux bl w) =\n    bl_to_bin_aux (drop (length bl - m) bl) (bintrunc (m - length bl) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit m (bl_to_bin_aux bl w) =\n    bl_to_bin_aux (drop (length bl - m) bl) (take_bit (m - length bl) w)", "proof (induct bl arbitrary: w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       take_bit m (bl_to_bin_aux [] w) =\n       bl_to_bin_aux (drop (length [] - m) []) (take_bit (m - length []) w)\n 2. \\<And>a bl w.\n       (\\<And>w.\n           take_bit m (bl_to_bin_aux bl w) =\n           bl_to_bin_aux (drop (length bl - m) bl)\n            (take_bit (m - length bl) w)) \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (a # bl) w) =\n       bl_to_bin_aux (drop (length (a # bl) - m) (a # bl))\n        (take_bit (m - length (a # bl)) w)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>w.\n       take_bit m (bl_to_bin_aux [] w) =\n       bl_to_bin_aux (drop (length [] - m) []) (take_bit (m - length []) w)\n 2. \\<And>a bl w.\n       (\\<And>w.\n           take_bit m (bl_to_bin_aux bl w) =\n           bl_to_bin_aux (drop (length bl - m) bl)\n            (take_bit (m - length bl) w)) \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (a # bl) w) =\n       bl_to_bin_aux (drop (length (a # bl) - m) (a # bl))\n        (take_bit (m - length (a # bl)) w)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit m (bl_to_bin_aux [] w) =\n    bl_to_bin_aux (drop (length [] - m) []) (take_bit (m - length []) w)", "by simp"], ["proof (state)\nthis:\n  take_bit m (bl_to_bin_aux [] w) =\n  bl_to_bin_aux (drop (length [] - m) []) (take_bit (m - length []) w)\n\ngoal (1 subgoal):\n 1. \\<And>a bl w.\n       (\\<And>w.\n           take_bit m (bl_to_bin_aux bl w) =\n           bl_to_bin_aux (drop (length bl - m) bl)\n            (take_bit (m - length bl) w)) \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (a # bl) w) =\n       bl_to_bin_aux (drop (length (a # bl) - m) (a # bl))\n        (take_bit (m - length (a # bl)) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bl w.\n       (\\<And>w.\n           take_bit m (bl_to_bin_aux bl w) =\n           bl_to_bin_aux (drop (length bl - m) bl)\n            (take_bit (m - length bl) w)) \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (a # bl) w) =\n       bl_to_bin_aux (drop (length (a # bl) - m) (a # bl))\n        (take_bit (m - length (a # bl)) w)", "case (Cons b bl)"], ["proof (state)\nthis:\n  take_bit m (bl_to_bin_aux bl ?w) =\n  bl_to_bin_aux (drop (length bl - m) bl) (take_bit (m - length bl) ?w)\n\ngoal (1 subgoal):\n 1. \\<And>a bl w.\n       (\\<And>w.\n           take_bit m (bl_to_bin_aux bl w) =\n           bl_to_bin_aux (drop (length bl - m) bl)\n            (take_bit (m - length bl) w)) \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (a # bl) w) =\n       bl_to_bin_aux (drop (length (a # bl) - m) (a # bl))\n        (take_bit (m - length (a # bl)) w)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit m (bl_to_bin_aux (b # bl) w) =\n    bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n     (take_bit (m - length (b # bl)) w)", "proof (cases \"m - length bl\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m - length bl = 0 \\<Longrightarrow>\n    take_bit m (bl_to_bin_aux (b # bl) w) =\n    bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n     (take_bit (m - length (b # bl)) w)\n 2. \\<And>nat.\n       m - length bl = Suc nat \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (b # bl) w) =\n       bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n        (take_bit (m - length (b # bl)) w)", "case 0"], ["proof (state)\nthis:\n  m - length bl = 0\n\ngoal (2 subgoals):\n 1. m - length bl = 0 \\<Longrightarrow>\n    take_bit m (bl_to_bin_aux (b # bl) w) =\n    bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n     (take_bit (m - length (b # bl)) w)\n 2. \\<And>nat.\n       m - length bl = Suc nat \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (b # bl) w) =\n       bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n        (take_bit (m - length (b # bl)) w)", "then"], ["proof (chain)\npicking this:\n  m - length bl = 0", "have \"Suc (length bl) - m = Suc (length bl - m)\""], ["proof (prove)\nusing this:\n  m - length bl = 0\n\ngoal (1 subgoal):\n 1. Suc (length bl) - m = Suc (length bl - m)", "by simp"], ["proof (state)\nthis:\n  Suc (length bl) - m = Suc (length bl - m)\n\ngoal (2 subgoals):\n 1. m - length bl = 0 \\<Longrightarrow>\n    take_bit m (bl_to_bin_aux (b # bl) w) =\n    bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n     (take_bit (m - length (b # bl)) w)\n 2. \\<And>nat.\n       m - length bl = Suc nat \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (b # bl) w) =\n       bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n        (take_bit (m - length (b # bl)) w)", "with Cons"], ["proof (chain)\npicking this:\n  take_bit m (bl_to_bin_aux bl ?w) =\n  bl_to_bin_aux (drop (length bl - m) bl) (take_bit (m - length bl) ?w)\n  Suc (length bl) - m = Suc (length bl - m)", "show ?thesis"], ["proof (prove)\nusing this:\n  take_bit m (bl_to_bin_aux bl ?w) =\n  bl_to_bin_aux (drop (length bl - m) bl) (take_bit (m - length bl) ?w)\n  Suc (length bl) - m = Suc (length bl - m)\n\ngoal (1 subgoal):\n 1. take_bit m (bl_to_bin_aux (b # bl) w) =\n    bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n     (take_bit (m - length (b # bl)) w)", "by simp"], ["proof (state)\nthis:\n  take_bit m (bl_to_bin_aux (b # bl) w) =\n  bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n   (take_bit (m - length (b # bl)) w)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m - length bl = Suc nat \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (b # bl) w) =\n       bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n        (take_bit (m - length (b # bl)) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m - length bl = Suc nat \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (b # bl) w) =\n       bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n        (take_bit (m - length (b # bl)) w)", "case (Suc n)"], ["proof (state)\nthis:\n  m - length bl = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m - length bl = Suc nat \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (b # bl) w) =\n       bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n        (take_bit (m - length (b # bl)) w)", "then"], ["proof (chain)\npicking this:\n  m - length bl = Suc n", "have \"m - Suc (length bl) = n\""], ["proof (prove)\nusing this:\n  m - length bl = Suc n\n\ngoal (1 subgoal):\n 1. m - Suc (length bl) = n", "by simp"], ["proof (state)\nthis:\n  m - Suc (length bl) = n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m - length bl = Suc nat \\<Longrightarrow>\n       take_bit m (bl_to_bin_aux (b # bl) w) =\n       bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n        (take_bit (m - length (b # bl)) w)", "with Cons Suc"], ["proof (chain)\npicking this:\n  take_bit m (bl_to_bin_aux bl ?w) =\n  bl_to_bin_aux (drop (length bl - m) bl) (take_bit (m - length bl) ?w)\n  m - length bl = Suc n\n  m - Suc (length bl) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  take_bit m (bl_to_bin_aux bl ?w) =\n  bl_to_bin_aux (drop (length bl - m) bl) (take_bit (m - length bl) ?w)\n  m - length bl = Suc n\n  m - Suc (length bl) = n\n\ngoal (1 subgoal):\n 1. take_bit m (bl_to_bin_aux (b # bl) w) =\n    bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n     (take_bit (m - length (b # bl)) w)", "by (simp add: take_bit_Suc ac_simps)"], ["proof (state)\nthis:\n  take_bit m (bl_to_bin_aux (b # bl) w) =\n  bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n   (take_bit (m - length (b # bl)) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take_bit m (bl_to_bin_aux (b # bl) w) =\n  bl_to_bin_aux (drop (length (b # bl) - m) (b # bl))\n   (take_bit (m - length (b # bl)) w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trunc_bl2bin: \"bintrunc m (bl_to_bin bl) = bl_to_bin (drop (length bl - m) bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit m (bl_to_bin bl) = bl_to_bin (drop (length bl - m) bl)", "by (simp add: bl_to_bin_def trunc_bl2bin_aux)"], ["", "lemma trunc_bl2bin_len [simp]: \"bintrunc (length bl) (bl_to_bin bl) = bl_to_bin bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit (length bl) (bl_to_bin bl) = bl_to_bin bl", "by (simp add: trunc_bl2bin)"], ["", "lemma bl2bin_drop: \"bl_to_bin (drop k bl) = bintrunc (length bl - k) (bl_to_bin bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (drop k bl) = take_bit (length bl - k) (bl_to_bin bl)", "apply (rule trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bl_to_bin (drop k bl) = ?s\n 2. ?s = take_bit (length bl - k) (bl_to_bin bl)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?s = take_bit (length bl - k) (bl_to_bin bl)\n 2. bl_to_bin (drop k bl) = ?s", "apply (rule trunc_bl2bin [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (drop k bl) =\n    bl_to_bin (drop (length bl - (length bl - k)) bl)", "apply (cases \"k \\<le> length bl\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<le> length bl \\<Longrightarrow>\n    bl_to_bin (drop k bl) =\n    bl_to_bin (drop (length bl - (length bl - k)) bl)\n 2. \\<not> k \\<le> length bl \\<Longrightarrow>\n    bl_to_bin (drop k bl) =\n    bl_to_bin (drop (length bl - (length bl - k)) bl)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_rest_power_bin: \"m \\<le> n \\<Longrightarrow> take m (bin_to_bl n w) = bin_to_bl m ((bin_rest ^^ (n - m)) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    take m (bin_to_bl n w) =\n    bin_to_bl m (((\\<lambda>w. w div 2) ^^ (n - m)) w)", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> n \\<Longrightarrow>\n    length (take m (bin_to_bl n w)) =\n    length (bin_to_bl m (((\\<lambda>w. w div 2) ^^ (n - m)) w))\n 2. \\<And>i.\n       \\<lbrakk>m \\<le> n; i < length (take m (bin_to_bl n w))\\<rbrakk>\n       \\<Longrightarrow> take m (bin_to_bl n w) ! i =\n                         bin_to_bl m\n                          (((\\<lambda>w. w div 2) ^^ (n - m)) w) !\n                         i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>m \\<le> n; i < length (take m (bin_to_bl n w))\\<rbrakk>\n       \\<Longrightarrow> take m (bin_to_bl n w) ! i =\n                         bin_to_bl m\n                          (((\\<lambda>w. w div 2) ^^ (n - m)) w) !\n                         i", "apply (clarsimp simp add: nth_bin_to_bl nth_rest_power_bin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma last_bin_last': \"size xs > 0 \\<Longrightarrow> last xs \\<longleftrightarrow> bin_last (bl_to_bin_aux xs w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow> last xs = odd (bl_to_bin_aux xs w)", "by (induct xs arbitrary: w) auto"], ["", "lemma last_bin_last: \"size xs > 0 \\<Longrightarrow> last xs \\<longleftrightarrow> bin_last (bl_to_bin xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow> last xs = odd (bl_to_bin xs)", "unfolding bl_to_bin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs \\<Longrightarrow> last xs = odd (bl_to_bin_aux xs 0)", "by (erule last_bin_last')"], ["", "lemma bin_last_last: \"bin_last w \\<longleftrightarrow> last (bin_to_bl (Suc n) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd w = last (bin_to_bl (Suc n) w)", "by (simp add: bin_to_bl_def) (auto simp: bin_to_bl_aux_alt)"], ["", "lemma drop_bin2bl_aux:\n  \"drop m (bin_to_bl_aux n bin bs) =\n    bin_to_bl_aux (n - m) bin (drop (m - n) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop m (bin_to_bl_aux n bin bs) =\n    bin_to_bl_aux (n - m) bin (drop (m - n) bs)", "apply (induction n arbitrary: m bin bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m bin bs.\n       drop m (bin_to_bl_aux 0 bin bs) =\n       bin_to_bl_aux (0 - m) bin (drop (m - 0) bs)\n 2. \\<And>n m bin bs.\n       (\\<And>m bin bs.\n           drop m (bin_to_bl_aux n bin bs) =\n           bin_to_bl_aux (n - m) bin (drop (m - n) bs)) \\<Longrightarrow>\n       drop m (bin_to_bl_aux (Suc n) bin bs) =\n       bin_to_bl_aux (Suc n - m) bin (drop (m - Suc n) bs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m bin bs.\n       (\\<And>m bin bs.\n           drop m (bin_to_bl_aux n bin bs) =\n           bin_to_bl_aux (n - m) bin (drop (m - n) bs)) \\<Longrightarrow>\n       bin_to_bl_aux (n - m) (bin div 2) (drop (m - n) (odd bin # bs)) =\n       bin_to_bl_aux (Suc n - m) bin (drop (m - Suc n) bs)", "apply (case_tac \"m \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m bin bs.\n       \\<lbrakk>\\<And>m bin bs.\n                   drop m (bin_to_bl_aux n bin bs) =\n                   bin_to_bl_aux (n - m) bin (drop (m - n) bs);\n        m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux (n - m) (bin div 2)\n                          (drop (m - n) (odd bin # bs)) =\n                         bin_to_bl_aux (Suc n - m) bin (drop (m - Suc n) bs)\n 2. \\<And>n m bin bs.\n       \\<lbrakk>\\<And>m bin bs.\n                   drop m (bin_to_bl_aux n bin bs) =\n                   bin_to_bl_aux (n - m) bin (drop (m - n) bs);\n        \\<not> m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux (n - m) (bin div 2)\n                          (drop (m - n) (odd bin # bs)) =\n                         bin_to_bl_aux (Suc n - m) bin (drop (m - Suc n) bs)", "apply (auto simp add: not_le Suc_diff_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m bin bs.\n       \\<lbrakk>\\<And>m bin bs.\n                   drop m (bin_to_bl_aux n bin bs) =\n                   bin_to_bl_aux (n - m) bin (drop (m - n) bs);\n        n < m\\<rbrakk>\n       \\<Longrightarrow> drop (m - n) (odd bin # bs) = drop (m - Suc n) bs", "apply (case_tac \"m - n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m bin bs.\n       \\<lbrakk>\\<And>m bin bs.\n                   drop m (bin_to_bl_aux n bin bs) =\n                   bin_to_bl_aux (n - m) bin (drop (m - n) bs);\n        n < m; m - n = 0\\<rbrakk>\n       \\<Longrightarrow> drop (m - n) (odd bin # bs) = drop (m - Suc n) bs\n 2. \\<And>n m bin bs nat.\n       \\<lbrakk>\\<And>m bin bs.\n                   drop m (bin_to_bl_aux n bin bs) =\n                   bin_to_bl_aux (n - m) bin (drop (m - n) bs);\n        n < m; m - n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop (m - n) (odd bin # bs) = drop (m - Suc n) bs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m bs nat.\n       \\<lbrakk>\\<And>m bin bs.\n                   drop m (bin_to_bl_aux n bin bs) =\n                   bin_to_bl_aux (n - m) bin (drop (m - n) bs);\n        n < m; m - n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop nat bs = drop (m - Suc n) bs", "apply (use Suc_diff_Suc in fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma drop_bin2bl: \"drop m (bin_to_bl n bin) = bin_to_bl (n - m) bin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop m (bin_to_bl n bin) = bin_to_bl (n - m) bin", "by (simp add: bin_to_bl_def drop_bin2bl_aux)"], ["", "lemma take_bin2bl_lem1: \"take m (bin_to_bl_aux m w bs) = bin_to_bl m w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take m (bin_to_bl_aux m w bs) = bin_to_bl m w", "apply (induct m arbitrary: w bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w bs. take 0 (bin_to_bl_aux 0 w bs) = bin_to_bl 0 w\n 2. \\<And>m w bs.\n       (\\<And>w bs.\n           take m (bin_to_bl_aux m w bs) = bin_to_bl m w) \\<Longrightarrow>\n       take (Suc m) (bin_to_bl_aux (Suc m) w bs) = bin_to_bl (Suc m) w", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m w bs.\n       (\\<And>w bs.\n           take m (bin_to_bl_aux m w bs) = bin_to_bl m w) \\<Longrightarrow>\n       take (Suc m) (bin_to_bl_aux (Suc m) w bs) = bin_to_bl (Suc m) w", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m w bs.\n       (\\<And>w bs.\n           take m (bin_to_bl_aux m w bs) = bin_to_bl m w) \\<Longrightarrow>\n       take (Suc m) (bin_to_bl_aux m (w div 2) (odd w # bs)) =\n       bin_to_bl (Suc m) w", "apply (simp add: bin_to_bl_aux_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m w. bin_to_bl m (w div 2) @ [odd w] = bin_to_bl (Suc m) w", "apply (simp add: bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m w.\n       bin_to_bl_aux m (w div 2) [] @ [odd w] =\n       bin_to_bl_aux m (w div 2) [odd w]", "apply (simp add: bin_to_bl_aux_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_bin2bl_lem: \"take m (bin_to_bl_aux (m + n) w bs) = take m (bin_to_bl (m + n) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take m (bin_to_bl_aux (m + n) w bs) = take m (bin_to_bl (m + n) w)", "by (induct n arbitrary: w bs) (simp_all (no_asm) add: bin_to_bl_def take_bin2bl_lem1, simp)"], ["", "lemma bin_split_take: \"bin_split n c = (a, b) \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl (m + n) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n c = (a, b) \\<Longrightarrow>\n    bin_to_bl m a = take m (bin_to_bl (m + n) c)", "apply (induct n arbitrary: b c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       bin_split 0 c = (a, b) \\<Longrightarrow>\n       bin_to_bl m a = take m (bin_to_bl (m + 0) c)\n 2. \\<And>n b c.\n       \\<lbrakk>\\<And>b c.\n                   bin_split n c = (a, b) \\<Longrightarrow>\n                   bin_to_bl m a = take m (bin_to_bl (m + n) c);\n        bin_split (Suc n) c = (a, b)\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl (m + Suc n) c)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n b c.\n       \\<lbrakk>\\<And>b c.\n                   bin_split n c = (a, b) \\<Longrightarrow>\n                   bin_to_bl m a = take m (bin_to_bl (m + n) c);\n        bin_split (Suc n) c = (a, b)\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl (m + Suc n) c)", "apply (clarsimp simp: Let_def split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>ca.\n                   drop_bit n ca = drop_bit (Suc n) c \\<Longrightarrow>\n                   bin_to_bl m (drop_bit (Suc n) c) =\n                   take m (bin_to_bl (m + n) ca);\n        a = drop_bit (Suc n) c\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl m (drop_bit (Suc n) c) =\n                         take m (bin_to_bl (Suc (m + n)) c)", "apply (simp add: bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n c.\n       \\<lbrakk>\\<And>ca.\n                   drop_bit n ca = drop_bit (Suc n) c \\<Longrightarrow>\n                   bin_to_bl_aux m (drop_bit (Suc n) c) [] =\n                   take m (bin_to_bl_aux (m + n) ca []);\n        a = drop_bit (Suc n) c\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux m (drop_bit (Suc n) c) [] =\n                         take m (bin_to_bl_aux (m + n) (c div 2) [odd c])", "apply (simp add: take_bin2bl_lem drop_bit_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_to_bl_drop_bit:\n  \"k = m + n \\<Longrightarrow> bin_to_bl m (drop_bit n c) = take m (bin_to_bl k c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = m + n \\<Longrightarrow>\n    bin_to_bl m (drop_bit n c) = take m (bin_to_bl k c)", "using bin_split_take"], ["proof (prove)\nusing this:\n  bin_split ?n ?c = (?a, ?b) \\<Longrightarrow>\n  bin_to_bl ?m ?a = take ?m (bin_to_bl (?m + ?n) ?c)\n\ngoal (1 subgoal):\n 1. k = m + n \\<Longrightarrow>\n    bin_to_bl m (drop_bit n c) = take m (bin_to_bl k c)", "by simp"], ["", "lemma bin_split_take1:\n  \"k = m + n \\<Longrightarrow> bin_split n c = (a, b) \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl k c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k = m + n; bin_split n c = (a, b)\\<rbrakk>\n    \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl k c)", "using bin_split_take"], ["proof (prove)\nusing this:\n  bin_split ?n ?c = (?a, ?b) \\<Longrightarrow>\n  bin_to_bl ?m ?a = take ?m (bin_to_bl (?m + ?n) ?c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k = m + n; bin_split n c = (a, b)\\<rbrakk>\n    \\<Longrightarrow> bin_to_bl m a = take m (bin_to_bl k c)", "by simp"], ["", "lemma bl_bin_bl_rep_drop:\n  \"bin_to_bl n (bl_to_bin bl) =\n    replicate (n - length bl) False @ drop (length bl - n) bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl n (bl_to_bin bl) =\n    replicate (n - length bl) False @ drop (length bl - n) bl", "by (simp add: bl_to_bin_inj bl_to_bin_rep_F trunc_bl2bin)"], ["", "lemma bl_to_bin_aux_cat:\n  \"bl_to_bin_aux bs (bin_cat w nv v) =\n    bin_cat w (nv + length bs) (bl_to_bin_aux bs v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin_aux bs (concat_bit nv v w) =\n    concat_bit (nv + length bs) (bl_to_bin_aux bs v) w", "by (rule bit_eqI)\n    (auto simp add: bin_nth_of_bl_aux bin_nth_cat algebra_simps)"], ["", "lemma bin_to_bl_aux_cat:\n  \"bin_to_bl_aux (nv + nw) (bin_cat v nw w) bs =\n    bin_to_bl_aux nv v (bin_to_bl_aux nw w bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl_aux (nv + nw) (concat_bit nw w v) bs =\n    bin_to_bl_aux nv v (bin_to_bl_aux nw w bs)", "by (induction nw arbitrary: w bs) (simp_all add: concat_bit_Suc)"], ["", "lemma bl_to_bin_aux_alt: \"bl_to_bin_aux bs w = bin_cat w (length bs) (bl_to_bin bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin_aux bs w = concat_bit (length bs) (bl_to_bin bs) w", "using bl_to_bin_aux_cat [where nv = \"0\" and v = \"0\"]"], ["proof (prove)\nusing this:\n  bl_to_bin_aux ?bs (concat_bit 0 0 ?w) =\n  concat_bit (0 + length ?bs) (bl_to_bin_aux ?bs 0) ?w\n\ngoal (1 subgoal):\n 1. bl_to_bin_aux bs w = concat_bit (length bs) (bl_to_bin bs) w", "by (simp add: bl_to_bin_def [symmetric])"], ["", "lemma bin_to_bl_cat:\n  \"bin_to_bl (nv + nw) (bin_cat v nw w) =\n    bin_to_bl_aux nv v (bin_to_bl nw w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl (nv + nw) (concat_bit nw w v) =\n    bin_to_bl_aux nv v (bin_to_bl nw w)", "by (simp add: bin_to_bl_def bin_to_bl_aux_cat)"], ["", "lemmas bl_to_bin_aux_app_cat =\n  trans [OF bl_to_bin_aux_append bl_to_bin_aux_alt]"], ["", "lemmas bin_to_bl_aux_cat_app =\n  trans [OF bin_to_bl_aux_cat bin_to_bl_aux_alt]"], ["", "lemma bl_to_bin_app_cat:\n  \"bl_to_bin (bsa @ bs) = bin_cat (bl_to_bin bsa) (length bs) (bl_to_bin bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (bsa @ bs) =\n    concat_bit (length bs) (bl_to_bin bs) (bl_to_bin bsa)", "by (simp only: bl_to_bin_aux_app_cat bl_to_bin_def)"], ["", "lemma bin_to_bl_cat_app:\n  \"bin_to_bl (n + nw) (bin_cat w nw wa) = bin_to_bl n w @ bin_to_bl nw wa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl (n + nw) (concat_bit nw wa w) =\n    bin_to_bl n w @ bin_to_bl nw wa", "by (simp only: bin_to_bl_def bin_to_bl_aux_cat_app)"], ["", "text \\<open>\\<open>bl_to_bin_app_cat_alt\\<close> and \\<open>bl_to_bin_app_cat\\<close> are easily interderivable.\\<close>"], ["", "lemma bl_to_bin_app_cat_alt: \"bin_cat (bl_to_bin cs) n w = bl_to_bin (cs @ bin_to_bl n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n w (bl_to_bin cs) = bl_to_bin (cs @ bin_to_bl n w)", "by (simp add: bl_to_bin_app_cat)"], ["", "lemma mask_lem: \"(bl_to_bin (True # replicate n False)) = bl_to_bin (replicate n True) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (True # replicate n False) = bl_to_bin (replicate n True) + 1", "apply (unfold bl_to_bin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin_aux (True # replicate n False) 0 =\n    bl_to_bin_aux (replicate n True) 0 + 1", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bl_to_bin_aux (True # replicate 0 False) 0 =\n    bl_to_bin_aux (replicate 0 True) 0 + 1\n 2. \\<And>n.\n       bl_to_bin_aux (True # replicate n False) 0 =\n       bl_to_bin_aux (replicate n True) 0 + 1 \\<Longrightarrow>\n       bl_to_bin_aux (True # replicate (Suc n) False) 0 =\n       bl_to_bin_aux (replicate (Suc n) True) 0 + 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       bl_to_bin_aux (True # replicate n False) 0 =\n       bl_to_bin_aux (replicate n True) 0 + 1 \\<Longrightarrow>\n       bl_to_bin_aux (True # replicate (Suc n) False) 0 =\n       bl_to_bin_aux (replicate (Suc n) True) 0 + 1", "apply (simp only: Suc_eq_plus1 replicate_add append_Cons [symmetric] bl_to_bin_aux_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       bl_to_bin_aux (True # replicate n False) 0 =\n       bl_to_bin_aux (replicate n True) 0 + 1 \\<Longrightarrow>\n       bl_to_bin_aux (replicate 1 False)\n        (bl_to_bin_aux (replicate n True) 0 + 1) =\n       bl_to_bin_aux (replicate 1 True)\n        (bl_to_bin_aux (replicate n True) 0) +\n       1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_exhaust:\n  \"(\\<And>x b. bin = of_bool b + 2 * x \\<Longrightarrow> Q) \\<Longrightarrow> Q\" for bin :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x b.\n        bin = of_bool b + 2 * x \\<Longrightarrow> Q) \\<Longrightarrow>\n    Q", "apply (cases \\<open>even bin\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x b. bin = of_bool b + 2 * x \\<Longrightarrow> Q;\n     even bin\\<rbrakk>\n    \\<Longrightarrow> Q\n 2. \\<lbrakk>\\<And>x b. bin = of_bool b + 2 * x \\<Longrightarrow> Q;\n     odd bin\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (auto elim!: evenE oddE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>x ba. 2 * b = of_bool ba + 2 * x \\<Longrightarrow> Q;\n        bin = 2 * b\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>b.\n       \\<lbrakk>\\<And>x ba.\n                   2 * b + 1 = of_bool ba + 2 * x \\<Longrightarrow> Q;\n        bin = 2 * b + 1\\<rbrakk>\n       \\<Longrightarrow> Q", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>x ba.\n                   2 * b + 1 = of_bool ba + 2 * x \\<Longrightarrow> Q;\n        bin = 2 * b + 1\\<rbrakk>\n       \\<Longrightarrow> Q", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec rbl_succ :: \"bool list \\<Rightarrow> bool list\"\n  where\n    Nil: \"rbl_succ Nil = Nil\"\n  | Cons: \"rbl_succ (x # xs) = (if x then False # rbl_succ xs else True # xs)\""], ["", "primrec rbl_pred :: \"bool list \\<Rightarrow> bool list\"\n  where\n    Nil: \"rbl_pred Nil = Nil\"\n  | Cons: \"rbl_pred (x # xs) = (if x then False # xs else True # rbl_pred xs)\""], ["", "primrec rbl_add :: \"bool list \\<Rightarrow> bool list \\<Rightarrow> bool list\"\n  where \\<comment> \\<open>result is length of first arg, second arg may be longer\\<close>\n    Nil: \"rbl_add Nil x = Nil\"\n  | Cons: \"rbl_add (y # ys) x =\n      (let ws = rbl_add ys (tl x)\n       in (y \\<noteq> hd x) # (if hd x \\<and> y then rbl_succ ws else ws))\""], ["", "primrec rbl_mult :: \"bool list \\<Rightarrow> bool list \\<Rightarrow> bool list\"\n  where \\<comment> \\<open>result is length of first arg, second arg may be longer\\<close>\n    Nil: \"rbl_mult Nil x = Nil\"\n  | Cons: \"rbl_mult (y # ys) x =\n      (let ws = False # rbl_mult ys x\n       in if y then rbl_add ws x else ws)\""], ["", "lemma size_rbl_pred: \"length (rbl_pred bl) = length bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rbl_pred bl) = length bl", "by (induct bl) auto"], ["", "lemma size_rbl_succ: \"length (rbl_succ bl) = length bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rbl_succ bl) = length bl", "by (induct bl) auto"], ["", "lemma size_rbl_add: \"length (rbl_add bl cl) = length bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rbl_add bl cl) = length bl", "by (induct bl arbitrary: cl) (auto simp: Let_def size_rbl_succ)"], ["", "lemma size_rbl_mult: \"length (rbl_mult bl cl) = length bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rbl_mult bl cl) = length bl", "by (induct bl arbitrary: cl) (auto simp add: Let_def size_rbl_add)"], ["", "lemmas rbl_sizes [simp] =\n  size_rbl_pred size_rbl_succ size_rbl_add size_rbl_mult"], ["", "lemmas rbl_Nils =\n  rbl_pred.Nil rbl_succ.Nil rbl_add.Nil rbl_mult.Nil"], ["", "lemma rbl_add_app2: \"length blb \\<ge> length bla \\<Longrightarrow> rbl_add bla (blb @ blc) = rbl_add bla blb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    rbl_add bla (blb @ blc) = rbl_add bla blb", "apply (induct bla arbitrary: blb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>blb.\n       length [] \\<le> length blb \\<Longrightarrow>\n       rbl_add [] (blb @ blc) = rbl_add [] blb\n 2. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (blb @ blc) = rbl_add bla blb;\n        length (a # bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> rbl_add (a # bla) (blb @ blc) =\n                         rbl_add (a # bla) blb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (blb @ blc) = rbl_add bla blb;\n        length (a # bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> rbl_add (a # bla) (blb @ blc) =\n                         rbl_add (a # bla) blb", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (blb @ blc) = rbl_add bla blb;\n        Suc (length bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> (let ws = rbl_add bla (tl (blb @ blc))\n                          in (a = (\\<not> hd (blb @ blc))) #\n                             (if hd (blb @ blc) \\<and> a then rbl_succ ws\n                              else ws)) =\n                         (let ws = rbl_add bla (tl blb)\n                          in (a = (\\<not> hd blb)) #\n                             (if hd blb \\<and> a then rbl_succ ws else ws))", "apply (case_tac blb, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb aa list.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (blb @ blc) = rbl_add bla blb;\n        Suc (length bla) \\<le> length blb; blb = aa # list\\<rbrakk>\n       \\<Longrightarrow> (let ws = rbl_add bla (tl (blb @ blc))\n                          in (a = (\\<not> hd (blb @ blc))) #\n                             (if hd (blb @ blc) \\<and> a then rbl_succ ws\n                              else ws)) =\n                         (let ws = rbl_add bla (tl blb)\n                          in (a = (\\<not> hd blb)) #\n                             (if hd blb \\<and> a then rbl_succ ws else ws))", "apply (clarsimp simp: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_add_take2:\n  \"length blb \\<ge> length bla \\<Longrightarrow> rbl_add bla (take (length bla) blb) = rbl_add bla blb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    rbl_add bla (take (length bla) blb) = rbl_add bla blb", "apply (induct bla arbitrary: blb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>blb.\n       length [] \\<le> length blb \\<Longrightarrow>\n       rbl_add [] (take (length []) blb) = rbl_add [] blb\n 2. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (take (length bla) blb) = rbl_add bla blb;\n        length (a # bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> rbl_add (a # bla) (take (length (a # bla)) blb) =\n                         rbl_add (a # bla) blb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (take (length bla) blb) = rbl_add bla blb;\n        length (a # bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> rbl_add (a # bla) (take (length (a # bla)) blb) =\n                         rbl_add (a # bla) blb", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (take (length bla) blb) = rbl_add bla blb;\n        Suc (length bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> (let ws = rbl_add bla\n                                    (tl (take (Suc (length bla)) blb))\n                          in (a = (\\<not> hd blb)) #\n                             (if hd blb \\<and> a then rbl_succ ws\n                              else ws)) =\n                         (let ws = rbl_add bla (tl blb)\n                          in (a = (\\<not> hd blb)) #\n                             (if hd blb \\<and> a then rbl_succ ws else ws))", "apply (case_tac blb, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb aa list.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_add bla (take (length bla) blb) = rbl_add bla blb;\n        Suc (length bla) \\<le> length blb; blb = aa # list\\<rbrakk>\n       \\<Longrightarrow> (let ws = rbl_add bla\n                                    (tl (take (Suc (length bla)) blb))\n                          in (a = (\\<not> hd blb)) #\n                             (if hd blb \\<and> a then rbl_succ ws\n                              else ws)) =\n                         (let ws = rbl_add bla (tl blb)\n                          in (a = (\\<not> hd blb)) #\n                             (if hd blb \\<and> a then rbl_succ ws else ws))", "apply (clarsimp simp: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_mult_app2: \"length blb \\<ge> length bla \\<Longrightarrow> rbl_mult bla (blb @ blc) = rbl_mult bla blb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    rbl_mult bla (blb @ blc) = rbl_mult bla blb", "apply (induct bla arbitrary: blb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>blb.\n       length [] \\<le> length blb \\<Longrightarrow>\n       rbl_mult [] (blb @ blc) = rbl_mult [] blb\n 2. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_mult bla (blb @ blc) = rbl_mult bla blb;\n        length (a # bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> rbl_mult (a # bla) (blb @ blc) =\n                         rbl_mult (a # bla) blb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_mult bla (blb @ blc) = rbl_mult bla blb;\n        length (a # bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> rbl_mult (a # bla) (blb @ blc) =\n                         rbl_mult (a # bla) blb", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_mult bla (blb @ blc) = rbl_mult bla blb;\n        Suc (length bla) \\<le> length blb\\<rbrakk>\n       \\<Longrightarrow> (let ws = False # rbl_mult bla blb\n                          in if a then rbl_add ws (blb @ blc) else ws) =\n                         (let ws = False # rbl_mult bla blb\n                          in if a then rbl_add ws blb else ws)", "apply (case_tac blb, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bla blb aa list.\n       \\<lbrakk>\\<And>blb.\n                   length bla \\<le> length blb \\<Longrightarrow>\n                   rbl_mult bla (blb @ blc) = rbl_mult bla blb;\n        Suc (length bla) \\<le> length blb; blb = aa # list\\<rbrakk>\n       \\<Longrightarrow> (let ws = False # rbl_mult bla blb\n                          in if a then rbl_add ws (blb @ blc) else ws) =\n                         (let ws = False # rbl_mult bla blb\n                          in if a then rbl_add ws blb else ws)", "apply (clarsimp simp: Let_def rbl_add_app2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_mult_take2:\n  \"length blb \\<ge> length bla \\<Longrightarrow> rbl_mult bla (take (length bla) blb) = rbl_mult bla blb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    rbl_mult bla (take (length bla) blb) = rbl_mult bla blb", "apply (rule trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    rbl_mult bla (take (length bla) blb) = ?s\n 2. length bla \\<le> length blb \\<Longrightarrow> ?s = rbl_mult bla blb", "apply (rule rbl_mult_app2 [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    length bla \\<le> length (take (length bla) blb)\n 2. length bla \\<le> length blb \\<Longrightarrow>\n    rbl_mult bla (take (length bla) blb @ ?blc3) = rbl_mult bla blb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    rbl_mult bla (take (length bla) blb @ ?blc3) = rbl_mult bla blb", "apply (rule_tac f = \"rbl_mult bla\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length bla \\<le> length blb \\<Longrightarrow>\n    take (length bla) blb @ ?blc3 = blb", "apply (rule append_take_drop_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_add_split:\n  \"P (rbl_add (y # ys) (x # xs)) =\n    (\\<forall>ws. length ws = length ys \\<longrightarrow> ws = rbl_add ys xs \\<longrightarrow>\n      (y \\<longrightarrow> ((x \\<longrightarrow> P (False # rbl_succ ws)) \\<and> (\\<not> x \\<longrightarrow> P (True # ws)))) \\<and>\n      (\\<not> y \\<longrightarrow> P (x # ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (rbl_add (y # ys) (x # xs)) =\n    (\\<forall>ws.\n        length ws = length ys \\<longrightarrow>\n        ws = rbl_add ys xs \\<longrightarrow>\n        (y \\<longrightarrow>\n         (x \\<longrightarrow> P (False # rbl_succ ws)) \\<and>\n         (\\<not> x \\<longrightarrow> P (True # ws))) \\<and>\n        (\\<not> y \\<longrightarrow> P (x # ws)))", "by (cases y) (auto simp: Let_def)"], ["", "lemma rbl_mult_split:\n  \"P (rbl_mult (y # ys) xs) =\n    (\\<forall>ws. length ws = Suc (length ys) \\<longrightarrow> ws = False # rbl_mult ys xs \\<longrightarrow>\n      (y \\<longrightarrow> P (rbl_add ws xs)) \\<and> (\\<not> y \\<longrightarrow> P ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (rbl_mult (y # ys) xs) =\n    (\\<forall>ws.\n        length ws = Suc (length ys) \\<longrightarrow>\n        ws = False # rbl_mult ys xs \\<longrightarrow>\n        (y \\<longrightarrow> P (rbl_add ws xs)) \\<and>\n        (\\<not> y \\<longrightarrow> P ws))", "by (auto simp: Let_def)"], ["", "lemma rbl_pred: \"rbl_pred (rev (bin_to_bl n bin)) = rev (bin_to_bl n (bin - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_pred (rev (bin_to_bl n bin)) = rev (bin_to_bl n (bin - 1))", "proof (unfold bin_to_bl_def, induction n arbitrary: bin)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bin.\n       rbl_pred (rev (bin_to_bl_aux 0 bin [])) =\n       rev (bin_to_bl_aux 0 (bin - 1) [])\n 2. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>bin.\n       rbl_pred (rev (bin_to_bl_aux 0 bin [])) =\n       rev (bin_to_bl_aux 0 (bin - 1) [])\n 2. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_pred (rev (bin_to_bl_aux 0 bin [])) =\n    rev (bin_to_bl_aux 0 (bin - 1) [])", "by simp"], ["proof (state)\nthis:\n  rbl_pred (rev (bin_to_bl_aux 0 bin [])) =\n  rev (bin_to_bl_aux 0 (bin - 1) [])\n\ngoal (1 subgoal):\n 1. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "case (Suc n)"], ["proof (state)\nthis:\n  rbl_pred (rev (bin_to_bl_aux n ?bin [])) =\n  rev (bin_to_bl_aux n (?bin - 1) [])\n\ngoal (1 subgoal):\n 1. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "obtain b k where \\<open>bin = of_bool b + 2 * k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b k.\n        bin = of_bool b + 2 * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bin_exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x b.\n      ?bin = of_bool b + 2 * x \\<Longrightarrow> ?Q) \\<Longrightarrow>\n  ?Q\n\ngoal (1 subgoal):\n 1. (\\<And>b k.\n        bin = of_bool b + 2 * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bin = of_bool b + 2 * k\n\ngoal (1 subgoal):\n 1. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "moreover"], ["proof (state)\nthis:\n  bin = of_bool b + 2 * k\n\ngoal (1 subgoal):\n 1. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "have \\<open>(2 * k - 1) div 2 = k - 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * k - 1) div 2 = k - 1", "using even_succ_div_2 [of \\<open>2 * (k - 1)\\<close>]"], ["proof (prove)\nusing this:\n  even (2 * (k - 1)) \\<Longrightarrow>\n  (1 + 2 * (k - 1)) div 2 = 2 * (k - 1) div 2\n\ngoal (1 subgoal):\n 1. (2 * k - 1) div 2 = k - 1", "by simp"], ["proof (state)\nthis:\n  (2 * k - 1) div 2 = k - 1\n\ngoal (1 subgoal):\n 1. \\<And>n bin.\n       (\\<And>bin.\n           rbl_pred (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin - 1) [])) \\<Longrightarrow>\n       rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "ultimately"], ["proof (chain)\npicking this:\n  bin = of_bool b + 2 * k\n  (2 * k - 1) div 2 = k - 1", "show ?case"], ["proof (prove)\nusing this:\n  bin = of_bool b + 2 * k\n  (2 * k - 1) div 2 = k - 1\n\ngoal (1 subgoal):\n 1. rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n    rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "using Suc [of \\<open>bin div 2\\<close>]"], ["proof (prove)\nusing this:\n  bin = of_bool b + 2 * k\n  (2 * k - 1) div 2 = k - 1\n  rbl_pred (rev (bin_to_bl_aux n (bin div 2) [])) =\n  rev (bin_to_bl_aux n (bin div 2 - 1) [])\n\ngoal (1 subgoal):\n 1. rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n    rev (bin_to_bl_aux (Suc n) (bin - 1) [])", "by simp (simp add: bin_to_bl_aux_alt)"], ["proof (state)\nthis:\n  rbl_pred (rev (bin_to_bl_aux (Suc n) bin [])) =\n  rev (bin_to_bl_aux (Suc n) (bin - 1) [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rbl_succ: \"rbl_succ (rev (bin_to_bl n bin)) = rev (bin_to_bl n (bin + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_succ (rev (bin_to_bl n bin)) = rev (bin_to_bl n (bin + 1))", "apply (unfold bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_succ (rev (bin_to_bl_aux n bin [])) =\n    rev (bin_to_bl_aux n (bin + 1) [])", "apply (induction n arbitrary: bin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bin.\n       rbl_succ (rev (bin_to_bl_aux 0 bin [])) =\n       rev (bin_to_bl_aux 0 (bin + 1) [])\n 2. \\<And>n bin.\n       (\\<And>bin.\n           rbl_succ (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin + 1) [])) \\<Longrightarrow>\n       rbl_succ (rev (bin_to_bl_aux (Suc n) bin [])) =\n       rev (bin_to_bl_aux (Suc n) (bin + 1) [])", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bin.\n       (\\<And>bin.\n           rbl_succ (rev (bin_to_bl_aux n bin [])) =\n           rev (bin_to_bl_aux n (bin + 1) [])) \\<Longrightarrow>\n       rbl_succ (rev (bin_to_bl_aux n (bin div 2) [odd bin])) =\n       rev (bin_to_bl_aux n ((bin + 1) div 2) [even bin])", "apply (case_tac bin rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bin x b.\n       \\<lbrakk>\\<And>bin.\n                   rbl_succ (rev (bin_to_bl_aux n bin [])) =\n                   rev (bin_to_bl_aux n (bin + 1) []);\n        bin = of_bool b + 2 * x\\<rbrakk>\n       \\<Longrightarrow> rbl_succ\n                          (rev (bin_to_bl_aux n (bin div 2) [odd bin])) =\n                         rev (bin_to_bl_aux n ((bin + 1) div 2) [even bin])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bin x b.\n       \\<lbrakk>\\<And>bin.\n                   rbl_succ (rev (bin_to_bl_aux n bin [])) =\n                   rev (bin_to_bl_aux n (bin + 1) []);\n        bin = of_bool b + 2 * x\\<rbrakk>\n       \\<Longrightarrow> (b \\<longrightarrow>\n                          rbl_succ (rev (bin_to_bl_aux n x [True])) =\n                          rev (bin_to_bl_aux n (1 + x) [False])) \\<and>\n                         (\\<not> b \\<longrightarrow>\n                          rbl_succ (rev (bin_to_bl_aux n x [False])) =\n                          rev (bin_to_bl_aux n x [True]))", "apply (simp add: bin_to_bl_aux_alt ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_add:\n  \"\\<And>bina binb. rbl_add (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n    rev (bin_to_bl n (bina + binb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bina binb.\n       rbl_add (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n       rev (bin_to_bl n (bina + binb))", "apply (unfold bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bina binb.\n       rbl_add (rev (bin_to_bl_aux n bina []))\n        (rev (bin_to_bl_aux n binb [])) =\n       rev (bin_to_bl_aux n (bina + binb) [])", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bina binb.\n       rbl_add (rev (bin_to_bl_aux 0 bina []))\n        (rev (bin_to_bl_aux 0 binb [])) =\n       rev (bin_to_bl_aux 0 (bina + binb) [])\n 2. \\<And>n bina binb.\n       (\\<And>bina binb.\n           rbl_add (rev (bin_to_bl_aux n bina []))\n            (rev (bin_to_bl_aux n binb [])) =\n           rev (bin_to_bl_aux n (bina + binb) [])) \\<Longrightarrow>\n       rbl_add (rev (bin_to_bl_aux (Suc n) bina []))\n        (rev (bin_to_bl_aux (Suc n) binb [])) =\n       rev (bin_to_bl_aux (Suc n) (bina + binb) [])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb.\n       (\\<And>bina binb.\n           rbl_add (rev (bin_to_bl_aux n bina []))\n            (rev (bin_to_bl_aux n binb [])) =\n           rev (bin_to_bl_aux n (bina + binb) [])) \\<Longrightarrow>\n       rbl_add (rev (bin_to_bl_aux (Suc n) bina []))\n        (rev (bin_to_bl_aux (Suc n) binb [])) =\n       rev (bin_to_bl_aux (Suc n) (bina + binb) [])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb.\n       (\\<And>bina binb.\n           rbl_add (rev (bin_to_bl_aux n bina []))\n            (rev (bin_to_bl_aux n binb [])) =\n           rev (bin_to_bl_aux n (bina + binb) [])) \\<Longrightarrow>\n       rbl_add (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n        (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n       rev (bin_to_bl_aux n ((bina + binb) div 2) [even bina = odd binb])", "apply (case_tac bina rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb x b.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])", "apply (case_tac binb rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa; b\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])\n 2. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa;\n        \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])", "apply (case_tac [!] \"ba\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa; b; ba\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])\n 2. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa; b;\n        \\<not> ba\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])\n 3. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa; \\<not> b;\n        ba\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])\n 4. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_add (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina + binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa; \\<not> b;\n        \\<not> ba\\<rbrakk>\n       \\<Longrightarrow> rbl_add\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n ((bina + binb) div 2)\n                               [even bina = odd binb])", "apply (auto simp: rbl_succ bin_to_bl_aux_alt Let_def ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_add_long:\n  \"m \\<ge> n \\<Longrightarrow> rbl_add (rev (bin_to_bl n bina)) (rev (bin_to_bl m binb)) =\n    rev (bin_to_bl n (bina + binb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    rbl_add (rev (bin_to_bl n bina)) (rev (bin_to_bl m binb)) =\n    rev (bin_to_bl n (bina + binb))", "apply (rule box_equals [OF _ rbl_add_take2 rbl_add])"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<le> m \\<Longrightarrow>\n    rbl_add (rev (bin_to_bl n bina))\n     (take (length (rev (bin_to_bl n bina))) (rev (bin_to_bl m binb))) =\n    rbl_add (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb))\n 2. n \\<le> m \\<Longrightarrow>\n    length (rev (bin_to_bl n bina)) \\<le> length (rev (bin_to_bl m binb))", "apply (rule_tac f = \"rbl_add (rev (bin_to_bl n bina))\" in arg_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<le> m \\<Longrightarrow>\n    take (length (rev (bin_to_bl n bina))) (rev (bin_to_bl m binb)) =\n    rev (bin_to_bl n binb)\n 2. n \\<le> m \\<Longrightarrow>\n    length (rev (bin_to_bl n bina)) \\<le> length (rev (bin_to_bl m binb))", "apply (rule rev_swap [THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<le> m \\<Longrightarrow>\n    rev (take (length (rev (bin_to_bl n bina))) (rev (bin_to_bl m binb))) =\n    bin_to_bl n binb\n 2. n \\<le> m \\<Longrightarrow>\n    length (rev (bin_to_bl n bina)) \\<le> length (rev (bin_to_bl m binb))", "apply (simp add: rev_take drop_bin2bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    length (rev (bin_to_bl n bina)) \\<le> length (rev (bin_to_bl m binb))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_mult_gt1:\n  \"m \\<ge> length bl \\<Longrightarrow>\n    rbl_mult bl (rev (bin_to_bl m binb)) =\n    rbl_mult bl (rev (bin_to_bl (length bl) binb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bl \\<le> m \\<Longrightarrow>\n    rbl_mult bl (rev (bin_to_bl m binb)) =\n    rbl_mult bl (rev (bin_to_bl (length bl) binb))", "apply (rule trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length bl \\<le> m \\<Longrightarrow>\n    rbl_mult bl (rev (bin_to_bl m binb)) = ?s\n 2. length bl \\<le> m \\<Longrightarrow>\n    ?s = rbl_mult bl (rev (bin_to_bl (length bl) binb))", "apply (rule rbl_mult_take2 [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. length bl \\<le> m \\<Longrightarrow>\n    length bl \\<le> length (rev (bin_to_bl m binb))\n 2. length bl \\<le> m \\<Longrightarrow>\n    rbl_mult bl (take (length bl) (rev (bin_to_bl m binb))) =\n    rbl_mult bl (rev (bin_to_bl (length bl) binb))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. length bl \\<le> m \\<Longrightarrow>\n    rbl_mult bl (take (length bl) (rev (bin_to_bl m binb))) =\n    rbl_mult bl (rev (bin_to_bl (length bl) binb))", "apply (rule_tac f = \"rbl_mult bl\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length bl \\<le> m \\<Longrightarrow>\n    take (length bl) (rev (bin_to_bl m binb)) =\n    rev (bin_to_bl (length bl) binb)", "apply (rule rev_swap [THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length bl \\<le> m \\<Longrightarrow>\n    rev (take (length bl) (rev (bin_to_bl m binb))) =\n    bin_to_bl (length bl) binb", "apply (simp add: rev_take drop_bin2bl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_mult_gt:\n  \"m > n \\<Longrightarrow>\n    rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl m binb)) =\n    rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow>\n    rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl m binb)) =\n    rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb))", "by (auto intro: trans [OF rbl_mult_gt1])"], ["", "lemmas rbl_mult_Suc = lessI [THEN rbl_mult_gt]"], ["", "lemma rbbl_Cons: \"b # rev (bin_to_bl n x) = rev (bin_to_bl (Suc n) (of_bool b + 2 * x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b # rev (bin_to_bl n x) = rev (bin_to_bl (Suc n) (of_bool b + 2 * x))", "by (simp add: bin_to_bl_def) (simp add: bin_to_bl_aux_alt)"], ["", "lemma rbl_mult:\n  \"rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n    rev (bin_to_bl n (bina * binb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n    rev (bin_to_bl n (bina * binb))", "apply (induct n arbitrary: bina binb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bina binb.\n       rbl_mult (rev (bin_to_bl 0 bina)) (rev (bin_to_bl 0 binb)) =\n       rev (bin_to_bl 0 (bina * binb))\n 2. \\<And>n bina binb.\n       (\\<And>bina binb.\n           rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n           rev (bin_to_bl n (bina * binb))) \\<Longrightarrow>\n       rbl_mult (rev (bin_to_bl (Suc n) bina))\n        (rev (bin_to_bl (Suc n) binb)) =\n       rev (bin_to_bl (Suc n) (bina * binb))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb.\n       (\\<And>bina binb.\n           rbl_mult (rev (bin_to_bl n bina)) (rev (bin_to_bl n binb)) =\n           rev (bin_to_bl n (bina * binb))) \\<Longrightarrow>\n       rbl_mult (rev (bin_to_bl (Suc n) bina))\n        (rev (bin_to_bl (Suc n) binb)) =\n       rev (bin_to_bl (Suc n) (bina * binb))", "apply (unfold bin_to_bl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb.\n       (\\<And>bina binb.\n           rbl_mult (rev (bin_to_bl_aux n bina []))\n            (rev (bin_to_bl_aux n binb [])) =\n           rev (bin_to_bl_aux n (bina * binb) [])) \\<Longrightarrow>\n       rbl_mult (rev (bin_to_bl_aux (Suc n) bina []))\n        (rev (bin_to_bl_aux (Suc n) binb [])) =\n       rev (bin_to_bl_aux (Suc n) (bina * binb) [])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb.\n       (\\<And>bina binb.\n           rbl_mult (rev (bin_to_bl_aux n bina []))\n            (rev (bin_to_bl_aux n binb [])) =\n           rev (bin_to_bl_aux n (bina * binb) [])) \\<Longrightarrow>\n       rbl_mult (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n        (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n       rev (bin_to_bl_aux n (bina * binb div 2) [odd bina \\<and> odd binb])", "apply (case_tac bina rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb x b.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_mult (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina * binb) []);\n        bina = of_bool b + 2 * x\\<rbrakk>\n       \\<Longrightarrow> rbl_mult\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n (bina * binb div 2)\n                               [odd bina \\<and> odd binb])", "apply (case_tac binb rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_mult (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina * binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa\\<rbrakk>\n       \\<Longrightarrow> rbl_mult\n                          (rev (bin_to_bl_aux n (bina div 2) [odd bina]))\n                          (rev (bin_to_bl_aux n (binb div 2) [odd binb])) =\n                         rev (bin_to_bl_aux n (bina * binb div 2)\n                               [odd bina \\<and> odd binb])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_mult (rev (bin_to_bl_aux n bina []))\n                    (rev (bin_to_bl_aux n binb [])) =\n                   rev (bin_to_bl_aux n (bina * binb) []);\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa\\<rbrakk>\n       \\<Longrightarrow> (b \\<longrightarrow>\n                          (ba \\<longrightarrow>\n                           rbl_mult (rev (bin_to_bl_aux n x [True]))\n                            (rev (bin_to_bl_aux n xa [True])) =\n                           rev (bin_to_bl_aux n\n                                 ((1 + 2 * x) * (1 + 2 * xa) div 2)\n                                 [True])) \\<and>\n                          (\\<not> ba \\<longrightarrow>\n                           rbl_mult (rev (bin_to_bl_aux n x [True]))\n                            (rev (bin_to_bl_aux n xa [False])) =\n                           rev (bin_to_bl_aux n ((1 + 2 * x) * xa)\n                                 [False]))) \\<and>\n                         (\\<not> b \\<longrightarrow>\n                          (ba \\<longrightarrow>\n                           rbl_mult (rev (bin_to_bl_aux n x [False]))\n                            (rev (bin_to_bl_aux n xa [True])) =\n                           rev (bin_to_bl_aux n (x * (1 + 2 * xa))\n                                 [False])) \\<and>\n                          (\\<not> ba \\<longrightarrow>\n                           rbl_mult (rev (bin_to_bl_aux n x [False]))\n                            (rev (bin_to_bl_aux n xa [False])) =\n                           rev (bin_to_bl_aux n (2 * x * xa) [False])))", "apply (simp add: bin_to_bl_aux_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bina binb x b xa ba.\n       \\<lbrakk>\\<And>bina binb.\n                   rbl_mult (rev (bin_to_bl n bina))\n                    (rev (bin_to_bl n binb)) =\n                   rev (bin_to_bl n (bina * binb));\n        bina = of_bool b + 2 * x; binb = of_bool ba + 2 * xa\\<rbrakk>\n       \\<Longrightarrow> (b \\<longrightarrow>\n                          (ba \\<longrightarrow>\n                           rbl_add\n                            (rbl_mult (rev (bin_to_bl n x))\n                              (True # rev (bin_to_bl n xa)))\n                            (rev (bin_to_bl n xa)) =\n                           rev (bin_to_bl n\n                                 ((1 + 2 * x) * (1 + 2 * xa) div 2))) \\<and>\n                          (\\<not> ba \\<longrightarrow>\n                           rbl_add\n                            (rbl_mult (rev (bin_to_bl n x))\n                              (False # rev (bin_to_bl n xa)))\n                            (rev (bin_to_bl n xa)) =\n                           rev (bin_to_bl n ((1 + 2 * x) * xa)))) \\<and>\n                         (\\<not> b \\<longrightarrow>\n                          (ba \\<longrightarrow>\n                           rbl_mult (rev (bin_to_bl n x))\n                            (True # rev (bin_to_bl n xa)) =\n                           rev (bin_to_bl n (x * (1 + 2 * xa)))) \\<and>\n                          (\\<not> ba \\<longrightarrow>\n                           rbl_mult (rev (bin_to_bl n x))\n                            (False # rev (bin_to_bl n xa)) =\n                           rev (bin_to_bl n (2 * x * xa))))", "apply (simp add: rbbl_Cons rbl_mult_Suc rbl_add algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sclem: \"size (concat (map (bin_to_bl n) xs)) = length xs * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (map (bin_to_bl n) xs)) = length xs * n", "by (induct xs) auto"], ["", "lemma bin_cat_foldl_lem:\n  \"foldl (\\<lambda>u. bin_cat u n) x xs =\n    bin_cat x (size xs * n) (foldl (\\<lambda>u. bin_cat u n) y xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>u l. concat_bit n l u) x xs =\n    concat_bit (length xs * n) (foldl (\\<lambda>u l. concat_bit n l u) y xs)\n     x", "apply (induct xs arbitrary: x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       foldl (\\<lambda>u l. concat_bit n l u) x [] =\n       concat_bit (length [] * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) y []) x\n 2. \\<And>a xs x.\n       (\\<And>x.\n           foldl (\\<lambda>u l. concat_bit n l u) x xs =\n           concat_bit (length xs * n)\n            (foldl (\\<lambda>u l. concat_bit n l u) y xs)\n            x) \\<Longrightarrow>\n       foldl (\\<lambda>u l. concat_bit n l u) x (a # xs) =\n       concat_bit (length (a # xs) * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) y (a # xs)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           foldl (\\<lambda>u l. concat_bit n l u) x xs =\n           concat_bit (length xs * n)\n            (foldl (\\<lambda>u l. concat_bit n l u) y xs)\n            x) \\<Longrightarrow>\n       foldl (\\<lambda>u l. concat_bit n l u) x (a # xs) =\n       concat_bit (length (a # xs) * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) y (a # xs)) x", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           foldl (\\<lambda>u l. concat_bit n l u) x xs =\n           concat_bit (length xs * n)\n            (foldl (\\<lambda>u l. concat_bit n l u) y xs)\n            x) \\<Longrightarrow>\n       foldl (\\<lambda>u l. concat_bit n l u) (concat_bit n a x) xs =\n       concat_bit (n + length xs * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) (concat_bit n a y) xs) x", "apply (frule asm_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   foldl (\\<lambda>u l. concat_bit n l u) x xs =\n                   concat_bit (length xs * n)\n                    (foldl (\\<lambda>u l. concat_bit n l u) y xs) x;\n        \\<And>x.\n           foldl (\\<lambda>u l. concat_bit n l u) x xs =\n           concat_bit (length xs * n)\n            (foldl (\\<lambda>u l. concat_bit n l u) y xs) x\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>u l. concat_bit n l u)\n                          (concat_bit n a x) xs =\n                         concat_bit (n + length xs * n)\n                          (foldl (\\<lambda>u l. concat_bit n l u)\n                            (concat_bit n a y) xs)\n                          x", "apply (drule meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   foldl (\\<lambda>u l. concat_bit n l u) x xs =\n                   concat_bit (length xs * n)\n                    (foldl (\\<lambda>u l. concat_bit n l u) y xs) x;\n        foldl (\\<lambda>u l. concat_bit n l u) (?x4 a xs x) xs =\n        concat_bit (length xs * n)\n         (foldl (\\<lambda>u l. concat_bit n l u) y xs) (?x4 a xs x)\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>u l. concat_bit n l u)\n                          (concat_bit n a x) xs =\n                         concat_bit (n + length xs * n)\n                          (foldl (\\<lambda>u l. concat_bit n l u)\n                            (concat_bit n a y) xs)\n                          x", "apply (erule trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           foldl (\\<lambda>u l. concat_bit n l u) x xs =\n           concat_bit (length xs * n)\n            (foldl (\\<lambda>u l. concat_bit n l u) y xs)\n            x) \\<Longrightarrow>\n       concat_bit (length xs * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) y xs) (concat_bit n a x) =\n       concat_bit (n + length xs * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) (concat_bit n a y) xs) x", "apply (drule_tac x = \"bin_cat y n a\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       foldl (\\<lambda>u l. concat_bit n l u) (concat_bit n a y) xs =\n       concat_bit (length xs * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) y xs)\n        (concat_bit n a y) \\<Longrightarrow>\n       concat_bit (length xs * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) y xs) (concat_bit n a x) =\n       concat_bit (n + length xs * n)\n        (foldl (\\<lambda>u l. concat_bit n l u) (concat_bit n a y) xs) x", "apply (simp add: bin_cat_assoc_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_rcat_bl: \"bin_rcat n wl = bl_to_bin (concat (map (bin_to_bl n) wl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rcat n wl = bl_to_bin (concat (map (bin_to_bl n) wl))", "apply (unfold bin_rcat_eq_foldl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>u v. concat_bit n v u) 0 wl =\n    bl_to_bin (concat (map (bin_to_bl n) wl))", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (concat (map (bin_to_bl n) wl)) =\n    foldl (\\<lambda>u v. concat_bit n v u) 0 wl", "apply (induct wl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bl_to_bin (concat (map (bin_to_bl n) [])) =\n    foldl (\\<lambda>u v. concat_bit n v u) 0 []\n 2. \\<And>a wl.\n       bl_to_bin (concat (map (bin_to_bl n) wl)) =\n       foldl (\\<lambda>u v. concat_bit n v u) 0 wl \\<Longrightarrow>\n       bl_to_bin (concat (map (bin_to_bl n) (a # wl))) =\n       foldl (\\<lambda>u v. concat_bit n v u) 0 (a # wl)", "apply (auto simp add: bl_to_bin_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wl.\n       bl_to_bin (concat (map (bin_to_bl n) wl)) =\n       foldl (\\<lambda>u v. concat_bit n v u) 0 wl \\<Longrightarrow>\n       bl_to_bin_aux (concat (map (bin_to_bl n) wl)) (take_bit n a) =\n       foldl (\\<lambda>u v. concat_bit n v u) (take_bit n a) wl", "apply (simp add: bl_to_bin_aux_alt sclem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wl.\n       bl_to_bin (concat (map (bin_to_bl n) wl)) =\n       foldl (\\<lambda>u v. concat_bit n v u) 0 wl \\<Longrightarrow>\n       concat_bit (length wl * n)\n        (foldl (\\<lambda>u v. concat_bit n v u) 0 wl) (take_bit n a) =\n       foldl (\\<lambda>u v. concat_bit n v u) (take_bit n a) wl", "apply (simp add: bin_cat_foldl_lem [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_last_bl_to_bin: \"bin_last (bl_to_bin bs) \\<longleftrightarrow> bs \\<noteq> [] \\<and> last bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (bl_to_bin bs) = (bs \\<noteq> [] \\<and> last bs)", "by(cases \"bs = []\")(auto simp add: bl_to_bin_def last_bin_last'[where w=0])"], ["", "lemma bin_rest_bl_to_bin: \"bin_rest (bl_to_bin bs) = bl_to_bin (butlast bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin bs div 2 = bl_to_bin (butlast bs)", "by(cases \"bs = []\")(simp_all add: bl_to_bin_def butlast_rest_bl2bin_aux)"], ["", "lemma bl_xor_aux_bin:\n  \"map2 (\\<lambda>x y. x \\<noteq> y) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v XOR w) (map2 (\\<lambda>x y. x \\<noteq> y) bs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<noteq>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v XOR w) (map2 (\\<noteq>) bs cs)", "apply (induction n arbitrary: v w bs cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v w bs cs.\n       map2 (\\<noteq>) (bin_to_bl_aux 0 v bs) (bin_to_bl_aux 0 w cs) =\n       bin_to_bl_aux 0 (v XOR w) (map2 (\\<noteq>) bs cs)\n 2. \\<And>n v w bs cs.\n       (\\<And>v w bs cs.\n           map2 (\\<noteq>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n           bin_to_bl_aux n (v XOR w)\n            (map2 (\\<noteq>) bs cs)) \\<Longrightarrow>\n       map2 (\\<noteq>) (bin_to_bl_aux (Suc n) v bs)\n        (bin_to_bl_aux (Suc n) w cs) =\n       bin_to_bl_aux (Suc n) (v XOR w) (map2 (\\<noteq>) bs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v w bs cs.\n       (\\<And>v w bs cs.\n           map2 (\\<lambda>x y. x = (\\<not> y)) (bin_to_bl_aux n v bs)\n            (bin_to_bl_aux n w cs) =\n           bin_to_bl_aux n (v XOR w)\n            (map2 (\\<lambda>x y. x = (\\<not> y)) bs cs)) \\<Longrightarrow>\n       bin_to_bl_aux n (v div 2 XOR w div 2)\n        ((even v = odd w) # map2 (\\<lambda>x y. x = (\\<not> y)) bs cs) =\n       bin_to_bl_aux n (v div 2 XOR w div 2)\n        (((even v \\<longrightarrow> odd w) \\<and> (even v \\<or> even w)) #\n         map2 (\\<lambda>x y. x = (\\<not> y)) bs cs)", "apply (case_tac v rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v w bs cs x b.\n       \\<lbrakk>\\<And>v w bs cs.\n                   map2 (\\<lambda>x y. x = (\\<not> y))\n                    (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n                   bin_to_bl_aux n (v XOR w)\n                    (map2 (\\<lambda>x y. x = (\\<not> y)) bs cs);\n        v = of_bool b + 2 * x\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux n (v div 2 XOR w div 2)\n                          ((even v = odd w) #\n                           map2 (\\<lambda>x y. x = (\\<not> y)) bs cs) =\n                         bin_to_bl_aux n (v div 2 XOR w div 2)\n                          (((even v \\<longrightarrow> odd w) \\<and>\n                            (even v \\<or> even w)) #\n                           map2 (\\<lambda>x y. x = (\\<not> y)) bs cs)", "apply (case_tac w rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v w bs cs x b xa ba.\n       \\<lbrakk>\\<And>v w bs cs.\n                   map2 (\\<lambda>x y. x = (\\<not> y))\n                    (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n                   bin_to_bl_aux n (v XOR w)\n                    (map2 (\\<lambda>x y. x = (\\<not> y)) bs cs);\n        v = of_bool b + 2 * x; w = of_bool ba + 2 * xa\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl_aux n (v div 2 XOR w div 2)\n                          ((even v = odd w) #\n                           map2 (\\<lambda>x y. x = (\\<not> y)) bs cs) =\n                         bin_to_bl_aux n (v div 2 XOR w div 2)\n                          (((even v \\<longrightarrow> odd w) \\<and>\n                            (even v \\<or> even w)) #\n                           map2 (\\<lambda>x y. x = (\\<not> y)) bs cs)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_or_aux_bin:\n  \"map2 (\\<or>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v OR w) (map2 (\\<or>) bs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<or>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v OR w) (map2 (\\<or>) bs cs)", "by (induct n arbitrary: v w bs cs) simp_all"], ["", "lemma bl_and_aux_bin:\n  \"map2 (\\<and>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v AND w) (map2 (\\<and>) bs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<and>) (bin_to_bl_aux n v bs) (bin_to_bl_aux n w cs) =\n    bin_to_bl_aux n (v AND w) (map2 (\\<and>) bs cs)", "by (induction n arbitrary: v w bs cs) simp_all"], ["", "lemma bl_not_aux_bin: \"map Not (bin_to_bl_aux n w cs) = bin_to_bl_aux n (NOT w) (map Not cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map Not (bin_to_bl_aux n w cs) = bin_to_bl_aux n (NOT w) (map Not cs)", "by (induct n arbitrary: w cs) auto"], ["", "lemma bl_not_bin: \"map Not (bin_to_bl n w) = bin_to_bl n (NOT w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map Not (bin_to_bl n w) = bin_to_bl n (NOT w)", "by (simp add: bin_to_bl_def bl_not_aux_bin)"], ["", "lemma bl_and_bin: \"map2 (\\<and>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v AND w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<and>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v AND w)", "by (simp add: bin_to_bl_def bl_and_aux_bin)"], ["", "lemma bl_or_bin: \"map2 (\\<or>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v OR w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<or>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v OR w)", "by (simp add: bin_to_bl_def bl_or_aux_bin)"], ["", "lemma bl_xor_bin: \"map2 (\\<noteq>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v XOR w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<noteq>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v XOR w)", "using bl_xor_aux_bin"], ["proof (prove)\nusing this:\n  map2 (\\<noteq>) (bin_to_bl_aux ?n ?v ?bs) (bin_to_bl_aux ?n ?w ?cs) =\n  bin_to_bl_aux ?n (?v XOR ?w) (map2 (\\<noteq>) ?bs ?cs)\n\ngoal (1 subgoal):\n 1. map2 (\\<noteq>) (bin_to_bl n v) (bin_to_bl n w) = bin_to_bl n (v XOR w)", "by (simp add: bin_to_bl_def)"], ["", "subsection \\<open>Type \\<^typ>\\<open>'a word\\<close>\\<close>"], ["", "lift_definition of_bl :: \\<open>bool list \\<Rightarrow> 'a::len word\\<close>\n  is bl_to_bin"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition to_bl :: \\<open>'a::len word \\<Rightarrow> bool list\\<close>\n  is \\<open>bin_to_bl LENGTH('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int1 int2.\n       take_bit LENGTH('a) int1 = take_bit LENGTH('a) int2 \\<Longrightarrow>\n       bin_to_bl LENGTH('a) int1 = bin_to_bl LENGTH('a) int2", "by (simp add: bl_to_bin_inj)"], ["", "lemma to_bl_eq:\n  \\<open>to_bl w = bin_to_bl (LENGTH('a)) (uint w)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = bin_to_bl LENGTH('a) (uint w)", "by transfer simp"], ["", "lemma bit_of_bl_iff [bit_simps]:\n  \\<open>bit (of_bl bs :: 'a word) n \\<longleftrightarrow> rev bs ! n \\<and> n < LENGTH('a::len) \\<and> n < length bs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (of_bl bs) n =\n    (rev bs ! n \\<and> n < LENGTH('a) \\<and> n < length bs)", "by transfer (simp add: bin_nth_of_bl ac_simps)"], ["", "lemma rev_to_bl_eq:\n  \\<open>rev (to_bl w) = map (bit w) [0..<LENGTH('a)]\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl w) = map (bit w) [0..<LENGTH('a)]", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (rev (to_bl w)) = length (map (bit w) [0..<LENGTH('a)])\n 2. \\<And>i.\n       i < length (rev (to_bl w)) \\<Longrightarrow>\n       rev (to_bl w) ! i = map (bit w) [0..<LENGTH('a)] ! i", "apply (simp add: to_bl.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (rev (to_bl w)) \\<Longrightarrow>\n       rev (to_bl w) ! i = map (bit w) [0..<LENGTH('a)] ! i", "apply (simp add: bin_nth_bl bit_word.rep_eq to_bl.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_bl_eq_rev:\n  \\<open>to_bl w = map (bit w) (rev [0..<LENGTH('a)])\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = map (bit w) (rev [0..<LENGTH('a)])", "using rev_to_bl_eq [of w]"], ["proof (prove)\nusing this:\n  rev (to_bl w) = map (bit w) [0..<LENGTH('a)]\n\ngoal (1 subgoal):\n 1. to_bl w = map (bit w) (rev [0..<LENGTH('a)])", "apply (subst rev_is_rev_conv [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl w) = map (bit w) [0..<LENGTH('a)] \\<Longrightarrow>\n    rev (to_bl w) = rev (map (bit w) (rev [0..<LENGTH('a)]))", "apply (simp add: rev_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_bl_rev_eq:\n  \\<open>of_bl (rev bs) = horner_sum of_bool 2 bs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (rev bs) = horner_sum of_bool 2 bs", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       bit (of_bl (rev bs)) n = bit (horner_sum of_bool 2 bs) n", "apply (simp add: bit_of_bl_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       (bs ! n \\<and> n < length bs) = bit (horner_sum of_bool 2 bs) n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bs.\n       n < LENGTH('a) \\<Longrightarrow>\n       (bs ! n \\<and> n < length bs) =\n       (n < LENGTH('a) \\<and> bit (horner_sum of_bool 2 bs) n)", "apply (simp add: bit_horner_sum_bit_iff ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_bl_eq:\n  \\<open>of_bl bs = horner_sum of_bool 2 (rev bs)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl bs = horner_sum of_bool 2 (rev bs)", "using of_bl_rev_eq [of \\<open>rev bs\\<close>]"], ["proof (prove)\nusing this:\n  of_bl (rev (rev bs)) = horner_sum of_bool 2 (rev bs)\n\ngoal (1 subgoal):\n 1. of_bl bs = horner_sum of_bool 2 (rev bs)", "by simp"], ["", "lemma bshiftr1_eq:\n  \\<open>bshiftr1 b w = of_bl (b # butlast (to_bl w))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bshiftr1 b w = of_bl (b # butlast (to_bl w))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b w.\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a) w div 2 +\n         of_bool b * 2 ^ (LENGTH('a) - Suc 0)) =\n       take_bit LENGTH('a)\n        (bl_to_bin (b # butlast (bin_to_bl LENGTH('a) w)))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b w.\n       b \\<Longrightarrow>\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a) w div 2 + 2 ^ (LENGTH('a) - Suc 0)) =\n       take_bit LENGTH('a)\n        (bl_to_bin (True # butlast (bin_to_bl LENGTH('a) w)))\n 2. \\<And>b w.\n       \\<not> b \\<Longrightarrow>\n       take_bit LENGTH('a) w div 2 =\n       take_bit LENGTH('a) (bl_to_bin (butlast (bin_to_bl LENGTH('a) w)))", "apply (subst bl_to_bin_app_cat [of \\<open>[True]\\<close>, simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b w.\n       b \\<Longrightarrow>\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a) w div 2 + 2 ^ (LENGTH('a) - Suc 0)) =\n       take_bit LENGTH('a)\n        (concat_bit (length (butlast (bin_to_bl LENGTH('a) w)))\n          (bl_to_bin (butlast (bin_to_bl LENGTH('a) w))) (bl_to_bin [True]))\n 2. \\<And>b w.\n       \\<not> b \\<Longrightarrow>\n       take_bit LENGTH('a) w div 2 =\n       take_bit LENGTH('a) (bl_to_bin (butlast (bin_to_bl LENGTH('a) w)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b w.\n       b \\<Longrightarrow>\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a) w div 2 + 2 ^ (LENGTH('a) - Suc 0)) =\n       take_bit LENGTH('a)\n        (concat_bit (LENGTH('a) - Suc 0)\n          (bl_to_bin (butlast (bin_to_bl LENGTH('a) w))) (bl_to_bin [True]))\n 2. \\<And>b w.\n       \\<not> b \\<Longrightarrow>\n       take_bit LENGTH('a) w div 2 =\n       take_bit LENGTH('a) (bl_to_bin (butlast (bin_to_bl LENGTH('a) w)))", "apply (metis One_nat_def add.commute bin_bl_bin bin_last_bl_to_bin bin_rest_bl_to_bin butlast_bin_rest concat_bit_eq last.simps list.distinct(1) list.size(3) list.size(4) odd_iff_mod_2_eq_one plus_1_eq_Suc power_Suc0_right push_bit_of_1 size_bin_to_bl take_bit_eq_mod trunc_bl2bin_len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b w.\n       \\<not> b \\<Longrightarrow>\n       take_bit LENGTH('a) w div 2 =\n       take_bit LENGTH('a) (bl_to_bin (butlast (bin_to_bl LENGTH('a) w)))", "apply (simp add: butlast_rest_bl2bin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_to_bl_eq:\n  \\<open>length (to_bl w) = LENGTH('a)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (to_bl w) = LENGTH('a)", "by transfer simp"], ["", "lemma word_rotr_eq:\n  \\<open>word_rotr n w = of_bl (rotater n (to_bl w))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_rotr n w = of_bl (rotater n (to_bl w))", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (word_rotr n w) na = bit (of_bl (rotater n (to_bl w))) na", "subgoal for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    bit (word_rotr n w) n = bit (of_bl (rotater n (to_bl w))) n", "apply (cases \\<open>n < LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bit (word_rotr n w) n =\n                      bit (of_bl (rotater n (to_bl w))) n\n 2. \\<lbrakk>n < LENGTH('a); \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bit (word_rotr n w) n =\n                      bit (of_bl (rotater n (to_bl w))) n", "apply (simp_all add: bit_word_rotr_iff bit_of_bl_iff rotater_rev length_to_bl_eq nth_rotate rev_to_bl_eq ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_rotl_eq:\n  \\<open>word_rotl n w = of_bl (rotate n (to_bl w))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_rotl n w = of_bl (rotate n (to_bl w))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. word_rotl n w = of_bl (rotate n (to_bl w))", "have \\<open>rotate n (to_bl w) = rev (rotater n (rev (to_bl w)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate n (to_bl w) = rev (rotater n (rev (to_bl w)))", "by (simp add: rotater_rev')"], ["proof (state)\nthis:\n  rotate n (to_bl w) = rev (rotater n (rev (to_bl w)))\n\ngoal (1 subgoal):\n 1. word_rotl n w = of_bl (rotate n (to_bl w))", "then"], ["proof (chain)\npicking this:\n  rotate n (to_bl w) = rev (rotater n (rev (to_bl w)))", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate n (to_bl w) = rev (rotater n (rev (to_bl w)))\n\ngoal (1 subgoal):\n 1. word_rotl n w = of_bl (rotate n (to_bl w))", "apply (simp add: word_rotl_eq_word_rotr bit_of_bl_iff length_to_bl_eq rev_to_bl_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate n (to_bl w) =\n    rev (rotater n (map (bit w) [0..<LENGTH('a)])) \\<Longrightarrow>\n    word_rotr (LENGTH('a) - n mod LENGTH('a)) w =\n    of_bl (rev (rotater n (map (bit w) [0..<LENGTH('a)])))", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>rotate n (to_bl w) =\n                rev (rotater n (map (bit w) [0..<LENGTH('a)]));\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (word_rotr (LENGTH('a) - n mod LENGTH('a)) w)\n                          na =\n                         bit (of_bl\n                               (rev (rotater n\n(map (bit w) [0..<LENGTH('a)]))))\n                          na", "subgoal for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate n (to_bl w) =\n             rev (rotater n (map (bit w) [0..<LENGTH('a)]));\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bit (word_rotr (LENGTH('a) - n mod LENGTH('a)) w) n =\n                      bit (of_bl\n                            (rev (rotater n\n                                   (map (bit w) [0..<LENGTH('a)]))))\n                       n", "apply (cases \\<open>n < LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rotate n (to_bl w) =\n             rev (rotater n (map (bit w) [0..<LENGTH('a)]));\n     n < LENGTH('a); n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bit (word_rotr (LENGTH('a) - n mod LENGTH('a)) w) n =\n                      bit (of_bl\n                            (rev (rotater n\n                                   (map (bit w) [0..<LENGTH('a)]))))\n                       n\n 2. \\<lbrakk>rotate n (to_bl w) =\n             rev (rotater n (map (bit w) [0..<LENGTH('a)]));\n     n < LENGTH('a); \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bit (word_rotr (LENGTH('a) - n mod LENGTH('a)) w) n =\n                      bit (of_bl\n                            (rev (rotater n\n                                   (map (bit w) [0..<LENGTH('a)]))))\n                       n", "apply (simp_all add: bit_word_rotr_iff bit_of_bl_iff nth_rotater)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  word_rotl n w = of_bl (rotate n (to_bl w))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_bl_def': \"(to_bl :: 'a::len word \\<Rightarrow> bool list) = bin_to_bl (LENGTH('a)) \\<circ> uint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl = bin_to_bl LENGTH('a) \\<circ> uint", "by transfer (simp add: fun_eq_iff)\n\n\\<comment> \\<open>type definitions theorem for in terms of equivalent bool list\\<close>"], ["", "lemma td_bl:\n  \"type_definition\n    (to_bl :: 'a::len word \\<Rightarrow> bool list)\n    of_bl\n    {bl. length bl = LENGTH('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition to_bl of_bl {bl. length bl = LENGTH('a)}", "apply (standard; transfer)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. bin_to_bl LENGTH('a) x \\<in> {bl. length bl = LENGTH('a)}\n 2. \\<And>x.\n       take_bit LENGTH('a) (bl_to_bin (bin_to_bl LENGTH('a) x)) =\n       take_bit LENGTH('a) x\n 3. \\<And>y.\n       y \\<in> {bl. length bl = LENGTH('a)} \\<Longrightarrow>\n       bin_to_bl LENGTH('a) (bl_to_bin y) = y", "apply (auto dest: sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation word_bl:\n  type_definition\n    \"to_bl :: 'a::len word \\<Rightarrow> bool list\"\n    of_bl\n    \"{bl. length bl = LENGTH('a::len)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition to_bl of_bl {bl. length bl = LENGTH('a)}", "by (fact td_bl)"], ["", "lemmas word_bl_Rep' = word_bl.Rep [unfolded mem_Collect_eq, iff]"], ["", "lemma word_size_bl: \"size w = size (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size w = length (to_bl w)", "by (auto simp: word_size)"], ["", "lemma to_bl_use_of_bl: \"to_bl w = bl \\<longleftrightarrow> w = of_bl bl \\<and> length bl = length (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_bl w = bl) = (w = of_bl bl \\<and> length bl = length (to_bl w))", "by (fastforce elim!: word_bl.Abs_inverse [unfolded mem_Collect_eq])"], ["", "lemma length_bl_gt_0 [iff]: \"0 < length (to_bl x)\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (to_bl x)", "unfolding word_bl_Rep'"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < LENGTH('a)", "by (rule len_gt_0)"], ["", "lemma bl_not_Nil [iff]: \"to_bl x \\<noteq> []\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl x \\<noteq> []", "by (fact length_bl_gt_0 [unfolded length_greater_0_conv])"], ["", "lemma length_bl_neq_0 [iff]: \"length (to_bl x) \\<noteq> 0\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (to_bl x) \\<noteq> 0", "by (fact length_bl_gt_0 [THEN gr_implies_not0])"], ["", "lemma hd_bl_sign_sint: \"hd (to_bl w) = (bin_sign (sint w) = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (to_bl w) = (bin_sign (sint w) = - 1)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       hd (bin_to_bl LENGTH('a) w) =\n       (bin_sign (signed_take_bit (LENGTH('a) - Suc 0) w) = - 1)", "apply (auto simp add: bin_sign_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>\\<not> bit w (LENGTH('a) - Suc 0);\n        hd (bin_to_bl LENGTH('a) w)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>w.\n       bit w (LENGTH('a) - Suc 0) \\<Longrightarrow>\n       hd (bin_to_bl LENGTH('a) w)", "using bin_sign_lem bl_sbin_sign"], ["proof (prove)\nusing this:\n  (bin_sign (signed_take_bit ?n ?bin) = - 1) = bit ?bin ?n\n  hd (bin_to_bl (Suc ?n) ?w) = (bin_sign (signed_take_bit ?n ?w) = - 1)\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>\\<not> bit w (LENGTH('a) - Suc 0);\n        hd (bin_to_bl LENGTH('a) w)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>w.\n       bit w (LENGTH('a) - Suc 0) \\<Longrightarrow>\n       hd (bin_to_bl LENGTH('a) w)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       bit w (LENGTH('a) - Suc 0) \\<Longrightarrow>\n       hd (bin_to_bl LENGTH('a) w)", "using bin_sign_lem bl_sbin_sign"], ["proof (prove)\nusing this:\n  (bin_sign (signed_take_bit ?n ?bin) = - 1) = bit ?bin ?n\n  hd (bin_to_bl (Suc ?n) ?w) = (bin_sign (signed_take_bit ?n ?w) = - 1)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       bit w (LENGTH('a) - Suc 0) \\<Longrightarrow>\n       hd (bin_to_bl LENGTH('a) w)", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_bl_drop':\n  \"lend = length bl - LENGTH('a::len) \\<Longrightarrow>\n    of_bl (drop lend bl) = (of_bl bl :: 'a word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lend = length bl - LENGTH('a) \\<Longrightarrow>\n    of_bl (drop lend bl) = of_bl bl", "by transfer (simp flip: trunc_bl2bin)"], ["", "lemma test_bit_of_bl:\n  \"(of_bl bl::'a::len word) !! n = (rev bl ! n \\<and> n < LENGTH('a) \\<and> n < length bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl bl !! n = (rev bl ! n \\<and> n < LENGTH('a) \\<and> n < length bl)", "by transfer (simp add: bin_nth_of_bl ac_simps)"], ["", "lemma no_of_bl: \"(numeral bin ::'a::len word) = of_bl (bin_to_bl (LENGTH('a)) (numeral bin))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral bin = of_bl (bin_to_bl LENGTH('a) (numeral bin))", "by transfer simp"], ["", "lemma uint_bl: \"to_bl w = bin_to_bl (size w) (uint w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = bin_to_bl (size w) (uint w)", "by transfer simp"], ["", "lemma to_bl_bin: \"bl_to_bin (to_bl w) = uint w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (to_bl w) = uint w", "by (simp add: uint_bl word_size)"], ["", "lemma to_bl_of_bin: \"to_bl (word_of_int bin::'a::len word) = bin_to_bl (LENGTH('a)) bin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (word_of_int bin) = bin_to_bl LENGTH('a) bin", "by (auto simp: uint_bl word_ubin.eq_norm word_size)"], ["", "lemma to_bl_numeral [simp]:\n  \"to_bl (numeral bin::'a::len word) =\n    bin_to_bl (LENGTH('a)) (numeral bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (numeral bin) = bin_to_bl LENGTH('a) (numeral bin)", "unfolding word_numeral_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (word_of_int (numeral bin)) = bin_to_bl LENGTH('a) (numeral bin)", "by (rule to_bl_of_bin)"], ["", "lemma to_bl_neg_numeral [simp]:\n  \"to_bl (- numeral bin::'a::len word) =\n    bin_to_bl (LENGTH('a)) (- numeral bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (- numeral bin) = bin_to_bl LENGTH('a) (- numeral bin)", "unfolding word_neg_numeral_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (word_of_int (- numeral bin)) =\n    bin_to_bl LENGTH('a) (- numeral bin)", "by (rule to_bl_of_bin)"], ["", "lemma to_bl_to_bin [simp] : \"bl_to_bin (to_bl w) = uint w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (to_bl w) = uint w", "by (simp add: uint_bl word_size)"], ["", "lemma uint_bl_bin: \"bl_to_bin (bin_to_bl (LENGTH('a)) (uint x)) = uint x\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin (bin_to_bl LENGTH('a) (uint x)) = uint x", "by (rule trans [OF bin_bl_bin word_ubin.norm_Rep])"], ["", "lemma ucast_bl: \"ucast w = of_bl (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ucast w = of_bl (to_bl w)", "by transfer simp"], ["", "lemma ucast_down_bl:\n  \\<open>(ucast :: 'a::len word \\<Rightarrow> 'b::len word) (of_bl bl) = of_bl bl\\<close>\n    if \\<open>is_down (ucast :: 'a::len word \\<Rightarrow> 'b::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ucast (of_bl bl) = of_bl bl", "using that"], ["proof (prove)\nusing this:\n  is_down ucast\n\ngoal (1 subgoal):\n 1. ucast (of_bl bl) = of_bl bl", "by transfer simp"], ["", "lemma of_bl_append_same: \"of_bl (X @ to_bl w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (X @ to_bl w) = w", "by transfer (simp add: bl_to_bin_app_cat)"], ["", "lemma ucast_of_bl_up:\n  \\<open>ucast (of_bl bl :: 'a::len word) = of_bl bl\\<close>\n  if \\<open>size bl \\<le> size (of_bl bl :: 'a::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ucast (of_bl bl) = of_bl bl", "using that"], ["proof (prove)\nusing this:\n  length bl \\<le> size (of_bl bl)\n\ngoal (1 subgoal):\n 1. ucast (of_bl bl) = of_bl bl", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       length bl \\<le> LENGTH('a) \\<Longrightarrow>\n       take_bit LENGTH('b) (take_bit LENGTH('a) (bl_to_bin bl)) =\n       take_bit LENGTH('b) (bl_to_bin bl)", "apply (rule bit_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl n.\n       \\<lbrakk>length bl \\<le> LENGTH('a); 2 ^ n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit LENGTH('b)\n                               (take_bit LENGTH('a) (bl_to_bin bl)))\n                          n =\n                         bit (take_bit LENGTH('b) (bl_to_bin bl)) n", "apply (auto simp add: bit_take_bit_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl n.\n       \\<lbrakk>length bl \\<le> LENGTH('a); n < LENGTH('b);\n        bit (bl_to_bin bl) n\\<rbrakk>\n       \\<Longrightarrow> n < LENGTH('a)", "apply (subst (asm) trunc_bl2bin_len [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl n.\n       \\<lbrakk>length bl \\<le> LENGTH('a); n < LENGTH('b);\n        bit (take_bit (length bl) (bl_to_bin bl)) n\\<rbrakk>\n       \\<Longrightarrow> n < LENGTH('a)", "apply (auto simp only: bit_take_bit_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_rev_tf:\n  \"to_bl (of_bl bl::'a::len word) =\n    rev (takefill False (LENGTH('a)) (rev bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (of_bl bl) = rev (takefill False LENGTH('a) (rev bl))", "by transfer (simp add: bl_bin_bl_rtf)"], ["", "lemma word_rep_drop:\n  \"to_bl (of_bl bl::'a::len word) =\n    replicate (LENGTH('a) - length bl) False @\n    drop (length bl - LENGTH('a)) bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (of_bl bl) =\n    replicate (LENGTH('a) - length bl) False @\n    drop (length bl - LENGTH('a)) bl", "by (simp add: word_rev_tf takefill_alt rev_take)"], ["", "lemma to_bl_ucast:\n  \"to_bl (ucast (w::'b::len word) ::'a::len word) =\n    replicate (LENGTH('a) - LENGTH('b)) False @\n    drop (LENGTH('b) - LENGTH('a)) (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (ucast w) =\n    replicate (LENGTH('a) - LENGTH('b)) False @\n    drop (LENGTH('b) - LENGTH('a)) (to_bl w)", "apply (unfold ucast_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (of_bl (to_bl w)) =\n    replicate (LENGTH('a) - LENGTH('b)) False @\n    drop (LENGTH('b) - LENGTH('a)) (to_bl w)", "apply (rule trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. to_bl (of_bl (to_bl w)) = ?s\n 2. ?s =\n    replicate (LENGTH('a) - LENGTH('b)) False @\n    drop (LENGTH('b) - LENGTH('a)) (to_bl w)", "apply (rule word_rep_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (LENGTH('a) - length (to_bl w)) False @\n    drop (length (to_bl w) - LENGTH('a)) (to_bl w) =\n    replicate (LENGTH('a) - LENGTH('b)) False @\n    drop (LENGTH('b) - LENGTH('a)) (to_bl w)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_up_app:\n  \\<open>to_bl (ucast w :: 'b::len word) = replicate n False @ (to_bl w)\\<close>\n    if \\<open>source_size (ucast :: 'a word \\<Rightarrow> 'b word) + n = target_size (ucast :: 'a word \\<Rightarrow> 'b word)\\<close>\n    for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (ucast w) = replicate n False @ to_bl w", "using that"], ["proof (prove)\nusing this:\n  source_size ucast + n = target_size ucast\n\ngoal (1 subgoal):\n 1. to_bl (ucast w) = replicate n False @ to_bl w", "by (auto simp add : source_size target_size to_bl_ucast)"], ["", "lemma ucast_down_drop [OF refl]:\n  \"uc = ucast \\<Longrightarrow> source_size uc = target_size uc + n \\<Longrightarrow>\n    to_bl (uc w) = drop n (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uc = ucast; source_size uc = target_size uc + n\\<rbrakk>\n    \\<Longrightarrow> to_bl (uc w) = drop n (to_bl w)", "by (auto simp add : source_size target_size to_bl_ucast)"], ["", "lemma scast_down_drop [OF refl]:\n  \"sc = scast \\<Longrightarrow> source_size sc = target_size sc + n \\<Longrightarrow>\n    to_bl (sc w) = drop n (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sc = scast; source_size sc = target_size sc + n\\<rbrakk>\n    \\<Longrightarrow> to_bl (sc w) = drop n (to_bl w)", "apply (subgoal_tac \"sc = ucast\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sc = scast; source_size sc = target_size sc + n;\n     sc = ucast\\<rbrakk>\n    \\<Longrightarrow> to_bl (sc w) = drop n (to_bl w)\n 2. \\<lbrakk>sc = scast; source_size sc = target_size sc + n\\<rbrakk>\n    \\<Longrightarrow> sc = ucast", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>source_size scast = target_size scast + n; scast = ucast;\n     sc = scast\\<rbrakk>\n    \\<Longrightarrow> to_bl (scast w) = drop n (to_bl w)\n 2. \\<lbrakk>source_size scast = target_size scast + n; sc = scast\\<rbrakk>\n    \\<Longrightarrow> scast = ucast", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>source_size ucast = target_size ucast + n; scast = ucast;\n     sc = ucast\\<rbrakk>\n    \\<Longrightarrow> to_bl (ucast w) = drop n (to_bl w)\n 2. \\<lbrakk>source_size scast = target_size scast + n; sc = scast\\<rbrakk>\n    \\<Longrightarrow> scast = ucast", "apply (erule ucast_down_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>source_size scast = target_size scast + n; sc = scast\\<rbrakk>\n    \\<Longrightarrow> scast = ucast", "apply (rule down_cast_same [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>source_size scast = target_size scast + n; sc = scast\\<rbrakk>\n    \\<Longrightarrow> is_down ucast", "apply (simp add : source_size target_size is_down)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_0_bl [simp]: \"of_bl [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl [] = 0", "by transfer simp"], ["", "lemma word_1_bl: \"of_bl [True] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl [True] = 1", "by transfer (simp add: bl_to_bin_def)"], ["", "lemma of_bl_0 [simp]: \"of_bl (replicate n False) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (replicate n False) = 0", "by transfer (simp add: bl_to_bin_rep_False)"], ["", "lemma to_bl_0 [simp]: \"to_bl (0::'a::len word) = replicate (LENGTH('a)) False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl 0 = replicate LENGTH('a) False", "by (simp add: uint_bl word_size bin_to_bl_zero)\n\n\\<comment> \\<open>links with \\<open>rbl\\<close> operations\\<close>"], ["", "lemma word_succ_rbl: \"to_bl w = bl \\<Longrightarrow> to_bl (word_succ w) = rev (rbl_succ (rev bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = bl \\<Longrightarrow>\n    to_bl (word_succ w) = rev (rbl_succ (rev bl))", "by transfer (simp add: rbl_succ)"], ["", "lemma word_pred_rbl: \"to_bl w = bl \\<Longrightarrow> to_bl (word_pred w) = rev (rbl_pred (rev bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = bl \\<Longrightarrow>\n    to_bl (word_pred w) = rev (rbl_pred (rev bl))", "by transfer (simp add: rbl_pred)"], ["", "lemma word_add_rbl:\n  \"to_bl v = vbl \\<Longrightarrow> to_bl w = wbl \\<Longrightarrow>\n    to_bl (v + w) = rev (rbl_add (rev vbl) (rev wbl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>to_bl v = vbl; to_bl w = wbl\\<rbrakk>\n    \\<Longrightarrow> to_bl (v + w) = rev (rbl_add (rev vbl) (rev wbl))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vbl w wbl.\n       \\<lbrakk>bin_to_bl LENGTH('a) v = vbl;\n        bin_to_bl LENGTH('a) w = wbl\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a) (v + w) =\n                         rev (rbl_add (rev vbl) (rev wbl))", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vbl w wbl.\n       \\<lbrakk>bin_to_bl LENGTH('a) w = wbl;\n        vbl = bin_to_bl LENGTH('a) v\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a) (v + w) =\n                         rev (rbl_add (rev vbl) (rev wbl))", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vbl w wbl.\n       \\<lbrakk>vbl = bin_to_bl LENGTH('a) v;\n        wbl = bin_to_bl LENGTH('a) w\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a) (v + w) =\n                         rev (rbl_add (rev vbl) (rev wbl))", "apply (simp add: rbl_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_mult_rbl:\n  \"to_bl v = vbl \\<Longrightarrow> to_bl w = wbl \\<Longrightarrow>\n    to_bl (v * w) = rev (rbl_mult (rev vbl) (rev wbl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>to_bl v = vbl; to_bl w = wbl\\<rbrakk>\n    \\<Longrightarrow> to_bl (v * w) = rev (rbl_mult (rev vbl) (rev wbl))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vbl w wbl.\n       \\<lbrakk>bin_to_bl LENGTH('a) v = vbl;\n        bin_to_bl LENGTH('a) w = wbl\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a) (v * w) =\n                         rev (rbl_mult (rev vbl) (rev wbl))", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vbl w wbl.\n       \\<lbrakk>bin_to_bl LENGTH('a) w = wbl;\n        vbl = bin_to_bl LENGTH('a) v\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a) (v * w) =\n                         rev (rbl_mult (rev vbl) (rev wbl))", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vbl w wbl.\n       \\<lbrakk>vbl = bin_to_bl LENGTH('a) v;\n        wbl = bin_to_bl LENGTH('a) w\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a) (v * w) =\n                         rev (rbl_mult (rev vbl) (rev wbl))", "apply (simp add: rbl_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rtb_rbl_ariths:\n  \"rev (to_bl w) = ys \\<Longrightarrow> rev (to_bl (word_succ w)) = rbl_succ ys\"\n  \"rev (to_bl w) = ys \\<Longrightarrow> rev (to_bl (word_pred w)) = rbl_pred ys\"\n  \"rev (to_bl v) = ys \\<Longrightarrow> rev (to_bl w) = xs \\<Longrightarrow> rev (to_bl (v * w)) = rbl_mult ys xs\"\n  \"rev (to_bl v) = ys \\<Longrightarrow> rev (to_bl w) = xs \\<Longrightarrow> rev (to_bl (v + w)) = rbl_add ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rev (to_bl w) = ys \\<Longrightarrow>\n      rev (to_bl (word_succ w)) = rbl_succ ys) &&&\n     (rev (to_bl w) = ys \\<Longrightarrow>\n      rev (to_bl (word_pred w)) = rbl_pred ys)) &&&\n    (\\<lbrakk>rev (to_bl v) = ys; rev (to_bl w) = xs\\<rbrakk>\n     \\<Longrightarrow> rev (to_bl (v * w)) = rbl_mult ys xs) &&&\n    (\\<lbrakk>rev (to_bl v) = ys; rev (to_bl w) = xs\\<rbrakk>\n     \\<Longrightarrow> rev (to_bl (v + w)) = rbl_add ys xs)", "by (auto simp: rev_swap [symmetric] word_succ_rbl word_pred_rbl word_mult_rbl word_add_rbl)"], ["", "lemma of_bl_length_less:\n  \\<open>(of_bl x :: 'a::len word) < 2 ^ k\\<close>\n    if \\<open>length x = k\\<close> \\<open>k < LENGTH('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl x < 2 ^ k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_bl x < 2 ^ k", "from that"], ["proof (chain)\npicking this:\n  length x = k\n  k < LENGTH('a)", "have \\<open>length x < LENGTH('a)\\<close>"], ["proof (prove)\nusing this:\n  length x = k\n  k < LENGTH('a)\n\ngoal (1 subgoal):\n 1. length x < LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  length x < LENGTH('a)\n\ngoal (1 subgoal):\n 1. of_bl x < 2 ^ k", "then"], ["proof (chain)\npicking this:\n  length x < LENGTH('a)", "have \\<open>(of_bl x :: 'a::len word) < 2 ^ length x\\<close>"], ["proof (prove)\nusing this:\n  length x < LENGTH('a)\n\ngoal (1 subgoal):\n 1. of_bl x < 2 ^ length x", "apply (simp add: of_bl_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length x < LENGTH('a) \\<Longrightarrow>\n    horner_sum of_bool 2 (rev x) < 2 ^ length x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       length x < LENGTH('a) \\<Longrightarrow>\n       take_bit LENGTH('a) (horner_sum of_bool 2 (rev x))\n       < take_bit LENGTH('a) (2 ^ length x)", "apply (simp add: take_bit_horner_sum_bit_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       length x < LENGTH('a) \\<Longrightarrow>\n       horner_sum of_bool 2 (rev x) < 2 ^ length x", "apply (subst length_rev [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       length x < LENGTH('a) \\<Longrightarrow>\n       horner_sum of_bool 2 (rev x) < 2 ^ length (rev x)", "apply (simp only: horner_sum_of_bool_2_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  of_bl x < 2 ^ length x\n\ngoal (1 subgoal):\n 1. of_bl x < 2 ^ k", "with that"], ["proof (chain)\npicking this:\n  length x = k\n  k < LENGTH('a)\n  of_bl x < 2 ^ length x", "show ?thesis"], ["proof (prove)\nusing this:\n  length x = k\n  k < LENGTH('a)\n  of_bl x < 2 ^ length x\n\ngoal (1 subgoal):\n 1. of_bl x < 2 ^ k", "by simp"], ["proof (state)\nthis:\n  of_bl x < 2 ^ k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_eq_rbl_eq: \"x = y \\<longleftrightarrow> rev (to_bl x) = rev (to_bl y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (rev (to_bl x) = rev (to_bl y))", "by simp"], ["", "lemma bl_word_not: \"to_bl (NOT w) = map Not (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (NOT w) = map Not (to_bl w)", "by transfer (simp add: bl_not_bin)"], ["", "lemma bl_word_xor: \"to_bl (v XOR w) = map2 (\\<noteq>) (to_bl v) (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (v XOR w) = map2 (\\<noteq>) (to_bl v) (to_bl w)", "by transfer (simp flip: bl_xor_bin)"], ["", "lemma bl_word_or: \"to_bl (v OR w) = map2 (\\<or>) (to_bl v) (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (v OR w) = map2 (\\<or>) (to_bl v) (to_bl w)", "by transfer (simp flip: bl_or_bin)"], ["", "lemma bl_word_and: \"to_bl (v AND w) = map2 (\\<and>) (to_bl v) (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (v AND w) = map2 (\\<and>) (to_bl v) (to_bl w)", "by transfer (simp flip: bl_and_bin)"], ["", "lemma bin_nth_uint': \"bin_nth (uint w) n \\<longleftrightarrow> rev (bin_to_bl (size w) (uint w)) ! n \\<and> n < size w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (uint w) n =\n    (rev (bin_to_bl (size w) (uint w)) ! n \\<and> n < size w)", "apply (unfold word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (uint w) n =\n    (rev (bin_to_bl LENGTH('a) (uint w)) ! n \\<and> n < LENGTH('a))", "apply (safe elim!: bin_nth_uint_imp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bit (uint w) n \\<Longrightarrow> rev (bin_to_bl LENGTH('a) (uint w)) ! n\n 2. \\<lbrakk>rev (bin_to_bl LENGTH('a) (uint w)) ! n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bit (uint w) n", "apply (frule bin_nth_uint_imp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bit (uint w) n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> rev (bin_to_bl LENGTH('a) (uint w)) ! n\n 2. \\<lbrakk>rev (bin_to_bl LENGTH('a) (uint w)) ! n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bit (uint w) n", "apply (fast dest!: bin_nth_bl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas bin_nth_uint = bin_nth_uint' [unfolded word_size]"], ["", "lemma test_bit_bl: \"w !! n \\<longleftrightarrow> rev (to_bl w) ! n \\<and> n < size w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w !! n = (rev (to_bl w) ! n \\<and> n < size w)", "by transfer (auto simp add: bin_nth_bl)"], ["", "lemma to_bl_nth: \"n < size w \\<Longrightarrow> to_bl w ! n = w !! (size w - Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < size w \\<Longrightarrow> to_bl w ! n = w !! (size w - Suc n)", "by (simp add: word_size rev_nth test_bit_bl)"], ["", "lemma map_bit_interval_eq:\n  \\<open>map (bit w) [0..<n] = takefill False n (rev (to_bl w))\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (bit w) [0..<n] = takefill False n (rev (to_bl w))", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (bit w) [0..<n]) = length (takefill False n (rev (to_bl w)))\n 2. \\<And>i.\n       i < length (map (bit w) [0..<n]) \\<Longrightarrow>\n       map (bit w) [0..<n] ! i = takefill False n (rev (to_bl w)) ! i", "show \\<open>length (map (bit w) [0..<n]) =\n    length (takefill False n (rev (to_bl w)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (bit w) [0..<n]) = length (takefill False n (rev (to_bl w)))", "by simp"], ["proof (state)\nthis:\n  length (map (bit w) [0..<n]) = length (takefill False n (rev (to_bl w)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (bit w) [0..<n]) \\<Longrightarrow>\n       map (bit w) [0..<n] ! i = takefill False n (rev (to_bl w)) ! i", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (bit w) [0..<n]) \\<Longrightarrow>\n       map (bit w) [0..<n] ! i = takefill False n (rev (to_bl w)) ! i", "assume \\<open>m < length (map (bit w) [0..<n])\\<close>"], ["proof (state)\nthis:\n  m < length (map (bit w) [0..<n])\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (bit w) [0..<n]) \\<Longrightarrow>\n       map (bit w) [0..<n] ! i = takefill False n (rev (to_bl w)) ! i", "then"], ["proof (chain)\npicking this:\n  m < length (map (bit w) [0..<n])", "have \\<open>m < n\\<close>"], ["proof (prove)\nusing this:\n  m < length (map (bit w) [0..<n])\n\ngoal (1 subgoal):\n 1. m < n", "by simp"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (bit w) [0..<n]) \\<Longrightarrow>\n       map (bit w) [0..<n] ! i = takefill False n (rev (to_bl w)) ! i", "then"], ["proof (chain)\npicking this:\n  m < n", "have \\<open>bit w m \\<longleftrightarrow> takefill False n (rev (to_bl w)) ! m\\<close>"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. bit w m = takefill False n (rev (to_bl w)) ! m", "by (auto simp add: nth_takefill not_less rev_nth to_bl_nth word_size test_bit_word_eq dest: bit_imp_le_length)"], ["proof (state)\nthis:\n  bit w m = takefill False n (rev (to_bl w)) ! m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (map (bit w) [0..<n]) \\<Longrightarrow>\n       map (bit w) [0..<n] ! i = takefill False n (rev (to_bl w)) ! i", "with \\<open>m < n \\<close>"], ["proof (chain)\npicking this:\n  m < n\n  bit w m = takefill False n (rev (to_bl w)) ! m", "show \\<open>map (bit w) [0..<n] ! m \\<longleftrightarrow> takefill False n (rev (to_bl w)) ! m\\<close>"], ["proof (prove)\nusing this:\n  m < n\n  bit w m = takefill False n (rev (to_bl w)) ! m\n\ngoal (1 subgoal):\n 1. map (bit w) [0..<n] ! m = takefill False n (rev (to_bl w)) ! m", "by simp"], ["proof (state)\nthis:\n  map (bit w) [0..<n] ! m = takefill False n (rev (to_bl w)) ! m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_bl_unfold:\n  \\<open>to_bl w = rev (map (bit w) [0..<LENGTH('a)])\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = rev (map (bit w) [0..<LENGTH('a)])", "by (simp add: map_bit_interval_eq takefill_bintrunc to_bl_def flip: bin_to_bl_def)"], ["", "lemma nth_rev_to_bl:\n  \\<open>rev (to_bl w) ! n \\<longleftrightarrow> bit w n\\<close>\n  if \\<open>n < LENGTH('a)\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl w) ! n = bit w n", "using that"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. rev (to_bl w) ! n = bit w n", "by (simp add: to_bl_unfold)"], ["", "lemma nth_to_bl:\n  \\<open>to_bl w ! n \\<longleftrightarrow> bit w (LENGTH('a) - Suc n)\\<close>\n  if \\<open>n < LENGTH('a)\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w ! n = bit w (LENGTH('a) - Suc n)", "using that"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. to_bl w ! n = bit w (LENGTH('a) - Suc n)", "by (simp add: to_bl_unfold rev_nth)"], ["", "lemma of_bl_rep_False: \"of_bl (replicate n False @ bs) = of_bl bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (replicate n False @ bs) = of_bl bs", "by (auto simp: of_bl_def bl_to_bin_rep_F)"], ["", "lemma [code abstract]:\n  \\<open>Word.the_int (of_bl bs :: 'a word) = horner_sum of_bool 2 (take LENGTH('a::len) (rev bs))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Word.the_int (of_bl bs) =\n    horner_sum of_bool 2 (take LENGTH('a) (rev bs))", "apply (simp add: of_bl_eq flip: take_bit_horner_sum_bit_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (horner_sum of_bool 2 (rev bs)) =\n    take_bit LENGTH('a) (horner_sum of_bool 2 (rev bs))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       take_bit LENGTH('a) (horner_sum of_bool 2 (rev bs)) =\n       take_bit LENGTH('a) (horner_sum of_bool 2 (rev bs))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [code]:\n  \\<open>to_bl w = map (bit w) (rev [0..<LENGTH('a::len)])\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = map (bit w) (rev [0..<LENGTH('a)])", "by (fact to_bl_eq_rev)"], ["", "lemma word_reverse_eq_of_bl_rev_to_bl:\n  \\<open>word_reverse w = of_bl (rev (to_bl w))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_reverse w = of_bl (rev (to_bl w))", "by (rule bit_word_eqI)\n    (auto simp add: bit_word_reverse_iff bit_of_bl_iff nth_to_bl)"], ["", "lemmas word_reverse_no_def [simp] =\n  word_reverse_eq_of_bl_rev_to_bl [of \"numeral w\"] for w"], ["", "lemma to_bl_word_rev: \"to_bl (word_reverse w) = rev (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (word_reverse w) = rev (to_bl w)", "by (rule nth_equalityI) (simp_all add: nth_rev_to_bl word_reverse_def word_rep_drop flip: of_bl_eq)"], ["", "lemma to_bl_n1 [simp]: \"to_bl (-1::'a::len word) = replicate (LENGTH('a)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (- 1) = replicate LENGTH('a) True", "apply (rule word_bl.Abs_inverse')"], ["proof (prove)\ngoal (2 subgoals):\n 1. replicate LENGTH('a) True \\<in> {bl. length bl = LENGTH('a)}\n 2. of_bl (replicate LENGTH('a) True) = - 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (replicate LENGTH('a) True) = - 1", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < size (of_bl (replicate LENGTH('a) True)) \\<longrightarrow>\n       of_bl (replicate LENGTH('a) True) !! n = (- 1) !! n", "apply (clarsimp simp add: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       of_bl (replicate LENGTH('a) True) !! n", "apply (auto simp add: word_bl.Abs_inverse test_bit_bl word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_word_or: \"rev (to_bl (x OR y)) = map2 (\\<or>) (rev (to_bl x)) (rev (to_bl y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (x OR y)) = map2 (\\<or>) (rev (to_bl x)) (rev (to_bl y))", "by (simp add: zip_rev bl_word_or rev_map)"], ["", "lemma rbl_word_and: \"rev (to_bl (x AND y)) = map2 (\\<and>) (rev (to_bl x)) (rev (to_bl y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (x AND y)) = map2 (\\<and>) (rev (to_bl x)) (rev (to_bl y))", "by (simp add: zip_rev bl_word_and rev_map)"], ["", "lemma rbl_word_xor: \"rev (to_bl (x XOR y)) = map2 (\\<noteq>) (rev (to_bl x)) (rev (to_bl y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (x XOR y)) = map2 (\\<noteq>) (rev (to_bl x)) (rev (to_bl y))", "by (simp add: zip_rev bl_word_xor rev_map)"], ["", "lemma rbl_word_not: \"rev (to_bl (NOT x)) = map Not (rev (to_bl x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (NOT x)) = map Not (rev (to_bl x))", "by (simp add: bl_word_not rev_map)"], ["", "lemma bshiftr1_numeral [simp]:\n  \\<open>bshiftr1 b (numeral w :: 'a word) = of_bl (b # butlast (bin_to_bl LENGTH('a::len) (numeral w)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bshiftr1 b (numeral w) =\n    of_bl (b # butlast (bin_to_bl LENGTH('a) (numeral w)))", "by (simp add: bshiftr1_eq)"], ["", "lemma bshiftr1_bl: \"to_bl (bshiftr1 b w) = b # butlast (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (bshiftr1 b w) = b # butlast (to_bl w)", "unfolding bshiftr1_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (of_bl (b # butlast (to_bl w))) = b # butlast (to_bl w)", "by (rule word_bl.Abs_inverse) simp"], ["", "lemma shiftl1_of_bl: \"shiftl1 (of_bl bl) = of_bl (bl @ [False])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftl1 (of_bl bl) = of_bl (bl @ [False])", "by transfer (simp add: bl_to_bin_append)"], ["", "lemma shiftl1_bl: \"shiftl1 w = of_bl (to_bl w @ [False])\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftl1 w = of_bl (to_bl w @ [False])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. shiftl1 w = of_bl (to_bl w @ [False])", "have \"shiftl1 w = shiftl1 (of_bl (to_bl w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftl1 w = shiftl1 (of_bl (to_bl w))", "by simp"], ["proof (state)\nthis:\n  shiftl1 w = shiftl1 (of_bl (to_bl w))\n\ngoal (1 subgoal):\n 1. shiftl1 w = of_bl (to_bl w @ [False])", "also"], ["proof (state)\nthis:\n  shiftl1 w = shiftl1 (of_bl (to_bl w))\n\ngoal (1 subgoal):\n 1. shiftl1 w = of_bl (to_bl w @ [False])", "have \"\\<dots> = of_bl (to_bl w @ [False])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftl1 (of_bl (to_bl w)) = of_bl (to_bl w @ [False])", "by (rule shiftl1_of_bl)"], ["proof (state)\nthis:\n  shiftl1 (of_bl (to_bl w)) = of_bl (to_bl w @ [False])\n\ngoal (1 subgoal):\n 1. shiftl1 w = of_bl (to_bl w @ [False])", "finally"], ["proof (chain)\npicking this:\n  shiftl1 w = of_bl (to_bl w @ [False])", "show ?thesis"], ["proof (prove)\nusing this:\n  shiftl1 w = of_bl (to_bl w @ [False])\n\ngoal (1 subgoal):\n 1. shiftl1 w = of_bl (to_bl w @ [False])", "."], ["proof (state)\nthis:\n  shiftl1 w = of_bl (to_bl w @ [False])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl_shiftl1: \"to_bl (shiftl1 w) = tl (to_bl w) @ [False]\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (shiftl1 w) = tl (to_bl w) @ [False]", "by (simp add: shiftl1_bl word_rep_drop drop_Suc drop_Cons') (fast intro!: Suc_leI)\n\n\\<comment> \\<open>Generalized version of \\<open>bl_shiftl1\\<close>. Maybe this one should replace it?\\<close>"], ["", "lemma bl_shiftl1': \"to_bl (shiftl1 w) = tl (to_bl w @ [False])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (shiftl1 w) = tl (to_bl w @ [False])", "by (simp add: shiftl1_bl word_rep_drop drop_Suc del: drop_append)"], ["", "lemma shiftr1_bl:\n  \\<open>shiftr1 w = of_bl (butlast (to_bl w))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftr1 w = of_bl (butlast (to_bl w))", "proof (rule bit_word_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "assume \\<open>n < LENGTH('a)\\<close>"], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "show \\<open>bit (shiftr1 w) n \\<longleftrightarrow> bit (of_bl (butlast (to_bl w)) :: 'a word) n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "proof (cases \\<open>n = LENGTH('a) - 1\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n\n 2. n \\<noteq> LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "case True"], ["proof (state)\nthis:\n  n = LENGTH('a) - 1\n\ngoal (2 subgoals):\n 1. n = LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n\n 2. n \\<noteq> LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "then"], ["proof (chain)\npicking this:\n  n = LENGTH('a) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  n = LENGTH('a) - 1\n\ngoal (1 subgoal):\n 1. bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "by (simp add: bit_shiftr1_iff bit_of_bl_iff)"], ["proof (state)\nthis:\n  bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n\n\ngoal (1 subgoal):\n 1. n \\<noteq> LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> LENGTH('a) - 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "with \\<open>n < LENGTH('a)\\<close>"], ["proof (chain)\npicking this:\n  n < LENGTH('a)\n  n \\<noteq> LENGTH('a) - 1", "have \\<open>n < LENGTH('a) - 1\\<close>"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n  n \\<noteq> LENGTH('a) - 1\n\ngoal (1 subgoal):\n 1. n < LENGTH('a) - 1", "by simp"], ["proof (state)\nthis:\n  n < LENGTH('a) - 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> LENGTH('a) - 1 \\<Longrightarrow>\n    bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "with \\<open>n < LENGTH('a)\\<close>"], ["proof (chain)\npicking this:\n  n < LENGTH('a)\n  n < LENGTH('a) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n  n < LENGTH('a) - 1\n\ngoal (1 subgoal):\n 1. bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n", "by (simp add: bit_shiftr1_iff bit_of_bl_iff rev_nth nth_butlast\n        word_size test_bit_word_eq to_bl_nth)"], ["proof (state)\nthis:\n  bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bit (shiftr1 w) n = bit (of_bl (butlast (to_bl w))) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl_shiftr1: \"to_bl (shiftr1 w) = False # butlast (to_bl w)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (shiftr1 w) = False # butlast (to_bl w)", "by (simp add: shiftr1_bl word_rep_drop len_gt_0 [THEN Suc_leI])\n\n\\<comment> \\<open>Generalized version of \\<open>bl_shiftr1\\<close>. Maybe this one should replace it?\\<close>"], ["", "lemma bl_shiftr1': \"to_bl (shiftr1 w) = butlast (False # to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (shiftr1 w) = butlast (False # to_bl w)", "apply (rule word_bl.Abs_inverse')"], ["proof (prove)\ngoal (2 subgoals):\n 1. butlast (False # to_bl w) \\<in> {bl. length bl = LENGTH('a)}\n 2. of_bl (butlast (False # to_bl w)) = shiftr1 w", "apply (simp del: butlast.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (butlast (False # to_bl w)) = shiftr1 w", "apply (simp add: shiftr1_bl of_bl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_sshiftr1: \"to_bl (sshiftr1 w) = hd (to_bl w) # butlast (to_bl w)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (sshiftr1 w) = hd (to_bl w) # butlast (to_bl w)", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (to_bl (sshiftr1 w)) = length (hd (to_bl w) # butlast (to_bl w))\n 2. \\<And>i.\n       i < length (to_bl (sshiftr1 w)) \\<Longrightarrow>\n       to_bl (sshiftr1 w) ! i = (hd (to_bl w) # butlast (to_bl w)) ! i", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. length (to_bl (sshiftr1 w)) = length (hd (to_bl w) # butlast (to_bl w))\n 2. \\<And>i.\n       i < length (to_bl (sshiftr1 w)) \\<Longrightarrow>\n       to_bl (sshiftr1 w) ! i = (hd (to_bl w) # butlast (to_bl w)) ! i", "assume \\<open>n < length (to_bl (sshiftr1 w))\\<close>"], ["proof (state)\nthis:\n  n < length (to_bl (sshiftr1 w))\n\ngoal (2 subgoals):\n 1. length (to_bl (sshiftr1 w)) = length (hd (to_bl w) # butlast (to_bl w))\n 2. \\<And>i.\n       i < length (to_bl (sshiftr1 w)) \\<Longrightarrow>\n       to_bl (sshiftr1 w) ! i = (hd (to_bl w) # butlast (to_bl w)) ! i", "then"], ["proof (chain)\npicking this:\n  n < length (to_bl (sshiftr1 w))", "have \\<open>n < LENGTH('a)\\<close>"], ["proof (prove)\nusing this:\n  n < length (to_bl (sshiftr1 w))\n\ngoal (1 subgoal):\n 1. n < LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (2 subgoals):\n 1. length (to_bl (sshiftr1 w)) = length (hd (to_bl w) # butlast (to_bl w))\n 2. \\<And>i.\n       i < length (to_bl (sshiftr1 w)) \\<Longrightarrow>\n       to_bl (sshiftr1 w) ! i = (hd (to_bl w) # butlast (to_bl w)) ! i", "then"], ["proof (chain)\npicking this:\n  n < LENGTH('a)", "show \\<open>to_bl (sshiftr1 w) ! n \\<longleftrightarrow> (hd (to_bl w) # butlast (to_bl w)) ! n\\<close>"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. to_bl (sshiftr1 w) ! n = (hd (to_bl w) # butlast (to_bl w)) ! n", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); n = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (sshiftr1 w) ! n =\n                      (hd (to_bl w) # butlast (to_bl w)) ! n\n 2. \\<And>nat.\n       \\<lbrakk>n < LENGTH('a); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> to_bl (sshiftr1 w) ! n =\n                         (hd (to_bl w) # butlast (to_bl w)) ! n", "apply (simp_all add: to_bl_nth word_size hd_conv_nth test_bit_eq_bit bit_sshiftr1_iff nth_butlast Suc_diff_Suc nth_to_bl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  to_bl (sshiftr1 w) ! n = (hd (to_bl w) # butlast (to_bl w)) ! n\n\ngoal (1 subgoal):\n 1. length (to_bl (sshiftr1 w)) = length (hd (to_bl w) # butlast (to_bl w))", "qed simp"], ["", "lemma drop_shiftr: \"drop n (to_bl (w >> n)) = take (size w - n) (to_bl w)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n (to_bl (w >> n)) = take (size w - n) (to_bl w)", "apply (unfold shiftr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n (to_bl ((shiftr1 ^^ n) w)) = take (size w - n) (to_bl w)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. drop 0 (to_bl ((shiftr1 ^^ 0) w)) = take (size w - 0) (to_bl w)\n 2. \\<And>n.\n       drop n (to_bl ((shiftr1 ^^ n) w)) =\n       take (size w - n) (to_bl w) \\<Longrightarrow>\n       drop (Suc n) (to_bl ((shiftr1 ^^ Suc n) w)) =\n       take (size w - Suc n) (to_bl w)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       drop n (to_bl ((shiftr1 ^^ n) w)) =\n       take (size w - n) (to_bl w) \\<Longrightarrow>\n       drop (Suc n) (to_bl ((shiftr1 ^^ Suc n) w)) =\n       take (size w - Suc n) (to_bl w)\n 2. drop 0 (to_bl ((shiftr1 ^^ 0) w)) = take (size w - 0) (to_bl w)", "apply (simp add: drop_Suc bl_shiftr1 butlast_drop [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       drop n (to_bl ((shiftr1 ^^ n) w)) =\n       take (size w - n) (to_bl w) \\<Longrightarrow>\n       butlast (take (size w - n) (to_bl w)) =\n       take (size w - Suc n) (to_bl w)\n 2. drop 0 (to_bl ((shiftr1 ^^ 0) w)) = take (size w - 0) (to_bl w)", "apply (rule butlast_take [THEN trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       drop n (to_bl ((shiftr1 ^^ n) w)) =\n       take (size w - n) (to_bl w) \\<Longrightarrow>\n       size w - n \\<le> length (to_bl w)\n 2. \\<And>n.\n       drop n (to_bl ((shiftr1 ^^ n) w)) =\n       take (size w - n) (to_bl w) \\<Longrightarrow>\n       take (size w - n - 1) (to_bl w) = take (size w - Suc n) (to_bl w)\n 3. drop 0 (to_bl ((shiftr1 ^^ 0) w)) = take (size w - 0) (to_bl w)", "apply (auto simp: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma drop_sshiftr: \"drop n (to_bl (w >>> n)) = take (size w - n) (to_bl w)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n (to_bl (w >>> n)) = take (size w - n) (to_bl w)", "apply (simp_all add: word_size sshiftr_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n (to_bl (signed_drop_bit n w)) = take (LENGTH('a) - n) (to_bl w)", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (drop n (to_bl (signed_drop_bit n w))) =\n    length (take (LENGTH('a) - n) (to_bl w))\n 2. \\<And>i.\n       i < length (drop n (to_bl (signed_drop_bit n w))) \\<Longrightarrow>\n       drop n (to_bl (signed_drop_bit n w)) ! i =\n       take (LENGTH('a) - n) (to_bl w) ! i", "apply (simp_all add: word_size nth_to_bl bit_signed_drop_bit_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_shiftr: \"n \\<le> size w \\<Longrightarrow> take n (to_bl (w >> n)) = replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> size w \\<Longrightarrow>\n    take n (to_bl (w >> n)) = replicate n False", "apply (unfold shiftr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> size w \\<Longrightarrow>\n    take n (to_bl ((shiftr1 ^^ n) w)) = replicate n False", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> size w \\<Longrightarrow>\n    take 0 (to_bl ((shiftr1 ^^ 0) w)) = replicate 0 False\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> size w \\<Longrightarrow>\n                take n (to_bl ((shiftr1 ^^ n) w)) = replicate n False;\n        Suc n \\<le> size w\\<rbrakk>\n       \\<Longrightarrow> take (Suc n) (to_bl ((shiftr1 ^^ Suc n) w)) =\n                         replicate (Suc n) False", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> size w \\<Longrightarrow>\n                take n (to_bl ((shiftr1 ^^ n) w)) = replicate n False;\n        Suc n \\<le> size w\\<rbrakk>\n       \\<Longrightarrow> take (Suc n) (to_bl ((shiftr1 ^^ Suc n) w)) =\n                         replicate (Suc n) False\n 2. 0 \\<le> size w \\<Longrightarrow>\n    take 0 (to_bl ((shiftr1 ^^ 0) w)) = replicate 0 False", "apply (simp add: bl_shiftr1' length_0_conv [symmetric] word_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>take n (to_bl ((shiftr1 ^^ n) w)) = replicate n False;\n        Suc n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take n (butlast (to_bl ((shiftr1 ^^ n) w))) =\n                         replicate n False\n 2. 0 \\<le> size w \\<Longrightarrow>\n    take 0 (to_bl ((shiftr1 ^^ 0) w)) = replicate 0 False", "apply (rule take_butlast [THEN trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>take n (to_bl ((shiftr1 ^^ n) w)) = replicate n False;\n        Suc n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> n < length (to_bl ((shiftr1 ^^ n) w))\n 2. \\<And>n.\n       \\<lbrakk>take n (to_bl ((shiftr1 ^^ n) w)) = replicate n False;\n        Suc n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take n (to_bl ((shiftr1 ^^ n) w)) =\n                         replicate n False\n 3. 0 \\<le> size w \\<Longrightarrow>\n    take 0 (to_bl ((shiftr1 ^^ 0) w)) = replicate 0 False", "apply (auto simp: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_sshiftr':\n  \"n \\<le> size w \\<Longrightarrow> hd (to_bl (w >>> n)) = hd (to_bl w) \\<and>\n    take n (to_bl (w >>> n)) = replicate n (hd (to_bl w))\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> size w \\<Longrightarrow>\n    hd (to_bl (w >>> n)) = hd (to_bl w) \\<and>\n    take n (to_bl (w >>> n)) = replicate n (hd (to_bl w))", "apply (auto simp add: sshiftr_eq hd_bl_sign_sint bin_sign_def not_le word_size sint_signed_drop_bit_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> LENGTH('a); 0 \\<le> sint w\\<rbrakk>\n    \\<Longrightarrow> take n (to_bl (signed_drop_bit n w)) =\n                      replicate n False\n 2. \\<lbrakk>n \\<le> LENGTH('a); sint w < 0\\<rbrakk>\n    \\<Longrightarrow> take n (to_bl (signed_drop_bit n w)) =\n                      replicate n True", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<le> LENGTH('a); 0 \\<le> sint w\\<rbrakk>\n    \\<Longrightarrow> length (take n (to_bl (signed_drop_bit n w))) =\n                      length (replicate n False)\n 2. \\<And>i.\n       \\<lbrakk>n \\<le> LENGTH('a); 0 \\<le> sint w;\n        i < length (take n (to_bl (signed_drop_bit n w)))\\<rbrakk>\n       \\<Longrightarrow> take n (to_bl (signed_drop_bit n w)) ! i =\n                         replicate n False ! i\n 3. \\<lbrakk>n \\<le> LENGTH('a); sint w < 0\\<rbrakk>\n    \\<Longrightarrow> take n (to_bl (signed_drop_bit n w)) =\n                      replicate n True", "apply (auto simp add: nth_to_bl bit_signed_drop_bit_iff bit_last_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> LENGTH('a); sint w < 0\\<rbrakk>\n    \\<Longrightarrow> take n (to_bl (signed_drop_bit n w)) =\n                      replicate n True", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> LENGTH('a); sint w < 0\\<rbrakk>\n    \\<Longrightarrow> length (take n (to_bl (signed_drop_bit n w))) =\n                      length (replicate n True)\n 2. \\<And>i.\n       \\<lbrakk>n \\<le> LENGTH('a); sint w < 0;\n        i < length (take n (to_bl (signed_drop_bit n w)))\\<rbrakk>\n       \\<Longrightarrow> take n (to_bl (signed_drop_bit n w)) ! i =\n                         replicate n True ! i", "apply (auto simp add: nth_to_bl bit_signed_drop_bit_iff bit_last_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas hd_sshiftr = take_sshiftr' [THEN conjunct1]"], ["", "lemmas take_sshiftr = take_sshiftr' [THEN conjunct2]"], ["", "lemma atd_lem: \"take n xs = t \\<Longrightarrow> drop n xs = d \\<Longrightarrow> xs = t @ d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take n xs = t; drop n xs = d\\<rbrakk>\n    \\<Longrightarrow> xs = t @ d", "by (auto intro: append_take_drop_id [symmetric])"], ["", "lemmas bl_shiftr = atd_lem [OF take_shiftr drop_shiftr]"], ["", "lemmas bl_sshiftr = atd_lem [OF take_sshiftr drop_sshiftr]"], ["", "lemma shiftl_of_bl: \"of_bl bl << n = of_bl (bl @ replicate n False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl bl << n = of_bl (bl @ replicate n False)", "by (induct n) (auto simp: shiftl_def shiftl1_of_bl replicate_app_Cons_same)"], ["", "lemma shiftl_bl: \"w << n = of_bl (to_bl w @ replicate n False)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w << n = of_bl (to_bl w @ replicate n False)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w << n = of_bl (to_bl w @ replicate n False)", "have \"w << n = of_bl (to_bl w) << n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w << n = of_bl (to_bl w) << n", "by simp"], ["proof (state)\nthis:\n  w << n = of_bl (to_bl w) << n\n\ngoal (1 subgoal):\n 1. w << n = of_bl (to_bl w @ replicate n False)", "also"], ["proof (state)\nthis:\n  w << n = of_bl (to_bl w) << n\n\ngoal (1 subgoal):\n 1. w << n = of_bl (to_bl w @ replicate n False)", "have \"\\<dots> = of_bl (to_bl w @ replicate n False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (to_bl w) << n = of_bl (to_bl w @ replicate n False)", "by (rule shiftl_of_bl)"], ["proof (state)\nthis:\n  of_bl (to_bl w) << n = of_bl (to_bl w @ replicate n False)\n\ngoal (1 subgoal):\n 1. w << n = of_bl (to_bl w @ replicate n False)", "finally"], ["proof (chain)\npicking this:\n  w << n = of_bl (to_bl w @ replicate n False)", "show ?thesis"], ["proof (prove)\nusing this:\n  w << n = of_bl (to_bl w @ replicate n False)\n\ngoal (1 subgoal):\n 1. w << n = of_bl (to_bl w @ replicate n False)", "."], ["proof (state)\nthis:\n  w << n = of_bl (to_bl w @ replicate n False)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl_shiftl: \"to_bl (w << n) = drop n (to_bl w) @ replicate (min (size w) n) False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (w << n) = drop n (to_bl w) @ replicate (min (size w) n) False", "by (simp add: shiftl_bl word_rep_drop word_size)"], ["", "lemma shiftr1_bl_of:\n  \"length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    shiftr1 (of_bl bl::'a::len word) = of_bl (butlast bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    shiftr1 (of_bl bl) = of_bl (butlast bl)", "by transfer (simp add: butlast_rest_bl2bin trunc_bl2bin)"], ["", "lemma shiftr_bl_of:\n  \"length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    (of_bl bl::'a::len word) >> n = of_bl (take (length bl - n) bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    of_bl bl >> n = of_bl (take (length bl - n) bl)", "apply (unfold shiftr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    (shiftr1 ^^ n) (of_bl bl) = of_bl (take (length bl - n) bl)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length bl \\<le> LENGTH('a) \\<Longrightarrow>\n    (shiftr1 ^^ 0) (of_bl bl) = of_bl (take (length bl - 0) bl)\n 2. \\<And>n.\n       \\<lbrakk>length bl \\<le> LENGTH('a) \\<Longrightarrow>\n                (shiftr1 ^^ n) (of_bl bl) = of_bl (take (length bl - n) bl);\n        length bl \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> (shiftr1 ^^ Suc n) (of_bl bl) =\n                         of_bl (take (length bl - Suc n) bl)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>length bl \\<le> LENGTH('a) \\<Longrightarrow>\n                (shiftr1 ^^ n) (of_bl bl) = of_bl (take (length bl - n) bl);\n        length bl \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> (shiftr1 ^^ Suc n) (of_bl bl) =\n                         of_bl (take (length bl - Suc n) bl)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(shiftr1 ^^ n) (of_bl bl) = of_bl (take (length bl - n) bl);\n        length bl \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> shiftr1 (of_bl (take (length bl - n) bl)) =\n                         of_bl (take (length bl - Suc n) bl)", "apply (subst shiftr1_bl_of)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>(shiftr1 ^^ n) (of_bl bl) = of_bl (take (length bl - n) bl);\n        length bl \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> length (take (length bl - n) bl) \\<le> LENGTH('a)\n 2. \\<And>n.\n       \\<lbrakk>(shiftr1 ^^ n) (of_bl bl) = of_bl (take (length bl - n) bl);\n        length bl \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> of_bl (butlast (take (length bl - n) bl)) =\n                         of_bl (take (length bl - Suc n) bl)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(shiftr1 ^^ n) (of_bl bl) = of_bl (take (length bl - n) bl);\n        length bl \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> of_bl (butlast (take (length bl - n) bl)) =\n                         of_bl (take (length bl - Suc n) bl)", "apply (simp add: butlast_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_bl: \"x >> n \\<equiv> of_bl (take (LENGTH('a) - n) (to_bl x))\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> n \\<equiv> of_bl (take (LENGTH('a) - n) (to_bl x))", "using shiftr_bl_of [where 'a='a, of \"to_bl x\"]"], ["proof (prove)\nusing this:\n  length (to_bl x) \\<le> LENGTH('a) \\<Longrightarrow>\n  of_bl (to_bl x) >> ?n = of_bl (take (length (to_bl x) - ?n) (to_bl x))\n\ngoal (1 subgoal):\n 1. x >> n \\<equiv> of_bl (take (LENGTH('a) - n) (to_bl x))", "by simp"], ["", "lemma aligned_bl_add_size [OF refl]:\n  \"size x - n = m \\<Longrightarrow> n \\<le> size x \\<Longrightarrow> drop m (to_bl x) = replicate n False \\<Longrightarrow>\n    take m (to_bl y) = replicate m False \\<Longrightarrow>\n    to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)\" for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)", "apply (subgoal_tac \"x AND y = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)\n 2. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> x AND y = 0", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> x AND y = 0\n 2. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)", "apply (rule word_bl.Rep_eqD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> to_bl (x AND y) = to_bl 0\n 2. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)", "apply (simp add: bl_word_and)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> map2 (\\<and>) (to_bl x) (to_bl y) =\n                      replicate LENGTH('a) False\n 2. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)", "apply (rule align_lem_and [THEN trans])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = ?n4 + ?m4\n 2. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> length (to_bl y) = ?n4 + ?m4\n 3. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> drop ?m4 (to_bl x) = replicate ?n4 False\n 4. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> take ?m4 (to_bl y) = replicate ?m4 False\n 5. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> replicate (?n4 + ?m4) False =\n                      replicate LENGTH('a) False\n 6. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)", "apply (simp_all add: word_size)[5]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>LENGTH('a) - n = m; n \\<le> LENGTH('a);\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False\\<rbrakk>\n    \\<Longrightarrow> n + m = LENGTH('a)\n 2. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl (x + y) = take m (to_bl x) @ drop m (to_bl y)", "apply (subst word_plus_and_or [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> to_bl ((x AND y) + (x OR y)) =\n                      take m (to_bl x) @ drop m (to_bl y)", "apply (simp add : bl_word_or)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> map2 (\\<or>) (to_bl x) (to_bl y) =\n                      take m (to_bl x) @ drop m (to_bl y)", "apply (rule align_lem_or)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = ?n88 + m\n 2. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> length (to_bl y) = ?n88 + m\n 3. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> drop m (to_bl x) = replicate ?n88 False\n 4. \\<lbrakk>size x - n = m; n \\<le> size x;\n     drop m (to_bl x) = replicate n False;\n     take m (to_bl y) = replicate m False; x AND y = 0\\<rbrakk>\n    \\<Longrightarrow> take m (to_bl y) = replicate m False", "apply (simp_all add: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_bl: \"mask n = of_bl (replicate n True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n = of_bl (replicate n True)", "by (auto simp add : test_bit_of_bl word_size intro: word_eqI)"], ["", "lemma bl_and_mask':\n  \"to_bl (w AND mask n :: 'a::len word) =\n    replicate (LENGTH('a) - n) False @\n    drop (LENGTH('a) - n) (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) =\n    replicate (LENGTH('a) - n) False @ drop (LENGTH('a) - n) (to_bl w)", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (to_bl (w AND mask n)) =\n    length\n     (replicate (LENGTH('a) - n) False @ drop (LENGTH('a) - n) (to_bl w))\n 2. \\<And>i.\n       i < length (to_bl (w AND mask n)) \\<Longrightarrow>\n       to_bl (w AND mask n) ! i =\n       (replicate (LENGTH('a) - n) False @\n        drop (LENGTH('a) - n) (to_bl w)) !\n       i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (to_bl (w AND mask n)) \\<Longrightarrow>\n       to_bl (w AND mask n) ! i =\n       (replicate (LENGTH('a) - n) False @\n        drop (LENGTH('a) - n) (to_bl w)) !\n       i", "apply (clarsimp simp add: to_bl_nth word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < LENGTH('a) \\<Longrightarrow>\n       (w !! (LENGTH('a) - Suc i) \\<and> LENGTH('a) - Suc i < n) =\n       (replicate (LENGTH('a) - n) False @\n        drop (LENGTH('a) - n) (to_bl w)) !\n       i", "apply (auto simp add: word_size test_bit_bl nth_append rev_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma slice1_eq_of_bl:\n  \\<open>(slice1 n w :: 'b::len word) = of_bl (takefill False n (to_bl w))\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice1 n w = of_bl (takefill False n (to_bl w))", "proof (rule bit_word_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('b) \\<Longrightarrow>\n       bit (slice1 n w) na = bit (of_bl (takefill False n (to_bl w))) na", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('b) \\<Longrightarrow>\n       bit (slice1 n w) na = bit (of_bl (takefill False n (to_bl w))) na", "assume \\<open>m < LENGTH('b)\\<close>"], ["proof (state)\nthis:\n  m < LENGTH('b)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('b) \\<Longrightarrow>\n       bit (slice1 n w) na = bit (of_bl (takefill False n (to_bl w))) na", "show \\<open>bit (slice1 n w :: 'b::len word) m \\<longleftrightarrow> bit (of_bl (takefill False n (to_bl w)) :: 'b word) m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (slice1 n w) m = bit (of_bl (takefill False n (to_bl w))) m", "by (cases \\<open>m \\<ge> n\\<close>; cases \\<open>LENGTH('a) \\<ge> n\\<close>)\n      (auto simp add: bit_slice1_iff bit_of_bl_iff not_less rev_nth not_le nth_takefill nth_to_bl algebra_simps)"], ["proof (state)\nthis:\n  bit (slice1 n w) m = bit (of_bl (takefill False n (to_bl w))) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice1_no_bin [simp]:\n  \"slice1 n (numeral w :: 'b word) = of_bl (takefill False n (bin_to_bl (LENGTH('b::len)) (numeral w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice1 n (numeral w) =\n    of_bl (takefill False n (bin_to_bl LENGTH('b) (numeral w)))", "by (simp add: slice1_eq_of_bl)"], ["", "(* TODO: neg_numeral *)"], ["", "lemma slice_no_bin [simp]:\n  \"slice n (numeral w :: 'b word) = of_bl (takefill False (LENGTH('b::len) - n)\n    (bin_to_bl (LENGTH('b::len)) (numeral w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice n (numeral w) =\n    of_bl\n     (takefill False (LENGTH('b) - n) (bin_to_bl LENGTH('b) (numeral w)))", "by (simp add: slice_def)"], ["", "(* TODO: neg_numeral *)"], ["", "lemma slice_take': \"slice n w = of_bl (take (size w - n) (to_bl w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice n w = of_bl (take (size w - n) (to_bl w))", "by (simp add: slice_def word_size slice1_eq_of_bl takefill_alt)"], ["", "lemmas slice_take = slice_take' [unfolded word_size]\n\n\\<comment> \\<open>shiftr to a word of the same size is just slice,\n    slice is just shiftr then ucast\\<close>"], ["", "lemmas shiftr_slice = trans [OF shiftr_bl [THEN meta_eq_to_obj_eq] slice_take [symmetric]]"], ["", "lemma slice1_down_alt':\n  \"sl = slice1 n w \\<Longrightarrow> fs = size sl \\<Longrightarrow> fs + k = n \\<Longrightarrow>\n    to_bl sl = takefill False fs (drop k (to_bl w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sl = slice1 n w; fs = size sl; fs + k = n\\<rbrakk>\n    \\<Longrightarrow> to_bl sl = takefill False fs (drop k (to_bl w))", "apply (simp add: slice1_eq_of_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sl = of_bl (takefill False n (to_bl w));\n     fs = size (of_bl (takefill False n (to_bl w)));\n     size (of_bl (takefill False n (to_bl w))) + k = n\\<rbrakk>\n    \\<Longrightarrow> to_bl (of_bl (takefill False n (to_bl w))) =\n                      takefill False\n                       (size (of_bl (takefill False n (to_bl w))))\n                       (drop k (to_bl w))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sl n w fs k.\n       \\<lbrakk>take_bit LENGTH('a) sl =\n                take_bit LENGTH('a)\n                 (bl_to_bin (takefill False n (bin_to_bl LENGTH('b) w)));\n        fs = LENGTH('a); LENGTH('a) + k = n\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a)\n                          (bl_to_bin\n                            (takefill False n (bin_to_bl LENGTH('b) w))) =\n                         takefill False LENGTH('a)\n                          (drop k (bin_to_bl LENGTH('b) w))", "apply (simp add: bl_bin_bl_rep_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sl n w fs k.\n       \\<lbrakk>take_bit LENGTH('a) sl =\n                take_bit LENGTH('a)\n                 (bl_to_bin (takefill False n (bin_to_bl LENGTH('b) w)));\n        fs = LENGTH('a); LENGTH('a) + k = n\\<rbrakk>\n       \\<Longrightarrow> drop (n - LENGTH('a))\n                          (takefill False n (bin_to_bl LENGTH('b) w)) =\n                         takefill False LENGTH('a)\n                          (drop k (bin_to_bl LENGTH('b) w))", "using drop_takefill"], ["proof (prove)\nusing this:\n  drop ?k (takefill ?fill (?m + ?k) ?w) = takefill ?fill ?m (drop ?k ?w)\n\ngoal (1 subgoal):\n 1. \\<And>sl n w fs k.\n       \\<lbrakk>take_bit LENGTH('a) sl =\n                take_bit LENGTH('a)\n                 (bl_to_bin (takefill False n (bin_to_bl LENGTH('b) w)));\n        fs = LENGTH('a); LENGTH('a) + k = n\\<rbrakk>\n       \\<Longrightarrow> drop (n - LENGTH('a))\n                          (takefill False n (bin_to_bl LENGTH('b) w)) =\n                         takefill False LENGTH('a)\n                          (drop k (bin_to_bl LENGTH('b) w))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma slice1_up_alt':\n  \"sl = slice1 n w \\<Longrightarrow> fs = size sl \\<Longrightarrow> fs = n + k \\<Longrightarrow>\n    to_bl sl = takefill False fs (replicate k False @ (to_bl w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sl = slice1 n w; fs = size sl; fs = n + k\\<rbrakk>\n    \\<Longrightarrow> to_bl sl =\n                      takefill False fs (replicate k False @ to_bl w)", "apply (simp add: slice1_eq_of_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sl = of_bl (takefill False n (to_bl w));\n     n + k = size (of_bl (takefill False n (to_bl w)));\n     fs = size (of_bl (takefill False n (to_bl w)))\\<rbrakk>\n    \\<Longrightarrow> to_bl (of_bl (takefill False n (to_bl w))) =\n                      takefill False\n                       (size (of_bl (takefill False n (to_bl w))))\n                       (replicate k False @ to_bl w)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sl n w k fs.\n       \\<lbrakk>take_bit LENGTH('a) sl =\n                take_bit LENGTH('a)\n                 (bl_to_bin (takefill False n (bin_to_bl LENGTH('b) w)));\n        n + k = LENGTH('a); fs = LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bin_to_bl LENGTH('a)\n                          (bl_to_bin\n                            (takefill False n (bin_to_bl LENGTH('b) w))) =\n                         takefill False LENGTH('a)\n                          (replicate k False @ bin_to_bl LENGTH('b) w)", "apply (simp add: bl_bin_bl_rep_drop flip: takefill_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sl n w k fs.\n       \\<lbrakk>take_bit LENGTH('a) sl =\n                take_bit LENGTH('a)\n                 (bl_to_bin (takefill False n (bin_to_bl LENGTH('b) w)));\n        n + k = LENGTH('a); fs = LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> takefill False LENGTH('a)\n                          (replicate (LENGTH('a) - n) False @\n                           bin_to_bl LENGTH('b) w) =\n                         takefill False LENGTH('a)\n                          (replicate k False @ bin_to_bl LENGTH('b) w)", "apply (metis diff_add_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas sd1 = slice1_down_alt' [OF refl refl, unfolded word_size]"], ["", "lemmas su1 = slice1_up_alt' [OF refl refl, unfolded word_size]"], ["", "lemmas slice1_down_alt = le_add_diff_inverse [THEN sd1]"], ["", "lemmas slice1_up_alts =\n  le_add_diff_inverse [symmetric, THEN su1]\n  le_add_diff_inverse2 [symmetric, THEN su1]"], ["", "lemma slice1_tf_tf':\n  \"to_bl (slice1 n w :: 'a::len word) =\n    rev (takefill False (LENGTH('a)) (rev (takefill False n (to_bl w))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (slice1 n w) =\n    rev (takefill False LENGTH('a) (rev (takefill False n (to_bl w))))", "unfolding slice1_eq_of_bl"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (of_bl (takefill False n (to_bl w))) =\n    rev (takefill False LENGTH('a) (rev (takefill False n (to_bl w))))", "by (rule word_rev_tf)"], ["", "lemmas slice1_tf_tf = slice1_tf_tf' [THEN word_bl.Rep_inverse', symmetric]"], ["", "lemma revcast_eq_of_bl:\n  \\<open>(revcast w :: 'b::len word) = of_bl (takefill False (LENGTH('b)) (to_bl w))\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. revcast w = of_bl (takefill False LENGTH('b) (to_bl w))", "by (simp add: revcast_def slice1_eq_of_bl)"], ["", "lemmas revcast_no_def [simp] = revcast_eq_of_bl [where w=\"numeral w\", unfolded word_size] for w"], ["", "lemma to_bl_revcast:\n  \"to_bl (revcast w :: 'a::len word) = takefill False (LENGTH('a)) (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (revcast w) = takefill False LENGTH('a) (to_bl w)", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (to_bl (revcast w)) =\n    length (takefill False LENGTH('a) (to_bl w))\n 2. \\<And>i.\n       i < length (to_bl (revcast w)) \\<Longrightarrow>\n       to_bl (revcast w) ! i = takefill False LENGTH('a) (to_bl w) ! i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (to_bl (revcast w)) \\<Longrightarrow>\n       to_bl (revcast w) ! i = takefill False LENGTH('a) (to_bl w) ! i", "apply (cases \\<open>LENGTH('a) \\<le> LENGTH('b)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length (to_bl (revcast w));\n        LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> to_bl (revcast w) ! i =\n                         takefill False LENGTH('a) (to_bl w) ! i\n 2. \\<And>i.\n       \\<lbrakk>i < length (to_bl (revcast w));\n        \\<not> LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> to_bl (revcast w) ! i =\n                         takefill False LENGTH('a) (to_bl w) ! i", "apply (auto simp add: nth_to_bl nth_takefill bit_revcast_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_cat_bl: \"word_cat a b = of_bl (to_bl a @ to_bl b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_cat a b = of_bl (to_bl a @ to_bl b)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       bit (word_cat a b) n = bit (of_bl (to_bl a @ to_bl b)) n", "apply (simp add: bit_word_cat_iff bit_of_bl_iff nth_append not_less nth_rev_to_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < LENGTH('a) \\<Longrightarrow>\n       LENGTH('c) \\<le> n \\<longrightarrow>\n       bit a (n - LENGTH('c)) =\n       (rev (to_bl a) ! (n - LENGTH('c)) \\<and> n < LENGTH('b) + LENGTH('c))", "apply (meson bit_word.rep_eq less_diff_conv2 nth_rev_to_bl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_bl_append:\n  \"(of_bl (xs @ ys) :: 'a::len word) = of_bl xs * 2^(length ys) + of_bl ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (xs @ ys) = of_bl xs * 2 ^ length ys + of_bl ys", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       take_bit LENGTH('a) (bl_to_bin (xs @ ys)) =\n       take_bit LENGTH('a) (bl_to_bin xs * 2 ^ length ys + bl_to_bin ys)", "apply (simp add: bl_to_bin_app_cat bin_cat_num)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_bl_False [simp]: \"of_bl (False#xs) = of_bl xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (False # xs) = of_bl xs", "by (rule word_eqI) (auto simp: test_bit_of_bl nth_append)"], ["", "lemma of_bl_True [simp]: \"(of_bl (True # xs) :: 'a::len word) = 2^length xs + of_bl xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (True # xs) = 2 ^ length xs + of_bl xs", "by (subst of_bl_append [where xs=\"[True]\", simplified]) (simp add: word_1_bl)"], ["", "lemma of_bl_Cons: \"of_bl (x#xs) = of_bool x * 2^length xs + of_bl xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (x # xs) = of_bool x * 2 ^ length xs + of_bl xs", "by (cases x) simp_all"], ["", "lemma word_split_bl':\n  \"std = size c - size b \\<Longrightarrow> (word_split c = (a, b)) \\<Longrightarrow>\n    (a = of_bl (take std (to_bl c)) \\<and> b = of_bl (drop std (to_bl c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>std = size c - size b; word_split c = (a, b)\\<rbrakk>\n    \\<Longrightarrow> a = of_bl (take std (to_bl c)) \\<and>\n                      b = of_bl (drop std (to_bl c))", "apply (simp add: word_split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>std = size c - size b;\n     ucast (drop_bit LENGTH('b) c) = a \\<and> ucast c = b\\<rbrakk>\n    \\<Longrightarrow> a = of_bl (take (size c - size b) (to_bl c)) \\<and>\n                      b = of_bl (drop (size c - size b) (to_bl c))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>std c b a.\n       \\<lbrakk>std = LENGTH('a) - LENGTH('b);\n        take_bit LENGTH('c)\n         (take_bit LENGTH('a)\n           ((drop_bit LENGTH('b) \\<circ> take_bit LENGTH('a)) c)) =\n        take_bit LENGTH('c) a \\<and>\n        take_bit LENGTH('b) (take_bit LENGTH('a) c) =\n        take_bit LENGTH('b) b\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('c) a =\n                         take_bit LENGTH('c)\n                          (bl_to_bin\n                            (take (LENGTH('a) - LENGTH('b))\n                              (bin_to_bl LENGTH('a) c))) \\<and>\n                         take_bit LENGTH('b) b =\n                         take_bit LENGTH('b)\n                          (bl_to_bin\n                            (drop (LENGTH('a) - LENGTH('b))\n                              (bin_to_bl LENGTH('a) c)))", "apply (cases \\<open>LENGTH('b) \\<le> LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>std c b a.\n       \\<lbrakk>std = LENGTH('a) - LENGTH('b);\n        take_bit LENGTH('c)\n         (take_bit LENGTH('a)\n           ((drop_bit LENGTH('b) \\<circ> take_bit LENGTH('a)) c)) =\n        take_bit LENGTH('c) a \\<and>\n        take_bit LENGTH('b) (take_bit LENGTH('a) c) = take_bit LENGTH('b) b;\n        LENGTH('b) \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('c) a =\n                         take_bit LENGTH('c)\n                          (bl_to_bin\n                            (take (LENGTH('a) - LENGTH('b))\n                              (bin_to_bl LENGTH('a) c))) \\<and>\n                         take_bit LENGTH('b) b =\n                         take_bit LENGTH('b)\n                          (bl_to_bin\n                            (drop (LENGTH('a) - LENGTH('b))\n                              (bin_to_bl LENGTH('a) c)))\n 2. \\<And>std c b a.\n       \\<lbrakk>std = LENGTH('a) - LENGTH('b);\n        take_bit LENGTH('c)\n         (take_bit LENGTH('a)\n           ((drop_bit LENGTH('b) \\<circ> take_bit LENGTH('a)) c)) =\n        take_bit LENGTH('c) a \\<and>\n        take_bit LENGTH('b) (take_bit LENGTH('a) c) = take_bit LENGTH('b) b;\n        \\<not> LENGTH('b) \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('c) a =\n                         take_bit LENGTH('c)\n                          (bl_to_bin\n                            (take (LENGTH('a) - LENGTH('b))\n                              (bin_to_bl LENGTH('a) c))) \\<and>\n                         take_bit LENGTH('b) b =\n                         take_bit LENGTH('b)\n                          (bl_to_bin\n                            (drop (LENGTH('a) - LENGTH('b))\n                              (bin_to_bl LENGTH('a) c)))", "apply (auto simp add: drop_bit_take_bit drop_bin2bl bin_to_bl_drop_bit [symmetric, of \\<open>LENGTH('a)\\<close> \\<open>LENGTH('a) - LENGTH('b)\\<close> \\<open>LENGTH('b)\\<close>] min_absorb2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_split_bl: \"std = size c - size b \\<Longrightarrow>\n    (a = of_bl (take std (to_bl c)) \\<and> b = of_bl (drop std (to_bl c))) \\<longleftrightarrow>\n    word_split c = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. std = size c - size b \\<Longrightarrow>\n    (a = of_bl (take std (to_bl c)) \\<and> b = of_bl (drop std (to_bl c))) =\n    (word_split c = (a, b))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>std = size c - size b;\n     a = of_bl (take std (to_bl c)) \\<and>\n     b = of_bl (drop std (to_bl c))\\<rbrakk>\n    \\<Longrightarrow> word_split c = (a, b)\n 2. \\<lbrakk>std = size c - size b; word_split c = (a, b)\\<rbrakk>\n    \\<Longrightarrow> a = of_bl (take std (to_bl c)) \\<and>\n                      b = of_bl (drop std (to_bl c))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>std = size c - size b; word_split c = (a, b)\\<rbrakk>\n    \\<Longrightarrow> a = of_bl (take std (to_bl c)) \\<and>\n                      b = of_bl (drop std (to_bl c))\n 2. \\<lbrakk>std = size c - size b;\n     a = of_bl (take std (to_bl c)) \\<and>\n     b = of_bl (drop std (to_bl c))\\<rbrakk>\n    \\<Longrightarrow> word_split c = (a, b)", "apply (erule (1) word_split_bl')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>std = size c - size b;\n     a = of_bl (take std (to_bl c)) \\<and>\n     b = of_bl (drop std (to_bl c))\\<rbrakk>\n    \\<Longrightarrow> word_split c = (a, b)", "apply (case_tac \"word_split c\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>std = size c - size b;\n        a = of_bl (take std (to_bl c)) \\<and>\n        b = of_bl (drop std (to_bl c));\n        word_split c = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> word_split c = (a, b)", "apply (auto simp add: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>std = LENGTH('a) - LENGTH('b); word_split c = (aa, ba);\n        a = of_bl (take (LENGTH('a) - LENGTH('b)) (to_bl c));\n        b = of_bl (drop (LENGTH('a) - LENGTH('b)) (to_bl c))\\<rbrakk>\n       \\<Longrightarrow> word_split c =\n                         (of_bl (take (LENGTH('a) - LENGTH('b)) (to_bl c)),\n                          of_bl (drop (LENGTH('a) - LENGTH('b)) (to_bl c)))", "apply (frule word_split_bl' [rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>std = LENGTH('a) - LENGTH('b); word_split c = (aa, ba);\n        a = of_bl (take (LENGTH('a) - LENGTH('b)) (to_bl c));\n        b = of_bl (drop (LENGTH('a) - LENGTH('b)) (to_bl c))\\<rbrakk>\n       \\<Longrightarrow> ?std8 aa ba = size c - size ba\n 2. \\<And>aa ba.\n       \\<lbrakk>std = LENGTH('a) - LENGTH('b); word_split c = (aa, ba);\n        a = of_bl (take (LENGTH('a) - LENGTH('b)) (to_bl c));\n        b = of_bl (drop (LENGTH('a) - LENGTH('b)) (to_bl c));\n        aa = of_bl (take (?std8 aa ba) (to_bl c)) \\<and>\n        ba = of_bl (drop (?std8 aa ba) (to_bl c))\\<rbrakk>\n       \\<Longrightarrow> word_split c =\n                         (of_bl (take (LENGTH('a) - LENGTH('b)) (to_bl c)),\n                          of_bl (drop (LENGTH('a) - LENGTH('b)) (to_bl c)))", "apply (auto simp add: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_split_bl_eq:\n  \"(word_split c :: ('c::len word \\<times> 'd::len word)) =\n    (of_bl (take (LENGTH('a::len) - LENGTH('d::len)) (to_bl c)),\n     of_bl (drop (LENGTH('a) - LENGTH('d)) (to_bl c)))\"\n  for c :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_split c =\n    (of_bl (take (LENGTH('a) - LENGTH('d)) (to_bl c)),\n     of_bl (drop (LENGTH('a) - LENGTH('d)) (to_bl c)))", "apply (rule word_split_bl [THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?std1 = size c - size (of_bl (drop (LENGTH('a) - LENGTH('d)) (to_bl c)))\n 2. of_bl (take (LENGTH('a) - LENGTH('d)) (to_bl c)) =\n    of_bl (take ?std1 (to_bl c)) \\<and>\n    of_bl (drop (LENGTH('a) - LENGTH('d)) (to_bl c)) =\n    of_bl (drop ?std1 (to_bl c))", "apply (unfold word_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?std1 = LENGTH('a) - LENGTH('d)\n 2. of_bl (take (LENGTH('a) - LENGTH('d)) (to_bl c)) =\n    of_bl (take ?std1 (to_bl c)) \\<and>\n    of_bl (drop (LENGTH('a) - LENGTH('d)) (to_bl c)) =\n    of_bl (drop ?std1 (to_bl c))", "apply (rule refl conjI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_rcat_bl:\n  \\<open>word_rcat wl = of_bl (concat (map to_bl wl))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_rcat wl = of_bl (concat (map to_bl wl))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. word_rcat wl = of_bl (concat (map to_bl wl))", "define ws where \\<open>ws = rev wl\\<close>"], ["proof (state)\nthis:\n  ws = rev wl\n\ngoal (1 subgoal):\n 1. word_rcat wl = of_bl (concat (map to_bl wl))", "moreover"], ["proof (state)\nthis:\n  ws = rev wl\n\ngoal (1 subgoal):\n 1. word_rcat wl = of_bl (concat (map to_bl wl))", "have \\<open>word_rcat (rev ws) = of_bl (concat (map to_bl (rev ws)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_rcat (rev ws) = of_bl (concat (map to_bl (rev ws)))", "apply (simp add: word_rcat_def of_bl_eq rev_concat rev_map comp_def rev_to_bl_eq flip: horner_sum_of_bool_2_concat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int\n     (horner_sum of_bool 2\n       (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('b)]) ws))) =\n    horner_sum of_bool 2\n     (concat (map (\\<lambda>x. map (bit x) [0..<LENGTH('b)]) ws))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ws.\n       take_bit LENGTH('c)\n        (horner_sum of_bool 2\n          (concat\n            (map (\\<lambda>x.\n                     map (\\<lambda>n. n < LENGTH('b) \\<and> bit x n)\n                      [0..<LENGTH('b)])\n              ws))) =\n       take_bit LENGTH('c)\n        (horner_sum of_bool 2\n          (concat\n            (map (\\<lambda>x.\n                     map (\\<lambda>n. n < LENGTH('b) \\<and> bit x n)\n                      [0..<LENGTH('b)])\n              ws)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  word_rcat (rev ws) = of_bl (concat (map to_bl (rev ws)))\n\ngoal (1 subgoal):\n 1. word_rcat wl = of_bl (concat (map to_bl wl))", "ultimately"], ["proof (chain)\npicking this:\n  ws = rev wl\n  word_rcat (rev ws) = of_bl (concat (map to_bl (rev ws)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ws = rev wl\n  word_rcat (rev ws) = of_bl (concat (map to_bl (rev ws)))\n\ngoal (1 subgoal):\n 1. word_rcat wl = of_bl (concat (map to_bl wl))", "by simp"], ["proof (state)\nthis:\n  word_rcat wl = of_bl (concat (map to_bl wl))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_rcat_lem': \"size (concat (map to_bl wl)) = length wl * size (hd wl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (map to_bl wl)) = length wl * size (hd wl)", "by (induct wl) (auto simp: word_size)"], ["", "lemmas size_rcat_lem = size_rcat_lem' [unfolded word_size]"], ["", "lemma nth_rcat_lem:\n  \"n < length (wl::'a word list) * LENGTH('a::len) \\<Longrightarrow>\n    rev (concat (map to_bl wl)) ! n =\n    rev (to_bl (rev wl ! (n div LENGTH('a)))) ! (n mod LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length wl * LENGTH('a) \\<Longrightarrow>\n    rev (concat (map to_bl wl)) ! n =\n    rev (to_bl (rev wl ! (n div LENGTH('a)))) ! (n mod LENGTH('a))", "apply (induct wl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < length [] * LENGTH('a) \\<Longrightarrow>\n    rev (concat (map to_bl [])) ! n =\n    rev (to_bl (rev [] ! (n div LENGTH('a)))) ! (n mod LENGTH('a))\n 2. \\<And>a wl.\n       \\<lbrakk>n < length wl * LENGTH('a) \\<Longrightarrow>\n                rev (concat (map to_bl wl)) ! n =\n                rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                (n mod LENGTH('a));\n        n < length (a # wl) * LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> rev (concat (map to_bl (a # wl))) ! n =\n                         rev (to_bl (rev (a # wl) ! (n div LENGTH('a)))) !\n                         (n mod LENGTH('a))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wl.\n       \\<lbrakk>n < length wl * LENGTH('a) \\<Longrightarrow>\n                rev (concat (map to_bl wl)) ! n =\n                rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                (n mod LENGTH('a));\n        n < length (a # wl) * LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> rev (concat (map to_bl (a # wl))) ! n =\n                         rev (to_bl (rev (a # wl) ! (n div LENGTH('a)))) !\n                         (n mod LENGTH('a))", "apply (clarsimp simp add : nth_append size_rcat_lem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wl.\n       \\<lbrakk>n < length wl * LENGTH('a) \\<Longrightarrow>\n                rev (concat (map to_bl wl)) ! n =\n                rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                (n mod LENGTH('a));\n        n < LENGTH('a) + length wl * LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> (n div LENGTH('a) < length wl \\<longrightarrow>\n                          \\<not> n < length wl *\n                                     LENGTH('a) \\<longrightarrow>\n                          rev (to_bl a) ! (n - length wl * LENGTH('a)) =\n                          rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                          (n mod LENGTH('a))) \\<and>\n                         (\\<not> n div LENGTH('a)\n                                 < length wl \\<longrightarrow>\n                          (n < length wl * LENGTH('a) \\<longrightarrow>\n                           rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                           (n mod LENGTH('a)) =\n                           rev (to_bl\n                                 ([a] ! (n div LENGTH('a) - length wl))) !\n                           (n mod LENGTH('a))) \\<and>\n                          (\\<not> n < length wl *\nLENGTH('a) \\<longrightarrow>\n                           rev (to_bl a) ! (n - length wl * LENGTH('a)) =\n                           rev (to_bl\n                                 ([a] ! (n div LENGTH('a) - length wl))) !\n                           (n mod LENGTH('a))))", "apply (simp flip: mult_Suc minus_div_mult_eq_mod add: less_Suc_eq_le not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a wl.\n       \\<lbrakk>n < length wl * LENGTH('a) \\<Longrightarrow>\n                rev (concat (map to_bl wl)) ! n =\n                rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                (n - n div LENGTH('a) * LENGTH('a));\n        n < Suc (length wl) * LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> (n div LENGTH('a) < length wl \\<longrightarrow>\n                          length wl * LENGTH('a) \\<le> n \\<longrightarrow>\n                          rev (to_bl a) ! (n - length wl * LENGTH('a)) =\n                          rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                          (n - n div LENGTH('a) * LENGTH('a))) \\<and>\n                         (length wl \\<le> n div LENGTH('a) \\<longrightarrow>\n                          (n < length wl * LENGTH('a) \\<longrightarrow>\n                           rev (to_bl (rev wl ! (n div LENGTH('a)))) !\n                           (n - n div LENGTH('a) * LENGTH('a)) =\n                           rev (to_bl\n                                 ([a] ! (n div LENGTH('a) - length wl))) !\n                           (n - n div LENGTH('a) * LENGTH('a))) \\<and>\n                          (length wl * LENGTH('a) \\<le> n \\<longrightarrow>\n                           rev (to_bl a) ! (n - length wl * LENGTH('a)) =\n                           rev (to_bl\n                                 ([a] ! (n div LENGTH('a) - length wl))) !\n                           (n - n div LENGTH('a) * LENGTH('a))))", "apply (metis (no_types, lifting) diff_is_0_eq div_le_mono len_not_eq_0 less_Suc_eq less_mult_imp_div_less nonzero_mult_div_cancel_right not_le nth_Cons_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldl_eq_foldr: \"foldl (+) x xs = foldr (+) (x # xs) 0\"\n  for x :: \"'a::comm_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) x xs = foldr (+) (x # xs) (0::'a)", "by (induct xs arbitrary: x) (auto simp: add.assoc)"], ["", "lemmas word_cat_bl_no_bin [simp] =\n  word_cat_bl [where a=\"numeral a\" and b=\"numeral b\", unfolded to_bl_numeral]\n  for a b"], ["", "(* FIXME: negative numerals, 0 and 1 *)"], ["", "lemmas word_split_bl_no_bin [simp] =\n  word_split_bl_eq [where c=\"numeral c\", unfolded to_bl_numeral] for c"], ["", "lemmas word_rot_defs = word_roti_eq_word_rotr_word_rotl word_rotr_eq word_rotl_eq"], ["", "lemma to_bl_rotl: \"to_bl (word_rotl n w) = rotate n (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (word_rotl n w) = rotate n (to_bl w)", "by (simp add: word_rotl_eq to_bl_use_of_bl)"], ["", "lemmas blrs0 = rotate_eqs [THEN to_bl_rotl [THEN trans]]"], ["", "lemmas word_rotl_eqs =\n  blrs0 [simplified word_bl_Rep' word_bl.Rep_inject to_bl_rotl [symmetric]]"], ["", "lemma to_bl_rotr: \"to_bl (word_rotr n w) = rotater n (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (word_rotr n w) = rotater n (to_bl w)", "by (simp add: word_rotr_eq to_bl_use_of_bl)"], ["", "lemmas brrs0 = rotater_eqs [THEN to_bl_rotr [THEN trans]]"], ["", "lemmas word_rotr_eqs =\n  brrs0 [simplified word_bl_Rep' word_bl.Rep_inject to_bl_rotr [symmetric]]"], ["", "declare word_rotr_eqs (1) [simp]"], ["", "declare word_rotl_eqs (1) [simp]"], ["", "lemmas abl_cong = arg_cong [where f = \"of_bl\"]"], ["", "locale word_rotate\nbegin"], ["", "lemmas word_rot_defs' = to_bl_rotl to_bl_rotr"], ["", "lemmas blwl_syms [symmetric] = bl_word_not bl_word_and bl_word_or bl_word_xor"], ["", "lemmas lbl_lbl = trans [OF word_bl_Rep' word_bl_Rep' [symmetric]]"], ["", "lemmas ths_map2 [OF lbl_lbl] = rotate_map2 rotater_map2"], ["", "lemmas ths_map [where xs = \"to_bl v\"] = rotate_map rotater_map for v"], ["", "lemmas th1s [simplified word_rot_defs' [symmetric]] = ths_map2 ths_map"], ["", "end"], ["", "lemmas bl_word_rotl_dt = trans [OF to_bl_rotl rotate_drop_take,\n  simplified word_bl_Rep']"], ["", "lemmas bl_word_rotr_dt = trans [OF to_bl_rotr rotater_drop_take,\n  simplified word_bl_Rep']"], ["", "lemma bl_word_roti_dt':\n  \"n = nat ((- i) mod int (size (w :: 'a::len word))) \\<Longrightarrow>\n    to_bl (word_roti i w) = drop n (to_bl w) @ take n (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = nat (- i mod int (size w)) \\<Longrightarrow>\n    to_bl (word_roti i w) = drop n (to_bl w) @ take n (to_bl w)", "apply (unfold word_roti_eq_word_rotr_word_rotl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = nat (- i mod int (size w)) \\<Longrightarrow>\n    to_bl\n     (if 0 \\<le> i then word_rotr (nat i) w else word_rotl (nat (- i)) w) =\n    drop n (to_bl w) @ take n (to_bl w)", "apply (simp add: bl_word_rotl_dt bl_word_rotr_dt word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = nat (- i mod int LENGTH('a)) \\<Longrightarrow>\n    (0 \\<le> i \\<longrightarrow>\n     drop (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) @\n     take (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) =\n     drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n     take (nat (- i mod int LENGTH('a))) (to_bl w)) \\<and>\n    (\\<not> 0 \\<le> i \\<longrightarrow>\n     drop (nat (- i) mod LENGTH('a)) (to_bl w) @\n     take (nat (- i) mod LENGTH('a)) (to_bl w) =\n     drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n     take (nat (- i mod int LENGTH('a))) (to_bl w))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = nat (- i mod int LENGTH('a)); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> drop (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) @\n                      take (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) =\n                      drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n                      take (nat (- i mod int LENGTH('a))) (to_bl w)\n 2. \\<lbrakk>n = nat (- i mod int LENGTH('a)); \\<not> 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> drop (nat (- i) mod LENGTH('a)) (to_bl w) @\n                      take (nat (- i) mod LENGTH('a)) (to_bl w) =\n                      drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n                      take (nat (- i mod int LENGTH('a))) (to_bl w)", "apply (simp add: zmod_zminus1_eq_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n =\n             nat (if i mod int LENGTH('a) = 0 then 0\n                  else int LENGTH('a) - i mod int LENGTH('a));\n     0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> (i mod int LENGTH('a) = 0 \\<longrightarrow>\n                       drop (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) @\n                       take (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) =\n                       to_bl w) \\<and>\n                      (i mod int LENGTH('a) \\<noteq> 0 \\<longrightarrow>\n                       drop (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) @\n                       take (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) =\n                       drop (nat (int LENGTH('a) - i mod int LENGTH('a)))\n                        (to_bl w) @\n                       take (nat (int LENGTH('a) - i mod int LENGTH('a)))\n                        (to_bl w))\n 2. \\<lbrakk>n = nat (- i mod int LENGTH('a)); \\<not> 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> drop (nat (- i) mod LENGTH('a)) (to_bl w) @\n                      take (nat (- i) mod LENGTH('a)) (to_bl w) =\n                      drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n                      take (nat (- i mod int LENGTH('a))) (to_bl w)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>n =\n                nat (if int LENGTH('a) * q mod int LENGTH('a) = 0 then 0\n                     else int LENGTH('a) -\n                          int LENGTH('a) * q mod int LENGTH('a));\n        0 \\<le> int LENGTH('a) * q; i = int LENGTH('a) * q\\<rbrakk>\n       \\<Longrightarrow> drop\n                          (LENGTH('a) -\n                           nat (int LENGTH('a) * q) mod LENGTH('a))\n                          (to_bl w) @\n                         take\n                          (LENGTH('a) -\n                           nat (int LENGTH('a) * q) mod LENGTH('a))\n                          (to_bl w) =\n                         to_bl w\n 2. \\<lbrakk>n =\n             nat (if i mod int LENGTH('a) = 0 then 0\n                  else int LENGTH('a) - i mod int LENGTH('a));\n     0 \\<le> i; i mod int LENGTH('a) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> drop (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) @\n                      take (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) =\n                      drop (nat (int LENGTH('a) - i mod int LENGTH('a)))\n                       (to_bl w) @\n                      take (nat (int LENGTH('a) - i mod int LENGTH('a)))\n                       (to_bl w)\n 3. \\<lbrakk>n = nat (- i mod int LENGTH('a)); \\<not> 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> drop (nat (- i) mod LENGTH('a)) (to_bl w) @\n                      take (nat (- i) mod LENGTH('a)) (to_bl w) =\n                      drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n                      take (nat (- i mod int LENGTH('a))) (to_bl w)", "apply (simp add: nat_mult_distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n =\n             nat (if i mod int LENGTH('a) = 0 then 0\n                  else int LENGTH('a) - i mod int LENGTH('a));\n     0 \\<le> i; i mod int LENGTH('a) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> drop (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) @\n                      take (LENGTH('a) - nat i mod LENGTH('a)) (to_bl w) =\n                      drop (nat (int LENGTH('a) - i mod int LENGTH('a)))\n                       (to_bl w) @\n                      take (nat (int LENGTH('a) - i mod int LENGTH('a)))\n                       (to_bl w)\n 2. \\<lbrakk>n = nat (- i mod int LENGTH('a)); \\<not> 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> drop (nat (- i) mod LENGTH('a)) (to_bl w) @\n                      take (nat (- i) mod LENGTH('a)) (to_bl w) =\n                      drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n                      take (nat (- i mod int LENGTH('a))) (to_bl w)", "apply (simp add: nat_diff_distrib [OF pos_mod_sign pos_mod_conj\n                                      [THEN conjunct2, THEN order_less_imp_le]]\n                    nat_mod_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = nat (- i mod int LENGTH('a)); \\<not> 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> drop (nat (- i) mod LENGTH('a)) (to_bl w) @\n                      take (nat (- i) mod LENGTH('a)) (to_bl w) =\n                      drop (nat (- i mod int LENGTH('a))) (to_bl w) @\n                      take (nat (- i mod int LENGTH('a))) (to_bl w)", "apply (simp add: nat_mod_distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas bl_word_roti_dt = bl_word_roti_dt' [unfolded word_size]"], ["", "lemmas word_rotl_dt = bl_word_rotl_dt [THEN word_bl.Rep_inverse' [symmetric]]"], ["", "lemmas word_rotr_dt = bl_word_rotr_dt [THEN word_bl.Rep_inverse' [symmetric]]"], ["", "lemmas word_roti_dt = bl_word_roti_dt [THEN word_bl.Rep_inverse' [symmetric]]"], ["", "lemmas word_rotr_dt_no_bin' [simp] =\n  word_rotr_dt [where w=\"numeral w\", unfolded to_bl_numeral] for w"], ["", "(* FIXME: negative numerals, 0 and 1 *)"], ["", "lemmas word_rotl_dt_no_bin' [simp] =\n  word_rotl_dt [where w=\"numeral w\", unfolded to_bl_numeral] for w"], ["", "(* FIXME: negative numerals, 0 and 1 *)"], ["", "lemma max_word_bl: \"to_bl (max_word::'a::len word) = replicate LENGTH('a) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (- 1) = replicate LENGTH('a) True", "by (fact to_bl_n1)"], ["", "lemma to_bl_mask:\n  \"to_bl (mask n :: 'a::len word) =\n  replicate (LENGTH('a) - n) False @\n    replicate (min (LENGTH('a)) n) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (mask n) =\n    replicate (LENGTH('a) - n) False @ replicate (min LENGTH('a) n) True", "by (simp add: mask_bl word_rep_drop min_def)"], ["", "lemma map_replicate_True:\n  \"n = length xs \\<Longrightarrow>\n    map (\\<lambda>(x,y). x \\<and> y) (zip xs (replicate n True)) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length xs \\<Longrightarrow> map2 (\\<and>) xs (replicate n True) = xs", "by (induct xs arbitrary: n) auto"], ["", "lemma map_replicate_False:\n  \"n = length xs \\<Longrightarrow> map (\\<lambda>(x,y). x \\<and> y)\n    (zip xs (replicate n False)) = replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length xs \\<Longrightarrow>\n    map2 (\\<and>) xs (replicate n False) = replicate n False", "by (induct xs arbitrary: n) auto"], ["", "lemma bl_and_mask:\n  fixes w :: \"'a::len word\"\n    and n :: nat\n  defines \"n' \\<equiv> LENGTH('a) - n\"\n  shows \"to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "note [simp] = map_replicate_True map_replicate_False"], ["proof (state)\nthis:\n  ?n = length ?xs \\<Longrightarrow>\n  map2 (\\<and>) ?xs (replicate ?n True) = ?xs\n  ?n = length ?xs \\<Longrightarrow>\n  map2 (\\<and>) ?xs (replicate ?n False) = replicate ?n False\n\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "have \"to_bl (w AND mask n) = map2 (\\<and>) (to_bl w) (to_bl (mask n::'a::len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = map2 (\\<and>) (to_bl w) (to_bl (mask n))", "by (simp add: bl_word_and)"], ["proof (state)\nthis:\n  to_bl (w AND mask n) = map2 (\\<and>) (to_bl w) (to_bl (mask n))\n\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "also"], ["proof (state)\nthis:\n  to_bl (w AND mask n) = map2 (\\<and>) (to_bl w) (to_bl (mask n))\n\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "have \"to_bl w = take n' (to_bl w) @ drop n' (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = take n' (to_bl w) @ drop n' (to_bl w)", "by simp"], ["proof (state)\nthis:\n  to_bl w = take n' (to_bl w) @ drop n' (to_bl w)\n\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "also"], ["proof (state)\nthis:\n  to_bl w = take n' (to_bl w) @ drop n' (to_bl w)\n\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "have \"map2 (\\<and>) \\<dots> (to_bl (mask n::'a::len word)) =\n      replicate n' False @ drop n' (to_bl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<and>) (take n' (to_bl w) @ drop n' (to_bl w)) (to_bl (mask n)) =\n    replicate n' False @ drop n' (to_bl w)", "unfolding to_bl_mask n'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<and>)\n     (take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl w))\n     (replicate (LENGTH('a) - n) False @\n      replicate (min LENGTH('a) n) True) =\n    replicate (LENGTH('a) - n) False @ drop (LENGTH('a) - n) (to_bl w)", "by (subst zip_append) auto"], ["proof (state)\nthis:\n  map2 (\\<and>) (take n' (to_bl w) @ drop n' (to_bl w)) (to_bl (mask n)) =\n  replicate n' False @ drop n' (to_bl w)\n\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "finally"], ["proof (chain)\npicking this:\n  to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "show ?thesis"], ["proof (prove)\nusing this:\n  to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)\n\ngoal (1 subgoal):\n 1. to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)", "."], ["proof (state)\nthis:\n  to_bl (w AND mask n) = replicate n' False @ drop n' (to_bl w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_rev_takefill:\n  \"length xs \\<le> n \\<Longrightarrow>\n    drop (n - length xs) (rev (takefill False n (rev xs))) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow>\n    drop (n - length xs) (rev (takefill False n (rev xs))) = xs", "by (simp add: takefill_alt rev_take)"], ["", "declare bin_to_bl_def [simp]"], ["", "lemmas of_bl_reasoning = to_bl_use_of_bl of_bl_append"], ["", "lemma uint_of_bl_is_bl_to_bin_drop:\n  \"length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow> uint (of_bl l :: 'a::len word) = bl_to_bin l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n    uint (of_bl l) = bl_to_bin l", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n       take_bit LENGTH('a) (bl_to_bin l) = bl_to_bin l", "apply (simp add: take_bit_eq_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n       bl_to_bin l mod 2 ^ LENGTH('a) = bl_to_bin l", "apply (rule Divides.mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n       0 \\<le> bl_to_bin l\n 2. \\<And>l.\n       length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n       bl_to_bin l < 2 ^ LENGTH('a)", "apply (rule bl_to_bin_ge0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n       bl_to_bin l < 2 ^ LENGTH('a)", "using bl_to_bin_lt2p_drop"], ["proof (prove)\nusing this:\n  bl_to_bin ?bs < 2 ^ length (dropWhile Not ?bs)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n       bl_to_bin l < 2 ^ LENGTH('a)", "apply (rule order.strict_trans2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       length (dropWhile Not l) \\<le> LENGTH('a) \\<Longrightarrow>\n       2 ^ length (dropWhile Not l) \\<le> 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary uint_of_bl_is_bl_to_bin:\n  \"length l\\<le>LENGTH('a) \\<Longrightarrow> uint ((of_bl::bool list\\<Rightarrow> ('a :: len) word) l) = bl_to_bin l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l \\<le> LENGTH('a) \\<Longrightarrow> uint (of_bl l) = bl_to_bin l", "apply(rule uint_of_bl_is_bl_to_bin_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length l \\<le> LENGTH('a) \\<Longrightarrow>\n    length (dropWhile Not l) \\<le> LENGTH('a)", "using le_trans length_dropWhile_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n  length (dropWhile ?P ?xs) \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. length l \\<le> LENGTH('a) \\<Longrightarrow>\n    length (dropWhile Not l) \\<le> LENGTH('a)", "by blast"], ["", "lemma bin_to_bl_or:\n  \"bin_to_bl n (a OR b) = map2 (\\<or>) (bin_to_bl n a) (bin_to_bl n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_to_bl n (a OR b) = map2 (\\<or>) (bin_to_bl n a) (bin_to_bl n b)", "using bl_or_aux_bin[where n=n and v=a and w=b and bs=\"[]\" and cs=\"[]\"]"], ["proof (prove)\nusing this:\n  map2 (\\<or>) (bin_to_bl_aux n a []) (bin_to_bl_aux n b []) =\n  bin_to_bl_aux n (a OR b) (map2 (\\<or>) [] [])\n\ngoal (1 subgoal):\n 1. bin_to_bl n (a OR b) = map2 (\\<or>) (bin_to_bl n a) (bin_to_bl n b)", "by simp"], ["", "lemma word_and_1_bl:\n  fixes x::\"'a::len word\"\n  shows \"(x AND 1) = of_bl [x !! 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND 1 = of_bl [x !! 0]", "by (simp add: mod_2_eq_odd test_bit_word_eq and_one_eq)"], ["", "lemma word_1_and_bl:\n  fixes x::\"'a::len word\"\n  shows \"(1 AND x) = of_bl [x !! 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 AND x = of_bl [x !! 0]", "by (simp add: mod_2_eq_odd test_bit_word_eq one_and_eq)"], ["", "lemma of_bl_drop:\n  \"of_bl (drop n xs) = (of_bl xs AND mask (length xs - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (drop n xs) = of_bl xs AND mask (length xs - n)", "apply (clarsimp simp: bang_eq test_bit_of_bl rev_nth cong: rev_conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       (drop n xs ! (length xs - Suc (n + na)) \\<and>\n        na < LENGTH('a) \\<and> na < length xs - n) =\n       (xs ! (length xs - Suc na) \\<and>\n        na < LENGTH('a) \\<and>\n        na < length xs \\<and>\n        na < length xs - n \\<and> na < size (mask (length xs - n)))", "apply (safe; simp add: word_size to_bl_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_bl_1:\n  \"to_bl (1::'a::len word) = replicate (LENGTH('a) - 1) False @ [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl 1 = replicate (LENGTH('a) - 1) False @ [True]", "by (rule nth_equalityI) (auto simp add: to_bl_unfold nth_append rev_nth bit_1_iff not_less not_le)"], ["", "lemma eq_zero_set_bl:\n  \"(w = 0) = (True \\<notin> set (to_bl w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = 0) = (True \\<notin> set (to_bl w))", "apply (auto simp add: to_bl_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..<LENGTH('a)}. \\<not> bit w x \\<Longrightarrow> w = 0", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>{0..<LENGTH('a)}. \\<not> bit w x;\n        n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit w n = bit 0 n", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_drop_to_bl:\n  \"of_bl (drop n (to_bl x)) = (x AND mask (size x - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (drop n (to_bl x)) = x AND mask (size x - n)", "by (simp add: of_bl_drop word_size_bl)"], ["", "lemma unat_of_bl_length:\n  \"unat (of_bl xs :: 'a::len word) < 2 ^ (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (of_bl xs) < 2 ^ length xs", "proof (cases \"length xs < LENGTH('a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs < LENGTH('a) \\<Longrightarrow> unat (of_bl xs) < 2 ^ length xs\n 2. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "case True"], ["proof (state)\nthis:\n  length xs < LENGTH('a)\n\ngoal (2 subgoals):\n 1. length xs < LENGTH('a) \\<Longrightarrow> unat (of_bl xs) < 2 ^ length xs\n 2. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "then"], ["proof (chain)\npicking this:\n  length xs < LENGTH('a)", "have \"(of_bl xs::'a::len word) < 2 ^ length xs\""], ["proof (prove)\nusing this:\n  length xs < LENGTH('a)\n\ngoal (1 subgoal):\n 1. of_bl xs < 2 ^ length xs", "by (simp add: of_bl_length_less)"], ["proof (state)\nthis:\n  of_bl xs < 2 ^ length xs\n\ngoal (2 subgoals):\n 1. length xs < LENGTH('a) \\<Longrightarrow> unat (of_bl xs) < 2 ^ length xs\n 2. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "with True"], ["proof (chain)\npicking this:\n  length xs < LENGTH('a)\n  of_bl xs < 2 ^ length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  length xs < LENGTH('a)\n  of_bl xs < 2 ^ length xs\n\ngoal (1 subgoal):\n 1. unat (of_bl xs) < 2 ^ length xs", "by (simp add: word_less_nat_alt unat_of_nat)"], ["proof (state)\nthis:\n  unat (of_bl xs) < 2 ^ length xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "case False"], ["proof (state)\nthis:\n  \\<not> length xs < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "have \"unat (of_bl xs::'a::len word) < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (of_bl xs) < 2 ^ LENGTH('a)", "by (simp split: unat_split)"], ["proof (state)\nthis:\n  unat (of_bl xs) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "also"], ["proof (state)\nthis:\n  unat (of_bl xs) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "from False"], ["proof (chain)\npicking this:\n  \\<not> length xs < LENGTH('a)", "have \"LENGTH('a) \\<le> length xs\""], ["proof (prove)\nusing this:\n  \\<not> length xs < LENGTH('a)\n\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> length xs", "by simp"], ["proof (state)\nthis:\n  LENGTH('a) \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "then"], ["proof (chain)\npicking this:\n  LENGTH('a) \\<le> length xs", "have \"2 ^ LENGTH('a) \\<le> (2::nat) ^ length xs\""], ["proof (prove)\nusing this:\n  LENGTH('a) \\<le> length xs\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('a) \\<le> 2 ^ length xs", "by (rule power_increasing) simp"], ["proof (state)\nthis:\n  2 ^ LENGTH('a) \\<le> 2 ^ length xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs < LENGTH('a) \\<Longrightarrow>\n    unat (of_bl xs) < 2 ^ length xs", "finally"], ["proof (chain)\npicking this:\n  unat (of_bl xs) < 2 ^ length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  unat (of_bl xs) < 2 ^ length xs\n\ngoal (1 subgoal):\n 1. unat (of_bl xs) < 2 ^ length xs", "."], ["proof (state)\nthis:\n  unat (of_bl xs) < 2 ^ length xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_msb_alt: \"msb w \\<longleftrightarrow> hd (to_bl w)\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb w = hd (to_bl w)", "apply (simp add: msb_word_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit w (LENGTH('a) - Suc 0) = hd (to_bl w)", "apply (subst hd_conv_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. to_bl w \\<noteq> []\n 2. bit w (LENGTH('a) - Suc 0) = to_bl w ! 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit w (LENGTH('a) - Suc 0) = to_bl w ! 0", "apply (subst nth_to_bl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < LENGTH('a)\n 2. bit w (LENGTH('a) - Suc 0) = bit w (LENGTH('a) - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit w (LENGTH('a) - Suc 0) = bit w (LENGTH('a) - Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_lsb_last:\n  \\<open>lsb w \\<longleftrightarrow> last (to_bl w)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb w = last (to_bl w)", "using nth_to_bl [of \\<open>LENGTH('a) - Suc 0\\<close> w]"], ["proof (prove)\nusing this:\n  LENGTH('a) - Suc 0 < LENGTH('a) \\<Longrightarrow>\n  to_bl w ! (LENGTH('a) - Suc 0) =\n  bit w (LENGTH('a) - Suc (LENGTH('a) - Suc 0))\n\ngoal (1 subgoal):\n 1. lsb w = last (to_bl w)", "by (simp add: lsb_odd last_conv_nth)"], ["", "lemma is_aligned_to_bl:\n  \"is_aligned (w :: 'a :: len word) n = (True \\<notin> set (drop (size w - n) (to_bl w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w n = (True \\<notin> set (drop (size w - n) (to_bl w)))", "apply (simp add: is_aligned_mask eq_zero_set_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (True \\<in> set (to_bl (w AND mask n))) =\n    (True \\<in> set (drop (size w - n) (to_bl w)))", "apply (clarsimp simp: in_set_conv_nth word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<LENGTH('a). to_bl (w AND mask n) ! i) =\n    (\\<exists>i<LENGTH('a) - (LENGTH('a) - n).\n        to_bl w ! (LENGTH('a) - n + i))", "apply (simp add: to_bl_nth word_size cong: conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<LENGTH('a).\n        w !! (LENGTH('a) - Suc i) \\<and> LENGTH('a) - Suc i < n) =\n    (\\<exists>i<LENGTH('a) - (LENGTH('a) - n).\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i)))", "apply (simp add: diff_diff_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<LENGTH('a).\n        w !! (LENGTH('a) - Suc i) \\<and> LENGTH('a) - Suc i < n) =\n    (\\<exists>i<LENGTH('a).\n        i < n \\<and> w !! (LENGTH('a) - Suc (LENGTH('a) - n + i)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (case_tac \"n \\<le> LENGTH('a)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; \\<not> n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 3. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; \\<not> n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 3. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; \\<not> n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> i < LENGTH('a) \\<and>\n                         i < n \\<and>\n                         w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 3. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (subgoal_tac \"\\<exists>j < LENGTH('a). j < n \\<and> LENGTH('a) - n + j = i\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a);\n        \\<exists>j<LENGTH('a). j < n \\<and> LENGTH('a) - n + j = i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j<LENGTH('a).\n                            j < n \\<and> LENGTH('a) - n + j = i\n 3. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (erule exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a);\n        j < LENGTH('a) \\<and> j < n \\<and> LENGTH('a) - n + j = i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            i < n \\<and>\n                            w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j<LENGTH('a).\n                            j < n \\<and> LENGTH('a) - n + j = i\n 3. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (rule_tac x=j in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a);\n        j < LENGTH('a) \\<and> j < n \\<and> LENGTH('a) - n + j = i\\<rbrakk>\n       \\<Longrightarrow> j < LENGTH('a) \\<and>\n                         j < n \\<and>\n                         w !! (LENGTH('a) - Suc (LENGTH('a) - n + j))\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j<LENGTH('a).\n                            j < n \\<and> LENGTH('a) - n + j = i\n 3. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); w !! (LENGTH('a) - Suc i);\n        LENGTH('a) - Suc i < n; n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j<LENGTH('a).\n                            j < n \\<and> LENGTH('a) - n + j = i\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (thin_tac \"w !! t\" for t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); LENGTH('a) - Suc i < n;\n        n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j<LENGTH('a).\n                            j < n \\<and> LENGTH('a) - n + j = i\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (rule_tac x=\"i + n - LENGTH('a)\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); LENGTH('a) - Suc i < n;\n        n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> i + n - LENGTH('a) < LENGTH('a) \\<and>\n                         i + n - LENGTH('a) < n \\<and>\n                         LENGTH('a) - n + (i + n - LENGTH('a)) = i\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); LENGTH('a) - Suc i < n;\n        n \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> i + n - LENGTH('a) < LENGTH('a) \\<and>\n                         i + n - LENGTH('a) < n\n 2. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<LENGTH('a).\n                            w !! (LENGTH('a) - Suc i) \\<and>\n                            LENGTH('a) - Suc i < n", "apply (rule_tac x=\"LENGTH('a) - n + i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> LENGTH('a) - n + i < LENGTH('a) \\<and>\n                         w !! (LENGTH('a) - Suc (LENGTH('a) - n + i)) \\<and>\n                         LENGTH('a) - Suc (LENGTH('a) - n + i) < n", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); i < n;\n        w !! (LENGTH('a) - Suc (LENGTH('a) - n + i))\\<rbrakk>\n       \\<Longrightarrow> LENGTH('a) - n + i < LENGTH('a) \\<and>\n                         LENGTH('a) - Suc (LENGTH('a) - n + i) < n", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_replicate:\n  fixes w::\"'a::len word\"\n  assumes aligned: \"is_aligned w n\"\n  and          nv: \"n \\<le> LENGTH('a)\"\n  shows   \"to_bl w = (take (LENGTH('a) - n) (to_bl w)) @ replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False", "from nv"], ["proof (chain)\npicking this:\n  n \\<le> LENGTH('a)", "have rl: \"\\<And>q. q < 2 ^ (LENGTH('a) - n) \\<Longrightarrow>\n      to_bl (2 ^ n * (of_nat q :: 'a word)) =\n      drop n (to_bl (of_nat q :: 'a word)) @ replicate n False\""], ["proof (prove)\nusing this:\n  n \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q < 2 ^ (LENGTH('a) - n) \\<Longrightarrow>\n       to_bl (2 ^ n * word_of_nat q) =\n       drop n (to_bl (word_of_nat q)) @ replicate n False", "by (metis bl_shiftl le_antisym min_def shiftl_t2n wsst_TYs(3))"], ["proof (state)\nthis:\n  ?q < 2 ^ (LENGTH('a) - n) \\<Longrightarrow>\n  to_bl (2 ^ n * word_of_nat ?q) =\n  drop n (to_bl (word_of_nat ?q)) @ replicate n False\n\ngoal (1 subgoal):\n 1. to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False", "using aligned"], ["proof (prove)\nusing this:\n  is_aligned w n\n\ngoal (1 subgoal):\n 1. to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False", "by (auto simp: rl elim: is_alignedE)"], ["proof (state)\nthis:\n  to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_drop:\n  fixes w::\"'a::len word\"\n  assumes \"is_aligned w n\" \"n \\<le> LENGTH('a)\"\n  shows \"drop (LENGTH('a) - n) (to_bl w) = replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "have \"to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False", "by (rule is_aligned_replicate) fact+"], ["proof (state)\nthis:\n  to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False\n\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "then"], ["proof (chain)\npicking this:\n  to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False", "have \"drop (LENGTH('a) - n) (to_bl w) = drop (LENGTH('a) - n) \\<dots>\""], ["proof (prove)\nusing this:\n  to_bl w = take (LENGTH('a) - n) (to_bl w) @ replicate n False\n\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) =\n    drop (LENGTH('a) - n)\n     (take (LENGTH('a) - n) (to_bl w) @ replicate n False)", "by simp"], ["proof (state)\nthis:\n  drop (LENGTH('a) - n) (to_bl w) =\n  drop (LENGTH('a) - n)\n   (take (LENGTH('a) - n) (to_bl w) @ replicate n False)\n\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "also"], ["proof (state)\nthis:\n  drop (LENGTH('a) - n) (to_bl w) =\n  drop (LENGTH('a) - n)\n   (take (LENGTH('a) - n) (to_bl w) @ replicate n False)\n\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "have \"\\<dots> = replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n)\n     (take (LENGTH('a) - n) (to_bl w) @ replicate n False) =\n    replicate n False", "by simp"], ["proof (state)\nthis:\n  drop (LENGTH('a) - n)\n   (take (LENGTH('a) - n) (to_bl w) @ replicate n False) =\n  replicate n False\n\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "finally"], ["proof (chain)\npicking this:\n  drop (LENGTH('a) - n) (to_bl w) = replicate n False", "show ?thesis"], ["proof (prove)\nusing this:\n  drop (LENGTH('a) - n) (to_bl w) = replicate n False\n\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "."], ["proof (state)\nthis:\n  drop (LENGTH('a) - n) (to_bl w) = replicate n False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_is_drop_replicate:\n  fixes x::\"'a::len word\"\n  assumes lt: \"x < 2 ^ n\"\n  shows   \"to_bl x = replicate (LENGTH('a) - n) False @ drop (LENGTH('a) - n) (to_bl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl x =\n    replicate (LENGTH('a) - n) False @ drop (LENGTH('a) - n) (to_bl x)", "by (metis assms bl_and_mask' less_mask_eq)"], ["", "lemma is_aligned_add_conv:\n  fixes off::\"'a::len word\"\n  assumes aligned: \"is_aligned w n\"\n  and        offv: \"off < 2 ^ n\"\n  shows    \"to_bl (w + off) =\n   (take (LENGTH('a) - n) (to_bl w)) @ (drop (LENGTH('a) - n) (to_bl off))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)\n 2. \\<not> ?P \\<Longrightarrow>\n    to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "assume nv: \"n \\<le> LENGTH('a)\""], ["proof (state)\nthis:\n  n \\<le> LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)\n 2. \\<not> ?P \\<Longrightarrow>\n    to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "proof (subst aligned_bl_add_size, simp_all only: word_size)"], ["proof (state)\ngoal (3 subgoals):\n 1. n \\<le> LENGTH('a)\n 2. drop (LENGTH('a) - n) (to_bl w) = replicate n False\n 3. take (LENGTH('a) - n) (to_bl off) = replicate (LENGTH('a) - n) False", "show \"drop (LENGTH('a) - n) (to_bl w) = replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (LENGTH('a) - n) (to_bl w) = replicate n False", "by (subst is_aligned_replicate [OF aligned nv]) (simp add: word_size)"], ["proof (state)\nthis:\n  drop (LENGTH('a) - n) (to_bl w) = replicate n False\n\ngoal (2 subgoals):\n 1. n \\<le> LENGTH('a)\n 2. take (LENGTH('a) - n) (to_bl off) = replicate (LENGTH('a) - n) False", "from offv"], ["proof (chain)\npicking this:\n  off < 2 ^ n", "show \"take (LENGTH('a) - n) (to_bl off) =\n                    replicate (LENGTH('a) - n) False\""], ["proof (prove)\nusing this:\n  off < 2 ^ n\n\ngoal (1 subgoal):\n 1. take (LENGTH('a) - n) (to_bl off) = replicate (LENGTH('a) - n) False", "by (subst less_is_drop_replicate, assumption) simp"], ["proof (state)\nthis:\n  take (LENGTH('a) - n) (to_bl off) = replicate (LENGTH('a) - n) False\n\ngoal (1 subgoal):\n 1. n \\<le> LENGTH('a)", "qed fact"], ["proof (state)\nthis:\n  to_bl (w + off) =\n  take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> LENGTH('a) \\<Longrightarrow>\n    to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> LENGTH('a) \\<Longrightarrow>\n    to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "assume \"\\<not> n \\<le> LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> n \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> LENGTH('a) \\<Longrightarrow>\n    to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "with offv"], ["proof (chain)\npicking this:\n  off < 2 ^ n\n  \\<not> n \\<le> LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  off < 2 ^ n\n  \\<not> n \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. to_bl (w + off) =\n    take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)", "by (simp add: power_overflow)"], ["proof (state)\nthis:\n  to_bl (w + off) =\n  take (LENGTH('a) - n) (to_bl w) @ drop (LENGTH('a) - n) (to_bl off)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_replicateI:\n  \"to_bl p = addr @ replicate n False \\<Longrightarrow> is_aligned (p::'a::len word) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl p = addr @ replicate n False \\<Longrightarrow> is_aligned p n", "apply (simp add: is_aligned_to_bl word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl p = addr @ replicate n False \\<Longrightarrow>\n    True \\<notin> set (drop (LENGTH('a) - n) addr)", "apply (subgoal_tac \"length addr = LENGTH('a) - n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>to_bl p = addr @ replicate n False;\n     length addr = LENGTH('a) - n\\<rbrakk>\n    \\<Longrightarrow> True \\<notin> set (drop (LENGTH('a) - n) addr)\n 2. to_bl p = addr @ replicate n False \\<Longrightarrow>\n    length addr = LENGTH('a) - n", "apply (simp add: replicate_not_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl p = addr @ replicate n False \\<Longrightarrow>\n    length addr = LENGTH('a) - n", "apply (drule arg_cong [where f=length])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (to_bl p) = length (addr @ replicate n False) \\<Longrightarrow>\n    length addr = LENGTH('a) - n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_bl_2p:\n  \"n < LENGTH('a) \\<Longrightarrow>\n   to_bl ((2::'a::len word) ^ n) =\n   replicate (LENGTH('a) - Suc n) False @ True # replicate n False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    to_bl (2 ^ n) =\n    replicate (LENGTH('a) - Suc n) False @ True # replicate n False", "apply (subst shiftl_1 [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    to_bl (1 << n) =\n    replicate (LENGTH('a) - Suc n) False @ True # replicate n False", "apply (subst bl_shiftl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    drop n (to_bl 1) @ replicate (min (size 1) n) False =\n    replicate (LENGTH('a) - Suc n) False @ True # replicate n False", "apply (simp add: to_bl_1 min_def word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma xor_2p_to_bl:\n  fixes x::\"'a::len word\"\n  shows \"to_bl (x XOR 2^n) =\n  (if n < LENGTH('a)\n   then take (LENGTH('a)-Suc n) (to_bl x) @ (\\<not>rev (to_bl x)!n) # drop (LENGTH('a)-n) (to_bl x)\n   else to_bl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (x XOR 2 ^ n) =\n    (if n < LENGTH('a)\n     then take (LENGTH('a) - Suc n) (to_bl x) @\n          (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n     else to_bl x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_bl (x XOR 2 ^ n) =\n    (if n < LENGTH('a)\n     then take (LENGTH('a) - Suc n) (to_bl x) @\n          (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n     else to_bl x)", "have x: \"to_bl x = take (LENGTH('a)-Suc n) (to_bl x) @ drop (LENGTH('a)-Suc n) (to_bl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl x =\n    take (LENGTH('a) - Suc n) (to_bl x) @\n    drop (LENGTH('a) - Suc n) (to_bl x)", "by simp"], ["proof (state)\nthis:\n  to_bl x =\n  take (LENGTH('a) - Suc n) (to_bl x) @ drop (LENGTH('a) - Suc n) (to_bl x)\n\ngoal (1 subgoal):\n 1. to_bl (x XOR 2 ^ n) =\n    (if n < LENGTH('a)\n     then take (LENGTH('a) - Suc n) (to_bl x) @\n          (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n     else to_bl x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (x XOR 2 ^ n) =\n    (if n < LENGTH('a)\n     then take (LENGTH('a) - Suc n) (to_bl x) @\n          (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n     else to_bl x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < LENGTH('a) \\<longrightarrow>\n     to_bl (x XOR 2 ^ n) =\n     take (LENGTH('a) - Suc n) (to_bl x) @\n     (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)) \\<and>\n    (\\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < LENGTH('a) \\<longrightarrow>\n    to_bl (x XOR 2 ^ n) =\n    take (LENGTH('a) - Suc n) (to_bl x) @\n    (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n 2. \\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x", "apply (clarsimp simp: word_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    to_bl (x XOR 2 ^ n) =\n    take (LENGTH('a) - Suc n) (to_bl x) @\n    (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n 2. \\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x", "apply (simp add: bl_word_xor to_bl_2p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    map2 (\\<lambda>x y. x = (\\<not> y)) (to_bl x)\n     (replicate (LENGTH('a) - Suc n) False @ True # replicate n False) =\n    take (LENGTH('a) - Suc n) (to_bl x) @\n    (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n 2. \\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x", "apply (subst x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    map2 (\\<lambda>x y. x = (\\<not> y))\n     (take (LENGTH('a) - Suc n) (to_bl x) @\n      drop (LENGTH('a) - Suc n) (to_bl x))\n     (replicate (LENGTH('a) - Suc n) False @ True # replicate n False) =\n    take (LENGTH('a) - Suc n) (to_bl x) @\n    (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n 2. \\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x", "apply (subst zip_append)"], ["proof (prove)\ngoal (3 subgoals):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    length (take (LENGTH('a) - Suc n) (to_bl x)) =\n    length (replicate (LENGTH('a) - Suc n) False)\n 2. n < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>(x, y). x = (\\<not> y))\n     (zip (take (LENGTH('a) - Suc n) (to_bl x))\n       (replicate (LENGTH('a) - Suc n) False) @\n      zip (drop (LENGTH('a) - Suc n) (to_bl x))\n       (True # replicate n False)) =\n    take (LENGTH('a) - Suc n) (to_bl x) @\n    (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n 3. \\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>(x, y). x = (\\<not> y))\n     (zip (take (LENGTH('a) - Suc n) (to_bl x))\n       (replicate (LENGTH('a) - Suc n) False) @\n      zip (drop (LENGTH('a) - Suc n) (to_bl x))\n       (True # replicate n False)) =\n    take (LENGTH('a) - Suc n) (to_bl x) @\n    (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n 2. \\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x", "apply (simp add: map_zip_replicate_False_xor drop_minus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < LENGTH('a) \\<longrightarrow> x XOR 2 ^ n = x", "apply (auto simp add: word_size nth_w2p intro!: word_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  to_bl (x XOR 2 ^ n) =\n  (if n < LENGTH('a)\n   then take (LENGTH('a) - Suc n) (to_bl x) @\n        (\\<not> rev (to_bl x) ! n) # drop (LENGTH('a) - n) (to_bl x)\n   else to_bl x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_replicateD:\n  \"\\<lbrakk> is_aligned (w::'a::len word) n; n \\<le> LENGTH('a) \\<rbrakk>\n     \\<Longrightarrow> \\<exists>xs. to_bl w = xs @ replicate n False\n               \\<and> length xs = size w - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned w n; n \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         to_bl w = xs @ replicate n False \\<and>\n                         length xs = size w - n", "apply (subst is_aligned_replicate, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned w n; n \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         take (LENGTH('a) - n) (to_bl w) @\n                         replicate n False =\n                         xs @ replicate n False \\<and>\n                         length xs = size w - n", "apply (rule exI, rule conjI, rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned w n; n \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> length (take (LENGTH('a) - n) (to_bl w)) = size w - n", "apply (simp add: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>right-padding a word to a certain length\\<close>"], ["", "definition\n  \"bl_pad_to bl sz \\<equiv> bl @ (replicate (sz - length bl) False)\""], ["", "lemma bl_pad_to_length:\n  assumes lbl: \"length bl \\<le> sz\"\n  shows   \"length (bl_pad_to bl sz) = sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bl_pad_to bl sz) = sz", "using lbl"], ["proof (prove)\nusing this:\n  length bl \\<le> sz\n\ngoal (1 subgoal):\n 1. length (bl_pad_to bl sz) = sz", "by (simp add: bl_pad_to_def)"], ["", "lemma bl_pad_to_prefix:\n  \"prefix bl (bl_pad_to bl sz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix bl (bl_pad_to bl sz)", "by (simp add: bl_pad_to_def)"], ["", "lemma of_bl_length:\n  \"length xs < LENGTH('a) \\<Longrightarrow> of_bl xs < (2 :: 'a::len word) ^ length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs < LENGTH('a) \\<Longrightarrow> of_bl xs < 2 ^ length xs", "by (simp add: of_bl_length_less)"], ["", "lemma of_bl_mult_and_not_mask_eq:\n  \"\\<lbrakk>is_aligned (a :: 'a::len word) n; length b + m \\<le> n\\<rbrakk>\n   \\<Longrightarrow> a + of_bl b * (2^m) AND NOT(mask n) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; length b + m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> a + of_bl b * 2 ^ m AND NOT (mask n) = a", "apply (simp flip: push_bit_eq_mult subtract_mask(1) take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; length b + m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> push_bit m (of_bl b) =\n                      take_bit n (a + push_bit m (of_bl b))", "apply (subst disjunctive_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned a n; length b + m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit a na \\<or>\n                         \\<not> bit (push_bit m (of_bl b)) na\n 2. \\<lbrakk>is_aligned a n; length b + m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> push_bit m (of_bl b) =\n                      take_bit n (a OR push_bit m (of_bl b))", "apply (auto simp add: bit_simps not_le not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned a n; length b + m \\<le> n; rev b ! (na - m);\n        bit a na; m \\<le> na; na < LENGTH('a); na - m < length b\\<rbrakk>\n       \\<Longrightarrow> LENGTH('a) \\<le> na - m\n 2. \\<lbrakk>is_aligned a n; length b + m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> push_bit m (of_bl b) =\n                      take_bit n a OR take_bit n (push_bit m (of_bl b))", "apply (meson is_aligned_imp_not_bit is_aligned_weaken less_diff_conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; length b + m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> push_bit m (of_bl b) =\n                      take_bit n a OR take_bit n (push_bit m (of_bl b))", "apply (erule is_alignedE')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>length b + m \\<le> n; a = push_bit n (word_of_nat q);\n        q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n       \\<Longrightarrow> push_bit m (of_bl b) =\n                         take_bit n a OR take_bit n (push_bit m (of_bl b))", "apply (simp add: take_bit_push_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>length b + m \\<le> n; a = push_bit n (word_of_nat q);\n        q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n       \\<Longrightarrow> push_bit m (of_bl b) =\n                         push_bit m (take_bit (n - m) (of_bl b))", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q na.\n       \\<lbrakk>length b + m \\<le> n; a = push_bit n (word_of_nat q);\n        q < 2 ^ (LENGTH('a) - n); na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (push_bit m (of_bl b)) na =\n                         bit (push_bit m (take_bit (n - m) (of_bl b))) na", "apply (auto simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_to_bl_of_bl_eq:\n  \"\\<lbrakk>is_aligned (a::'a::len word) n; length b + c \\<le> n; length b + c < LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> bin_to_bl (length b) (uint ((a + of_bl b * 2^c) >> c)) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; length b + c \\<le> n;\n     length b + c < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bin_to_bl (length b)\n                       (uint (a + of_bl b * 2 ^ c >> c)) =\n                      b", "apply (simp flip: push_bit_eq_mult take_bit_eq_mask add: shiftr_eq_drop_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; length b + c \\<le> n;\n     length b + c < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bin_to_bl_aux (length b)\n                       (uint (drop_bit c (a + push_bit c (of_bl b)))) [] =\n                      b", "apply (subst disjunctive_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned a n; length b + c \\<le> n;\n        length b + c < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit a na \\<or>\n                         \\<not> bit (push_bit c (of_bl b)) na\n 2. \\<lbrakk>is_aligned a n; length b + c \\<le> n;\n     length b + c < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> bin_to_bl_aux (length b)\n                       (uint (drop_bit c (a OR push_bit c (of_bl b)))) [] =\n                      b", "apply (auto simp add: bit_simps not_le not_less unsigned_or_eq unsigned_drop_bit_eq\n     unsigned_push_bit_eq bin_to_bl_or simp flip: bin_to_bl_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned a n; length b + c \\<le> n;\n        length b + c < LENGTH('a); rev b ! (na - c); bit a na; c \\<le> na;\n        na < LENGTH('a); na - c < length b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned a n; length b + c \\<le> n;\n     length b + c < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> map2 (\\<or>)\n                       (bin_to_bl (length b) (drop_bit c (uint a)))\n                       (bin_to_bl (length b)\n                         (drop_bit c\n                           (take_bit LENGTH('a)\n                             (push_bit c (uint (of_bl b)))))) =\n                      b", "apply (meson is_aligned_imp_not_bit is_aligned_weaken less_diff_conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; length b + c \\<le> n;\n     length b + c < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> map2 (\\<or>)\n                       (bin_to_bl (length b) (drop_bit c (uint a)))\n                       (bin_to_bl (length b)\n                         (drop_bit c\n                           (take_bit LENGTH('a)\n                             (push_bit c (uint (of_bl b)))))) =\n                      b", "apply (erule is_alignedE')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>length b + c \\<le> n; length b + c < LENGTH('a);\n        a = push_bit n (word_of_nat q); q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n       \\<Longrightarrow> map2 (\\<or>)\n                          (bin_to_bl (length b) (drop_bit c (uint a)))\n                          (bin_to_bl (length b)\n                            (drop_bit c\n                              (take_bit LENGTH('a)\n                                (push_bit c (uint (of_bl b)))))) =\n                         b", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>length b + c \\<le> n; length b + c < LENGTH('a);\n        a = push_bit n (word_of_nat q); q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (map2 (\\<or>)\n                            (bin_to_bl (length b) (drop_bit c (uint a)))\n                            (bin_to_bl (length b)\n                              (drop_bit c\n                                (take_bit LENGTH('a)\n                                  (push_bit c (uint (of_bl b))))))) =\n                         length b\n 2. \\<And>q i.\n       \\<lbrakk>length b + c \\<le> n; length b + c < LENGTH('a);\n        a = push_bit n (word_of_nat q); q < 2 ^ (LENGTH('a) - n);\n        i < length\n             (map2 (\\<or>) (bin_to_bl (length b) (drop_bit c (uint a)))\n               (bin_to_bl (length b)\n                 (drop_bit c\n                   (take_bit LENGTH('a)\n                     (push_bit c (uint (of_bl b)))))))\\<rbrakk>\n       \\<Longrightarrow> map2 (\\<or>)\n                          (bin_to_bl (length b) (drop_bit c (uint a)))\n                          (bin_to_bl (length b)\n                            (drop_bit c\n                              (take_bit LENGTH('a)\n                                (push_bit c (uint (of_bl b)))))) !\n                         i =\n                         b ! i", "apply (auto simp add: nth_bin_to_bl bit_simps rev_nth simp flip: bin_to_bl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* FIXME: move to Word distribution *)"], ["", "lemma bin_nth_minus_Bit0[simp]:\n  \"0 < n \\<Longrightarrow> bin_nth (numeral (num.Bit0 w)) n = bin_nth (numeral w) (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bit (numeral (num.Bit0 w)) n = bit (numeral w) (n - 1)", "by (cases n; simp)"], ["", "lemma bin_nth_minus_Bit1[simp]:\n  \"0 < n \\<Longrightarrow> bin_nth (numeral (num.Bit1 w)) n = bin_nth (numeral w) (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bit (numeral (num.Bit1 w)) n = bit (numeral w) (n - 1)", "by (cases n; simp)"], ["", "(* casting a long word to a shorter word and casting back to the long word\n   is equal to the original long word -- if the word is small enough.\n  'l is the longer word.\n  's is the shorter word.\n*)"], ["", "lemma bl_cast_long_short_long_ingoreLeadingZero_generic:\n  \"\\<lbrakk> length (dropWhile Not (to_bl w)) \\<le> LENGTH('s); LENGTH('s) \\<le> LENGTH('l) \\<rbrakk> \\<Longrightarrow>\n   (of_bl :: _ \\<Rightarrow> 'l::len word) (to_bl ((of_bl::_ \\<Rightarrow> 's::len word) (to_bl w))) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (dropWhile Not (to_bl w)) \\<le> LENGTH('s);\n     LENGTH('s) \\<le> LENGTH('l)\\<rbrakk>\n    \\<Longrightarrow> of_bl (to_bl (of_bl (to_bl w))) = w", "by (rule word_uint_eqI) (simp add: uint_of_bl_is_bl_to_bin uint_of_bl_is_bl_to_bin_drop)"], ["", "(*\n Casting between longer and shorter word.\n  'l is the longer word.\n  's is the shorter word.\n For example: 'l::len word is 128 word (full ipv6 address)\n              's::len word is 16 word (address piece of ipv6 address in colon-text-representation)\n*)"], ["", "corollary ucast_short_ucast_long_ingoreLeadingZero:\n  \"\\<lbrakk> length (dropWhile Not (to_bl w)) \\<le> LENGTH('s); LENGTH('s) \\<le> LENGTH('l) \\<rbrakk> \\<Longrightarrow>\n   (ucast:: 's::len word \\<Rightarrow> 'l::len word) ((ucast:: 'l::len word \\<Rightarrow> 's::len word) w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (dropWhile Not (to_bl w)) \\<le> LENGTH('s);\n     LENGTH('s) \\<le> LENGTH('l)\\<rbrakk>\n    \\<Longrightarrow> ucast (ucast w) = w", "apply (subst ucast_bl)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (dropWhile Not (to_bl w)) \\<le> LENGTH('s);\n     LENGTH('s) \\<le> LENGTH('l)\\<rbrakk>\n    \\<Longrightarrow> of_bl (to_bl (of_bl (to_bl w))) = w", "apply (rule bl_cast_long_short_long_ingoreLeadingZero_generic; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_drop_mask:\n  fixes w::\"'a::len word\"\n  shows \"length (dropWhile Not (to_bl (w AND mask n))) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dropWhile Not (to_bl (w AND mask n))) \\<le> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (dropWhile Not (to_bl (w AND mask n))) \\<le> n", "have \"length (takeWhile Not (replicate n False @ ls)) = n + length (takeWhile Not ls)\"\n    for ls n"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile Not (replicate n False @ ls)) =\n    n + length (takeWhile Not ls)", "by(subst takeWhile_append2) simp+"], ["proof (state)\nthis:\n  length (takeWhile Not (replicate ?n False @ ?ls)) =\n  ?n + length (takeWhile Not ?ls)\n\ngoal (1 subgoal):\n 1. length (dropWhile Not (to_bl (w AND mask n))) \\<le> n", "then"], ["proof (chain)\npicking this:\n  length (takeWhile Not (replicate ?n False @ ?ls)) =\n  ?n + length (takeWhile Not ?ls)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (takeWhile Not (replicate ?n False @ ?ls)) =\n  ?n + length (takeWhile Not ?ls)\n\ngoal (1 subgoal):\n 1. length (dropWhile Not (to_bl (w AND mask n))) \\<le> n", "unfolding bl_and_mask"], ["proof (prove)\nusing this:\n  length (takeWhile Not (replicate ?n False @ ?ls)) =\n  ?n + length (takeWhile Not ?ls)\n\ngoal (1 subgoal):\n 1. length\n     (dropWhile Not\n       (replicate (LENGTH('a) - n) False @ drop (LENGTH('a) - n) (to_bl w)))\n    \\<le> n", "by (simp add: dropWhile_eq_drop)"], ["proof (state)\nthis:\n  length (dropWhile Not (to_bl (w AND mask n))) \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_bits_rev_to_bl:\n  \"map ((!!) x) [0..<size x] = rev (to_bl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!!) x) [0..<size x] = rev (to_bl x)", "by (auto simp: list_eq_iff_nth_eq test_bit_bl word_size)"], ["", "lemma of_bl_length2:\n  \"length xs + c < LENGTH('a) \\<Longrightarrow> of_bl xs * 2^c < (2::'a::len word) ^ (length xs + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs + c < LENGTH('a) \\<Longrightarrow>\n    of_bl xs * 2 ^ c < 2 ^ (length xs + c)", "by (simp add: of_bl_length word_less_power_trans2)"], ["", "lemma of_bl_max:\n  \"(of_bl xs :: 'a::len word) \\<le> mask (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl xs \\<le> mask (length xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_bl xs \\<le> mask (length xs)", "define ys where \\<open>ys = rev xs\\<close>"], ["proof (state)\nthis:\n  ys = rev xs\n\ngoal (1 subgoal):\n 1. of_bl xs \\<le> mask (length xs)", "have \\<open>take_bit (length ys) (horner_sum of_bool 2 ys :: 'a word) = horner_sum of_bool 2 ys\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit (length ys) (horner_sum of_bool 2 ys) = horner_sum of_bool 2 ys", "by transfer (simp add: take_bit_horner_sum_bit_eq min_def)"], ["proof (state)\nthis:\n  take_bit (length ys) (horner_sum of_bool 2 ys) = horner_sum of_bool 2 ys\n\ngoal (1 subgoal):\n 1. of_bl xs \\<le> mask (length xs)", "then"], ["proof (chain)\npicking this:\n  take_bit (length ys) (horner_sum of_bool 2 ys) = horner_sum of_bool 2 ys", "have \\<open>(of_bl (rev ys) :: 'a word) \\<le> mask (length ys)\\<close>"], ["proof (prove)\nusing this:\n  take_bit (length ys) (horner_sum of_bool 2 ys) = horner_sum of_bool 2 ys\n\ngoal (1 subgoal):\n 1. of_bl (rev ys) \\<le> mask (length ys)", "by (simp only: of_bl_rev_eq less_eq_mask_iff_take_bit_eq_self)"], ["proof (state)\nthis:\n  of_bl (rev ys) \\<le> mask (length ys)\n\ngoal (1 subgoal):\n 1. of_bl xs \\<le> mask (length xs)", "with ys_def"], ["proof (chain)\npicking this:\n  ys = rev xs\n  of_bl (rev ys) \\<le> mask (length ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = rev xs\n  of_bl (rev ys) \\<le> mask (length ys)\n\ngoal (1 subgoal):\n 1. of_bl xs \\<le> mask (length xs)", "by simp"], ["proof (state)\nthis:\n  of_bl xs \\<le> mask (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}