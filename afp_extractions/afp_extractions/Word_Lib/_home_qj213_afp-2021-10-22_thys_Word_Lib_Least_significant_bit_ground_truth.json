{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Least_significant_bit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma bin_last_conv_lsb: \"bin_last = lsb\"", "lemma int_lsb_numeral [simp]:\n  \"lsb (0 :: int) = False\"\n  \"lsb (1 :: int) = True\"\n  \"lsb (Numeral1 :: int) = True\"\n  \"lsb (- 1 :: int) = True\"\n  \"lsb (- Numeral1 :: int) = True\"\n  \"lsb (numeral (num.Bit0 w) :: int) = False\"\n  \"lsb (numeral (num.Bit1 w) :: int) = True\"\n  \"lsb (- numeral (num.Bit0 w) :: int) = False\"\n  \"lsb (- numeral (num.Bit1 w) :: int) = True\"", "lemma lsb_word_eq:\n  \\<open>lsb = (odd :: 'a word \\<Rightarrow> bool)\\<close> for w :: \\<open>'a::len word\\<close>", "lemma word_lsb_alt: \"lsb w = test_bit w 0\"\n  for w :: \"'a::len word\"", "lemma word_lsb_1_0 [simp]: \"lsb (1::'a::len word) \\<and> \\<not> lsb (0::'b::len word)\"", "lemma word_lsb_int: \"lsb w \\<longleftrightarrow> uint w mod 2 = 1\"", "lemmas word_ops_lsb = lsb0 [unfolded word_lsb_alt]", "lemma word_lsb_numeral [simp]:\n  \"lsb (numeral bin :: 'a::len word) \\<longleftrightarrow> bin_last (numeral bin)\"", "lemma word_lsb_neg_numeral [simp]:\n  \"lsb (- numeral bin :: 'a::len word) \\<longleftrightarrow> bin_last (- numeral bin)\"", "lemma word_lsb_nat:\"lsb w = (unat w mod 2 = 1)\""], "translations": [["", "lemma bin_last_conv_lsb: \"bin_last = lsb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd = lsb", "by (simp add: lsb_odd)"], ["", "lemma int_lsb_numeral [simp]:\n  \"lsb (0 :: int) = False\"\n  \"lsb (1 :: int) = True\"\n  \"lsb (Numeral1 :: int) = True\"\n  \"lsb (- 1 :: int) = True\"\n  \"lsb (- Numeral1 :: int) = True\"\n  \"lsb (numeral (num.Bit0 w) :: int) = False\"\n  \"lsb (numeral (num.Bit1 w) :: int) = True\"\n  \"lsb (- numeral (num.Bit0 w) :: int) = False\"\n  \"lsb (- numeral (num.Bit1 w) :: int) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((lsb 0 = False &&& lsb 1 = True) &&&\n     lsb Numeral1 = True &&& lsb (- 1) = True) &&&\n    (lsb (- Numeral1) = True &&& lsb (numeral (num.Bit0 w)) = False) &&&\n    lsb (numeral (num.Bit1 w)) = True &&&\n    lsb (- numeral (num.Bit0 w)) = False &&&\n    lsb (- numeral (num.Bit1 w)) = True", "by (simp_all add: lsb_int_def)"], ["", "instantiation word :: (len) lsb\nbegin"], ["", "definition lsb_word :: \\<open>'a word \\<Rightarrow> bool\\<close>\n  where word_lsb_def: \\<open>lsb a \\<longleftrightarrow> odd (uint a)\\<close> for a :: \\<open>'a word\\<close>"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a word, lsb_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb = odd", "apply (simp add: fun_eq_iff word_lsb_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. even (uint x) = even x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. even (take_bit LENGTH('a) x) = even x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma lsb_word_eq:\n  \\<open>lsb = (odd :: 'a word \\<Rightarrow> bool)\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb = odd", "by (fact lsb_odd)"], ["", "lemma word_lsb_alt: \"lsb w = test_bit w 0\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb w = w !! 0", "by (auto simp: word_test_bit_def word_lsb_def)"], ["", "lemma word_lsb_1_0 [simp]: \"lsb (1::'a::len word) \\<and> \\<not> lsb (0::'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb 1 \\<and> \\<not> lsb 0", "unfolding word_lsb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (uint 1) \\<and> \\<not> odd (uint 0)", "by simp"], ["", "lemma word_lsb_int: \"lsb w \\<longleftrightarrow> uint w mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb w = (uint w mod 2 = 1)", "apply (simp add: lsb_odd flip: odd_iff_mod_2_eq_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. even w = even (uint w)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w. even w = even (take_bit LENGTH('a) w)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_ops_lsb = lsb0 [unfolded word_lsb_alt]"], ["", "lemma word_lsb_numeral [simp]:\n  \"lsb (numeral bin :: 'a::len word) \\<longleftrightarrow> bin_last (numeral bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb (numeral bin) = odd (numeral bin)", "unfolding word_lsb_alt test_bit_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < LENGTH('a) \\<and> bit (numeral bin) 0) = odd (numeral bin)", "by simp"], ["", "lemma word_lsb_neg_numeral [simp]:\n  \"lsb (- numeral bin :: 'a::len word) \\<longleftrightarrow> bin_last (- numeral bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb (- numeral bin) = odd (- numeral bin)", "by (simp add: word_lsb_alt)"], ["", "lemma word_lsb_nat:\"lsb w = (unat w mod 2 = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb w = (unat w mod 2 = 1)", "apply (simp add: word_lsb_def Groebner_Basis.algebra(31))"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (uint w) = even (unat w)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       even (take_bit LENGTH('a) w) =\n       even ((nat \\<circ> take_bit LENGTH('a)) w)", "apply (simp add: even_nat_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}