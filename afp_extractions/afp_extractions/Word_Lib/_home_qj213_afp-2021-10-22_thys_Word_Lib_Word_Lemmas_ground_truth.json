{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Word_Lemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma bitfield_op_twice:\n  \"(x AND NOT (mask n << m) OR ((y AND mask n) << m)) AND NOT (mask n << m) = x AND NOT (mask n << m)\"\n  for x :: \\<open>'a::len word\\<close>", "lemma bitfield_op_twice'':\n  \"\\<lbrakk>NOT a = b << c; \\<exists>x. b = mask x\\<rbrakk> \\<Longrightarrow> (x AND a OR (y AND b << c)) AND a = x AND a\"\n  for a b :: \\<open>'a::len word\\<close>", "lemma bit_twiddle_min:\n  \"(y::'a::len word) XOR (((x::'a::len word) XOR y) AND (if x < y then -1 else 0)) = min x y\"", "lemma bit_twiddle_max:\n  \"(x::'a::len word) XOR (((x::'a::len word) XOR y) AND (if x < y then -1 else 0)) = max x y\"", "lemma swap_with_xor:\n  \"\\<lbrakk>(x::'a::len word) = a XOR b; y = b XOR x; z = x XOR y\\<rbrakk> \\<Longrightarrow> z = b \\<and> y = a\"", "lemma scast_nop1 [simp]:\n  \"((scast ((of_int x)::('a::len) word))::'a sword) = of_int x\"", "lemma scast_nop2 [simp]:\n  \"((scast ((of_int x)::('a::len) sword))::'a word) = of_int x\"", "lemmas scast_nop = scast_nop1 scast_nop2 scast_id", "lemma le_mask_imp_and_mask:\n  \"(x::'a::len word) \\<le> mask n \\<Longrightarrow> x AND mask n = x\"", "lemma or_not_mask_nop:\n  \"((x::'a::len word) OR NOT (mask n)) AND mask n = x AND mask n\"", "lemma mask_subsume:\n  \"\\<lbrakk>n \\<le> m\\<rbrakk> \\<Longrightarrow> ((x::'a::len word) OR y AND mask n) AND NOT (mask m) = x AND NOT (mask m)\"", "lemma and_mask_0_iff_le_mask:\n  fixes w :: \"'a::len word\"\n  shows \"(w AND NOT(mask n) = 0) = (w \\<le> mask n)\"", "lemma mask_twice2:\n  \"n \\<le> m \\<Longrightarrow> ((x::'a::len word) AND mask m) AND mask n = x AND mask n\"", "lemma uint_2_id:\n  \"LENGTH('a) \\<ge> 2 \\<Longrightarrow> uint (2::('a::len) word) = 2\"", "lemma bintrunc_id:\n  \"\\<lbrakk>m \\<le> of_nat n; 0 < m\\<rbrakk> \\<Longrightarrow> bintrunc n m = m\"", "lemma shiftr1_unfold: \"shiftr1 x = x >> 1\"", "lemma shiftr1_is_div_2: \"(x::('a::len) word) >> 1 = x div 2\"", "lemma shiftl1_is_mult: \"(x << 1) = (x :: 'a::len word) * 2\"", "lemma div_of_0_id[simp]:\"(0::('a::len) word) div n = 0\"", "lemma degenerate_word:\"LENGTH('a) = 1 \\<Longrightarrow> (x::('a::len) word) = 0 \\<or> x = 1\"", "lemma div_by_0_word:\"(x::('a::len) word) div 0 = 0\"", "lemma div_less_dividend_word:\"\\<lbrakk>x \\<noteq> 0; n \\<noteq> 1\\<rbrakk> \\<Longrightarrow> (x::('a::len) word) div n < x\"", "lemma shiftr1_lt:\"x \\<noteq> 0 \\<Longrightarrow> (x::('a::len) word) >> 1 < x\"", "lemma word_less_div:\n  fixes x :: \"('a::len) word\"\n    and y :: \"('a::len) word\"\n  shows \"x div y = 0 \\<Longrightarrow> y = 0 \\<or> x < y\"", "lemma not_degenerate_imp_2_neq_0:\"LENGTH('a) > 1 \\<Longrightarrow> (2::('a::len) word) \\<noteq> 0\"", "lemma shiftr1_0_or_1:\"(x::('a::len) word) >> 1 = 0 \\<Longrightarrow> x = 0 \\<or> x = 1\"", "lemma word_overflow:\"(x::('a::len) word) + 1 > x \\<or> x + 1 = 0\"", "lemma word_overflow_unat:\"unat ((x::('a::len) word) + 1) = unat x + 1 \\<or> x + 1 = 0\"", "lemma even_word_imp_odd_next:\"even (unat (x::('a::len) word)) \\<Longrightarrow> x + 1 = 0 \\<or> odd (unat (x + 1))\"", "lemma odd_word_imp_even_next:\"odd (unat (x::('a::len) word)) \\<Longrightarrow> x + 1 = 0 \\<or> even (unat (x + 1))\"", "lemma overflow_imp_lsb:\"(x::('a::len) word) + 1 = 0 \\<Longrightarrow> x !! 0\"", "lemma odd_iff_lsb:\"odd (unat (x::('a::len) word)) = x !! 0\"", "lemma of_nat_neq_iff_word:\n      \"x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a) \\<Longrightarrow>\n         (((of_nat x)::('a::len) word) \\<noteq> of_nat y) = (x \\<noteq> y)\"", "lemma shiftr1_irrelevant_lsb:\"(x::('a::len) word) !! 0 \\<or> x >> 1 = (x + 1) >> 1\"", "lemma shiftr1_0_imp_only_lsb:\"((x::('a::len) word) + 1) >> 1 = 0 \\<Longrightarrow> x = 0 \\<or> x + 1 = 0\"", "lemma shiftr1_irrelevant_lsb':\"\\<not>((x::('a::len) word) !! 0) \\<Longrightarrow> x >> 1 = (x + 1) >> 1\"", "lemma lsb_this_or_next:\"\\<not>(((x::('a::len) word) + 1) !! 0) \\<Longrightarrow> x !! 0\"", "lemma cast_chunk_assemble_id:\n  \"\\<lbrakk>n = LENGTH('a::len); m = LENGTH('b::len); n * 2 = m\\<rbrakk> \\<Longrightarrow>\n  (((ucast ((ucast (x::'b word))::'a word))::'b word) OR (((ucast ((ucast (x >> n))::'a word))::'b word) << n)) = x\"", "lemma cast_chunk_scast_assemble_id:\n  \"\\<lbrakk>n = LENGTH('a::len); m = LENGTH('b::len); n * 2 = m\\<rbrakk> \\<Longrightarrow>\n  (((ucast ((scast (x::'b word))::'a word))::'b word) OR\n   (((ucast ((scast (x >> n))::'a word))::'b word) << n)) = x\"", "lemma mask_or_not_mask:\n  \"x AND mask n OR x AND NOT (mask n) = x\"\n  for x :: \\<open>'a::len word\\<close>", "lemma is_aligned_add_not_aligned:\n  \"\\<lbrakk>is_aligned (p::'a::len word) n; \\<not> is_aligned (q::'a::len word) n\\<rbrakk> \\<Longrightarrow> \\<not> is_aligned (p + q) n\"", "lemma word_gr0_conv_Suc: \"(m::'a::len word) > 0 \\<Longrightarrow> \\<exists>n. m = n + 1\"", "lemma neg_mask_add_aligned:\n  \"\\<lbrakk> is_aligned p n; q < 2 ^ n \\<rbrakk> \\<Longrightarrow> (p + q) AND NOT (mask n) = p AND NOT (mask n)\"", "lemma word_sless_sint_le:\"x <s y \\<Longrightarrow> sint x \\<le> sint y - 1\"", "lemma upper_trivial:\n  fixes x :: \"'a::len word\"\n  shows \"x \\<noteq> 2 ^ LENGTH('a) - 1 \\<Longrightarrow> x < 2 ^ LENGTH('a) - 1\"", "lemma constraint_expand:\n  fixes x :: \"'a::len word\"\n  shows \"x \\<in> {y. lower \\<le> y \\<and> y \\<le> upper} = (lower \\<le> x \\<and> x \\<le> upper)\"", "lemma card_map_elide:\n  \"card ((of_nat :: nat \\<Rightarrow> 'a::len word) ` {0..<n}) = card {0..<n}\"\n    if \"n \\<le> CARD('a::len word)\"", "lemma card_map_elide2:\n  \"n \\<le> CARD('a::len word) \\<Longrightarrow> card ((of_nat::nat \\<Rightarrow> 'a::len word) ` {0..<n}) = n\"", "lemma le_max_word_ucast_id:\n  \\<open>UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x\\<close>\n    if \\<open>x \\<le> UCAST('b::len \\<rightarrow> 'a) (- 1)\\<close>\n    for x :: \\<open>'a::len word\\<close>", "lemma remdups_enum_upto:\n  fixes s::\"'a::len word\"\n  shows \"remdups [s .e. e] = [s .e. e]\"", "lemma card_enum_upto:\n  fixes s::\"'a::len word\"\n  shows \"card (set [s .e. e]) = Suc (unat e) - unat s\"", "lemma complement_nth_w2p:\n  shows \"n' < LENGTH('a) \\<Longrightarrow> (NOT (2 ^ n :: 'a::len word)) !! n' = (n' \\<noteq> n)\"", "lemma word_unat_and_lt:\n  \"unat x < n \\<or> unat y < n \\<Longrightarrow> unat (x AND y) < n\"", "lemma word_unat_mask_lt:\n  \"m \\<le> size w \\<Longrightarrow> unat ((w::'a::len word) AND mask m) < 2 ^ m\"", "lemma unat_shiftr_less_t2n:\n  fixes x :: \"'a :: len word\"\n  shows \"unat x < 2 ^ (n + m) \\<Longrightarrow> unat (x >> n) < 2 ^ m\"", "lemma le_or_mask:\n  \"w \\<le> w' \\<Longrightarrow> w OR mask x \\<le> w' OR mask x\"\n  for w w' :: \\<open>'a::len word\\<close>", "lemma le_shiftr1':\n  \"\\<lbrakk> shiftr1 u \\<le> shiftr1 v ; shiftr1 u \\<noteq> shiftr1 v \\<rbrakk> \\<Longrightarrow> u \\<le> v\"", "lemma le_shiftr':\n  \"\\<lbrakk> u >> n \\<le> v >> n ; u >> n \\<noteq> v >> n \\<rbrakk> \\<Longrightarrow> (u::'a::len word) \\<le> v\"", "lemma word_add_no_overflow:\"(x::'a::len word) < max_word \\<Longrightarrow> x < x + 1\"", "lemma lt_plus_1_le_word:\n  fixes x :: \"'a::len word\"\n  assumes bound:\"n < unat (maxBound::'a word)\"\n  shows \"x < 1 + of_nat n = (x \\<le> of_nat n)\"", "lemma unat_ucast_up_simp:\n  fixes x :: \"'a::len word\"\n  assumes \"LENGTH('a) \\<le> LENGTH('b)\"\n  shows \"unat (ucast x :: 'b::len word) = unat x\"", "lemma unat_ucast_less_no_overflow:\n  \"\\<lbrakk>n < 2 ^ LENGTH('a); unat f < n\\<rbrakk> \\<Longrightarrow> (f::('a::len) word) < of_nat n\"", "lemma unat_ucast_less_no_overflow_simp:\n  \"n < 2 ^ LENGTH('a) \\<Longrightarrow> (unat f < n) = ((f::('a::len) word) < of_nat n)\"", "lemma unat_ucast_no_overflow_le:\n  assumes no_overflow: \"unat b < (2 :: nat) ^ LENGTH('a)\"\n  and upward_cast: \"LENGTH('a) < LENGTH('b)\"\n  shows \"(ucast (f::'a::len word) < (b :: 'b :: len word)) = (unat f < unat b)\"", "lemmas ucast_up_mono = ucast_less_ucast[THEN iffD2]", "lemma minus_one_word:\n  \"(-1 :: 'a :: len word) = 2 ^ LENGTH('a) - 1\"", "lemma mask_exceed:\n  \"n \\<ge> LENGTH('a) \\<Longrightarrow> (x::'a::len word) AND NOT (mask n) = 0\"", "lemma word_shift_by_2:\n  \"x * 4 = (x::'a::len word) << 2\"", "lemma le_2p_upper_bits:\n  \"\\<lbrakk> (p::'a::len word) \\<le> 2^n - 1; n < LENGTH('a) \\<rbrakk> \\<Longrightarrow>\n  \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\"", "lemma le2p_bits_unset:\n  \"p \\<le> 2 ^ n - 1 \\<Longrightarrow> \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> (p::'a::len word) !! n'\"", "lemma ucast_less_shiftl_helper:\n  \"\\<lbrakk> LENGTH('b) + 2 < LENGTH('a); 2 ^ (LENGTH('b) + 2) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (ucast (x :: 'b::len word) << 2) < (n :: 'a::len word)\"", "lemma word_power_nonzero:\n  \"\\<lbrakk> (x :: 'a::len word) < 2 ^ (LENGTH('a) - n); n < LENGTH('a); x \\<noteq> 0 \\<rbrakk>\n  \\<Longrightarrow> x * 2 ^ n \\<noteq> 0\"", "lemma less_1_helper:\n  \"n \\<le> m \\<Longrightarrow> (n - 1 :: int) < m\"", "lemma div_power_helper:\n  \"\\<lbrakk> x \\<le> y; y < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 ^ y - 1) div (2 ^ x :: 'a::len word) = 2 ^ (y - x) - 1\"", "lemma word_add_power_off:\n  fixes a :: \"'a :: len word\"\n  assumes ak: \"a < k\"\n  and kw: \"k < 2 ^ (LENGTH('a) - m)\"\n  and mw: \"m < LENGTH('a)\"\n  and off: \"off < 2 ^ m\"\n  shows \"(a * 2 ^ m) + off < k * 2 ^ m\"", "lemma offset_not_aligned:\n  \"\\<lbrakk> is_aligned (p::'a::len word) n; i > 0; i < 2 ^ n; n < LENGTH('a)\\<rbrakk> \\<Longrightarrow>\n   \\<not> is_aligned (p + of_nat i) n\"", "lemma length_upto_enum_one:\n  fixes x :: \"'a :: len word\"\n  assumes lt1: \"x < y\" and lt2: \"z < y\" and lt3: \"x \\<le> z\"\n  shows \"[x , y .e. z] = [x]\"", "lemma max_word_mask:\n  \"(max_word :: 'a::len word) = mask LENGTH('a)\"", "lemmas mask_len_max = max_word_mask[symmetric]", "lemma mask_out_first_mask_some:\n  \"\\<lbrakk> x AND NOT (mask n) = y; n \\<le> m \\<rbrakk> \\<Longrightarrow> x AND NOT (mask m) = y AND NOT (mask m)\"\n  for x y :: \\<open>'a::len word\\<close>", "lemma mask_lower_twice:\n  \"n \\<le> m \\<Longrightarrow> (x AND NOT (mask n)) AND NOT (mask m) = x AND NOT (mask m)\"\n  for x :: \\<open>'a::len word\\<close>", "lemma mask_lower_twice2:\n  \"(a AND NOT (mask n)) AND NOT (mask m) = a AND NOT (mask (max n m))\"\n  for a :: \\<open>'a::len word\\<close>", "lemma ucast_and_neg_mask:\n  \"ucast (x AND NOT (mask n)) = ucast x AND NOT (mask n)\"", "lemma ucast_and_mask:\n  \"ucast (x AND mask n) = ucast x AND mask n\"", "lemma ucast_mask_drop:\n  \"LENGTH('a :: len) \\<le> n \\<Longrightarrow> (ucast (x AND mask n) :: 'a word) = ucast x\"", "lemma NOT_mask_shifted_lenword:\n  \"NOT (mask len << (LENGTH('a) - len) ::'a::len word) = mask (LENGTH('a) - len)\"", "lemma eq_ucast_ucast_eq:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow> x = ucast y \\<Longrightarrow> ucast x = y\"\n  for x :: \"'a::len word\" and y :: \"'b::len word\"", "lemma le_ucast_ucast_le:\n  \"x \\<le> ucast y \\<Longrightarrow> ucast x \\<le> y\"\n  for x :: \"'a::len word\" and y :: \"'b::len word\"", "lemma less_ucast_ucast_less:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow> x < ucast y \\<Longrightarrow> ucast x < y\"\n  for x :: \"'a::len word\" and y :: \"'b::len word\"", "lemma ucast_le_ucast:\n  \"LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow> (ucast x \\<le> (ucast y::'b::len word)) = (x \\<le> y)\"\n  for x :: \"'a::len word\"", "lemmas ucast_up_mono_le = ucast_le_ucast[THEN iffD2]", "lemma ucast_le_ucast_eq:\n  fixes x y :: \"'a::len word\"\n  assumes x: \"x < 2 ^ n\"\n  assumes y: \"y < 2 ^ n\"\n  assumes n: \"n = LENGTH('b::len)\"\n  shows \"(UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y) = (x \\<le> y)\"", "lemma ucast_or_distrib:\n  fixes x :: \"'a::len word\"\n  fixes y :: \"'a::len word\"\n  shows \"(ucast (x OR y) :: ('b::len) word) = ucast x OR ucast y\"", "lemma shiftr_less:\n  \"(w::'a::len word) < k \\<Longrightarrow> w >> n < k\"", "lemma word_and_notzeroD:\n  \"w AND w' \\<noteq> 0 \\<Longrightarrow> w \\<noteq> 0 \\<and> w' \\<noteq> 0\"", "lemma word_exists_nth:\n  \"(w::'a::len word) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. w !! i\"", "lemma shiftr_le_0:\n  \"unat (w::'a::len word) < 2 ^ n \\<Longrightarrow> w >> n = (0::'a::len word)\"", "lemma of_nat_shiftl:\n  \"(of_nat x << n) = (of_nat (x * 2 ^ n) :: ('a::len) word)\"", "lemma shiftl_1_not_0:\n  \"n < LENGTH('a) \\<Longrightarrow> (1::'a::len word) << n \\<noteq> 0\"", "lemma max_word_not_0 [simp]:\n  \"- 1 \\<noteq> (0 :: 'a::len word)\"", "lemma ucast_zero_is_aligned:\n  \"UCAST('a::len \\<rightarrow> 'b::len) w = 0 \\<Longrightarrow> n \\<le> LENGTH('b) \\<Longrightarrow> is_aligned w n\"", "lemma unat_ucast_eq_unat_and_mask:\n  \"unat (UCAST('b::len \\<rightarrow> 'a::len) w) = unat (w AND mask LENGTH('a))\"", "lemma unat_max_word_pos[simp]: \"0 < unat (- 1 :: 'a::len word)\"", "lemma mult_pow2_inj:\n  assumes ws: \"m + n \\<le> LENGTH('a)\"\n  assumes le: \"x \\<le> mask m\" \"y \\<le> mask m\"\n  assumes eq: \"x * 2 ^ n = y * (2 ^ n::'a::len word)\"\n  shows \"x = y\"", "lemma word_of_nat_inj:\n  assumes bounded: \"x < 2 ^ LENGTH('a)\" \"y < 2 ^ LENGTH('a)\"\n  assumes of_nats: \"of_nat x = (of_nat y :: 'a::len word)\"\n  shows \"x = y\"", "lemma uints_mono_iff: \"uints l \\<subseteq> uints m \\<longleftrightarrow> l \\<le> m\"", "lemmas uints_monoI = uints_mono_iff[THEN iffD2]", "lemma Bit_in_uints_Suc: \"of_bool c + 2 * w \\<in> uints (Suc m)\" if \"w \\<in> uints m\"", "lemma Bit_in_uintsI: \"of_bool c + 2 * w \\<in> uints m\" if \"w \\<in> uints (m - 1)\" \"m > 0\"", "lemma bin_cat_in_uintsI:\n  \\<open>bin_cat a n b \\<in> uints m\\<close> if \\<open>a \\<in> uints l\\<close> \\<open>m \\<ge> l + n\\<close>", "lemma bin_cat_cong: \"bin_cat a n b = bin_cat c m d\"\n  if \"n = m\" \"a = c\" \"bintrunc m b = bintrunc m d\"", "lemma bin_cat_eqD1: \"bin_cat a n b = bin_cat c n d \\<Longrightarrow> a = c\"", "lemma bin_cat_eqD2: \"bin_cat a n b = bin_cat c n d \\<Longrightarrow> bintrunc n b = bintrunc n d\"", "lemma bin_cat_inj: \"(bin_cat a n b) = bin_cat c n d \\<longleftrightarrow> a = c \\<and> bintrunc n b = bintrunc n d\"", "lemma word_of_int_bin_cat_eq_iff:\n  \"(word_of_int (bin_cat (uint a) LENGTH('b) (uint b))::'c::len word) =\n  word_of_int (bin_cat (uint c) LENGTH('b) (uint d)) \\<longleftrightarrow> b = d \\<and> a = c\"\n  if \"LENGTH('a) + LENGTH('b) \\<le> LENGTH('c)\"\n  for a::\"'a::len word\" and b::\"'b::len word\"", "lemma word_cat_inj: \"(word_cat a b::'c::len word) = word_cat c d \\<longleftrightarrow> a = c \\<and> b = d\"\n  if \"LENGTH('a) + LENGTH('b) \\<le> LENGTH('c)\"\n  for a::\"'a::len word\" and b::\"'b::len word\"", "lemma p2_eq_1: \"2 ^ n = (1::'a::len word) \\<longleftrightarrow> n = 0\"", "lemma bitmagic_zeroLast_leq_or1Last:\n  \"(a::('a::len) word) AND (mask len << x - len) \\<le> a OR mask (y - len)\"", "lemma zero_base_lsb_imp_set_eq_as_bit_operation:\n  fixes base ::\"'a::len word\"\n  assumes valid_prefix: \"mask (LENGTH('a) - len) AND base = 0\"\n  shows \"(base = NOT (mask (LENGTH('a) - len)) AND a) \\<longleftrightarrow>\n         (a \\<in> {base .. base OR mask (LENGTH('a) - len)})\"", "lemma of_nat_eq_signed_scast:\n  \"(of_nat x = (y :: ('a::len) signed word))\n   = (of_nat x = (scast y :: 'a word))\"", "lemma word_aligned_add_no_wrap_bounded:\n  \"\\<lbrakk> w + 2^n \\<le> x; w + 2^n \\<noteq> 0; is_aligned w n \\<rbrakk> \\<Longrightarrow> (w::'a::len word) < x\"", "lemma mask_Suc:\n  \"mask (Suc n) = (2 :: 'a::len word) ^ n + mask n\"", "lemma mask_mono:\n  \"sz' \\<le> sz \\<Longrightarrow> mask sz' \\<le> (mask sz :: 'a::len word)\"", "lemma aligned_mask_disjoint:\n  \"\\<lbrakk> is_aligned (a :: 'a :: len word) n; b \\<le> mask n \\<rbrakk> \\<Longrightarrow> a AND b = 0\"", "lemma word_and_or_mask_aligned:\n  \"\\<lbrakk> is_aligned a n; b \\<le> mask n \\<rbrakk> \\<Longrightarrow> a + b = a OR b\"", "lemma word_and_or_mask_aligned2:\n  \\<open>is_aligned b n \\<Longrightarrow> a \\<le> mask n \\<Longrightarrow> a + b = a OR b\\<close>", "lemma is_aligned_ucastI:\n  \"is_aligned w n \\<Longrightarrow> is_aligned (ucast w) n\"", "lemma ucast_le_maskI:\n  \"a \\<le> mask n \\<Longrightarrow> UCAST('a::len \\<rightarrow> 'b::len) a \\<le> mask n\"", "lemma ucast_add_mask_aligned:\n  \"\\<lbrakk> a \\<le> mask n; is_aligned b n \\<rbrakk> \\<Longrightarrow> UCAST ('a::len \\<rightarrow> 'b::len) (a + b) = ucast a + ucast b\"", "lemma ucast_shiftl:\n  \"LENGTH('b) \\<le> LENGTH ('a) \\<Longrightarrow> UCAST ('a::len \\<rightarrow> 'b::len) x << n = ucast (x << n)\"", "lemma ucast_leq_mask:\n  \"LENGTH('a) \\<le> n \\<Longrightarrow> ucast (x::'a::len word) \\<le> mask n\"", "lemma shiftl_inj:\n  \"\\<lbrakk> x << n = y << n; x \\<le> mask (LENGTH('a)-n); y \\<le> mask (LENGTH('a)-n) \\<rbrakk> \\<Longrightarrow>\n   x = (y :: 'a :: len word)\"", "lemma distinct_word_add_ucast_shift_inj:\n  \"\\<lbrakk> p + (UCAST('a::len \\<rightarrow> 'b::len) off << n) = p' + (ucast off' << n);\n     is_aligned p n'; is_aligned p' n'; n' = n + LENGTH('a); n' < LENGTH('b) \\<rbrakk>\n   \\<Longrightarrow> p' = p \\<and> off' = off\"", "lemma word_upto_Nil:\n  \"y < x \\<Longrightarrow> [x .e. y ::'a::len word] = []\"", "lemma word_enum_decomp_elem:\n  assumes \"[x .e. (y ::'a::len word)] = as @ a # bs\"\n  shows \"x \\<le> a \\<and> a \\<le> y\"", "lemma max_word_not_less[simp]:\n   \"\\<not> max_word < x\"", "lemma word_enum_prefix:\n  \"[x .e. (y ::'a::len word)] = as @ a # bs \\<Longrightarrow> as = (if x < a then [x .e. a - 1] else [])\"", "lemma word_enum_decomp_set:\n  \"[x .e. (y ::'a::len word)] = as @ a # bs \\<Longrightarrow> a \\<notin> set as\"", "lemma word_enum_decomp:\n  assumes \"[x .e. (y ::'a::len word)] = as @ a # bs\"\n  shows \"x \\<le> a \\<and> a \\<le> y \\<and> a \\<notin> set as \\<and> (\\<forall>z \\<in> set as. x \\<le> z \\<and> z \\<le> y)\"", "lemma of_nat_unat_le_mask_ucast:\n  \"\\<lbrakk>of_nat (unat t) = w; t \\<le> mask LENGTH('a)\\<rbrakk> \\<Longrightarrow> t = UCAST('a::len \\<rightarrow> 'b::len) w\"", "lemma less_diff_gt0:\n  \"a < b \\<Longrightarrow> (0 :: 'a :: len word) < b - a\"", "lemma unat_plus_gt:\n  \"unat ((a :: 'a :: len word) + b) \\<le> unat a + unat b\"", "lemma const_less:\n  \"\\<lbrakk> (a :: 'a :: len word) - 1 < b; a \\<noteq> b \\<rbrakk> \\<Longrightarrow> a < b\"", "lemma add_mult_aligned_neg_mask:\n  \\<open>(x + y * m) AND NOT(mask n) = (x AND NOT(mask n)) + y * m\\<close>\n  if \\<open>m AND (2 ^ n - 1) = 0\\<close>\n  for x y m :: \\<open>'a::len word\\<close>", "lemma unat_of_nat_minus_1:\n  \"\\<lbrakk> n < 2 ^ LENGTH('a); n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> unat ((of_nat n:: 'a :: len word) - 1) = n - 1\"", "lemma word_eq_zeroI:\n  \"a \\<le> a - 1 \\<Longrightarrow> a = 0\" for a :: \"'a :: len word\"", "lemma word_add_format:\n  \"(-1 :: 'a :: len  word) + b + c = b + (c - 1)\"", "lemma upto_enum_word_nth:\n  \"\\<lbrakk> i \\<le> j; k \\<le> unat (j - i) \\<rbrakk> \\<Longrightarrow> [i .e. j] ! k = i + of_nat k\"", "lemma upto_enum_step_nth:\n  \"\\<lbrakk> a \\<le> c; n \\<le> unat ((c - a) div (b - a)) \\<rbrakk>\n   \\<Longrightarrow> [a, b .e. c] ! n = a + of_nat n * (b - a)\"", "lemma upto_enum_inc_1_len:\n  \"a < - 1 \\<Longrightarrow> [(0 :: 'a :: len word) .e. 1 + a] = [0 .e. a] @ [1 + a]\"", "lemma neg_mask_add:\n  \"y AND mask n = 0 \\<Longrightarrow> x + y AND NOT(mask n) = (x AND NOT(mask n)) + y\"\n  for x y :: \\<open>'a::len word\\<close>", "lemma shiftr_shiftl_shiftr[simp]:\n  \"(x :: 'a :: len word)  >> a << a >> a = x >> a\"", "lemma add_right_shift:\n  \"\\<lbrakk> x AND mask n = 0; y AND mask n = 0; x \\<le> x + y \\<rbrakk>\n   \\<Longrightarrow> (x + y :: ('a :: len) word) >> n = (x >> n) + (y >> n)\"", "lemma sub_right_shift:\n  \"\\<lbrakk> x AND mask n = 0; y AND mask n = 0; y \\<le> x \\<rbrakk>\n   \\<Longrightarrow> (x - y) >> n = (x >> n :: 'a :: len word) - (y >> n)\"", "lemma and_and_mask_simple:\n  \"y AND mask n = mask n \\<Longrightarrow> (x AND y) AND mask n = x AND mask n\"", "lemma and_and_mask_simple_not:\n  \"y AND mask n = 0 \\<Longrightarrow> (x AND y) AND mask n = 0\"", "lemma word_and_le':\n  \"b \\<le> c \\<Longrightarrow> (a :: 'a :: len word) AND b \\<le> c\"", "lemma word_and_less':\n  \"b < c \\<Longrightarrow> (a :: 'a :: len word) AND b < c\"", "lemma shiftr_w2p:\n  \"x < LENGTH('a) \\<Longrightarrow> 2 ^ x = (2 ^ (LENGTH('a) - 1) >> (LENGTH('a) - 1 - x) :: 'a :: len word)\"", "lemma t2p_shiftr:\n  \"\\<lbrakk> b \\<le> a; a < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 :: 'a :: len word) ^ a >> b = 2 ^ (a - b)\"", "lemma scast_1[simp]:\n  \"scast (1 :: 'a :: len signed word) = (1 :: 'a word)\"", "lemma unsigned_uminus1 [simp]:\n  \\<open>(unsigned (-1::'b::len word)::'c::len word) = mask LENGTH('b)\\<close>", "lemma ucast_ucast_mask_eq:\n  \"\\<lbrakk> UCAST('a::len \\<rightarrow> 'b::len) x = y; x AND mask LENGTH('b) = x \\<rbrakk> \\<Longrightarrow> x = ucast y\"", "lemma ucast_up_eq:\n  \"\\<lbrakk> ucast x = (ucast y::'b::len word); LENGTH('a) \\<le> LENGTH ('b) \\<rbrakk>\n   \\<Longrightarrow> ucast x = (ucast y::'a::len word)\"", "lemma ucast_up_neq:\n  \"\\<lbrakk> ucast x \\<noteq> (ucast y::'b::len word); LENGTH('b) \\<le> LENGTH ('a) \\<rbrakk>\n   \\<Longrightarrow> ucast x \\<noteq> (ucast y::'a::len word)\"", "lemma mask_AND_less_0:\n  \"\\<lbrakk> x AND mask n = 0; m \\<le> n \\<rbrakk> \\<Longrightarrow> x AND mask m = 0\"\n  for x :: \\<open>'a::len word\\<close>", "lemma mask_len_id [simp]:\n  \"(x :: 'a :: len word) AND mask LENGTH('a) = x\"", "lemma scast_ucast_down_same:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow> SCAST('a \\<rightarrow> 'b) = UCAST('a::len \\<rightarrow> 'b::len)\"", "lemma word_aligned_0_sum:\n  \"\\<lbrakk> a + b = 0; is_aligned (a :: 'a :: len word) n; b \\<le> mask n; n < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> a = 0 \\<and> b = 0\"", "lemma mask_eq1_nochoice:\n  \"\\<lbrakk> LENGTH('a) > 1; (x :: 'a :: len word) AND 1 = x \\<rbrakk> \\<Longrightarrow> x = 0 \\<or> x = 1\"", "lemma shiftr_and_eq_shiftl:\n  \"(w >> n) AND x = y \\<Longrightarrow> w AND (x << n) = (y << n)\" for y :: \"'a:: len word\"", "lemma add_mask_lower_bits':\n  \"\\<lbrakk> len = LENGTH('a); is_aligned (x :: 'a :: len word) n;\n     \\<forall>n' \\<ge> n. n' < len \\<longrightarrow> \\<not> p !! n' \\<rbrakk>\n   \\<Longrightarrow> x + p AND NOT(mask n) = x\"", "lemma leq_mask_shift:\n  \"(x :: 'a :: len word) \\<le> mask (low_bits + high_bits) \\<Longrightarrow> (x >> low_bits) \\<le> mask high_bits\"", "lemma ucast_ucast_eq_mask_shift:\n  \"(x :: 'a :: len word) \\<le> mask (low_bits + LENGTH('b))\n   \\<Longrightarrow> ucast((ucast (x >> low_bits)) :: 'b :: len word) = x >> low_bits\"", "lemma const_le_unat:\n  \"\\<lbrakk> b < 2 ^ LENGTH('a); of_nat b \\<le> a \\<rbrakk> \\<Longrightarrow> b \\<le> unat (a :: 'a :: len word)\"", "lemma upt_enum_offset_trivial:\n  \"\\<lbrakk> x < 2 ^ LENGTH('a) - 1 ; n \\<le> unat x \\<rbrakk>\n   \\<Longrightarrow> ([(0 :: 'a :: len word) .e. x] ! n) = of_nat n\"", "lemma word_le_mask_out_plus_2sz:\n  \"x \\<le> (x AND NOT(mask sz)) + 2 ^ sz - 1\"\n  for x :: \\<open>'a::len word\\<close>", "lemma ucast_add:\n  \"ucast (a + (b :: 'a :: len word)) = ucast a + (ucast b :: ('a signed word))\"", "lemma ucast_minus:\n  \"ucast (a - (b :: 'a :: len word)) = ucast a - (ucast b :: ('a signed word))\"", "lemma scast_ucast_add_one [simp]:\n  \"scast (ucast (x :: 'a::len word) + (1 :: 'a signed word)) = x + 1\"", "lemma word_and_le_plus_one:\n  \"a > 0 \\<Longrightarrow> (x :: 'a :: len word) AND (a - 1) < a\"", "lemma unat_of_ucast_then_shift_eq_unat_of_shift[simp]:\n  \"LENGTH('b) \\<ge> LENGTH('a)\n   \\<Longrightarrow> unat ((ucast (x :: 'a :: len word) :: 'b :: len word) >> n) = unat (x >> n)\"", "lemma unat_of_ucast_then_mask_eq_unat_of_mask[simp]:\n  \"LENGTH('b) \\<ge> LENGTH('a)\n   \\<Longrightarrow> unat ((ucast (x :: 'a :: len word) :: 'b :: len word) AND mask m) = unat (x AND mask m)\"", "lemma shiftr_less_t2n3:\n  \"\\<lbrakk> (2 :: 'a word) ^ (n + m) = 0; m < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> (x :: 'a :: len word) >> n < 2 ^ m\"", "lemma unat_shiftr_le_bound:\n  \"\\<lbrakk> 2 ^ (LENGTH('a :: len) - n) - 1 \\<le> bnd; 0 < n \\<rbrakk>\n   \\<Longrightarrow> unat ((x :: 'a word) >> n) \\<le> bnd\"", "lemma shiftr_eqD:\n  \"\\<lbrakk> x >> n = y >> n; is_aligned x n; is_aligned y n \\<rbrakk>\n   \\<Longrightarrow> x = y\"", "lemma word_shiftr_shiftl_shiftr_eq_shiftr:\n  \"a \\<ge> b \\<Longrightarrow> (x :: 'a :: len word) >> a << b >> b = x >> a\"", "lemma of_int_uint_ucast:\n   \"of_int (uint (x :: 'a::len word)) = (ucast x :: 'b::len word)\"", "lemma mod_mask_drop:\n  \"\\<lbrakk> m = 2 ^ n; 0 < m; mask n AND msk = mask n \\<rbrakk>\n   \\<Longrightarrow> (x mod m) AND msk = x mod m\"\n  for x :: \\<open>'a::len word\\<close>", "lemma mask_eq_ucast_eq:\n  \"\\<lbrakk> x AND mask LENGTH('a) = (x :: ('c :: len word));\n     LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> ucast (ucast x :: ('a :: len word)) = (ucast x :: ('b :: len word))\"", "lemma of_nat_less_t2n:\n  \"of_nat i < (2 :: ('a :: len) word) ^ n \\<Longrightarrow> n < LENGTH('a) \\<and> unat (of_nat i :: 'a word) < 2 ^ n\"", "lemma two_power_increasing_less_1:\n  \"\\<lbrakk> n \\<le> m; m \\<le> LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 :: 'a :: len word) ^ n - 1 \\<le> 2 ^ m - 1\"", "lemma word_sub_mono4:\n  \"\\<lbrakk> y + x \\<le> z + x; y \\<le> y + x; z \\<le> z + x \\<rbrakk> \\<Longrightarrow> y \\<le> z\" for y :: \"'a :: len word\"", "lemma eq_or_less_helperD:\n  \"\\<lbrakk> n = unat (2 ^ m - 1 :: 'a :: len word) \\<or> n < unat (2 ^ m - 1 :: 'a word); m < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> n < 2 ^ m\"", "lemma mask_sub:\n  \"n \\<le> m \\<Longrightarrow> mask m - mask n = mask m AND NOT(mask n :: 'a::len word)\"", "lemma neg_mask_diff_bound:\n  \"sz'\\<le> sz \\<Longrightarrow> (ptr AND NOT(mask sz')) - (ptr AND NOT(mask sz)) \\<le> 2 ^ sz - 2 ^ sz'\"\n  (is \"_ \\<Longrightarrow> ?lhs \\<le> ?rhs\")\n  for ptr :: \\<open>'a::len word\\<close>", "lemma mask_out_eq_0:\n  \"\\<lbrakk> idx < 2 ^ sz; sz < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (of_nat idx :: 'a :: len word) AND NOT(mask sz) = 0\"", "lemma is_aligned_neg_mask_eq':\n  \"is_aligned ptr sz = (ptr AND NOT(mask sz) = ptr)\"", "lemma neg_mask_mask_unat:\n  \"sz < LENGTH('a)\n   \\<Longrightarrow> unat ((ptr :: 'a :: len word) AND NOT(mask sz)) + unat (ptr AND mask sz) = unat ptr\"", "lemma unat_pow_le_intro:\n  \"LENGTH('a) \\<le> n \\<Longrightarrow> unat (x :: 'a :: len word) < 2 ^ n\"", "lemma unat_shiftl_less_t2n:\n  \"\\<lbrakk> unat (x :: 'a :: len word) < 2 ^ (m - n); m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> unat (x << n) < 2 ^ m\"", "lemma unat_is_aligned_add:\n  \"\\<lbrakk> is_aligned p n; unat d < 2 ^ n \\<rbrakk>\n   \\<Longrightarrow> unat (p + d AND mask n) = unat d \\<and> unat (p + d AND NOT(mask n)) = unat p\"", "lemma unat_shiftr_shiftl_mask_zero:\n  \"\\<lbrakk> c + a \\<ge> LENGTH('a) + b ; c < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> unat (((q :: 'a :: len word) >> a << b) AND NOT(mask c)) = 0\"", "lemmas of_nat_ucast = ucast_of_nat[symmetric]", "lemma shift_then_mask_eq_shift_low_bits:\n  \"x \\<le> mask (low_bits + high_bits) \\<Longrightarrow> (x >> low_bits) AND mask high_bits = x >> low_bits\"\n  for x :: \\<open>'a::len word\\<close>", "lemma leq_low_bits_iff_zero:\n  \"\\<lbrakk> x \\<le> mask (low bits + high bits); x >> low_bits = 0 \\<rbrakk> \\<Longrightarrow> (x AND mask low_bits = 0) = (x = 0)\"\n  for x :: \\<open>'a::len word\\<close>", "lemma unat_less_iff:\n  \"\\<lbrakk> unat (a :: 'a :: len word) = b; c < 2 ^ LENGTH('a) \\<rbrakk> \\<Longrightarrow> (a < of_nat c) = (b < c)\"", "lemma is_aligned_no_overflow3:\n \"\\<lbrakk> is_aligned (a :: 'a :: len word) n; n < LENGTH('a); b < 2 ^ n; c \\<le> 2 ^ n; b < c \\<rbrakk>\n  \\<Longrightarrow> a + b \\<le> a + (c - 1)\"", "lemma mask_add_aligned_right:\n  \"is_aligned p n \\<Longrightarrow> (q + p) AND mask n = q AND mask n\"", "lemma leq_high_bits_shiftr_low_bits_leq_bits_mask:\n  \"x \\<le> mask high_bits \\<Longrightarrow> (x :: 'a :: len word) << low_bits \\<le> mask (low_bits + high_bits)\"", "lemma word_two_power_neg_ineq:\n  \"2 ^ m \\<noteq> (0 :: 'a word) \\<Longrightarrow> 2 ^ n \\<le> - (2 ^ m :: 'a :: len word)\"", "lemma unat_shiftl_absorb:\n  \"\\<lbrakk> x \\<le> 2 ^ p; p + k < LENGTH('a) \\<rbrakk> \\<Longrightarrow> unat (x :: 'a :: len word) * 2 ^ k = unat (x * 2 ^ k)\"", "lemma word_plus_mono_right_split:\n  \"\\<lbrakk> unat ((x :: 'a :: len word) AND mask sz) + unat z < 2 ^ sz; sz < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> x \\<le> x + z\"", "lemma mul_not_mask_eq_neg_shiftl:\n  \"NOT(mask n :: 'a::len word) = -1 << n\"", "lemma shiftr_mul_not_mask_eq_and_not_mask:\n  \"(x >> n) * NOT(mask n) = - (x AND NOT(mask n))\"\n  for x :: \\<open>'a::len word\\<close>", "lemma mask_eq_n1_shiftr:\n  \"n \\<le> LENGTH('a) \\<Longrightarrow> (mask n :: 'a :: len word) = -1 >> (LENGTH('a) - n)\"", "lemma is_aligned_mask_out_add_eq:\n  \"is_aligned p n \\<Longrightarrow> (p + x) AND NOT(mask n) = p + (x AND NOT(mask n))\"", "lemmas is_aligned_mask_out_add_eq_sub\n    = is_aligned_mask_out_add_eq[where x=\"a - b\" for a b, simplified field_simps]", "lemma aligned_bump_down:\n  \"is_aligned x n \\<Longrightarrow> (x - 1) AND NOT(mask n) = x - 2 ^ n\"", "lemma unat_2tp_if:\n  \"unat (2 ^ n :: ('a :: len) word) = (if n < LENGTH ('a) then 2 ^ n else 0)\"", "lemma mask_of_mask:\n  \"mask (n::nat) AND mask (m::nat) = (mask (min m n) :: 'a::len word)\"", "lemma unat_signed_ucast_less_ucast:\n  \"LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow> unat (ucast (x :: 'a :: len word) :: 'b :: len signed word) = unat x\"", "lemma toEnum_of_ucast:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n   (toEnum (unat (b::'b :: len word))::'a :: len word) = of_nat (unat b)\"", "lemmas unat_ucast_mask = unat_ucast_eq_unat_and_mask[where w=a for a]", "lemma t2n_mask_eq_if:\n  \"2 ^ n AND mask m = (if n < m then 2 ^ n else (0 :: 'a::len word))\"", "lemma unat_ucast_le:\n  \"unat (ucast (x :: 'a :: len word) :: 'b :: len word) \\<le> unat x\"", "lemma ucast_le_up_down_iff:\n  \"\\<lbrakk> LENGTH('a) \\<le> LENGTH('b); (x :: 'b :: len word) \\<le> ucast (max_word :: 'a :: len word) \\<rbrakk>\n   \\<Longrightarrow> (ucast x \\<le> (y :: 'a word)) = (x \\<le> ucast y)\"", "lemma ucast_ucast_mask_shift:\n  \"a \\<le> LENGTH('a) + b\n   \\<Longrightarrow> ucast (ucast (p AND mask a >> b) :: 'a :: len word) = p AND mask a >> b\"", "lemma unat_ucast_mask_shift:\n  \"a \\<le> LENGTH('a) + b\n   \\<Longrightarrow> unat (ucast (p AND mask a >> b) :: 'a :: len word) = unat (p AND mask a >> b)\"", "lemma mask_overlap_zero:\n  \"a \\<le> b \\<Longrightarrow> (p AND mask a) AND NOT(mask b) = 0\"\n  for p :: \\<open>'a::len word\\<close>", "lemma mask_shifl_overlap_zero:\n  \"a + c \\<le> b \\<Longrightarrow> (p AND mask a << c) AND NOT(mask b) = 0\"\n  for p :: \\<open>'a::len word\\<close>", "lemma mask_overlap_zero':\n  \"a \\<ge> b \\<Longrightarrow> (p AND NOT(mask a)) AND mask b = 0\"\n  for p :: \\<open>'a::len word\\<close>", "lemma mask_rshift_mult_eq_rshift_lshift:\n  \"((a :: 'a :: len word) >> b) * (1 << c) = (a >> b << c)\"", "lemma shift_alignment:\n  \"a \\<ge> b \\<Longrightarrow> is_aligned (p >> a << a) b\"", "lemma mask_split_sum_twice:\n  \"a \\<ge> b \\<Longrightarrow> (p AND NOT(mask a)) + ((p AND mask a) AND NOT(mask b)) + (p AND mask b) = p\"\n  for p :: \\<open>'a::len word\\<close>", "lemma mask_shift_eq_mask_mask:\n  \"(p AND mask a >> b << b) = (p AND mask a) AND NOT(mask b)\"\n  for p :: \\<open>'a::len word\\<close>", "lemma mask_shift_sum:\n  \"\\<lbrakk> a \\<ge> b; unat n = unat (p AND mask b) \\<rbrakk>\n   \\<Longrightarrow> (p AND NOT(mask a)) + (p AND mask a >> b) * (1 << b) + n = (p :: 'a :: len word)\"", "lemma is_up_compose:\n  \"\\<lbrakk> is_up uc; is_up uc' \\<rbrakk> \\<Longrightarrow> is_up (uc' \\<circ> uc)\"", "lemma of_int_sint_scast:\n  \"of_int (sint (x :: 'a :: len word)) = (scast x :: 'b :: len word)\"", "lemma scast_of_nat_to_signed [simp]:\n  \"scast (of_nat x :: 'a :: len word) = (of_nat x :: 'a signed word)\"", "lemma scast_of_nat_signed_to_unsigned_add:\n  \"scast (of_nat x + of_nat y :: 'a :: len signed word) = (of_nat x + of_nat y :: 'a :: len word)\"", "lemma scast_of_nat_unsigned_to_signed_add:\n  \"(scast (of_nat x + of_nat y :: 'a :: len word)) = (of_nat x + of_nat y :: 'a :: len signed word)\"", "lemma and_mask_cases:\n  fixes x :: \"'a :: len word\"\n  assumes len: \"n < LENGTH('a)\"\n  shows \"x AND mask n \\<in> of_nat ` set [0 ..< 2 ^ n]\"", "lemma sint_eq_uint_2pl:\n  \"\\<lbrakk> (a :: 'a :: len word) < 2 ^ (LENGTH('a) - 1) \\<rbrakk>\n   \\<Longrightarrow> sint a = uint a\"", "lemma pow_sub_less:\n  \"\\<lbrakk> a + b \\<le> LENGTH('a); unat (x :: 'a :: len word) = 2 ^ a \\<rbrakk>\n   \\<Longrightarrow> unat (x * 2 ^ b - 1) < 2 ^ (a + b)\"", "lemma sle_le_2pl:\n  \"\\<lbrakk> (b :: 'a :: len word) < 2 ^ (LENGTH('a) - 1); a \\<le> b \\<rbrakk> \\<Longrightarrow> a <=s b\"", "lemma sless_less_2pl:\n  \"\\<lbrakk> (b :: 'a :: len word) < 2 ^ (LENGTH('a) - 1); a < b \\<rbrakk> \\<Longrightarrow> a <s b\"", "lemma and_mask2:\n  \"w << n >> n = w AND mask (size w - n)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma aligned_sub_aligned_simple:\n  \"\\<lbrakk> is_aligned a n; is_aligned b n \\<rbrakk> \\<Longrightarrow> is_aligned (a - b) n\"", "lemma minus_one_shift:\n  \"- (1 << n) = (-1 << n :: 'a::len word)\"", "lemma ucast_eq_mask:\n  \"(UCAST('a::len \\<rightarrow> 'b::len) x = UCAST('a \\<rightarrow> 'b) y) =\n   (x AND mask LENGTH('b) = y AND mask LENGTH('b))\"", "lemma sbintrunc_uint_ucast:\n  assumes \"Suc n = LENGTH('b::len)\"\n  shows \"sbintrunc n (uint (ucast w :: 'b word)) = sbintrunc n (uint w)\"", "lemma test_bit_sbintrunc:\n  assumes \"i < LENGTH('a)\"\n  shows \"(word_of_int (sbintrunc n (uint w)) :: 'a word) !! i\n           = (if n < i then w !! n else w !! i)\"", "lemma test_bit_sbintrunc_ucast:\n  assumes len_a: \"i < LENGTH('a)\"\n  shows \"(word_of_int (sbintrunc (LENGTH('b) - 1) (uint (ucast w :: 'b word))) :: 'a word) !! i\n          = (if LENGTH('b::len) \\<le> i then w !! (LENGTH('b) - 1) else w !! i)\"", "lemma scast_ucast_high_bits:\n  \\<open>scast (ucast w :: 'b::len word) = w\n     \\<longleftrightarrow> (\\<forall> i \\<in> {LENGTH('b) ..< size w}. w !! i = w !! (LENGTH('b) - 1))\\<close>", "lemma scast_ucast_mask_compare:\n  \"scast (ucast w :: 'b::len word) = w\n   \\<longleftrightarrow> (w \\<le> mask (LENGTH('b) - 1) \\<or> NOT(mask (LENGTH('b) - 1)) \\<le> w)\"", "lemma ucast_less_shiftl_helper':\n  \"\\<lbrakk> LENGTH('b) + (a::nat) < LENGTH('a); 2 ^ (LENGTH('b) + a) \\<le> n\\<rbrakk>\n   \\<Longrightarrow> (ucast (x :: 'b::len word) << a) < (n :: 'a::len word)\"", "lemma ucast_ucast_mask2:\n  \"is_down (UCAST ('a \\<rightarrow> 'b)) \\<Longrightarrow>\n   UCAST ('b::len \\<rightarrow> 'c::len) (UCAST ('a::len \\<rightarrow> 'b::len) x) = UCAST ('a \\<rightarrow> 'c) (x AND mask LENGTH('b))\"", "lemma ucast_NOT:\n  \"ucast (NOT x) = NOT(ucast x) AND mask (LENGTH('a))\" for x::\"'a::len word\"", "lemma ucast_NOT_down:\n  \"is_down UCAST('a::len \\<rightarrow> 'b::len) \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) (NOT x) = NOT(UCAST('a \\<rightarrow> 'b) x)\"", "lemma upto_enum_step_shift:\n  \"\\<lbrakk> is_aligned p n \\<rbrakk> \\<Longrightarrow>\n  ([p , p + 2 ^ m .e. p + 2 ^ n - 1])\n      = map ((+) p) [0, 2 ^ m .e. 2 ^ n - 1]\"", "lemma upto_enum_step_shift_red:\n  \"\\<lbrakk> is_aligned p sz; sz < LENGTH('a); us \\<le> sz \\<rbrakk>\n     \\<Longrightarrow> [p :: 'a :: len word, p + 2 ^ us .e. p + 2 ^ sz - 1]\n          = map (\\<lambda>x. p + of_nat x * 2 ^ us) [0 ..< 2 ^ (sz - us)]\"", "lemma upto_enum_step_subset:\n  \"set [x, y .e. z] \\<subseteq> {x .. z}\"", "lemma ucast_distrib:\n  fixes M :: \"'a::len word \\<Rightarrow> 'a::len word \\<Rightarrow> 'a::len word\"\n  fixes M' :: \"'b::len word \\<Rightarrow> 'b::len word \\<Rightarrow> 'b::len word\"\n  fixes L :: \"int \\<Rightarrow> int \\<Rightarrow> int\"\n  assumes lift_M: \"\\<And>x y. uint (M x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('a)\"\n  assumes lift_M': \"\\<And>x y. uint (M' x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('b)\"\n  assumes distrib: \"\\<And>x y. (L (x mod (2 ^ LENGTH('b))) (y mod (2 ^ LENGTH('b)))) mod (2 ^ LENGTH('b))\n                               = (L x y) mod (2 ^ LENGTH('b))\"\n  assumes is_down: \"is_down (ucast :: 'a word \\<Rightarrow> 'b word)\"\n  shows \"ucast (M a b) = M' (ucast a) (ucast b)\"", "lemma ucast_down_add:\n    \"is_down (ucast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  ucast ((a :: 'a::len word) + b) = (ucast a + ucast b :: 'b::len word)\"", "lemma ucast_down_minus:\n    \"is_down (ucast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  ucast ((a :: 'a::len word) - b) = (ucast a - ucast b :: 'b::len word)\"", "lemma ucast_down_mult:\n    \"is_down (ucast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  ucast ((a :: 'a::len word) * b) = (ucast a * ucast b :: 'b::len word)\"", "lemma scast_distrib:\n  fixes M :: \"'a::len word \\<Rightarrow> 'a::len word \\<Rightarrow> 'a::len word\"\n  fixes M' :: \"'b::len word \\<Rightarrow> 'b::len word \\<Rightarrow> 'b::len word\"\n  fixes L :: \"int \\<Rightarrow> int \\<Rightarrow> int\"\n  assumes lift_M: \"\\<And>x y. uint (M x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('a)\"\n  assumes lift_M': \"\\<And>x y. uint (M' x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('b)\"\n  assumes distrib: \"\\<And>x y. (L (x mod (2 ^ LENGTH('b))) (y mod (2 ^ LENGTH('b)))) mod (2 ^ LENGTH('b))\n                               = (L x y) mod (2 ^ LENGTH('b))\"\n  assumes is_down: \"is_down (scast :: 'a word \\<Rightarrow> 'b word)\"\n  shows \"scast (M a b) = M' (scast a) (scast b)\"", "lemma scast_down_add:\n    \"is_down (scast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  scast ((a :: 'a::len word) + b) = (scast a + scast b :: 'b::len word)\"", "lemma scast_down_minus:\n    \"is_down (scast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  scast ((a :: 'a::len word) - b) = (scast a - scast b :: 'b::len word)\"", "lemma scast_down_mult:\n    \"is_down (scast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  scast ((a :: 'a::len word) * b) = (scast a * scast b :: 'b::len word)\"", "lemma scast_ucast_1:\n  \"\\<lbrakk> is_down (ucast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n         (scast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\"", "lemma scast_ucast_3:\n  \"\\<lbrakk> is_down (ucast :: 'a word \\<Rightarrow> 'c word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n         (scast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\"", "lemma scast_ucast_4:\n  \"\\<lbrakk> is_up (ucast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n         (scast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\"", "lemma scast_scast_b:\n  \"\\<lbrakk> is_up (scast :: 'a word \\<Rightarrow> 'b word) \\<rbrakk> \\<Longrightarrow>\n     (scast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\"", "lemma ucast_scast_1:\n  \"\\<lbrakk> is_down (scast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n            (ucast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\"", "lemma ucast_scast_3:\n  \"\\<lbrakk> is_down (scast :: 'a word \\<Rightarrow> 'c word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n     (ucast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\"", "lemma ucast_scast_4:\n  \"\\<lbrakk> is_up (scast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n     (ucast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\"", "lemma ucast_ucast_a:\n  \"\\<lbrakk> is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n        (ucast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\"", "lemma ucast_ucast_b:\n  \"\\<lbrakk> is_up (ucast :: 'a word \\<Rightarrow> 'b word) \\<rbrakk> \\<Longrightarrow>\n     (ucast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\"", "lemma scast_scast_a:\n  \"\\<lbrakk> is_down (scast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n            (scast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\"", "lemma scast_down_wi [OF refl]:\n  \"uc = scast \\<Longrightarrow> is_down uc \\<Longrightarrow> uc (word_of_int x) = word_of_int x\"", "lemmas cast_simps =\n  is_down is_up\n  scast_down_add scast_down_minus scast_down_mult\n  ucast_down_add ucast_down_minus ucast_down_mult\n  scast_ucast_1 scast_ucast_3 scast_ucast_4\n  ucast_scast_1 ucast_scast_3 ucast_scast_4\n  ucast_ucast_a ucast_ucast_b\n  scast_scast_a scast_scast_b\n  ucast_down_wi scast_down_wi\n  ucast_of_nat scast_of_nat\n  uint_up_ucast sint_up_scast\n  up_scast_surj up_ucast_surj", "lemma sdiv_word_max:\n    \"(sint (a :: ('a::len) word) sdiv sint (b :: ('a::len) word) < (2 ^ (size a - 1))) =\n          ((a \\<noteq> - (2 ^ (size a - 1)) \\<or> (b \\<noteq> -1)))\"\n    (is \"?lhs = (\\<not> ?a_int_min \\<or> \\<not> ?b_minus1)\")", "lemmas sdiv_word_min' = sdiv_word_min [simplified word_size, simplified]", "lemmas sdiv_word_max' = sdiv_word_max [simplified word_size, simplified]", "lemma signed_arith_ineq_checks_to_eq:\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a + sint b)) \\<and> (sint a + sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a + sint b = sint (a + b ))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a - sint b)) \\<and> (sint a - sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a - sint b = sint (a - b))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (- sint a)) \\<and> (- sint a) \\<le> (2 ^ (size a - 1) - 1))\n    = ((- sint a) = sint (- a))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a * sint b)) \\<and> (sint a * sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a * sint b = sint (a * b))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a sdiv sint b)) \\<and> (sint a sdiv sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a sdiv sint b = sint (a sdiv b))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a smod sint b)) \\<and> (sint a smod sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a smod sint b = sint (a smod b))\"", "lemma signed_arith_sint:\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a + sint b)) \\<and> (sint a + sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a + b) = (sint a + sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a - sint b)) \\<and> (sint a - sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a - b) = (sint a - sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (- sint a)) \\<and> (- sint a) \\<le> (2 ^ (size a - 1) - 1))\n    \\<Longrightarrow> sint (- a) = (- sint a)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a * sint b)) \\<and> (sint a * sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a * b) = (sint a * sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a sdiv sint b)) \\<and> (sint a sdiv sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a sdiv b) = (sint a sdiv sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a smod sint b)) \\<and> (sint a smod sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a smod b) = (sint a smod sint b)\""], "translations": [["", "lemma bitfield_op_twice:\n  \"(x AND NOT (mask n << m) OR ((y AND mask n) << m)) AND NOT (mask n << m) = x AND NOT (mask n << m)\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND NOT (mask n << m) OR (y AND mask n << m)) AND NOT (mask n << m) =\n    x AND NOT (mask n << m)", "by (induct n arbitrary: m) (auto simp: word_ao_dist)"], ["", "lemma bitfield_op_twice'':\n  \"\\<lbrakk>NOT a = b << c; \\<exists>x. b = mask x\\<rbrakk> \\<Longrightarrow> (x AND a OR (y AND b << c)) AND a = x AND a\"\n  for a b :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NOT a = b << c; \\<exists>x. b = mask x\\<rbrakk>\n    \\<Longrightarrow> (x AND a OR (y AND b << c)) AND a = x AND a", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>NOT a = mask xa << c; b = mask xa\\<rbrakk>\n       \\<Longrightarrow> (x AND a OR (y AND mask xa << c)) AND a = x AND a", "apply (cut_tac n=xa and m=c and x=x and y=y in bitfield_op_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>NOT a = mask xa << c; b = mask xa;\n        (x AND NOT (mask xa << c) OR (y AND mask xa << c)) AND\n        NOT (mask xa << c) =\n        x AND NOT (mask xa << c)\\<rbrakk>\n       \\<Longrightarrow> (x AND a OR (y AND mask xa << c)) AND a = x AND a", "apply (clarsimp simp:mask_eq_decr_exp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>NOT a = 2 ^ xa - 1 << c; b = 2 ^ xa - 1;\n        (x AND NOT (2 ^ xa - 1 << c) OR (y AND 2 ^ xa - 1 << c)) AND\n        NOT (2 ^ xa - 1 << c) =\n        x AND NOT (2 ^ xa - 1 << c)\\<rbrakk>\n       \\<Longrightarrow> (x AND a OR (y AND 2 ^ xa - 1 << c)) AND a =\n                         x AND a", "apply (drule not_switch)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>b = 2 ^ xa - 1;\n        (x AND NOT (2 ^ xa - 1 << c) OR (y AND 2 ^ xa - 1 << c)) AND\n        NOT (2 ^ xa - 1 << c) =\n        x AND NOT (2 ^ xa - 1 << c);\n        a = NOT (2 ^ xa - 1 << c)\\<rbrakk>\n       \\<Longrightarrow> (x AND a OR (y AND 2 ^ xa - 1 << c)) AND a =\n                         x AND a", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bit_twiddle_min:\n  \"(y::'a::len word) XOR (((x::'a::len word) XOR y) AND (if x < y then -1 else 0)) = min x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y XOR (x XOR y) AND (if x < y then - 1 else 0) = min x y", "by (auto simp add: Parity.bit_eq_iff bit_xor_iff min_def)"], ["", "lemma bit_twiddle_max:\n  \"(x::'a::len word) XOR (((x::'a::len word) XOR y) AND (if x < y then -1 else 0)) = max x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x XOR (x XOR y) AND (if x < y then - 1 else 0) = max x y", "by (auto simp add: Parity.bit_eq_iff bit_xor_iff max_def)"], ["", "lemma swap_with_xor:\n  \"\\<lbrakk>(x::'a::len word) = a XOR b; y = b XOR x; z = x XOR y\\<rbrakk> \\<Longrightarrow> z = b \\<and> y = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = a XOR b; y = b XOR x; z = x XOR y\\<rbrakk>\n    \\<Longrightarrow> z = b \\<and> y = a", "by (auto simp add: Parity.bit_eq_iff bit_xor_iff max_def)"], ["", "lemma scast_nop1 [simp]:\n  \"((scast ((of_int x)::('a::len) word))::'a sword) = of_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a \\<rightarrow> 'a signed) (word_of_int x) = word_of_int x", "apply (simp only: scast_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (sint (word_of_int x)) = word_of_int x", "by (metis len_signed sint_sbintrunc' word_sint.Rep_inverse)"], ["", "lemma scast_nop2 [simp]:\n  \"((scast ((of_int x)::('a::len) sword))::'a word) = of_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a signed \\<rightarrow> 'a) (word_of_int x) = word_of_int x", "apply (simp only: scast_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (sint (word_of_int x)) = word_of_int x", "by (metis len_signed sint_sbintrunc' word_sint.Rep_inverse)"], ["", "lemmas scast_nop = scast_nop1 scast_nop2 scast_id"], ["", "lemma le_mask_imp_and_mask:\n  \"(x::'a::len word) \\<le> mask n \\<Longrightarrow> x AND mask n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> mask n \\<Longrightarrow> x AND mask n = x", "by (metis and_mask_eq_iff_le_mask)"], ["", "lemma or_not_mask_nop:\n  \"((x::'a::len word) OR NOT (mask n)) AND mask n = x AND mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR NOT (mask n)) AND mask n = x AND mask n", "by (metis word_and_not word_ao_dist2 word_bw_comms(1) word_log_esimps(3))"], ["", "lemma mask_subsume:\n  \"\\<lbrakk>n \\<le> m\\<rbrakk> \\<Longrightarrow> ((x::'a::len word) OR y AND mask n) AND NOT (mask m) = x AND NOT (mask m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    (x OR y AND mask n) AND NOT (mask m) = x AND NOT (mask m)", "by (auto simp add: Parity.bit_eq_iff bit_not_iff bit_or_iff bit_and_iff bit_mask_iff)"], ["", "lemma and_mask_0_iff_le_mask:\n  fixes w :: \"'a::len word\"\n  shows \"(w AND NOT(mask n) = 0) = (w \\<le> mask n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND NOT (mask n) = 0) = (w \\<le> mask n)", "by (simp add: mask_eq_0_eq_x le_mask_imp_and_mask and_mask_eq_iff_le_mask)"], ["", "lemma mask_twice2:\n  \"n \\<le> m \\<Longrightarrow> ((x::'a::len word) AND mask m) AND mask n = x AND mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> (x AND mask m) AND mask n = x AND mask n", "by (metis mask_twice min_def)"], ["", "lemma uint_2_id:\n  \"LENGTH('a) \\<ge> 2 \\<Longrightarrow> uint (2::('a::len) word) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> LENGTH('a) \\<Longrightarrow> uint 2 = 2", "by simp"], ["", "lemma bintrunc_id:\n  \"\\<lbrakk>m \\<le> of_nat n; 0 < m\\<rbrakk> \\<Longrightarrow> bintrunc n m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> int n; 0 < m\\<rbrakk>\n    \\<Longrightarrow> take_bit n m = m", "by (simp add: bintrunc_mod2p le_less_trans)"], ["", "lemma shiftr1_unfold: \"shiftr1 x = x >> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftr1 x = x >> 1", "by (metis One_nat_def comp_apply funpow.simps(1) funpow.simps(2) id_apply shiftr_def)"], ["", "lemma shiftr1_is_div_2: \"(x::('a::len) word) >> 1 = x div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> 1 = x div 2", "by transfer (simp add: drop_bit_Suc)"], ["", "lemma shiftl1_is_mult: \"(x << 1) = (x :: 'a::len word) * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x << 1 = x * 2", "by (metis One_nat_def mult_2 mult_2_right one_add_one\n        power_0 power_Suc shiftl_t2n)"], ["", "lemma div_of_0_id[simp]:\"(0::('a::len) word) div n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 div n = 0", "by (simp add: word_div_def)"], ["", "lemma degenerate_word:\"LENGTH('a) = 1 \\<Longrightarrow> (x::('a::len) word) = 0 \\<or> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) = 1 \\<Longrightarrow> x = 0 \\<or> x = 1", "by (metis One_nat_def less_irrefl_nat sint_1_cases)"], ["", "lemma div_by_0_word:\"(x::('a::len) word) div 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div 0 = 0", "by (metis div_0 div_by_0 unat_0 word_arith_nat_defs(6) word_div_1)"], ["", "lemma div_less_dividend_word:\"\\<lbrakk>x \\<noteq> 0; n \\<noteq> 1\\<rbrakk> \\<Longrightarrow> (x::('a::len) word) div n < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> x div n < x", "apply (cases \\<open>n = 0\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n = 0\\<rbrakk>\n    \\<Longrightarrow> x div n < x\n 2. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x div n < x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> 0; n = 0\\<rbrakk> \\<Longrightarrow> 0 < x\n 2. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x div n < x", "apply (simp add:word_neq_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x div n < x", "apply (subst word_arith_nat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (unat x div unat n) < x", "apply (rule word_of_nat_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x div unat n < unat x", "apply (rule div_less_dividend)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 1 < unat n\n 2. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < unat x", "using unat_eq_zero word_unat_Rep_inject1"], ["proof (prove)\nusing this:\n  (unat ?x = 0) = (?x = 0)\n  (unat ?x = unat 1) = (?x = 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 1 < unat n\n 2. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < unat x", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; n \\<noteq> 1; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < unat x", "apply (simp add:unat_gt_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr1_lt:\"x \\<noteq> 0 \\<Longrightarrow> (x::('a::len) word) >> 1 < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x >> 1 < x", "apply (subst shiftr1_is_div_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x div 2 < x", "apply (rule div_less_dividend_word)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0\n 2. x \\<noteq> 0 \\<Longrightarrow> 2 \\<noteq> 1", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_less_div:\n  fixes x :: \"('a::len) word\"\n    and y :: \"('a::len) word\"\n  shows \"x div y = 0 \\<Longrightarrow> y = 0 \\<or> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = 0 \\<Longrightarrow> y = 0 \\<or> x < y", "apply (case_tac \"y = 0\", clarsimp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x div y = 0; y \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x < y", "by (metis One_nat_def Suc_le_mono le0 le_div_geq not_less unat_0 unat_div unat_gt_0 word_less_nat_alt zero_less_one)"], ["", "lemma not_degenerate_imp_2_neq_0:\"LENGTH('a) > 1 \\<Longrightarrow> (2::('a::len) word) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < LENGTH('a) \\<Longrightarrow> 2 \\<noteq> 0", "by (metis numerals(1) power_not_zero power_zero_numeral)"], ["", "lemma shiftr1_0_or_1:\"(x::('a::len) word) >> 1 = 0 \\<Longrightarrow> x = 0 \\<or> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> 1 = 0 \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (subst (asm) shiftr1_is_div_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div 2 = 0 \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (drule word_less_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = 0 \\<or> x < 2 \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (case_tac \"LENGTH('a) = 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 = 0 \\<or> x < 2; LENGTH('a) = 1\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1\n 2. \\<lbrakk>2 = 0 \\<or> x < 2; LENGTH('a) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (simp add:degenerate_word)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 = 0 \\<or> x < 2; LENGTH('a) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1\n 2. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (subgoal_tac \"(2::'a word) \\<noteq> 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0; 2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1\n 2. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0\\<rbrakk>\n    \\<Longrightarrow> 2 \\<noteq> 0\n 3. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0\\<rbrakk>\n    \\<Longrightarrow> 2 \\<noteq> 0\n 2. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (rule not_degenerate_imp_2_neq_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0\\<rbrakk>\n    \\<Longrightarrow> 1 < LENGTH('a)\n 2. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (subgoal_tac \"LENGTH('a) \\<noteq> 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0; LENGTH('a) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 1 < LENGTH('a)\n 2. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0\\<rbrakk>\n    \\<Longrightarrow> LENGTH('a) \\<noteq> 0\n 3. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply arith"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; 2 = 0\\<rbrakk>\n    \\<Longrightarrow> LENGTH('a) \\<noteq> 0\n 2. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (rule x_less_2_0_1', simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_overflow:\"(x::('a::len) word) + 1 > x \\<or> x + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < x + 1 \\<or> x + 1 = 0", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 1 \\<noteq> 0 \\<Longrightarrow> x < x + 1", "by (metis diff_0 eq_diff_eq less_x_plus_1)"], ["", "lemma word_overflow_unat:\"unat ((x::('a::len) word) + 1) = unat x + 1 \\<or> x + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (x + 1) = unat x + 1 \\<or> x + 1 = 0", "by (metis Suc_eq_plus1 add.commute unatSuc)"], ["", "lemma even_word_imp_odd_next:\"even (unat (x::('a::len) word)) \\<Longrightarrow> x + 1 = 0 \\<or> odd (unat (x + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (unat x) \\<Longrightarrow> x + 1 = 0 \\<or> odd (unat (x + 1))", "apply (cut_tac x=x in word_overflow_unat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (unat x);\n     unat (x + 1) = unat x + 1 \\<or> x + 1 = 0\\<rbrakk>\n    \\<Longrightarrow> x + 1 = 0 \\<or> odd (unat (x + 1))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma odd_word_imp_even_next:\"odd (unat (x::('a::len) word)) \\<Longrightarrow> x + 1 = 0 \\<or> even (unat (x + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (unat x) \\<Longrightarrow> x + 1 = 0 \\<or> even (unat (x + 1))", "apply (cut_tac x=x in word_overflow_unat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (unat x);\n     unat (x + 1) = unat x + 1 \\<or> x + 1 = 0\\<rbrakk>\n    \\<Longrightarrow> x + 1 = 0 \\<or> even (unat (x + 1))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma overflow_imp_lsb:\"(x::('a::len) word) + 1 = 0 \\<Longrightarrow> x !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 1 = 0 \\<Longrightarrow> x !! 0", "using even_plus_one_iff [of x]"], ["proof (prove)\nusing this:\n  even (x + 1) = odd x\n\ngoal (1 subgoal):\n 1. x + 1 = 0 \\<Longrightarrow> x !! 0", "by (simp add: test_bit_word_eq)"], ["", "lemma odd_iff_lsb:\"odd (unat (x::('a::len) word)) = x !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (unat x) = x !! 0", "by transfer (simp add: even_nat_iff)"], ["", "lemma of_nat_neq_iff_word:\n      \"x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a) \\<Longrightarrow>\n         (((of_nat x)::('a::len) word) \\<noteq> of_nat y) = (x \\<noteq> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a) \\<Longrightarrow>\n    (word_of_nat x \\<noteq> word_of_nat y) = (x \\<noteq> y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     word_of_nat x \\<noteq> word_of_nat y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y", "apply (case_tac \"x = y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     word_of_nat x \\<noteq> word_of_nat y; x = y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     word_of_nat x \\<noteq> word_of_nat y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 3. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y", "apply (subst (asm) of_nat_eq_iff[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>of_nat (x mod 2 ^ LENGTH('a)) \\<noteq>\n             of_nat (y mod 2 ^ LENGTH('a));\n     word_of_nat x \\<noteq> word_of_nat y; x = y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     word_of_nat x \\<noteq> word_of_nat y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 3. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y", "apply (case_tac \"((of_nat x)::('a::len) word) = of_nat y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y; word_of_nat x = word_of_nat y\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y\n 2. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y; word_of_nat x \\<noteq> word_of_nat y\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y", "apply (subst (asm) word_unat.norm_eq_iff[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y; x mod 2 ^ LENGTH('a) = y mod 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y\n 2. \\<lbrakk>x mod 2 ^ LENGTH('a) \\<noteq> y mod 2 ^ LENGTH('a);\n     x \\<noteq> y; word_of_nat x \\<noteq> word_of_nat y\\<rbrakk>\n    \\<Longrightarrow> word_of_nat x \\<noteq> word_of_nat y", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr1_irrelevant_lsb:\"(x::('a::len) word) !! 0 \\<or> x >> 1 = (x + 1) >> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x !! 0 \\<or> x >> 1 = x + 1 >> 1", "apply (cases \\<open>LENGTH('a)\\<close>; transfer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       LENGTH('a) = 0 \\<Longrightarrow>\n       0 < LENGTH('a) \\<and> bit x 0 \\<or>\n       take_bit LENGTH('a) ((drop_bit 1 \\<circ> take_bit LENGTH('a)) x) =\n       take_bit LENGTH('a)\n        ((drop_bit 1 \\<circ> take_bit LENGTH('a)) (x + 1))\n 2. \\<And>nat x.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       0 < LENGTH('a) \\<and> bit x 0 \\<or>\n       take_bit LENGTH('a) ((drop_bit 1 \\<circ> take_bit LENGTH('a)) x) =\n       take_bit LENGTH('a)\n        ((drop_bit 1 \\<circ> take_bit LENGTH('a)) (x + 1))", "apply (simp_all add: take_bit_drop_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat x.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       even x \\<longrightarrow>\n       drop_bit (Suc 0) (take_bit (Suc nat) x) =\n       drop_bit (Suc 0) (take_bit (Suc nat) (x + 1))", "apply (simp add: drop_bit_take_bit drop_bit_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr1_0_imp_only_lsb:\"((x::('a::len) word) + 1) >> 1 = 0 \\<Longrightarrow> x = 0 \\<or> x + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 1 >> 1 = 0 \\<Longrightarrow> x = 0 \\<or> x + 1 = 0", "by (metis One_nat_def shiftr1_0_or_1 word_less_1 word_overflow)"], ["", "lemma shiftr1_irrelevant_lsb':\"\\<not>((x::('a::len) word) !! 0) \\<Longrightarrow> x >> 1 = (x + 1) >> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x !! 0 \\<Longrightarrow> x >> 1 = x + 1 >> 1", "by (metis shiftr1_irrelevant_lsb)"], ["", "lemma lsb_this_or_next:\"\\<not>(((x::('a::len) word) + 1) !! 0) \\<Longrightarrow> x !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (x + 1) !! 0 \\<Longrightarrow> x !! 0", "by (metis (poly_guards_query) even_word_imp_odd_next odd_iff_lsb overflow_imp_lsb)"], ["", "(* Perhaps this one should be a simp lemma, but it seems a little dangerous. *)"], ["", "lemma cast_chunk_assemble_id:\n  \"\\<lbrakk>n = LENGTH('a::len); m = LENGTH('b::len); n * 2 = m\\<rbrakk> \\<Longrightarrow>\n  (((ucast ((ucast (x::'b word))::'a word))::'b word) OR (((ucast ((ucast (x >> n))::'a word))::'b word) << n)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) x) OR\n                      (UCAST('a \\<rightarrow> 'b)\n                        (UCAST('b \\<rightarrow> 'a) (x >> n)) <<\n                       n) =\n                      x", "apply (subgoal_tac \"((ucast ((ucast (x >> n))::'a word))::'b word) = x >> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m;\n     UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) (x >> n)) =\n     x >> n\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) x) OR\n                      (UCAST('a \\<rightarrow> 'b)\n                        (UCAST('b \\<rightarrow> 'a) (x >> n)) <<\n                       n) =\n                      x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) (x >> n)) =\n                      x >> n", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); LENGTH('a) * 2 = LENGTH('b);\n     UCAST('a \\<rightarrow> 'b)\n      (UCAST('b \\<rightarrow> 'a) (x >> LENGTH('a))) =\n     x >> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) x) OR\n                      (x >> LENGTH('a) << LENGTH('a)) =\n                      x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) (x >> n)) =\n                      x >> n", "apply (subst and_not_mask[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); LENGTH('a) * 2 = LENGTH('b);\n     UCAST('a \\<rightarrow> 'b)\n      (UCAST('b \\<rightarrow> 'a) (x >> LENGTH('a))) =\n     x >> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) x) OR\n                      x AND NOT (mask LENGTH('a)) =\n                      x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) (x >> n)) =\n                      x >> n", "apply (subst ucast_ucast_mask)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); LENGTH('a) * 2 = LENGTH('b);\n     UCAST('a \\<rightarrow> 'b)\n      (UCAST('b \\<rightarrow> 'a) (x >> LENGTH('a))) =\n     x >> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND mask LENGTH('a) OR x AND NOT (mask LENGTH('a)) =\n                      x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) (x >> n)) =\n                      x >> n", "apply (subst word_ao_dist2[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); LENGTH('a) * 2 = LENGTH('b);\n     UCAST('a \\<rightarrow> 'b)\n      (UCAST('b \\<rightarrow> 'a) (x >> LENGTH('a))) =\n     x >> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND (mask LENGTH('a) OR NOT (mask LENGTH('a))) = x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) (x >> n)) =\n                      x >> n", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('b \\<rightarrow> 'a) (x >> n)) =\n                      x >> n", "apply (rule ucast_ucast_len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> x >> n < 2 ^ LENGTH('a)", "apply (rule shiftr_less_t2n')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> x AND mask (n + LENGTH('a)) = x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> LENGTH('a) < LENGTH('b)", "apply (subst and_mask_eq_iff_le_mask)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> x \\<le> mask (n + LENGTH('a))\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> LENGTH('a) < LENGTH('b)", "apply (simp_all add: mask_eq_decr_exp flip: mult_2_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b);\n     LENGTH('a) * 2 = LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> LENGTH('a) < LENGTH('b)", "apply (metis add_diff_cancel_left' len_gt_0 mult_2_right zero_less_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cast_chunk_scast_assemble_id:\n  \"\\<lbrakk>n = LENGTH('a::len); m = LENGTH('b::len); n * 2 = m\\<rbrakk> \\<Longrightarrow>\n  (((ucast ((scast (x::'b word))::'a word))::'b word) OR\n   (((ucast ((scast (x >> n))::'a word))::'b word) << n)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (SCAST('b \\<rightarrow> 'a) x) OR\n                      (UCAST('a \\<rightarrow> 'b)\n                        (SCAST('b \\<rightarrow> 'a) (x >> n)) <<\n                       n) =\n                      x", "apply (subgoal_tac \"((scast x)::'a word) = ((ucast x)::'a word)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m;\n     SCAST('b \\<rightarrow> 'a) x = UCAST('b \\<rightarrow> 'a) x\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (SCAST('b \\<rightarrow> 'a) x) OR\n                      (UCAST('a \\<rightarrow> 'b)\n                        (SCAST('b \\<rightarrow> 'a) (x >> n)) <<\n                       n) =\n                      x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'a) x =\n                      UCAST('b \\<rightarrow> 'a) x", "apply (subgoal_tac \"((scast (x >> n))::'a word) = ((ucast (x >> n))::'a word)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m;\n     SCAST('b \\<rightarrow> 'a) x = UCAST('b \\<rightarrow> 'a) x;\n     SCAST('b \\<rightarrow> 'a) (x >> n) =\n     UCAST('b \\<rightarrow> 'a) (x >> n)\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (SCAST('b \\<rightarrow> 'a) x) OR\n                      (UCAST('a \\<rightarrow> 'b)\n                        (SCAST('b \\<rightarrow> 'a) (x >> n)) <<\n                       n) =\n                      x\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m;\n     SCAST('b \\<rightarrow> 'a) x = UCAST('b \\<rightarrow> 'a) x\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'a) (x >> n) =\n                      UCAST('b \\<rightarrow> 'a) (x >> n)\n 3. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'a) x =\n                      UCAST('b \\<rightarrow> 'a) x", "apply (simp add:cast_chunk_assemble_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m;\n     SCAST('b \\<rightarrow> 'a) x = UCAST('b \\<rightarrow> 'a) x\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'a) (x >> n) =\n                      UCAST('b \\<rightarrow> 'a) (x >> n)\n 2. \\<lbrakk>n = LENGTH('a); m = LENGTH('b); n * 2 = m\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'a) x =\n                      UCAST('b \\<rightarrow> 'a) x", "apply (subst down_cast_same[symmetric], subst is_down, arith, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_or_not_mask:\n  \"x AND mask n OR x AND NOT (mask n) = x\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND mask n OR x AND NOT (mask n) = x", "apply (subst word_oa_dist, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND (mask n OR x AND NOT (mask n)) = x", "apply (subst word_oa_dist2, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_add_not_aligned:\n  \"\\<lbrakk>is_aligned (p::'a::len word) n; \\<not> is_aligned (q::'a::len word) n\\<rbrakk> \\<Longrightarrow> \\<not> is_aligned (p + q) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; \\<not> is_aligned q n\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_aligned (p + q) n", "by (metis is_aligned_addD1)"], ["", "lemma word_gr0_conv_Suc: \"(m::'a::len word) > 0 \\<Longrightarrow> \\<exists>n. m = n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> \\<exists>n. m = n + 1", "by (metis add.commute add_minus_cancel)"], ["", "lemma neg_mask_add_aligned:\n  \"\\<lbrakk> is_aligned p n; q < 2 ^ n \\<rbrakk> \\<Longrightarrow> (p + q) AND NOT (mask n) = p AND NOT (mask n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; q < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> p + q AND NOT (mask n) = p AND NOT (mask n)", "by (metis is_aligned_add_helper is_aligned_neg_mask_eq)"], ["", "lemma word_sless_sint_le:\"x <s y \\<Longrightarrow> sint x \\<le> sint y - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x <s y \\<Longrightarrow> sint x \\<le> sint y - 1", "by (metis word_sless_alt zle_diff1_eq)"], ["", "lemma upper_trivial:\n  fixes x :: \"'a::len word\"\n  shows \"x \\<noteq> 2 ^ LENGTH('a) - 1 \\<Longrightarrow> x < 2 ^ LENGTH('a) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 2 ^ LENGTH('a) - 1 \\<Longrightarrow> x < 2 ^ LENGTH('a) - 1", "by (simp add: less_le)"], ["", "lemma constraint_expand:\n  fixes x :: \"'a::len word\"\n  shows \"x \\<in> {y. lower \\<le> y \\<and> y \\<le> upper} = (lower \\<le> x \\<and> x \\<le> upper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {y. lower \\<le> y \\<and> y \\<le> upper}) =\n    (lower \\<le> x \\<and> x \\<le> upper)", "by (rule mem_Collect_eq)"], ["", "lemma card_map_elide:\n  \"card ((of_nat :: nat \\<Rightarrow> 'a::len word) ` {0..<n}) = card {0..<n}\"\n    if \"n \\<le> CARD('a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "let ?of_nat = \"of_nat :: nat \\<Rightarrow> 'a word\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "from word_unat.Abs_inj_on"], ["proof (chain)\npicking this:\n  inj_on word_of_nat (unats LENGTH(?'a))", "have \"inj_on ?of_nat {i. i < CARD('a word)}\""], ["proof (prove)\nusing this:\n  inj_on word_of_nat (unats LENGTH(?'a))\n\ngoal (1 subgoal):\n 1. inj_on word_of_nat {i. i < CARD('a word)}", "by (simp add: unats_def card_word)"], ["proof (state)\nthis:\n  inj_on word_of_nat {i. i < CARD('a word)}\n\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "moreover"], ["proof (state)\nthis:\n  inj_on word_of_nat {i. i < CARD('a word)}\n\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "have \"{0..<n} \\<subseteq> {i. i < CARD('a word)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} \\<subseteq> {i. i < CARD('a word)}", "using that"], ["proof (prove)\nusing this:\n  n \\<le> CARD('a word)\n\ngoal (1 subgoal):\n 1. {0..<n} \\<subseteq> {i. i < CARD('a word)}", "by auto"], ["proof (state)\nthis:\n  {0..<n} \\<subseteq> {i. i < CARD('a word)}\n\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "ultimately"], ["proof (chain)\npicking this:\n  inj_on word_of_nat {i. i < CARD('a word)}\n  {0..<n} \\<subseteq> {i. i < CARD('a word)}", "have \"inj_on ?of_nat {0..<n}\""], ["proof (prove)\nusing this:\n  inj_on word_of_nat {i. i < CARD('a word)}\n  {0..<n} \\<subseteq> {i. i < CARD('a word)}\n\ngoal (1 subgoal):\n 1. inj_on word_of_nat {0..<n}", "by (rule inj_on_subset)"], ["proof (state)\nthis:\n  inj_on word_of_nat {0..<n}\n\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "then"], ["proof (chain)\npicking this:\n  inj_on word_of_nat {0..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on word_of_nat {0..<n}\n\ngoal (1 subgoal):\n 1. card (word_of_nat ` {0..<n}) = card {0..<n}", "by (simp add: card_image)"], ["proof (state)\nthis:\n  card (word_of_nat ` {0..<n}) = card {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_map_elide2:\n  \"n \\<le> CARD('a::len word) \\<Longrightarrow> card ((of_nat::nat \\<Rightarrow> 'a::len word) ` {0..<n}) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> CARD('a word) \\<Longrightarrow> card (word_of_nat ` {0..<n}) = n", "by (subst card_map_elide) clarsimp+"], ["", "lemma le_max_word_ucast_id:\n  \\<open>UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x\\<close>\n    if \\<open>x \\<le> UCAST('b::len \\<rightarrow> 'a) (- 1)\\<close>\n    for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "from that"], ["proof (chain)\npicking this:\n  x \\<le> UCAST('b \\<rightarrow> 'a) (- 1)", "have a1: \\<open>x \\<le> word_of_int (uint (word_of_int (2 ^ LENGTH('b) - 1) :: 'b word))\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> UCAST('b \\<rightarrow> 'a) (- 1)\n\ngoal (1 subgoal):\n 1. x \\<le> word_of_int (uint (word_of_int (2 ^ LENGTH('b) - 1)))", "by simp"], ["proof (state)\nthis:\n  x \\<le> word_of_int (uint (word_of_int (2 ^ LENGTH('b) - 1)))\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "have f2: \"((\\<exists>i ia. (0::int) \\<le> i \\<and> \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n            \\<not> (0::int) \\<le> - 1 + 2 ^ LENGTH('b) \\<or> (0::int) \\<le> - 1 + 2 ^ LENGTH('b) + - 1 * 2 ^ LENGTH('b) \\<or>\n            (- (1::int) + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) =\n              - 1 + 2 ^ LENGTH('b)) = ((\\<exists>i ia. (0::int) \\<le> i \\<and> \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n            \\<not> (1::int) \\<le> 2 ^ LENGTH('b) \\<or>\n            2 ^ LENGTH('b) + - (1::int) * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>i ia.\n         0 \\<le> i \\<and>\n         \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n     \\<not> 0 \\<le> - 1 + 2 ^ LENGTH('b) \\<or>\n     0 \\<le> - 1 + 2 ^ LENGTH('b) + - 1 * 2 ^ LENGTH('b) \\<or>\n     (- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) = - 1 + 2 ^ LENGTH('b)) =\n    ((\\<exists>i ia.\n         0 \\<le> i \\<and>\n         \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n     \\<not> 1 \\<le> 2 ^ LENGTH('b) \\<or>\n     2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1)", "by force"], ["proof (state)\nthis:\n  ((\\<exists>i ia.\n       0 \\<le> i \\<and>\n       \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n   \\<not> 0 \\<le> - 1 + 2 ^ LENGTH('b) \\<or>\n   0 \\<le> - 1 + 2 ^ LENGTH('b) + - 1 * 2 ^ LENGTH('b) \\<or>\n   (- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) = - 1 + 2 ^ LENGTH('b)) =\n  ((\\<exists>i ia.\n       0 \\<le> i \\<and>\n       \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n   \\<not> 1 \\<le> 2 ^ LENGTH('b) \\<or>\n   2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1)\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "have f3: \"\\<forall>i ia. \\<not> (0::int) \\<le> i \\<or> 0 \\<le> i + - 1 * ia \\<or> i mod ia = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       \\<not> 0 \\<le> i \\<or> 0 \\<le> i + - 1 * ia \\<or> i mod ia = i", "using mod_pos_pos_trivial"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?k; ?k < ?l\\<rbrakk> \\<Longrightarrow> ?k mod ?l = ?k\n\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       \\<not> 0 \\<le> i \\<or> 0 \\<le> i + - 1 * ia \\<or> i mod ia = i", "by force"], ["proof (state)\nthis:\n  \\<forall>i ia.\n     \\<not> 0 \\<le> i \\<or> 0 \\<le> i + - 1 * ia \\<or> i mod ia = i\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "have \"(1::int) \\<le> 2 ^ LENGTH('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> 2 ^ LENGTH('b)", "by simp"], ["proof (state)\nthis:\n  1 \\<le> 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "then"], ["proof (chain)\npicking this:\n  1 \\<le> 2 ^ LENGTH('b)", "have \"2 ^ LENGTH('b) + - (1::int) * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ len_of TYPE ('b)) = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1", "using f3 f2"], ["proof (prove)\nusing this:\n  1 \\<le> 2 ^ LENGTH('b)\n  \\<forall>i ia.\n     \\<not> 0 \\<le> i \\<or> 0 \\<le> i + - 1 * ia \\<or> i mod ia = i\n  ((\\<exists>i ia.\n       0 \\<le> i \\<and>\n       \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n   \\<not> 0 \\<le> - 1 + 2 ^ LENGTH('b) \\<or>\n   0 \\<le> - 1 + 2 ^ LENGTH('b) + - 1 * 2 ^ LENGTH('b) \\<or>\n   (- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) = - 1 + 2 ^ LENGTH('b)) =\n  ((\\<exists>i ia.\n       0 \\<le> i \\<and>\n       \\<not> 0 \\<le> i + - 1 * ia \\<and> i mod ia \\<noteq> i) \\<or>\n   \\<not> 1 \\<le> 2 ^ LENGTH('b) \\<or>\n   2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1)\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1", "by blast"], ["proof (state)\nthis:\n  2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "then"], ["proof (chain)\npicking this:\n  2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1", "have f4: \"- (1::int) + 2 ^ LENGTH('b) = (- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)\""], ["proof (prove)\nusing this:\n  2 ^ LENGTH('b) + - 1 * ((- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)) = 1\n\ngoal (1 subgoal):\n 1. - 1 + 2 ^ LENGTH('b) = (- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)", "by linarith"], ["proof (state)\nthis:\n  - 1 + 2 ^ LENGTH('b) = (- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "have f5: \"x \\<le> word_of_int (uint (word_of_int (- 1 + 2 ^ LENGTH('b))::'b word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> word_of_int (uint (word_of_int (- 1 + 2 ^ LENGTH('b))))", "using a1"], ["proof (prove)\nusing this:\n  x \\<le> word_of_int (uint (word_of_int (2 ^ LENGTH('b) - 1)))\n\ngoal (1 subgoal):\n 1. x \\<le> word_of_int (uint (word_of_int (- 1 + 2 ^ LENGTH('b))))", "by force"], ["proof (state)\nthis:\n  x \\<le> word_of_int (uint (word_of_int (- 1 + 2 ^ LENGTH('b))))\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "have f6: \"2 ^ LENGTH('b) + - (1::int) = - 1 + 2 ^ LENGTH('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('b) + - 1 = - 1 + 2 ^ LENGTH('b)", "by force"], ["proof (state)\nthis:\n  2 ^ LENGTH('b) + - 1 = - 1 + 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "have f7: \"- (1::int) * 1 = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 * 1 = - 1", "by auto"], ["proof (state)\nthis:\n  - 1 * 1 = - 1\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "have \"\\<forall>x0 x1. (x1::int) - x0 = x1 + - 1 * x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x1. x1 - x0 = x1 + - 1 * x0", "by force"], ["proof (state)\nthis:\n  \\<forall>x0 x1. x1 - x0 = x1 + - 1 * x0\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1. x1 - x0 = x1 + - 1 * x0", "have \"x \\<le> 2 ^ LENGTH('b) - 1\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1. x1 - x0 = x1 + - 1 * x0\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ LENGTH('b) - 1", "using f7 f6 f5 f4"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1. x1 - x0 = x1 + - 1 * x0\n  - 1 * 1 = - 1\n  2 ^ LENGTH('b) + - 1 = - 1 + 2 ^ LENGTH('b)\n  x \\<le> word_of_int (uint (word_of_int (- 1 + 2 ^ LENGTH('b))))\n  - 1 + 2 ^ LENGTH('b) = (- 1 + 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ LENGTH('b) - 1", "by (metis uint_word_of_int wi_homs(2) word_arith_wis(8) word_of_int_2p)"], ["proof (state)\nthis:\n  x \\<le> 2 ^ LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "then"], ["proof (chain)\npicking this:\n  x \\<le> 2 ^ LENGTH('b) - 1", "have \\<open>uint x \\<le> uint (2 ^ LENGTH('b) - (1 :: 'a word))\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> 2 ^ LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. uint x \\<le> uint (2 ^ LENGTH('b) - 1)", "by (simp add: word_le_def)"], ["proof (state)\nthis:\n  uint x \\<le> uint (2 ^ LENGTH('b) - 1)\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "then"], ["proof (chain)\npicking this:\n  uint x \\<le> uint (2 ^ LENGTH('b) - 1)", "have \\<open>uint x \\<le> 2 ^ LENGTH('b) - 1\\<close>"], ["proof (prove)\nusing this:\n  uint x \\<le> uint (2 ^ LENGTH('b) - 1)\n\ngoal (1 subgoal):\n 1. uint x \\<le> 2 ^ LENGTH('b) - 1", "by (simp add: uint_word_ariths)\n      (metis \\<open>1 \\<le> 2 ^ LENGTH('b)\\<close> \\<open>uint x \\<le> uint (2 ^ LENGTH('b) - 1)\\<close> linorder_not_less lt2p_lem uint_1 uint_minus_simple_alt uint_power_lower word_le_def zle_diff1_eq)"], ["proof (state)\nthis:\n  uint x \\<le> 2 ^ LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "then"], ["proof (chain)\npicking this:\n  uint x \\<le> 2 ^ LENGTH('b) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  uint x \\<le> 2 ^ LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x", "apply (simp add: word_ubin.eq_norm bintrunc_mod2p unsigned_ucast_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint x < 2 ^ LENGTH('b) \\<Longrightarrow> take_bit LENGTH('b) x = x", "apply (metis \\<open>x \\<le> 2 ^ LENGTH('b) - 1\\<close> and_mask_eq_iff_le_mask mask_eq_decr_exp take_bit_eq_mask)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remdups_enum_upto:\n  fixes s::\"'a::len word\"\n  shows \"remdups [s .e. e] = [s .e. e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups [s .e. e] = [s .e. e]", "by simp"], ["", "lemma card_enum_upto:\n  fixes s::\"'a::len word\"\n  shows \"card (set [s .e. e]) = Suc (unat e) - unat s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set [s .e. e]) = Suc (unat e) - unat s", "by (subst List.card_set) (simp add: remdups_enum_upto)"], ["", "lemma complement_nth_w2p:\n  shows \"n' < LENGTH('a) \\<Longrightarrow> (NOT (2 ^ n :: 'a::len word)) !! n' = (n' \\<noteq> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' < LENGTH('a) \\<Longrightarrow> NOT (2 ^ n) !! n' = (n' \\<noteq> n)", "by (fastforce simp: word_ops_nth_size word_size nth_w2p)"], ["", "lemma word_unat_and_lt:\n  \"unat x < n \\<or> unat y < n \\<Longrightarrow> unat (x AND y) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < n \\<or> unat y < n \\<Longrightarrow> unat (x AND y) < n", "by (meson le_less_trans word_and_le1 word_and_le2 word_le_nat_alt)"], ["", "lemma word_unat_mask_lt:\n  \"m \\<le> size w \\<Longrightarrow> unat ((w::'a::len word) AND mask m) < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> size w \\<Longrightarrow> unat (w AND mask m) < 2 ^ m", "by (rule word_unat_and_lt) (simp add: unat_mask word_size)"], ["", "lemma unat_shiftr_less_t2n:\n  fixes x :: \"'a :: len word\"\n  shows \"unat x < 2 ^ (n + m) \\<Longrightarrow> unat (x >> n) < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ (n + m) \\<Longrightarrow> unat (x >> n) < 2 ^ m", "by (simp add: shiftr_div_2n' power_add mult.commute less_mult_imp_div_less)"], ["", "lemma le_or_mask:\n  \"w \\<le> w' \\<Longrightarrow> w OR mask x \\<le> w' OR mask x\"\n  for w w' :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<le> w' \\<Longrightarrow> w OR mask x \\<le> w' OR mask x", "by (metis neg_mask_add_mask add.commute le_word_or1 mask_2pm1 neg_mask_mono_le word_plus_mono_left)"], ["", "lemma le_shiftr1':\n  \"\\<lbrakk> shiftr1 u \\<le> shiftr1 v ; shiftr1 u \\<noteq> shiftr1 v \\<rbrakk> \\<Longrightarrow> u \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shiftr1 u \\<le> shiftr1 v;\n     shiftr1 u \\<noteq> shiftr1 v\\<rbrakk>\n    \\<Longrightarrow> u \\<le> v", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>take_bit LENGTH('a) (take_bit LENGTH('a) u div 2)\n                \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) v div 2);\n        take_bit LENGTH('a) (take_bit LENGTH('a) u div 2) \\<noteq>\n        take_bit LENGTH('a) (take_bit LENGTH('a) v div 2)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) u \\<le> take_bit LENGTH('a) v", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_shiftr':\n  \"\\<lbrakk> u >> n \\<le> v >> n ; u >> n \\<noteq> v >> n \\<rbrakk> \\<Longrightarrow> (u::'a::len word) \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u >> n \\<le> v >> n; u >> n \\<noteq> v >> n\\<rbrakk>\n    \\<Longrightarrow> u \\<le> v", "apply (induct n; simp add: shiftr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>(shiftr1 ^^ n) u \\<le> (shiftr1 ^^ n) v;\n                 (shiftr1 ^^ n) u \\<noteq> (shiftr1 ^^ n) v\\<rbrakk>\n                \\<Longrightarrow> u \\<le> v;\n        shiftr1 ((shiftr1 ^^ n) u) \\<le> shiftr1 ((shiftr1 ^^ n) v);\n        shiftr1 ((shiftr1 ^^ n) u) \\<noteq>\n        shiftr1 ((shiftr1 ^^ n) v)\\<rbrakk>\n       \\<Longrightarrow> u \\<le> v", "apply (case_tac \"(shiftr1 ^^ n) u = (shiftr1 ^^ n) v\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>(shiftr1 ^^ n) u \\<le> (shiftr1 ^^ n) v;\n                 (shiftr1 ^^ n) u \\<noteq> (shiftr1 ^^ n) v\\<rbrakk>\n                \\<Longrightarrow> u \\<le> v;\n        shiftr1 ((shiftr1 ^^ n) u) \\<le> shiftr1 ((shiftr1 ^^ n) v);\n        shiftr1 ((shiftr1 ^^ n) u) \\<noteq> shiftr1 ((shiftr1 ^^ n) v);\n        (shiftr1 ^^ n) u \\<noteq> (shiftr1 ^^ n) v\\<rbrakk>\n       \\<Longrightarrow> u \\<le> v", "apply (fastforce dest: le_shiftr1')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_add_no_overflow:\"(x::'a::len word) < max_word \\<Longrightarrow> x < x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < - 1 \\<Longrightarrow> x < x + 1", "using less_x_plus_1 order_less_le"], ["proof (prove)\nusing this:\n  ?x \\<noteq> - 1 \\<Longrightarrow> (?y < ?x + 1) = (?y < ?x \\<or> ?y = ?x)\n  (?x < ?y) = (?x \\<le> ?y \\<and> ?x \\<noteq> ?y)\n\ngoal (1 subgoal):\n 1. x < - 1 \\<Longrightarrow> x < x + 1", "by blast"], ["", "lemma lt_plus_1_le_word:\n  fixes x :: \"'a::len word\"\n  assumes bound:\"n < unat (maxBound::'a word)\"\n  shows \"x < 1 + of_nat n = (x \\<le> of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < 1 + word_of_nat n) = (x \\<le> word_of_nat n)", "by (metis add.commute bound max_word_max word_Suc_leq word_not_le word_of_nat_less)"], ["", "lemma unat_ucast_up_simp:\n  fixes x :: \"'a::len word\"\n  assumes \"LENGTH('a) \\<le> LENGTH('b)\"\n  shows \"unat (ucast x :: 'b::len word) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (UCAST('a \\<rightarrow> 'b) x) = unat x", "unfolding ucast_eq unat_eq_nat_uint"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (uint (word_of_int (uint x))) = nat (uint x)", "apply (subst int_word_uint)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (uint x mod 2 ^ LENGTH('b)) = nat (uint x)", "apply (subst mod_pos_pos_trivial; simp?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint x < 2 ^ LENGTH('b)", "apply (rule lt2p_lem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b)", "apply (simp add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_ucast_less_no_overflow:\n  \"\\<lbrakk>n < 2 ^ LENGTH('a); unat f < n\\<rbrakk> \\<Longrightarrow> (f::('a::len) word) < of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ LENGTH('a); unat f < n\\<rbrakk>\n    \\<Longrightarrow> f < word_of_nat n", "by (erule (1)  order_le_less_trans[OF _ of_nat_mono_maybe,rotated]) simp"], ["", "lemma unat_ucast_less_no_overflow_simp:\n  \"n < 2 ^ LENGTH('a) \\<Longrightarrow> (unat f < n) = ((f::('a::len) word) < of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 2 ^ LENGTH('a) \\<Longrightarrow> (unat f < n) = (f < word_of_nat n)", "using unat_less_helper unat_ucast_less_no_overflow"], ["proof (prove)\nusing this:\n  ?x < word_of_nat ?n \\<Longrightarrow> unat ?x < ?n\n  \\<lbrakk>?n < 2 ^ LENGTH(?'a); unat ?f < ?n\\<rbrakk>\n  \\<Longrightarrow> ?f < word_of_nat ?n\n\ngoal (1 subgoal):\n 1. n < 2 ^ LENGTH('a) \\<Longrightarrow> (unat f < n) = (f < word_of_nat n)", "by blast"], ["", "lemma unat_ucast_no_overflow_le:\n  assumes no_overflow: \"unat b < (2 :: nat) ^ LENGTH('a)\"\n  and upward_cast: \"LENGTH('a) < LENGTH('b)\"\n  shows \"(ucast (f::'a::len word) < (b :: 'b :: len word)) = (unat f < unat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UCAST('a \\<rightarrow> 'b) f < b) = (unat f < unat b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (UCAST('a \\<rightarrow> 'b) f < b) = (unat f < unat b)", "have LR: \"ucast f < b \\<Longrightarrow> unat f < unat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) f < b \\<Longrightarrow> unat f < unat b", "apply (rule unat_less_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) f < b \\<Longrightarrow>\n    f < word_of_nat (unat b)", "apply (simp add:ucast_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) f < b \\<Longrightarrow>\n    f < UCAST('b \\<rightarrow> 'a) b", "apply (rule_tac 'b1 = 'b in  ucast_less_ucast[OF order.strict_implies_order, THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. UCAST('a \\<rightarrow> 'b) f < b \\<Longrightarrow>\n    LENGTH('a) < LENGTH('b)\n 2. UCAST('a \\<rightarrow> 'b) f < b \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) f\n    < UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) b)", "apply (rule upward_cast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) f < b \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) f\n    < UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) b)", "apply (simp add: ucast_ucast_mask less_mask_eq word_less_nat_alt\n                     unat_power_lower[OF upward_cast] no_overflow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UCAST('a \\<rightarrow> 'b) f < b \\<Longrightarrow> unat f < unat b\n\ngoal (1 subgoal):\n 1. (UCAST('a \\<rightarrow> 'b) f < b) = (unat f < unat b)", "have RL: \"unat f < unat b \\<Longrightarrow> ucast f < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat f < unat b \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) f < b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. unat f < unat b \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) f < b", "assume ineq: \"unat f < unat b\""], ["proof (state)\nthis:\n  unat f < unat b\n\ngoal (1 subgoal):\n 1. unat f < unat b \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) f < b", "have \"ucast (f::'a::len word) < ((ucast (ucast b ::'a::len word)) :: 'b :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) f\n    < UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) b)", "apply (simp add: ucast_less_ucast[OF order.strict_implies_order] upward_cast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f < UCAST('b \\<rightarrow> 'a) b", "apply (simp only: flip: ucast_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f < word_of_nat (unat b)", "apply (rule unat_ucast_less_no_overflow[OF no_overflow ineq])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UCAST('a \\<rightarrow> 'b) f\n  < UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) b)\n\ngoal (1 subgoal):\n 1. unat f < unat b \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) f < b", "then"], ["proof (chain)\npicking this:\n  UCAST('a \\<rightarrow> 'b) f\n  < UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) b)", "show ?thesis"], ["proof (prove)\nusing this:\n  UCAST('a \\<rightarrow> 'b) f\n  < UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) b)\n\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) f < b", "apply (rule order_less_le_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) (UCAST('b \\<rightarrow> 'a) b) \\<le> b", "apply (simp add:ucast_ucast_mask word_and_le2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UCAST('a \\<rightarrow> 'b) f < b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat f < unat b \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) f < b\n\ngoal (1 subgoal):\n 1. (UCAST('a \\<rightarrow> 'b) f < b) = (unat f < unat b)", "then"], ["proof (chain)\npicking this:\n  unat f < unat b \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) f < b", "show ?thesis"], ["proof (prove)\nusing this:\n  unat f < unat b \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) f < b\n\ngoal (1 subgoal):\n 1. (UCAST('a \\<rightarrow> 'b) f < b) = (unat f < unat b)", "by (simp add:RL LR iffI)"], ["proof (state)\nthis:\n  (UCAST('a \\<rightarrow> 'b) f < b) = (unat f < unat b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas ucast_up_mono = ucast_less_ucast[THEN iffD2]"], ["", "lemma minus_one_word:\n  \"(-1 :: 'a :: len word) = 2 ^ LENGTH('a) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 = 2 ^ LENGTH('a) - 1", "by simp"], ["", "lemma mask_exceed:\n  \"n \\<ge> LENGTH('a) \\<Longrightarrow> (x::'a::len word) AND NOT (mask n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> x AND NOT (mask n) = 0", "by (simp add: and_not_mask shiftr_eq_0)"], ["", "lemma word_shift_by_2:\n  \"x * 4 = (x::'a::len word) << 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 4 = x << 2", "by (simp add: shiftl_t2n)"], ["", "lemma le_2p_upper_bits:\n  \"\\<lbrakk> (p::'a::len word) \\<le> 2^n - 1; n < LENGTH('a) \\<rbrakk> \\<Longrightarrow>\n  \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> 2 ^ n - 1; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n'\\<ge>n.\n                         n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'", "by (subst upper_bits_unset_is_l2p; simp)"], ["", "lemma le2p_bits_unset:\n  \"p \\<le> 2 ^ n - 1 \\<Longrightarrow> \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> (p::'a::len word) !! n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> 2 ^ n - 1 \\<Longrightarrow>\n    \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'", "using upper_bits_unset_is_l2p [where p=p]"], ["proof (prove)\nusing this:\n  ?n < LENGTH('a) \\<Longrightarrow>\n  (\\<forall>n'\\<ge>?n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n') =\n  (p < 2 ^ ?n)\n\ngoal (1 subgoal):\n 1. p \\<le> 2 ^ n - 1 \\<Longrightarrow>\n    \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'", "by (cases \"n < LENGTH('a)\") auto"], ["", "lemma ucast_less_shiftl_helper:\n  \"\\<lbrakk> LENGTH('b) + 2 < LENGTH('a); 2 ^ (LENGTH('b) + 2) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (ucast (x :: 'b::len word) << 2) < (n :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('b) + 2 < LENGTH('a);\n     2 ^ (LENGTH('b) + 2) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'a) x << 2 < n", "apply (erule order_less_le_trans[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) + 2 < LENGTH('a) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'a) x << 2 < 2 ^ (LENGTH('b) + 2)", "using ucast_less[where x=x and 'a='a]"], ["proof (prove)\nusing this:\n  LENGTH('b) < LENGTH('a) \\<Longrightarrow>\n  UCAST('b \\<rightarrow> 'a) x < 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. LENGTH('b) + 2 < LENGTH('a) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'a) x << 2 < 2 ^ (LENGTH('b) + 2)", "apply (simp only: shiftl_t2n field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('b) + 2 < LENGTH('a);\n     LENGTH('b) < LENGTH('a) \\<Longrightarrow>\n     UCAST('b \\<rightarrow> 'a) x < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'a) x * 2\\<^sup>2\n                      < 2 ^ (LENGTH('b) + 2)", "apply (rule word_less_power_trans2; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_power_nonzero:\n  \"\\<lbrakk> (x :: 'a::len word) < 2 ^ (LENGTH('a) - n); n < LENGTH('a); x \\<noteq> 0 \\<rbrakk>\n  \\<Longrightarrow> x * 2 ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (LENGTH('a) - n); n < LENGTH('a); x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n \\<noteq> 0", "by (metis and_mask_eq_iff_shiftr_0 less_mask_eq p2_gt_0 semiring_normalization_rules(7)\n            shiftl_shiftr_id shiftl_t2n)"], ["", "lemma less_1_helper:\n  \"n \\<le> m \\<Longrightarrow> (n - 1 :: int) < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> n - 1 < m", "by arith"], ["", "lemma div_power_helper:\n  \"\\<lbrakk> x \\<le> y; y < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 ^ y - 1) div (2 ^ x :: 'a::len word) = 2 ^ (y - x) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x = 2 ^ (y - x) - 1", "apply (rule word_uint.Rep_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> uint ((2 ^ y - 1) div 2 ^ x) = uint (2 ^ (y - x) - 1)", "apply (simp only: uint_word_ariths uint_div uint_power_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1 mod 2 ^ LENGTH('a)) mod 2 ^ LENGTH('a) div\n                      2 ^ x =\n                      (2 ^ (y - x) - 1 mod 2 ^ LENGTH('a)) mod\n                      2 ^ LENGTH('a)", "apply (subst mod_pos_pos_trivial, fastforce, fastforce)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) mod 2 ^ LENGTH('a) div 2 ^ x =\n                      (2 ^ (y - x) - 1) mod 2 ^ LENGTH('a)", "apply (subst mod_pos_pos_trivial)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 2 ^ y - 1\n 2. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ y - 1 < 2 ^ LENGTH('a)\n 3. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x =\n                      (2 ^ (y - x) - 1) mod 2 ^ LENGTH('a)", "apply (simp add: le_diff_eq uint_2p_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ y - 1 < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x =\n                      (2 ^ (y - x) - 1) mod 2 ^ LENGTH('a)", "apply (rule less_1_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ y \\<le> 2 ^ LENGTH('a)\n 2. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x =\n                      (2 ^ (y - x) - 1) mod 2 ^ LENGTH('a)", "apply (rule power_increasing; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x =\n                      (2 ^ (y - x) - 1) mod 2 ^ LENGTH('a)", "apply (subst mod_pos_pos_trivial)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 2 ^ (y - x) - 1\n 2. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (y - x) - 1 < 2 ^ LENGTH('a)\n 3. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x = 2 ^ (y - x) - 1", "apply (simp add: uint_2p_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (y - x) - 1 < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x = 2 ^ (y - x) - 1", "apply (rule less_1_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (y - x) \\<le> 2 ^ LENGTH('a)\n 2. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x = 2 ^ (y - x) - 1", "apply (rule power_increasing; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ y - 1) div 2 ^ x = 2 ^ (y - x) - 1", "apply (subst int_div_sub_1; simp add: uint_2p_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ x dvd 2 ^ y \\<longrightarrow>\n                       2 ^ y div 2 ^ x = 2 ^ (y - x)) \\<and>\n                      (\\<not> 2 ^ x dvd 2 ^ y \\<longrightarrow>\n                       2 ^ y div 2 ^ x = 2 ^ (y - x) - 1)", "apply (subst power_0[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ x dvd 2 ^ y \\<longrightarrow>\n                       2 ^ y div 2 ^ x = 2 ^ (y - x)) \\<and>\n                      (\\<not> 2 ^ x dvd 2 ^ y \\<longrightarrow>\n                       2 ^ y div 2 ^ x = 2 ^ (y - x) - ?a82 ^ 0)", "apply (simp add: uint_2p_alt le_imp_power_dvd power_diff_power_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_add_power_off:\n  fixes a :: \"'a :: len word\"\n  assumes ak: \"a < k\"\n  and kw: \"k < 2 ^ (LENGTH('a) - m)\"\n  and mw: \"m < LENGTH('a)\"\n  and off: \"off < 2 ^ m\"\n  shows \"(a * 2 ^ m) + off < k * 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * 2 ^ m + off < k * 2 ^ m", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m\n 2. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m\n 2. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "then"], ["proof (chain)\npicking this:\n  m = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. a * 2 ^ m + off < k * 2 ^ m", "using off ak"], ["proof (prove)\nusing this:\n  m = 0\n  off < 2 ^ m\n  a < k\n\ngoal (1 subgoal):\n 1. a * 2 ^ m + off < k * 2 ^ m", "by simp"], ["proof (state)\nthis:\n  a * 2 ^ m + off < k * 2 ^ m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "from ak"], ["proof (chain)\npicking this:\n  a < k", "have ak1: \"a + 1 \\<le> k\""], ["proof (prove)\nusing this:\n  a < k\n\ngoal (1 subgoal):\n 1. a + 1 \\<le> k", "by (rule inc_le)"], ["proof (state)\nthis:\n  a + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "then"], ["proof (chain)\npicking this:\n  a + 1 \\<le> k", "have \"(a + 1) * 2 ^ m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. (a + 1) * 2 ^ m \\<noteq> 0", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 \\<le> k \\<Longrightarrow> (a + 1) * 2 ^ m \\<noteq> 0", "apply (rule word_power_nonzero)"], ["proof (prove)\ngoal (3 subgoals):\n 1. a + 1 \\<le> k \\<Longrightarrow> a + 1 < 2 ^ (LENGTH('a) - m)\n 2. a + 1 \\<le> k \\<Longrightarrow> m < LENGTH('a)\n 3. a + 1 \\<le> k \\<Longrightarrow> a + 1 \\<noteq> 0", "apply (erule order_le_less_trans  [OF _ kw])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a + 1 \\<le> k \\<Longrightarrow> m < LENGTH('a)\n 2. a + 1 \\<le> k \\<Longrightarrow> a + 1 \\<noteq> 0", "apply (rule mw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 \\<le> k \\<Longrightarrow> a + 1 \\<noteq> 0", "apply (rule less_is_non_zero_p1 [OF ak])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (a + 1) * 2 ^ m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "then"], ["proof (chain)\npicking this:\n  (a + 1) * 2 ^ m \\<noteq> 0", "have \"(a * 2 ^ m) + off < ((a + 1) * 2 ^ m)\""], ["proof (prove)\nusing this:\n  (a + 1) * 2 ^ m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * 2 ^ m + off < (a + 1) * 2 ^ m", "using kw mw"], ["proof (prove)\nusing this:\n  (a + 1) * 2 ^ m \\<noteq> 0\n  k < 2 ^ (LENGTH('a) - m)\n  m < LENGTH('a)\n\ngoal (1 subgoal):\n 1. a * 2 ^ m + off < (a + 1) * 2 ^ m", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a + 1) * 2 ^ m \\<noteq> 0; k < 2 ^ (LENGTH('a) - m);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a * 2 ^ m + off < (a + 1) * 2 ^ m", "apply (simp add: distrib_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * 2 ^ m + 2 ^ m \\<noteq> 0; k < 2 ^ (LENGTH('a) - m);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a * 2 ^ m + off < a * 2 ^ m + 2 ^ m", "apply (rule word_plus_strict_mono_right [OF off])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * 2 ^ m + 2 ^ m \\<noteq> 0; k < 2 ^ (LENGTH('a) - m);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a * 2 ^ m \\<le> a * 2 ^ m + 2 ^ m", "apply (rule is_aligned_no_overflow'')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a * 2 ^ m + 2 ^ m \\<noteq> 0; k < 2 ^ (LENGTH('a) - m);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned (a * 2 ^ m) m\n 2. \\<lbrakk>a * 2 ^ m + 2 ^ m \\<noteq> 0; k < 2 ^ (LENGTH('a) - m);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a * 2 ^ m + 2 ^ m \\<noteq> 0", "apply (rule is_aligned_mult_triv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * 2 ^ m + 2 ^ m \\<noteq> 0; k < 2 ^ (LENGTH('a) - m);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a * 2 ^ m + 2 ^ m \\<noteq> 0", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a * 2 ^ m + off < (a + 1) * 2 ^ m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "also"], ["proof (state)\nthis:\n  a * 2 ^ m + off < (a + 1) * 2 ^ m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "have \"\\<dots> \\<le> k * 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + 1) * 2 ^ m \\<le> k * 2 ^ m", "using ak1 mw kw False"], ["proof (prove)\nusing this:\n  a + 1 \\<le> k\n  m < LENGTH('a)\n  k < 2 ^ (LENGTH('a) - m)\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (a + 1) * 2 ^ m \\<le> k * 2 ^ m", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + 1 \\<le> k; m < LENGTH('a); k < 2 ^ (LENGTH('a) - m);\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (a + 1) * 2 ^ m \\<le> k * 2 ^ m", "apply (erule word_mult_le_mono1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m < LENGTH('a); k < 2 ^ (LENGTH('a) - m); m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ m\n 2. \\<lbrakk>m < LENGTH('a); k < 2 ^ (LENGTH('a) - m); m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat k * unat (2 ^ m) < 2 ^ LENGTH('a)", "apply (simp add: p2_gt_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < LENGTH('a); k < 2 ^ (LENGTH('a) - m); m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat k * unat (2 ^ m) < 2 ^ LENGTH('a)", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < LENGTH('a); unat k < 2 ^ (LENGTH('a) - m); 0 < m\\<rbrakk>\n    \\<Longrightarrow> unat k * 2 ^ m < 2 ^ LENGTH('a)", "apply (meson nat_mult_power_less_eq zero_less_numeral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (a + 1) * 2 ^ m \\<le> k * 2 ^ m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> a * 2 ^ m + off < k * 2 ^ m", "finally"], ["proof (chain)\npicking this:\n  a * 2 ^ m + off < k * 2 ^ m", "show ?thesis"], ["proof (prove)\nusing this:\n  a * 2 ^ m + off < k * 2 ^ m\n\ngoal (1 subgoal):\n 1. a * 2 ^ m + off < k * 2 ^ m", "."], ["proof (state)\nthis:\n  a * 2 ^ m + off < k * 2 ^ m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offset_not_aligned:\n  \"\\<lbrakk> is_aligned (p::'a::len word) n; i > 0; i < 2 ^ n; n < LENGTH('a)\\<rbrakk> \\<Longrightarrow>\n   \\<not> is_aligned (p + of_nat i) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; 0 < i; i < 2 ^ n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_aligned (p + word_of_nat i) n", "apply (erule is_aligned_add_not_aligned)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i < 2 ^ n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_aligned (word_of_nat i) n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>0 < i; i < 2 ^ n; n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> 2 ^ n dvd take_bit LENGTH('a) (int i)", "apply (auto simp add: is_aligned_iff_udvd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>0 < i; i < 2 ^ n; n < LENGTH('a);\n        2 ^ n dvd take_bit LENGTH('a) (int i)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis bintrunc_bintrunc_ge int_ops(1) nat_int_comparison(1) nat_less_le take_bit_eq_0_iff take_bit_nat_eq_self_iff take_bit_of_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_upto_enum_one:\n  fixes x :: \"'a :: len word\"\n  assumes lt1: \"x < y\" and lt2: \"z < y\" and lt3: \"x \\<le> z\"\n  shows \"[x , y .e. z] = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x , y .e. z] = [x]", "unfolding upto_enum_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if z < x then []\n     else map (\\<lambda>xa. x + xa * (y - x)) [0 .e. (z - x) div (y - x)]) =\n    [x]", "proof (subst upto_enum_red, subst if_not_P [OF leD [OF lt3]], clarsimp, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. unat ((z - x) div (y - x)) = 0\n 2. (z - x) div (y - x) * (y - x) = 0", "show \"unat ((z - x) div (y - x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ((z - x) div (y - x)) = 0", "proof (subst unat_div, rule div_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. unat (z - x) < unat (y - x)", "have syx: \"unat (y - x) = unat y - unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (y - x) = unat y - unat x", "by (rule unat_sub [OF order_less_imp_le]) fact"], ["proof (state)\nthis:\n  unat (y - x) = unat y - unat x\n\ngoal (1 subgoal):\n 1. unat (z - x) < unat (y - x)", "moreover"], ["proof (state)\nthis:\n  unat (y - x) = unat y - unat x\n\ngoal (1 subgoal):\n 1. unat (z - x) < unat (y - x)", "have \"unat (z - x) = unat z - unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (z - x) = unat z - unat x", "by (rule unat_sub) fact"], ["proof (state)\nthis:\n  unat (z - x) = unat z - unat x\n\ngoal (1 subgoal):\n 1. unat (z - x) < unat (y - x)", "ultimately"], ["proof (chain)\npicking this:\n  unat (y - x) = unat y - unat x\n  unat (z - x) = unat z - unat x", "show \"unat (z - x) < unat (y - x)\""], ["proof (prove)\nusing this:\n  unat (y - x) = unat y - unat x\n  unat (z - x) = unat z - unat x\n\ngoal (1 subgoal):\n 1. unat (z - x) < unat (y - x)", "using lt2 lt3 unat_mono word_less_minus_mono_left"], ["proof (prove)\nusing this:\n  unat (y - x) = unat y - unat x\n  unat (z - x) = unat z - unat x\n  z < y\n  x \\<le> z\n  ?a < ?b \\<Longrightarrow> unat ?a < unat ?b\n  \\<lbrakk>?y < ?z; ?x \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?y - ?x < ?z - ?x\n\ngoal (1 subgoal):\n 1. unat (z - x) < unat (y - x)", "by blast"], ["proof (state)\nthis:\n  unat (z - x) < unat (y - x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat ((z - x) div (y - x)) = 0\n\ngoal (1 subgoal):\n 1. (z - x) div (y - x) * (y - x) = 0", "then"], ["proof (chain)\npicking this:\n  unat ((z - x) div (y - x)) = 0", "show \"(z - x) div (y - x) * (y - x) = 0\""], ["proof (prove)\nusing this:\n  unat ((z - x) div (y - x)) = 0\n\ngoal (1 subgoal):\n 1. (z - x) div (y - x) * (y - x) = 0", "by (metis mult_zero_left unat_0 word_unat.Rep_eqD)"], ["proof (state)\nthis:\n  (z - x) div (y - x) * (y - x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_word_mask:\n  \"(max_word :: 'a::len word) = mask LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 = mask LENGTH('a)", "unfolding mask_eq_decr_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 = 2 ^ LENGTH('a) - 1", "by simp"], ["", "lemmas mask_len_max = max_word_mask[symmetric]"], ["", "lemma mask_out_first_mask_some:\n  \"\\<lbrakk> x AND NOT (mask n) = y; n \\<le> m \\<rbrakk> \\<Longrightarrow> x AND NOT (mask m) = y AND NOT (mask m)\"\n  for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND NOT (mask n) = y; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> x AND NOT (mask m) = y AND NOT (mask m)", "by (rule bit_word_eqI) (auto simp add: bit_simps)"], ["", "lemma mask_lower_twice:\n  \"n \\<le> m \\<Longrightarrow> (x AND NOT (mask n)) AND NOT (mask m) = x AND NOT (mask m)\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    (x AND NOT (mask n)) AND NOT (mask m) = x AND NOT (mask m)", "by (rule bit_word_eqI) (auto simp add: bit_simps)"], ["", "lemma mask_lower_twice2:\n  \"(a AND NOT (mask n)) AND NOT (mask m) = a AND NOT (mask (max n m))\"\n  for a :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a AND NOT (mask n)) AND NOT (mask m) = a AND NOT (mask (max n m))", "by (rule bit_word_eqI) (auto simp add: bit_simps)"], ["", "lemma ucast_and_neg_mask:\n  \"ucast (x AND NOT (mask n)) = ucast x AND NOT (mask n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (x AND NOT (mask n)) =\n    UCAST('b \\<rightarrow> 'a) x AND NOT (mask n)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (UCAST('b \\<rightarrow> 'a) (x AND NOT (mask n))) na =\n       bit (UCAST('b \\<rightarrow> 'a) x AND NOT (mask n)) na", "apply (auto simp add: bit_simps dest: bit_imp_le_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_and_mask:\n  \"ucast (x AND mask n) = ucast x AND mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'a) (x AND mask n) =\n    UCAST('b \\<rightarrow> 'a) x AND mask n", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (UCAST('b \\<rightarrow> 'a) (x AND mask n)) na =\n       bit (UCAST('b \\<rightarrow> 'a) x AND mask n) na", "apply (auto simp add: bit_simps dest: bit_imp_le_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_mask_drop:\n  \"LENGTH('a :: len) \\<le> n \\<Longrightarrow> (ucast (x AND mask n) :: 'a word) = ucast x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'a) (x AND mask n) = UCAST('b \\<rightarrow> 'a) x", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>LENGTH('a) \\<le> n; na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (UCAST('b \\<rightarrow> 'a) (x AND mask n))\n                          na =\n                         bit (UCAST('b \\<rightarrow> 'a) x) na", "apply (auto simp add: bit_simps dest: bit_imp_le_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* negating a mask which has been shifted to the very left *)"], ["", "lemma NOT_mask_shifted_lenword:\n  \"NOT (mask len << (LENGTH('a) - len) ::'a::len word) = mask (LENGTH('a) - len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (mask len << LENGTH('a) - len) = mask (LENGTH('a) - len)", "by (rule bit_word_eqI)\n    (auto simp add: shiftl_word_eq word_size bit_not_iff bit_push_bit_iff bit_mask_iff)"], ["", "(* Comparisons between different word sizes. *)"], ["", "lemma eq_ucast_ucast_eq:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow> x = ucast y \\<Longrightarrow> ucast x = y\"\n  for x :: \"'a::len word\" and y :: \"'b::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('b) \\<le> LENGTH('a);\n     x = UCAST('b \\<rightarrow> 'a) y\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) x = y", "by transfer simp"], ["", "lemma le_ucast_ucast_le:\n  \"x \\<le> ucast y \\<Longrightarrow> ucast x \\<le> y\"\n  for x :: \"'a::len word\" and y :: \"'b::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> UCAST('b \\<rightarrow> 'a) y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> y", "by (smt le_unat_uoi linorder_not_less order_less_imp_le ucast_nat_def unat_arith_simps(1))"], ["", "lemma less_ucast_ucast_less:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow> x < ucast y \\<Longrightarrow> ucast x < y\"\n  for x :: \"'a::len word\" and y :: \"'b::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('b) \\<le> LENGTH('a);\n     x < UCAST('b \\<rightarrow> 'a) y\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) x < y", "by (metis ucast_nat_def unat_mono unat_ucast_up_simp word_of_nat_less)"], ["", "lemma ucast_le_ucast:\n  \"LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow> (ucast x \\<le> (ucast y::'b::len word)) = (x \\<le> y)\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y) =\n    (x \\<le> y)", "by (simp add: unat_arith_simps(1) unat_ucast_up_simp)"], ["", "lemmas ucast_up_mono_le = ucast_le_ucast[THEN iffD2]"], ["", "lemma ucast_le_ucast_eq:\n  fixes x y :: \"'a::len word\"\n  assumes x: \"x < 2 ^ n\"\n  assumes y: \"y < 2 ^ n\"\n  assumes n: \"n = LENGTH('b::len)\"\n  shows \"(UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y) =\n    (x \\<le> y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. UCAST('a \\<rightarrow> 'b) x\n    \\<le> UCAST('a \\<rightarrow> 'b) y \\<Longrightarrow>\n    x \\<le> y\n 2. x \\<le> y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y", "apply (cases \"LENGTH('b) < LENGTH('a)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     \\<not> LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 3. x \\<le> y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y", "apply (subst less_mask_eq[OF x, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND mask n \\<le> y\n 2. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     \\<not> LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 3. x \\<le> y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y", "apply (subst less_mask_eq[OF y, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND mask n \\<le> y AND mask n\n 2. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     \\<not> LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 3. x \\<le> y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y", "apply (unfold n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND mask LENGTH('b) \\<le> y AND mask LENGTH('b)\n 2. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     \\<not> LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 3. x \\<le> y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y", "apply (subst ucast_ucast_mask[symmetric])+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'a)\n                       (UCAST('a \\<rightarrow> 'b) x)\n                      \\<le> UCAST('b \\<rightarrow> 'a)\n                             (UCAST('a \\<rightarrow> 'b) y)\n 2. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x\n             \\<le> UCAST('a \\<rightarrow> 'b) y;\n     \\<not> LENGTH('b) < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 3. x \\<le> y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y", "apply (simp add: ucast_le_ucast)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> UCAST('a \\<rightarrow> 'b) y", "apply (erule ucast_mono_le[OF _ y[unfolded n]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_or_distrib:\n  fixes x :: \"'a::len word\"\n  fixes y :: \"'a::len word\"\n  shows \"(ucast (x OR y) :: ('b::len) word) = ucast x OR ucast y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) (x OR y) =\n    UCAST('a \\<rightarrow> 'b) x OR UCAST('a \\<rightarrow> 'b) y", "by transfer simp"], ["", "lemma shiftr_less:\n  \"(w::'a::len word) < k \\<Longrightarrow> w >> n < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w < k \\<Longrightarrow> w >> n < k", "by (metis div_le_dividend le_less_trans shiftr_div_2n' unat_arith_simps(2))"], ["", "lemma word_and_notzeroD:\n  \"w AND w' \\<noteq> 0 \\<Longrightarrow> w \\<noteq> 0 \\<and> w' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND w' \\<noteq> (0::'a) \\<Longrightarrow>\n    w \\<noteq> (0::'a) \\<and> w' \\<noteq> (0::'a)", "by auto"], ["", "lemma word_exists_nth:\n  \"(w::'a::len word) \\<noteq> 0 \\<Longrightarrow> \\<exists>i. w !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> \\<exists>i. w !! i", "by (simp add: bit_eq_iff test_bit_word_eq)"], ["", "lemma shiftr_le_0:\n  \"unat (w::'a::len word) < 2 ^ n \\<Longrightarrow> w >> n = (0::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat w < 2 ^ n \\<Longrightarrow> w >> n = 0", "by (rule word_unat.Rep_eqD) (simp add: shiftr_div_2n')"], ["", "lemma of_nat_shiftl:\n  \"(of_nat x << n) = (of_nat (x * 2 ^ n) :: ('a::len) word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat x << n = word_of_nat (x * 2 ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. word_of_nat x << n = word_of_nat (x * 2 ^ n)", "have \"(of_nat x::'a word) << n = of_nat (2 ^ n) * of_nat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat x << n = word_of_nat (2 ^ n) * word_of_nat x", "using shiftl_t2n"], ["proof (prove)\nusing this:\n  ?w << ?n = 2 ^ ?n * ?w\n\ngoal (1 subgoal):\n 1. word_of_nat x << n = word_of_nat (2 ^ n) * word_of_nat x", "by (metis word_unat_power)"], ["proof (state)\nthis:\n  word_of_nat x << n = word_of_nat (2 ^ n) * word_of_nat x\n\ngoal (1 subgoal):\n 1. word_of_nat x << n = word_of_nat (x * 2 ^ n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  word_of_nat x << n = word_of_nat (2 ^ n) * word_of_nat x\n\ngoal (1 subgoal):\n 1. word_of_nat x << n = word_of_nat (x * 2 ^ n)", "by simp"], ["proof (state)\nthis:\n  word_of_nat x << n = word_of_nat (x * 2 ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shiftl_1_not_0:\n  \"n < LENGTH('a) \\<Longrightarrow> (1::'a::len word) << n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> 1 << n \\<noteq> 0", "by (simp add: shiftl_t2n)"], ["", "lemma max_word_not_0 [simp]:\n  \"- 1 \\<noteq> (0 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<noteq> 0", "by simp"], ["", "lemma ucast_zero_is_aligned:\n  \"UCAST('a::len \\<rightarrow> 'b::len) w = 0 \\<Longrightarrow> n \\<le> LENGTH('b) \\<Longrightarrow> is_aligned w n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>UCAST('a \\<rightarrow> 'b) w = 0; n \\<le> LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> is_aligned w n", "by (clarsimp simp: is_aligned_mask word_eq_iff word_size nth_ucast)"], ["", "lemma unat_ucast_eq_unat_and_mask:\n  \"unat (UCAST('b::len \\<rightarrow> 'a::len) w) = unat (w AND mask LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (UCAST('b \\<rightarrow> 'a) w) = unat (w AND mask LENGTH('a))", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (UCAST('b \\<rightarrow> 'a) w) = unat (take_bit LENGTH('a) w)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       (nat \\<circ> take_bit LENGTH('a)) (take_bit LENGTH('b) w) =\n       (nat \\<circ> take_bit LENGTH('b))\n        (take_bit (min LENGTH('b) LENGTH('a)) w)", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_max_word_pos[simp]: \"0 < unat (- 1 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < unat (- 1)", "using unat_gt_0 [of \\<open>- 1 :: 'a::len word\\<close>]"], ["proof (prove)\nusing this:\n  (0 < unat (- 1)) = (- 1 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 0 < unat (- 1)", "by simp"], ["", "(* Miscellaneous conditional injectivity rules. *)"], ["", "lemma mult_pow2_inj:\n  assumes ws: \"m + n \\<le> LENGTH('a)\"\n  assumes le: \"x \\<le> mask m\" \"y \\<le> mask m\"\n  assumes eq: \"x * 2 ^ n = y * (2 ^ n::'a::len word)\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule bit_word_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. n < LENGTH('a) \\<Longrightarrow> bit x n = bit y n", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. n < LENGTH('a) \\<Longrightarrow> bit x n = bit y n", "assume \\<open>q < LENGTH('a)\\<close>"], ["proof (state)\nthis:\n  q < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>n. n < LENGTH('a) \\<Longrightarrow> bit x n = bit y n", "from eq"], ["proof (chain)\npicking this:\n  x * 2 ^ n = y * 2 ^ n", "have \\<open>push_bit n x = push_bit n y\\<close>"], ["proof (prove)\nusing this:\n  x * 2 ^ n = y * 2 ^ n\n\ngoal (1 subgoal):\n 1. push_bit n x = push_bit n y", "by (simp add: push_bit_eq_mult)"], ["proof (state)\nthis:\n  push_bit n x = push_bit n y\n\ngoal (1 subgoal):\n 1. \\<And>n. n < LENGTH('a) \\<Longrightarrow> bit x n = bit y n", "moreover"], ["proof (state)\nthis:\n  push_bit n x = push_bit n y\n\ngoal (1 subgoal):\n 1. \\<And>n. n < LENGTH('a) \\<Longrightarrow> bit x n = bit y n", "from le"], ["proof (chain)\npicking this:\n  x \\<le> mask m\n  y \\<le> mask m", "have \\<open>take_bit m x = x\\<close> \\<open>take_bit m y = y\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> mask m\n  y \\<le> mask m\n\ngoal (1 subgoal):\n 1. take_bit m x = x &&& take_bit m y = y", "by (simp_all add: less_eq_mask_iff_take_bit_eq_self)"], ["proof (state)\nthis:\n  take_bit m x = x\n  take_bit m y = y\n\ngoal (1 subgoal):\n 1. \\<And>n. n < LENGTH('a) \\<Longrightarrow> bit x n = bit y n", "ultimately"], ["proof (chain)\npicking this:\n  push_bit n x = push_bit n y\n  take_bit m x = x\n  take_bit m y = y", "have \\<open>push_bit n (take_bit m x) = push_bit n (take_bit m y)\\<close>"], ["proof (prove)\nusing this:\n  push_bit n x = push_bit n y\n  take_bit m x = x\n  take_bit m y = y\n\ngoal (1 subgoal):\n 1. push_bit n (take_bit m x) = push_bit n (take_bit m y)", "by simp_all"], ["proof (state)\nthis:\n  push_bit n (take_bit m x) = push_bit n (take_bit m y)\n\ngoal (1 subgoal):\n 1. \\<And>n. n < LENGTH('a) \\<Longrightarrow> bit x n = bit y n", "with \\<open>q < LENGTH('a)\\<close> ws"], ["proof (chain)\npicking this:\n  q < LENGTH('a)\n  m + n \\<le> LENGTH('a)\n  push_bit n (take_bit m x) = push_bit n (take_bit m y)", "show \\<open>bit x q \\<longleftrightarrow> bit y q\\<close>"], ["proof (prove)\nusing this:\n  q < LENGTH('a)\n  m + n \\<le> LENGTH('a)\n  push_bit n (take_bit m x) = push_bit n (take_bit m y)\n\ngoal (1 subgoal):\n 1. bit x q = bit y q", "apply (simp add: push_bit_take_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < LENGTH('a); m + n \\<le> LENGTH('a);\n     take_bit (n + m) (push_bit n x) =\n     take_bit (n + m) (push_bit n y)\\<rbrakk>\n    \\<Longrightarrow> bit x q = bit y q", "unfolding bit_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < LENGTH('a); m + n \\<le> LENGTH('a);\n     \\<forall>na.\n        bit (take_bit (n + m) (push_bit n x)) na =\n        bit (take_bit (n + m) (push_bit n y)) na\\<rbrakk>\n    \\<Longrightarrow> bit x q = bit y q", "apply (simp add: bit_simps not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < LENGTH('a); m + n \\<le> LENGTH('a);\n     \\<forall>na.\n        (na < n + m \\<and>\n         n \\<le> na \\<and> na < LENGTH('a) \\<and> bit x (na - n)) =\n        (na < n + m \\<and>\n         n \\<le> na \\<and> na < LENGTH('a) \\<and> bit y (na - n))\\<rbrakk>\n    \\<Longrightarrow> bit x q = bit y q", "apply (metis (full_types) \\<open>take_bit m x = x\\<close> \\<open>take_bit m y = y\\<close> add.commute add_diff_cancel_right' add_less_cancel_right bit_take_bit_iff le_add2 less_le_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bit x q = bit y q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_of_nat_inj:\n  assumes bounded: \"x < 2 ^ LENGTH('a)\" \"y < 2 ^ LENGTH('a)\"\n  assumes of_nats: \"of_nat x = (of_nat y :: 'a::len word)\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (rule contrapos_pp[OF of_nats]; cases \"x < y\"; cases \"y < x\")\n     (auto dest: bounded[THEN of_nat_mono_maybe])"], ["", "(* Uints *)"], ["", "lemma uints_mono_iff: \"uints l \\<subseteq> uints m \\<longleftrightarrow> l \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uints l \\<subseteq> uints m) = (l \\<le> m)", "using power_increasing_iff[of \"2::int\" l m]"], ["proof (prove)\nusing this:\n  1 < 2 \\<Longrightarrow> (2 ^ l \\<le> 2 ^ m) = (l \\<le> m)\n\ngoal (1 subgoal):\n 1. (uints l \\<subseteq> uints m) = (l \\<le> m)", "apply (auto simp: uints_num subset_iff simp del: power_increasing_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 2 ^ l \\<le> 2 ^ m; \\<not> l \\<le> m;\n     \\<forall>t.\n        0 \\<le> t \\<and> t < 2 ^ l \\<longrightarrow> t < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (meson less_irrefl not_le zero_le_numeral zero_le_power)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas uints_monoI = uints_mono_iff[THEN iffD2]"], ["", "lemma Bit_in_uints_Suc: \"of_bool c + 2 * w \\<in> uints (Suc m)\" if \"w \\<in> uints m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bool c + 2 * w \\<in> uints (Suc m)", "using that"], ["proof (prove)\nusing this:\n  w \\<in> uints m\n\ngoal (1 subgoal):\n 1. of_bool c + 2 * w \\<in> uints (Suc m)", "by (auto simp: uints_num)"], ["", "lemma Bit_in_uintsI: \"of_bool c + 2 * w \\<in> uints m\" if \"w \\<in> uints (m - 1)\" \"m > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bool c + 2 * w \\<in> uints m", "using Bit_in_uints_Suc[OF that(1)] that(2)"], ["proof (prove)\nusing this:\n  of_bool ?c + 2 * w \\<in> uints (Suc (m - 1))\n  0 < m\n\ngoal (1 subgoal):\n 1. of_bool c + 2 * w \\<in> uints m", "by auto"], ["", "lemma bin_cat_in_uintsI:\n  \\<open>bin_cat a n b \\<in> uints m\\<close> if \\<open>a \\<in> uints l\\<close> \\<open>m \\<ge> l + n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "from \\<open>m \\<ge> l + n\\<close>"], ["proof (chain)\npicking this:\n  l + n \\<le> m", "obtain q where \\<open>m = l + n + q\\<close>"], ["proof (prove)\nusing this:\n  l + n \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<And>q. m = l + n + q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using le_Suc_ex"], ["proof (prove)\nusing this:\n  l + n \\<le> m\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. (\\<And>q. m = l + n + q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = l + n + q\n\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "then"], ["proof (chain)\npicking this:\n  m = l + n + q", "have \\<open>(2::int) ^ m = 2 ^ n * 2 ^ (l + q)\\<close>"], ["proof (prove)\nusing this:\n  m = l + n + q\n\ngoal (1 subgoal):\n 1. 2 ^ m = 2 ^ n * 2 ^ (l + q)", "by (simp add: ac_simps power_add)"], ["proof (state)\nthis:\n  2 ^ m = 2 ^ n * 2 ^ (l + q)\n\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "moreover"], ["proof (state)\nthis:\n  2 ^ m = 2 ^ n * 2 ^ (l + q)\n\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "have \\<open>a mod 2 ^ (l + q) = a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod 2 ^ (l + q) = a", "using \\<open>a \\<in> uints l\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> uints l\n\ngoal (1 subgoal):\n 1. a mod 2 ^ (l + q) = a", "by (auto simp add: uints_def take_bit_eq_mod power_add Divides.mod_mult2_eq)"], ["proof (state)\nthis:\n  a mod 2 ^ (l + q) = a\n\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "ultimately"], ["proof (chain)\npicking this:\n  2 ^ m = 2 ^ n * 2 ^ (l + q)\n  a mod 2 ^ (l + q) = a", "have \\<open>concat_bit n b a = take_bit m (concat_bit n b a)\\<close>"], ["proof (prove)\nusing this:\n  2 ^ m = 2 ^ n * 2 ^ (l + q)\n  a mod 2 ^ (l + q) = a\n\ngoal (1 subgoal):\n 1. concat_bit n b a = take_bit m (concat_bit n b a)", "by (simp add: concat_bit_eq take_bit_eq_mod push_bit_eq_mult Divides.mod_mult2_eq)"], ["proof (state)\nthis:\n  concat_bit n b a = take_bit m (concat_bit n b a)\n\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "then"], ["proof (chain)\npicking this:\n  concat_bit n b a = take_bit m (concat_bit n b a)", "show ?thesis"], ["proof (prove)\nusing this:\n  concat_bit n b a = take_bit m (concat_bit n b a)\n\ngoal (1 subgoal):\n 1. concat_bit n b a \\<in> uints m", "by (simp add: uints_def)"], ["proof (state)\nthis:\n  concat_bit n b a \\<in> uints m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_cat_cong: \"bin_cat a n b = bin_cat c m d\"\n  if \"n = m\" \"a = c\" \"bintrunc m b = bintrunc m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n b a = concat_bit m d c", "using that(3)"], ["proof (prove)\nusing this:\n  take_bit m b = take_bit m d\n\ngoal (1 subgoal):\n 1. concat_bit n b a = concat_bit m d c", "unfolding that(1,2)"], ["proof (prove)\nusing this:\n  take_bit m b = take_bit m d\n\ngoal (1 subgoal):\n 1. concat_bit m b c = concat_bit m d c", "by (simp add: bin_cat_eq_push_bit_add_take_bit)"], ["", "lemma bin_cat_eqD1: \"bin_cat a n b = bin_cat c n d \\<Longrightarrow> a = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n b a = concat_bit n d c \\<Longrightarrow> a = c", "by (metis drop_bit_bin_cat_eq)"], ["", "lemma bin_cat_eqD2: \"bin_cat a n b = bin_cat c n d \\<Longrightarrow> bintrunc n b = bintrunc n d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n b a = concat_bit n d c \\<Longrightarrow>\n    take_bit n b = take_bit n d", "by (metis take_bit_bin_cat_eq)"], ["", "lemma bin_cat_inj: \"(bin_cat a n b) = bin_cat c n d \\<longleftrightarrow> a = c \\<and> bintrunc n b = bintrunc n d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat_bit n b a = concat_bit n d c) =\n    (a = c \\<and> take_bit n b = take_bit n d)", "by (auto intro: bin_cat_cong bin_cat_eqD1 bin_cat_eqD2)"], ["", "lemma word_of_int_bin_cat_eq_iff:\n  \"(word_of_int (bin_cat (uint a) LENGTH('b) (uint b))::'c::len word) =\n  word_of_int (bin_cat (uint c) LENGTH('b) (uint d)) \\<longleftrightarrow> b = d \\<and> a = c\"\n  if \"LENGTH('a) + LENGTH('b) \\<le> LENGTH('c)\"\n  for a::\"'a::len word\" and b::\"'b::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (word_of_int (concat_bit LENGTH('b) (uint b) (uint a)) =\n     word_of_int (concat_bit LENGTH('b) (uint d) (uint c))) =\n    (b = d \\<and> a = c)", "by (subst word_uint.Abs_inject)\n     (auto simp: bin_cat_inj intro!: that bin_cat_in_uintsI)"], ["", "lemma word_cat_inj: \"(word_cat a b::'c::len word) = word_cat c d \\<longleftrightarrow> a = c \\<and> b = d\"\n  if \"LENGTH('a) + LENGTH('b) \\<le> LENGTH('c)\"\n  for a::\"'a::len word\" and b::\"'b::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (word_cat a b = word_cat c d) = (a = c \\<and> b = d)", "using word_of_int_bin_cat_eq_iff [OF that, of b a d c]"], ["proof (prove)\nusing this:\n  (word_of_int (concat_bit LENGTH('b) (uint b) (uint a)) =\n   word_of_int (concat_bit LENGTH('b) (uint d) (uint c))) =\n  (b = d \\<and> a = c)\n\ngoal (1 subgoal):\n 1. (word_cat a b = word_cat c d) = (a = c \\<and> b = d)", "by transfer auto"], ["", "lemma p2_eq_1: \"2 ^ n = (1::'a::len word) \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ n = 1) = (n = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (2 ^ n = 1) = (n = 0)", "have \"2 ^ n = (1::'a word) \\<Longrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n = 1 \\<Longrightarrow> n = 0", "by (metis One_nat_def not_less one_less_numeral_iff p2_eq_0 p2_gt_0 power_0 power_0\n        power_inject_exp semiring_norm(76) unat_power_lower zero_neq_one)"], ["proof (state)\nthis:\n  2 ^ n = 1 \\<Longrightarrow> n = 0\n\ngoal (1 subgoal):\n 1. (2 ^ n = 1) = (n = 0)", "then"], ["proof (chain)\npicking this:\n  2 ^ n = 1 \\<Longrightarrow> n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ n = 1 \\<Longrightarrow> n = 0\n\ngoal (1 subgoal):\n 1. (2 ^ n = 1) = (n = 0)", "by auto"], ["proof (state)\nthis:\n  (2 ^ n = 1) = (n = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* usually: x,y = (len_of TYPE ('a)) *)"], ["", "lemma bitmagic_zeroLast_leq_or1Last:\n  \"(a::('a::len) word) AND (mask len << x - len) \\<le> a OR mask (y - len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a AND (mask len << x - len) \\<le> a OR mask (y - len)", "by (meson le_word_or2 order_trans word_and_le2)"], ["", "lemma zero_base_lsb_imp_set_eq_as_bit_operation:\n  fixes base ::\"'a::len word\"\n  assumes valid_prefix: \"mask (LENGTH('a) - len) AND base = 0\"\n  shows \"(base = NOT (mask (LENGTH('a) - len)) AND a) \\<longleftrightarrow>\n         (a \\<in> {base .. base OR mask (LENGTH('a) - len)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (base = NOT (mask (LENGTH('a) - len)) AND a) =\n    (a \\<in> {base..base OR mask (LENGTH('a) - len)})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a \\<Longrightarrow>\n    a \\<in> {base..base OR mask (LENGTH('a) - len)}\n 2. a \\<in> {base..base OR mask (LENGTH('a) - len)} \\<Longrightarrow>\n    base = NOT (mask (LENGTH('a) - len)) AND a", "have helper3: \"x OR y = x OR y AND NOT x\" for x y ::\"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x OR y = x OR y AND NOT x", "by (simp add: word_oa_dist2)"], ["proof (state)\nthis:\n  ?x OR ?y = ?x OR ?y AND NOT ?x\n\ngoal (2 subgoals):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a \\<Longrightarrow>\n    a \\<in> {base..base OR mask (LENGTH('a) - len)}\n 2. a \\<in> {base..base OR mask (LENGTH('a) - len)} \\<Longrightarrow>\n    base = NOT (mask (LENGTH('a) - len)) AND a", "from assms"], ["proof (chain)\npicking this:\n  mask (LENGTH('a) - len) AND base = 0", "show \"base = NOT (mask (LENGTH('a) - len)) AND a \\<Longrightarrow>\n                    a \\<in> {base..base OR mask (LENGTH('a) - len)}\""], ["proof (prove)\nusing this:\n  mask (LENGTH('a) - len) AND base = 0\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a \\<Longrightarrow>\n    a \\<in> {base..base OR mask (LENGTH('a) - len)}", "apply(simp add: word_and_le1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>base = NOT (mask (LENGTH('a) - len)) AND a;\n     mask (LENGTH('a) - len) AND NOT (mask (LENGTH('a) - len)) AND a =\n     0\\<rbrakk>\n    \\<Longrightarrow> a \\<le> NOT (mask (LENGTH('a) - len)) AND a OR\n                              mask (LENGTH('a) - len)", "apply(metis helper3 le_word_or2 word_bw_comms(1) word_bw_comms(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  base = NOT (mask (LENGTH('a) - len)) AND a \\<Longrightarrow>\n  a \\<in> {base..base OR mask (LENGTH('a) - len)}\n\ngoal (1 subgoal):\n 1. a \\<in> {base..base OR mask (LENGTH('a) - len)} \\<Longrightarrow>\n    base = NOT (mask (LENGTH('a) - len)) AND a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> {base..base OR mask (LENGTH('a) - len)} \\<Longrightarrow>\n    base = NOT (mask (LENGTH('a) - len)) AND a", "assume \"a \\<in> {base..base OR mask (LENGTH('a) - len)}\""], ["proof (state)\nthis:\n  a \\<in> {base..base OR mask (LENGTH('a) - len)}\n\ngoal (1 subgoal):\n 1. a \\<in> {base..base OR mask (LENGTH('a) - len)} \\<Longrightarrow>\n    base = NOT (mask (LENGTH('a) - len)) AND a", "hence a: \"base \\<le> a \\<and> a \\<le> base OR mask (LENGTH('a) - len)\""], ["proof (prove)\nusing this:\n  a \\<in> {base..base OR mask (LENGTH('a) - len)}\n\ngoal (1 subgoal):\n 1. base \\<le> a \\<and> a \\<le> base OR mask (LENGTH('a) - len)", "by simp"], ["proof (state)\nthis:\n  base \\<le> a \\<and> a \\<le> base OR mask (LENGTH('a) - len)\n\ngoal (1 subgoal):\n 1. a \\<in> {base..base OR mask (LENGTH('a) - len)} \\<Longrightarrow>\n    base = NOT (mask (LENGTH('a) - len)) AND a", "show \"base = NOT (mask (LENGTH('a) - len)) AND a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "have f2: \"\\<forall>x\\<^sub>0. base AND NOT (mask x\\<^sub>0) \\<le> a AND NOT (mask x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       base AND NOT (mask x\\<^sub>0) \\<le> a AND NOT (mask x\\<^sub>0)", "using a neg_mask_mono_le"], ["proof (prove)\nusing this:\n  base \\<le> a \\<and> a \\<le> base OR mask (LENGTH('a) - len)\n  ?x \\<le> ?y \\<Longrightarrow>\n  ?x AND NOT (mask ?n) \\<le> ?y AND NOT (mask ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       base AND NOT (mask x\\<^sub>0) \\<le> a AND NOT (mask x\\<^sub>0)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>0.\n     base AND NOT (mask x\\<^sub>0) \\<le> a AND NOT (mask x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "have f3: \"\\<forall>x\\<^sub>0. a AND NOT (mask x\\<^sub>0) \\<le> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       a AND NOT (mask x\\<^sub>0)\n       \\<le> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>0)", "using a neg_mask_mono_le"], ["proof (prove)\nusing this:\n  base \\<le> a \\<and> a \\<le> base OR mask (LENGTH('a) - len)\n  ?x \\<le> ?y \\<Longrightarrow>\n  ?x AND NOT (mask ?n) \\<le> ?y AND NOT (mask ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       a AND NOT (mask x\\<^sub>0)\n       \\<le> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>0)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>0.\n     a AND NOT (mask x\\<^sub>0)\n     \\<le> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "have f4: \"base = base AND NOT (mask (LENGTH('a) - len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base = base AND NOT (mask (LENGTH('a) - len))", "using valid_prefix"], ["proof (prove)\nusing this:\n  mask (LENGTH('a) - len) AND base = 0\n\ngoal (1 subgoal):\n 1. base = base AND NOT (mask (LENGTH('a) - len))", "by (metis mask_eq_0_eq_x word_bw_comms(1))"], ["proof (state)\nthis:\n  base = base AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "hence f5: \"\\<forall>x\\<^sub>6. (base OR x\\<^sub>6) AND NOT (mask (LENGTH('a) - len)) =\n                      base OR x\\<^sub>6 AND NOT (mask (LENGTH('a) - len))\""], ["proof (prove)\nusing this:\n  base = base AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>6.\n       (base OR x\\<^sub>6) AND NOT (mask (LENGTH('a) - len)) =\n       base OR x\\<^sub>6 AND NOT (mask (LENGTH('a) - len))", "using word_ao_dist"], ["proof (prove)\nusing this:\n  base = base AND NOT (mask (LENGTH('a) - len))\n  (?x OR ?y) AND ?z = ?x AND ?z OR ?y AND ?z\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>6.\n       (base OR x\\<^sub>6) AND NOT (mask (LENGTH('a) - len)) =\n       base OR x\\<^sub>6 AND NOT (mask (LENGTH('a) - len))", "by (metis)"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>6.\n     (base OR x\\<^sub>6) AND NOT (mask (LENGTH('a) - len)) =\n     base OR x\\<^sub>6 AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "have f6: \"\\<forall>x\\<^sub>2 x\\<^sub>3. a AND NOT (mask x\\<^sub>2) \\<le> x\\<^sub>3 \\<or>\n                      \\<not> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>2) \\<le> x\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>2 x\\<^sub>3.\n       a AND NOT (mask x\\<^sub>2) \\<le> x\\<^sub>3 \\<or>\n       \\<not> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>2)\n              \\<le> x\\<^sub>3", "using f3 dual_order.trans"], ["proof (prove)\nusing this:\n  \\<forall>x\\<^sub>0.\n     a AND NOT (mask x\\<^sub>0)\n     \\<le> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>0)\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>2 x\\<^sub>3.\n       a AND NOT (mask x\\<^sub>2) \\<le> x\\<^sub>3 \\<or>\n       \\<not> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>2)\n              \\<le> x\\<^sub>3", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>2 x\\<^sub>3.\n     a AND NOT (mask x\\<^sub>2) \\<le> x\\<^sub>3 \\<or>\n     \\<not> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>2)\n            \\<le> x\\<^sub>3\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "have \"base = (base OR mask (LENGTH('a) - len)) AND NOT (mask (LENGTH('a) - len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base =\n    (base OR mask (LENGTH('a) - len)) AND NOT (mask (LENGTH('a) - len))", "using f5"], ["proof (prove)\nusing this:\n  \\<forall>x\\<^sub>6.\n     (base OR x\\<^sub>6) AND NOT (mask (LENGTH('a) - len)) =\n     base OR x\\<^sub>6 AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. base =\n    (base OR mask (LENGTH('a) - len)) AND NOT (mask (LENGTH('a) - len))", "by auto"], ["proof (state)\nthis:\n  base = (base OR mask (LENGTH('a) - len)) AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "hence \"base = a AND NOT (mask (LENGTH('a) - len))\""], ["proof (prove)\nusing this:\n  base = (base OR mask (LENGTH('a) - len)) AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. base = a AND NOT (mask (LENGTH('a) - len))", "using f2 f4 f6"], ["proof (prove)\nusing this:\n  base = (base OR mask (LENGTH('a) - len)) AND NOT (mask (LENGTH('a) - len))\n  \\<forall>x\\<^sub>0.\n     base AND NOT (mask x\\<^sub>0) \\<le> a AND NOT (mask x\\<^sub>0)\n  base = base AND NOT (mask (LENGTH('a) - len))\n  \\<forall>x\\<^sub>2 x\\<^sub>3.\n     a AND NOT (mask x\\<^sub>2) \\<le> x\\<^sub>3 \\<or>\n     \\<not> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\\<^sub>2)\n            \\<le> x\\<^sub>3\n\ngoal (1 subgoal):\n 1. base = a AND NOT (mask (LENGTH('a) - len))", "by (metis eq_iff)"], ["proof (state)\nthis:\n  base = a AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "thus \"base = NOT (mask (LENGTH('a) - len)) AND a\""], ["proof (prove)\nusing this:\n  base = a AND NOT (mask (LENGTH('a) - len))\n\ngoal (1 subgoal):\n 1. base = NOT (mask (LENGTH('a) - len)) AND a", "by (metis word_bw_comms(1))"], ["proof (state)\nthis:\n  base = NOT (mask (LENGTH('a) - len)) AND a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base = NOT (mask (LENGTH('a) - len)) AND a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_nat_eq_signed_scast:\n  \"(of_nat x = (y :: ('a::len) signed word))\n   = (of_nat x = (scast y :: 'a word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (word_of_nat x = y) =\n    (word_of_nat x = SCAST('a signed \\<rightarrow> 'a) y)", "by (metis scast_of_nat scast_scast_id(2))"], ["", "lemma word_aligned_add_no_wrap_bounded:\n  \"\\<lbrakk> w + 2^n \\<le> x; w + 2^n \\<noteq> 0; is_aligned w n \\<rbrakk> \\<Longrightarrow> (w::'a::len word) < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w + 2 ^ n \\<le> x; w + 2 ^ n \\<noteq> 0;\n     is_aligned w n\\<rbrakk>\n    \\<Longrightarrow> w < x", "by (blast dest: is_aligned_no_overflow le_less_trans word_leq_le_minus_one)"], ["", "lemma mask_Suc:\n  \"mask (Suc n) = (2 :: 'a::len word) ^ n + mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc n) = 2 ^ n + mask n", "by (simp add: mask_eq_decr_exp)"], ["", "lemma mask_mono:\n  \"sz' \\<le> sz \\<Longrightarrow> mask sz' \\<le> (mask sz :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sz' \\<le> sz \\<Longrightarrow> mask sz' \\<le> mask sz", "by (simp add: le_mask_iff shiftr_mask_le)"], ["", "lemma aligned_mask_disjoint:\n  \"\\<lbrakk> is_aligned (a :: 'a :: len word) n; b \\<le> mask n \\<rbrakk> \\<Longrightarrow> a AND b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; b \\<le> mask n\\<rbrakk>\n    \\<Longrightarrow> a AND b = 0", "by (metis and_zero_eq is_aligned_mask le_mask_imp_and_mask word_bw_lcs(1))"], ["", "lemma word_and_or_mask_aligned:\n  \"\\<lbrakk> is_aligned a n; b \\<le> mask n \\<rbrakk> \\<Longrightarrow> a + b = a OR b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; b \\<le> mask n\\<rbrakk>\n    \\<Longrightarrow> a + b = a OR b", "by (simp add: aligned_mask_disjoint word_plus_and_or_coroll)"], ["", "lemma word_and_or_mask_aligned2:\n  \\<open>is_aligned b n \\<Longrightarrow> a \\<le> mask n \\<Longrightarrow> a + b = a OR b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned b n; a \\<le> mask n\\<rbrakk>\n    \\<Longrightarrow> a + b = a OR b", "using word_and_or_mask_aligned [of b n a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_aligned b n; a \\<le> mask n\\<rbrakk>\n  \\<Longrightarrow> b + a = b OR a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned b n; a \\<le> mask n\\<rbrakk>\n    \\<Longrightarrow> a + b = a OR b", "by (simp add: ac_simps)"], ["", "lemma is_aligned_ucastI:\n  \"is_aligned w n \\<Longrightarrow> is_aligned (ucast w) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w n \\<Longrightarrow>\n    is_aligned (UCAST('a \\<rightarrow> 'b) w) n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w n.\n       2 ^ n dvd take_bit LENGTH('a) w \\<Longrightarrow>\n       2 ^ n dvd take_bit LENGTH('b) (take_bit LENGTH('a) w)", "apply (auto simp add: min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w n.\n       \\<lbrakk>2 ^ n dvd take_bit LENGTH('a) w;\n        LENGTH('b) \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n dvd take_bit LENGTH('b) w", "apply (metis bintrunc_bintrunc_ge bintrunc_n_0 nat_less_le not_le take_bit_eq_0_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_le_maskI:\n  \"a \\<le> mask n \\<Longrightarrow> UCAST('a::len \\<rightarrow> 'b::len) a \\<le> mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> mask n \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) a \\<le> mask n", "by (metis and_mask_eq_iff_le_mask ucast_and_mask)"], ["", "lemma ucast_add_mask_aligned:\n  \"\\<lbrakk> a \\<le> mask n; is_aligned b n \\<rbrakk> \\<Longrightarrow> UCAST ('a::len \\<rightarrow> 'b::len) (a + b) = ucast a + ucast b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> mask n; is_aligned b n\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) (a + b) =\n                      UCAST('a \\<rightarrow> 'b) a +\n                      UCAST('a \\<rightarrow> 'b) b", "by (metis add.commute is_aligned_ucastI ucast_le_maskI ucast_or_distrib word_and_or_mask_aligned)"], ["", "lemma ucast_shiftl:\n  \"LENGTH('b) \\<le> LENGTH ('a) \\<Longrightarrow> UCAST ('a::len \\<rightarrow> 'b::len) x << n = ucast (x << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x << n = UCAST('a \\<rightarrow> 'b) (x << n)", "by word_eqI_solve"], ["", "lemma ucast_leq_mask:\n  \"LENGTH('a) \\<le> n \\<Longrightarrow> ucast (x::'a::len word) \\<le> mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) x \\<le> mask n", "apply (simp add: less_eq_mask_iff_take_bit_eq_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow>\n    take_bit n (UCAST('a \\<rightarrow> 'b) x) = UCAST('a \\<rightarrow> 'b) x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       LENGTH('a) \\<le> n \\<Longrightarrow>\n       take_bit LENGTH('b)\n        (take_bit (min LENGTH('b) n) (take_bit LENGTH('a) x)) =\n       take_bit LENGTH('b) (take_bit LENGTH('a) x)", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_inj:\n  \"\\<lbrakk> x << n = y << n; x \\<le> mask (LENGTH('a)-n); y \\<le> mask (LENGTH('a)-n) \\<rbrakk> \\<Longrightarrow>\n   x = (y :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x << n = y << n; x \\<le> mask (LENGTH('a) - n);\n     y \\<le> mask (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply word_eqI"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>na.\n                   (na < LENGTH('a) \\<and>\n                    n \\<le> na \\<and> x !! (na - n)) =\n                   (na < LENGTH('a) \\<and> n \\<le> na \\<and> y !! (na - n));\n        \\<forall>i\\<in>{LENGTH('a) - n..<LENGTH('a)}. \\<not> x !! i;\n        \\<forall>i\\<in>{LENGTH('a) - n..<LENGTH('a)}. \\<not> y !! i;\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> x !! na = y !! na", "apply (rename_tac n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       \\<lbrakk>\\<forall>na.\n                   (na < LENGTH('a) \\<and>\n                    n \\<le> na \\<and> x !! (na - n)) =\n                   (na < LENGTH('a) \\<and> n \\<le> na \\<and> y !! (na - n));\n        \\<forall>i\\<in>{LENGTH('a) - n..<LENGTH('a)}. \\<not> x !! i;\n        \\<forall>i\\<in>{LENGTH('a) - n..<LENGTH('a)}. \\<not> y !! i;\n        n' < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> x !! n' = y !! n'", "apply (case_tac \"LENGTH('a) - n \\<le> n'\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       \\<lbrakk>\\<forall>na.\n                   (na < LENGTH('a) \\<and>\n                    n \\<le> na \\<and> x !! (na - n)) =\n                   (na < LENGTH('a) \\<and> n \\<le> na \\<and> y !! (na - n));\n        \\<forall>i\\<in>{LENGTH('a) - n..<LENGTH('a)}. \\<not> x !! i;\n        \\<forall>i\\<in>{LENGTH('a) - n..<LENGTH('a)}. \\<not> y !! i;\n        n' < LENGTH('a); \\<not> LENGTH('a) - n \\<le> n'\\<rbrakk>\n       \\<Longrightarrow> x !! n' = y !! n'", "by (metis add.commute add.right_neutral diff_add_inverse le_diff_conv linorder_not_less zero_order(1))"], ["", "lemma distinct_word_add_ucast_shift_inj:\n  \"\\<lbrakk> p + (UCAST('a::len \\<rightarrow> 'b::len) off << n) = p' + (ucast off' << n);\n     is_aligned p n'; is_aligned p' n'; n' = n + LENGTH('a); n' < LENGTH('b) \\<rbrakk>\n   \\<Longrightarrow> p' = p \\<and> off' = off\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p + (UCAST('a \\<rightarrow> 'b) off << n) =\n             p' + (UCAST('a \\<rightarrow> 'b) off' << n);\n     is_aligned p n'; is_aligned p' n'; n' = n + LENGTH('a);\n     n' < LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> p' = p \\<and> off' = off", "apply (simp add: word_and_or_mask_aligned le_mask_shiftl_le_mask[where n=\"LENGTH('a)\"]\n                   ucast_leq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p OR (UCAST('a \\<rightarrow> 'b) off << n) =\n             p' OR (UCAST('a \\<rightarrow> 'b) off' << n);\n     is_aligned p (n + LENGTH('a)); is_aligned p' (n + LENGTH('a));\n     n' = n + LENGTH('a); n + LENGTH('a) < LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> p' = p \\<and> off' = off", "apply (simp add: is_aligned_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p OR (UCAST('a \\<rightarrow> 'b) off << n) =\n             p' OR (UCAST('a \\<rightarrow> 'b) off' << n);\n     \\<forall>na<n + LENGTH('a). \\<not> p !! na;\n     \\<forall>na<n + LENGTH('a). \\<not> p' !! na; n' = n + LENGTH('a);\n     n + LENGTH('a) < LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> p' = p \\<and> off' = off", "apply (rule conjI; word_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>na.\n                   (p !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off !! (na - n) \\<and> na - n < LENGTH('b)) =\n                   (p' !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off' !! (na - n) \\<and> na - n < LENGTH('b));\n        \\<forall>na<n + LENGTH('a). \\<not> p !! na;\n        \\<forall>na<n + LENGTH('a). \\<not> p' !! na; n' = n + LENGTH('a);\n        n + LENGTH('a) < LENGTH('b); na < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> p' !! na = p !! na\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>na.\n                   (p !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off !! (na - n) \\<and> na - n < LENGTH('b)) =\n                   (p' !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off' !! (na - n) \\<and> na - n < LENGTH('b));\n        \\<forall>na<n + LENGTH('a). \\<not> p !! na;\n        \\<forall>na<n + LENGTH('a). \\<not> p' !! na; n' = n + LENGTH('a);\n        n + LENGTH('a) < LENGTH('b); na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> off' !! na = off !! na", "apply (metis add.commute test_bit_conj_lt diff_add_inverse le_diff_conv nat_less_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>na.\n                   (p !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off !! (na - n) \\<and> na - n < LENGTH('b)) =\n                   (p' !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off' !! (na - n) \\<and> na - n < LENGTH('b));\n        \\<forall>na<n + LENGTH('a). \\<not> p !! na;\n        \\<forall>na<n + LENGTH('a). \\<not> p' !! na; n' = n + LENGTH('a);\n        n + LENGTH('a) < LENGTH('b); na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> off' !! na = off !! na", "apply (rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>na.\n                   (p !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off !! (na - n) \\<and> na - n < LENGTH('b)) =\n                   (p' !! na \\<or>\n                    na < LENGTH('b) \\<and>\n                    n \\<le> na \\<and>\n                    off' !! (na - n) \\<and> na - n < LENGTH('b));\n        \\<forall>na<n + LENGTH('a). \\<not> p !! na;\n        \\<forall>na<n + LENGTH('a). \\<not> p' !! na; n' = n + LENGTH('a);\n        n + LENGTH('a) < LENGTH('b); i < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> off' !! i = off !! i", "apply (erule_tac x=\"i+n\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>na<n + LENGTH('a). \\<not> p !! na;\n        \\<forall>na<n + LENGTH('a). \\<not> p' !! na; n' = n + LENGTH('a);\n        n + LENGTH('a) < LENGTH('b); i < LENGTH('a);\n        (p !! (i + n) \\<or>\n         i + n < LENGTH('b) \\<and>\n         n \\<le> i + n \\<and>\n         off !! (i + n - n) \\<and> i + n - n < LENGTH('b)) =\n        (p' !! (i + n) \\<or>\n         i + n < LENGTH('b) \\<and>\n         n \\<le> i + n \\<and>\n         off' !! (i + n - n) \\<and> i + n - n < LENGTH('b))\\<rbrakk>\n       \\<Longrightarrow> off' !! i = off !! i", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_upto_Nil:\n  \"y < x \\<Longrightarrow> [x .e. y ::'a::len word] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow> [x .e. y] = []", "by (simp add: upto_enum_red not_le word_less_nat_alt)"], ["", "lemma word_enum_decomp_elem:\n  assumes \"[x .e. (y ::'a::len word)] = as @ a # bs\"\n  shows \"x \\<le> a \\<and> a \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> a \\<and> a \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> a \\<and> a \\<le> y", "have \"set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]", "using assms"], ["proof (prove)\nusing this:\n  [x .e. y] = as @ a # bs\n\ngoal (1 subgoal):\n 1. set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]", "by (auto dest: arg_cong[where f=set])"], ["proof (state)\nthis:\n  set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]\n\ngoal (1 subgoal):\n 1. x \\<le> a \\<and> a \\<le> y", "then"], ["proof (chain)\npicking this:\n  set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]", "show ?thesis"], ["proof (prove)\nusing this:\n  set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]\n\ngoal (1 subgoal):\n 1. x \\<le> a \\<and> a \\<le> y", "by auto"], ["proof (state)\nthis:\n  x \\<le> a \\<and> a \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_word_not_less[simp]:\n   \"\\<not> max_word < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> - 1 < x", "by (simp add: not_less)"], ["", "lemma word_enum_prefix:\n  \"[x .e. (y ::'a::len word)] = as @ a # bs \\<Longrightarrow> as = (if x < a then [x .e. a - 1] else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x .e. y] = as @ a # bs \\<Longrightarrow>\n    as = (if x < a then [x .e. a - 1] else [])", "apply (induct as arbitrary: x; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 2. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (case_tac \"x < y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 2. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 3. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 2. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 3. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (case_tac \"x = y\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; \\<not> x < y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 2. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 3. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (simp add: not_less)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; y \\<le> x; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 2. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 3. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (drule (1) dual_order.not_eq_order_implies_strict)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; y \\<le> x; y < x\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 2. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 3. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (simp add: word_upto_Nil)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x .e. y] = a # bs; x < a; x < y\\<rbrakk>\n       \\<Longrightarrow> [] = [x .e. a - 1]\n 2. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (simp add: word_upto_Cons_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (case_tac \"x < y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a\n 2. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a\n 2. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (case_tac \"x = y\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; \\<not> x < y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a\n 2. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (simp add: not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; y \\<le> x; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a\n 2. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (drule (1) dual_order.not_eq_order_implies_strict)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; y \\<le> x; y < x\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a\n 2. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (simp add: word_upto_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as x.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [x .e. y] = aa # as @ a # bs; x < y\\<rbrakk>\n       \\<Longrightarrow> (x < a \\<longrightarrow>\n                          aa # as = [x .e. a - 1]) \\<and>\n                         x < a", "apply (clarsimp simp: word_upto_Cons_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y\\<rbrakk>\n       \\<Longrightarrow> (aa < a \\<longrightarrow>\n                          aa # as = [aa .e. a - 1]) \\<and>\n                         aa < a", "apply (frule word_enum_decomp_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y;\n        aa + 1 \\<le> a \\<and> a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (aa < a \\<longrightarrow>\n                          aa # as = [aa .e. a - 1]) \\<and>\n                         aa < a", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (aa < a \\<longrightarrow>\n                          aa # as = [aa .e. a - 1]) \\<and>\n                         aa < a", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> aa < a \\<longrightarrow> aa # as = [aa .e. a - 1]\n 2. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> aa < a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> aa < a\n 2. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> aa < a \\<longrightarrow> aa # as = [aa .e. a - 1]", "apply (subst word_Suc_le[symmetric]; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       \\<lbrakk>\\<And>x.\n                   [x .e. y] = as @ a # bs \\<Longrightarrow>\n                   as = (if x < a then [x .e. a - 1] else []);\n        [aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> aa < a \\<longrightarrow> aa # as = [aa .e. a - 1]", "apply (drule meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       \\<lbrakk>[aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y;\n        [?x41 aa as .e. y] = as @ a # bs \\<Longrightarrow>\n        as =\n        (if ?x41 aa as < a then [?x41 aa as .e. a - 1] else [])\\<rbrakk>\n       \\<Longrightarrow> aa < a \\<longrightarrow> aa # as = [aa .e. a - 1]", "apply (drule (1) meta_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       \\<lbrakk>[aa + 1 .e. y] = as @ a # bs; aa < y; aa + 1 \\<le> a;\n        a \\<le> y;\n        as = (if aa + 1 < a then [aa + 1 .e. a - 1] else [])\\<rbrakk>\n       \\<Longrightarrow> aa < a \\<longrightarrow> aa # as = [aa .e. a - 1]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>[aa + 1 .e. y] =\n                (if aa + 1 < a then [aa + 1 .e. a - 1] else []) @ a # bs;\n        aa < y; aa + 1 \\<le> a; a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (aa + 1 < a \\<longrightarrow>\n                          aa < a \\<longrightarrow>\n                          aa # [aa + 1 .e. a - 1] = [aa .e. a - 1]) \\<and>\n                         (aa + 1 = a \\<longrightarrow>\n                          aa < a \\<longrightarrow> [aa] = [aa .e. a - 1])", "apply (rule conjI; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>[aa + 1 .e. y] = [aa + 1 .e. a - 1] @ a # bs; aa < y;\n        aa + 1 \\<le> a; a \\<le> y; aa + 1 < a; aa < a\\<rbrakk>\n       \\<Longrightarrow> aa # [aa + 1 .e. a - 1] = [aa .e. a - 1]", "apply (subst (2) word_upto_Cons_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>[aa + 1 .e. y] = [aa + 1 .e. a - 1] @ a # bs; aa < y;\n        aa + 1 \\<le> a; a \\<le> y; aa + 1 < a; aa < a\\<rbrakk>\n       \\<Longrightarrow> aa < a - 1\n 2. \\<And>aa.\n       \\<lbrakk>[aa + 1 .e. y] = [aa + 1 .e. a - 1] @ a # bs; aa < y;\n        aa + 1 \\<le> a; a \\<le> y; aa + 1 < a; aa < a\\<rbrakk>\n       \\<Longrightarrow> aa # [aa + 1 .e. a - 1] = aa # [aa + 1 .e. a - 1]", "apply unat_arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>[aa + 1 .e. y] = [aa + 1 .e. a - 1] @ a # bs; aa < y;\n        aa + 1 \\<le> a; a \\<le> y; aa + 1 < a; aa < a\\<rbrakk>\n       \\<Longrightarrow> aa # [aa + 1 .e. a - 1] = aa # [aa + 1 .e. a - 1]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_enum_decomp_set:\n  \"[x .e. (y ::'a::len word)] = as @ a # bs \\<Longrightarrow> a \\<notin> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x .e. y] = as @ a # bs \\<Longrightarrow> a \\<notin> set as", "by (metis distinct_append distinct_enum_upto' not_distinct_conv_prefix)"], ["", "lemma word_enum_decomp:\n  assumes \"[x .e. (y ::'a::len word)] = as @ a # bs\"\n  shows \"x \\<le> a \\<and> a \\<le> y \\<and> a \\<notin> set as \\<and> (\\<forall>z \\<in> set as. x \\<le> z \\<and> z \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> a \\<and>\n    a \\<le> y \\<and>\n    a \\<notin> set as \\<and>\n    (\\<forall>z\\<in>set as. x \\<le> z \\<and> z \\<le> y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> a \\<and>\n    a \\<le> y \\<and>\n    a \\<notin> set as \\<and>\n    (\\<forall>z\\<in>set as. x \\<le> z \\<and> z \\<le> y)", "from assms"], ["proof (chain)\npicking this:\n  [x .e. y] = as @ a # bs", "have \"set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]\""], ["proof (prove)\nusing this:\n  [x .e. y] = as @ a # bs\n\ngoal (1 subgoal):\n 1. set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]", "by (auto dest: arg_cong[where f=set])"], ["proof (state)\nthis:\n  set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]\n\ngoal (1 subgoal):\n 1. x \\<le> a \\<and>\n    a \\<le> y \\<and>\n    a \\<notin> set as \\<and>\n    (\\<forall>z\\<in>set as. x \\<le> z \\<and> z \\<le> y)", "with word_enum_decomp_set[OF assms]"], ["proof (chain)\npicking this:\n  a \\<notin> set as\n  set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> set as\n  set as \\<subseteq> set [x .e. y] \\<and> a \\<in> set [x .e. y]\n\ngoal (1 subgoal):\n 1. x \\<le> a \\<and>\n    a \\<le> y \\<and>\n    a \\<notin> set as \\<and>\n    (\\<forall>z\\<in>set as. x \\<le> z \\<and> z \\<le> y)", "by auto"], ["proof (state)\nthis:\n  x \\<le> a \\<and>\n  a \\<le> y \\<and>\n  a \\<notin> set as \\<and>\n  (\\<forall>z\\<in>set as. x \\<le> z \\<and> z \\<le> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_nat_unat_le_mask_ucast:\n  \"\\<lbrakk>of_nat (unat t) = w; t \\<le> mask LENGTH('a)\\<rbrakk> \\<Longrightarrow> t = UCAST('a::len \\<rightarrow> 'b::len) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_of_nat (unat t) = w; t \\<le> mask LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> t = UCAST('a \\<rightarrow> 'b) w", "by (clarsimp simp: ucast_nat_def ucast_ucast_mask simp flip: and_mask_eq_iff_le_mask)"], ["", "lemma less_diff_gt0:\n  \"a < b \\<Longrightarrow> (0 :: 'a :: len word) < b - a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> 0 < b - a", "by unat_arith"], ["", "lemma unat_plus_gt:\n  \"unat ((a :: 'a :: len word) + b) \\<le> unat a + unat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (a + b) \\<le> unat a + unat b", "by (clarsimp simp: unat_plus_if_size)"], ["", "lemma const_less:\n  \"\\<lbrakk> (a :: 'a :: len word) - 1 < b; a \\<noteq> b \\<rbrakk> \\<Longrightarrow> a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a - 1 < b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> a < b", "by (metis less_1_simp word_le_less_eq)"], ["", "lemma add_mult_aligned_neg_mask:\n  \\<open>(x + y * m) AND NOT(mask n) = (x AND NOT(mask n)) + y * m\\<close>\n  if \\<open>m AND (2 ^ n - 1) = 0\\<close>\n  for x y m :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y * m AND NOT (mask n) = (x AND NOT (mask n)) + y * m", "by (metis (no_types, hide_lams)\n    add.assoc add.commute add.right_neutral add_uminus_conv_diff\n   mask_eq_decr_exp mask_eqs(2) mask_eqs(6) mult.commute mult_zero_left\n   subtract_mask(1) that)"], ["", "lemma unat_of_nat_minus_1:\n  \"\\<lbrakk> n < 2 ^ LENGTH('a); n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> unat ((of_nat n:: 'a :: len word) - 1) = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ LENGTH('a); n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (word_of_nat n - 1) = n - 1", "by (simp add: of_nat_diff unat_eq_of_nat)"], ["", "lemma word_eq_zeroI:\n  \"a \\<le> a - 1 \\<Longrightarrow> a = 0\" for a :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> a - 1 \\<Longrightarrow> a = 0", "by (simp add: word_must_wrap)"], ["", "lemma word_add_format:\n  \"(-1 :: 'a :: len  word) + b + c = b + (c - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 + b + c = b + (c - 1)", "by simp"], ["", "lemma upto_enum_word_nth:\n  \"\\<lbrakk> i \\<le> j; k \\<le> unat (j - i) \\<rbrakk> \\<Longrightarrow> [i .e. j] ! k = i + of_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i)\\<rbrakk>\n    \\<Longrightarrow> [i .e. j] ! k = i + word_of_nat k", "apply (clarsimp simp: upto_enum_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i)\\<rbrakk>\n    \\<Longrightarrow> (k < unat j - unat i \\<longrightarrow>\n                       (unat i \\<le> unat j \\<longrightarrow>\n                        toEnum (unat i + k) = i + word_of_nat k) \\<and>\n                       (\\<not> unat i \\<le> unat j \\<longrightarrow>\n                        [] ! k = i + word_of_nat k)) \\<and>\n                      (\\<not> k < unat j - unat i \\<longrightarrow>\n                       (unat i \\<le> unat j \\<longrightarrow>\n                        [j] ! (k + unat i - unat j) =\n                        i + word_of_nat k) \\<and>\n                       (\\<not> unat i \\<le> unat j \\<longrightarrow>\n                        [] ! k = i + word_of_nat k))", "apply (clarsimp simp: word_le_nat_alt[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i)\\<rbrakk>\n    \\<Longrightarrow> (k < unat j - unat i \\<longrightarrow>\n                       toEnum (unat i + k) = i + word_of_nat k) \\<and>\n                      (\\<not> k < unat j - unat i \\<longrightarrow>\n                       [j] ! (k + unat i - unat j) = i + word_of_nat k)", "apply (rule conjI, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i); k < unat j - unat i\\<rbrakk>\n    \\<Longrightarrow> toEnum (unat i + k) = i + word_of_nat k\n 2. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i)\\<rbrakk>\n    \\<Longrightarrow> \\<not> k < unat j - unat i \\<longrightarrow>\n                      [j] ! (k + unat i - unat j) = i + word_of_nat k", "apply (subst toEnum_of_nat, unat_arith)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i); k < unat j - unat i\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (unat i + k) = i + word_of_nat k\n 2. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i)\\<rbrakk>\n    \\<Longrightarrow> \\<not> k < unat j - unat i \\<longrightarrow>\n                      [j] ! (k + unat i - unat j) = i + word_of_nat k", "apply unat_arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; k \\<le> unat (j - i)\\<rbrakk>\n    \\<Longrightarrow> \\<not> k < unat j - unat i \\<longrightarrow>\n                      [j] ! (k + unat i - unat j) = i + word_of_nat k", "apply (clarsimp simp: not_less unat_sub[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; k = unat (j - i)\\<rbrakk>\n    \\<Longrightarrow> [j] ! (unat (j - i) + unat i - unat j) = j", "apply unat_arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upto_enum_step_nth:\n  \"\\<lbrakk> a \\<le> c; n \\<le> unat ((c - a) div (b - a)) \\<rbrakk>\n   \\<Longrightarrow> [a, b .e. c] ! n = a + of_nat n * (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> c; n \\<le> unat ((c - a) div (b - a))\\<rbrakk>\n    \\<Longrightarrow> [a , b .e. c] ! n = a + word_of_nat n * (b - a)", "by (clarsimp simp: upto_enum_step_def not_less[symmetric] upto_enum_word_nth)"], ["", "lemma upto_enum_inc_1_len:\n  \"a < - 1 \\<Longrightarrow> [(0 :: 'a :: len word) .e. 1 + a] = [0 .e. a] @ [1 + a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < - 1 \\<Longrightarrow> [0 .e. 1 + a] = [0 .e. a] @ [1 + a]", "apply (simp add: upto_enum_word)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < - 1 \\<Longrightarrow>\n    map word_of_nat [0..<unat (1 + a)] = map word_of_nat [0..<unat a] @ [a]", "apply (subgoal_tac \"unat (1+a) = 1 + unat a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a < - 1; unat (1 + a) = 1 + unat a\\<rbrakk>\n    \\<Longrightarrow> map word_of_nat [0..<unat (1 + a)] =\n                      map word_of_nat [0..<unat a] @ [a]\n 2. a < - 1 \\<Longrightarrow> unat (1 + a) = 1 + unat a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < - 1 \\<Longrightarrow> unat (1 + a) = 1 + unat a", "apply (subst unat_plus_simple[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a < - 1 \\<Longrightarrow> 1 \\<le> 1 + a\n 2. a < - 1 \\<Longrightarrow> unat 1 + unat a = 1 + unat a", "apply (metis add.commute no_plus_overflow_neg olen_add_eqv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < - 1 \\<Longrightarrow> unat 1 + unat a = 1 + unat a", "apply unat_arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma neg_mask_add:\n  \"y AND mask n = 0 \\<Longrightarrow> x + y AND NOT(mask n) = (x AND NOT(mask n)) + y\"\n  for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. y AND mask n = 0 \\<Longrightarrow>\n    x + y AND NOT (mask n) = (x AND NOT (mask n)) + y", "by (clarsimp simp: mask_out_sub_mask mask_eqs(7)[symmetric] mask_twice)"], ["", "lemma shiftr_shiftl_shiftr[simp]:\n  \"(x :: 'a :: len word)  >> a << a >> a = x >> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> a << a >> a = x >> a", "by word_eqI_solve"], ["", "lemma add_right_shift:\n  \"\\<lbrakk> x AND mask n = 0; y AND mask n = 0; x \\<le> x + y \\<rbrakk>\n   \\<Longrightarrow> (x + y :: ('a :: len) word) >> n = (x >> n) + (y >> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND mask n = 0; y AND mask n = 0; x \\<le> x + y\\<rbrakk>\n    \\<Longrightarrow> x + y >> n = (x >> n) + (y >> n)", "apply (simp add: no_olen_add_nat is_aligned_mask[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n;\n     unat x + unat y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + y >> n = (x >> n) + (y >> n)", "apply (simp add: unat_arith_simps shiftr_div_2n' split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n;\n     unat x + unat y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (unat x + unat y) div 2 ^ n =\n                      (if unat x div 2 ^ n + unat y div 2 ^ n\n                          < 2 ^ LENGTH('a)\n                       then unat (x >> n) + unat (y >> n)\n                       else unat (x >> n) + unat (y >> n) - 2 ^ LENGTH('a))", "apply (subst if_P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n;\n     unat x + unat y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x div 2 ^ n + unat y div 2 ^ n < 2 ^ LENGTH('a)\n 2. \\<lbrakk>is_aligned x n; is_aligned y n;\n     unat x + unat y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (unat x + unat y) div 2 ^ n =\n                      unat (x >> n) + unat (y >> n)", "apply (erule order_le_less_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n\\<rbrakk>\n    \\<Longrightarrow> unat x div 2 ^ n + unat y div 2 ^ n\n                      \\<le> unat x + unat y\n 2. \\<lbrakk>is_aligned x n; is_aligned y n;\n     unat x + unat y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (unat x + unat y) div 2 ^ n =\n                      unat (x >> n) + unat (y >> n)", "apply (simp add: add_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n;\n     unat x + unat y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (unat x + unat y) div 2 ^ n =\n                      unat (x >> n) + unat (y >> n)", "apply (simp add: shiftr_div_2n' is_aligned_iff_dvd_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sub_right_shift:\n  \"\\<lbrakk> x AND mask n = 0; y AND mask n = 0; y \\<le> x \\<rbrakk>\n   \\<Longrightarrow> (x - y) >> n = (x >> n :: 'a :: len word) - (y >> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND mask n = 0; y AND mask n = 0; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - y >> n = (x >> n) - (y >> n)", "using add_right_shift[where x=\"x - y\" and y=y and n=n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x - y AND mask n = 0; y AND mask n = 0;\n   x - y \\<le> x - y + y\\<rbrakk>\n  \\<Longrightarrow> x - y + y >> n = (x - y >> n) + (y >> n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND mask n = 0; y AND mask n = 0; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - y >> n = (x >> n) - (y >> n)", "by (simp add: aligned_sub_aligned is_aligned_mask[symmetric] word_sub_le)"], ["", "lemma and_and_mask_simple:\n  \"y AND mask n = mask n \\<Longrightarrow> (x AND y) AND mask n = x AND mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y AND mask n = mask n \\<Longrightarrow>\n    (x AND y) AND mask n = x AND mask n", "by (simp add: ac_simps)"], ["", "lemma and_and_mask_simple_not:\n  \"y AND mask n = 0 \\<Longrightarrow> (x AND y) AND mask n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y AND mask n = (0::'a) \\<Longrightarrow> (x AND y) AND mask n = (0::'a)", "by (simp add: ac_simps)"], ["", "lemma word_and_le':\n  \"b \\<le> c \\<Longrightarrow> (a :: 'a :: len word) AND b \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> c \\<Longrightarrow> a AND b \\<le> c", "by (metis word_and_le1 order_trans)"], ["", "lemma word_and_less':\n  \"b < c \\<Longrightarrow> (a :: 'a :: len word) AND b < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < c \\<Longrightarrow> a AND b < c", "by transfer simp"], ["", "lemma shiftr_w2p:\n  \"x < LENGTH('a) \\<Longrightarrow> 2 ^ x = (2 ^ (LENGTH('a) - 1) >> (LENGTH('a) - 1 - x) :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < LENGTH('a) \\<Longrightarrow>\n    2 ^ x = 2 ^ (LENGTH('a) - 1) >> LENGTH('a) - 1 - x", "by word_eqI_solve"], ["", "lemma t2p_shiftr:\n  \"\\<lbrakk> b \\<le> a; a < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 :: 'a :: len word) ^ a >> b = 2 ^ (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> a; a < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ a >> b = 2 ^ (a - b)", "by word_eqI_solve"], ["", "lemma scast_1[simp]:\n  \"scast (1 :: 'a :: len signed word) = (1 :: 'a word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a signed \\<rightarrow> 'a) 1 = 1", "by simp"], ["", "lemma unsigned_uminus1 [simp]:\n  \\<open>(unsigned (-1::'b::len word)::'c::len word) = mask LENGTH('b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('b \\<rightarrow> 'c) (- 1) = mask LENGTH('b)", "by word_eqI"], ["", "lemma ucast_ucast_mask_eq:\n  \"\\<lbrakk> UCAST('a::len \\<rightarrow> 'b::len) x = y; x AND mask LENGTH('b) = x \\<rbrakk> \\<Longrightarrow> x = ucast y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>UCAST('a \\<rightarrow> 'b) x = y;\n     x AND mask LENGTH('b) = x\\<rbrakk>\n    \\<Longrightarrow> x = UCAST('b \\<rightarrow> 'a) y", "by word_eqI_solve"], ["", "lemma ucast_up_eq:\n  \"\\<lbrakk> ucast x = (ucast y::'b::len word); LENGTH('a) \\<le> LENGTH ('b) \\<rbrakk>\n   \\<Longrightarrow> ucast x = (ucast y::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>UCAST('c \\<rightarrow> 'b) x = UCAST('d \\<rightarrow> 'b) y;\n     LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> UCAST('c \\<rightarrow> 'a) x =\n                      UCAST('d \\<rightarrow> 'a) y", "by word_eqI_solve"], ["", "lemma ucast_up_neq:\n  \"\\<lbrakk> ucast x \\<noteq> (ucast y::'b::len word); LENGTH('b) \\<le> LENGTH ('a) \\<rbrakk>\n   \\<Longrightarrow> ucast x \\<noteq> (ucast y::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>UCAST('c \\<rightarrow> 'b) x \\<noteq>\n             UCAST('d \\<rightarrow> 'b) y;\n     LENGTH('b) \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> UCAST('c \\<rightarrow> 'a) x \\<noteq>\n                      UCAST('d \\<rightarrow> 'a) y", "by (fastforce dest: ucast_up_eq)"], ["", "lemma mask_AND_less_0:\n  \"\\<lbrakk> x AND mask n = 0; m \\<le> n \\<rbrakk> \\<Longrightarrow> x AND mask m = 0\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND mask n = 0; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x AND mask m = 0", "by (metis mask_twice2 word_and_notzeroD)"], ["", "lemma mask_len_id [simp]:\n  \"(x :: 'a :: len word) AND mask LENGTH('a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND mask LENGTH('a) = x", "using uint_lt2p [of x]"], ["proof (prove)\nusing this:\n  uint x < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. x AND mask LENGTH('a) = x", "by (simp add: mask_eq_iff)"], ["", "lemma scast_ucast_down_same:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow> SCAST('a \\<rightarrow> 'b) = UCAST('a::len \\<rightarrow> 'b::len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n    SCAST('a \\<rightarrow> 'b) = UCAST('a \\<rightarrow> 'b)", "by (simp add: down_cast_same is_down)"], ["", "lemma word_aligned_0_sum:\n  \"\\<lbrakk> a + b = 0; is_aligned (a :: 'a :: len word) n; b \\<le> mask n; n < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> a = 0 \\<and> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + b = 0; is_aligned a n; b \\<le> mask n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a = 0 \\<and> b = 0", "by (simp add: word_plus_and_or_coroll aligned_mask_disjoint word_or_zero)"], ["", "lemma mask_eq1_nochoice:\n  \"\\<lbrakk> LENGTH('a) > 1; (x :: 'a :: len word) AND 1 = x \\<rbrakk> \\<Longrightarrow> x = 0 \\<or> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < LENGTH('a); x AND 1 = x\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "by (metis word_and_1)"], ["", "lemma shiftr_and_eq_shiftl:\n  \"(w >> n) AND x = y \\<Longrightarrow> w AND (x << n) = (y << n)\" for y :: \"'a:: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w >> n) AND x = y \\<Longrightarrow> w AND (x << n) = y << n", "by (metis (no_types, lifting) and_not_mask bit.conj_ac(1) bit.conj_ac(2) mask_eq_0_eq_x shiftl_mask_is_0 shiftl_over_and_dist)"], ["", "lemma add_mask_lower_bits':\n  \"\\<lbrakk> len = LENGTH('a); is_aligned (x :: 'a :: len word) n;\n     \\<forall>n' \\<ge> n. n' < len \\<longrightarrow> \\<not> p !! n' \\<rbrakk>\n   \\<Longrightarrow> x + p AND NOT(mask n) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>len = LENGTH('a); is_aligned x n;\n     \\<forall>n'\\<ge>n. n' < len \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> x + p AND NOT (mask n) = x", "using add_mask_lower_bits"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_aligned ?x ?n;\n   \\<forall>n'\\<ge>?n.\n      n' < LENGTH(?'a) \\<longrightarrow> \\<not> ?p !! n'\\<rbrakk>\n  \\<Longrightarrow> ?x + ?p AND NOT (mask ?n) = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>len = LENGTH('a); is_aligned x n;\n     \\<forall>n'\\<ge>n. n' < len \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> x + p AND NOT (mask n) = x", "by auto"], ["", "lemma leq_mask_shift:\n  \"(x :: 'a :: len word) \\<le> mask (low_bits + high_bits) \\<Longrightarrow> (x >> low_bits) \\<le> mask high_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> mask (low_bits + high_bits) \\<Longrightarrow>\n    x >> low_bits \\<le> mask high_bits", "by (simp add: le_mask_iff shiftr_shiftr)"], ["", "lemma ucast_ucast_eq_mask_shift:\n  \"(x :: 'a :: len word) \\<le> mask (low_bits + LENGTH('b))\n   \\<Longrightarrow> ucast((ucast (x >> low_bits)) :: 'b :: len word) = x >> low_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> mask (low_bits + LENGTH('b)) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'a)\n     (UCAST('a \\<rightarrow> 'b) (x >> low_bits)) =\n    x >> low_bits", "by (meson and_mask_eq_iff_le_mask eq_ucast_ucast_eq not_le_imp_less shiftr_less_t2n'\n            ucast_ucast_len)"], ["", "lemma const_le_unat:\n  \"\\<lbrakk> b < 2 ^ LENGTH('a); of_nat b \\<le> a \\<rbrakk> \\<Longrightarrow> b \\<le> unat (a :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 2 ^ LENGTH('a); word_of_nat b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> b \\<le> unat a", "apply (simp add: word_le_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 2 ^ LENGTH('a);\n     int (take_bit LENGTH('a) b) \\<le> uint a\\<rbrakk>\n    \\<Longrightarrow> b \\<le> unat a", "apply (simp only: uint_nat zle_int)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 2 ^ LENGTH('a); take_bit LENGTH('a) b \\<le> unat a\\<rbrakk>\n    \\<Longrightarrow> b \\<le> unat a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       \\<lbrakk>b < 2 ^ LENGTH('a);\n        take_bit LENGTH('a) b\n        \\<le> (nat \\<circ> take_bit LENGTH('a)) a\\<rbrakk>\n       \\<Longrightarrow> b \\<le> (nat \\<circ> take_bit LENGTH('a)) a", "apply (simp add: take_bit_nat_eq_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upt_enum_offset_trivial:\n  \"\\<lbrakk> x < 2 ^ LENGTH('a) - 1 ; n \\<le> unat x \\<rbrakk>\n   \\<Longrightarrow> ([(0 :: 'a :: len word) .e. x] ! n) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a) - 1; n \\<le> unat x\\<rbrakk>\n    \\<Longrightarrow> [0 .e. x] ! n = word_of_nat n", "apply (induct x arbitrary: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n.\n       \\<lbrakk>y \\<in> {f. \\<forall>i.\n                               f i \\<longrightarrow> i < LENGTH('a)};\n        set_bits y < 2 ^ LENGTH('a) - 1; n \\<le> unat (set_bits y)\\<rbrakk>\n       \\<Longrightarrow> [0 .e. set_bits y] ! n = word_of_nat n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n.\n       \\<lbrakk>\\<forall>i. y i \\<longrightarrow> i < LENGTH('a);\n        set_bits y < - 1; n \\<le> unat (set_bits y)\\<rbrakk>\n       \\<Longrightarrow> [0 .e. set_bits y] ! n = word_of_nat n", "by (simp add: upto_enum_word_nth)"], ["", "lemma word_le_mask_out_plus_2sz:\n  \"x \\<le> (x AND NOT(mask sz)) + 2 ^ sz - 1\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (x AND NOT (mask sz)) + 2 ^ sz - 1", "by (metis add_diff_eq word_neg_and_le)"], ["", "lemma ucast_add:\n  \"ucast (a + (b :: 'a :: len word)) = ucast a + (ucast b :: ('a signed word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'a signed) (a + b) =\n    UCAST('a \\<rightarrow> 'a signed) a +\n    UCAST('a \\<rightarrow> 'a signed) b", "by transfer (simp add: take_bit_add)"], ["", "lemma ucast_minus:\n  \"ucast (a - (b :: 'a :: len word)) = ucast a - (ucast b :: ('a signed word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'a signed) (a - b) =\n    UCAST('a \\<rightarrow> 'a signed) a -\n    UCAST('a \\<rightarrow> 'a signed) b", "apply (insert ucast_add[where a=a and b=\"-b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'a signed) (a + - b) =\n    UCAST('a \\<rightarrow> 'a signed) a +\n    UCAST('a \\<rightarrow> 'a signed) (- b) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'a signed) (a - b) =\n    UCAST('a \\<rightarrow> 'a signed) a -\n    UCAST('a \\<rightarrow> 'a signed) b", "apply (metis (no_types, hide_lams) add_diff_eq diff_add_cancel ucast_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scast_ucast_add_one [simp]:\n  \"scast (ucast (x :: 'a::len word) + (1 :: 'a signed word)) = x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a signed \\<rightarrow> 'a)\n     (UCAST('a \\<rightarrow> 'a signed) x + 1) =\n    x + 1", "apply (subst ucast_1[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a signed \\<rightarrow> 'a)\n     (UCAST('a \\<rightarrow> 'a signed) x +\n      UCAST(?'aa \\<rightarrow> 'a signed) 1) =\n    x + 1", "apply (subst ucast_add[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a signed \\<rightarrow> 'a)\n     (UCAST('a \\<rightarrow> 'a signed) (x + 1)) =\n    x + 1", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_and_le_plus_one:\n  \"a > 0 \\<Longrightarrow> (x :: 'a :: len word) AND (a - 1) < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> x AND a - 1 < a", "by (simp add: gt0_iff_gem1 word_and_less')"], ["", "lemma unat_of_ucast_then_shift_eq_unat_of_shift[simp]:\n  \"LENGTH('b) \\<ge> LENGTH('a)\n   \\<Longrightarrow> unat ((ucast (x :: 'a :: len word) :: 'b :: len word) >> n) = unat (x >> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    unat (UCAST('a \\<rightarrow> 'b) x >> n) = unat (x >> n)", "by (simp add: shiftr_div_2n' unat_ucast_up_simp)"], ["", "lemma unat_of_ucast_then_mask_eq_unat_of_mask[simp]:\n  \"LENGTH('b) \\<ge> LENGTH('a)\n   \\<Longrightarrow> unat ((ucast (x :: 'a :: len word) :: 'b :: len word) AND mask m) = unat (x AND mask m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    unat (UCAST('a \\<rightarrow> 'b) x AND mask m) = unat (x AND mask m)", "by (metis ucast_and_mask unat_ucast_up_simp)"], ["", "lemma shiftr_less_t2n3:\n  \"\\<lbrakk> (2 :: 'a word) ^ (n + m) = 0; m < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> (x :: 'a :: len word) >> n < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ (n + m) = 0; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x >> n < 2 ^ m", "by (fastforce intro: shiftr_less_t2n' simp: mask_eq_decr_exp power_overflow)"], ["", "lemma unat_shiftr_le_bound:\n  \"\\<lbrakk> 2 ^ (LENGTH('a :: len) - n) - 1 \\<le> bnd; 0 < n \\<rbrakk>\n   \\<Longrightarrow> unat ((x :: 'a word) >> n) \\<le> bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ (LENGTH('a) - n) - 1 \\<le> bnd; 0 < n\\<rbrakk>\n    \\<Longrightarrow> unat (x >> n) \\<le> bnd", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - 1 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> (nat \\<circ> take_bit LENGTH('a))\n                          ((drop_bit n \\<circ> take_bit LENGTH('a)) x)\n                         \\<le> bnd", "apply (simp add: take_bit_drop_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - Suc 0 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> nat (drop_bit n (take_bit LENGTH('a) x)) \\<le> bnd", "apply (simp add: drop_bit_take_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - Suc 0 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit (LENGTH('a) - n) (drop_bit n x))\n                         \\<le> bnd", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - Suc 0 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit (LENGTH('a) - n) (drop_bit n x))\n                         \\<le> ?y185 n bnd x\n 2. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - Suc 0 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> ?y185 n bnd x \\<le> bnd", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - Suc 0 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> ?y185 n bnd x \\<le> bnd\n 2. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - Suc 0 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit (LENGTH('a) - n) (drop_bit n x))\n                         \\<le> ?y185 n bnd x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bnd x.\n       \\<lbrakk>2 ^ (LENGTH('a) - n) - Suc 0 \\<le> bnd; 0 < n\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit (LENGTH('a) - n) (drop_bit n x))\n                         \\<le> 2 ^ (LENGTH('a) - n) - Suc 0", "apply (simp add: nat_le_iff of_nat_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftr_eqD:\n  \"\\<lbrakk> x >> n = y >> n; is_aligned x n; is_aligned y n \\<rbrakk>\n   \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x >> n = y >> n; is_aligned x n; is_aligned y n\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis is_aligned_shiftr_shiftl)"], ["", "lemma word_shiftr_shiftl_shiftr_eq_shiftr:\n  \"a \\<ge> b \\<Longrightarrow> (x :: 'a :: len word) >> a << b >> b = x >> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow> x >> a << b >> b = x >> a", "by (simp add: mask_shift multi_shift_simps(5) shiftr_shiftr)"], ["", "lemma of_int_uint_ucast:\n   \"of_int (uint (x :: 'a::len word)) = (ucast x :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (uint x) = UCAST('a \\<rightarrow> 'b) x", "by (fact Word.of_int_uint)"], ["", "lemma mod_mask_drop:\n  \"\\<lbrakk> m = 2 ^ n; 0 < m; mask n AND msk = mask n \\<rbrakk>\n   \\<Longrightarrow> (x mod m) AND msk = x mod m\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 2 ^ n; 0 < m; mask n AND msk = mask n\\<rbrakk>\n    \\<Longrightarrow> x mod m AND msk = x mod m", "by (simp add: word_mod_2p_is_mask word_bw_assocs)"], ["", "lemma mask_eq_ucast_eq:\n  \"\\<lbrakk> x AND mask LENGTH('a) = (x :: ('c :: len word));\n     LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> ucast (ucast x :: ('a :: len word)) = (ucast x :: ('b :: len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND mask LENGTH('a) = x; LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> UCAST('a \\<rightarrow> 'b)\n                       (UCAST('c \\<rightarrow> 'a) x) =\n                      UCAST('c \\<rightarrow> 'b) x", "by (metis ucast_and_mask ucast_id ucast_ucast_mask ucast_up_eq)"], ["", "lemma of_nat_less_t2n:\n  \"of_nat i < (2 :: ('a :: len) word) ^ n \\<Longrightarrow> n < LENGTH('a) \\<and> unat (of_nat i :: 'a word) < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat i < 2 ^ n \\<Longrightarrow>\n    n < LENGTH('a) \\<and> unat (word_of_nat i) < 2 ^ n", "by (metis order_less_trans p2_gt_0 unat_less_power word_neq_0_conv)"], ["", "lemma two_power_increasing_less_1:\n  \"\\<lbrakk> n \\<le> m; m \\<le> LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 :: 'a :: len word) ^ n - 1 \\<le> 2 ^ m - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> m; m \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 \\<le> 2 ^ m - 1", "by (metis diff_diff_cancel le_m1_iff_lt less_imp_diff_less p2_gt_0 two_power_increasing\n            word_1_le_power word_le_minus_mono_left word_less_sub_1)"], ["", "lemma word_sub_mono4:\n  \"\\<lbrakk> y + x \\<le> z + x; y \\<le> y + x; z \\<le> z + x \\<rbrakk> \\<Longrightarrow> y \\<le> z\" for y :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y + x \\<le> z + x; y \\<le> y + x; z \\<le> z + x\\<rbrakk>\n    \\<Longrightarrow> y \\<le> z", "by (simp add: word_add_le_iff2)"], ["", "lemma eq_or_less_helperD:\n  \"\\<lbrakk> n = unat (2 ^ m - 1 :: 'a :: len word) \\<or> n < unat (2 ^ m - 1 :: 'a word); m < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> n < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = unat (2 ^ m - 1) \\<or> n < unat (2 ^ m - 1);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n < 2 ^ m", "by (meson le_less_trans nat_less_le unat_less_power word_power_less_1)"], ["", "lemma mask_sub:\n  \"n \\<le> m \\<Longrightarrow> mask m - mask n = mask m AND NOT(mask n :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> mask m - mask n = mask m AND NOT (mask n)", "by (metis (full_types) and_mask_eq_iff_shiftr_0 mask_out_sub_mask shiftr_mask_le word_bw_comms(1))"], ["", "lemma neg_mask_diff_bound:\n  \"sz'\\<le> sz \\<Longrightarrow> (ptr AND NOT(mask sz')) - (ptr AND NOT(mask sz)) \\<le> 2 ^ sz - 2 ^ sz'\"\n  (is \"_ \\<Longrightarrow> ?lhs \\<le> ?rhs\")\n  for ptr :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz' \\<le> sz \\<Longrightarrow>\n    (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz))\n    \\<le> 2 ^ sz - 2 ^ sz'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sz' \\<le> sz \\<Longrightarrow>\n    (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz))\n    \\<le> 2 ^ sz - 2 ^ sz'", "assume lt: \"sz' \\<le> sz\""], ["proof (state)\nthis:\n  sz' \\<le> sz\n\ngoal (1 subgoal):\n 1. sz' \\<le> sz \\<Longrightarrow>\n    (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz))\n    \\<le> 2 ^ sz - 2 ^ sz'", "hence \"?lhs = ptr AND (mask sz AND NOT(mask sz'))\""], ["proof (prove)\nusing this:\n  sz' \\<le> sz\n\ngoal (1 subgoal):\n 1. (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz)) =\n    ptr AND mask sz AND NOT (mask sz')", "by (metis add_diff_cancel_left' multiple_mask_trivia)"], ["proof (state)\nthis:\n  (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz)) =\n  ptr AND mask sz AND NOT (mask sz')\n\ngoal (1 subgoal):\n 1. sz' \\<le> sz \\<Longrightarrow>\n    (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz))\n    \\<le> 2 ^ sz - 2 ^ sz'", "also"], ["proof (state)\nthis:\n  (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz)) =\n  ptr AND mask sz AND NOT (mask sz')\n\ngoal (1 subgoal):\n 1. sz' \\<le> sz \\<Longrightarrow>\n    (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz))\n    \\<le> 2 ^ sz - 2 ^ sz'", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr AND mask sz AND NOT (mask sz') \\<le> 2 ^ sz - 2 ^ sz'", "using lt"], ["proof (prove)\nusing this:\n  sz' \\<le> sz\n\ngoal (1 subgoal):\n 1. ptr AND mask sz AND NOT (mask sz') \\<le> 2 ^ sz - 2 ^ sz'", "by (metis (mono_tags) add_diff_eq diff_eq_eq eq_iff mask_2pm1 mask_sub word_and_le')"], ["proof (state)\nthis:\n  ptr AND mask sz AND NOT (mask sz') \\<le> 2 ^ sz - 2 ^ sz'\n\ngoal (1 subgoal):\n 1. sz' \\<le> sz \\<Longrightarrow>\n    (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz))\n    \\<le> 2 ^ sz - 2 ^ sz'", "finally"], ["proof (chain)\npicking this:\n  (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz)) \\<le> 2 ^ sz - 2 ^ sz'", "show ?thesis"], ["proof (prove)\nusing this:\n  (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz)) \\<le> 2 ^ sz - 2 ^ sz'\n\ngoal (1 subgoal):\n 1. (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz))\n    \\<le> 2 ^ sz - 2 ^ sz'", "by simp"], ["proof (state)\nthis:\n  (ptr AND NOT (mask sz')) - (ptr AND NOT (mask sz)) \\<le> 2 ^ sz - 2 ^ sz'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mask_out_eq_0:\n  \"\\<lbrakk> idx < 2 ^ sz; sz < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (of_nat idx :: 'a :: len word) AND NOT(mask sz) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>idx < 2 ^ sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat idx AND NOT (mask sz) = 0", "by (simp add: of_nat_power less_mask_eq mask_eq_0_eq_x)"], ["", "lemma is_aligned_neg_mask_eq':\n  \"is_aligned ptr sz = (ptr AND NOT(mask sz) = ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned ptr sz = (ptr AND NOT (mask sz) = ptr)", "using is_aligned_mask mask_eq_0_eq_x"], ["proof (prove)\nusing this:\n  is_aligned ?w ?n = (?w AND mask ?n = 0)\n  (?x AND ?w = 0) = (?x AND NOT ?w = ?x)\n\ngoal (1 subgoal):\n 1. is_aligned ptr sz = (ptr AND NOT (mask sz) = ptr)", "by blast"], ["", "lemma neg_mask_mask_unat:\n  \"sz < LENGTH('a)\n   \\<Longrightarrow> unat ((ptr :: 'a :: len word) AND NOT(mask sz)) + unat (ptr AND mask sz) = unat ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    unat (ptr AND NOT (mask sz)) + unat (ptr AND mask sz) = unat ptr", "by (metis AND_NOT_mask_plus_AND_mask_eq unat_plus_simple word_and_le2)"], ["", "lemma unat_pow_le_intro:\n  \"LENGTH('a) \\<le> n \\<Longrightarrow> unat (x :: 'a :: len word) < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> unat x < 2 ^ n", "by (metis lt2p_lem not_le of_nat_le_iff of_nat_numeral semiring_1_class.of_nat_power uint_nat)"], ["", "lemma unat_shiftl_less_t2n:\n  \"\\<lbrakk> unat (x :: 'a :: len word) < 2 ^ (m - n); m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> unat (x << n) < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ (m - n); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (x << n) < 2 ^ m", "by (metis (no_types) of_nat_power diff_le_self le_less_trans shiftl_less_t2n\n                       unat_less_power word_unat.Rep_inverse)"], ["", "lemma unat_is_aligned_add:\n  \"\\<lbrakk> is_aligned p n; unat d < 2 ^ n \\<rbrakk>\n   \\<Longrightarrow> unat (p + d AND mask n) = unat d \\<and> unat (p + d AND NOT(mask n)) = unat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; unat d < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> unat (p + d AND mask n) = unat d \\<and>\n                      unat (p + d AND NOT (mask n)) = unat p", "by (metis add.right_neutral and_mask_eq_iff_le_mask and_not_mask le_mask_iff mask_add_aligned\n            mask_out_add_aligned mult_zero_right shiftl_t2n shiftr_le_0)"], ["", "lemma unat_shiftr_shiftl_mask_zero:\n  \"\\<lbrakk> c + a \\<ge> LENGTH('a) + b ; c < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> unat (((q :: 'a :: len word) >> a << b) AND NOT(mask c)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('a) + b \\<le> c + a; c < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ((q >> a << b) AND NOT (mask c)) = 0", "by (fastforce intro: unat_is_aligned_add[where p=0 and n=c, simplified, THEN conjunct2]\n                       unat_shiftl_less_t2n unat_shiftr_less_t2n unat_pow_le_intro)"], ["", "lemmas of_nat_ucast = ucast_of_nat[symmetric]"], ["", "lemma shift_then_mask_eq_shift_low_bits:\n  \"x \\<le> mask (low_bits + high_bits) \\<Longrightarrow> (x >> low_bits) AND mask high_bits = x >> low_bits\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> mask (low_bits + high_bits) \\<Longrightarrow>\n    (x >> low_bits) AND mask high_bits = x >> low_bits", "by (simp add: leq_mask_shift le_mask_imp_and_mask)"], ["", "lemma leq_low_bits_iff_zero:\n  \"\\<lbrakk> x \\<le> mask (low bits + high bits); x >> low_bits = 0 \\<rbrakk> \\<Longrightarrow> (x AND mask low_bits = 0) = (x = 0)\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> mask (low bits + high bits); x >> low_bits = 0\\<rbrakk>\n    \\<Longrightarrow> (x AND mask low_bits = 0) = (x = 0)", "using and_mask_eq_iff_shiftr_0"], ["proof (prove)\nusing this:\n  (?w AND mask ?n = ?w) = (?w >> ?n = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> mask (low bits + high bits); x >> low_bits = 0\\<rbrakk>\n    \\<Longrightarrow> (x AND mask low_bits = 0) = (x = 0)", "by force"], ["", "lemma unat_less_iff:\n  \"\\<lbrakk> unat (a :: 'a :: len word) = b; c < 2 ^ LENGTH('a) \\<rbrakk> \\<Longrightarrow> (a < of_nat c) = (b < c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a = b; c < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (a < word_of_nat c) = (b < c)", "using unat_ucast_less_no_overflow_simp"], ["proof (prove)\nusing this:\n  ?n < 2 ^ LENGTH(?'a) \\<Longrightarrow>\n  (unat ?f < ?n) = (?f < word_of_nat ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a = b; c < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (a < word_of_nat c) = (b < c)", "by blast"], ["", "lemma is_aligned_no_overflow3:\n \"\\<lbrakk> is_aligned (a :: 'a :: len word) n; n < LENGTH('a); b < 2 ^ n; c \\<le> 2 ^ n; b < c \\<rbrakk>\n  \\<Longrightarrow> a + b \\<le> a + (c - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; n < LENGTH('a); b < 2 ^ n; c \\<le> 2 ^ n;\n     b < c\\<rbrakk>\n    \\<Longrightarrow> a + b \\<le> a + (c - 1)", "by (meson is_aligned_no_wrap' le_m1_iff_lt not_le word_less_sub_1 word_plus_mono_right)"], ["", "lemma mask_add_aligned_right:\n  \"is_aligned p n \\<Longrightarrow> (q + p) AND mask n = q AND mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p n \\<Longrightarrow> q + p AND mask n = q AND mask n", "by (simp add: mask_add_aligned add.commute)"], ["", "lemma leq_high_bits_shiftr_low_bits_leq_bits_mask:\n  \"x \\<le> mask high_bits \\<Longrightarrow> (x :: 'a :: len word) << low_bits \\<le> mask (low_bits + high_bits)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> mask high_bits \\<Longrightarrow>\n    x << low_bits \\<le> mask (low_bits + high_bits)", "by (metis le_mask_shiftl_le_mask)"], ["", "lemma word_two_power_neg_ineq:\n  \"2 ^ m \\<noteq> (0 :: 'a word) \\<Longrightarrow> 2 ^ n \\<le> - (2 ^ m :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ m \\<noteq> 0 \\<Longrightarrow> 2 ^ n \\<le> - (2 ^ m)", "apply (cases \"n < LENGTH('a)\"; simp add: power_overflow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> LENGTH('a) \\<le> m; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n \\<le> - (2 ^ m)", "apply (cases \"m < LENGTH('a)\"; simp add: power_overflow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n \\<le> - (2 ^ m)", "apply (simp add: word_le_nat_alt unat_minus word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n \\<le> 2 ^ LENGTH('a) - 2 ^ m", "apply (cases \"LENGTH('a)\"; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>n < Suc nat; m < Suc nat; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n \\<le> 2 * 2 ^ nat - 2 ^ m", "apply (simp add: less_Suc_eq_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>n \\<le> nat; m \\<le> nat; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n \\<le> 2 * 2 ^ nat - 2 ^ m", "apply (drule power_increasing[where a=2 and n=n] power_increasing[where a=2 and n=m], simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; (2::?'a28) ^ n \\<le> (2::?'a28) ^ nat;\n        (2::?'a31) ^ m \\<le> (2::?'a31) ^ nat\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n \\<le> 2 * 2 ^ nat - 2 ^ m", "apply (drule(1) add_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>LENGTH('a) = Suc nat; 2 ^ m \\<le> 2 ^ nat;\n        2 ^ n + 2 ^ m \\<le> 2 ^ nat + 2 ^ nat\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n \\<le> 2 * 2 ^ nat - 2 ^ m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_shiftl_absorb:\n  \"\\<lbrakk> x \\<le> 2 ^ p; p + k < LENGTH('a) \\<rbrakk> \\<Longrightarrow> unat (x :: 'a :: len word) * 2 ^ k = unat (x * 2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 2 ^ p; p + k < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ k = unat (x * 2 ^ k)", "by (smt add_diff_cancel_right' add_lessD1 le_add2 le_less_trans mult.commute nat_le_power_trans\n          unat_lt2p unat_mult_lem unat_power_lower word_le_nat_alt)"], ["", "lemma word_plus_mono_right_split:\n  \"\\<lbrakk> unat ((x :: 'a :: len word) AND mask sz) + unat z < 2 ^ sz; sz < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> x \\<le> x + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz;\n     sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + z", "apply (subgoal_tac \"(x AND NOT(mask sz)) + (x AND mask sz) \\<le> (x AND NOT(mask sz)) + ((x AND mask sz) + z)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz; sz < LENGTH('a);\n     (x AND NOT (mask sz)) + (x AND mask sz)\n     \\<le> (x AND NOT (mask sz)) + ((x AND mask sz) + z)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + z\n 2. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz;\n     sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x AND NOT (mask sz)) + (x AND mask sz)\n                      \\<le> (x AND NOT (mask sz)) + ((x AND mask sz) + z)", "apply (simp add:word_plus_and_or_coroll2 field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz;\n     sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x AND NOT (mask sz)) + (x AND mask sz)\n                      \\<le> (x AND NOT (mask sz)) + ((x AND mask sz) + z)", "apply (rule word_plus_mono_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz;\n     sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND mask sz \\<le> (x AND mask sz) + z\n 2. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz;\n     sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND NOT (mask sz)\n                      \\<le> (x AND NOT (mask sz)) + ((x AND mask sz) + z)", "apply (simp add: less_le_trans no_olen_add_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz;\n     sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND NOT (mask sz)\n                      \\<le> (x AND NOT (mask sz)) + ((x AND mask sz) + z)", "using of_nat_power is_aligned_no_wrap'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p < 2 ^ ?x; ?x < LENGTH(?'a)\\<rbrakk>\n  \\<Longrightarrow> word_of_nat ?p < 2 ^ ?x\n  \\<lbrakk>is_aligned ?ptr ?sz; ?off < 2 ^ ?sz\\<rbrakk>\n  \\<Longrightarrow> ?ptr \\<le> ?ptr + ?off\n\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (x AND mask sz) + unat z < 2 ^ sz;\n     sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x AND NOT (mask sz)\n                      \\<le> (x AND NOT (mask sz)) + ((x AND mask sz) + z)", "by force"], ["", "lemma mul_not_mask_eq_neg_shiftl:\n  \"NOT(mask n :: 'a::len word) = -1 << n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (mask n) = - 1 << n", "by (simp add: NOT_mask shiftl_t2n)"], ["", "lemma shiftr_mul_not_mask_eq_and_not_mask:\n  \"(x >> n) * NOT(mask n) = - (x AND NOT(mask n))\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x >> n) * NOT (mask n) = - (x AND NOT (mask n))", "by (metis NOT_mask and_not_mask mult_minus_left semiring_normalization_rules(7) shiftl_t2n)"], ["", "lemma mask_eq_n1_shiftr:\n  \"n \\<le> LENGTH('a) \\<Longrightarrow> (mask n :: 'a :: len word) = -1 >> (LENGTH('a) - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> LENGTH('a) \\<Longrightarrow> mask n = - 1 >> LENGTH('a) - n", "by (metis diff_diff_cancel eq_refl mask_full shiftr_mask2)"], ["", "lemma is_aligned_mask_out_add_eq:\n  \"is_aligned p n \\<Longrightarrow> (p + x) AND NOT(mask n) = p + (x AND NOT(mask n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p n \\<Longrightarrow>\n    p + x AND NOT (mask n) = p + (x AND NOT (mask n))", "by (simp add: mask_out_sub_mask mask_add_aligned)"], ["", "lemmas is_aligned_mask_out_add_eq_sub\n    = is_aligned_mask_out_add_eq[where x=\"a - b\" for a b, simplified field_simps]"], ["", "lemma aligned_bump_down:\n  \"is_aligned x n \\<Longrightarrow> (x - 1) AND NOT(mask n) = x - 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned x n \\<Longrightarrow> x - 1 AND NOT (mask n) = x - 2 ^ n", "by (drule is_aligned_mask_out_add_eq[where x=\"-1\"]) (simp add: NOT_mask)"], ["", "lemma unat_2tp_if:\n  \"unat (2 ^ n :: ('a :: len) word) = (if n < LENGTH ('a) then 2 ^ n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ n) = (if n < LENGTH('a) then 2 ^ n else 0)", "by (split if_split, simp_all add: power_overflow)"], ["", "lemma mask_of_mask:\n  \"mask (n::nat) AND mask (m::nat) = (mask (min m n) :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n AND mask m = mask (min m n)", "by word_eqI_solve"], ["", "lemma unat_signed_ucast_less_ucast:\n  \"LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow> unat (ucast (x :: 'a :: len word) :: 'b :: len signed word) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    unat (UCAST('a \\<rightarrow> 'b signed) x) = unat x", "by (simp add: unat_ucast_up_simp)"], ["", "lemma toEnum_of_ucast:\n  \"LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n   (toEnum (unat (b::'b :: len word))::'a :: len word) = of_nat (unat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n    toEnum (unat b) = word_of_nat (unat b)", "by (simp add: unat_pow_le_intro)"], ["", "lemmas unat_ucast_mask = unat_ucast_eq_unat_and_mask[where w=a for a]"], ["", "lemma t2n_mask_eq_if:\n  \"2 ^ n AND mask m = (if n < m then 2 ^ n else (0 :: 'a::len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n AND mask m = (if n < m then 2 ^ n else 0)", "by (rule word_eqI, auto simp add: word_size nth_w2p split: if_split)"], ["", "lemma unat_ucast_le:\n  \"unat (ucast (x :: 'a :: len word) :: 'b :: len word) \\<le> unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (UCAST('a \\<rightarrow> 'b) x) \\<le> unat x", "by (simp add: ucast_nat_def word_unat_less_le)"], ["", "lemma ucast_le_up_down_iff:\n  \"\\<lbrakk> LENGTH('a) \\<le> LENGTH('b); (x :: 'b :: len word) \\<le> ucast (max_word :: 'a :: len word) \\<rbrakk>\n   \\<Longrightarrow> (ucast x \\<le> (y :: 'a word)) = (x \\<le> ucast y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('a) \\<le> LENGTH('b);\n     x \\<le> UCAST('a \\<rightarrow> 'b) (- 1)\\<rbrakk>\n    \\<Longrightarrow> (UCAST('b \\<rightarrow> 'a) x \\<le> y) =\n                      (x \\<le> UCAST('a \\<rightarrow> 'b) y)", "using le_max_word_ucast_id ucast_le_ucast"], ["proof (prove)\nusing this:\n  ?x \\<le> UCAST(?'b \\<rightarrow> ?'a) (- 1) \\<Longrightarrow>\n  UCAST(?'b \\<rightarrow> ?'a) (UCAST(?'a \\<rightarrow> ?'b) ?x) = ?x\n  LENGTH(?'a) \\<le> LENGTH(?'b) \\<Longrightarrow>\n  (UCAST(?'a \\<rightarrow> ?'b) ?x \\<le> UCAST(?'a \\<rightarrow> ?'b) ?y) =\n  (?x \\<le> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('a) \\<le> LENGTH('b);\n     x \\<le> UCAST('a \\<rightarrow> 'b) (- 1)\\<rbrakk>\n    \\<Longrightarrow> (UCAST('b \\<rightarrow> 'a) x \\<le> y) =\n                      (x \\<le> UCAST('a \\<rightarrow> 'b) y)", "by metis"], ["", "lemma ucast_ucast_mask_shift:\n  \"a \\<le> LENGTH('a) + b\n   \\<Longrightarrow> ucast (ucast (p AND mask a >> b) :: 'a :: len word) = p AND mask a >> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> LENGTH('a) + b \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b)\n     (UCAST('b \\<rightarrow> 'a) (p AND mask a >> b)) =\n    p AND mask a >> b", "by (metis add.commute le_mask_iff shiftr_mask_le ucast_ucast_eq_mask_shift word_and_le')"], ["", "lemma unat_ucast_mask_shift:\n  \"a \\<le> LENGTH('a) + b\n   \\<Longrightarrow> unat (ucast (p AND mask a >> b) :: 'a :: len word) = unat (p AND mask a >> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> LENGTH('a) + b \\<Longrightarrow>\n    unat (UCAST('b \\<rightarrow> 'a) (p AND mask a >> b)) =\n    unat (p AND mask a >> b)", "by (metis linear ucast_ucast_mask_shift unat_ucast_up_simp)"], ["", "lemma mask_overlap_zero:\n  \"a \\<le> b \\<Longrightarrow> (p AND mask a) AND NOT(mask b) = 0\"\n  for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> (p AND mask a) AND NOT (mask b) = 0", "by (metis NOT_mask_AND_mask mask_lower_twice2 max_def)"], ["", "lemma mask_shifl_overlap_zero:\n  \"a + c \\<le> b \\<Longrightarrow> (p AND mask a << c) AND NOT(mask b) = 0\"\n  for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + c \\<le> b \\<Longrightarrow> (p AND mask a << c) AND NOT (mask b) = 0", "by (metis and_mask_0_iff_le_mask mask_mono mask_shiftl_decompose order_trans shiftl_over_and_dist word_and_le' word_and_le2)"], ["", "lemma mask_overlap_zero':\n  \"a \\<ge> b \\<Longrightarrow> (p AND NOT(mask a)) AND mask b = 0\"\n  for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow> (p AND NOT (mask a)) AND mask b = 0", "using mask_AND_NOT_mask mask_AND_less_0"], ["proof (prove)\nusing this:\n  (?w AND NOT (mask ?n)) AND mask ?n = 0\n  \\<lbrakk>?x AND mask ?n = 0; ?m \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> ?x AND mask ?m = 0\n\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow> (p AND NOT (mask a)) AND mask b = 0", "by blast"], ["", "lemma mask_rshift_mult_eq_rshift_lshift:\n  \"((a :: 'a :: len word) >> b) * (1 << c) = (a >> b << c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a >> b) * (1 << c) = a >> b << c", "by (simp add: shiftl_t2n)"], ["", "lemma shift_alignment:\n  \"a \\<ge> b \\<Longrightarrow> is_aligned (p >> a << a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow> is_aligned (p >> a << a) b", "using is_aligned_shift is_aligned_weaken"], ["proof (prove)\nusing this:\n  is_aligned (?k << ?m) ?m\n  \\<lbrakk>is_aligned ?w ?x; ?y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> is_aligned ?w ?y\n\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow> is_aligned (p >> a << a) b", "by blast"], ["", "lemma mask_split_sum_twice:\n  \"a \\<ge> b \\<Longrightarrow> (p AND NOT(mask a)) + ((p AND mask a) AND NOT(mask b)) + (p AND mask b) = p\"\n  for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow>\n    (p AND NOT (mask a)) + ((p AND mask a) AND NOT (mask b)) +\n    (p AND mask b) =\n    p", "by (simp add: add.commute multiple_mask_trivia word_bw_comms(1) word_bw_lcs(1) word_plus_and_or_coroll2)"], ["", "lemma mask_shift_eq_mask_mask:\n  \"(p AND mask a >> b << b) = (p AND mask a) AND NOT(mask b)\"\n  for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p AND mask a >> b << b = (p AND mask a) AND NOT (mask b)", "by (simp add: and_not_mask)"], ["", "lemma mask_shift_sum:\n  \"\\<lbrakk> a \\<ge> b; unat n = unat (p AND mask b) \\<rbrakk>\n   \\<Longrightarrow> (p AND NOT(mask a)) + (p AND mask a >> b) * (1 << b) + n = (p :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> a; unat n = unat (p AND mask b)\\<rbrakk>\n    \\<Longrightarrow> (p AND NOT (mask a)) +\n                      (p AND mask a >> b) * (1 << b) +\n                      n =\n                      p", "by (metis and_not_mask mask_rshift_mult_eq_rshift_lshift mask_split_sum_twice word_unat.Rep_eqD)"], ["", "lemma is_up_compose:\n  \"\\<lbrakk> is_up uc; is_up uc' \\<rbrakk> \\<Longrightarrow> is_up (uc' \\<circ> uc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_up uc; is_up uc'\\<rbrakk>\n    \\<Longrightarrow> is_up (uc' \\<circ> uc)", "unfolding is_up_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_fun (map_fun Word.Word Word.rep) id\n              (\\<lambda>_. LENGTH('a) \\<le> LENGTH('b)) uc;\n     map_fun (map_fun Word.Word Word.rep) id\n      (\\<lambda>_. LENGTH('b) \\<le> LENGTH('c)) uc'\\<rbrakk>\n    \\<Longrightarrow> map_fun (map_fun Word.Word Word.rep) id\n                       (\\<lambda>_. LENGTH('a) \\<le> LENGTH('c))\n                       (uc' \\<circ> uc)", "by (simp add: Word.target_size Word.source_size)"], ["", "lemma of_int_sint_scast:\n  \"of_int (sint (x :: 'a :: len word)) = (scast x :: 'b :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (sint x) = SCAST('a \\<rightarrow> 'b) x", "by (fact Word.of_int_sint)"], ["", "lemma scast_of_nat_to_signed [simp]:\n  \"scast (of_nat x :: 'a :: len word) = (of_nat x :: 'a signed word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a \\<rightarrow> 'a signed) (word_of_nat x) = word_of_nat x", "by transfer simp"], ["", "lemma scast_of_nat_signed_to_unsigned_add:\n  \"scast (of_nat x + of_nat y :: 'a :: len signed word) = (of_nat x + of_nat y :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a signed \\<rightarrow> 'a) (word_of_nat x + word_of_nat y) =\n    word_of_nat x + word_of_nat y", "by (metis of_nat_add scast_of_nat)"], ["", "lemma scast_of_nat_unsigned_to_signed_add:\n  \"(scast (of_nat x + of_nat y :: 'a :: len word)) = (of_nat x + of_nat y :: 'a :: len signed word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a \\<rightarrow> 'a signed) (word_of_nat x + word_of_nat y) =\n    word_of_nat x + word_of_nat y", "by (metis Abs_fnat_hom_add scast_of_nat_to_signed)"], ["", "lemma and_mask_cases:\n  fixes x :: \"'a :: len word\"\n  assumes len: \"n < LENGTH('a)\"\n  shows \"x AND mask n \\<in> of_nat ` set [0 ..< 2 ^ n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND mask n \\<in> word_of_nat ` set [0..<2 ^ n]", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n x \\<in> word_of_nat ` {0..<2 ^ n}", "apply (rule image_eqI [of _ _ \\<open>unat (take_bit n x)\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. take_bit n x = word_of_nat (unat (take_bit n x))\n 2. unat (take_bit n x) \\<in> {0..<2 ^ n}", "using len"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (2 subgoals):\n 1. take_bit n x = word_of_nat (unat (take_bit n x))\n 2. unat (take_bit n x) \\<in> {0..<2 ^ n}", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> unat (take_bit n x) < 2 ^ n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       n < LENGTH('a) \\<Longrightarrow>\n       (nat \\<circ> take_bit LENGTH('a)) (take_bit (min LENGTH('a) n) x)\n       < 2 ^ n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sint_eq_uint_2pl:\n  \"\\<lbrakk> (a :: 'a :: len word) < 2 ^ (LENGTH('a) - 1) \\<rbrakk>\n   \\<Longrightarrow> sint a = uint a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> sint a = uint a", "by (simp add: not_msb_from_less sint_eq_uint word_2p_lem word_size)"], ["", "lemma pow_sub_less:\n  \"\\<lbrakk> a + b \\<le> LENGTH('a); unat (x :: 'a :: len word) = 2 ^ a \\<rbrakk>\n   \\<Longrightarrow> unat (x * 2 ^ b - 1) < 2 ^ (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + b \\<le> LENGTH('a); unat x = 2 ^ a\\<rbrakk>\n    \\<Longrightarrow> unat (x * 2 ^ b - 1) < 2 ^ (a + b)", "by (metis (mono_tags) eq_or_less_helperD not_less of_nat_numeral power_add\n                        semiring_1_class.of_nat_power unat_pow_le_intro word_unat.Rep_inverse)"], ["", "lemma sle_le_2pl:\n  \"\\<lbrakk> (b :: 'a :: len word) < 2 ^ (LENGTH('a) - 1); a \\<le> b \\<rbrakk> \\<Longrightarrow> a <=s b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 2 ^ (LENGTH('a) - 1); a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<le>s b", "by (simp add: not_msb_from_less word_sle_msb_le)"], ["", "lemma sless_less_2pl:\n  \"\\<lbrakk> (b :: 'a :: len word) < 2 ^ (LENGTH('a) - 1); a < b \\<rbrakk> \\<Longrightarrow> a <s b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 2 ^ (LENGTH('a) - 1); a < b\\<rbrakk>\n    \\<Longrightarrow> a <s b", "using not_msb_from_less word_sless_msb_less"], ["proof (prove)\nusing this:\n  ?v < 2 ^ (LENGTH(?'a) - 1) \\<Longrightarrow> \\<not> msb ?v\n  (?x <s ?y) =\n  ((msb ?y \\<longrightarrow> msb ?x) \\<and>\n   (msb ?x \\<and> \\<not> msb ?y \\<or> ?x < ?y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 2 ^ (LENGTH('a) - 1); a < b\\<rbrakk>\n    \\<Longrightarrow> a <s b", "by blast"], ["", "lemma and_mask2:\n  \"w << n >> n = w AND mask (size w - n)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w << n >> n = w AND mask (size w - n)", "by (cases \"n \\<le> size w\"; clarsimp simp: word_and_le2 and_mask shiftl_zero_size)"], ["", "lemma aligned_sub_aligned_simple:\n  \"\\<lbrakk> is_aligned a n; is_aligned b n \\<rbrakk> \\<Longrightarrow> is_aligned (a - b) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (a - b) n", "by (simp add: aligned_sub_aligned)"], ["", "lemma minus_one_shift:\n  \"- (1 << n) = (-1 << n :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (1 << n) = - 1 << n", "by (simp add: mask_eq_decr_exp NOT_eq flip: mul_not_mask_eq_neg_shiftl)"], ["", "lemma ucast_eq_mask:\n  \"(UCAST('a::len \\<rightarrow> 'b::len) x = UCAST('a \\<rightarrow> 'b) y) =\n   (x AND mask LENGTH('b) = y AND mask LENGTH('b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UCAST('a \\<rightarrow> 'b) x = UCAST('a \\<rightarrow> 'b) y) =\n    (x AND mask LENGTH('b) = y AND mask LENGTH('b))", "by (rule iffI; word_eqI_solve)"], ["", "context\n  fixes w :: \"'a::len word\"\nbegin"], ["", "private"], ["", "lemma sbintrunc_uint_ucast:\n  assumes \"Suc n = LENGTH('b::len)\"\n  shows \"sbintrunc n (uint (ucast w :: 'b word)) = sbintrunc n (uint w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n (uint (UCAST('a \\<rightarrow> 'b) w)) =\n    signed_take_bit n (uint w)", "by (metis assms sbintrunc_bintrunc ucast_eq word_ubin.eq_norm)"], ["", "private"], ["", "lemma test_bit_sbintrunc:\n  assumes \"i < LENGTH('a)\"\n  shows \"(word_of_int (sbintrunc n (uint w)) :: 'a word) !! i\n           = (if n < i then w !! n else w !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (signed_take_bit n (uint w)) !! i =\n    (if n < i then w !! n else w !! i)", "using assms"], ["proof (prove)\nusing this:\n  i < LENGTH('a)\n\ngoal (1 subgoal):\n 1. word_of_int (signed_take_bit n (uint w)) !! i =\n    (if n < i then w !! n else w !! i)", "by (simp add: nth_sbintr)\n                 (simp add: test_bit_bin)"], ["", "private"], ["", "lemma test_bit_sbintrunc_ucast:\n  assumes len_a: \"i < LENGTH('a)\"\n  shows \"(word_of_int (sbintrunc (LENGTH('b) - 1) (uint (ucast w :: 'b word))) :: 'a word) !! i\n          = (if LENGTH('b::len) \\<le> i then w !! (LENGTH('b) - 1) else w !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int\n     (signed_take_bit (LENGTH('b) - 1)\n       (uint (UCAST('a \\<rightarrow> 'b) w))) !!\n    i =\n    (if LENGTH('b) \\<le> i then w !! (LENGTH('b) - 1) else w !! i)", "apply (subst sbintrunc_uint_ucast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (LENGTH('b) - 1) = LENGTH('b)\n 2. word_of_int (signed_take_bit (LENGTH('b) - 1) (uint w)) !! i =\n    (if LENGTH('b) \\<le> i then w !! (LENGTH('b) - 1) else w !! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (signed_take_bit (LENGTH('b) - 1) (uint w)) !! i =\n    (if LENGTH('b) \\<le> i then w !! (LENGTH('b) - 1) else w !! i)", "apply (subst test_bit_sbintrunc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < LENGTH('a)\n 2. (if LENGTH('b) - 1 < i then w !! (LENGTH('b) - 1) else w !! i) =\n    (if LENGTH('b) \\<le> i then w !! (LENGTH('b) - 1) else w !! i)", "apply (rule len_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if LENGTH('b) - 1 < i then w !! (LENGTH('b) - 1) else w !! i) =\n    (if LENGTH('b) \\<le> i then w !! (LENGTH('b) - 1) else w !! i)", "apply (rule if_cong[OF _ refl refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LENGTH('b) - 1 < i) = (LENGTH('b) \\<le> i)", "using leD less_linear"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  ?x < ?y \\<or> ?x = ?y \\<or> ?y < ?x\n\ngoal (1 subgoal):\n 1. (LENGTH('b) - 1 < i) = (LENGTH('b) \\<le> i)", "by fastforce"], ["", "lemma scast_ucast_high_bits:\n  \\<open>scast (ucast w :: 'b::len word) = w\n     \\<longleftrightarrow> (\\<forall> i \\<in> {LENGTH('b) ..< size w}. w !! i = w !! (LENGTH('b) - 1))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "proof (cases \\<open>LENGTH('a) \\<le> LENGTH('b)\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))\n 2. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "case True"], ["proof (state)\nthis:\n  LENGTH('a) \\<le> LENGTH('b)\n\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))\n 2. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "moreover"], ["proof (state)\nthis:\n  LENGTH('a) \\<le> LENGTH('b)\n\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))\n 2. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "define m where \\<open>m = LENGTH('b) - LENGTH('a)\\<close>"], ["proof (state)\nthis:\n  m = LENGTH('b) - LENGTH('a)\n\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))\n 2. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "ultimately"], ["proof (chain)\npicking this:\n  LENGTH('a) \\<le> LENGTH('b)\n  m = LENGTH('b) - LENGTH('a)", "have \\<open>LENGTH('b) = m + LENGTH('a)\\<close>"], ["proof (prove)\nusing this:\n  LENGTH('a) \\<le> LENGTH('b)\n  m = LENGTH('b) - LENGTH('a)\n\ngoal (1 subgoal):\n 1. LENGTH('b) = m + LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  LENGTH('b) = m + LENGTH('a)\n\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))\n 2. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "then"], ["proof (chain)\npicking this:\n  LENGTH('b) = m + LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  LENGTH('b) = m + LENGTH('a)\n\ngoal (1 subgoal):\n 1. (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "apply (simp_all add: signed_ucast_eq word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) = m + LENGTH('a) \\<Longrightarrow>\n    signed_take_bit (m + LENGTH('a) - Suc 0) w = w", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>LENGTH('b) = m + LENGTH('a); n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (signed_take_bit (m + LENGTH('a) - Suc 0) w)\n                          n =\n                         bit w n", "apply (simp add: bit_signed_take_bit_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n  (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "case False"], ["proof (state)\nthis:\n  \\<not> LENGTH('a) \\<le> LENGTH('b)\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "define q where \\<open>q = LENGTH('b) - 1\\<close>"], ["proof (state)\nthis:\n  q = LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "then"], ["proof (chain)\npicking this:\n  q = LENGTH('b) - 1", "have \\<open>LENGTH('b) = Suc q\\<close>"], ["proof (prove)\nusing this:\n  q = LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. LENGTH('b) = Suc q", "by simp"], ["proof (state)\nthis:\n  LENGTH('b) = Suc q\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "moreover"], ["proof (state)\nthis:\n  LENGTH('b) = Suc q\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "define m where \\<open>m = Suc LENGTH('a) - LENGTH('b)\\<close>"], ["proof (state)\nthis:\n  m = Suc LENGTH('a) - LENGTH('b)\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "with False \\<open>LENGTH('b) = Suc q\\<close>"], ["proof (chain)\npicking this:\n  \\<not> LENGTH('a) \\<le> LENGTH('b)\n  LENGTH('b) = Suc q\n  m = Suc LENGTH('a) - LENGTH('b)", "have \\<open>LENGTH('a) = m + q\\<close>"], ["proof (prove)\nusing this:\n  \\<not> LENGTH('a) \\<le> LENGTH('b)\n  LENGTH('b) = Suc q\n  m = Suc LENGTH('a) - LENGTH('b)\n\ngoal (1 subgoal):\n 1. LENGTH('a) = m + q", "by (simp add: not_le)"], ["proof (state)\nthis:\n  LENGTH('a) = m + q\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "ultimately"], ["proof (chain)\npicking this:\n  LENGTH('b) = Suc q\n  LENGTH('a) = m + q", "show ?thesis"], ["proof (prove)\nusing this:\n  LENGTH('b) = Suc q\n  LENGTH('a) = m + q\n\ngoal (1 subgoal):\n 1. (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))", "apply (simp_all add: signed_ucast_eq word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q\\<rbrakk>\n    \\<Longrightarrow> (signed_take_bit q w = w) =\n                      (\\<forall>i\\<in>{Suc q..<m + q}. w !! i = w !! q)", "apply (transfer fixing: m q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q\\<rbrakk>\n       \\<Longrightarrow> (take_bit LENGTH('a)\n                           (signed_take_bit q (take_bit LENGTH('a) w)) =\n                          take_bit LENGTH('a) w) =\n                         (\\<forall>i\\<in>{Suc q..<m + q}.\n                             (i < LENGTH('a) \\<and> bit w i) =\n                             (q < LENGTH('a) \\<and> bit w q))", "apply (simp add: signed_take_bit_take_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q\\<rbrakk>\n       \\<Longrightarrow> 0 < m \\<longrightarrow>\n                         (take_bit (m + q) (signed_take_bit q w) =\n                          take_bit (m + q) w) =\n                         (\\<forall>i\\<in>{Suc q..<m + q}. bit w i = bit w q)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q; 0 < m\\<rbrakk>\n       \\<Longrightarrow> (take_bit (m + q) (signed_take_bit q w) =\n                          take_bit (m + q) w) =\n                         (\\<forall>i\\<in>{Suc q..<m + q}. bit w i = bit w q)", "apply (subst bit_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q; 0 < m\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>n.\n                             bit (take_bit (m + q) (signed_take_bit q w))\n                              n =\n                             bit (take_bit (m + q) w) n) =\n                         (\\<forall>i\\<in>{Suc q..<m + q}. bit w i = bit w q)", "apply (simp add: bit_take_bit_iff bit_signed_take_bit_iff min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q; 0 < m\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>n\\<ge>q.\n                             (n < m + q \\<and> bit w q) =\n                             (n < m + q \\<and> bit w n)) =\n                         (\\<forall>i\\<in>{Suc q..<m + q}. bit w i = bit w q)", "apply (auto simp add: Suc_le_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w i.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q;\n        \\<forall>n\\<ge>q.\n           (n < m + q \\<and> bit w q) = (n < m + q \\<and> bit w n);\n        bit w i; q < i; i < m + q\\<rbrakk>\n       \\<Longrightarrow> bit w q\n 2. \\<And>w i.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q;\n        \\<forall>n\\<ge>q. (n < m + q) = (n < m + q \\<and> bit w n); bit w q;\n        q < i; i < m + q\\<rbrakk>\n       \\<Longrightarrow> bit w i", "using less_imp_le_nat"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (2 subgoals):\n 1. \\<And>w i.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q;\n        \\<forall>n\\<ge>q.\n           (n < m + q \\<and> bit w q) = (n < m + q \\<and> bit w n);\n        bit w i; q < i; i < m + q\\<rbrakk>\n       \\<Longrightarrow> bit w q\n 2. \\<And>w i.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q;\n        \\<forall>n\\<ge>q. (n < m + q) = (n < m + q \\<and> bit w n); bit w q;\n        q < i; i < m + q\\<rbrakk>\n       \\<Longrightarrow> bit w i", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w i.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q;\n        \\<forall>n\\<ge>q. (n < m + q) = (n < m + q \\<and> bit w n); bit w q;\n        q < i; i < m + q\\<rbrakk>\n       \\<Longrightarrow> bit w i", "using less_imp_le_nat"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<And>w i.\n       \\<lbrakk>LENGTH('b) = Suc q; LENGTH('a) = m + q;\n        \\<forall>n\\<ge>q. (n < m + q) = (n < m + q \\<and> bit w n); bit w q;\n        q < i; i < m + q\\<rbrakk>\n       \\<Longrightarrow> bit w i", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n  (\\<forall>i\\<in>{LENGTH('b)..<size w}. w !! i = w !! (LENGTH('b) - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scast_ucast_mask_compare:\n  \"scast (ucast w :: 'b::len word) = w\n   \\<longleftrightarrow> (w \\<le> mask (LENGTH('b) - 1) \\<or> NOT(mask (LENGTH('b) - 1)) \\<le> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SCAST('b \\<rightarrow> 'a) (UCAST('a \\<rightarrow> 'b) w) = w) =\n    (w \\<le> mask (LENGTH('b) - 1) \\<or>\n     NOT (mask (LENGTH('b) - 1)) \\<le> w)", "apply (clarsimp simp: le_mask_high_bits neg_mask_le_high_bits scast_ucast_high_bits word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{LENGTH('b)..<LENGTH('a)}.\n        w !! i = w !! (LENGTH('b) - Suc 0)) =\n    ((\\<forall>i\\<in>{LENGTH('b) - Suc 0..<LENGTH('a)}. \\<not> w !! i) \\<or>\n     (\\<forall>i\\<in>{LENGTH('b) - Suc 0..<LENGTH('a)}. w !! i))", "apply (rule iffI; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i\\<in>{LENGTH('b)..<LENGTH('a)}.\n                   w !! i = w !! (LENGTH('b) - Suc 0);\n        \\<not> w !! i; w !! ia; LENGTH('b) - Suc 0 \\<le> i; i < LENGTH('a);\n        LENGTH('b) - Suc 0 \\<le> ia; ia < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>(\\<forall>i\\<in>{LENGTH('b) - Suc 0..<LENGTH('a)}.\n                    \\<not> w !! i) \\<or>\n                (\\<forall>i\\<in>{LENGTH('b) - Suc 0..<LENGTH('a)}. w !! i);\n        LENGTH('b) \\<le> i; i < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> w !! i = w !! (LENGTH('b) - Suc 0)", "apply (rename_tac i j; case_tac \"i = LENGTH('b) - 1\"; case_tac \"j = LENGTH('b) - 1\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<in>{LENGTH('b)..<LENGTH('a)}.\n                   w !! i = w !! (LENGTH('b) - Suc 0);\n        \\<not> w !! i; w !! j; LENGTH('b) - Suc 0 \\<le> i; i < LENGTH('a);\n        LENGTH('b) - Suc 0 \\<le> j; j < LENGTH('a); i = LENGTH('b) - 1;\n        j = LENGTH('b) - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<in>{LENGTH('b)..<LENGTH('a)}.\n                   w !! i = w !! (LENGTH('b) - Suc 0);\n        \\<not> w !! i; w !! j; LENGTH('b) - Suc 0 \\<le> i; i < LENGTH('a);\n        LENGTH('b) - Suc 0 \\<le> j; j < LENGTH('a); i = LENGTH('b) - 1;\n        j \\<noteq> LENGTH('b) - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<in>{LENGTH('b)..<LENGTH('a)}.\n                   w !! i = w !! (LENGTH('b) - Suc 0);\n        \\<not> w !! i; w !! j; LENGTH('b) - Suc 0 \\<le> i; i < LENGTH('a);\n        LENGTH('b) - Suc 0 \\<le> j; j < LENGTH('a);\n        i \\<noteq> LENGTH('b) - 1; j = LENGTH('b) - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<in>{LENGTH('b)..<LENGTH('a)}.\n                   w !! i = w !! (LENGTH('b) - Suc 0);\n        \\<not> w !! i; w !! j; LENGTH('b) - Suc 0 \\<le> i; i < LENGTH('a);\n        LENGTH('b) - Suc 0 \\<le> j; j < LENGTH('a);\n        i \\<noteq> LENGTH('b) - 1; j \\<noteq> LENGTH('b) - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>i.\n       \\<lbrakk>(\\<forall>i\\<in>{LENGTH('b) - Suc 0..<LENGTH('a)}.\n                    \\<not> w !! i) \\<or>\n                (\\<forall>i\\<in>{LENGTH('b) - Suc 0..<LENGTH('a)}. w !! i);\n        LENGTH('b) \\<le> i; i < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> w !! i = w !! (LENGTH('b) - Suc 0)", "by auto"], ["", "lemma ucast_less_shiftl_helper':\n  \"\\<lbrakk> LENGTH('b) + (a::nat) < LENGTH('a); 2 ^ (LENGTH('b) + a) \\<le> n\\<rbrakk>\n   \\<Longrightarrow> (ucast (x :: 'b::len word) << a) < (n :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('b) + a < LENGTH('a);\n     2 ^ (LENGTH('b) + a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'a) x << a < n", "apply (erule order_less_le_trans[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) + a < LENGTH('a) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'a) x << a < 2 ^ (LENGTH('b) + a)", "using ucast_less[where x=x and 'a='a]"], ["proof (prove)\nusing this:\n  LENGTH('b) < LENGTH('a) \\<Longrightarrow>\n  UCAST('b \\<rightarrow> 'a) x < 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. LENGTH('b) + a < LENGTH('a) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'a) x << a < 2 ^ (LENGTH('b) + a)", "apply (simp only: shiftl_t2n field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + LENGTH('b) < LENGTH('a);\n     LENGTH('b) < LENGTH('a) \\<Longrightarrow>\n     UCAST('b \\<rightarrow> 'a) x < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'a) x * 2 ^ a\n                      < 2 ^ (a + LENGTH('b))", "apply (rule word_less_power_trans2; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma ucast_ucast_mask2:\n  \"is_down (UCAST ('a \\<rightarrow> 'b)) \\<Longrightarrow>\n   UCAST ('b::len \\<rightarrow> 'c::len) (UCAST ('a::len \\<rightarrow> 'b::len) x) = UCAST ('a \\<rightarrow> 'c) (x AND mask LENGTH('b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'c) (UCAST('a \\<rightarrow> 'b) x) =\n    UCAST('a \\<rightarrow> 'c) (x AND mask LENGTH('b))", "by word_eqI_solve"], ["", "lemma ucast_NOT:\n  \"ucast (NOT x) = NOT(ucast x) AND mask (LENGTH('a))\" for x::\"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) (NOT x) =\n    NOT (UCAST('a \\<rightarrow> 'b) x) AND mask LENGTH('a)", "by word_eqI"], ["", "lemma ucast_NOT_down:\n  \"is_down UCAST('a::len \\<rightarrow> 'b::len) \\<Longrightarrow> UCAST('a \\<rightarrow> 'b) (NOT x) = NOT(UCAST('a \\<rightarrow> 'b) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) (NOT x) = NOT (UCAST('a \\<rightarrow> 'b) x)", "by word_eqI"], ["", "lemma upto_enum_step_shift:\n  \"\\<lbrakk> is_aligned p n \\<rbrakk> \\<Longrightarrow>\n  ([p , p + 2 ^ m .e. p + 2 ^ n - 1])\n      = map ((+) p) [0, 2 ^ m .e. 2 ^ n - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p n \\<Longrightarrow>\n    [p , p + 2 ^ m .e. p + 2 ^ n - 1] =\n    map ((+) p) [0 , 2 ^ m .e. 2 ^ n - 1]", "apply (erule is_aligned_get_word_bits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> [p , p + 2 ^ m .e. p + 2 ^ n - 1] =\n                      map ((+) p) [0 , 2 ^ m .e. 2 ^ n - 1]\n 2. \\<lbrakk>p = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> [p , p + 2 ^ m .e. p + 2 ^ n - 1] =\n                      map ((+) p) [0 , 2 ^ m .e. 2 ^ n - 1]", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> [p , p + 2 ^ m .e. p + 2 ^ n - 1] =\n                      map ((+) p) [0 , 2 ^ m .e. 2 ^ n - 1]\n 2. \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> [p , p + 2 ^ m .e. p + 2 ^ n - 1] =\n                      map ((+) p) [0 , 2 ^ m .e. 2 ^ n - 1]", "apply (simp add: map_idI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> [p , p + 2 ^ m .e. p + 2 ^ n - 1] =\n                      map ((+) p) [0 , 2 ^ m .e. 2 ^ n - 1]", "apply (clarsimp simp: upto_enum_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; n < LENGTH('a); p + 2 ^ n - 1 < p\\<rbrakk>\n    \\<Longrightarrow> [0 .e. (2 ^ n - 1) div 2 ^ m] = []", "apply (frule is_aligned_no_overflow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; n < LENGTH('a); p + 2 ^ n - 1 < p;\n     p \\<le> p + 2 ^ n - 1\\<rbrakk>\n    \\<Longrightarrow> [0 .e. (2 ^ n - 1) div 2 ^ m] = []", "apply (simp add: linorder_not_le [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upto_enum_step_shift_red:\n  \"\\<lbrakk> is_aligned p sz; sz < LENGTH('a); us \\<le> sz \\<rbrakk>\n     \\<Longrightarrow> [p :: 'a :: len word, p + 2 ^ us .e. p + 2 ^ sz - 1]\n          = map (\\<lambda>x. p + of_nat x * 2 ^ us) [0 ..< 2 ^ (sz - us)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p sz; sz < LENGTH('a); us \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> [p , p + 2 ^ us .e. p + 2 ^ sz - 1] =\n                      map (\\<lambda>x. p + word_of_nat x * 2 ^ us)\n                       [0..<2 ^ (sz - us)]", "apply (subst upto_enum_step_shift, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p sz; sz < LENGTH('a); us \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> map ((+) p) [0 , 2 ^ us .e. 2 ^ sz - 1] =\n                      map (\\<lambda>x. p + word_of_nat x * 2 ^ us)\n                       [0..<2 ^ (sz - us)]", "apply (simp add: upto_enum_step_red)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upto_enum_step_subset:\n  \"set [x, y .e. z] \\<subseteq> {x .. z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [x , y .e. z] \\<subseteq> {x..z}", "apply (clarsimp simp: upto_enum_step_def linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa \\<le> (z - x) div (y - x)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x + xa * (y - x) \\<and>\n                         x + xa * (y - x) \\<le> z", "apply (drule div_to_mult_word_lt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x + xa * (y - x) \\<and>\n                         x + xa * (y - x) \\<le> z", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x + xa * (y - x)\n 2. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x + xa * (y - x) \\<le> z", "apply (erule word_random[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. x \\<le> z \\<Longrightarrow> x \\<le> x + (z - x)\n 2. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x + xa * (y - x) \\<le> z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x + xa * (y - x) \\<le> z", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x + xa * (y - x) \\<le> ?y20 xa\n 2. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> ?y20 xa \\<le> z", "apply (erule word_plus_mono_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. x \\<le> z \\<Longrightarrow> x \\<le> x + (z - x)\n 2. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x + (z - x) \\<le> z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<le> z; xa * (y - x) \\<le> z - x\\<rbrakk>\n       \\<Longrightarrow> x + (z - x) \\<le> z", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_distrib:\n  fixes M :: \"'a::len word \\<Rightarrow> 'a::len word \\<Rightarrow> 'a::len word\"\n  fixes M' :: \"'b::len word \\<Rightarrow> 'b::len word \\<Rightarrow> 'b::len word\"\n  fixes L :: \"int \\<Rightarrow> int \\<Rightarrow> int\"\n  assumes lift_M: \"\\<And>x y. uint (M x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('a)\"\n  assumes lift_M': \"\\<And>x y. uint (M' x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('b)\"\n  assumes distrib: \"\\<And>x y. (L (x mod (2 ^ LENGTH('b))) (y mod (2 ^ LENGTH('b)))) mod (2 ^ LENGTH('b))\n                               = (L x y) mod (2 ^ LENGTH('b))\"\n  assumes is_down: \"is_down (ucast :: 'a word \\<Rightarrow> 'b word)\"\n  shows \"ucast (M a b) = M' (ucast a) (ucast b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) (M a b) =\n    M' (UCAST('a \\<rightarrow> 'b) a) (UCAST('a \\<rightarrow> 'b) b)", "apply (simp only: ucast_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (uint (M a b)) =\n    M' (word_of_int (uint a)) (word_of_int (uint b))", "apply (subst lift_M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (L (uint a) (uint b) mod 2 ^ LENGTH('a)) =\n    M' (word_of_int (uint a)) (word_of_int (uint b))", "apply (subst of_int_uint [symmetric], subst lift_M')"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (L (uint a) (uint b) mod 2 ^ LENGTH('a)) =\n    word_of_int\n     (L (uint (word_of_int (uint a))) (uint (word_of_int (uint b))) mod\n      2 ^ LENGTH('b))", "apply (subst (1 2) int_word_uint)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (L (uint a) (uint b) mod 2 ^ LENGTH('a)) =\n    word_of_int\n     (L (uint a mod 2 ^ LENGTH('b)) (uint b mod 2 ^ LENGTH('b)) mod\n      2 ^ LENGTH('b))", "apply (subst word_ubin.norm_eq_iff [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit LENGTH('b) (L (uint a) (uint b) mod 2 ^ LENGTH('a)) =\n    take_bit LENGTH('b)\n     (L (uint a mod 2 ^ LENGTH('b)) (uint b mod 2 ^ LENGTH('b)) mod\n      2 ^ LENGTH('b))", "apply (subst (1 2) bintrunc_mod2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. L (uint a) (uint b) mod 2 ^ LENGTH('a) mod 2 ^ LENGTH('b) =\n    L (uint a mod 2 ^ LENGTH('b)) (uint b mod 2 ^ LENGTH('b)) mod\n    2 ^ LENGTH('b) mod\n    2 ^ LENGTH('b)", "apply (insert is_down)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    L (uint a) (uint b) mod 2 ^ LENGTH('a) mod 2 ^ LENGTH('b) =\n    L (uint a mod 2 ^ LENGTH('b)) (uint b mod 2 ^ LENGTH('b)) mod\n    2 ^ LENGTH('b) mod\n    2 ^ LENGTH('b)", "apply (unfold is_down_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun (map_fun Word.Word Word.rep) id\n     (\\<lambda>_. LENGTH('b) \\<le> LENGTH('a))\n     UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    L (uint a) (uint b) mod 2 ^ LENGTH('a) mod 2 ^ LENGTH('b) =\n    L (uint a mod 2 ^ LENGTH('b)) (uint b mod 2 ^ LENGTH('b)) mod\n    2 ^ LENGTH('b) mod\n    2 ^ LENGTH('b)", "apply (clarsimp simp: target_size source_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n    L (uint a) (uint b) mod 2 ^ LENGTH('a) mod 2 ^ LENGTH('b) =\n    L (uint a mod 2 ^ LENGTH('b)) (uint b mod 2 ^ LENGTH('b)) mod\n    2 ^ LENGTH('b)", "apply (clarsimp simp: mod_exp_eq min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n    L (uint a) (uint b) mod 2 ^ LENGTH('b) =\n    L (uint a mod 2 ^ LENGTH('b)) (uint b mod 2 ^ LENGTH('b)) mod\n    2 ^ LENGTH('b)", "apply (rule distrib [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_down_add:\n    \"is_down (ucast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  ucast ((a :: 'a::len word) + b) = (ucast a + ucast b :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) (a + b) =\n    UCAST('a \\<rightarrow> 'b) a + UCAST('a \\<rightarrow> 'b) b", "by (rule ucast_distrib [where L=\"(+)\"], (clarsimp simp: uint_word_ariths)+, presburger, simp)"], ["", "lemma ucast_down_minus:\n    \"is_down (ucast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  ucast ((a :: 'a::len word) - b) = (ucast a - ucast b :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) (a - b) =\n    UCAST('a \\<rightarrow> 'b) a - UCAST('a \\<rightarrow> 'b) b", "apply (rule ucast_distrib [where L=\"(-)\"], (clarsimp simp: uint_word_ariths)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n       (x mod 2 ^ LENGTH('b) - y mod 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) =\n       (x - y) mod 2 ^ LENGTH('b)\n 2. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down UCAST('a \\<rightarrow> 'b)", "apply (metis mod_diff_left_eq mod_diff_right_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down UCAST('a \\<rightarrow> 'b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_down_mult:\n    \"is_down (ucast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  ucast ((a :: 'a::len word) * b) = (ucast a * ucast b :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) (a * b) =\n    UCAST('a \\<rightarrow> 'b) a * UCAST('a \\<rightarrow> 'b) b", "apply (rule ucast_distrib [where L=\"(*)\"], (clarsimp simp: uint_word_ariths)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n       x mod 2 ^ LENGTH('b) * (y mod 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) =\n       x * y mod 2 ^ LENGTH('b)\n 2. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down UCAST('a \\<rightarrow> 'b)", "apply (metis mod_mult_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down UCAST('a \\<rightarrow> 'b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scast_distrib:\n  fixes M :: \"'a::len word \\<Rightarrow> 'a::len word \\<Rightarrow> 'a::len word\"\n  fixes M' :: \"'b::len word \\<Rightarrow> 'b::len word \\<Rightarrow> 'b::len word\"\n  fixes L :: \"int \\<Rightarrow> int \\<Rightarrow> int\"\n  assumes lift_M: \"\\<And>x y. uint (M x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('a)\"\n  assumes lift_M': \"\\<And>x y. uint (M' x y) = L (uint x) (uint y)  mod 2 ^ LENGTH('b)\"\n  assumes distrib: \"\\<And>x y. (L (x mod (2 ^ LENGTH('b))) (y mod (2 ^ LENGTH('b)))) mod (2 ^ LENGTH('b))\n                               = (L x y) mod (2 ^ LENGTH('b))\"\n  assumes is_down: \"is_down (scast :: 'a word \\<Rightarrow> 'b word)\"\n  shows \"scast (M a b) = M' (scast a) (scast b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST('a \\<rightarrow> 'b) (M a b) =\n    M' (SCAST('a \\<rightarrow> 'b) a) (SCAST('a \\<rightarrow> 'b) b)", "apply (subst (1 2 3) down_cast_same [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_down UCAST('a \\<rightarrow> 'b)\n 2. UCAST('a \\<rightarrow> 'b) (M a b) =\n    M' (UCAST('a \\<rightarrow> 'b) a) (UCAST('a \\<rightarrow> 'b) b)", "apply (insert is_down)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down UCAST('a \\<rightarrow> 'b)\n 2. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) (M a b) =\n    M' (UCAST('a \\<rightarrow> 'b) a) (UCAST('a \\<rightarrow> 'b) b)", "apply (clarsimp simp: is_down_def target_size source_size is_down)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('a \\<rightarrow> 'b) (M a b) =\n    M' (UCAST('a \\<rightarrow> 'b) a) (UCAST('a \\<rightarrow> 'b) b)", "apply (rule ucast_distrib [where L=L, OF lift_M lift_M' distrib])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down UCAST('a \\<rightarrow> 'b)", "apply (insert is_down)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_down SCAST('a \\<rightarrow> 'b);\n     is_down SCAST('a \\<rightarrow> 'b)\\<rbrakk>\n    \\<Longrightarrow> is_down UCAST('a \\<rightarrow> 'b)", "apply (clarsimp simp: is_down_def target_size source_size is_down)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scast_down_add:\n    \"is_down (scast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  scast ((a :: 'a::len word) + b) = (scast a + scast b :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    SCAST('a \\<rightarrow> 'b) (a + b) =\n    SCAST('a \\<rightarrow> 'b) a + SCAST('a \\<rightarrow> 'b) b", "by (rule scast_distrib [where L=\"(+)\"], (clarsimp simp: uint_word_ariths)+, presburger, simp)"], ["", "lemma scast_down_minus:\n    \"is_down (scast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  scast ((a :: 'a::len word) - b) = (scast a - scast b :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    SCAST('a \\<rightarrow> 'b) (a - b) =\n    SCAST('a \\<rightarrow> 'b) a - SCAST('a \\<rightarrow> 'b) b", "apply (rule scast_distrib [where L=\"(-)\"], (clarsimp simp: uint_word_ariths)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n       (x mod 2 ^ LENGTH('b) - y mod 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) =\n       (x - y) mod 2 ^ LENGTH('b)\n 2. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down SCAST('a \\<rightarrow> 'b)", "apply (metis mod_diff_left_eq mod_diff_right_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down SCAST('a \\<rightarrow> 'b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scast_down_mult:\n    \"is_down (scast:: 'a word \\<Rightarrow> 'b word) \\<Longrightarrow>  scast ((a :: 'a::len word) * b) = (scast a * scast b :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    SCAST('a \\<rightarrow> 'b) (a * b) =\n    SCAST('a \\<rightarrow> 'b) a * SCAST('a \\<rightarrow> 'b) b", "apply (rule scast_distrib [where L=\"(*)\"], (clarsimp simp: uint_word_ariths)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n       x mod 2 ^ LENGTH('b) * (y mod 2 ^ LENGTH('b)) mod 2 ^ LENGTH('b) =\n       x * y mod 2 ^ LENGTH('b)\n 2. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down SCAST('a \\<rightarrow> 'b)", "apply (metis mod_mult_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    is_down SCAST('a \\<rightarrow> 'b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scast_ucast_1:\n  \"\\<lbrakk> is_down (ucast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n         (scast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_down UCAST('a \\<rightarrow> 'b);\n     is_down UCAST('b \\<rightarrow> 'c)\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'c)\n                       (UCAST('a \\<rightarrow> 'b) a) =\n                      UCAST('a \\<rightarrow> 'c) a", "by (metis down_cast_same ucast_eq ucast_down_wi)"], ["", "lemma scast_ucast_3:\n  \"\\<lbrakk> is_down (ucast :: 'a word \\<Rightarrow> 'c word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n         (scast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_down UCAST('a \\<rightarrow> 'c);\n     is_down UCAST('b \\<rightarrow> 'c)\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'c)\n                       (UCAST('a \\<rightarrow> 'b) a) =\n                      UCAST('a \\<rightarrow> 'c) a", "by (metis down_cast_same ucast_eq ucast_down_wi)"], ["", "lemma scast_ucast_4:\n  \"\\<lbrakk> is_up (ucast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n         (scast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_up UCAST('a \\<rightarrow> 'b);\n     is_down UCAST('b \\<rightarrow> 'c)\\<rbrakk>\n    \\<Longrightarrow> SCAST('b \\<rightarrow> 'c)\n                       (UCAST('a \\<rightarrow> 'b) a) =\n                      UCAST('a \\<rightarrow> 'c) a", "by (metis down_cast_same ucast_eq ucast_down_wi)"], ["", "lemma scast_scast_b:\n  \"\\<lbrakk> is_up (scast :: 'a word \\<Rightarrow> 'b word) \\<rbrakk> \\<Longrightarrow>\n     (scast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_up SCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    SCAST('b \\<rightarrow> 'c) (SCAST('a \\<rightarrow> 'b) a) =\n    SCAST('a \\<rightarrow> 'c) a", "by (metis scast_eq sint_up_scast)"], ["", "lemma ucast_scast_1:\n  \"\\<lbrakk> is_down (scast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n            (ucast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_down SCAST('a \\<rightarrow> 'b);\n     is_down UCAST('b \\<rightarrow> 'c)\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'c)\n                       (SCAST('a \\<rightarrow> 'b) a) =\n                      SCAST('a \\<rightarrow> 'c) a", "by (metis scast_eq ucast_down_wi)"], ["", "lemma ucast_scast_3:\n  \"\\<lbrakk> is_down (scast :: 'a word \\<Rightarrow> 'c word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n     (ucast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_down SCAST('a \\<rightarrow> 'c);\n     is_down UCAST('b \\<rightarrow> 'c)\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'c)\n                       (SCAST('a \\<rightarrow> 'b) a) =\n                      SCAST('a \\<rightarrow> 'c) a", "by (metis scast_eq ucast_down_wi)"], ["", "lemma ucast_scast_4:\n  \"\\<lbrakk> is_up (scast :: 'a word \\<Rightarrow> 'b word); is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n     (ucast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_up SCAST('a \\<rightarrow> 'b);\n     is_down UCAST('b \\<rightarrow> 'c)\\<rbrakk>\n    \\<Longrightarrow> UCAST('b \\<rightarrow> 'c)\n                       (SCAST('a \\<rightarrow> 'b) a) =\n                      SCAST('a \\<rightarrow> 'c) a", "by (metis down_cast_same scast_eq sint_up_scast)"], ["", "lemma ucast_ucast_a:\n  \"\\<lbrakk> is_down (ucast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n        (ucast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down UCAST('b \\<rightarrow> 'c) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'c) (UCAST('a \\<rightarrow> 'b) a) =\n    UCAST('a \\<rightarrow> 'c) a", "by (metis down_cast_same ucast_eq ucast_down_wi)"], ["", "lemma ucast_ucast_b:\n  \"\\<lbrakk> is_up (ucast :: 'a word \\<Rightarrow> 'b word) \\<rbrakk> \\<Longrightarrow>\n     (ucast (ucast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = ucast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_up UCAST('a \\<rightarrow> 'b) \\<Longrightarrow>\n    UCAST('b \\<rightarrow> 'c) (UCAST('a \\<rightarrow> 'b) a) =\n    UCAST('a \\<rightarrow> 'c) a", "by (metis ucast_up_ucast)"], ["", "lemma scast_scast_a:\n  \"\\<lbrakk> is_down (scast :: 'b word \\<Rightarrow> 'c word) \\<rbrakk> \\<Longrightarrow>\n            (scast (scast (a :: 'a::len word) :: 'b::len word) :: 'c::len word) = scast a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('b \\<rightarrow> 'c) \\<Longrightarrow>\n    SCAST('b \\<rightarrow> 'c) (SCAST('a \\<rightarrow> 'b) a) =\n    SCAST('a \\<rightarrow> 'c) a", "apply (simp only: scast_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down SCAST('b \\<rightarrow> 'c) \\<Longrightarrow>\n    word_of_int (sint (word_of_int (sint a))) = word_of_int (sint a)", "apply (metis down_cast_same is_up_down scast_eq ucast_down_wi)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scast_down_wi [OF refl]:\n  \"uc = scast \\<Longrightarrow> is_down uc \\<Longrightarrow> uc (word_of_int x) = word_of_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uc = SCAST('a \\<rightarrow> 'b); is_down uc\\<rbrakk>\n    \\<Longrightarrow> uc (word_of_int x) = word_of_int x", "by (metis down_cast_same is_up_down ucast_down_wi)"], ["", "lemmas cast_simps =\n  is_down is_up\n  scast_down_add scast_down_minus scast_down_mult\n  ucast_down_add ucast_down_minus ucast_down_mult\n  scast_ucast_1 scast_ucast_3 scast_ucast_4\n  ucast_scast_1 ucast_scast_3 ucast_scast_4\n  ucast_ucast_a ucast_ucast_b\n  scast_scast_a scast_scast_b\n  ucast_down_wi scast_down_wi\n  ucast_of_nat scast_of_nat\n  uint_up_ucast sint_up_scast\n  up_scast_surj up_ucast_surj"], ["", "lemma sdiv_word_max:\n    \"(sint (a :: ('a::len) word) sdiv sint (b :: ('a::len) word) < (2 ^ (size a - 1))) =\n          ((a \\<noteq> - (2 ^ (size a - 1)) \\<or> (b \\<noteq> -1)))\"\n    (is \"?lhs = (\\<not> ?a_int_min \\<or> \\<not> ?b_minus1)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "proof (rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1) \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "assume not_thesis: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n  (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)\n\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1) \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "have not_zero: \"b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "using not_thesis"], ["proof (prove)\nusing this:\n  (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n  (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "by (clarsimp)"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1) \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "have result_range: \"sint a sdiv sint b \\<in> (sints (size a)) \\<union> {2 ^ (size a - 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a sdiv sint b \\<in> sints (size a) \\<union> {2 ^ (size a - 1)}", "apply (cut_tac sdiv_int_range [where a=\"sint a\" and b=\"sint b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a sdiv sint b\n    \\<in> {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>} \\<Longrightarrow>\n    sint a sdiv sint b \\<in> sints (size a) \\<union> {2 ^ (size a - 1)}", "apply (erule rev_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>}\n    \\<subseteq> sints (size a) \\<union> {2 ^ (size a - 1)}", "using sint_range' [where x=a]  sint_range' [where x=b]"], ["proof (prove)\nusing this:\n  - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint a \\<and>\n  sint a < 2 ^ (LENGTH('a) - Suc 0)\n  - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint b \\<and>\n  sint b < 2 ^ (LENGTH('a) - Suc 0)\n\ngoal (1 subgoal):\n 1. {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>}\n    \\<subseteq> sints (size a) \\<union> {2 ^ (size a - 1)}", "apply (auto simp: max_def abs_if word_size sints_num)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sint a sdiv sint b \\<in> sints (size a) \\<union> {2 ^ (size a - 1)}\n\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1) \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "have result_range_overflow: \"(sint a sdiv sint b = 2 ^ (size a - 1)) = (?a_int_min \\<and> ?b_minus1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint a sdiv sint b = 2 ^ (size a - 1)) =\n    (a = - (2 ^ (size a - 1)) \\<and> b = - 1)", "apply (rule iffI [rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = - (2 ^ (size a - 1)) \\<and> b = - 1 \\<Longrightarrow>\n    sint a sdiv sint b = 2 ^ (size a - 1)\n 2. sint a sdiv sint b = 2 ^ (size a - 1) \\<Longrightarrow>\n    a = - (2 ^ (size a - 1)) \\<and> b = - 1", "apply (clarsimp simp: signed_divide_int_def sgn_if word_size sint_int_min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a sdiv sint b = 2 ^ (size a - 1) \\<Longrightarrow>\n    a = - (2 ^ (size a - 1)) \\<and> b = - 1", "apply (rule classical)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1)\\<rbrakk>\n    \\<Longrightarrow> a = - (2 ^ (size a - 1)) \\<and> b = - 1", "apply (case_tac \"?a_int_min\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a = - (2 ^ (size a - 1))\\<rbrakk>\n    \\<Longrightarrow> a = - (2 ^ (size a - 1)) \\<and> b = - 1\n 2. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1))\\<rbrakk>\n    \\<Longrightarrow> a = - (2 ^ (size a - 1)) \\<and> b = - 1", "apply (clarsimp simp: word_size sint_int_min)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- (2 ^ (LENGTH('a) - Suc 0)) sdiv sint b =\n             2 ^ (LENGTH('a) - Suc 0);\n     b \\<noteq> - 1; a = - (2 ^ (LENGTH('a) - Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1))\\<rbrakk>\n    \\<Longrightarrow> a = - (2 ^ (size a - 1)) \\<and> b = - 1", "apply (metis diff_0_right\n              int_sdiv_negated_is_minus1 minus_diff_eq minus_int_code(2)\n              power_eq_0_iff sint_minus1 zero_neq_numeral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1))\\<rbrakk>\n    \\<Longrightarrow> a = - (2 ^ (size a - 1)) \\<and> b = - 1", "apply (subgoal_tac \"abs (sint a) < 2 ^ (size a - 1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1));\n     \\<bar>sint a\\<bar> < 2 ^ (size a - 1)\\<rbrakk>\n    \\<Longrightarrow> a = - (2 ^ (size a - 1)) \\<and> b = - 1\n 2. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1))\\<rbrakk>\n    \\<Longrightarrow> \\<bar>sint a\\<bar> < 2 ^ (size a - 1)", "apply (insert sdiv_int_range [where a=\"sint a\" and b=\"sint b\"])[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1)); \\<bar>sint a\\<bar> < 2 ^ (size a - 1);\n     sint a sdiv sint b\n     \\<in> {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>}\\<rbrakk>\n    \\<Longrightarrow> a = - (2 ^ (size a - 1)) \\<and> b = - 1\n 2. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1))\\<rbrakk>\n    \\<Longrightarrow> \\<bar>sint a\\<bar> < 2 ^ (size a - 1)", "apply (clarsimp simp: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1))\\<rbrakk>\n    \\<Longrightarrow> \\<bar>sint a\\<bar> < 2 ^ (size a - 1)", "apply (insert sdiv_int_range [where a=\"sint a\" and b=\"sint b\"])[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1));\n     sint a sdiv sint b\n     \\<in> {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>sint a\\<bar> < 2 ^ (size a - 1)", "apply (insert word_sint.Rep [where x=\"a\"])[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint a sdiv sint b = 2 ^ (size a - 1);\n     \\<not> (a = - (2 ^ (size a - 1)) \\<and> b = - 1);\n     a \\<noteq> - (2 ^ (size a - 1));\n     sint a sdiv sint b \\<in> {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>};\n     sint a \\<in> sints LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<bar>sint a\\<bar> < 2 ^ (size a - 1)", "apply (clarsimp simp: minus_le_iff word_size abs_if sints_num split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint a sdiv sint b = - sint a;\n     a \\<noteq> - (2 ^ (LENGTH('a) - Suc 0)); sint a < 0;\n     2 ^ (LENGTH('a) - Suc 0) = - sint a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis minus_minus sint_int_min word_sint.Rep_inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sint a sdiv sint b = 2 ^ (size a - 1)) =\n  (a = - (2 ^ (size a - 1)) \\<and> b = - 1)\n\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1) \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "have result_range_simple: \"(sint a sdiv sint b \\<in> (sints (size a))) \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a sdiv sint b \\<in> sints (size a) \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "apply (insert sdiv_int_range [where a=\"sint a\" and b=\"sint b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint a sdiv sint b \\<in> sints (size a);\n     sint a sdiv sint b\n     \\<in> {- \\<bar>sint a\\<bar>..\\<bar>sint a\\<bar>}\\<rbrakk>\n    \\<Longrightarrow> (sint a sdiv sint b < 2 ^ (size a - 1)) =\n                      (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "apply (clarsimp simp: word_size sints_num sint_int_min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sint a sdiv sint b \\<in> sints (size a) \\<Longrightarrow>\n  (sint a sdiv sint b < 2 ^ (size a - 1)) =\n  (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)\n\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) \\<noteq>\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1) \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "apply (rule UnE [OF result_range result_range_simple])"], ["proof (prove)\ngoal (2 subgoals):\n 1. sint a sdiv sint b \\<in> sints (size a) \\<Longrightarrow>\n    sint a sdiv sint b \\<in> sints (size a)\n 2. sint a sdiv sint b \\<in> {2 ^ (size a - 1)} \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a sdiv sint b \\<in> {2 ^ (size a - 1)} \\<Longrightarrow>\n    (sint a sdiv sint b < 2 ^ (size a - 1)) =\n    (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)", "apply (clarsimp simp: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sint a sdiv sint b = 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n    a = - (2 ^ (LENGTH('a) - Suc 0)) \\<and> b = - 1", "using result_range_overflow"], ["proof (prove)\nusing this:\n  (sint a sdiv sint b = 2 ^ (size a - 1)) =\n  (a = - (2 ^ (size a - 1)) \\<and> b = - 1)\n\ngoal (1 subgoal):\n 1. sint a sdiv sint b = 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n    a = - (2 ^ (LENGTH('a) - Suc 0)) \\<and> b = - 1", "apply (clarsimp simp: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sint a sdiv sint b < 2 ^ (size a - 1)) =\n  (a \\<noteq> - (2 ^ (size a - 1)) \\<or> b \\<noteq> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas sdiv_word_min' = sdiv_word_min [simplified word_size, simplified]"], ["", "lemmas sdiv_word_max' = sdiv_word_max [simplified word_size, simplified]"], ["", "lemma signed_arith_ineq_checks_to_eq:\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a + sint b)) \\<and> (sint a + sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a + sint b = sint (a + b ))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a - sint b)) \\<and> (sint a - sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a - sint b = sint (a - b))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (- sint a)) \\<and> (- sint a) \\<le> (2 ^ (size a - 1) - 1))\n    = ((- sint a) = sint (- a))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a * sint b)) \\<and> (sint a * sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a * sint b = sint (a * b))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a sdiv sint b)) \\<and> (sint a sdiv sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a sdiv sint b = sint (a sdiv b))\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a smod sint b)) \\<and> (sint a smod sint b \\<le> (2 ^ (size a - 1) - 1)))\n    = (sint a smod sint b = sint (a smod b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((- (2 ^ (size a - 1)) \\<le> sint a + sint b \\<and>\n      sint a + sint b \\<le> 2 ^ (size a - 1) - 1) =\n     (sint a + sint b = sint (a + b)) &&&\n     (- (2 ^ (size a - 1)) \\<le> sint a - sint b \\<and>\n      sint a - sint b \\<le> 2 ^ (size a - 1) - 1) =\n     (sint a - sint b = sint (a - b)) &&&\n     (- (2 ^ (size a - 1)) \\<le> - sint a \\<and>\n      - sint a \\<le> 2 ^ (size a - 1) - 1) =\n     (- sint a = sint (- a))) &&&\n    (- (2 ^ (size a - 1)) \\<le> sint a * sint b \\<and>\n     sint a * sint b \\<le> 2 ^ (size a - 1) - 1) =\n    (sint a * sint b = sint (a * b)) &&&\n    (- (2 ^ (size a - 1)) \\<le> sint a sdiv sint b \\<and>\n     sint a sdiv sint b \\<le> 2 ^ (size a - 1) - 1) =\n    (sint a sdiv sint b = sint (a sdiv b)) &&&\n    (- (2 ^ (size a - 1)) \\<le> sint a smod sint b \\<and>\n     sint a smod sint b \\<le> 2 ^ (size a - 1) - 1) =\n    (sint a smod sint b = sint (a smod b))", "by (auto simp: sint_word_ariths word_size signed_div_arith signed_mod_arith\n                    sbintrunc_eq_in_range range_sbintrunc)"], ["", "lemma signed_arith_sint:\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a + sint b)) \\<and> (sint a + sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a + b) = (sint a + sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a - sint b)) \\<and> (sint a - sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a - b) = (sint a - sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (- sint a)) \\<and> (- sint a) \\<le> (2 ^ (size a - 1) - 1))\n    \\<Longrightarrow> sint (- a) = (- sint a)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a * sint b)) \\<and> (sint a * sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a * b) = (sint a * sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a sdiv sint b)) \\<and> (sint a sdiv sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a sdiv b) = (sint a sdiv sint b)\"\n  \"((- (2 ^ (size a - 1)) \\<le> (sint a smod sint b)) \\<and> (sint a smod sint b \\<le> (2 ^ (size a - 1) - 1)))\n    \\<Longrightarrow> sint (a smod b) = (sint a smod sint b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((- (2 ^ (size a - 1)) \\<le> sint a + sint b \\<and>\n      sint a + sint b \\<le> 2 ^ (size a - 1) - 1 \\<Longrightarrow>\n      sint (a + b) = sint a + sint b) &&&\n     (- (2 ^ (size a - 1)) \\<le> sint a - sint b \\<and>\n      sint a - sint b \\<le> 2 ^ (size a - 1) - 1 \\<Longrightarrow>\n      sint (a - b) = sint a - sint b) &&&\n     (- (2 ^ (size a - 1)) \\<le> - sint a \\<and>\n      - sint a \\<le> 2 ^ (size a - 1) - 1 \\<Longrightarrow>\n      sint (- a) = - sint a)) &&&\n    (- (2 ^ (size a - 1)) \\<le> sint a * sint b \\<and>\n     sint a * sint b \\<le> 2 ^ (size a - 1) - 1 \\<Longrightarrow>\n     sint (a * b) = sint a * sint b) &&&\n    (- (2 ^ (size a - 1)) \\<le> sint a sdiv sint b \\<and>\n     sint a sdiv sint b \\<le> 2 ^ (size a - 1) - 1 \\<Longrightarrow>\n     sint (a sdiv b) = sint a sdiv sint b) &&&\n    (- (2 ^ (size a - 1)) \\<le> sint a smod sint b \\<and>\n     sint a smod sint b \\<le> 2 ^ (size a - 1) - 1 \\<Longrightarrow>\n     sint (a smod b) = sint a smod sint b)", "by (subst (asm) signed_arith_ineq_checks_to_eq; simp)+"], ["", "end"]]}