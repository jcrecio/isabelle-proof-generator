{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Enumeration.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma the_index_bounded:\n  \"x \\<in> set xs \\<Longrightarrow> the_index xs x < length xs\"", "lemma nth_the_index:\n  \"x \\<in> set xs \\<Longrightarrow> xs ! the_index xs x = x\"", "lemma distinct_the_index_is_index[simp]:\n  \"\\<lbrakk> distinct xs ; n < length xs \\<rbrakk> \\<Longrightarrow> the_index xs (xs ! n) = n\"", "lemma the_index_last_distinct:\n  \"distinct xs \\<and> xs \\<noteq> [] \\<Longrightarrow> the_index xs (last xs) = length xs - 1\"", "lemmas enum_surj[simp] = enum_UNIV", "lemma enum_nonempty[simp]: \"(enum :: 'a list) \\<noteq> []\"", "lemma maxBound_is_length:\n  \"fromEnum maxBound = length (enum :: 'a list) - 1\"", "lemma maxBound_less_length:\n  \"(x \\<le> fromEnum maxBound) = (x < length (enum :: 'a list))\"", "lemma maxBound_is_bound [simp]:\n  \"fromEnum x \\<le> fromEnum maxBound\"", "lemma to_from_enum [simp]:\n  fixes x :: 'a\n  shows \"toEnum (fromEnum x) = x\"", "lemma from_to_enum [simp]:\n  \"x \\<le> fromEnum maxBound \\<Longrightarrow> fromEnum (toEnum x) = x\"", "lemma map_enum:\n  fixes x :: 'a\n  shows \"map f enum ! fromEnum x = f x\"", "lemmas enum_bool = enum_bool_def", "lemma fromEnumTrue [simp]: \"fromEnum True = 1\"", "lemma fromEnumFalse [simp]: \"fromEnum False = 0\"", "lemma enum_alt_inj_2:\n  assumes \"enum_alt x = (enum_alt y :: 'a option)\"\n          \"enum_alt x \\<noteq> (None :: 'a option)\"\n  shows \"x = y\"", "lemma enum_alt_surj_2:\n  \"\\<exists>x. enum_alt x = Some y\"", "lemma handy_if_lemma: \"((if P then Some A else None) = Some B) = (P \\<and> (A = B))\"", "lemma fromEnum_alt_red[simp]:\n  \"fromEnumAlt = (fromEnum :: ('a :: enumeration_both) \\<Rightarrow> nat)\"", "lemma toEnum_alt_red[simp]:\n  \"toEnumAlt = (toEnum :: nat \\<Rightarrow> 'a :: enumeration_both)\"", "lemma upto_enum_red:\n  \"[(n :: ('a :: enumeration_both)) .e. m] = map toEnum [fromEnum n ..< Suc (fromEnum m)]\"", "lemma toEnumAlt_nat[simp]: \"toEnumAlt = id\"", "lemma fromEnumAlt_nat[simp]: \"fromEnumAlt = id\"", "lemma upto_enum_nat[simp]: \"[n .e. m] = [n ..< Suc m]\"", "lemma to_from_enum_alt[simp]:\n  \"toEnumAlt (fromEnumAlt x) = (x :: 'a :: enumeration_alt)\"", "lemma upto_enum_triv [simp]: \"[x .e. x] = [x]\"", "lemma toEnum_eq_to_fromEnum_eq:\n  fixes v :: \"'a :: enum\"\n  shows \"n \\<le> fromEnum (maxBound :: 'a) \\<Longrightarrow> (toEnum n = v) = (n = fromEnum v)\"", "lemma le_imp_diff_le:\n  \"(j::nat) \\<le> k \\<Longrightarrow> j - n \\<le> k\"", "lemma fromEnum_upto_nth:\n  fixes start :: \"'a :: enumeration_both\"\n  assumes \"n < length [start .e. end]\"\n  shows \"fromEnum ([start .e. end] ! n) = fromEnum start + n\"", "lemma length_upto_enum_le_maxBound:\n  fixes start :: \"'a :: enumeration_both\"\n  shows \"length [start .e. end] \\<le> Suc (fromEnum (maxBound :: 'a))\"", "lemma less_length_upto_enum_maxBoundD:\n  fixes start :: \"'a :: enumeration_both\"\n  assumes \"n < length [start .e. end]\"\n  shows \"n \\<le> fromEnum (maxBound :: 'a)\"", "lemma fromEnum_eq_iff:\n  \"(fromEnum e = fromEnum f) = (e = f)\"", "lemma maxBound_is_bound':\n  \"i = fromEnum (e::('a::enum)) \\<Longrightarrow> i \\<le> fromEnum (maxBound::('a::enum))\""], "translations": [["", "lemma the_index_bounded:\n  \"x \\<in> set xs \\<Longrightarrow> the_index xs x < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> the_index xs x < length xs", "by (induct xs, clarsimp+)"], ["", "lemma nth_the_index:\n  \"x \\<in> set xs \\<Longrightarrow> xs ! the_index xs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs ! the_index xs x = x", "by (induct xs, clarsimp+)"], ["", "lemma distinct_the_index_is_index[simp]:\n  \"\\<lbrakk> distinct xs ; n < length xs \\<rbrakk> \\<Longrightarrow> the_index xs (xs ! n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n    \\<Longrightarrow> the_index xs (xs ! n) = n", "by (meson nth_eq_iff_index_eq nth_mem nth_the_index the_index_bounded)"], ["", "lemma the_index_last_distinct:\n  \"distinct xs \\<and> xs \\<noteq> [] \\<Longrightarrow> the_index xs (last xs) = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<and> xs \\<noteq> [] \\<Longrightarrow>\n    the_index xs (last xs) = length xs - 1", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> the_index xs (last xs) = length xs - 1", "apply (subgoal_tac \"xs ! (length xs - 1) = last xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> [];\n     xs ! (length xs - 1) = last xs\\<rbrakk>\n    \\<Longrightarrow> the_index xs (last xs) = length xs - 1\n 2. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - 1) = last xs", "apply (subgoal_tac \"xs ! the_index xs (last xs) = last xs\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> the_index xs (last xs) = length xs - 1\n 2. \\<lbrakk>distinct xs; xs \\<noteq> [];\n     xs ! (length xs - 1) = last xs\\<rbrakk>\n    \\<Longrightarrow> xs ! the_index xs (last xs) = last xs\n 3. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - 1) = last xs", "apply (subst nth_eq_iff_index_eq[symmetric])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> distinct ?xs4\n 2. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> the_index xs (last xs) < length ?xs4\n 3. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> length xs - 1 < length ?xs4\n 4. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> ?xs4 ! the_index xs (last xs) = ?xs4 ! (length xs - 1)\n 5. \\<lbrakk>distinct xs; xs \\<noteq> [];\n     xs ! (length xs - 1) = last xs\\<rbrakk>\n    \\<Longrightarrow> xs ! the_index xs (last xs) = last xs\n 6. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - 1) = last xs", "apply assumption"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> the_index xs (last xs) < length xs\n 2. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> length xs - 1 < length xs\n 3. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> xs ! the_index xs (last xs) = xs ! (length xs - 1)\n 4. \\<lbrakk>distinct xs; xs \\<noteq> [];\n     xs ! (length xs - 1) = last xs\\<rbrakk>\n    \\<Longrightarrow> xs ! the_index xs (last xs) = last xs\n 5. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - 1) = last xs", "apply (rule the_index_bounded)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> last xs \\<in> set xs\n 2. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> length xs - 1 < length xs\n 3. \\<lbrakk>distinct xs; xs \\<noteq> []; xs ! (length xs - 1) = last xs;\n     xs ! the_index xs (last xs) = last xs\\<rbrakk>\n    \\<Longrightarrow> xs ! the_index xs (last xs) = xs ! (length xs - 1)\n 4. \\<lbrakk>distinct xs; xs \\<noteq> [];\n     xs ! (length xs - 1) = last xs\\<rbrakk>\n    \\<Longrightarrow> xs ! the_index xs (last xs) = last xs\n 5. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - 1) = last xs", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> [];\n     xs ! (length xs - Suc 0) = last xs\\<rbrakk>\n    \\<Longrightarrow> xs ! the_index xs (last xs) = last xs\n 2. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - Suc 0) = last xs", "apply (rule nth_the_index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> [];\n     xs ! (length xs - Suc 0) = last xs\\<rbrakk>\n    \\<Longrightarrow> last xs \\<in> set xs\n 2. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - Suc 0) = last xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! (length xs - Suc 0) = last xs", "apply (induct xs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context enum begin"], ["", "(* These two are added for historical reasons. *)"], ["", "lemmas enum_surj[simp] = enum_UNIV"], ["", "declare enum_distinct[simp]"], ["", "lemma enum_nonempty[simp]: \"(enum :: 'a list) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum \\<noteq> []", "using enum_surj"], ["proof (prove)\nusing this:\n  set enum_class.enum = UNIV\n\ngoal (1 subgoal):\n 1. enum_class.enum \\<noteq> []", "by fastforce"], ["", "definition\n  maxBound :: 'a where\n  \"maxBound \\<equiv> last enum\""], ["", "definition\n  minBound :: 'a where\n  \"minBound \\<equiv> hd enum\""], ["", "definition\n  toEnum :: \"nat \\<Rightarrow> 'a\" where\n  \"toEnum n \\<equiv> if n < length (enum :: 'a list) then enum ! n else the None\""], ["", "definition\n  fromEnum :: \"'a \\<Rightarrow> nat\" where\n  \"fromEnum x \\<equiv> the_index enum x\""], ["", "lemma maxBound_is_length:\n  \"fromEnum maxBound = length (enum :: 'a list) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum maxBound = length enum_class.enum - 1", "by (simp add: maxBound_def fromEnum_def the_index_last_distinct)"], ["", "lemma maxBound_less_length:\n  \"(x \\<le> fromEnum maxBound) = (x < length (enum :: 'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> fromEnum maxBound) = (x < length enum_class.enum)", "unfolding maxBound_is_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> length enum_class.enum - 1) = (x < length enum_class.enum)", "by (cases \"length enum\") auto"], ["", "lemma maxBound_is_bound [simp]:\n  \"fromEnum x \\<le> fromEnum maxBound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum x \\<le> fromEnum maxBound", "unfolding maxBound_less_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum x < length enum_class.enum", "by (fastforce simp: fromEnum_def intro: the_index_bounded)"], ["", "lemma to_from_enum [simp]:\n  fixes x :: 'a\n  shows \"toEnum (fromEnum x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toEnum (fromEnum x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. toEnum (fromEnum x) = x", "have \"x \\<in> set enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set enum_class.enum", "by simp"], ["proof (state)\nthis:\n  x \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. toEnum (fromEnum x) = x", "then"], ["proof (chain)\npicking this:\n  x \\<in> set enum_class.enum", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. toEnum (fromEnum x) = x", "by (simp add: toEnum_def fromEnum_def nth_the_index the_index_bounded)"], ["proof (state)\nthis:\n  toEnum (fromEnum x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_to_enum [simp]:\n  \"x \\<le> fromEnum maxBound \\<Longrightarrow> fromEnum (toEnum x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> fromEnum maxBound \\<Longrightarrow> fromEnum (toEnum x) = x", "unfolding maxBound_less_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length enum_class.enum \\<Longrightarrow> fromEnum (toEnum x) = x", "by (simp add: toEnum_def fromEnum_def)"], ["", "lemma map_enum:\n  fixes x :: 'a\n  shows \"map f enum ! fromEnum x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "have \"fromEnum x \\<le> fromEnum (maxBound :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum x \\<le> fromEnum maxBound", "by (rule maxBound_is_bound)"], ["proof (state)\nthis:\n  fromEnum x \\<le> fromEnum maxBound\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "then"], ["proof (chain)\npicking this:\n  fromEnum x \\<le> fromEnum maxBound", "have \"fromEnum x < length (enum::'a list)\""], ["proof (prove)\nusing this:\n  fromEnum x \\<le> fromEnum maxBound\n\ngoal (1 subgoal):\n 1. fromEnum x < length enum_class.enum", "by (simp add: maxBound_less_length)"], ["proof (state)\nthis:\n  fromEnum x < length enum_class.enum\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "then"], ["proof (chain)\npicking this:\n  fromEnum x < length enum_class.enum", "have \"map f enum ! fromEnum x = f (enum ! fromEnum x)\""], ["proof (prove)\nusing this:\n  fromEnum x < length enum_class.enum\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f (enum_class.enum ! fromEnum x)", "by simp"], ["proof (state)\nthis:\n  map f enum_class.enum ! fromEnum x = f (enum_class.enum ! fromEnum x)\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "also"], ["proof (state)\nthis:\n  map f enum_class.enum ! fromEnum x = f (enum_class.enum ! fromEnum x)\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "have \"x \\<in> set enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set enum_class.enum", "by simp"], ["proof (state)\nthis:\n  x \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "then"], ["proof (chain)\npicking this:\n  x \\<in> set enum_class.enum", "have \"enum ! fromEnum x = x\""], ["proof (prove)\nusing this:\n  x \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_class.enum ! fromEnum x = x", "by (simp add: fromEnum_def nth_the_index)"], ["proof (state)\nthis:\n  enum_class.enum ! fromEnum x = x\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "finally"], ["proof (chain)\npicking this:\n  map f enum_class.enum ! fromEnum x = f x", "show ?thesis"], ["proof (prove)\nusing this:\n  map f enum_class.enum ! fromEnum x = f x\n\ngoal (1 subgoal):\n 1. map f enum_class.enum ! fromEnum x = f x", "."], ["proof (state)\nthis:\n  map f enum_class.enum ! fromEnum x = f x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  assocs :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<times> 'b) list\" where\n \"assocs f \\<equiv> map (\\<lambda>x. (x, f x)) enum\""], ["", "end"], ["", "(* For historical naming reasons. *)"], ["", "lemmas enum_bool = enum_bool_def"], ["", "lemma fromEnumTrue [simp]: \"fromEnum True = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum True = 1", "by (simp add: fromEnum_def enum_bool)"], ["", "lemma fromEnumFalse [simp]: \"fromEnum False = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum False = 0", "by (simp add: fromEnum_def enum_bool)"], ["", "class enum_alt =\n  fixes enum_alt :: \"nat \\<Rightarrow> 'a option\""], ["", "class enumeration_alt = enum_alt +\n  assumes enum_alt_one_bound:\n    \"enum_alt x = (None :: 'a option) \\<Longrightarrow> enum_alt (Suc x) = (None :: 'a option)\"\n  assumes enum_alt_surj:\n    \"range enum_alt \\<union> {None} = UNIV\"\n  assumes enum_alt_inj:\n    \"(enum_alt x :: 'a option) = enum_alt y \\<Longrightarrow> (x = y) \\<or> (enum_alt x = (None :: 'a option))\"\nbegin"], ["", "lemma enum_alt_inj_2:\n  assumes \"enum_alt x = (enum_alt y :: 'a option)\"\n          \"enum_alt x \\<noteq> (None :: 'a option)\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "from assms"], ["proof (chain)\npicking this:\n  enum_alt x = enum_alt y\n  enum_alt x \\<noteq> None", "have \"(x = y) \\<or> (enum_alt x = (None :: 'a option))\""], ["proof (prove)\nusing this:\n  enum_alt x = enum_alt y\n  enum_alt x \\<noteq> None\n\ngoal (1 subgoal):\n 1. x = y \\<or> enum_alt x = None", "by (fastforce intro!: enum_alt_inj)"], ["proof (state)\nthis:\n  x = y \\<or> enum_alt x = None\n\ngoal (1 subgoal):\n 1. x = y", "with assms"], ["proof (chain)\npicking this:\n  enum_alt x = enum_alt y\n  enum_alt x \\<noteq> None\n  x = y \\<or> enum_alt x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  enum_alt x = enum_alt y\n  enum_alt x \\<noteq> None\n  x = y \\<or> enum_alt x = None\n\ngoal (1 subgoal):\n 1. x = y", "by clarsimp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enum_alt_surj_2:\n  \"\\<exists>x. enum_alt x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. enum_alt x = Some y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. enum_alt x = Some y", "have \"Some y \\<in> range enum_alt \\<union> {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some y \\<in> range enum_alt \\<union> {None}", "by (subst enum_alt_surj) simp"], ["proof (state)\nthis:\n  Some y \\<in> range enum_alt \\<union> {None}\n\ngoal (1 subgoal):\n 1. \\<exists>x. enum_alt x = Some y", "then"], ["proof (chain)\npicking this:\n  Some y \\<in> range enum_alt \\<union> {None}", "have \"Some y \\<in> range enum_alt\""], ["proof (prove)\nusing this:\n  Some y \\<in> range enum_alt \\<union> {None}\n\ngoal (1 subgoal):\n 1. Some y \\<in> range enum_alt", "by simp"], ["proof (state)\nthis:\n  Some y \\<in> range enum_alt\n\ngoal (1 subgoal):\n 1. \\<exists>x. enum_alt x = Some y", "then"], ["proof (chain)\npicking this:\n  Some y \\<in> range enum_alt", "show ?thesis"], ["proof (prove)\nusing this:\n  Some y \\<in> range enum_alt\n\ngoal (1 subgoal):\n 1. \\<exists>x. enum_alt x = Some y", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. enum_alt x = Some y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition\n  alt_from_ord :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a option\"\nwhere\n  \"alt_from_ord L \\<equiv> \\<lambda>n. if (n < length L) then Some (L ! n) else None\""], ["", "lemma handy_if_lemma: \"((if P then Some A else None) = Some B) = (P \\<and> (A = B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then Some A else None) = Some B) = (P \\<and> A = B)", "by simp"], ["", "class enumeration_both = enum_alt + enum +\n  assumes enum_alt_rel: \"enum_alt = alt_from_ord enum\""], ["", "instance enumeration_both < enumeration_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, enumeration_alt_class)", "apply (intro_classes; simp add: enum_alt_rel alt_from_ord_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       (if x < length enum then Some (enum ! x) else None) =\n       None \\<Longrightarrow>\n       \\<not> Suc x < length enum\n 2. insert None\n     ((\\<lambda>x. Some (enum ! x)) ` {x. x < length enum} \\<union>\n      Map.empty ` {x. \\<not> x < length enum}) =\n    UNIV\n 3. \\<And>x y.\n       (if x < length enum then Some (enum ! x) else None) =\n       (if y < length enum then Some (enum ! y) else None) \\<Longrightarrow>\n       y < length enum \\<longrightarrow> x = y", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. insert None\n     ((\\<lambda>x. Some (enum ! x)) ` {x. x < length enum} \\<union>\n      Map.empty ` {x. \\<not> x < length enum}) =\n    UNIV\n 2. \\<And>x y.\n       (if x < length enum then Some (enum ! x) else None) =\n       (if y < length enum then Some (enum ! y) else None) \\<Longrightarrow>\n       y < length enum \\<longrightarrow> x = y", "apply (safe; simp)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       Some y\n       \\<notin> Map.empty ` {x. \\<not> x < length enum} \\<Longrightarrow>\n       Some y \\<in> (\\<lambda>x. Some (enum ! x)) ` {x. x < length enum}\n 2. \\<And>x y.\n       (if x < length enum then Some (enum ! x) else None) =\n       (if y < length enum then Some (enum ! y) else None) \\<Longrightarrow>\n       y < length enum \\<longrightarrow> x = y", "apply (rule rev_image_eqI; simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       Some y\n       \\<notin> Map.empty ` {x. \\<not> x < length enum} \\<Longrightarrow>\n       ?x53 y < length enum\n 2. \\<And>y.\n       Some y\n       \\<notin> Map.empty ` {x. \\<not> x < length enum} \\<Longrightarrow>\n       y = enum ! ?x53 y\n 3. \\<And>x y.\n       (if x < length enum then Some (enum ! x) else None) =\n       (if y < length enum then Some (enum ! y) else None) \\<Longrightarrow>\n       y < length enum \\<longrightarrow> x = y", "apply (rule the_index_bounded; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       Some y\n       \\<notin> Map.empty ` {x. \\<not> x < length enum} \\<Longrightarrow>\n       y = enum ! the_index enum (?x62 y)\n 2. \\<And>x y.\n       (if x < length enum then Some (enum ! x) else None) =\n       (if y < length enum then Some (enum ! y) else None) \\<Longrightarrow>\n       y < length enum \\<longrightarrow> x = y", "apply (subst nth_the_index; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (if x < length enum then Some (enum ! x) else None) =\n       (if y < length enum then Some (enum ! y) else None) \\<Longrightarrow>\n       y < length enum \\<longrightarrow> x = y", "apply (clarsimp simp: handy_if_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>y < length enum; x < length enum;\n        enum ! x = enum ! y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (subst nth_eq_iff_index_eq[symmetric]; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation bool :: enumeration_both\nbegin"], ["", "definition enum_alt_bool: \"enum_alt \\<equiv> alt_from_ord [False, True]\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, enumeration_both_class)", "by (intro_classes, simp add: enum_bool_def enum_alt_bool)"], ["", "end"], ["", "definition\n  toEnumAlt :: \"nat \\<Rightarrow> ('a :: enum_alt)\" where\n \"toEnumAlt n \\<equiv> the (enum_alt n)\""], ["", "definition\n  fromEnumAlt :: \"('a :: enum_alt) \\<Rightarrow> nat\" where\n \"fromEnumAlt x \\<equiv> THE n. enum_alt n = Some x\""], ["", "definition\n  upto_enum :: \"('a :: enumeration_alt) \\<Rightarrow> 'a \\<Rightarrow> 'a list\" (\"(1[_ .e. _])\") where\n \"upto_enum n m \\<equiv> map toEnumAlt [fromEnumAlt n ..< Suc (fromEnumAlt m)]\""], ["", "lemma fromEnum_alt_red[simp]:\n  \"fromEnumAlt = (fromEnum :: ('a :: enumeration_both) \\<Rightarrow> nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnumAlt = fromEnum", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. fromEnumAlt x = fromEnum x", "apply (simp add: fromEnumAlt_def fromEnum_def enum_alt_rel alt_from_ord_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (THE n.\n           (n < length enum \\<longrightarrow> enum ! n = x) \\<and>\n           n < length enum) =\n       the_index enum x", "apply (rule theI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       (?a9 x < length enum \\<longrightarrow> enum ! ?a9 x = x) \\<and>\n       ?a9 x < length enum\n 2. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = ?a9 x\n 3. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = the_index enum x", "apply (rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. ?a9 x < length enum \\<longrightarrow> enum ! ?a9 x = x\n 2. \\<And>x. ?a9 x < length enum\n 3. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = ?a9 x\n 4. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = the_index enum x", "apply (clarify, rule nth_the_index, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. the_index enum x < length enum\n 2. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = the_index enum x\n 3. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = the_index enum x", "apply (rule the_index_bounded, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = the_index enum x\n 2. \\<And>x xa.\n       (xa < length enum \\<longrightarrow> enum ! xa = x) \\<and>\n       xa < length enum \\<Longrightarrow>\n       xa = the_index enum x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma toEnum_alt_red[simp]:\n  \"toEnumAlt = (toEnum :: nat \\<Rightarrow> 'a :: enumeration_both)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toEnumAlt = toEnum", "by (rule ext) (simp add: enum_alt_rel alt_from_ord_def toEnum_def toEnumAlt_def)"], ["", "lemma upto_enum_red:\n  \"[(n :: ('a :: enumeration_both)) .e. m] = map toEnum [fromEnum n ..< Suc (fromEnum m)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n .e. m] = map toEnum [fromEnum n..<Suc (fromEnum m)]", "unfolding upto_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map toEnumAlt [fromEnumAlt n..<Suc (fromEnumAlt m)] =\n    map toEnum [fromEnum n..<Suc (fromEnum m)]", "by simp"], ["", "instantiation nat :: enumeration_alt\nbegin"], ["", "definition enum_alt_nat: \"enum_alt \\<equiv> Some\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, enumeration_alt_class)", "by (intro_classes; simp add: enum_alt_nat UNIV_option_conv)"], ["", "end"], ["", "lemma toEnumAlt_nat[simp]: \"toEnumAlt = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toEnumAlt = id", "by (rule ext) (simp add: toEnumAlt_def enum_alt_nat)"], ["", "lemma fromEnumAlt_nat[simp]: \"fromEnumAlt = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnumAlt = id", "by (rule ext) (simp add: fromEnumAlt_def enum_alt_nat)"], ["", "lemma upto_enum_nat[simp]: \"[n .e. m] = [n ..< Suc m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n .e. m] = [n..<Suc m]", "by (subst upto_enum_def) simp"], ["", "definition\n  zipE1 :: \"'a :: enum_alt \\<Rightarrow> 'b list \\<Rightarrow> ('a \\<times> 'b) list\"\nwhere\n  \"zipE1 x L \\<equiv> zip (map toEnumAlt [fromEnumAlt x ..< fromEnumAlt x + length L]) L\""], ["", "definition\n  zipE2 :: \"'a :: enum_alt \\<Rightarrow> 'a \\<Rightarrow> 'b list \\<Rightarrow> ('a \\<times> 'b) list\"\nwhere\n  \"zipE2 x xn L \\<equiv> zip (map (\\<lambda>n. toEnumAlt (fromEnumAlt x + (fromEnumAlt xn - fromEnumAlt x) * n))\n                      [0 ..< length L]) L\""], ["", "definition\n  zipE3 :: \"'a list \\<Rightarrow> 'b :: enum_alt \\<Rightarrow> ('a \\<times> 'b) list\"\nwhere\n  \"zipE3 L x \\<equiv> zip L (map toEnumAlt [fromEnumAlt x ..< fromEnumAlt x + length L])\""], ["", "definition\n  zipE4 :: \"'a list \\<Rightarrow> 'b :: enum_alt \\<Rightarrow> 'b \\<Rightarrow> ('a \\<times> 'b) list\"\nwhere\n  \"zipE4 L x xn \\<equiv> zip L (map (\\<lambda>n. toEnumAlt (fromEnumAlt x + (fromEnumAlt xn - fromEnumAlt x) * n))\n                         [0 ..< length L])\""], ["", "lemma to_from_enum_alt[simp]:\n  \"toEnumAlt (fromEnumAlt x) = (x :: 'a :: enumeration_alt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toEnumAlt (fromEnumAlt x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. toEnumAlt (fromEnumAlt x) = x", "have rl: \"\\<And>a b. a = Some b \\<Longrightarrow> the a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. a = Some b \\<Longrightarrow> the a = b", "by simp"], ["proof (state)\nthis:\n  ?a = Some ?b \\<Longrightarrow> the ?a = ?b\n\ngoal (1 subgoal):\n 1. toEnumAlt (fromEnumAlt x) = x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. toEnumAlt (fromEnumAlt x) = x", "unfolding fromEnumAlt_def toEnumAlt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. the (enum_alt (THE n. enum_alt n = Some x)) = x", "by (rule rl, rule theI') (metis enum_alt_inj enum_alt_surj_2 not_None_eq)"], ["proof (state)\nthis:\n  toEnumAlt (fromEnumAlt x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upto_enum_triv [simp]: \"[x .e. x] = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x .e. x] = [x]", "unfolding upto_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map toEnumAlt [fromEnumAlt x..<Suc (fromEnumAlt x)] = [x]", "by simp"], ["", "lemma toEnum_eq_to_fromEnum_eq:\n  fixes v :: \"'a :: enum\"\n  shows \"n \\<le> fromEnum (maxBound :: 'a) \\<Longrightarrow> (toEnum n = v) = (n = fromEnum v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> fromEnum maxBound \\<Longrightarrow>\n    (toEnum n = v) = (n = fromEnum v)", "by auto"], ["", "lemma le_imp_diff_le:\n  \"(j::nat) \\<le> k \\<Longrightarrow> j - n \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> k \\<Longrightarrow> j - n \\<le> k", "by simp"], ["", "lemma fromEnum_upto_nth:\n  fixes start :: \"'a :: enumeration_both\"\n  assumes \"n < length [start .e. end]\"\n  shows \"fromEnum ([start .e. end] ! n) = fromEnum start + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum ([start .e. end] ! n) = fromEnum start + n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fromEnum ([start .e. end] ! n) = fromEnum start + n", "have less_sub: \"\\<And>m k m' n. \\<lbrakk> (n::nat) < m - k ; m \\<le> m' \\<rbrakk> \\<Longrightarrow> n < m' - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k m' n.\n       \\<lbrakk>n < m - k; m \\<le> m'\\<rbrakk> \\<Longrightarrow> n < m' - k", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?n < ?m - ?k; ?m \\<le> ?m'\\<rbrakk>\n  \\<Longrightarrow> ?n < ?m' - ?k\n\ngoal (1 subgoal):\n 1. fromEnum ([start .e. end] ! n) = fromEnum start + n", "note upt_Suc[simp del]"], ["proof (state)\nthis:\n  [?i..<Suc ?j] = (if ?i \\<le> ?j then [?i..<?j] @ [?j] else [])\n\ngoal (1 subgoal):\n 1. fromEnum ([start .e. end] ! n) = fromEnum start + n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum ([start .e. end] ! n) = fromEnum start + n", "using assms"], ["proof (prove)\nusing this:\n  n < length [start .e. end]\n\ngoal (1 subgoal):\n 1. fromEnum ([start .e. end] ! n) = fromEnum start + n", "by (fastforce simp: upto_enum_red\n                dest: less_sub[where m'=\"Suc (fromEnum maxBound)\"] intro: maxBound_is_bound)"], ["proof (state)\nthis:\n  fromEnum ([start .e. end] ! n) = fromEnum start + n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_upto_enum_le_maxBound:\n  fixes start :: \"'a :: enumeration_both\"\n  shows \"length [start .e. end] \\<le> Suc (fromEnum (maxBound :: 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [start .e. end] \\<le> Suc (fromEnum maxBound)", "apply (clarsimp simp add: upto_enum_red split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum start \\<le> fromEnum end \\<Longrightarrow>\n    fromEnum end - fromEnum start \\<le> fromEnum maxBound", "apply (rule le_imp_diff_le[OF maxBound_is_bound[of \"end\"]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma less_length_upto_enum_maxBoundD:\n  fixes start :: \"'a :: enumeration_both\"\n  assumes \"n < length [start .e. end]\"\n  shows \"n \\<le> fromEnum (maxBound :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> fromEnum maxBound", "using assms"], ["proof (prove)\nusing this:\n  n < length [start .e. end]\n\ngoal (1 subgoal):\n 1. n \\<le> fromEnum maxBound", "by (simp add: upto_enum_red less_Suc_eq_le\n                le_trans[OF _ le_imp_diff_le[OF maxBound_is_bound[of \"end\"]]]\n           split: if_splits)"], ["", "lemma fromEnum_eq_iff:\n  \"(fromEnum e = fromEnum f) = (e = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fromEnum e = fromEnum f) = (e = f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fromEnum e = fromEnum f) = (e = f)", "have a: \"e \\<in> set enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set enum", "by auto"], ["proof (state)\nthis:\n  e \\<in> set enum\n\ngoal (1 subgoal):\n 1. (fromEnum e = fromEnum f) = (e = f)", "have b: \"f \\<in> set enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set enum", "by auto"], ["proof (state)\nthis:\n  f \\<in> set enum\n\ngoal (1 subgoal):\n 1. (fromEnum e = fromEnum f) = (e = f)", "from nth_the_index[OF a] nth_the_index[OF b]"], ["proof (chain)\npicking this:\n  enum ! the_index enum e = e\n  enum ! the_index enum f = f", "show ?thesis"], ["proof (prove)\nusing this:\n  enum ! the_index enum e = e\n  enum ! the_index enum f = f\n\ngoal (1 subgoal):\n 1. (fromEnum e = fromEnum f) = (e = f)", "unfolding fromEnum_def"], ["proof (prove)\nusing this:\n  enum ! the_index enum e = e\n  enum ! the_index enum f = f\n\ngoal (1 subgoal):\n 1. (the_index enum e = the_index enum f) = (e = f)", "by metis"], ["proof (state)\nthis:\n  (fromEnum e = fromEnum f) = (e = f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxBound_is_bound':\n  \"i = fromEnum (e::('a::enum)) \\<Longrightarrow> i \\<le> fromEnum (maxBound::('a::enum))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = fromEnum e \\<Longrightarrow> i \\<le> fromEnum maxBound", "by clarsimp"], ["", "end"]]}