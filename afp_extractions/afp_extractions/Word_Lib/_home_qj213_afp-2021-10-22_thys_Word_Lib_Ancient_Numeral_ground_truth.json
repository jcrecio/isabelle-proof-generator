{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Ancient_Numeral.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma Bit_B0: \"k BIT False = k + k\"", "lemma Bit_B1: \"k BIT True = k + k + 1\"", "lemma Bit_B0_2t: \"k BIT False = 2 * k\"", "lemma Bit_B1_2t: \"k BIT True = 2 * k + 1\"", "lemma uminus_Bit_eq:\n  \"- k BIT b = (- k - of_bool b) BIT b\"", "lemma power_BIT: \"2 ^ Suc n - 1 = (2 ^ n - 1) BIT True\"", "lemma bin_rl_simp [simp]: \"bin_rest w BIT bin_last w = w\"", "lemma bin_rest_BIT [simp]: \"bin_rest (x BIT b) = x\"", "lemma even_BIT [simp]: \"even (x BIT b) \\<longleftrightarrow> \\<not> b\"", "lemma bin_last_BIT [simp]: \"bin_last (x BIT b) = b\"", "lemma BIT_eq_iff [iff]: \"u BIT b = v BIT c \\<longleftrightarrow> u = v \\<and> b = c\"", "lemma BIT_bin_simps [simp]:\n  \"numeral k BIT False = numeral (Num.Bit0 k)\"\n  \"numeral k BIT True = numeral (Num.Bit1 k)\"\n  \"(- numeral k) BIT False = - numeral (Num.Bit0 k)\"\n  \"(- numeral k) BIT True = - numeral (Num.BitM k)\"", "lemma BIT_special_simps [simp]:\n  shows \"0 BIT False = 0\"\n    and \"0 BIT True = 1\"\n    and \"1 BIT False = 2\"\n    and \"1 BIT True = 3\"\n    and \"(- 1) BIT False = - 2\"\n    and \"(- 1) BIT True = - 1\"", "lemma Bit_eq_0_iff: \"w BIT b = 0 \\<longleftrightarrow> w = 0 \\<and> \\<not> b\"", "lemma Bit_eq_m1_iff: \"w BIT b = -1 \\<longleftrightarrow> w = -1 \\<and> b\"", "lemma expand_BIT:\n  \"numeral (Num.Bit0 w) = numeral w BIT False\"\n  \"numeral (Num.Bit1 w) = numeral w BIT True\"\n  \"- numeral (Num.Bit0 w) = (- numeral w) BIT False\"\n  \"- numeral (Num.Bit1 w) = (- numeral (w + Num.One)) BIT True\"", "lemma less_Bits: \"v BIT b < w BIT c \\<longleftrightarrow> v < w \\<or> v \\<le> w \\<and> \\<not> b \\<and> c\"", "lemma le_Bits: \"v BIT b \\<le> w BIT c \\<longleftrightarrow> v < w \\<or> v \\<le> w \\<and> (\\<not> b \\<or> c)\"", "lemma pred_BIT_simps [simp]:\n  \"x BIT False - 1 = (x - 1) BIT True\"\n  \"x BIT True - 1 = x BIT False\"", "lemma succ_BIT_simps [simp]:\n  \"x BIT False + 1 = x BIT True\"\n  \"x BIT True + 1 = (x + 1) BIT False\"", "lemma add_BIT_simps [simp]:\n  \"x BIT False + y BIT False = (x + y) BIT False\"\n  \"x BIT False + y BIT True = (x + y) BIT True\"\n  \"x BIT True + y BIT False = (x + y) BIT True\"\n  \"x BIT True + y BIT True = (x + y + 1) BIT False\"", "lemma mult_BIT_simps [simp]:\n  \"x BIT False * y = (x * y) BIT False\"\n  \"x * y BIT False = (x * y) BIT False\"\n  \"x BIT True * y = (x * y) BIT False + y\"", "lemma B_mod_2': \"X = 2 \\<Longrightarrow> (w BIT True) mod X = 1 \\<and> (w BIT False) mod X = 0\"", "lemma bin_ex_rl: \"\\<exists>w b. w BIT b = bin\"", "lemma bin_exhaust: \"(\\<And>x b. bin = x BIT b \\<Longrightarrow> Q) \\<Longrightarrow> Q\"", "lemma bin_abs_lem: \"bin = (w BIT b) \\<Longrightarrow> bin \\<noteq> -1 \\<longrightarrow> bin \\<noteq> 0 \\<longrightarrow> nat \\<bar>w\\<bar> < nat \\<bar>bin\\<bar>\"", "lemma bin_induct:\n  assumes PPls: \"P 0\"\n    and PMin: \"P (- 1)\"\n    and PBit: \"\\<And>bin bit. P bin \\<Longrightarrow> P (bin BIT bit)\"\n  shows \"P bin\"", "lemma Bit_div2: \"(w BIT b) div 2 = w\"", "lemma twice_conv_BIT: \"2 * x = x BIT False\"", "lemma BIT_lt0 [simp]: \"x BIT b < 0 \\<longleftrightarrow> x < 0\"", "lemma BIT_ge0 [simp]: \"x BIT b \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0\"", "lemma bin_to_bl_aux_Bit_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n (w BIT b) bl = bin_to_bl_aux (n - 1) w (b # bl)\"", "lemma bl_to_bin_BIT:\n  \"bl_to_bin bs BIT b = bl_to_bin (bs @ [b])\"", "lemma bin_nth_0_BIT: \"bin_nth (w BIT b) 0 \\<longleftrightarrow> b\"", "lemma bin_nth_Suc_BIT: \"bin_nth (w BIT b) (Suc n) = bin_nth w n\"", "lemma bin_nth_minus [simp]: \"0 < n \\<Longrightarrow> bin_nth (w BIT b) n = bin_nth w (n - 1)\"", "lemma bin_sign_simps [simp]:\n  \"bin_sign (w BIT b) = bin_sign w\"", "lemma bin_nth_Bit: \"bin_nth (w BIT b) n \\<longleftrightarrow> n = 0 \\<and> b \\<or> (\\<exists>m. n = Suc m \\<and> bin_nth w m)\"", "lemmas sbintrunc_Suc_BIT [simp] =\n  signed_take_bit_Suc [where a=\"w BIT b\", simplified bin_last_BIT bin_rest_BIT] for w b", "lemmas sbintrunc_0_BIT_B0 [simp] =\n  signed_take_bit_0 [where a=\"w BIT False\", simplified bin_last_numeral_simps bin_rest_numeral_simps]\n  for w", "lemmas sbintrunc_0_BIT_B1 [simp] =\n  signed_take_bit_0 [where a=\"w BIT True\", simplified bin_last_BIT bin_rest_numeral_simps]\n  for w", "lemma sbintrunc_Suc_minus_Is:\n  \\<open>0 < n \\<Longrightarrow>\n  sbintrunc (n - 1) w = y \\<Longrightarrow>\n  sbintrunc n (w BIT b) = y BIT b\\<close>", "lemma bin_cat_Suc_Bit: \"bin_cat w (Suc n) (v BIT b) = bin_cat w n v BIT b\"", "lemma int_not_BIT [simp]: \"NOT (w BIT b) = (NOT w) BIT (\\<not> b)\"", "lemma int_and_Bits [simp]: \"(x BIT b) AND (y BIT c) = (x AND y) BIT (b \\<and> c)\"", "lemma int_or_Bits [simp]: \"(x BIT b) OR (y BIT c) = (x OR y) BIT (b \\<or> c)\"", "lemma int_xor_Bits [simp]: \"(x BIT b) XOR (y BIT c) = (x XOR y) BIT ((b \\<or> c) \\<and> \\<not> (b \\<and> c))\"", "lemma mod_BIT:\n  \"bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit\" for bit", "lemma minus_BIT_0: fixes x y :: int shows \"x BIT b - y BIT False = (x - y) BIT b\"", "lemma int_lsb_BIT [simp]: fixes x :: int shows\n  \"lsb (x BIT b) \\<longleftrightarrow> b\"", "lemma int_shiftr_BIT [simp]: fixes x :: int\n  shows int_shiftr0: \"x >> 0 = x\"\n  and int_shiftr_Suc: \"x BIT b >> Suc n = x >> n\"", "lemma msb_BIT [simp]: \"msb (x BIT b) = msb x\""], "translations": [["", "lemma Bit_B0: \"k BIT False = k + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k BIT False = k + k", "by (simp add: Bit_def)"], ["", "lemma Bit_B1: \"k BIT True = k + k + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k BIT True = k + k + 1", "by (simp add: Bit_def)"], ["", "lemma Bit_B0_2t: \"k BIT False = 2 * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k BIT False = 2 * k", "by (rule trans, rule Bit_B0) simp"], ["", "lemma Bit_B1_2t: \"k BIT True = 2 * k + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k BIT True = 2 * k + 1", "by (rule trans, rule Bit_B1) simp"], ["", "lemma uminus_Bit_eq:\n  \"- k BIT b = (- k - of_bool b) BIT b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - k BIT b = (- k - of_bool b) BIT b", "by (cases b) (simp_all add: Bit_def)"], ["", "lemma power_BIT: \"2 ^ Suc n - 1 = (2 ^ n - 1) BIT True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ Suc n - 1 = (2 ^ n - 1) BIT True", "by (simp add: Bit_B1)"], ["", "lemma bin_rl_simp [simp]: \"bin_rest w BIT bin_last w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w div 2) BIT odd w = w", "by (simp add: Bit_def)"], ["", "lemma bin_rest_BIT [simp]: \"bin_rest (x BIT b) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT b div 2 = x", "by (simp add: Bit_def)"], ["", "lemma even_BIT [simp]: \"even (x BIT b) \\<longleftrightarrow> \\<not> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (x BIT b) = (\\<not> b)", "by (simp add: Bit_def)"], ["", "lemma bin_last_BIT [simp]: \"bin_last (x BIT b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (x BIT b) = b", "by simp"], ["", "lemma BIT_eq_iff [iff]: \"u BIT b = v BIT c \\<longleftrightarrow> u = v \\<and> b = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u BIT b = v BIT c) = (u = v \\<and> b = c)", "by (auto simp: Bit_def) arith+"], ["", "lemma BIT_bin_simps [simp]:\n  \"numeral k BIT False = numeral (Num.Bit0 k)\"\n  \"numeral k BIT True = numeral (Num.Bit1 k)\"\n  \"(- numeral k) BIT False = - numeral (Num.Bit0 k)\"\n  \"(- numeral k) BIT True = - numeral (Num.BitM k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (numeral k BIT False = numeral (num.Bit0 k) &&&\n     numeral k BIT True = numeral (num.Bit1 k)) &&&\n    (- numeral k) BIT False = - numeral (num.Bit0 k) &&&\n    (- numeral k) BIT True = - numeral (Num.BitM k)", "by (simp_all only: Bit_B0 Bit_B1 numeral.simps numeral_BitM)"], ["", "lemma BIT_special_simps [simp]:\n  shows \"0 BIT False = 0\"\n    and \"0 BIT True = 1\"\n    and \"1 BIT False = 2\"\n    and \"1 BIT True = 3\"\n    and \"(- 1) BIT False = - 2\"\n    and \"(- 1) BIT True = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 BIT False = 0 &&& 0 BIT True = 1 &&& 1 BIT False = 2) &&&\n    1 BIT True = 3 &&& (- 1) BIT False = - 2 &&& (- 1) BIT True = - 1", "by (simp_all add: Bit_def)"], ["", "lemma Bit_eq_0_iff: \"w BIT b = 0 \\<longleftrightarrow> w = 0 \\<and> \\<not> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w BIT b = 0) = (w = 0 \\<and> \\<not> b)", "by (auto simp: Bit_def) arith"], ["", "lemma Bit_eq_m1_iff: \"w BIT b = -1 \\<longleftrightarrow> w = -1 \\<and> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w BIT b = - 1) = (w = - 1 \\<and> b)", "by (auto simp: Bit_def) arith"], ["", "lemma expand_BIT:\n  \"numeral (Num.Bit0 w) = numeral w BIT False\"\n  \"numeral (Num.Bit1 w) = numeral w BIT True\"\n  \"- numeral (Num.Bit0 w) = (- numeral w) BIT False\"\n  \"- numeral (Num.Bit1 w) = (- numeral (w + Num.One)) BIT True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (numeral (num.Bit0 w) = numeral w BIT False &&&\n     numeral (num.Bit1 w) = numeral w BIT True) &&&\n    - numeral (num.Bit0 w) = (- numeral w) BIT False &&&\n    - numeral (num.Bit1 w) = (- numeral (w + num.One)) BIT True", "by (simp_all add: BitM_inc_eq add_One)"], ["", "lemma less_Bits: \"v BIT b < w BIT c \\<longleftrightarrow> v < w \\<or> v \\<le> w \\<and> \\<not> b \\<and> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v BIT b < w BIT c) = (v < w \\<or> v \\<le> w \\<and> \\<not> b \\<and> c)", "by (auto simp: Bit_def)"], ["", "lemma le_Bits: \"v BIT b \\<le> w BIT c \\<longleftrightarrow> v < w \\<or> v \\<le> w \\<and> (\\<not> b \\<or> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v BIT b \\<le> w BIT c) =\n    (v < w \\<or> v \\<le> w \\<and> (\\<not> b \\<or> c))", "by (auto simp: Bit_def)"], ["", "lemma pred_BIT_simps [simp]:\n  \"x BIT False - 1 = (x - 1) BIT True\"\n  \"x BIT True - 1 = x BIT False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT False - 1 = (x - 1) BIT True &&& x BIT True - 1 = x BIT False", "by (simp_all add: Bit_B0_2t Bit_B1_2t)"], ["", "lemma succ_BIT_simps [simp]:\n  \"x BIT False + 1 = x BIT True\"\n  \"x BIT True + 1 = (x + 1) BIT False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT False + 1 = x BIT True &&& x BIT True + 1 = (x + 1) BIT False", "by (simp_all add: Bit_B0_2t Bit_B1_2t)"], ["", "lemma add_BIT_simps [simp]:\n  \"x BIT False + y BIT False = (x + y) BIT False\"\n  \"x BIT False + y BIT True = (x + y) BIT True\"\n  \"x BIT True + y BIT False = (x + y) BIT True\"\n  \"x BIT True + y BIT True = (x + y + 1) BIT False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x BIT False + y BIT False = (x + y) BIT False &&&\n     x BIT False + y BIT True = (x + y) BIT True) &&&\n    x BIT True + y BIT False = (x + y) BIT True &&&\n    x BIT True + y BIT True = (x + y + 1) BIT False", "by (simp_all add: Bit_B0_2t Bit_B1_2t)"], ["", "lemma mult_BIT_simps [simp]:\n  \"x BIT False * y = (x * y) BIT False\"\n  \"x * y BIT False = (x * y) BIT False\"\n  \"x BIT True * y = (x * y) BIT False + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT False * y = (x * y) BIT False &&&\n    x * y BIT False = (x * y) BIT False &&&\n    x BIT True * y = (x * y) BIT False + y", "by (simp_all add: Bit_B0_2t Bit_B1_2t algebra_simps)"], ["", "lemma B_mod_2': \"X = 2 \\<Longrightarrow> (w BIT True) mod X = 1 \\<and> (w BIT False) mod X = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = 2 \\<Longrightarrow>\n    w BIT True mod X = 1 \\<and> w BIT False mod X = 0", "by (simp add: Bit_B0 Bit_B1)"], ["", "lemma bin_ex_rl: \"\\<exists>w b. w BIT b = bin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w b. w BIT b = bin", "by (metis bin_rl_simp)"], ["", "lemma bin_exhaust: \"(\\<And>x b. bin = x BIT b \\<Longrightarrow> Q) \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x b. bin = x BIT b \\<Longrightarrow> Q) \\<Longrightarrow> Q", "by (metis bin_ex_rl)"], ["", "lemma bin_abs_lem: \"bin = (w BIT b) \\<Longrightarrow> bin \\<noteq> -1 \\<longrightarrow> bin \\<noteq> 0 \\<longrightarrow> nat \\<bar>w\\<bar> < nat \\<bar>bin\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin = w BIT b \\<Longrightarrow>\n    bin \\<noteq> - 1 \\<longrightarrow>\n    bin \\<noteq> 0 \\<longrightarrow> nat \\<bar>w\\<bar> < nat \\<bar>bin\\<bar>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bin = w BIT b; w BIT b \\<noteq> - 1;\n     w BIT b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>w\\<bar> < \\<bar>w BIT b\\<bar>", "apply (unfold Bit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bin = (if b then 1 else 0) + w + w;\n     (if b then 1 else 0) + w + w \\<noteq> - 1;\n     (if b then 1 else 0) + w + w \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>w\\<bar>\n                      < \\<bar>(if b then 1 else 0) + w + w\\<bar>", "apply (cases b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bin = (if b then 1 else 0) + w + w;\n     (if b then 1 else 0) + w + w \\<noteq> - 1;\n     (if b then 1 else 0) + w + w \\<noteq> 0; b\\<rbrakk>\n    \\<Longrightarrow> \\<bar>w\\<bar>\n                      < \\<bar>(if b then 1 else 0) + w + w\\<bar>\n 2. \\<lbrakk>bin = (if b then 1 else 0) + w + w;\n     (if b then 1 else 0) + w + w \\<noteq> - 1;\n     (if b then 1 else 0) + w + w \\<noteq> 0; \\<not> b\\<rbrakk>\n    \\<Longrightarrow> \\<bar>w\\<bar>\n                      < \\<bar>(if b then 1 else 0) + w + w\\<bar>", "apply (clarsimp, arith)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bin = (if b then 1 else 0) + w + w;\n     (if b then 1 else 0) + w + w \\<noteq> - 1;\n     (if b then 1 else 0) + w + w \\<noteq> 0; \\<not> b\\<rbrakk>\n    \\<Longrightarrow> \\<bar>w\\<bar>\n                      < \\<bar>(if b then 1 else 0) + w + w\\<bar>", "apply (clarsimp, arith)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_induct:\n  assumes PPls: \"P 0\"\n    and PMin: \"P (- 1)\"\n    and PBit: \"\\<And>bin bit. P bin \\<Longrightarrow> P (bin BIT bit)\"\n  shows \"P bin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P bin", "apply (rule_tac P=P and a=bin and f1=\"nat \\<circ> abs\" in wf_measure [THEN wf_induct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure (nat \\<circ> abs) \\<longrightarrow>\n          P y \\<Longrightarrow>\n       P x", "apply (simp add: measure_def inv_image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          x \\<noteq> 0 \\<and>\n          \\<bar>y\\<bar> < \\<bar>x\\<bar> \\<longrightarrow>\n          P y \\<Longrightarrow>\n       P x", "apply (case_tac x rule: bin_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa b.\n       \\<lbrakk>\\<forall>y.\n                   x \\<noteq> 0 \\<and>\n                   \\<bar>y\\<bar> < \\<bar>x\\<bar> \\<longrightarrow>\n                   P y;\n        x = xa BIT b\\<rbrakk>\n       \\<Longrightarrow> P x", "apply (frule bin_abs_lem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa b.\n       \\<lbrakk>\\<forall>y.\n                   x \\<noteq> 0 \\<and>\n                   \\<bar>y\\<bar> < \\<bar>x\\<bar> \\<longrightarrow>\n                   P y;\n        x = xa BIT b;\n        x \\<noteq> - 1 \\<longrightarrow>\n        x \\<noteq> 0 \\<longrightarrow>\n        nat \\<bar>xa\\<bar> < nat \\<bar>x\\<bar>\\<rbrakk>\n       \\<Longrightarrow> P x", "apply (auto simp add : PPls PMin PBit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Bit_div2: \"(w BIT b) div 2 = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w BIT b div 2 = w", "by (fact bin_rest_BIT)"], ["", "lemma twice_conv_BIT: \"2 * x = x BIT False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * x = x BIT False", "by (simp add: Bit_def)"], ["", "lemma BIT_lt0 [simp]: \"x BIT b < 0 \\<longleftrightarrow> x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x BIT b < 0) = (x < 0)", "by(cases b)(auto simp add: Bit_def)"], ["", "lemma BIT_ge0 [simp]: \"x BIT b \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> x BIT b) = (0 \\<le> x)", "by(cases b)(auto simp add: Bit_def)"], ["", "lemma bin_to_bl_aux_Bit_minus_simp [simp]:\n  \"0 < n \\<Longrightarrow> bin_to_bl_aux n (w BIT b) bl = bin_to_bl_aux (n - 1) w (b # bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bin_to_bl_aux n (w BIT b) bl = bin_to_bl_aux (n - 1) w (b # bl)", "by (cases n) auto"], ["", "lemma bl_to_bin_BIT:\n  \"bl_to_bin bs BIT b = bl_to_bin (bs @ [b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_to_bin bs BIT b = bl_to_bin (bs @ [b])", "by (simp add: bl_to_bin_append Bit_def)"], ["", "lemma bin_nth_0_BIT: \"bin_nth (w BIT b) 0 \\<longleftrightarrow> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (w BIT b) 0 = b", "by simp"], ["", "lemma bin_nth_Suc_BIT: \"bin_nth (w BIT b) (Suc n) = bin_nth w n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (w BIT b) (Suc n) = bit w n", "by (simp add: bit_Suc)"], ["", "lemma bin_nth_minus [simp]: \"0 < n \\<Longrightarrow> bin_nth (w BIT b) n = bin_nth w (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> bit (w BIT b) n = bit w (n - 1)", "by (cases n) (simp_all add: bit_Suc)"], ["", "lemma bin_sign_simps [simp]:\n  \"bin_sign (w BIT b) = bin_sign w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (w BIT b) = bin_sign w", "by (simp add: bin_sign_def Bit_def)"], ["", "lemma bin_nth_Bit: \"bin_nth (w BIT b) n \\<longleftrightarrow> n = 0 \\<and> b \\<or> (\\<exists>m. n = Suc m \\<and> bin_nth w m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (w BIT b) n =\n    (n = 0 \\<and> b \\<or> (\\<exists>m. n = Suc m \\<and> bit w m))", "by (cases n) auto"], ["", "lemmas sbintrunc_Suc_BIT [simp] =\n  signed_take_bit_Suc [where a=\"w BIT b\", simplified bin_last_BIT bin_rest_BIT] for w b"], ["", "lemmas sbintrunc_0_BIT_B0 [simp] =\n  signed_take_bit_0 [where a=\"w BIT False\", simplified bin_last_numeral_simps bin_rest_numeral_simps]\n  for w"], ["", "lemmas sbintrunc_0_BIT_B1 [simp] =\n  signed_take_bit_0 [where a=\"w BIT True\", simplified bin_last_BIT bin_rest_numeral_simps]\n  for w"], ["", "lemma sbintrunc_Suc_minus_Is:\n  \\<open>0 < n \\<Longrightarrow>\n  sbintrunc (n - 1) w = y \\<Longrightarrow>\n  sbintrunc n (w BIT b) = y BIT b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; signed_take_bit (n - 1) w = y\\<rbrakk>\n    \\<Longrightarrow> signed_take_bit n (w BIT b) = y BIT b", "by (cases n) (simp_all add: Bit_def signed_take_bit_Suc)"], ["", "lemma bin_cat_Suc_Bit: \"bin_cat w (Suc n) (v BIT b) = bin_cat w n v BIT b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit (Suc n) (v BIT b) w = concat_bit n v w BIT b", "by (auto simp add: Bit_def concat_bit_Suc)"], ["", "lemma int_not_BIT [simp]: \"NOT (w BIT b) = (NOT w) BIT (\\<not> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (w BIT b) = NOT w BIT (\\<not> b)", "by (simp add: not_int_def Bit_def)"], ["", "lemma int_and_Bits [simp]: \"(x BIT b) AND (y BIT c) = (x AND y) BIT (b \\<and> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT b AND y BIT c = (x AND y) BIT (b \\<and> c)", "using and_int_rec [of \\<open>x BIT b\\<close> \\<open>y BIT c\\<close>]"], ["proof (prove)\nusing this:\n  x BIT b AND y BIT c =\n  of_bool (odd (x BIT b) \\<and> odd (y BIT c)) +\n  2 * (x BIT b div 2 AND y BIT c div 2)\n\ngoal (1 subgoal):\n 1. x BIT b AND y BIT c = (x AND y) BIT (b \\<and> c)", "by (auto simp add: Bit_B0_2t Bit_B1_2t)"], ["", "lemma int_or_Bits [simp]: \"(x BIT b) OR (y BIT c) = (x OR y) BIT (b \\<or> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT b OR y BIT c = (x OR y) BIT (b \\<or> c)", "using or_int_rec [of \\<open>x BIT b\\<close> \\<open>y BIT c\\<close>]"], ["proof (prove)\nusing this:\n  x BIT b OR y BIT c =\n  of_bool (odd (x BIT b) \\<or> odd (y BIT c)) +\n  2 * (x BIT b div 2 OR y BIT c div 2)\n\ngoal (1 subgoal):\n 1. x BIT b OR y BIT c = (x OR y) BIT (b \\<or> c)", "by (auto simp add: Bit_B0_2t Bit_B1_2t)"], ["", "lemma int_xor_Bits [simp]: \"(x BIT b) XOR (y BIT c) = (x XOR y) BIT ((b \\<or> c) \\<and> \\<not> (b \\<and> c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT b XOR y BIT c =\n    (x XOR y) BIT ((b \\<or> c) \\<and> \\<not> (b \\<and> c))", "using xor_int_rec [of \\<open>x BIT b\\<close> \\<open>y BIT c\\<close>]"], ["proof (prove)\nusing this:\n  x BIT b XOR y BIT c =\n  of_bool (odd (x BIT b) \\<noteq> odd (y BIT c)) +\n  2 * (x BIT b div 2 XOR y BIT c div 2)\n\ngoal (1 subgoal):\n 1. x BIT b XOR y BIT c =\n    (x XOR y) BIT ((b \\<or> c) \\<and> \\<not> (b \\<and> c))", "by (auto simp add: Bit_B0_2t Bit_B1_2t)"], ["", "lemma mod_BIT:\n  \"bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit\" for bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "have \"2 * (bin mod 2 ^ n) + 1 = (2 * bin mod 2 ^ Suc n) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (bin mod 2 ^ n) + 1 = 2 * bin mod 2 ^ Suc n + 1", "by (simp add: mod_mult_mult1)"], ["proof (state)\nthis:\n  2 * (bin mod 2 ^ n) + 1 = 2 * bin mod 2 ^ Suc n + 1\n\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "also"], ["proof (state)\nthis:\n  2 * (bin mod 2 ^ n) + 1 = 2 * bin mod 2 ^ Suc n + 1\n\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "have \"\\<dots> = ((2 * bin mod 2 ^ Suc n) + 1) mod 2 ^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * bin mod 2 ^ Suc n + 1 = (2 * bin mod 2 ^ Suc n + 1) mod 2 ^ Suc n", "by (simp add: ac_simps pos_zmod_mult_2)"], ["proof (state)\nthis:\n  2 * bin mod 2 ^ Suc n + 1 = (2 * bin mod 2 ^ Suc n + 1) mod 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "also"], ["proof (state)\nthis:\n  2 * bin mod 2 ^ Suc n + 1 = (2 * bin mod 2 ^ Suc n + 1) mod 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "have \"\\<dots> = (2 * bin + 1) mod 2 ^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * bin mod 2 ^ Suc n + 1) mod 2 ^ Suc n = (2 * bin + 1) mod 2 ^ Suc n", "by (simp only: mod_simps)"], ["proof (state)\nthis:\n  (2 * bin mod 2 ^ Suc n + 1) mod 2 ^ Suc n = (2 * bin + 1) mod 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "finally"], ["proof (chain)\npicking this:\n  2 * (bin mod 2 ^ n) + 1 = (2 * bin + 1) mod 2 ^ Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * (bin mod 2 ^ n) + 1 = (2 * bin + 1) mod 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit", "by (auto simp add: Bit_def)"], ["proof (state)\nthis:\n  bin BIT bit mod 2 ^ Suc n = (bin mod 2 ^ n) BIT bit\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_BIT_0: fixes x y :: int shows \"x BIT b - y BIT False = (x - y) BIT b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT b - y BIT False = (x - y) BIT b", "by(simp add: Bit_def)"], ["", "lemma int_lsb_BIT [simp]: fixes x :: int shows\n  \"lsb (x BIT b) \\<longleftrightarrow> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb (x BIT b) = b", "by(simp add: lsb_int_def)"], ["", "lemma int_shiftr_BIT [simp]: fixes x :: int\n  shows int_shiftr0: \"x >> 0 = x\"\n  and int_shiftr_Suc: \"x BIT b >> Suc n = x >> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> 0 = x &&& x BIT b >> Suc n = x >> n", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. x >> 0 = x\n 2. x BIT b >> Suc n = x >> n", "show \"x >> 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> 0 = x", "by (simp add: shiftr_int_def)"], ["proof (state)\nthis:\n  x >> 0 = x\n\ngoal (1 subgoal):\n 1. x BIT b >> Suc n = x >> n", "show \"x BIT b >> Suc n = x >> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x BIT b >> Suc n = x >> n", "by (cases b)\n   (simp_all add: shiftr_int_def Bit_def add.commute pos_zdiv_mult_2)"], ["proof (state)\nthis:\n  x BIT b >> Suc n = x >> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma msb_BIT [simp]: \"msb (x BIT b) = msb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb (x BIT b) = msb x", "by(simp add: msb_int_def)"], ["", "end"]]}