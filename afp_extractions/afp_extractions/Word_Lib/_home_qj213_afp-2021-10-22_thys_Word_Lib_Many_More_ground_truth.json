{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Many_More.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma nat_less_mult_monoish: \"\\<lbrakk> a < b; c < (d :: nat) \\<rbrakk> \\<Longrightarrow> (a + 1) * (c + 1) <= b * d\"", "lemma if_and_helper:\n  \"(If x v v') AND v'' = If x (v AND v'') (v' AND v'')\"", "lemma eq_eqI:\n  \"a = b \\<Longrightarrow> (a = x) = (b = x)\"", "lemma map2_Cons_2_3:\n  \"(map2 f xs (y # ys) = (z # zs)) = (\\<exists>x xs'. xs = x # xs' \\<and> f x y = z \\<and> map2 f xs' ys = zs)\"", "lemma map2_xor_replicate_False:\n  \"map2 (\\<lambda>x y. x \\<longleftrightarrow> \\<not> y) xs (replicate n False) = take n xs\"", "lemma plus_Collect_helper:\n  \"(+) x ` {xa. P (xa :: 'a :: len word)} = {xa. P (xa - x)}\"", "lemma plus_Collect_helper2:\n  \"(+) (- x) ` {xa. P (xa :: 'a :: len word)} = {xa. P (x + xa)}\"", "lemma range_subset_eq2:\n  \"{a :: 'a :: len word .. b} \\<noteq> {} \\<Longrightarrow> ({a .. b} \\<subseteq> {c .. d}) = (c \\<le> a \\<and> b \\<le> d)\"", "lemma nat_mod_power_lem:\n  fixes a :: nat\n  shows \"1 < a \\<Longrightarrow> a ^ n mod a ^ m = (if m \\<le> n then 0 else a ^ n)\"", "lemma i_hate_words_helper:\n  \"i \\<le> (j - k :: nat) \\<Longrightarrow> i \\<le> j\"", "lemma i_hate_words:\n  \"unat (a :: 'a word) \\<le> unat (b :: 'a :: len word) - Suc 0\n    \\<Longrightarrow> a \\<noteq> -1\"", "lemma If_eq_obvious:\n  \"x \\<noteq> z \\<Longrightarrow> ((if P then x else y) = z) = (\\<not> P \\<and> y = z)\"", "lemma Some_to_the:\n  \"v = Some x \\<Longrightarrow> x = the v\"", "lemma dom_if_Some:\n  \"dom (\\<lambda>x. if P x then Some (f x) else g x) = {x. P x} \\<union> dom g\"", "lemma dom_insert_absorb:\n  \"x \\<in> dom f \\<Longrightarrow> insert x (dom f) = dom f\"", "lemma emptyE2:\n  \"\\<lbrakk> S = {}; x \\<in> S \\<rbrakk> \\<Longrightarrow> P\"", "lemma ptr_add_image_multI:\n  \"\\<lbrakk> \\<And>x y. (x * val = y * val') = (x * val'' = y); x * val'' \\<in> S \\<rbrakk> \\<Longrightarrow>\n     ptr_add ptr (x * val) \\<in> (\\<lambda>p. ptr_add ptr (p * val')) ` S\"", "lemmas map_prod_split_imageI'\n  = map_prod_imageI[where f=\"case_prod f\" and g=\"case_prod g\"\n                    and a=\"(a, b)\" and b=\"(c, d)\" for a b c d f g]", "lemmas map_prod_split_imageI = map_prod_split_imageI'[simplified]", "lemma dom_if:\n  \"dom (\\<lambda>a. if a \\<in> addrs then Some (f a) else g a)  = addrs \\<union> dom g\"", "lemmas arg_cong_Not = arg_cong [where f=Not]", "lemma drop_append_miracle:\n  \"n = length xs \\<Longrightarrow> drop n (xs @ ys) = ys\"", "lemma foldr_does_nothing_to_xf:\n  \"\\<lbrakk> \\<And>x s. x \\<in> set xs \\<Longrightarrow> xf (f x s) = xf s \\<rbrakk> \\<Longrightarrow> xf (foldr f xs s) = xf s\"", "lemma mod_mod_power_int:\n  fixes k :: int\n  shows \"k mod 2 ^ m mod 2 ^ n = k mod 2 ^ (min m n)\"", "lemma le_step_down_nat:\"\\<lbrakk>(i::nat) \\<le> n; i = n \\<longrightarrow> P; i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma le_step_down_int:\"\\<lbrakk>(i::int) \\<le> n; i = n \\<longrightarrow> P; i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma replicate_numeral [simp]: \"replicate (numeral k) x = x # replicate (pred_numeral k) x\"", "lemma list_exhaust_size_gt0:\n  assumes \"\\<And>a list. y = a # list \\<Longrightarrow> P\"\n  shows \"0 < length y \\<Longrightarrow> P\"", "lemma list_exhaust_size_eq0:\n  assumes \"y = [] \\<Longrightarrow> P\"\n  shows \"length y = 0 \\<Longrightarrow> P\"", "lemma size_Cons_lem_eq: \"y = xa # list \\<Longrightarrow> size y = Suc k \\<Longrightarrow> size list = k\"", "lemma takeWhile_take_has_property:\n  \"n \\<le> length (takeWhile P xs) \\<Longrightarrow> \\<forall>x \\<in> set (take n xs). P x\"", "lemma takeWhile_take_has_property_nth:\n  \"\\<lbrakk> n < length (takeWhile P xs) \\<rbrakk> \\<Longrightarrow> P (xs ! n)\"", "lemma takeWhile_replicate:\n  \"takeWhile f (replicate len x) = (if f x then replicate len x else [])\"", "lemma takeWhile_replicate_empty:\n  \"\\<not> f x \\<Longrightarrow> takeWhile f (replicate len x) = []\"", "lemma takeWhile_replicate_id:\n  \"f x \\<Longrightarrow> takeWhile f (replicate len x) = replicate len x\"", "lemma nth_rev: \"n < length xs \\<Longrightarrow> rev xs ! n = xs ! (length xs - 1 - n)\"", "lemma nth_rev_alt: \"n < length ys \\<Longrightarrow> ys ! n = rev ys ! (length ys - Suc n)\"", "lemma hd_butlast: \"length xs > 1 \\<Longrightarrow> hd (butlast xs) = hd xs\"", "lemma split_upt_on_n:\n  \"n < m \\<Longrightarrow> [0 ..< m] = [0 ..< n] @ [n] @ [Suc n ..< m]\"", "lemma drop_eq_mono:\n  assumes le: \"m \\<le> n\"\n  assumes drop: \"drop m xs = drop m ys\"\n  shows \"drop n xs = drop n ys\"", "lemma drop_Suc_nth:\n  \"n < length xs \\<Longrightarrow> drop n xs = xs!n # drop (Suc n) xs\"", "lemma and_len: \"xs = ys \\<Longrightarrow> xs = ys \\<and> length xs = length ys\"", "lemma tl_if: \"tl (if p then xs else ys) = (if p then tl xs else tl ys)\"", "lemma hd_if: \"hd (if p then xs else ys) = (if p then hd xs else hd ys)\"", "lemma if_single: \"(if xc then [xab] else [an]) = [if xc then xab else an]\"", "lemma if_Cons: \"(if p then x # xs else y # ys) = If p x y # If p xs ys\"", "lemma list_of_false:\n  \"True \\<notin> set xs \\<Longrightarrow> xs = replicate (length xs) False\"", "lemma list_all2_induct [consumes 1, case_names Nil Cons]:\n  assumes lall: \"list_all2 Q xs ys\"\n  and     nilr: \"P [] []\"\n  and    consr: \"\\<And>x xs y ys. \\<lbrakk>list_all2 Q xs ys; Q x y; P xs ys\\<rbrakk> \\<Longrightarrow> P (x # xs) (y # ys)\"\n  shows  \"P xs ys\"", "lemma replicate_minus:\n  \"k < n \\<Longrightarrow> replicate n False = replicate (n - k) False @ replicate k False\"", "lemma cart_singleton_empty:\n  \"(S \\<times> {e} = {}) = (S = {})\"", "lemma MinI:\n  assumes fa: \"finite A\"\n  and     ne: \"A \\<noteq> {}\"\n  and     xv: \"m \\<in> A\"\n  and    min: \"\\<forall>y \\<in> A. m \\<le> y\"\n  shows \"Min A = m\"", "lemma power_numeral: \"a ^ numeral k = a * a ^ (pred_numeral k)\"", "lemma funpow_numeral [simp]: \"f ^^ numeral k = f \\<circ> f ^^ (pred_numeral k)\"", "lemma funpow_minus_simp: \"0 < n \\<Longrightarrow> f ^^ n = f \\<circ> f ^^ (n - 1)\"", "lemma rco_alt: \"(f \\<circ> g) ^^ n \\<circ> f = f \\<circ> (g \\<circ> f) ^^ n\"", "lemma union_sub:\n  \"\\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk> \\<Longrightarrow> (A - B) \\<union> (B - C) = (A - C)\"", "lemma insert_sub:\n  \"x \\<in> xs \\<Longrightarrow> (insert x (xs - ys)) = (xs - (ys - {x}))\"", "lemma ran_upd:\n  \"\\<lbrakk> inj_on f (dom f); f y = Some z \\<rbrakk> \\<Longrightarrow> ran (\\<lambda>x. if x = y then None else f x) = ran f - {z}\"", "lemma if_apply_def2:\n  \"(if P then F else G) = (\\<lambda>x. (P \\<longrightarrow> F x) \\<and> (\\<not> P \\<longrightarrow> G x))\"", "lemma case_bool_If:\n  \"case_bool P Q b = (if b then P else Q)\"", "lemma if_f:\n  \"(if a then f b else f c) = f (if a then b else c)\"", "lemma size_if: \"size (if p then xs else ys) = (if p then size xs else size ys)\"", "lemma if_Not_x: \"(if p then \\<not> x else x) = (p = (\\<not> x))\"", "lemma if_x_Not: \"(if p then x else \\<not> x) = (p = x)\"", "lemma if_same_and: \"(If p x y \\<and> If p u v) = (if p then x \\<and> u else y \\<and> v)\"", "lemma if_same_eq: \"(If p x y  = (If p u v)) = (if p then x = u else y = v)\"", "lemma if_same_eq_not: \"(If p x y = (\\<not> If p u v)) = (if p then x = (\\<not> u) else y = (\\<not> v))\"", "lemma the_elemI: \"y = {x} \\<Longrightarrow> the_elem y = x\"", "lemma nonemptyE: \"S \\<noteq> {} \\<Longrightarrow> (\\<And>x. x \\<in> S \\<Longrightarrow> R) \\<Longrightarrow> R\"", "lemmas xtr1 = xtrans(1)", "lemmas xtr2 = xtrans(2)", "lemmas xtr3 = xtrans(3)", "lemmas xtr4 = xtrans(4)", "lemmas xtr5 = xtrans(5)", "lemmas xtr6 = xtrans(6)", "lemmas xtr7 = xtrans(7)", "lemmas xtr8 = xtrans(8)", "lemmas if_fun_split = if_apply_def2", "lemma not_empty_eq:\n  \"(S \\<noteq> {}) = (\\<exists>x. x \\<in> S)\"", "lemma range_subset_lower:\n  fixes c :: \"'a ::linorder\"\n  shows \"\\<lbrakk> {a..b} \\<subseteq> {c..d}; x \\<in> {a..b} \\<rbrakk> \\<Longrightarrow> c \\<le> a\"", "lemma range_subset_upper:\n  fixes c :: \"'a ::linorder\"\n  shows \"\\<lbrakk> {a..b} \\<subseteq> {c..d}; x \\<in> {a..b} \\<rbrakk> \\<Longrightarrow> b \\<le> d\"", "lemma range_subset_eq:\n  fixes a::\"'a::linorder\"\n  assumes non_empty: \"a \\<le> b\"\n  shows \"({a..b} \\<subseteq> {c..d}) = (c \\<le> a \\<and> b \\<le> d)\"", "lemma range_eq:\n  fixes a::\"'a::linorder\"\n  assumes non_empty: \"a \\<le> b\"\n  shows \"({a..b} = {c..d}) = (a = c \\<and> b = d)\"", "lemma range_strict_subset_eq:\n  fixes a::\"'a::linorder\"\n  assumes non_empty: \"a \\<le> b\"\n  shows \"({a..b} \\<subset> {c..d}) = (c \\<le> a \\<and> b \\<le> d \\<and> (a = c \\<longrightarrow> b \\<noteq> d))\"", "lemma range_subsetI:\n  fixes x :: \"'a :: order\"\n  assumes xX: \"X \\<le> x\"\n  and     yY: \"y \\<le> Y\"\n  shows   \"{x .. y} \\<subseteq> {X .. Y}\"", "lemma set_False [simp]:\n  \"(set bs \\<subseteq> {False}) = (True \\<notin> set bs)\"", "lemma int_not_emptyD:\n  \"A \\<inter> B \\<noteq> {} \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> x \\<in> B\"", "lemma sum_map_simps[simp]:\n  \"sum_map f g (Inl v) = Inl (f v)\"\n  \"sum_map f g (Inr w) = Inr (g w)\"", "lemma if_Some_None_eq_None:\n  \"((if P then Some v else None) = None) = (\\<not> P)\"", "lemma CollectPairFalse [iff]:\n  \"{(a,b). False} = {}\"", "lemma if_conj_dist:\n  \"((if b then w else x) \\<and> (if b then y else z) \\<and> X) =\n  ((if b then w \\<and> y else x \\<and> z) \\<and> X)\"", "lemma if_P_True1:\n  \"Q \\<Longrightarrow> (if P then True else Q)\"", "lemma if_P_True2:\n  \"Q \\<Longrightarrow> (if P then Q else True)\"", "lemmas nat_simps = diff_add_inverse2 diff_add_inverse", "lemmas nat_iffs = le_add1 le_add2", "lemma nat_min_simps:\n  \"(a::nat) \\<le> b \\<Longrightarrow> min b a = a\"\n  \"a \\<le> b \\<Longrightarrow> min a b = a\"", "lemmas zadd_diff_inverse =\n  trans [OF diff_add_cancel [symmetric] add.commute]", "lemmas add_diff_cancel2 =\n  add.commute [THEN diff_eq_eq [THEN iffD2]]", "lemmas mcl = mult_cancel_left [THEN iffD1, THEN make_pos_rule]", "lemma pl_pl_rels: \"a + b = c + d \\<Longrightarrow> a \\<ge> c \\<and> b \\<le> d \\<or> a \\<le> c \\<and> b \\<ge> d\"\n  for a b c d :: nat", "lemmas pl_pl_rels' = add.commute [THEN [2] trans, THEN pl_pl_rels]", "lemma iszero_minus:\n  \\<open>iszero (- z) \\<longleftrightarrow> iszero z\\<close>", "lemma diff_le_eq': \"a - b \\<le> c \\<longleftrightarrow> a \\<le> b + c\"\n  for a b c :: int", "lemma zless2: \"0 < (2 :: int)\"", "lemma zless2p: \"0 < (2 ^ n :: int)\"", "lemma zle2p: \"0 \\<le> (2 ^ n :: int)\"", "lemma ex_eq_or: \"(\\<exists>m. n = Suc m \\<and> (m = k \\<or> P m)) \\<longleftrightarrow> n = Suc k \\<or> (\\<exists>m. n = Suc m \\<and> P m)\"", "lemma power_minus_simp: \"0 < n \\<Longrightarrow> a ^ n = a * a ^ (n - 1)\"", "lemma n2s_ths:\n  \\<open>2 + n = Suc (Suc n)\\<close>\n  \\<open>n + 2 = Suc (Suc n)\\<close>", "lemma s2n_ths:\n  \\<open>Suc (Suc n) = 2 + n\\<close>\n  \\<open>Suc (Suc n) = n + 2\\<close>", "lemma gt_or_eq_0: \"0 < y \\<or> 0 = y\"\n  for y :: nat", "lemma sum_imp_diff: \"j = k + i \\<Longrightarrow> j - i = k\"\n  for k :: nat", "lemma le_diff_eq': \"a \\<le> c - b \\<longleftrightarrow> b + a \\<le> c\"\n  for a b c :: int", "lemma less_diff_eq': \"a < c - b \\<longleftrightarrow> b + a < c\"\n  for a b c :: int", "lemma diff_less_eq': \"a - b < c \\<longleftrightarrow> a < b + c\"\n  for a b c :: int", "lemma axxbyy: \"a + m + m = b + n + n \\<Longrightarrow> a = 0 \\<or> a = 1 \\<Longrightarrow> b = 0 \\<or> b = 1 \\<Longrightarrow> a = b \\<and> m = n\"\n  for a b m n :: int", "lemma minus_eq: \"m - k = m \\<longleftrightarrow> k = 0 \\<or> m = 0\"\n  for k m :: nat", "lemma pl_pl_mm: \"a + b = c + d \\<Longrightarrow> a - c = d - b\"\n  for a b c d :: nat", "lemmas pl_pl_mm' = add.commute [THEN [2] trans, THEN pl_pl_mm]", "lemma less_le_mult': \"w * c < b * c \\<Longrightarrow> 0 \\<le> c \\<Longrightarrow> (w + 1) * c \\<le> b * c\"\n  for b c w :: int", "lemma less_le_mult: \"w * c < b * c \\<Longrightarrow> 0 \\<le> c \\<Longrightarrow> w * c + c \\<le> b * c\"\n  for b c w :: int", "lemmas less_le_mult_minus = iffD2 [OF le_diff_eq less_le_mult,\n  simplified left_diff_distrib]", "lemma gen_minus: \"0 < n \\<Longrightarrow> f n = f (Suc (n - 1))\"", "lemma mpl_lem: \"j \\<le> i \\<Longrightarrow> k < j \\<Longrightarrow> i - j + k < i\"\n  for i j k :: nat", "lemmas dme = div_mult_mod_eq", "lemmas dtle = div_times_less_eq_dividend", "lemmas th2 = order_trans [OF order_refl [THEN [2] mult_le_mono] div_times_less_eq_dividend]", "lemmas sdl = div_nat_eqI", "lemma given_quot: \"f > 0 \\<Longrightarrow> (f * l + (f - 1)) div f = l\"\n  for f l :: nat", "lemma given_quot_alt: \"f > 0 \\<Longrightarrow> (l * f + f - Suc 0) div f = l\"\n  for f l :: nat", "lemma x_power_minus_1:\n  fixes x :: \"'a :: {ab_group_add, power, numeral, one}\"\n  shows \"x + (2::'a) ^ n - (1::'a) = x + (2 ^ n - 1)\"", "lemma nat_diff_add:\n  fixes i :: nat\n  shows \"\\<lbrakk> i + j = k \\<rbrakk> \\<Longrightarrow> i = k - j\"", "lemma pow_2_gt: \"n \\<ge> 2 \\<Longrightarrow> (2::int) < 2 ^ n\"", "lemma sum_to_zero:\n  \"(a :: 'a :: ring) + b = 0 \\<Longrightarrow> a = (- b)\"", "lemma arith_is_1:\n  \"\\<lbrakk> x \\<le> Suc 0; x > 0 \\<rbrakk> \\<Longrightarrow> x = 1\"", "lemma suc_le_pow_2:\n  \"1 < (n::nat) \\<Longrightarrow> Suc n < 2 ^ n\"", "lemma nat_le_Suc_less_imp:\n  \"x < y \\<Longrightarrow> x \\<le> y - Suc 0\"", "lemma power_sub_int:\n  \"\\<lbrakk> m \\<le> n; 0 < b \\<rbrakk> \\<Longrightarrow> b ^ n div b ^ m = (b ^ (n - m) :: int)\"", "lemma nat_Suc_less_le_imp:\n  \"(k::nat) < Suc n \\<Longrightarrow> k \\<le> n\"", "lemma nat_add_less_by_max:\n  \"\\<lbrakk> (x::nat) \\<le> xmax ; y < k - xmax \\<rbrakk> \\<Longrightarrow> x + y < k\"", "lemma nat_le_Suc_less:\n  \"0 < y \\<Longrightarrow> (x \\<le> y - Suc 0) = (x < y)\"", "lemma nat_power_minus_less:\n  \"a < 2 ^ (x - n) \\<Longrightarrow> (a :: nat) < 2 ^ x\"", "lemma less_le_mult_nat':\n  \"w * c < b * c ==> 0 \\<le> c ==> Suc w * c \\<le> b * (c::nat)\"", "lemma less_le_mult_nat:\n  \\<open>0 < c \\<and> w < b \\<Longrightarrow> c + w * c \\<le> b * c\\<close> for b c w :: nat", "lemma p_assoc_help:\n  fixes p :: \"'a::{ring,power,numeral,one}\"\n  shows \"p + 2^sz - 1 = p + (2^sz - 1)\"", "lemma pow_mono_leq_imp_lt:\n  \"x \\<le> y \\<Longrightarrow> x < 2 ^ y\"", "lemma small_powers_of_2:\n  \"x \\<ge> 3 \\<Longrightarrow> x < 2 ^ (x - 1)\"", "lemma nat_less_power_trans2:\n  fixes n :: nat\n  shows \"\\<lbrakk>n < 2 ^ (m - k); k \\<le> m\\<rbrakk> \\<Longrightarrow> n * 2 ^ k  < 2 ^ m\"", "lemma nat_move_sub_le: \"(a::nat) + b \\<le> c \\<Longrightarrow> a \\<le> c - b\"", "lemma plus_minus_one_rewrite:\n  \"v + (- 1 :: ('a :: {ring, one, uminus})) \\<equiv> v - 1\"", "lemma Suc_0_lt_2p_len_of: \"Suc 0 < 2 ^ LENGTH('a :: len)\""], "translations": [["", "lemma nat_less_mult_monoish: \"\\<lbrakk> a < b; c < (d :: nat) \\<rbrakk> \\<Longrightarrow> (a + 1) * (c + 1) <= b * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < b; c < d\\<rbrakk>\n    \\<Longrightarrow> (a + 1) * (c + 1) \\<le> b * d", "apply (drule Suc_leI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc a \\<le> b; Suc c \\<le> d\\<rbrakk>\n    \\<Longrightarrow> (a + 1) * (c + 1) \\<le> b * d", "apply (drule(1) mult_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc c \\<le> d; Suc a * Suc c \\<le> b * d\\<rbrakk>\n    \\<Longrightarrow> (a + 1) * (c + 1) \\<le> b * d", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_and_helper:\n  \"(If x v v') AND v'' = If x (v AND v'') (v' AND v'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x then v else v') AND v'' = (if x then v AND v'' else v' AND v'')", "by (rule if_distrib)"], ["", "lemma eq_eqI:\n  \"a = b \\<Longrightarrow> (a = x) = (b = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> (a = x) = (b = x)", "by simp"], ["", "lemma map2_Cons_2_3:\n  \"(map2 f xs (y # ys) = (z # zs)) = (\\<exists>x xs'. xs = x # xs' \\<and> f x y = z \\<and> map2 f xs' ys = zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map2 f xs (y # ys) = z # zs) =\n    (\\<exists>x xs'.\n        xs = x # xs' \\<and> f x y = z \\<and> map2 f xs' ys = zs)", "by (case_tac xs, simp_all)"], ["", "lemma map2_xor_replicate_False:\n  \"map2 (\\<lambda>x y. x \\<longleftrightarrow> \\<not> y) xs (replicate n False) = take n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<lambda>x y. x = (\\<not> y)) xs (replicate n False) = take n xs", "apply (induct xs arbitrary: n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map2 (\\<lambda>x y. x = (\\<not> y)) xs (replicate n False) =\n           take n xs) \\<Longrightarrow>\n       map2 (\\<lambda>x y. x = (\\<not> y)) (a # xs) (replicate n False) =\n       take n (a # xs)", "apply (case_tac n; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma plus_Collect_helper:\n  \"(+) x ` {xa. P (xa :: 'a :: len word)} = {xa. P (xa - x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) x ` {xa. P xa} = {xa. P (xa - x)}", "by (fastforce simp add: image_def)"], ["", "lemma plus_Collect_helper2:\n  \"(+) (- x) ` {xa. P (xa :: 'a :: len word)} = {xa. P (x + xa)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) (- x) ` {xa. P xa} = {xa. P (x + xa)}", "using plus_Collect_helper [of \"- x\" P]"], ["proof (prove)\nusing this:\n  (+) (- x) ` {xa. P xa} = {xa. P (xa - - x)}\n\ngoal (1 subgoal):\n 1. (+) (- x) ` {xa. P xa} = {xa. P (x + xa)}", "by (simp add: ac_simps)"], ["", "lemma range_subset_eq2:\n  \"{a :: 'a :: len word .. b} \\<noteq> {} \\<Longrightarrow> ({a .. b} \\<subseteq> {c .. d}) = (c \\<le> a \\<and> b \\<le> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a..b} \\<noteq> {} \\<Longrightarrow>\n    ({a..b} \\<subseteq> {c..d}) = (c \\<le> a \\<and> b \\<le> d)", "by simp"], ["", "lemma nat_mod_power_lem:\n  fixes a :: nat\n  shows \"1 < a \\<Longrightarrow> a ^ n mod a ^ m = (if m \\<le> n then 0 else a ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < a \\<Longrightarrow>\n    a ^ n mod a ^ m = (if m \\<le> n then 0 else a ^ n)", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < a; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> a ^ n mod a ^ m = 0", "apply (clarsimp simp add: le_iff_add power_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_hate_words_helper:\n  \"i \\<le> (j - k :: nat) \\<Longrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j - k \\<Longrightarrow> i \\<le> j", "by simp"], ["", "lemma i_hate_words:\n  \"unat (a :: 'a word) \\<le> unat (b :: 'a :: len word) - Suc 0\n    \\<Longrightarrow> a \\<noteq> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a \\<le> unat b - Suc 0 \\<Longrightarrow> a \\<noteq> - 1", "apply (frule i_hate_words_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a \\<le> unat b - Suc 0; unat a \\<le> unat b\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> - 1", "apply (subst(asm) word_le_nat_alt[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a \\<le> unat b - Suc 0; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> - 1", "apply (clarsimp simp only: word_minus_one_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (- 1) \\<le> unat (- 1) - Suc 0; b = - 1; a = - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp only: linorder_not_less[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> unat (- 1) - Suc 0 < unat (- 1); b = - 1;\n     a = - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = - 1; a = - 1\\<rbrakk>\n    \\<Longrightarrow> unat (- 1) - Suc 0 < unat (- 1)", "apply (rule diff_Suc_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = - 1; a = - 1\\<rbrakk> \\<Longrightarrow> 0 < unat (- 1)", "apply (subst neq0_conv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = - 1; a = - 1\\<rbrakk>\n    \\<Longrightarrow> unat (- 1) \\<noteq> 0", "apply (subst unat_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = - 1; a = - 1\\<rbrakk> \\<Longrightarrow> - 1 \\<noteq> 0", "apply (rule notI, drule arg_cong[where f=\"(+) 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = - 1; - 1 = 0; 1 + b = 1 + - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma If_eq_obvious:\n  \"x \\<noteq> z \\<Longrightarrow> ((if P then x else y) = z) = (\\<not> P \\<and> y = z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow>\n    ((if P then x else y) = z) = (\\<not> P \\<and> y = z)", "by simp"], ["", "lemma Some_to_the:\n  \"v = Some x \\<Longrightarrow> x = the v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = Some x \\<Longrightarrow> x = the v", "by simp"], ["", "lemma dom_if_Some:\n  \"dom (\\<lambda>x. if P x then Some (f x) else g x) = {x. P x} \\<union> dom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x. if P x then Some (f x) else g x) =\n    {x. P x} \\<union> dom g", "by fastforce"], ["", "lemma dom_insert_absorb:\n  \"x \\<in> dom f \\<Longrightarrow> insert x (dom f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom f \\<Longrightarrow> insert x (dom f) = dom f", "by (fact insert_absorb)"], ["", "lemma emptyE2:\n  \"\\<lbrakk> S = {}; x \\<in> S \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S = {}; x \\<in> S\\<rbrakk> \\<Longrightarrow> P", "by simp"], ["", "lemma ptr_add_image_multI:\n  \"\\<lbrakk> \\<And>x y. (x * val = y * val') = (x * val'' = y); x * val'' \\<in> S \\<rbrakk> \\<Longrightarrow>\n     ptr_add ptr (x * val) \\<in> (\\<lambda>p. ptr_add ptr (p * val')) ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. (x * val = y * val') = (x * val'' = y);\n     x * val'' \\<in> S\\<rbrakk>\n    \\<Longrightarrow> ptr_add ptr (x * val)\n                      \\<in> (\\<lambda>p. ptr_add ptr (p * val')) ` S", "by (auto simp add: image_iff) metis"], ["", "lemmas map_prod_split_imageI'\n  = map_prod_imageI[where f=\"case_prod f\" and g=\"case_prod g\"\n                    and a=\"(a, b)\" and b=\"(c, d)\" for a b c d f g]"], ["", "lemmas map_prod_split_imageI = map_prod_split_imageI'[simplified]"], ["", "lemma dom_if:\n  \"dom (\\<lambda>a. if a \\<in> addrs then Some (f a) else g a)  = addrs \\<union> dom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>a. if a \\<in> addrs then Some (f a) else g a) =\n    addrs \\<union> dom g", "by (auto simp: dom_def split: if_split)"], ["", "lemmas arg_cong_Not = arg_cong [where f=Not]"], ["", "lemma drop_append_miracle:\n  \"n = length xs \\<Longrightarrow> drop n (xs @ ys) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length xs \\<Longrightarrow> drop n (xs @ ys) = ys", "by simp"], ["", "lemma foldr_does_nothing_to_xf:\n  \"\\<lbrakk> \\<And>x s. x \\<in> set xs \\<Longrightarrow> xf (f x s) = xf s \\<rbrakk> \\<Longrightarrow> xf (foldr f xs s) = xf s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x s.\n        x \\<in> set xs \\<Longrightarrow>\n        xf (f x s) = xf s) \\<Longrightarrow>\n    xf (foldr f xs s) = xf s", "by (induct xs, simp_all)"], ["", "lemma mod_mod_power_int:\n  fixes k :: int\n  shows \"k mod 2 ^ m mod 2 ^ n = k mod 2 ^ (min m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k mod 2 ^ m mod 2 ^ n = k mod 2 ^ min m n", "by (fact mod_exp_eq)"], ["", "lemma le_step_down_nat:\"\\<lbrakk>(i::nat) \\<le> n; i = n \\<longrightarrow> P; i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> n; i = n \\<longrightarrow> P;\n     i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by arith"], ["", "lemma le_step_down_int:\"\\<lbrakk>(i::int) \\<le> n; i = n \\<longrightarrow> P; i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> n; i = n \\<longrightarrow> P;\n     i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by arith"], ["", "lemma replicate_numeral [simp]: \"replicate (numeral k) x = x # replicate (pred_numeral k) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (numeral k) x = x # replicate (pred_numeral k) x", "by (simp add: numeral_eq_Suc)"], ["", "lemma list_exhaust_size_gt0:\n  assumes \"\\<And>a list. y = a # list \\<Longrightarrow> P\"\n  shows \"0 < length y \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length y \\<Longrightarrow> P", "apply (cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length y; y = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>a list.\n       \\<lbrakk>0 < length y; y = a # list\\<rbrakk> \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>0 < length y; y = a # list\\<rbrakk> \\<Longrightarrow> P", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>0 < length y; y = a # list\\<rbrakk>\n       \\<Longrightarrow> y = ?a1 a list # ?list1 a list", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_exhaust_size_eq0:\n  assumes \"y = [] \\<Longrightarrow> P\"\n  shows \"length y = 0 \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length y = 0 \\<Longrightarrow> P", "apply (cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length y = 0; y = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>a list.\n       \\<lbrakk>length y = 0; y = a # list\\<rbrakk> \\<Longrightarrow> P", "apply (rule assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length y = 0; y = []\\<rbrakk> \\<Longrightarrow> y = []\n 2. \\<And>a list.\n       \\<lbrakk>length y = 0; y = a # list\\<rbrakk> \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length y = 0; y = a # list\\<rbrakk> \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_Cons_lem_eq: \"y = xa # list \\<Longrightarrow> size y = Suc k \\<Longrightarrow> size list = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = xa # list; length y = Suc k\\<rbrakk>\n    \\<Longrightarrow> length list = k", "by auto"], ["", "lemma takeWhile_take_has_property:\n  \"n \\<le> length (takeWhile P xs) \\<Longrightarrow> \\<forall>x \\<in> set (take n xs). P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length (takeWhile P xs) \\<Longrightarrow>\n    \\<forall>x\\<in>set (take n xs). P x", "by (induct xs arbitrary: n; simp split: if_split_asm) (case_tac n, simp_all)"], ["", "lemma takeWhile_take_has_property_nth:\n  \"\\<lbrakk> n < length (takeWhile P xs) \\<rbrakk> \\<Longrightarrow> P (xs ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length (takeWhile P xs) \\<Longrightarrow> P (xs ! n)", "by (induct xs arbitrary: n; simp split: if_split_asm) (case_tac n, simp_all)"], ["", "lemma takeWhile_replicate:\n  \"takeWhile f (replicate len x) = (if f x then replicate len x else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takeWhile f (replicate len x) = (if f x then replicate len x else [])", "by (induct_tac len) auto"], ["", "lemma takeWhile_replicate_empty:\n  \"\\<not> f x \\<Longrightarrow> takeWhile f (replicate len x) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f x \\<Longrightarrow> takeWhile f (replicate len x) = []", "by (simp add: takeWhile_replicate)"], ["", "lemma takeWhile_replicate_id:\n  \"f x \\<Longrightarrow> takeWhile f (replicate len x) = replicate len x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<Longrightarrow> takeWhile f (replicate len x) = replicate len x", "by (simp add: takeWhile_replicate)"], ["", "lemma nth_rev: \"n < length xs \\<Longrightarrow> rev xs ! n = xs ! (length xs - 1 - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow> rev xs ! n = xs ! (length xs - 1 - n)", "using rev_nth"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow>\n  rev ?xs ! ?n = ?xs ! (length ?xs - Suc ?n)\n\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow> rev xs ! n = xs ! (length xs - 1 - n)", "by simp"], ["", "lemma nth_rev_alt: \"n < length ys \\<Longrightarrow> ys ! n = rev ys ! (length ys - Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length ys \\<Longrightarrow> ys ! n = rev ys ! (length ys - Suc n)", "by (simp add: nth_rev)"], ["", "lemma hd_butlast: \"length xs > 1 \\<Longrightarrow> hd (butlast xs) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow> hd (butlast xs) = hd xs", "by (cases xs) auto"], ["", "lemma split_upt_on_n:\n  \"n < m \\<Longrightarrow> [0 ..< m] = [0 ..< n] @ [n] @ [Suc n ..< m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow> [0..<m] = [0..<n] @ [n] @ [Suc n..<m]", "by (metis append_Cons append_Nil less_Suc_eq_le less_imp_le_nat upt_add_eq_append'\n            upt_rec zero_less_Suc)"], ["", "lemma drop_eq_mono:\n  assumes le: \"m \\<le> n\"\n  assumes drop: \"drop m xs = drop m ys\"\n  shows \"drop n xs = drop n ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n xs = drop n ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. drop n xs = drop n ys", "have ex: \"\\<exists>p. n = p + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. n = p + m", "by (rule exI[of _ \"n - m\"]) (simp add: le)"], ["proof (state)\nthis:\n  \\<exists>p. n = p + m\n\ngoal (1 subgoal):\n 1. drop n xs = drop n ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. n = p + m", "obtain p where p: \"n = p + m\""], ["proof (prove)\nusing this:\n  \\<exists>p. n = p + m\n\ngoal (1 subgoal):\n 1. (\\<And>p. n = p + m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  n = p + m\n\ngoal (1 subgoal):\n 1. drop n xs = drop n ys", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n xs = drop n ys", "unfolding p drop_drop[symmetric] drop"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop p (drop m ys) = drop p (drop m ys)", "by simp"], ["proof (state)\nthis:\n  drop n xs = drop n ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_Suc_nth:\n  \"n < length xs \\<Longrightarrow> drop n xs = xs!n # drop (Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow> drop n xs = xs ! n # drop (Suc n) xs", "by (simp add: Cons_nth_drop_Suc)"], ["", "lemma and_len: \"xs = ys \\<Longrightarrow> xs = ys \\<and> length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys \\<Longrightarrow> xs = ys \\<and> length xs = length ys", "by auto"], ["", "lemma tl_if: \"tl (if p then xs else ys) = (if p then tl xs else tl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (if p then xs else ys) = (if p then tl xs else tl ys)", "by auto"], ["", "lemma hd_if: \"hd (if p then xs else ys) = (if p then hd xs else hd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (if p then xs else ys) = (if p then hd xs else hd ys)", "by auto"], ["", "lemma if_single: \"(if xc then [xab] else [an]) = [if xc then xab else an]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if xc then [xab] else [an]) = [if xc then xab else an]", "by auto\n\n\\<comment> \\<open>note -- \\<open>if_Cons\\<close> can cause blowup in the size, if \\<open>p\\<close> is complex, so make a simproc\\<close>"], ["", "lemma if_Cons: \"(if p then x # xs else y # ys) = If p x y # If p xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p then x # xs else y # ys) =\n    (if p then x else y) # (if p then xs else ys)", "by auto"], ["", "lemma list_of_false:\n  \"True \\<notin> set xs \\<Longrightarrow> xs = replicate (length xs) False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<notin> set xs \\<Longrightarrow> xs = replicate (length xs) False", "by (induct xs, simp_all)"], ["", "lemma list_all2_induct [consumes 1, case_names Nil Cons]:\n  assumes lall: \"list_all2 Q xs ys\"\n  and     nilr: \"P [] []\"\n  and    consr: \"\\<And>x xs y ys. \\<lbrakk>list_all2 Q xs ys; Q x y; P xs ys\\<rbrakk> \\<Longrightarrow> P (x # xs) (y # ys)\"\n  shows  \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "using lall"], ["proof (prove)\nusing this:\n  list_all2 Q xs ys\n\ngoal (1 subgoal):\n 1. P xs ys", "proof (induct rule: list_induct2 [OF list_all2_lengthD [OF lall]])"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all2 Q [] [] \\<Longrightarrow> P [] []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_all2 Q xs ys \\<Longrightarrow> P xs ys;\n        list_all2 Q (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> P (x # xs) (y # ys)", "case 1"], ["proof (state)\nthis:\n  list_all2 Q [] []\n\ngoal (2 subgoals):\n 1. list_all2 Q [] [] \\<Longrightarrow> P [] []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_all2 Q xs ys \\<Longrightarrow> P xs ys;\n        list_all2 Q (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> P (x # xs) (y # ys)", "then"], ["proof (chain)\npicking this:\n  list_all2 Q [] []", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 Q [] []\n\ngoal (1 subgoal):\n 1. P [] []", "by auto fact+"], ["proof (state)\nthis:\n  P [] []\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_all2 Q xs ys \\<Longrightarrow> P xs ys;\n        list_all2 Q (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> P (x # xs) (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_all2 Q xs ys \\<Longrightarrow> P xs ys;\n        list_all2 Q (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> P (x # xs) (y # ys)", "case (2 x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  list_all2 Q xs ys \\<Longrightarrow> P xs ys\n  list_all2 Q (x # xs) (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_all2 Q xs ys \\<Longrightarrow> P xs ys;\n        list_all2 Q (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> P (x # xs) (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (x # xs) (y # ys)", "proof (rule consr)"], ["proof (state)\ngoal (3 subgoals):\n 1. list_all2 Q xs ys\n 2. Q x y\n 3. P xs ys", "from \"2.prems\""], ["proof (chain)\npicking this:\n  list_all2 Q (x # xs) (y # ys)", "show \"list_all2 Q xs ys\" and \"Q x y\""], ["proof (prove)\nusing this:\n  list_all2 Q (x # xs) (y # ys)\n\ngoal (1 subgoal):\n 1. list_all2 Q xs ys &&& Q x y", "by simp_all"], ["proof (state)\nthis:\n  list_all2 Q xs ys\n  Q x y\n\ngoal (1 subgoal):\n 1. P xs ys", "then"], ["proof (chain)\npicking this:\n  list_all2 Q xs ys\n  Q x y", "show \"P xs ys\""], ["proof (prove)\nusing this:\n  list_all2 Q xs ys\n  Q x y\n\ngoal (1 subgoal):\n 1. P xs ys", "by (intro \"2.hyps\")"], ["proof (state)\nthis:\n  P xs ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (x # xs) (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replicate_minus:\n  \"k < n \\<Longrightarrow> replicate n False = replicate (n - k) False @ replicate k False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    replicate n False = replicate (n - k) False @ replicate k False", "by (subst replicate_add [symmetric]) simp"], ["", "lemma cart_singleton_empty:\n  \"(S \\<times> {e} = {}) = (S = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<times> {e} = {}) = (S = {})", "by blast"], ["", "lemma MinI:\n  assumes fa: \"finite A\"\n  and     ne: \"A \\<noteq> {}\"\n  and     xv: \"m \\<in> A\"\n  and    min: \"\\<forall>y \\<in> A. m \\<le> y\"\n  shows \"Min A = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min A = m", "using fa ne xv min"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n  m \\<in> A\n  \\<forall>y\\<in>A. m \\<le> y\n\ngoal (1 subgoal):\n 1. Min A = m", "proof (induct A arbitrary: m rule: finite_ne_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x m.\n       \\<lbrakk>m \\<in> {x}; Ball {x} ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min {x} = m\n 2. \\<And>x F m.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; Ball F ((\\<le>) m)\\<rbrakk>\n           \\<Longrightarrow> Min F = m;\n        m \\<in> insert x F; Ball (insert x F) ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min (insert x F) = m", "case singleton"], ["proof (state)\nthis:\n  m \\<in> {x_}\n  \\<forall>a\\<in>{x_}. m \\<le> a\n\ngoal (2 subgoals):\n 1. \\<And>x m.\n       \\<lbrakk>m \\<in> {x}; Ball {x} ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min {x} = m\n 2. \\<And>x F m.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; Ball F ((\\<le>) m)\\<rbrakk>\n           \\<Longrightarrow> Min F = m;\n        m \\<in> insert x F; Ball (insert x F) ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min (insert x F) = m", "then"], ["proof (chain)\npicking this:\n  m \\<in> {x_}\n  \\<forall>a\\<in>{x_}. m \\<le> a", "show ?case"], ["proof (prove)\nusing this:\n  m \\<in> {x_}\n  \\<forall>a\\<in>{x_}. m \\<le> a\n\ngoal (1 subgoal):\n 1. Min {x_} = m", "by simp"], ["proof (state)\nthis:\n  Min {x_} = m\n\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; Ball F ((\\<le>) m)\\<rbrakk>\n           \\<Longrightarrow> Min F = m;\n        m \\<in> insert x F; Ball (insert x F) ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min (insert x F) = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; Ball F ((\\<le>) m)\\<rbrakk>\n           \\<Longrightarrow> Min F = m;\n        m \\<in> insert x F; Ball (insert x F) ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min (insert x F) = m", "case (insert y F)"], ["proof (state)\nthis:\n  finite F\n  F \\<noteq> {}\n  y \\<notin> F\n  \\<lbrakk>?m \\<in> F; \\<forall>a\\<in>F. ?m \\<le> a\\<rbrakk>\n  \\<Longrightarrow> Min F = ?m\n  m \\<in> insert y F\n  \\<forall>a\\<in>insert y F. m \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; Ball F ((\\<le>) m)\\<rbrakk>\n           \\<Longrightarrow> Min F = m;\n        m \\<in> insert x F; Ball (insert x F) ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min (insert x F) = m", "from insert.prems"], ["proof (chain)\npicking this:\n  m \\<in> insert y F\n  \\<forall>a\\<in>insert y F. m \\<le> a", "have yx: \"m \\<le> y\" and fx: \"\\<forall>y \\<in> F. m \\<le> y\""], ["proof (prove)\nusing this:\n  m \\<in> insert y F\n  \\<forall>a\\<in>insert y F. m \\<le> a\n\ngoal (1 subgoal):\n 1. m \\<le> y &&& \\<forall>y\\<in>F. m \\<le> y", "by auto"], ["proof (state)\nthis:\n  m \\<le> y\n  \\<forall>y\\<in>F. m \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; Ball F ((\\<le>) m)\\<rbrakk>\n           \\<Longrightarrow> Min F = m;\n        m \\<in> insert x F; Ball (insert x F) ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min (insert x F) = m", "have \"m \\<in> insert y F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> insert y F", "by fact"], ["proof (state)\nthis:\n  m \\<in> insert y F\n\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; Ball F ((\\<le>) m)\\<rbrakk>\n           \\<Longrightarrow> Min F = m;\n        m \\<in> insert x F; Ball (insert x F) ((\\<le>) m)\\<rbrakk>\n       \\<Longrightarrow> Min (insert x F) = m", "then"], ["proof (chain)\npicking this:\n  m \\<in> insert y F", "show ?case"], ["proof (prove)\nusing this:\n  m \\<in> insert y F\n\ngoal (1 subgoal):\n 1. Min (insert y F) = m", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m = y \\<Longrightarrow> Min (insert y F) = m\n 2. m \\<in> F \\<Longrightarrow> Min (insert y F) = m", "assume mv: \"m = y\""], ["proof (state)\nthis:\n  m = y\n\ngoal (2 subgoals):\n 1. m = y \\<Longrightarrow> Min (insert y F) = m\n 2. m \\<in> F \\<Longrightarrow> Min (insert y F) = m", "have mlt: \"m \\<le> Min F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> Min F", "by (rule iffD2 [OF Min_ge_iff [OF insert.hyps(1) insert.hyps(2)] fx])"], ["proof (state)\nthis:\n  m \\<le> Min F\n\ngoal (2 subgoals):\n 1. m = y \\<Longrightarrow> Min (insert y F) = m\n 2. m \\<in> F \\<Longrightarrow> Min (insert y F) = m", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (insert y F) = m", "apply (subst Min_insert [OF insert.hyps(1) insert.hyps(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. min y (Min F) = m", "apply (subst mv [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. min m (Min F) = m", "apply (auto simp: min_def mlt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Min (insert y F) = m\n\ngoal (1 subgoal):\n 1. m \\<in> F \\<Longrightarrow> Min (insert y F) = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<in> F \\<Longrightarrow> Min (insert y F) = m", "assume \"m \\<in> F\""], ["proof (state)\nthis:\n  m \\<in> F\n\ngoal (1 subgoal):\n 1. m \\<in> F \\<Longrightarrow> Min (insert y F) = m", "then"], ["proof (chain)\npicking this:\n  m \\<in> F", "have mf: \"Min F = m\""], ["proof (prove)\nusing this:\n  m \\<in> F\n\ngoal (1 subgoal):\n 1. Min F = m", "by (rule insert.hyps(4) [OF _ fx])"], ["proof (state)\nthis:\n  Min F = m\n\ngoal (1 subgoal):\n 1. m \\<in> F \\<Longrightarrow> Min (insert y F) = m", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (insert y F) = m", "apply (subst Min_insert [OF insert.hyps(1) insert.hyps(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. min y (Min F) = m", "apply (subst mf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. min y m = m", "apply (rule iffD2 [OF _ yx])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (min y m = m) = (m \\<le> y)", "apply (auto simp: min_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Min (insert y F) = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (insert y F) = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_numeral: \"a ^ numeral k = a * a ^ (pred_numeral k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ numeral k = a * a ^ pred_numeral k", "by (simp add: numeral_eq_Suc)"], ["", "lemma funpow_numeral [simp]: \"f ^^ numeral k = f \\<circ> f ^^ (pred_numeral k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ^^ numeral k = f \\<circ> f ^^ pred_numeral k", "by (simp add: numeral_eq_Suc)"], ["", "lemma funpow_minus_simp: \"0 < n \\<Longrightarrow> f ^^ n = f \\<circ> f ^^ (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> f ^^ n = f \\<circ> f ^^ (n - 1)", "by (auto dest: gr0_implies_Suc)"], ["", "lemma rco_alt: \"(f \\<circ> g) ^^ n \\<circ> f = f \\<circ> (g \\<circ> f) ^^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> g) ^^ n \\<circ> f = f \\<circ> (g \\<circ> f) ^^ n", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((f \\<circ> g) ^^ n \\<circ> f) x = (f \\<circ> (g \\<circ> f) ^^ n) x", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((f \\<circ> g) ^^ 0 \\<circ> f) x = (f \\<circ> (g \\<circ> f) ^^ 0) x\n 2. \\<And>n x.\n       (\\<And>x.\n           ((f \\<circ> g) ^^ n \\<circ> f) x =\n           (f \\<circ> (g \\<circ> f) ^^ n) x) \\<Longrightarrow>\n       ((f \\<circ> g) ^^ Suc n \\<circ> f) x =\n       (f \\<circ> (g \\<circ> f) ^^ Suc n) x", "apply (simp_all add: o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma union_sub:\n  \"\\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk> \\<Longrightarrow> (A - B) \\<union> (B - C) = (A - C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> A - B \\<union> (B - C) = A - C", "by fastforce"], ["", "lemma insert_sub:\n  \"x \\<in> xs \\<Longrightarrow> (insert x (xs - ys)) = (xs - (ys - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> xs \\<Longrightarrow> insert x (xs - ys) = xs - (ys - {x})", "by blast"], ["", "lemma ran_upd:\n  \"\\<lbrakk> inj_on f (dom f); f y = Some z \\<rbrakk> \\<Longrightarrow> ran (\\<lambda>x. if x = y then None else f x) = ran f - {z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (dom f); f y = Some z\\<rbrakk>\n    \\<Longrightarrow> ran (\\<lambda>x. if x = y then None else f x) =\n                      ran f - {z}", "unfolding ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (dom f); f y = Some z\\<rbrakk>\n    \\<Longrightarrow> {b. \\<exists>a.\n                             (if a = y then None else f a) = Some b} =\n                      {b. \\<exists>a. f a = Some b} - {z}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); f y = Some z\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> {b. \\<exists>a.\n   (if a = y then None else f a) = Some b}) =\n                         (x \\<in> {b. \\<exists>a. f a = Some b} - {z})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); f y = Some z\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a.\n                             a \\<noteq> y \\<and>\n                             (a \\<noteq> y \\<longrightarrow>\n                              f a = Some x)) =\n                         ((\\<exists>a. f a = Some x) \\<and> x \\<noteq> z)", "by (metis domI inj_on_eq_iff option.sel)"], ["", "lemma if_apply_def2:\n  \"(if P then F else G) = (\\<lambda>x. (P \\<longrightarrow> F x) \\<and> (\\<not> P \\<longrightarrow> G x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P then F else G) =\n    (\\<lambda>x.\n        (P \\<longrightarrow> F x) \\<and> (\\<not> P \\<longrightarrow> G x))", "by simp"], ["", "lemma case_bool_If:\n  \"case_bool P Q b = (if b then P else Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case b of True \\<Rightarrow> P | False \\<Rightarrow> Q) =\n    (if b then P else Q)", "by simp"], ["", "lemma if_f:\n  \"(if a then f b else f c) = f (if a then b else c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a then f b else f c) = f (if a then b else c)", "by simp"], ["", "lemma size_if: \"size (if p then xs else ys) = (if p then size xs else size ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (if p then xs else ys) = (if p then size xs else size ys)", "by (fact if_distrib)"], ["", "lemma if_Not_x: \"(if p then \\<not> x else x) = (p = (\\<not> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p then \\<not> x else x) = (p = (\\<not> x))", "by auto"], ["", "lemma if_x_Not: \"(if p then x else \\<not> x) = (p = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p then x else \\<not> x) = (p = x)", "by auto"], ["", "lemma if_same_and: \"(If p x y \\<and> If p u v) = (if p then x \\<and> u else y \\<and> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if p then x else y) \\<and> (if p then u else v)) =\n    (if p then x \\<and> u else y \\<and> v)", "by auto"], ["", "lemma if_same_eq: \"(If p x y  = (If p u v)) = (if p then x = u else y = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if p then x else y) = (if p then u else v)) =\n    (if p then x = u else y = v)", "by auto"], ["", "lemma if_same_eq_not: \"(If p x y = (\\<not> If p u v)) = (if p then x = (\\<not> u) else y = (\\<not> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if p then x else y) = (\\<not> (if p then u else v))) =\n    (if p then x = (\\<not> u) else y = (\\<not> v))", "by auto"], ["", "lemma the_elemI: \"y = {x} \\<Longrightarrow> the_elem y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = {x} \\<Longrightarrow> the_elem y = x", "by simp"], ["", "lemma nonemptyE: \"S \\<noteq> {} \\<Longrightarrow> (\\<And>x. x \\<in> S \\<Longrightarrow> R) \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {}; \\<And>x. x \\<in> S \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by auto"], ["", "lemmas xtr1 = xtrans(1)"], ["", "lemmas xtr2 = xtrans(2)"], ["", "lemmas xtr3 = xtrans(3)"], ["", "lemmas xtr4 = xtrans(4)"], ["", "lemmas xtr5 = xtrans(5)"], ["", "lemmas xtr6 = xtrans(6)"], ["", "lemmas xtr7 = xtrans(7)"], ["", "lemmas xtr8 = xtrans(8)"], ["", "lemmas if_fun_split = if_apply_def2"], ["", "lemma not_empty_eq:\n  \"(S \\<noteq> {}) = (\\<exists>x. x \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<noteq> {}) = (\\<exists>x. x \\<in> S)", "by auto"], ["", "lemma range_subset_lower:\n  fixes c :: \"'a ::linorder\"\n  shows \"\\<lbrakk> {a..b} \\<subseteq> {c..d}; x \\<in> {a..b} \\<rbrakk> \\<Longrightarrow> c \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; x \\<in> {a..b}\\<rbrakk>\n    \\<Longrightarrow> c \\<le> a", "apply (frule (1) subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; x \\<in> {a..b};\n     x \\<in> {c..d}\\<rbrakk>\n    \\<Longrightarrow> c \\<le> a", "apply (rule classical)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; x \\<in> {a..b}; x \\<in> {c..d};\n     \\<not> c \\<le> a\\<rbrakk>\n    \\<Longrightarrow> c \\<le> a", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_subset_upper:\n  fixes c :: \"'a ::linorder\"\n  shows \"\\<lbrakk> {a..b} \\<subseteq> {c..d}; x \\<in> {a..b} \\<rbrakk> \\<Longrightarrow> b \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; x \\<in> {a..b}\\<rbrakk>\n    \\<Longrightarrow> b \\<le> d", "apply (frule (1) subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; x \\<in> {a..b};\n     x \\<in> {c..d}\\<rbrakk>\n    \\<Longrightarrow> b \\<le> d", "apply (rule classical)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; x \\<in> {a..b}; x \\<in> {c..d};\n     \\<not> b \\<le> d\\<rbrakk>\n    \\<Longrightarrow> b \\<le> d", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_subset_eq:\n  fixes a::\"'a::linorder\"\n  assumes non_empty: \"a \\<le> b\"\n  shows \"({a..b} \\<subseteq> {c..d}) = (c \\<le> a \\<and> b \\<le> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a..b} \\<subseteq> {c..d}) = (c \\<le> a \\<and> b \\<le> d)", "apply (insert non_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    ({a..b} \\<subseteq> {c..d}) = (c \\<le> a \\<and> b \\<le> d)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> b; {a..b} \\<subseteq> {c..d}\\<rbrakk>\n    \\<Longrightarrow> c \\<le> a \\<and> b \\<le> d\n 2. \\<lbrakk>a \\<le> b; c \\<le> a \\<and> b \\<le> d\\<rbrakk>\n    \\<Longrightarrow> {a..b} \\<subseteq> {c..d}", "apply (frule range_subset_lower [where x=a], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> b; {a..b} \\<subseteq> {c..d}; c \\<le> a\\<rbrakk>\n    \\<Longrightarrow> c \\<le> a \\<and> b \\<le> d\n 2. \\<lbrakk>a \\<le> b; c \\<le> a \\<and> b \\<le> d\\<rbrakk>\n    \\<Longrightarrow> {a..b} \\<subseteq> {c..d}", "apply (drule range_subset_upper [where x=a], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> b; c \\<le> a; b \\<le> d\\<rbrakk>\n    \\<Longrightarrow> c \\<le> a \\<and> b \\<le> d\n 2. \\<lbrakk>a \\<le> b; c \\<le> a \\<and> b \\<le> d\\<rbrakk>\n    \\<Longrightarrow> {a..b} \\<subseteq> {c..d}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<le> a \\<and> b \\<le> d\\<rbrakk>\n    \\<Longrightarrow> {a..b} \\<subseteq> {c..d}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_eq:\n  fixes a::\"'a::linorder\"\n  assumes non_empty: \"a \\<le> b\"\n  shows \"({a..b} = {c..d}) = (a = c \\<and> b = d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a..b} = {c..d}) = (a = c \\<and> b = d)", "by (metis atLeastatMost_subset_iff eq_iff non_empty)"], ["", "lemma range_strict_subset_eq:\n  fixes a::\"'a::linorder\"\n  assumes non_empty: \"a \\<le> b\"\n  shows \"({a..b} \\<subset> {c..d}) = (c \\<le> a \\<and> b \\<le> d \\<and> (a = c \\<longrightarrow> b \\<noteq> d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a..b} \\<subset> {c..d}) =\n    (c \\<le> a \\<and>\n     b \\<le> d \\<and> (a = c \\<longrightarrow> b \\<noteq> d))", "apply (insert non_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    ({a..b} \\<subset> {c..d}) =\n    (c \\<le> a \\<and>\n     b \\<le> d \\<and> (a = c \\<longrightarrow> b \\<noteq> d))", "apply (subst psubset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    ({a..b} \\<subseteq> {c..d} \\<and> {a..b} \\<noteq> {c..d}) =\n    (c \\<le> a \\<and>\n     b \\<le> d \\<and> (a = c \\<longrightarrow> b \\<noteq> d))", "apply (subst range_subset_eq, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    ((c \\<le> a \\<and> b \\<le> d) \\<and> {a..b} \\<noteq> {c..d}) =\n    (c \\<le> a \\<and>\n     b \\<le> d \\<and> (a = c \\<longrightarrow> b \\<noteq> d))", "apply (subst range_eq, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    ((c \\<le> a \\<and> b \\<le> d) \\<and> \\<not> (a = c \\<and> b = d)) =\n    (c \\<le> a \\<and>\n     b \\<le> d \\<and> (a = c \\<longrightarrow> b \\<noteq> d))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_subsetI:\n  fixes x :: \"'a :: order\"\n  assumes xX: \"X \\<le> x\"\n  and     yY: \"y \\<le> Y\"\n  shows   \"{x .. y} \\<subseteq> {X .. Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x..y} \\<subseteq> {X..Y}", "using xX yY"], ["proof (prove)\nusing this:\n  X \\<le> x\n  y \\<le> Y\n\ngoal (1 subgoal):\n 1. {x..y} \\<subseteq> {X..Y}", "by auto"], ["", "lemma set_False [simp]:\n  \"(set bs \\<subseteq> {False}) = (True \\<notin> set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set bs \\<subseteq> {False}) = (True \\<notin> set bs)", "by auto"], ["", "lemma int_not_emptyD:\n  \"A \\<inter> B \\<noteq> {} \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> x \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>x. x \\<in> A \\<and> x \\<in> B", "by (erule contrapos_np, clarsimp simp: disjoint_iff_not_equal)"], ["", "definition\n  sum_map :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('c \\<Rightarrow> 'd) \\<Rightarrow> 'a + 'c \\<Rightarrow> 'b + 'd\" where\n \"sum_map f g x \\<equiv> case x of Inl v \\<Rightarrow> Inl (f v) | Inr v' \\<Rightarrow> Inr (g v')\""], ["", "lemma sum_map_simps[simp]:\n  \"sum_map f g (Inl v) = Inl (f v)\"\n  \"sum_map f g (Inr w) = Inr (g w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_map f g (Inl v) = Inl (f v) &&& sum_map f g (Inr w) = Inr (g w)", "by (simp add: sum_map_def)+"], ["", "lemma if_Some_None_eq_None:\n  \"((if P then Some v else None) = None) = (\\<not> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then Some v else None) = None) = (\\<not> P)", "by simp"], ["", "lemma CollectPairFalse [iff]:\n  \"{(a,b). False} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). False} = {}", "by (simp add: split_def)"], ["", "lemma if_conj_dist:\n  \"((if b then w else x) \\<and> (if b then y else z) \\<and> X) =\n  ((if b then w \\<and> y else x \\<and> z) \\<and> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if b then w else x) \\<and> (if b then y else z) \\<and> X) =\n    ((if b then w \\<and> y else x \\<and> z) \\<and> X)", "by simp"], ["", "lemma if_P_True1:\n  \"Q \\<Longrightarrow> (if P then True else Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<Longrightarrow> if P then True else Q", "by simp"], ["", "lemma if_P_True2:\n  \"Q \\<Longrightarrow> (if P then Q else True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<Longrightarrow> if P then Q else True", "by simp"], ["", "lemmas nat_simps = diff_add_inverse2 diff_add_inverse"], ["", "lemmas nat_iffs = le_add1 le_add2"], ["", "lemma nat_min_simps:\n  \"(a::nat) \\<le> b \\<Longrightarrow> min b a = a\"\n  \"a \\<le> b \\<Longrightarrow> min a b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow> min b a = a) &&&\n    (a \\<le> b \\<Longrightarrow> min a b = a)", "by simp_all"], ["", "lemmas zadd_diff_inverse =\n  trans [OF diff_add_cancel [symmetric] add.commute]"], ["", "lemmas add_diff_cancel2 =\n  add.commute [THEN diff_eq_eq [THEN iffD2]]"], ["", "lemmas mcl = mult_cancel_left [THEN iffD1, THEN make_pos_rule]"], ["", "lemma pl_pl_rels: \"a + b = c + d \\<Longrightarrow> a \\<ge> c \\<and> b \\<le> d \\<or> a \\<le> c \\<and> b \\<ge> d\"\n  for a b c d :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = c + d \\<Longrightarrow>\n    c \\<le> a \\<and> b \\<le> d \\<or> a \\<le> c \\<and> d \\<le> b", "by arith"], ["", "lemmas pl_pl_rels' = add.commute [THEN [2] trans, THEN pl_pl_rels]"], ["", "lemma iszero_minus:\n  \\<open>iszero (- z) \\<longleftrightarrow> iszero z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. iszero (- z) = iszero z", "by (simp add: iszero_def)"], ["", "lemma diff_le_eq': \"a - b \\<le> c \\<longleftrightarrow> a \\<le> b + c\"\n  for a b c :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - b \\<le> c) = (a \\<le> b + c)", "by arith"], ["", "lemma zless2: \"0 < (2 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2", "by (fact zero_less_numeral)"], ["", "lemma zless2p: \"0 < (2 ^ n :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 ^ n", "by arith"], ["", "lemma zle2p: \"0 \\<le> (2 ^ n :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 ^ n", "by arith"], ["", "lemma ex_eq_or: \"(\\<exists>m. n = Suc m \\<and> (m = k \\<or> P m)) \\<longleftrightarrow> n = Suc k \\<or> (\\<exists>m. n = Suc m \\<and> P m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m. n = Suc m \\<and> (m = k \\<or> P m)) =\n    (n = Suc k \\<or> (\\<exists>m. n = Suc m \\<and> P m))", "by auto"], ["", "lemma power_minus_simp: \"0 < n \\<Longrightarrow> a ^ n = a * a ^ (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> a ^ n = a * a ^ (n - 1)", "by (auto dest: gr0_implies_Suc)"], ["", "lemma n2s_ths:\n  \\<open>2 + n = Suc (Suc n)\\<close>\n  \\<open>n + 2 = Suc (Suc n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + n = Suc (Suc n) &&& n + 2 = Suc (Suc n)", "by (fact add_2_eq_Suc add_2_eq_Suc')+"], ["", "lemma s2n_ths:\n  \\<open>Suc (Suc n) = 2 + n\\<close>\n  \\<open>Suc (Suc n) = n + 2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc n) = 2 + n &&& Suc (Suc n) = n + 2", "by simp_all"], ["", "lemma gt_or_eq_0: \"0 < y \\<or> 0 = y\"\n  for y :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<or> 0 = y", "by arith"], ["", "lemma sum_imp_diff: \"j = k + i \\<Longrightarrow> j - i = k\"\n  for k :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = k + i \\<Longrightarrow> j - i = k", "by simp"], ["", "lemma le_diff_eq': \"a \\<le> c - b \\<longleftrightarrow> b + a \\<le> c\"\n  for a b c :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> c - b) = (b + a \\<le> c)", "by arith"], ["", "lemma less_diff_eq': \"a < c - b \\<longleftrightarrow> b + a < c\"\n  for a b c :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < c - b) = (b + a < c)", "by arith"], ["", "lemma diff_less_eq': \"a - b < c \\<longleftrightarrow> a < b + c\"\n  for a b c :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - b < c) = (a < b + c)", "by arith"], ["", "lemma axxbyy: \"a + m + m = b + n + n \\<Longrightarrow> a = 0 \\<or> a = 1 \\<Longrightarrow> b = 0 \\<or> b = 1 \\<Longrightarrow> a = b \\<and> m = n\"\n  for a b m n :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + m + m = b + n + n; a = 0 \\<or> a = 1;\n     b = 0 \\<or> b = 1\\<rbrakk>\n    \\<Longrightarrow> a = b \\<and> m = n", "by arith"], ["", "lemma minus_eq: \"m - k = m \\<longleftrightarrow> k = 0 \\<or> m = 0\"\n  for k m :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m - k = m) = (k = 0 \\<or> m = 0)", "by arith"], ["", "lemma pl_pl_mm: \"a + b = c + d \\<Longrightarrow> a - c = d - b\"\n  for a b c d :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = c + d \\<Longrightarrow> a - c = d - b", "by arith"], ["", "lemmas pl_pl_mm' = add.commute [THEN [2] trans, THEN pl_pl_mm]"], ["", "lemma less_le_mult': \"w * c < b * c \\<Longrightarrow> 0 \\<le> c \\<Longrightarrow> (w + 1) * c \\<le> b * c\"\n  for b c w :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> (w + 1) * c \\<le> b * c", "apply (rule mult_right_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> w + 1 \\<le> b\n 2. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> 0 \\<le> c", "apply (rule zless_imp_add1_zle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> w < b\n 2. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> 0 \\<le> c", "apply (erule (1) mult_right_less_imp_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> 0 \\<le> c", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma less_le_mult: \"w * c < b * c \\<Longrightarrow> 0 \\<le> c \\<Longrightarrow> w * c + c \\<le> b * c\"\n  for b c w :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> w * c + c \\<le> b * c", "using less_le_mult' [of w c b]"], ["proof (prove)\nusing this:\n  \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n  \\<Longrightarrow> (w + 1) * c \\<le> b * c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> w * c + c \\<le> b * c", "by (simp add: algebra_simps)"], ["", "lemmas less_le_mult_minus = iffD2 [OF le_diff_eq less_le_mult,\n  simplified left_diff_distrib]"], ["", "lemma gen_minus: \"0 < n \\<Longrightarrow> f n = f (Suc (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> f n = f (Suc (n - 1))", "by auto"], ["", "lemma mpl_lem: \"j \\<le> i \\<Longrightarrow> k < j \\<Longrightarrow> i - j + k < i\"\n  for i j k :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; k < j\\<rbrakk> \\<Longrightarrow> i - j + k < i", "by arith"], ["", "lemmas dme = div_mult_mod_eq"], ["", "lemmas dtle = div_times_less_eq_dividend"], ["", "lemmas th2 = order_trans [OF order_refl [THEN [2] mult_le_mono] div_times_less_eq_dividend]"], ["", "lemmas sdl = div_nat_eqI"], ["", "lemma given_quot: \"f > 0 \\<Longrightarrow> (f * l + (f - 1)) div f = l\"\n  for f l :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < f \\<Longrightarrow> (f * l + (f - 1)) div f = l", "by (rule div_nat_eqI) (simp_all)"], ["", "lemma given_quot_alt: \"f > 0 \\<Longrightarrow> (l * f + f - Suc 0) div f = l\"\n  for f l :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < f \\<Longrightarrow> (l * f + f - Suc 0) div f = l", "apply (frule given_quot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < f; (f * ?l + (f - 1)) div f = ?l\\<rbrakk>\n    \\<Longrightarrow> (l * f + f - Suc 0) div f = l", "apply (rule trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < f; (f * ?l + (f - 1)) div f = ?l\\<rbrakk>\n    \\<Longrightarrow> (l * f + f - Suc 0) div f = ?s2\n 2. \\<lbrakk>0 < f; (f * ?l + (f - 1)) div f = ?l\\<rbrakk>\n    \\<Longrightarrow> ?s2 = l", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < f; (f * ?l + (f - 1)) div f = ?l\\<rbrakk>\n    \\<Longrightarrow> ?s2 = l\n 2. \\<lbrakk>0 < f; (f * ?l + (f - 1)) div f = ?l\\<rbrakk>\n    \\<Longrightarrow> (l * f + f - Suc 0) div f = ?s2", "apply (erule asm_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < f; (f * l + (f - 1)) div f = l\\<rbrakk>\n    \\<Longrightarrow> (l * f + f - Suc 0) div f = (f * l + (f - 1)) div f", "apply (rule_tac f=\"\\<lambda>n. n div f\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < f; (f * l + (f - 1)) div f = l\\<rbrakk>\n    \\<Longrightarrow> l * f + f - Suc 0 = f * l + (f - 1)", "apply (simp add : ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma x_power_minus_1:\n  fixes x :: \"'a :: {ab_group_add, power, numeral, one}\"\n  shows \"x + (2::'a) ^ n - (1::'a) = x + (2 ^ n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) ^ n - (1::'a) = x + ((2::'a) ^ n - (1::'a))", "by simp"], ["", "lemma nat_diff_add:\n  fixes i :: nat\n  shows \"\\<lbrakk> i + j = k \\<rbrakk> \\<Longrightarrow> i = k - j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + j = k \\<Longrightarrow> i = k - j", "by arith"], ["", "lemma pow_2_gt: \"n \\<ge> 2 \\<Longrightarrow> (2::int) < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow> 2 < 2 ^ n", "by (induct n) auto"], ["", "lemma sum_to_zero:\n  \"(a :: 'a :: ring) + b = 0 \\<Longrightarrow> a = (- b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = (0::'a) \\<Longrightarrow> a = - b", "by (drule arg_cong[where f=\"\\<lambda> x. x - a\"], simp)"], ["", "lemma arith_is_1:\n  \"\\<lbrakk> x \\<le> Suc 0; x > 0 \\<rbrakk> \\<Longrightarrow> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> Suc 0; 0 < x\\<rbrakk> \\<Longrightarrow> x = 1", "by arith"], ["", "lemma suc_le_pow_2:\n  \"1 < (n::nat) \\<Longrightarrow> Suc n < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> Suc n < 2 ^ n", "by (induct n; clarsimp)\n     (case_tac \"n = 1\"; clarsimp)"], ["", "lemma nat_le_Suc_less_imp:\n  \"x < y \\<Longrightarrow> x \\<le> y - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> x \\<le> y - Suc 0", "by arith"], ["", "lemma power_sub_int:\n  \"\\<lbrakk> m \\<le> n; 0 < b \\<rbrakk> \\<Longrightarrow> b ^ n div b ^ m = (b ^ (n - m) :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; 0 < b\\<rbrakk>\n    \\<Longrightarrow> b ^ n div b ^ m = b ^ (n - m)", "apply (subgoal_tac \"\\<exists>n'. n = m + n'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<le> n; 0 < b; \\<exists>n'. n = m + n'\\<rbrakk>\n    \\<Longrightarrow> b ^ n div b ^ m = b ^ (n - m)\n 2. \\<lbrakk>m \\<le> n; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'. n = m + n'", "apply (clarsimp simp: power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'. n = m + n'", "apply (rule exI[where x=\"n - m\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; 0 < b\\<rbrakk> \\<Longrightarrow> n = m + (n - m)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nat_Suc_less_le_imp:\n  \"(k::nat) < Suc n \\<Longrightarrow> k \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < Suc n \\<Longrightarrow> k \\<le> n", "by auto"], ["", "lemma nat_add_less_by_max:\n  \"\\<lbrakk> (x::nat) \\<le> xmax ; y < k - xmax \\<rbrakk> \\<Longrightarrow> x + y < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> xmax; y < k - xmax\\<rbrakk> \\<Longrightarrow> x + y < k", "by simp"], ["", "lemma nat_le_Suc_less:\n  \"0 < y \\<Longrightarrow> (x \\<le> y - Suc 0) = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> (x \\<le> y - Suc 0) = (x < y)", "by arith"], ["", "lemma nat_power_minus_less:\n  \"a < 2 ^ (x - n) \\<Longrightarrow> (a :: nat) < 2 ^ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < 2 ^ (x - n) \\<Longrightarrow> a < 2 ^ x", "by (erule order_less_le_trans) simp"], ["", "lemma less_le_mult_nat':\n  \"w * c < b * c ==> 0 \\<le> c ==> Suc w * c \\<le> b * (c::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> Suc w * c \\<le> b * c", "apply (rule mult_right_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> Suc w \\<le> b\n 2. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> 0 \\<le> c", "apply (rule Suc_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> w < b\n 2. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> 0 \\<le> c", "apply (erule (1) mult_right_less_imp_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk> \\<Longrightarrow> 0 \\<le> c", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma less_le_mult_nat:\n  \\<open>0 < c \\<and> w < b \\<Longrightarrow> c + w * c \\<le> b * c\\<close> for b c w :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<and> w < b \\<Longrightarrow> c + w * c \\<le> b * c", "using less_le_mult_nat' [of w c b]"], ["proof (prove)\nusing this:\n  \\<lbrakk>w * c < b * c; 0 \\<le> c\\<rbrakk>\n  \\<Longrightarrow> Suc w * c \\<le> b * c\n\ngoal (1 subgoal):\n 1. 0 < c \\<and> w < b \\<Longrightarrow> c + w * c \\<le> b * c", "by simp"], ["", "lemma p_assoc_help:\n  fixes p :: \"'a::{ring,power,numeral,one}\"\n  shows \"p + 2^sz - 1 = p + (2^sz - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + (2::'a) ^ sz - (1::'a) = p + ((2::'a) ^ sz - (1::'a))", "by simp"], ["", "lemma pow_mono_leq_imp_lt:\n  \"x \\<le> y \\<Longrightarrow> x < 2 ^ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x < 2 ^ y", "by (simp add: le_less_trans)"], ["", "lemma small_powers_of_2:\n  \"x \\<ge> 3 \\<Longrightarrow> x < 2 ^ (x - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> x \\<Longrightarrow> x < 2 ^ (x - 1)", "by (induct x; simp add: suc_le_pow_2)"], ["", "lemma nat_less_power_trans2:\n  fixes n :: nat\n  shows \"\\<lbrakk>n < 2 ^ (m - k); k \\<le> m\\<rbrakk> \\<Longrightarrow> n * 2 ^ k  < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m\\<rbrakk>\n    \\<Longrightarrow> n * 2 ^ k < 2 ^ m", "by (subst mult.commute, erule (1) nat_less_power_trans)"], ["", "lemma nat_move_sub_le: \"(a::nat) + b \\<le> c \\<Longrightarrow> a \\<le> c - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b \\<le> c \\<Longrightarrow> a \\<le> c - b", "by arith"], ["", "lemma plus_minus_one_rewrite:\n  \"v + (- 1 :: ('a :: {ring, one, uminus})) \\<equiv> v - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v + - (1::'a) \\<equiv> v - (1::'a)", "by (simp add: field_simps)"], ["", "lemma Suc_0_lt_2p_len_of: \"Suc 0 < 2 ^ LENGTH('a :: len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < 2 ^ LENGTH('a)", "by (metis One_nat_def len_gt_0 lessI numeral_2_eq_2 one_less_power)"], ["", "end"]]}