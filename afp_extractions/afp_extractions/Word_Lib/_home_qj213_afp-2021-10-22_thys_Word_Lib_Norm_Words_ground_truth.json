{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Norm_Words.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma neg_num_bintr:\n  \"(- numeral x :: 'a::len word) =\n  word_of_int (bintrunc (LENGTH('a)) (-numeral x))\"", "lemma minus_one_norm:\n  \"(-1 :: 'a :: len word) = of_nat (2 ^ LENGTH('a) - 1)\"", "lemmas minus_one_norm_num =\n  minus_one_norm [where 'a=\"'b::len bit0\"] minus_one_norm [where 'a=\"'b::len0 bit1\"]", "lemma \"f (7 :: 2 word) = f 3\"", "lemma \"f 7 = f (3 :: 2 word)\"", "lemma \"f (-2) = f (21 + 1 :: 3 word)\"", "lemma \"f (-2) = f (13 + 1 :: 'a::len word)\"", "lemma \"f (-2) = f (0xFFFFFFFE :: 32 word)\"", "lemma \"(-1 :: 2 word) = 3\"", "lemma \"f (-2) = f (0xFFFFFFFE :: 32 signed word)\"", "lemma \"f (-1) = f (15 :: 4 word)\"", "lemma \"f (-1) = f (7 :: 3 word)\"", "lemma \"f (-1) = f (0xFFFF :: 16 word)\"", "lemma \"f (-1) = f (0xFFFF + 1 :: 'a::len word)\""], "translations": [["", "lemma neg_num_bintr:\n  \"(- numeral x :: 'a::len word) =\n  word_of_int (bintrunc (LENGTH('a)) (-numeral x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral x = word_of_int (take_bit LENGTH('a) (- numeral x))", "by transfer simp"], ["", "ML \\<open>\n  fun is_refl (Const (@{const_name Pure.eq}, _) $ x $ y) = (x = y)\n    | is_refl _ = false;\n\n  fun signed_dest_wordT (Type (@{type_name word}, [Type (@{type_name signed}, [T])])) = Word_Lib.dest_binT T\n    | signed_dest_wordT T = Word_Lib.dest_wordT T\n\n  fun typ_size_of t = signed_dest_wordT (type_of (Thm.term_of t));\n\n  fun num_len (Const (@{const_name Num.Bit0}, _) $ n) = num_len n + 1\n    | num_len (Const (@{const_name Num.Bit1}, _) $ n) = num_len n + 1\n    | num_len (Const (@{const_name Num.One}, _)) = 1\n    | num_len (Const (@{const_name numeral}, _) $ t) = num_len t\n    | num_len (Const (@{const_name uminus}, _) $ t) = num_len t\n    | num_len t = raise TERM (\"num_len\", [t])\n\n  fun unsigned_norm is_neg _ ctxt ct =\n  (if is_neg orelse num_len (Thm.term_of ct) > typ_size_of ct then let\n      val btr = if is_neg\n                then @{thm neg_num_bintr} else @{thm num_abs_bintr}\n      val th = [Thm.reflexive ct, mk_eq btr] MRS transitive_thm\n\n      (* will work in context of theory Word as well *)\n      val ss = simpset_of (@{context} addsimps @{thms bintrunc_numeral})\n      val cnv = simplify (put_simpset ss ctxt) th\n    in if is_refl (Thm.prop_of cnv) then NONE else SOME cnv end\n    else NONE)\n  handle TERM (\"num_len\", _) => NONE\n       | TYPE (\"dest_binT\", _, _) => NONE\n\\<close>"], ["", "simproc_setup\n  unsigned_norm (\"numeral n::'a::len word\") = \\<open>unsigned_norm false\\<close>"], ["", "simproc_setup\n  unsigned_norm_neg0 (\"-numeral (num.Bit0 num)::'a::len word\") = \\<open>unsigned_norm true\\<close>"], ["", "simproc_setup\n  unsigned_norm_neg1 (\"-numeral (num.Bit1 num)::'a::len word\") = \\<open>unsigned_norm true\\<close>"], ["", "lemma minus_one_norm:\n  \"(-1 :: 'a :: len word) = of_nat (2 ^ LENGTH('a) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 = word_of_nat (2 ^ LENGTH('a) - 1)", "by (simp add:of_nat_diff)"], ["", "lemmas minus_one_norm_num =\n  minus_one_norm [where 'a=\"'b::len bit0\"] minus_one_norm [where 'a=\"'b::len0 bit1\"]"], ["", "lemma \"f (7 :: 2 word) = f 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 7 = f 3", "by simp"], ["", "lemma \"f 7 = f (3 :: 2 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 7 = f 3", "by simp"], ["", "lemma \"f (-2) = f (21 + 1 :: 3 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 2) = f (21 + 1)", "by simp"], ["", "lemma \"f (-2) = f (13 + 1 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 2) = f (13 + 1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (word_of_int (take_bit LENGTH('a) (- 2))) = f 14", "(* does not touch generic word length *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (word_of_int (take_bit LENGTH('a) (- 2))) = f 14", "oops"], ["", "lemma \"f (-2) = f (0xFFFFFFFE :: 32 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 2) = f 4294967294", "by simp"], ["", "lemma \"(-1 :: 2 word) = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 = 3", "by simp"], ["", "lemma \"f (-2) = f (0xFFFFFFFE :: 32 signed word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 2) = f 4294967294", "by simp"], ["", "text \\<open>\n  We leave @{term \"-1\"} untouched by default, because it is often useful\n  and its normal form can be large.\n  To include it in the normalisation, add @{thm [source] minus_one_norm_num}.\n  The additional normalisation is restricted to concrete numeral word lengths,\n  like the rest.\n\\<close>"], ["", "context\n  notes minus_one_norm_num [simp]\nbegin"], ["", "lemma \"f (-1) = f (15 :: 4 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 1) = f 15", "by simp"], ["", "lemma \"f (-1) = f (7 :: 3 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 1) = f 7", "by simp"], ["", "lemma \"f (-1) = f (0xFFFF :: 16 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 1) = f 65535", "by simp"], ["", "lemma \"f (-1) = f (0xFFFF + 1 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 1) = f (65535 + 1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 1) = f 65536", "(* does not touch generic -1 *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (- 1) = f 65536", "oops"], ["", "end"], ["", "end"]]}