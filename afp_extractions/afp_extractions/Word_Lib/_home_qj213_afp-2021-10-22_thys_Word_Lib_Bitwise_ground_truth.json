{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Bitwise.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma carry_simps:\n  \"carry True a b = (a \\<or> b)\"\n  \"carry a True b = (a \\<or> b)\"\n  \"carry a b True = (a \\<or> b)\"\n  \"carry False a b = (a \\<and> b)\"\n  \"carry a False b = (a \\<and> b)\"\n  \"carry a b False = (a \\<and> b)\"", "lemma xor3_simps:\n  \"xor3 True a b = (a = b)\"\n  \"xor3 a True b = (a = b)\"\n  \"xor3 a b True = (a = b)\"\n  \"xor3 False a b = (a \\<noteq> b)\"\n  \"xor3 a False b = (a \\<noteq> b)\"\n  \"xor3 a b False = (a \\<noteq> b)\"", "lemma bl_word_sub: \"to_bl (x - y) = to_bl (x + (- y))\"", "lemma rbl_word_1: \"rev (to_bl (1 :: 'a::len word)) = takefill False (LENGTH('a)) [True]\"", "lemma rbl_word_if: \"rev (to_bl (if P then x else y)) = map2 (If P) (rev (to_bl x)) (rev (to_bl y))\"", "lemma rbl_add_carry_Cons:\n  \"(if car then rbl_succ else id) (rbl_add (x # xs) (y # ys)) =\n    xor3 x y car # (if carry x y car then rbl_succ else id) (rbl_add xs ys)\"", "lemma rbl_add_suc_carry_fold:\n  \"length xs = length ys \\<Longrightarrow>\n    \\<forall>car. (if car then rbl_succ else id) (rbl_add xs ys) =\n      (foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car)) (zip xs ys) (\\<lambda>_. [])) car\"", "lemma to_bl_plus_carry:\n  \"to_bl (x + y) =\n    rev (foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n      (rev (zip (to_bl x) (to_bl y))) (\\<lambda>_. []) False)\"", "lemma rbl_plus_simps:\n  \"rbl_plus cin (x # xs) (y # ys) = xor3 x y cin # rbl_plus (carry x y cin) xs ys\"\n  \"rbl_plus cin [] ys = []\"\n  \"rbl_plus cin xs [] = []\"", "lemma rbl_word_plus: \"rev (to_bl (x + y)) = rbl_plus False (rev (to_bl x)) (rev (to_bl y))\"", "lemma rbl_succ2_simps:\n  \"rbl_succ2 b [] = []\"\n  \"rbl_succ2 b (x # xs) = (b \\<noteq> x) # rbl_succ2 (x \\<and> b) xs\"", "lemma twos_complement: \"- x = word_succ (NOT x)\"", "lemma rbl_word_neg: \"rev (to_bl (- x)) = rbl_succ2 True (map Not (rev (to_bl x)))\"\n  for x :: \\<open>'a::len word\\<close>", "lemma rbl_word_cat:\n  \"rev (to_bl (word_cat x y :: 'a::len word)) =\n    takefill False (LENGTH('a)) (rev (to_bl y) @ rev (to_bl x))\"", "lemma rbl_word_slice:\n  \"rev (to_bl (slice n w :: 'a::len word)) =\n    takefill False (LENGTH('a)) (drop n (rev (to_bl w)))\"", "lemma rbl_word_ucast:\n  \"rev (to_bl (ucast x :: 'a::len word)) = takefill False (LENGTH('a)) (rev (to_bl x))\"", "lemma rbl_shiftl:\n  \"rev (to_bl (w << n)) = takefill False (size w) (replicate n False @ rev (to_bl w))\"", "lemma rbl_shiftr:\n  \"rev (to_bl (w >> n)) = takefill False (size w) (drop n (rev (to_bl w)))\"", "lemma drop_nonempty_simps:\n  \"drop_nonempty v (Suc n) (x # xs) = drop_nonempty x n xs\"\n  \"drop_nonempty v 0 (x # xs) = (x # xs)\"\n  \"drop_nonempty v n [] = [v]\"", "lemma takefill_last_simps:\n  \"takefill_last z (Suc n) (x # xs) = x # takefill_last x n xs\"\n  \"takefill_last z 0 xs = []\"\n  \"takefill_last z n [] = replicate n z\"", "lemma rbl_sshiftr:\n  \"rev (to_bl (w >>> n)) = takefill_last False (size w) (drop_nonempty False n (rev (to_bl w)))\"", "lemma nth_word_of_int:\n  \"(word_of_int x :: 'a::len word) !! n = (n < LENGTH('a) \\<and> bin_nth x n)\"", "lemma nth_scast:\n  \"(scast (x :: 'a::len word) :: 'b::len word) !! n =\n    (n < LENGTH('b) \\<and>\n    (if n < LENGTH('a) - 1 then x !! n\n     else x !! (LENGTH('a) - 1)))\"", "lemma rbl_word_scast:\n  \"rev (to_bl (scast x :: 'a::len word)) = takefill_last False (LENGTH('a)) (rev (to_bl x))\"", "lemma rbl_mul_simps:\n  \"rbl_mul (x # xs) ys = rbl_plus False (map ((\\<and>) x) ys) (False # rbl_mul xs ys)\"\n  \"rbl_mul [] ys = []\"", "lemma takefill_le2: \"length xs \\<le> n \\<Longrightarrow> takefill x m (takefill x n xs) = takefill x m xs\"", "lemma take_rbl_plus: \"\\<forall>n b. take n (rbl_plus b xs ys) = rbl_plus b (take n xs) (take n ys)\"", "lemma word_rbl_mul_induct:\n  \"length xs \\<le> size y \\<Longrightarrow>\n    rbl_mul xs (rev (to_bl y)) = take (length xs) (rev (to_bl (of_bl (rev xs) * y)))\"\n  for y :: \"'a::len word\"", "lemma rbl_word_mul: \"rev (to_bl (x * y)) = rbl_mul (rev (to_bl x)) (rev (to_bl y))\"\n  for x :: \"'a::len word\"", "lemma rev_bl_order_simps:\n  \"rev_bl_order F [] [] = F\"\n  \"rev_bl_order F (x # xs) (y # ys) = rev_bl_order ((y \\<and> \\<not> x) \\<or> ((y \\<or> \\<not> x) \\<and> F)) xs ys\"", "lemma rev_bl_order_rev_simp:\n  \"length xs = length ys \\<Longrightarrow>\n   rev_bl_order F (xs @ [x]) (ys @ [y]) = ((y \\<and> \\<not> x) \\<or> ((y \\<or> \\<not> x) \\<and> rev_bl_order F xs ys))\"", "lemma rev_bl_order_bl_to_bin:\n  \"length xs = length ys \\<Longrightarrow>\n    rev_bl_order True xs ys = (bl_to_bin (rev xs) \\<le> bl_to_bin (rev ys)) \\<and>\n    rev_bl_order False xs ys = (bl_to_bin (rev xs) < bl_to_bin (rev ys))\"", "lemma word_le_rbl: \"x \\<le> y \\<longleftrightarrow> rev_bl_order True (rev (to_bl x)) (rev (to_bl y))\"\n  for x y :: \"'a::len word\"", "lemma word_less_rbl: \"x < y \\<longleftrightarrow> rev_bl_order False (rev (to_bl x)) (rev (to_bl y))\"\n  for x y :: \"'a::len word\"", "lemma map_last_simps:\n  \"map_last f [] = []\"\n  \"map_last f [x] = [f x]\"\n  \"map_last f (x # y # zs) = x # map_last f (y # zs)\"", "lemma word_sle_rbl:\n  \"x <=s y \\<longleftrightarrow> rev_bl_order True (map_last Not (rev (to_bl x))) (map_last Not (rev (to_bl y)))\"", "lemma word_sless_rbl:\n  \"x <s y \\<longleftrightarrow> rev_bl_order False (map_last Not (rev (to_bl x))) (map_last Not (rev (to_bl y)))\"", "lemma rev_bin_to_bl_simps:\n  \"rev (bin_to_bl 0 x) = []\"\n  \"rev (bin_to_bl (Suc n) (numeral (num.Bit0 nm))) = False # rev (bin_to_bl n (numeral nm))\"\n  \"rev (bin_to_bl (Suc n) (numeral (num.Bit1 nm))) = True # rev (bin_to_bl n (numeral nm))\"\n  \"rev (bin_to_bl (Suc n) (numeral (num.One))) = True # replicate n False\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit0 nm))) = False # rev (bin_to_bl n (- numeral nm))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit1 nm))) =\n    True # rev (bin_to_bl n (- numeral (nm + num.One)))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.One))) = True # replicate n True\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit0 nm + num.One))) =\n    True # rev (bin_to_bl n (- numeral (nm + num.One)))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit1 nm + num.One))) =\n    False # rev (bin_to_bl n (- numeral (nm + num.One)))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.One + num.One))) =\n    False # rev (bin_to_bl n (- numeral num.One))\"", "lemma to_bl_upt: \"to_bl x = rev (map ((!!) x) [0 ..< size x])\"", "lemma rev_to_bl_upt: \"rev (to_bl x) = map ((!!) x) [0 ..< size x]\"", "lemma upt_eq_list_intros:\n  \"j \\<le> i \\<Longrightarrow> [i ..< j] = []\"\n  \"i = x \\<Longrightarrow> x < j \\<Longrightarrow> [x + 1 ..< j] = xs \\<Longrightarrow> [i ..< j] = (x # xs)\"", "lemma if_bool_simps:\n  \"If p True y = (p \\<or> y) \\<and> If p False y = (\\<not> p \\<and> y) \\<and>\n    If p y True = (p \\<longrightarrow> y) \\<and> If p y False = (p \\<and> y)\""], "translations": [["", "lemma carry_simps:\n  \"carry True a b = (a \\<or> b)\"\n  \"carry a True b = (a \\<or> b)\"\n  \"carry a b True = (a \\<or> b)\"\n  \"carry False a b = (a \\<and> b)\"\n  \"carry a False b = (a \\<and> b)\"\n  \"carry a b False = (a \\<and> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (carry True a b = (a \\<or> b) &&&\n     carry a True b = (a \\<or> b) &&& carry a b True = (a \\<or> b)) &&&\n    carry False a b = (a \\<and> b) &&&\n    carry a False b = (a \\<and> b) &&& carry a b False = (a \\<and> b)", "by (auto simp add: carry_def)"], ["", "lemma xor3_simps:\n  \"xor3 True a b = (a = b)\"\n  \"xor3 a True b = (a = b)\"\n  \"xor3 a b True = (a = b)\"\n  \"xor3 False a b = (a \\<noteq> b)\"\n  \"xor3 a False b = (a \\<noteq> b)\"\n  \"xor3 a b False = (a \\<noteq> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xor3 True a b = (a = b) &&&\n     xor3 a True b = (a = b) &&& xor3 a b True = (a = b)) &&&\n    xor3 False a b = (a \\<noteq> b) &&&\n    xor3 a False b = (a \\<noteq> b) &&& xor3 a b False = (a \\<noteq> b)", "by (simp_all add: xor3_def)"], ["", "text \\<open>Breaking up word equalities into equalities on their\n  bit lists. Equalities are generated and manipulated in the\n  reverse order to \\<^const>\\<open>to_bl\\<close>.\\<close>"], ["", "lemma bl_word_sub: \"to_bl (x - y) = to_bl (x + (- y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (x - y) = to_bl (x + - y)", "by simp"], ["", "lemma rbl_word_1: \"rev (to_bl (1 :: 'a::len word)) = takefill False (LENGTH('a)) [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl 1) = takefill False LENGTH('a) [True]", "apply (rule_tac s=\"rev (to_bl (word_succ (0 :: 'a word)))\" in trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rev (to_bl 1) = rev (to_bl (word_succ 0))\n 2. rev (to_bl (word_succ 0)) = takefill False LENGTH('a) [True]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (word_succ 0)) = takefill False LENGTH('a) [True]", "apply (simp only: rtb_rbl_ariths(1)[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_succ (rev (to_bl 0)) = takefill False LENGTH('a) [True]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_succ (replicate LENGTH('a) False) = takefill False LENGTH('a) [True]", "apply (case_tac \"LENGTH('a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) = 0 \\<Longrightarrow>\n    rbl_succ (replicate LENGTH('a) False) = takefill False LENGTH('a) [True]\n 2. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       rbl_succ (replicate LENGTH('a) False) =\n       takefill False LENGTH('a) [True]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       rbl_succ (replicate LENGTH('a) False) =\n       takefill False LENGTH('a) [True]", "apply (simp add: takefill_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_word_if: \"rev (to_bl (if P then x else y)) = map2 (If P) (rev (to_bl x)) (rev (to_bl y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (if P then x else y)) =\n    map2 (If P) (rev (to_bl x)) (rev (to_bl y))", "by (simp add: split_def)"], ["", "lemma rbl_add_carry_Cons:\n  \"(if car then rbl_succ else id) (rbl_add (x # xs) (y # ys)) =\n    xor3 x y car # (if carry x y car then rbl_succ else id) (rbl_add xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if car then rbl_succ else id) (rbl_add (x # xs) (y # ys)) =\n    xor3 x y car # (if carry x y car then rbl_succ else id) (rbl_add xs ys)", "by (simp add: carry_def xor3_def)"], ["", "lemma rbl_add_suc_carry_fold:\n  \"length xs = length ys \\<Longrightarrow>\n    \\<forall>car. (if car then rbl_succ else id) (rbl_add xs ys) =\n      (foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car)) (zip xs ys) (\\<lambda>_. [])) car\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    \\<forall>car.\n       (if car then rbl_succ else id) (rbl_add xs ys) =\n       foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n        (zip xs ys) (\\<lambda>_. []) car", "apply (erule list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>car.\n       (if car then rbl_succ else id) (rbl_add [] []) =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>res car. xor3 x y car # res (carry x y car))\n        (zip [] []) (\\<lambda>_. []) car\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>car.\n           (if car then rbl_succ else id) (rbl_add xs ys) =\n           foldr\n            (\\<lambda>a.\n                case a of\n                (x, y) \\<Rightarrow>\n                  \\<lambda>res car. xor3 x y car # res (carry x y car))\n            (zip xs ys) (\\<lambda>_. []) car\\<rbrakk>\n       \\<Longrightarrow> \\<forall>car.\n                            (if car then rbl_succ else id)\n                             (rbl_add (x # xs) (y # ys)) =\n                            foldr\n                             (\\<lambda>a.\n                                 case a of\n                                 (x, y) \\<Rightarrow>\n                                   \\<lambda>res car.\nxor3 x y car # res (carry x y car))\n                             (zip (x # xs) (y # ys)) (\\<lambda>_. []) car", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>car.\n           (if car then rbl_succ else id) (rbl_add xs ys) =\n           foldr\n            (\\<lambda>a.\n                case a of\n                (x, y) \\<Rightarrow>\n                  \\<lambda>res car. xor3 x y car # res (carry x y car))\n            (zip xs ys) (\\<lambda>_. []) car\\<rbrakk>\n       \\<Longrightarrow> \\<forall>car.\n                            (if car then rbl_succ else id)\n                             (rbl_add (x # xs) (y # ys)) =\n                            foldr\n                             (\\<lambda>a.\n                                 case a of\n                                 (x, y) \\<Rightarrow>\n                                   \\<lambda>res car.\nxor3 x y car # res (carry x y car))\n                             (zip (x # xs) (y # ys)) (\\<lambda>_. []) car", "apply (simp only: rbl_add_carry_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>car.\n           (if car then rbl_succ else id) (rbl_add xs ys) =\n           foldr\n            (\\<lambda>a.\n                case a of\n                (x, y) \\<Rightarrow>\n                  \\<lambda>res car. xor3 x y car # res (carry x y car))\n            (zip xs ys) (\\<lambda>_. []) car\\<rbrakk>\n       \\<Longrightarrow> \\<forall>car.\n                            xor3 x y car #\n                            foldr\n                             (\\<lambda>a.\n                                 case a of\n                                 (x, y) \\<Rightarrow>\n                                   \\<lambda>res car.\nxor3 x y car # res (carry x y car))\n                             (zip xs ys) (\\<lambda>_. []) (carry x y car) =\n                            foldr\n                             (\\<lambda>a.\n                                 case a of\n                                 (x, y) \\<Rightarrow>\n                                   \\<lambda>res car.\nxor3 x y car # res (carry x y car))\n                             (zip (x # xs) (y # ys)) (\\<lambda>_. []) car", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_bl_plus_carry:\n  \"to_bl (x + y) =\n    rev (foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n      (rev (zip (to_bl x) (to_bl y))) (\\<lambda>_. []) False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (x + y) =\n    rev (foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n          (rev (zip (to_bl x) (to_bl y))) (\\<lambda>_. []) False)", "using rbl_add_suc_carry_fold[where xs=\"rev (to_bl x)\" and ys=\"rev (to_bl y)\"]"], ["proof (prove)\nusing this:\n  length (rev (to_bl x)) = length (rev (to_bl y)) \\<Longrightarrow>\n  \\<forall>car.\n     (if car then rbl_succ else id)\n      (rbl_add (rev (to_bl x)) (rev (to_bl y))) =\n     foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n      (zip (rev (to_bl x)) (rev (to_bl y))) (\\<lambda>_. []) car\n\ngoal (1 subgoal):\n 1. to_bl (x + y) =\n    rev (foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n          (rev (zip (to_bl x) (to_bl y))) (\\<lambda>_. []) False)", "apply (simp add: word_add_rbl[OF refl refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>car.\n       (if car then rbl_succ else id)\n        (rbl_add (rev (to_bl x)) (rev (to_bl y))) =\n       foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n        (zip (rev (to_bl x)) (rev (to_bl y))) (\\<lambda>_. [])\n        car \\<Longrightarrow>\n    rbl_add (rev (to_bl x)) (rev (to_bl y)) =\n    foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n     (rev (zip (to_bl x) (to_bl y))) (\\<lambda>_. []) False", "apply (drule_tac x=False in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if False then rbl_succ else id)\n     (rbl_add (rev (to_bl x)) (rev (to_bl y))) =\n    foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n     (zip (rev (to_bl x)) (rev (to_bl y))) (\\<lambda>_. [])\n     False \\<Longrightarrow>\n    rbl_add (rev (to_bl x)) (rev (to_bl y)) =\n    foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n     (rev (zip (to_bl x) (to_bl y))) (\\<lambda>_. []) False", "apply (simp add: zip_rev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"rbl_plus cin xs ys =\n  foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car)) (zip xs ys) (\\<lambda>_. []) cin\""], ["", "lemma rbl_plus_simps:\n  \"rbl_plus cin (x # xs) (y # ys) = xor3 x y cin # rbl_plus (carry x y cin) xs ys\"\n  \"rbl_plus cin [] ys = []\"\n  \"rbl_plus cin xs [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_plus cin (x # xs) (y # ys) =\n    xor3 x y cin # rbl_plus (carry x y cin) xs ys &&&\n    rbl_plus cin [] ys = [] &&& rbl_plus cin xs [] = []", "by (simp_all add: rbl_plus_def)"], ["", "lemma rbl_word_plus: \"rev (to_bl (x + y)) = rbl_plus False (rev (to_bl x)) (rev (to_bl y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (x + y)) = rbl_plus False (rev (to_bl x)) (rev (to_bl y))", "by (simp add: rbl_plus_def to_bl_plus_carry zip_rev)"], ["", "definition \"rbl_succ2 b xs = (if b then rbl_succ xs else xs)\""], ["", "lemma rbl_succ2_simps:\n  \"rbl_succ2 b [] = []\"\n  \"rbl_succ2 b (x # xs) = (b \\<noteq> x) # rbl_succ2 (x \\<and> b) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_succ2 b [] = [] &&&\n    rbl_succ2 b (x # xs) = (b \\<noteq> x) # rbl_succ2 (x \\<and> b) xs", "by (simp_all add: rbl_succ2_def)"], ["", "lemma twos_complement: \"- x = word_succ (NOT x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x = word_succ (NOT x)", "using arg_cong[OF word_add_not[where x=x], where f=\"\\<lambda>a. a - x + 1\"]"], ["proof (prove)\nusing this:\n  x + NOT x - x + 1 = - 1 - x + 1\n\ngoal (1 subgoal):\n 1. - x = word_succ (NOT x)", "by (simp add: word_succ_p1 word_sp_01[unfolded word_succ_p1] del: word_add_not)"], ["", "lemma rbl_word_neg: \"rev (to_bl (- x)) = rbl_succ2 True (map Not (rev (to_bl x)))\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (- x)) = rbl_succ2 True (map Not (rev (to_bl x)))", "by (simp add: twos_complement word_succ_rbl[OF refl] bl_word_not rev_map rbl_succ2_def)"], ["", "lemma rbl_word_cat:\n  \"rev (to_bl (word_cat x y :: 'a::len word)) =\n    takefill False (LENGTH('a)) (rev (to_bl y) @ rev (to_bl x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (word_cat x y)) =\n    takefill False LENGTH('a) (rev (to_bl y) @ rev (to_bl x))", "by (simp add: word_cat_bl word_rev_tf)"], ["", "lemma rbl_word_slice:\n  \"rev (to_bl (slice n w :: 'a::len word)) =\n    takefill False (LENGTH('a)) (drop n (rev (to_bl w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (slice n w)) =\n    takefill False LENGTH('a) (drop n (rev (to_bl w)))", "apply (simp add: slice_take word_rev_tf rev_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill False LENGTH('a)\n     (drop (LENGTH('b) - (LENGTH('b) - n)) (rev (to_bl w))) =\n    takefill False LENGTH('a) (drop n (rev (to_bl w)))", "apply (cases \"n < LENGTH('b)\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_word_ucast:\n  \"rev (to_bl (ucast x :: 'a::len word)) = takefill False (LENGTH('a)) (rev (to_bl x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (ucast x)) = takefill False LENGTH('a) (rev (to_bl x))", "apply (simp add: to_bl_ucast takefill_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (drop (LENGTH('b) - LENGTH('a)) (to_bl x)) =\n    take LENGTH('a) (rev (to_bl x))", "apply (simp add: rev_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (LENGTH('b) - (LENGTH('b) - LENGTH('a))) (rev (to_bl x)) =\n    take LENGTH('a) (rev (to_bl x))", "apply (cases \"LENGTH('a) < LENGTH('b)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) < LENGTH('b) \\<Longrightarrow>\n    take (LENGTH('b) - (LENGTH('b) - LENGTH('a))) (rev (to_bl x)) =\n    take LENGTH('a) (rev (to_bl x))\n 2. \\<not> LENGTH('a) < LENGTH('b) \\<Longrightarrow>\n    take (LENGTH('b) - (LENGTH('b) - LENGTH('a))) (rev (to_bl x)) =\n    take LENGTH('a) (rev (to_bl x))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_shiftl:\n  \"rev (to_bl (w << n)) = takefill False (size w) (replicate n False @ rev (to_bl w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (w << n)) =\n    takefill False (size w) (replicate n False @ rev (to_bl w))", "by (simp add: bl_shiftl takefill_alt word_size rev_drop)"], ["", "lemma rbl_shiftr:\n  \"rev (to_bl (w >> n)) = takefill False (size w) (drop n (rev (to_bl w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (w >> n)) = takefill False (size w) (drop n (rev (to_bl w)))", "by (simp add: shiftr_slice rbl_word_slice word_size)"], ["", "definition \"drop_nonempty v n xs = (if n < length xs then drop n xs else [last (v # xs)])\""], ["", "lemma drop_nonempty_simps:\n  \"drop_nonempty v (Suc n) (x # xs) = drop_nonempty x n xs\"\n  \"drop_nonempty v 0 (x # xs) = (x # xs)\"\n  \"drop_nonempty v n [] = [v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_nonempty v (Suc n) (x # xs) = drop_nonempty x n xs &&&\n    drop_nonempty v 0 (x # xs) = x # xs &&& drop_nonempty v n [] = [v]", "by (simp_all add: drop_nonempty_def)"], ["", "definition \"takefill_last x n xs = takefill (last (x # xs)) n xs\""], ["", "lemma takefill_last_simps:\n  \"takefill_last z (Suc n) (x # xs) = x # takefill_last x n xs\"\n  \"takefill_last z 0 xs = []\"\n  \"takefill_last z n [] = replicate n z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takefill_last z (Suc n) (x # xs) = x # takefill_last x n xs &&&\n    takefill_last z 0 xs = [] &&& takefill_last z n [] = replicate n z", "by (simp_all add: takefill_last_def) (simp_all add: takefill_alt)"], ["", "lemma rbl_sshiftr:\n  \"rev (to_bl (w >>> n)) = takefill_last False (size w) (drop_nonempty False n (rev (to_bl w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (w >>> n)) =\n    takefill_last False (size w) (drop_nonempty False n (rev (to_bl w)))", "apply (cases \"n < size w\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < size w \\<Longrightarrow>\n    rev (to_bl (w >>> n)) =\n    takefill_last False (size w) (drop_nonempty False n (rev (to_bl w)))\n 2. \\<not> n < size w \\<Longrightarrow>\n    rev (to_bl (w >>> n)) =\n    takefill_last False (size w) (drop_nonempty False n (rev (to_bl w)))", "apply (simp add: bl_sshiftr takefill_last_def word_size\n      takefill_alt rev_take last_rev\n      drop_nonempty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < size w \\<Longrightarrow>\n    rev (to_bl (w >>> n)) =\n    takefill_last False (size w) (drop_nonempty False n (rev (to_bl w)))", "apply (subgoal_tac \"(w >>> n) = of_bl (replicate (size w) (msb w))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < size w;\n     w >>> n = of_bl (replicate (size w) (msb w))\\<rbrakk>\n    \\<Longrightarrow> rev (to_bl (w >>> n)) =\n                      takefill_last False (size w)\n                       (drop_nonempty False n (rev (to_bl w)))\n 2. \\<not> n < size w \\<Longrightarrow>\n    w >>> n = of_bl (replicate (size w) (msb w))", "apply (simp add: word_size takefill_last_def takefill_alt\n      last_rev word_msb_alt word_rev_tf\n      drop_nonempty_def take_Cons')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < LENGTH('a);\n     w >>> n = of_bl (replicate LENGTH('a) (hd (to_bl w)))\\<rbrakk>\n    \\<Longrightarrow> replicate LENGTH('a) (hd (to_bl w)) =\n                      hd (to_bl w) #\n                      replicate (LENGTH('a) - Suc 0) (hd (to_bl w))\n 2. \\<not> n < size w \\<Longrightarrow>\n    w >>> n = of_bl (replicate (size w) (msb w))", "apply (case_tac \"LENGTH('a)\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < size w \\<Longrightarrow>\n    w >>> n = of_bl (replicate (size w) (msb w))", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<not> n < size w \\<Longrightarrow>\n       na < size (w >>> n) \\<longrightarrow>\n       (w >>> n) !! na = of_bl (replicate (size w) (msb w)) !! na", "apply (simp add: nth_sshiftr word_size test_bit_of_bl\n      msb_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_word_of_int:\n  \"(word_of_int x :: 'a::len word) !! n = (n < LENGTH('a) \\<and> bin_nth x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int x !! n = (n < LENGTH('a) \\<and> bit x n)", "apply (simp add: test_bit_bl word_size to_bl_of_bin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev (bin_to_bl_aux LENGTH('a) x []) ! n \\<and> n < LENGTH('a)) =\n    (n < LENGTH('a) \\<and> bit x n)", "apply (subst conj_cong[OF refl], erule bin_nth_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev (bin_to_bl_aux LENGTH('a) x []) ! n \\<and> n < LENGTH('a)) =\n    (n < LENGTH('a) \\<and> rev (bin_to_bl LENGTH('a) x) ! n)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_scast:\n  \"(scast (x :: 'a::len word) :: 'b::len word) !! n =\n    (n < LENGTH('b) \\<and>\n    (if n < LENGTH('a) - 1 then x !! n\n     else x !! (LENGTH('a) - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scast x !! n =\n    (n < LENGTH('b) \\<and>\n     (if n < LENGTH('a) - 1 then x !! n else x !! (LENGTH('a) - 1)))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       (n < LENGTH('b) \\<and>\n        bit (signed_take_bit (LENGTH('a) - Suc 0) x) n) =\n       (n < LENGTH('b) \\<and>\n        (if n < LENGTH('a) - 1 then n < LENGTH('a) \\<and> bit x n\n         else LENGTH('a) - 1 < LENGTH('a) \\<and> bit x (LENGTH('a) - 1)))", "apply (auto simp add: bit_signed_take_bit_iff min_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rbl_word_scast:\n  \"rev (to_bl (scast x :: 'a::len word)) = takefill_last False (LENGTH('a)) (rev (to_bl x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (scast x)) = takefill_last False LENGTH('a) (rev (to_bl x))", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (rev (to_bl (scast x))) =\n    length (takefill_last False LENGTH('a) (rev (to_bl x)))\n 2. \\<And>i.\n       i < length (rev (to_bl (scast x))) \\<Longrightarrow>\n       rev (to_bl (scast x)) ! i =\n       takefill_last False LENGTH('a) (rev (to_bl x)) ! i", "apply (simp add: word_size takefill_last_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (rev (to_bl (scast x))) \\<Longrightarrow>\n       rev (to_bl (scast x)) ! i =\n       takefill_last False LENGTH('a) (rev (to_bl x)) ! i", "apply (clarsimp simp: nth_scast takefill_last_def\n      nth_takefill word_size rev_nth to_bl_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < LENGTH('a) \\<Longrightarrow>\n       (i < LENGTH('b) - Suc 0 \\<longrightarrow>\n        \\<not> i < LENGTH('b) \\<longrightarrow>\n        x !! i = last (rev (to_bl x))) \\<and>\n       (\\<not> i < LENGTH('b) - Suc 0 \\<longrightarrow>\n        (i < LENGTH('b) \\<longrightarrow>\n         x !! (LENGTH('b) - Suc 0) = x !! i) \\<and>\n        (\\<not> i < LENGTH('b) \\<longrightarrow>\n         x !! (LENGTH('b) - Suc 0) = last (rev (to_bl x))))", "apply (cases \"LENGTH('b)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < LENGTH('a); LENGTH('b) = 0\\<rbrakk>\n       \\<Longrightarrow> (i < LENGTH('b) - Suc 0 \\<longrightarrow>\n                          \\<not> i < LENGTH('b) \\<longrightarrow>\n                          x !! i = last (rev (to_bl x))) \\<and>\n                         (\\<not> i < LENGTH('b) - Suc 0 \\<longrightarrow>\n                          (i < LENGTH('b) \\<longrightarrow>\n                           x !! (LENGTH('b) - Suc 0) = x !! i) \\<and>\n                          (\\<not> i < LENGTH('b) \\<longrightarrow>\n                           x !! (LENGTH('b) - Suc 0) =\n                           last (rev (to_bl x))))\n 2. \\<And>i nat.\n       \\<lbrakk>i < LENGTH('a); LENGTH('b) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (i < LENGTH('b) - Suc 0 \\<longrightarrow>\n                          \\<not> i < LENGTH('b) \\<longrightarrow>\n                          x !! i = last (rev (to_bl x))) \\<and>\n                         (\\<not> i < LENGTH('b) - Suc 0 \\<longrightarrow>\n                          (i < LENGTH('b) \\<longrightarrow>\n                           x !! (LENGTH('b) - Suc 0) = x !! i) \\<and>\n                          (\\<not> i < LENGTH('b) \\<longrightarrow>\n                           x !! (LENGTH('b) - Suc 0) =\n                           last (rev (to_bl x))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nat.\n       \\<lbrakk>i < LENGTH('a); LENGTH('b) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (i < LENGTH('b) - Suc 0 \\<longrightarrow>\n                          \\<not> i < LENGTH('b) \\<longrightarrow>\n                          x !! i = last (rev (to_bl x))) \\<and>\n                         (\\<not> i < LENGTH('b) - Suc 0 \\<longrightarrow>\n                          (i < LENGTH('b) \\<longrightarrow>\n                           x !! (LENGTH('b) - Suc 0) = x !! i) \\<and>\n                          (\\<not> i < LENGTH('b) \\<longrightarrow>\n                           x !! (LENGTH('b) - Suc 0) =\n                           last (rev (to_bl x))))", "apply (clarsimp simp: less_Suc_eq_le linorder_not_less\n      last_rev word_msb_alt[symmetric]\n      msb_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition rbl_mul :: \"bool list \\<Rightarrow> bool list \\<Rightarrow> bool list\"\n  where \"rbl_mul xs ys = foldr (\\<lambda>x sm. rbl_plus False (map ((\\<and>) x) ys) (False # sm)) xs []\""], ["", "lemma rbl_mul_simps:\n  \"rbl_mul (x # xs) ys = rbl_plus False (map ((\\<and>) x) ys) (False # rbl_mul xs ys)\"\n  \"rbl_mul [] ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_mul (x # xs) ys =\n    rbl_plus False (map ((\\<and>) x) ys) (False # rbl_mul xs ys) &&&\n    rbl_mul [] ys = []", "by (simp_all add: rbl_mul_def)"], ["", "lemma takefill_le2: \"length xs \\<le> n \\<Longrightarrow> takefill x m (takefill x n xs) = takefill x m xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow>\n    takefill x m (takefill x n xs) = takefill x m xs", "by (simp add: takefill_alt replicate_add[symmetric])"], ["", "lemma take_rbl_plus: \"\\<forall>n b. take n (rbl_plus b xs ys) = rbl_plus b (take n xs) (take n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n b.\n       take n (rbl_plus b xs ys) = rbl_plus b (take n xs) (take n ys)", "apply (simp add: rbl_plus_def take_zip[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n b.\n       take n\n        (foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n          (zip xs ys) (\\<lambda>_. []) b) =\n       foldr (\\<lambda>(x, y) res car. xor3 x y car # res (carry x y car))\n        (take n (zip xs ys)) (\\<lambda>_. []) b", "apply (rule_tac list=\"zip xs ys\" in list.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n b.\n       take n\n        (foldr\n          (\\<lambda>a.\n              case a of\n              (x, y) \\<Rightarrow>\n                \\<lambda>res car. xor3 x y car # res (carry x y car))\n          [] (\\<lambda>_. []) b) =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>res car. xor3 x y car # res (carry x y car))\n        (take n []) (\\<lambda>_. []) b\n 2. \\<And>x1 x2.\n       \\<forall>n b.\n          take n\n           (foldr\n             (\\<lambda>a.\n                 case a of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>res car. xor3 x y car # res (carry x y car))\n             x2 (\\<lambda>_. []) b) =\n          foldr\n           (\\<lambda>a.\n               case a of\n               (x, y) \\<Rightarrow>\n                 \\<lambda>res car. xor3 x y car # res (carry x y car))\n           (take n x2) (\\<lambda>_. []) b \\<Longrightarrow>\n       \\<forall>n b.\n          take n\n           (foldr\n             (\\<lambda>a.\n                 case a of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>res car. xor3 x y car # res (carry x y car))\n             (x1 # x2) (\\<lambda>_. []) b) =\n          foldr\n           (\\<lambda>a.\n               case a of\n               (x, y) \\<Rightarrow>\n                 \\<lambda>res car. xor3 x y car # res (carry x y car))\n           (take n (x1 # x2)) (\\<lambda>_. []) b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<forall>n b.\n          take n\n           (foldr\n             (\\<lambda>a.\n                 case a of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>res car. xor3 x y car # res (carry x y car))\n             x2 (\\<lambda>_. []) b) =\n          foldr\n           (\\<lambda>a.\n               case a of\n               (x, y) \\<Rightarrow>\n                 \\<lambda>res car. xor3 x y car # res (carry x y car))\n           (take n x2) (\\<lambda>_. []) b \\<Longrightarrow>\n       \\<forall>n b.\n          take n\n           (foldr\n             (\\<lambda>a.\n                 case a of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>res car. xor3 x y car # res (carry x y car))\n             (x1 # x2) (\\<lambda>_. []) b) =\n          foldr\n           (\\<lambda>a.\n               case a of\n               (x, y) \\<Rightarrow>\n                 \\<lambda>res car. xor3 x y car # res (carry x y car))\n           (take n (x1 # x2)) (\\<lambda>_. []) b", "apply (clarsimp simp: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x2 n ba.\n       \\<forall>n b.\n          take n\n           (foldr\n             (\\<lambda>a b c.\n                 xor3 (fst a) (snd a) c # b (carry (fst a) (snd a) c))\n             x2 (\\<lambda>_. []) b) =\n          foldr\n           (\\<lambda>a b c.\n               xor3 (fst a) (snd a) c # b (carry (fst a) (snd a) c))\n           (take n x2) (\\<lambda>_. []) b \\<Longrightarrow>\n       take n\n        (xor3 a b ba #\n         foldr\n          (\\<lambda>a b c.\n              xor3 (fst a) (snd a) c # b (carry (fst a) (snd a) c))\n          x2 (\\<lambda>_. []) (carry a b ba)) =\n       foldr\n        (\\<lambda>a b c.\n            xor3 (fst a) (snd a) c # b (carry (fst a) (snd a) c))\n        (take n ((a, b) # x2)) (\\<lambda>_. []) ba", "apply (case_tac n, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_rbl_mul_induct:\n  \"length xs \\<le> size y \\<Longrightarrow>\n    rbl_mul xs (rev (to_bl y)) = take (length xs) (rev (to_bl (of_bl (rev xs) * y)))\"\n  for y :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> size y \\<Longrightarrow>\n    rbl_mul xs (rev (to_bl y)) =\n    take (length xs) (rev (to_bl (of_bl (rev xs) * y)))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. length [] \\<le> size y \\<Longrightarrow>\n    rbl_mul [] (rev (to_bl y)) =\n    take (length []) (rev (to_bl (of_bl (rev []) * y)))\n 2. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "case Nil"], ["proof (state)\nthis:\n  length [] \\<le> size y\n\ngoal (2 subgoals):\n 1. length [] \\<le> size y \\<Longrightarrow>\n    rbl_mul [] (rev (to_bl y)) =\n    take (length []) (rev (to_bl (of_bl (rev []) * y)))\n 2. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbl_mul [] (rev (to_bl y)) =\n    take (length []) (rev (to_bl (of_bl (rev []) * y)))", "by (simp add: rbl_mul_simps)"], ["proof (state)\nthis:\n  rbl_mul [] (rev (to_bl y)) =\n  take (length []) (rev (to_bl (of_bl (rev []) * y)))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "case (Cons z zs)"], ["proof (state)\nthis:\n  length zs \\<le> size y \\<Longrightarrow>\n  rbl_mul zs (rev (to_bl y)) =\n  take (length zs) (rev (to_bl (of_bl (rev zs) * y)))\n  length (z # zs) \\<le> size y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "have rbl_word_plus': \"to_bl (x + y) = rev (rbl_plus False (rev (to_bl x)) (rev (to_bl y)))\"\n    for x y :: \"'a word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (x + y) = rev (rbl_plus False (rev (to_bl x)) (rev (to_bl y)))", "by (simp add: rbl_word_plus[symmetric])"], ["proof (state)\nthis:\n  to_bl (?x + ?y) = rev (rbl_plus False (rev (to_bl ?x)) (rev (to_bl ?y)))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "have mult_bit: \"to_bl (of_bl [z] * y) = map ((\\<and>) z) (to_bl y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl (of_bl [z] * y) = map ((\\<and>) z) (to_bl y)", "by (cases z) (simp cong: map_cong, simp add: map_replicate_const cong: map_cong)"], ["proof (state)\nthis:\n  to_bl (of_bl [z] * y) = map ((\\<and>) z) (to_bl y)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "have shiftl: \"of_bl xs * 2 * y = (of_bl xs * y) << 1\" for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl xs * 2 * y = of_bl xs * y << 1", "by (simp add: shiftl_t2n)"], ["proof (state)\nthis:\n  of_bl ?xs * 2 * y = of_bl ?xs * y << 1\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "have zip_take_triv: \"\\<And>xs ys n. n = length ys \\<Longrightarrow> zip (take n xs) ys = zip xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys n.\n       n = length ys \\<Longrightarrow> zip (take n xs) ys = zip xs ys", "by (rule nth_equalityI) simp_all"], ["proof (state)\nthis:\n  ?n = length ?ys \\<Longrightarrow> zip (take ?n ?xs) ?ys = zip ?xs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>length xs \\<le> size y \\<Longrightarrow>\n                rbl_mul xs (rev (to_bl y)) =\n                take (length xs) (rev (to_bl (of_bl (rev xs) * y)));\n        length (a # xs) \\<le> size y\\<rbrakk>\n       \\<Longrightarrow> rbl_mul (a # xs) (rev (to_bl y)) =\n                         take (length (a # xs))\n                          (rev (to_bl (of_bl (rev (a # xs)) * y)))", "from Cons"], ["proof (chain)\npicking this:\n  length zs \\<le> size y \\<Longrightarrow>\n  rbl_mul zs (rev (to_bl y)) =\n  take (length zs) (rev (to_bl (of_bl (rev zs) * y)))\n  length (z # zs) \\<le> size y", "show ?case"], ["proof (prove)\nusing this:\n  length zs \\<le> size y \\<Longrightarrow>\n  rbl_mul zs (rev (to_bl y)) =\n  take (length zs) (rev (to_bl (of_bl (rev zs) * y)))\n  length (z # zs) \\<le> size y\n\ngoal (1 subgoal):\n 1. rbl_mul (z # zs) (rev (to_bl y)) =\n    take (length (z # zs)) (rev (to_bl (of_bl (rev (z # zs)) * y)))", "apply (simp add: trans [OF of_bl_append add.commute]\n        rbl_mul_simps rbl_word_plus' distrib_right mult_bit shiftl rbl_shiftl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rbl_mul zs (rev (to_bl y)) =\n             take (length zs) (rev (to_bl (of_bl (rev zs) * y)));\n     Suc (length zs) \\<le> size y\\<rbrakk>\n    \\<Longrightarrow> rbl_plus False (map ((\\<and>) z) (rev (to_bl y)))\n                       (False #\n                        take (length zs)\n                         (rev (to_bl (of_bl (rev zs) * y)))) =\n                      take (Suc (length zs))\n                       (rbl_plus False (rev (map ((\\<and>) z) (to_bl y)))\n                         (takefill False (size (of_bl (rev zs) * y))\n                           (False # rev (to_bl (of_bl (rev zs) * y)))))", "apply (simp add: takefill_alt word_size rev_map take_rbl_plus min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rbl_mul zs (rev (to_bl y)) =\n             take (length zs) (rev (to_bl (of_bl (rev zs) * y)));\n     Suc (length zs) \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> rbl_plus False (map ((\\<and>) z) (rev (to_bl y)))\n                       (False #\n                        take (length zs)\n                         (rev (to_bl (of_bl (rev zs) * y)))) =\n                      rbl_plus False\n                       (take (Suc (length zs))\n                         (map ((\\<and>) z) (rev (to_bl y))))\n                       (False #\n                        take (length zs) (rev (to_bl (of_bl (rev zs) * y))))", "apply (simp add: rbl_plus_def zip_take_triv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rbl_mul (z # zs) (rev (to_bl y)) =\n  take (length (z # zs)) (rev (to_bl (of_bl (rev (z # zs)) * y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rbl_word_mul: \"rev (to_bl (x * y)) = rbl_mul (rev (to_bl x)) (rev (to_bl y))\"\n  for x :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl (x * y)) = rbl_mul (rev (to_bl x)) (rev (to_bl y))", "using word_rbl_mul_induct[where xs=\"rev (to_bl x)\" and y=y]"], ["proof (prove)\nusing this:\n  length (rev (to_bl x)) \\<le> size y \\<Longrightarrow>\n  rbl_mul (rev (to_bl x)) (rev (to_bl y)) =\n  take (length (rev (to_bl x)))\n   (rev (to_bl (of_bl (rev (rev (to_bl x))) * y)))\n\ngoal (1 subgoal):\n 1. rev (to_bl (x * y)) = rbl_mul (rev (to_bl x)) (rev (to_bl y))", "by (simp add: word_size)"], ["", "text \\<open>Breaking up inequalities into bitlist properties.\\<close>"], ["", "definition\n  \"rev_bl_order F xs ys =\n     (length xs = length ys \\<and>\n       ((xs = ys \\<and> F)\n          \\<or> (\\<exists>n < length xs. drop (Suc n) xs = drop (Suc n) ys\n                   \\<and> \\<not> xs ! n \\<and> ys ! n)))\""], ["", "lemma rev_bl_order_simps:\n  \"rev_bl_order F [] [] = F\"\n  \"rev_bl_order F (x # xs) (y # ys) = rev_bl_order ((y \\<and> \\<not> x) \\<or> ((y \\<or> \\<not> x) \\<and> F)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_bl_order F [] [] = F &&&\n    rev_bl_order F (x # xs) (y # ys) =\n    rev_bl_order (y \\<and> \\<not> x \\<or> (y \\<or> \\<not> x) \\<and> F) xs ys", "apply (simp_all add: rev_bl_order_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = length ys \\<and>\n     (x = y \\<and> xs = ys \\<and> F \\<or>\n      (\\<exists>n<Suc (length xs).\n          drop n xs = drop n ys \\<and>\n          \\<not> (x # xs) ! n \\<and> (y # ys) ! n))) =\n    (length xs = length ys \\<and>\n     (xs = ys \\<and>\n      (y \\<and> \\<not> x \\<or> (y \\<or> \\<not> x) \\<and> F) \\<or>\n      (\\<exists>n<length xs.\n          drop (Suc n) xs = drop (Suc n) ys \\<and>\n          \\<not> xs ! n \\<and> ys ! n)))", "apply (rule conj_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    (x = y \\<and> xs = ys \\<and> F \\<or>\n     (\\<exists>n<Suc (length xs).\n         drop n xs = drop n ys \\<and>\n         \\<not> (x # xs) ! n \\<and> (y # ys) ! n)) =\n    (xs = ys \\<and>\n     (y \\<and> \\<not> x \\<or> (y \\<or> \\<not> x) \\<and> F) \\<or>\n     (\\<exists>n<length xs.\n         drop (Suc n) xs = drop (Suc n) ys \\<and>\n         \\<not> xs ! n \\<and> ys ! n))", "apply (cases \"xs = ys\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = length ys; xs = ys\\<rbrakk>\n    \\<Longrightarrow> (x = y \\<and> xs = ys \\<and> F \\<or>\n                       (\\<exists>n<Suc (length xs).\n                           drop n xs = drop n ys \\<and>\n                           \\<not> (x # xs) ! n \\<and> (y # ys) ! n)) =\n                      (xs = ys \\<and>\n                       (y \\<and> \\<not> x \\<or>\n                        (y \\<or> \\<not> x) \\<and> F) \\<or>\n                       (\\<exists>n<length xs.\n                           drop (Suc n) xs = drop (Suc n) ys \\<and>\n                           \\<not> xs ! n \\<and> ys ! n))\n 2. \\<lbrakk>length xs = length ys; xs \\<noteq> ys\\<rbrakk>\n    \\<Longrightarrow> (x = y \\<and> xs = ys \\<and> F \\<or>\n                       (\\<exists>n<Suc (length xs).\n                           drop n xs = drop n ys \\<and>\n                           \\<not> (x # xs) ! n \\<and> (y # ys) ! n)) =\n                      (xs = ys \\<and>\n                       (y \\<and> \\<not> x \\<or>\n                        (y \\<or> \\<not> x) \\<and> F) \\<or>\n                       (\\<exists>n<length xs.\n                           drop (Suc n) xs = drop (Suc n) ys \\<and>\n                           \\<not> xs ! n \\<and> ys ! n))", "apply (simp add: nth_Cons')"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = ys \\<Longrightarrow>\n    (x = y \\<and> F \\<or> \\<not> x \\<and> y) =\n    (y \\<and> \\<not> x \\<or> (y \\<or> \\<not> x) \\<and> F)\n 2. \\<lbrakk>length xs = length ys; xs \\<noteq> ys\\<rbrakk>\n    \\<Longrightarrow> (x = y \\<and> xs = ys \\<and> F \\<or>\n                       (\\<exists>n<Suc (length xs).\n                           drop n xs = drop n ys \\<and>\n                           \\<not> (x # xs) ! n \\<and> (y # ys) ! n)) =\n                      (xs = ys \\<and>\n                       (y \\<and> \\<not> x \\<or>\n                        (y \\<or> \\<not> x) \\<and> F) \\<or>\n                       (\\<exists>n<length xs.\n                           drop (Suc n) xs = drop (Suc n) ys \\<and>\n                           \\<not> xs ! n \\<and> ys ! n))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; xs \\<noteq> ys\\<rbrakk>\n    \\<Longrightarrow> (x = y \\<and> xs = ys \\<and> F \\<or>\n                       (\\<exists>n<Suc (length xs).\n                           drop n xs = drop n ys \\<and>\n                           \\<not> (x # xs) ! n \\<and> (y # ys) ! n)) =\n                      (xs = ys \\<and>\n                       (y \\<and> \\<not> x \\<or>\n                        (y \\<or> \\<not> x) \\<and> F) \\<or>\n                       (\\<exists>n<length xs.\n                           drop (Suc n) xs = drop (Suc n) ys \\<and>\n                           \\<not> xs ! n \\<and> ys ! n))", "apply (simp add: nth_Cons')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; xs \\<noteq> ys\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>n>0.\n                          0 < n \\<longrightarrow>\n                          n < Suc (length ys) \\<and>\n                          drop n xs = drop n ys \\<and>\n                          \\<not> xs ! (n - Suc 0) \\<and> ys ! (n - Suc 0)) =\n                      (\\<exists>n<length ys.\n                          drop (Suc n) xs = drop (Suc n) ys \\<and>\n                          \\<not> xs ! n \\<and> ys ! n)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>length xs = length ys; xs \\<noteq> ys; 0 < n;\n        n < Suc (length ys); drop n xs = drop n ys; \\<not> xs ! (n - Suc 0);\n        ys ! (n - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length ys.\n                            drop (Suc n) xs = drop (Suc n) ys \\<and>\n                            \\<not> xs ! n \\<and> ys ! n\n 2. \\<And>n.\n       \\<lbrakk>length xs = length ys; xs \\<noteq> ys; n < length ys;\n        drop (Suc n) xs = drop (Suc n) ys; \\<not> xs ! n; ys ! n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n>0.\n                            0 < n \\<longrightarrow>\n                            n < Suc (length ys) \\<and>\n                            drop n xs = drop n ys \\<and>\n                            \\<not> xs ! (n - Suc 0) \\<and> ys ! (n - Suc 0)", "apply (rule_tac x=\"n - 1\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>length xs = length ys; xs \\<noteq> ys; 0 < n;\n        n < Suc (length ys); drop n xs = drop n ys; \\<not> xs ! (n - Suc 0);\n        ys ! (n - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> n - 1 < length ys \\<and>\n                         drop (Suc (n - 1)) xs =\n                         drop (Suc (n - 1)) ys \\<and>\n                         \\<not> xs ! (n - 1) \\<and> ys ! (n - 1)\n 2. \\<And>n.\n       \\<lbrakk>length xs = length ys; xs \\<noteq> ys; n < length ys;\n        drop (Suc n) xs = drop (Suc n) ys; \\<not> xs ! n; ys ! n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n>0.\n                            0 < n \\<longrightarrow>\n                            n < Suc (length ys) \\<and>\n                            drop n xs = drop n ys \\<and>\n                            \\<not> xs ! (n - Suc 0) \\<and> ys ! (n - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>length xs = length ys; xs \\<noteq> ys; n < length ys;\n        drop (Suc n) xs = drop (Suc n) ys; \\<not> xs ! n; ys ! n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n>0.\n                            0 < n \\<longrightarrow>\n                            n < Suc (length ys) \\<and>\n                            drop n xs = drop n ys \\<and>\n                            \\<not> xs ! (n - Suc 0) \\<and> ys ! (n - Suc 0)", "apply (rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>length xs = length ys; xs \\<noteq> ys; n < length ys;\n        drop (Suc n) xs = drop (Suc n) ys; \\<not> xs ! n; ys ! n\\<rbrakk>\n       \\<Longrightarrow> 0 < Suc n \\<and>\n                         (0 < Suc n \\<longrightarrow>\n                          Suc n < Suc (length ys) \\<and>\n                          drop (Suc n) xs = drop (Suc n) ys \\<and>\n                          \\<not> xs ! (Suc n - Suc 0) \\<and>\n                          ys ! (Suc n - Suc 0))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rev_bl_order_rev_simp:\n  \"length xs = length ys \\<Longrightarrow>\n   rev_bl_order F (xs @ [x]) (ys @ [y]) = ((y \\<and> \\<not> x) \\<or> ((y \\<or> \\<not> x) \\<and> rev_bl_order F xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rev_bl_order F (xs @ [x]) (ys @ [y]) =\n    (y \\<and> \\<not> x \\<or> (y \\<or> \\<not> x) \\<and> rev_bl_order F xs ys)", "by (induct arbitrary: F rule: list_induct2) (auto simp: rev_bl_order_simps)"], ["", "lemma rev_bl_order_bl_to_bin:\n  \"length xs = length ys \\<Longrightarrow>\n    rev_bl_order True xs ys = (bl_to_bin (rev xs) \\<le> bl_to_bin (rev ys)) \\<and>\n    rev_bl_order False xs ys = (bl_to_bin (rev xs) < bl_to_bin (rev ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    rev_bl_order True xs ys =\n    (bl_to_bin (rev xs) \\<le> bl_to_bin (rev ys)) \\<and>\n    rev_bl_order False xs ys = (bl_to_bin (rev xs) < bl_to_bin (rev ys))", "apply (induct xs ys rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rev_bl_order True [] [] =\n    (bl_to_bin (rev []) \\<le> bl_to_bin (rev [])) \\<and>\n    rev_bl_order False [] [] = (bl_to_bin (rev []) < bl_to_bin (rev []))\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        rev_bl_order True xs ys =\n        (bl_to_bin (rev xs) \\<le> bl_to_bin (rev ys)) \\<and>\n        rev_bl_order False xs ys =\n        (bl_to_bin (rev xs) < bl_to_bin (rev ys))\\<rbrakk>\n       \\<Longrightarrow> rev_bl_order True (x # xs) (y # ys) =\n                         (bl_to_bin (rev (x # xs))\n                          \\<le> bl_to_bin (rev (y # ys))) \\<and>\n                         rev_bl_order False (x # xs) (y # ys) =\n                         (bl_to_bin (rev (x # xs))\n                          < bl_to_bin (rev (y # ys)))", "apply (simp_all add: rev_bl_order_simps bl_to_bin_app_cat concat_bit_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        rev_bl_order True xs ys =\n        (bl_to_bin (rev xs) \\<le> bl_to_bin (rev ys)) \\<and>\n        rev_bl_order False xs ys =\n        (bl_to_bin (rev xs) < bl_to_bin (rev ys))\\<rbrakk>\n       \\<Longrightarrow> rev_bl_order\n                          (y \\<and> \\<not> x \\<or> y \\<or> \\<not> x) xs ys =\n                         (bl_to_bin [x] mod 2 + 2 * bl_to_bin (rev xs)\n                          \\<le> bl_to_bin [y] mod 2 +\n                                2 * bl_to_bin (rev ys)) \\<and>\n                         rev_bl_order (y \\<and> \\<not> x) xs ys =\n                         (bl_to_bin [x] mod 2 + 2 * bl_to_bin (rev xs)\n                          < bl_to_bin [y] mod 2 + 2 * bl_to_bin (rev ys))", "apply (auto simp add: bl_to_bin_def add1_zle_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_le_rbl: \"x \\<le> y \\<longleftrightarrow> rev_bl_order True (rev (to_bl x)) (rev (to_bl y))\"\n  for x y :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = rev_bl_order True (rev (to_bl x)) (rev (to_bl y))", "by (simp add: rev_bl_order_bl_to_bin word_le_def)"], ["", "lemma word_less_rbl: \"x < y \\<longleftrightarrow> rev_bl_order False (rev (to_bl x)) (rev (to_bl y))\"\n  for x y :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = rev_bl_order False (rev (to_bl x)) (rev (to_bl y))", "by (simp add: word_less_alt rev_bl_order_bl_to_bin)"], ["", "definition \"map_last f xs = (if xs = [] then [] else butlast xs @ [f (last xs)])\""], ["", "lemma map_last_simps:\n  \"map_last f [] = []\"\n  \"map_last f [x] = [f x]\"\n  \"map_last f (x # y # zs) = x # map_last f (y # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_last f [] = [] &&&\n    map_last f [x] = [f x] &&&\n    map_last f (x # y # zs) = x # map_last f (y # zs)", "by (simp_all add: map_last_def)"], ["", "lemma word_sle_rbl:\n  \"x <=s y \\<longleftrightarrow> rev_bl_order True (map_last Not (rev (to_bl x))) (map_last Not (rev (to_bl y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le>s y) =\n    rev_bl_order True (map_last Not (rev (to_bl x)))\n     (map_last Not (rev (to_bl y)))", "using word_msb_alt[where w=x] word_msb_alt[where w=y]"], ["proof (prove)\nusing this:\n  msb x = hd (to_bl x)\n  msb y = hd (to_bl y)\n\ngoal (1 subgoal):\n 1. (x \\<le>s y) =\n    rev_bl_order True (map_last Not (rev (to_bl x)))\n     (map_last Not (rev (to_bl y)))", "apply (simp add: word_sle_msb_le word_le_rbl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow> hd (to_bl x)) \\<and>\n                       (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                        rev_bl_order True (rev (to_bl x))\n                         (rev (to_bl y)))) =\n                      rev_bl_order True (map_last Not (rev (to_bl x)))\n                       (map_last Not (rev (to_bl y)))", "apply (subgoal_tac \"length (to_bl x) = length (to_bl y)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y);\n     length (to_bl x) = length (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow> hd (to_bl x)) \\<and>\n                       (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                        rev_bl_order True (rev (to_bl x))\n                         (rev (to_bl y)))) =\n                      rev_bl_order True (map_last Not (rev (to_bl x)))\n                       (map_last Not (rev (to_bl y)))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply (cases \"to_bl x\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y);\n        length (to_bl x) = length (to_bl y); to_bl x = a # list\\<rbrakk>\n       \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow>\n                           hd (to_bl x)) \\<and>\n                          (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                           rev_bl_order True (rev (to_bl x))\n                            (rev (to_bl y)))) =\n                         rev_bl_order True (map_last Not (rev (to_bl x)))\n                          (map_last Not (rev (to_bl y)))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply (cases \"to_bl y\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y);\n        length (to_bl x) = length (to_bl y); to_bl x = a # list;\n        to_bl y = aa # lista\\<rbrakk>\n       \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow>\n                           hd (to_bl x)) \\<and>\n                          (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                           rev_bl_order True (rev (to_bl x))\n                            (rev (to_bl y)))) =\n                         rev_bl_order True (map_last Not (rev (to_bl x)))\n                          (map_last Not (rev (to_bl y)))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply (clarsimp simp: map_last_def rev_bl_order_rev_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list lista.\n       \\<lbrakk>length list = length lista; to_bl x = msb x # list;\n        to_bl y = msb y # lista\\<rbrakk>\n       \\<Longrightarrow> ((msb y \\<longrightarrow> msb x) \\<and>\n                          (msb x \\<and> \\<not> msb y \\<or>\n                           msb y \\<and> \\<not> msb x \\<or>\n                           (msb y \\<or> \\<not> msb x) \\<and>\n                           rev_bl_order True (rev list) (rev lista))) =\n                         (\\<not> msb y \\<and> msb x \\<or>\n                          (msb y \\<longrightarrow> msb x) \\<and>\n                          rev_bl_order True (rev list) (rev lista))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sless_rbl:\n  \"x <s y \\<longleftrightarrow> rev_bl_order False (map_last Not (rev (to_bl x))) (map_last Not (rev (to_bl y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x <s y) =\n    rev_bl_order False (map_last Not (rev (to_bl x)))\n     (map_last Not (rev (to_bl y)))", "using word_msb_alt[where w=x] word_msb_alt[where w=y]"], ["proof (prove)\nusing this:\n  msb x = hd (to_bl x)\n  msb y = hd (to_bl y)\n\ngoal (1 subgoal):\n 1. (x <s y) =\n    rev_bl_order False (map_last Not (rev (to_bl x)))\n     (map_last Not (rev (to_bl y)))", "apply (simp add: word_sless_msb_less word_less_rbl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow> hd (to_bl x)) \\<and>\n                       (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                        rev_bl_order False (rev (to_bl x))\n                         (rev (to_bl y)))) =\n                      rev_bl_order False (map_last Not (rev (to_bl x)))\n                       (map_last Not (rev (to_bl y)))", "apply (subgoal_tac \"length (to_bl x) = length (to_bl y)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y);\n     length (to_bl x) = length (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow> hd (to_bl x)) \\<and>\n                       (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                        rev_bl_order False (rev (to_bl x))\n                         (rev (to_bl y)))) =\n                      rev_bl_order False (map_last Not (rev (to_bl x)))\n                       (map_last Not (rev (to_bl y)))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply (cases \"to_bl x\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y);\n        length (to_bl x) = length (to_bl y); to_bl x = a # list\\<rbrakk>\n       \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow>\n                           hd (to_bl x)) \\<and>\n                          (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                           rev_bl_order False (rev (to_bl x))\n                            (rev (to_bl y)))) =\n                         rev_bl_order False (map_last Not (rev (to_bl x)))\n                          (map_last Not (rev (to_bl y)))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply (cases \"to_bl y\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y);\n        length (to_bl x) = length (to_bl y); to_bl x = a # list;\n        to_bl y = aa # lista\\<rbrakk>\n       \\<Longrightarrow> ((hd (to_bl y) \\<longrightarrow>\n                           hd (to_bl x)) \\<and>\n                          (hd (to_bl x) \\<and> \\<not> hd (to_bl y) \\<or>\n                           rev_bl_order False (rev (to_bl x))\n                            (rev (to_bl y)))) =\n                         rev_bl_order False (map_last Not (rev (to_bl x)))\n                          (map_last Not (rev (to_bl y)))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply (clarsimp simp: map_last_def rev_bl_order_rev_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list lista.\n       \\<lbrakk>length list = length lista; to_bl x = msb x # list;\n        to_bl y = msb y # lista\\<rbrakk>\n       \\<Longrightarrow> ((msb y \\<longrightarrow> msb x) \\<and>\n                          (msb x \\<and> \\<not> msb y \\<or>\n                           msb y \\<and> \\<not> msb x \\<or>\n                           (msb y \\<or> \\<not> msb x) \\<and>\n                           rev_bl_order False (rev list) (rev lista))) =\n                         (\\<not> msb y \\<and> msb x \\<or>\n                          (msb y \\<longrightarrow> msb x) \\<and>\n                          rev_bl_order False (rev list) (rev lista))\n 2. \\<lbrakk>msb x = hd (to_bl x); msb y = hd (to_bl y)\\<rbrakk>\n    \\<Longrightarrow> length (to_bl x) = length (to_bl y)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Lemmas for unpacking \\<^term>\\<open>rev (to_bl n)\\<close> for numerals n and also\n  for irreducible values and expressions.\\<close>"], ["", "lemma rev_bin_to_bl_simps:\n  \"rev (bin_to_bl 0 x) = []\"\n  \"rev (bin_to_bl (Suc n) (numeral (num.Bit0 nm))) = False # rev (bin_to_bl n (numeral nm))\"\n  \"rev (bin_to_bl (Suc n) (numeral (num.Bit1 nm))) = True # rev (bin_to_bl n (numeral nm))\"\n  \"rev (bin_to_bl (Suc n) (numeral (num.One))) = True # replicate n False\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit0 nm))) = False # rev (bin_to_bl n (- numeral nm))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit1 nm))) =\n    True # rev (bin_to_bl n (- numeral (nm + num.One)))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.One))) = True # replicate n True\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit0 nm + num.One))) =\n    True # rev (bin_to_bl n (- numeral (nm + num.One)))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.Bit1 nm + num.One))) =\n    False # rev (bin_to_bl n (- numeral (nm + num.One)))\"\n  \"rev (bin_to_bl (Suc n) (- numeral (num.One + num.One))) =\n    False # rev (bin_to_bl n (- numeral num.One))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rev (bin_to_bl 0 x) = [] &&&\n      rev (bin_to_bl (Suc n) (numeral (num.Bit0 nm))) =\n      False # rev (bin_to_bl n (numeral nm))) &&&\n     rev (bin_to_bl (Suc n) (numeral (num.Bit1 nm))) =\n     True # rev (bin_to_bl n (numeral nm)) &&&\n     rev (bin_to_bl (Suc n) Numeral1) = True # replicate n False &&&\n     rev (bin_to_bl (Suc n) (- numeral (num.Bit0 nm))) =\n     False # rev (bin_to_bl n (- numeral nm))) &&&\n    (rev (bin_to_bl (Suc n) (- numeral (num.Bit1 nm))) =\n     True # rev (bin_to_bl n (- numeral (nm + num.One))) &&&\n     rev (bin_to_bl (Suc n) (- Numeral1)) = True # replicate n True) &&&\n    rev (bin_to_bl (Suc n) (- numeral (num.Bit0 nm + num.One))) =\n    True # rev (bin_to_bl n (- numeral (nm + num.One))) &&&\n    rev (bin_to_bl (Suc n) (- numeral (num.Bit1 nm + num.One))) =\n    False # rev (bin_to_bl n (- numeral (nm + num.One))) &&&\n    rev (bin_to_bl (Suc n) (- numeral (num.One + num.One))) =\n    False # rev (bin_to_bl n (- Numeral1))", "by (simp_all add: bin_to_bl_aux_append bin_to_bl_zero_aux bin_to_bl_minus1_aux replicate_append_same)"], ["", "lemma to_bl_upt: \"to_bl x = rev (map ((!!) x) [0 ..< size x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bl x = rev (map ((!!) x) [0..<size x])", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (to_bl x) = length (rev (map ((!!) x) [0..<size x]))\n 2. \\<And>i.\n       i < length (to_bl x) \\<Longrightarrow>\n       to_bl x ! i = rev (map ((!!) x) [0..<size x]) ! i", "apply (simp add: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (to_bl x) \\<Longrightarrow>\n       to_bl x ! i = rev (map ((!!) x) [0..<size x]) ! i", "apply (auto simp: to_bl_nth word_size rev_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rev_to_bl_upt: \"rev (to_bl x) = map ((!!) x) [0 ..< size x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (to_bl x) = map ((!!) x) [0..<size x]", "by (simp add: to_bl_upt)"], ["", "lemma upt_eq_list_intros:\n  \"j \\<le> i \\<Longrightarrow> [i ..< j] = []\"\n  \"i = x \\<Longrightarrow> x < j \\<Longrightarrow> [x + 1 ..< j] = xs \\<Longrightarrow> [i ..< j] = (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j \\<le> i \\<Longrightarrow> [i..<j] = []) &&&\n    (\\<lbrakk>i = x; x < j; [x + 1..<j] = xs\\<rbrakk>\n     \\<Longrightarrow> [i..<j] = x # xs)", "by (simp_all add: upt_eq_Cons_conv)"], ["", "subsection \\<open>Tactic definition\\<close>"], ["", "lemma if_bool_simps:\n  \"If p True y = (p \\<or> y) \\<and> If p False y = (\\<not> p \\<and> y) \\<and>\n    If p y True = (p \\<longrightarrow> y) \\<and> If p y False = (p \\<and> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p then True else y) = (p \\<or> y) \\<and>\n    (if p then False else y) = (\\<not> p \\<and> y) \\<and>\n    (if p then y else True) = (p \\<longrightarrow> y) \\<and>\n    (if p then y else False) = (p \\<and> y)", "by auto"], ["", "ML \\<open>\nstructure Word_Bitwise_Tac =\nstruct\n\nval word_ss = simpset_of \\<^theory_context>\\<open>Word\\<close>;\n\nfun mk_nat_clist ns =\n  fold_rev (Thm.mk_binop \\<^cterm>\\<open>Cons :: nat \\<Rightarrow> _\\<close>)\n    ns \\<^cterm>\\<open>[] :: nat list\\<close>;\n\nfun upt_conv ctxt ct =\n  case Thm.term_of ct of\n    (\\<^const>\\<open>upt\\<close> $ n $ m) =>\n      let\n        val (i, j) = apply2 (snd o HOLogic.dest_number) (n, m);\n        val ns = map (Numeral.mk_cnumber \\<^ctyp>\\<open>nat\\<close>) (i upto (j - 1))\n          |> mk_nat_clist;\n        val prop =\n          Thm.mk_binop \\<^cterm>\\<open>(=) :: nat list \\<Rightarrow> _\\<close> ct ns\n          |> Thm.apply \\<^cterm>\\<open>Trueprop\\<close>;\n      in\n        try (fn () =>\n          Goal.prove_internal ctxt [] prop\n            (K (REPEAT_DETERM (resolve_tac ctxt @{thms upt_eq_list_intros} 1\n                ORELSE simp_tac (put_simpset word_ss ctxt) 1))) |> mk_meta_eq) ()\n      end\n  | _ => NONE;\n\nval expand_upt_simproc =\n  Simplifier.make_simproc \\<^context> \"expand_upt\"\n   {lhss = [\\<^term>\\<open>upt x y\\<close>], proc = K upt_conv};\n\nfun word_len_simproc_fn ctxt ct =\n  (case Thm.term_of ct of\n    Const (\\<^const_name>\\<open>len_of\\<close>, _) $ t =>\n     (let\n        val T = fastype_of t |> dest_Type |> snd |> the_single\n        val n = Numeral.mk_cnumber \\<^ctyp>\\<open>nat\\<close> (Word_Lib.dest_binT T);\n        val prop =\n          Thm.mk_binop \\<^cterm>\\<open>(=) :: nat \\<Rightarrow> _\\<close> ct n\n          |> Thm.apply \\<^cterm>\\<open>Trueprop\\<close>;\n      in\n        Goal.prove_internal ctxt [] prop (K (simp_tac (put_simpset word_ss ctxt) 1))\n        |> mk_meta_eq |> SOME\n      end handle TERM _ => NONE | TYPE _ => NONE)\n  | _ => NONE);\n\nval word_len_simproc =\n  Simplifier.make_simproc \\<^context> \"word_len\"\n   {lhss = [\\<^term>\\<open>len_of x\\<close>], proc = K word_len_simproc_fn};\n\n(* convert 5 or nat 5 to Suc 4 when n_sucs = 1, Suc (Suc 4) when n_sucs = 2,\n   or just 5 (discarding nat) when n_sucs = 0 *)\n\nfun nat_get_Suc_simproc_fn n_sucs ctxt ct =\n  let\n    val (f, arg) = dest_comb (Thm.term_of ct);\n    val n =\n      (case arg of \\<^term>\\<open>nat\\<close> $ n => n | n => n)\n      |> HOLogic.dest_number |> snd;\n    val (i, j) = if n > n_sucs then (n_sucs, n - n_sucs) else (n, 0);\n    val arg' = funpow i HOLogic.mk_Suc (HOLogic.mk_number \\<^typ>\\<open>nat\\<close> j);\n    val _ = if arg = arg' then raise TERM (\"\", []) else ();\n    fun propfn g =\n      HOLogic.mk_eq (g arg, g arg')\n      |> HOLogic.mk_Trueprop |> Thm.cterm_of ctxt;\n    val eq1 =\n      Goal.prove_internal ctxt [] (propfn I)\n        (K (simp_tac (put_simpset word_ss ctxt) 1));\n  in\n    Goal.prove_internal ctxt [] (propfn (curry (op $) f))\n      (K (simp_tac (put_simpset HOL_ss ctxt addsimps [eq1]) 1))\n    |> mk_meta_eq |> SOME\n  end handle TERM _ => NONE;\n\nfun nat_get_Suc_simproc n_sucs ts =\n  Simplifier.make_simproc \\<^context> \"nat_get_Suc\"\n   {lhss = map (fn t => t $ \\<^term>\\<open>n :: nat\\<close>) ts,\n    proc = K (nat_get_Suc_simproc_fn n_sucs)};\n\nval no_split_ss =\n  simpset_of (put_simpset HOL_ss \\<^context>\n    |> Splitter.del_split @{thm if_split});\n\nval expand_word_eq_sss =\n  (simpset_of (put_simpset HOL_basic_ss \\<^context> addsimps\n       @{thms word_eq_rbl_eq word_le_rbl word_less_rbl word_sle_rbl word_sless_rbl}),\n  map simpset_of [\n   put_simpset no_split_ss \\<^context> addsimps\n    @{thms rbl_word_plus rbl_word_and rbl_word_or rbl_word_not\n                                rbl_word_neg bl_word_sub rbl_word_xor\n                                rbl_word_cat rbl_word_slice rbl_word_scast\n                                rbl_word_ucast rbl_shiftl rbl_shiftr rbl_sshiftr\n                                rbl_word_if},\n   put_simpset no_split_ss \\<^context> addsimps\n    @{thms to_bl_numeral to_bl_neg_numeral to_bl_0 rbl_word_1},\n   put_simpset no_split_ss \\<^context> addsimps\n    @{thms rev_rev_ident rev_replicate rev_map to_bl_upt word_size}\n          addsimprocs [word_len_simproc],\n   put_simpset no_split_ss \\<^context> addsimps\n    @{thms list.simps split_conv replicate.simps list.map\n                                zip_Cons_Cons zip_Nil drop_Suc_Cons drop_0 drop_Nil\n                                foldr.simps list.map zip.simps(1) zip_Nil zip_Cons_Cons takefill_Suc_Cons\n                                takefill_Suc_Nil takefill.Z rbl_succ2_simps\n                                rbl_plus_simps rev_bin_to_bl_simps append.simps\n                                takefill_last_simps drop_nonempty_simps\n                                rev_bl_order_simps}\n          addsimprocs [expand_upt_simproc,\n                       nat_get_Suc_simproc 4\n                         [\\<^term>\\<open>replicate\\<close>, \\<^term>\\<open>takefill x\\<close>,\n                          \\<^term>\\<open>drop\\<close>, \\<^term>\\<open>bin_to_bl\\<close>,\n                          \\<^term>\\<open>takefill_last x\\<close>,\n                          \\<^term>\\<open>drop_nonempty x\\<close>]],\n    put_simpset no_split_ss \\<^context> addsimps @{thms xor3_simps carry_simps if_bool_simps}\n  ])\n\nfun tac ctxt =\n  let\n    val (ss, sss) = expand_word_eq_sss;\n  in\n    foldr1 (op THEN_ALL_NEW)\n      ((CHANGED o safe_full_simp_tac (put_simpset ss ctxt)) ::\n        map (fn ss => safe_full_simp_tac (put_simpset ss ctxt)) sss)\n  end;\n\nend\n\\<close>"], ["", "method_setup word_bitwise =\n  \\<open>Scan.succeed (fn ctxt => Method.SIMPLE_METHOD (Word_Bitwise_Tac.tac ctxt 1))\\<close>\n  \"decomposer for word equalities and inequalities into bit propositions\""], ["", "end"]]}