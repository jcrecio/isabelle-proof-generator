{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/More_Word.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma unat_power_lower [simp]:\n  \"unat ((2::'a::len word) ^ n) = 2 ^ n\" if \"n < LENGTH('a::len)\"", "lemma unat_p2: \"n < LENGTH('a :: len) \\<Longrightarrow> unat (2 ^ n :: 'a word) = 2 ^ n\"", "lemma word_div_lt_eq_0:\n  \"x < y \\<Longrightarrow> x div y = 0\" for x :: \"'a :: len word\"", "lemma word_div_eq_1_iff: \"n div m = 1 \\<longleftrightarrow> n \\<ge> m \\<and> unat n < 2 * unat (m :: 'a :: len word)\"", "lemma shiftl_power:\n  \"(shiftl1 ^^ x) (y::'a::len word) = 2 ^ x * y\"", "lemma AND_twice [simp]:\n  \"(w AND m) AND m = w AND m\"", "lemma word_combine_masks:\n  \"w AND m = z \\<Longrightarrow> w AND m' = z' \\<Longrightarrow> w AND (m OR m') = (z OR z')\"\n  for w m m' z z' :: \\<open>'a::len word\\<close>", "lemma p2_gt_0:\n  \"(0 < (2 ^ n :: 'a :: len word)) = (n < LENGTH('a))\"", "lemma uint_2p_alt:\n  \\<open>n < LENGTH('a::len) \\<Longrightarrow> uint ((2::'a::len word) ^ n) = 2 ^ n\\<close>", "lemma p2_eq_0:\n  \\<open>(2::'a::len word) ^ n = 0 \\<longleftrightarrow> LENGTH('a::len) \\<le> n\\<close>", "lemma p2len:\n  \\<open>(2 :: 'a word) ^ LENGTH('a::len) = 0\\<close>", "lemma neg_mask_is_div:\n  \"w AND NOT (mask n) = (w div 2^n) * 2^n\"\n  for w :: \\<open>'a::len word\\<close>", "lemma neg_mask_is_div':\n  \"n < size w \\<Longrightarrow> w AND NOT (mask n) = ((w div (2 ^ n)) * (2 ^ n))\"\n  for w :: \\<open>'a::len word\\<close>", "lemma and_mask_arith:\n  \"w AND mask n = (w * 2^(size w - n)) div 2^(size w - n)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma and_mask_arith':\n  \"0 < n \\<Longrightarrow> w AND mask n = (w * 2^(size w - n)) div 2^(size w - n)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma mask_2pm1: \"mask n = 2 ^ n - (1 :: 'a::len word)\"", "lemma add_mask_fold:\n  \"x + 2 ^ n - 1 = x + mask n\"\n  for x :: \\<open>'a::len word\\<close>", "lemma word_and_mask_le_2pm1: \"w AND mask n \\<le> 2 ^ n - 1\"\n  for w :: \\<open>'a::len word\\<close>", "lemma is_aligned_AND_less_0:\n  \"u AND mask n = 0 \\<Longrightarrow> v < 2^n \\<Longrightarrow> u AND v = 0\"\n  for u v :: \\<open>'a::len word\\<close>", "lemma le_shiftr1:\n  \\<open>shiftr1 u \\<le> shiftr1 v\\<close> if \\<open>u \\<le> v\\<close>", "lemma and_mask_eq_iff_le_mask:\n  \\<open>w AND mask n = w \\<longleftrightarrow> w \\<le> mask n\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma less_eq_mask_iff_take_bit_eq_self:\n  \\<open>w \\<le> mask n \\<longleftrightarrow> take_bit n w = w\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma NOT_eq:\n  \"NOT (x :: 'a :: len word) = - x - 1\"", "lemma NOT_mask: \"NOT (mask n :: 'a::len word) = - (2 ^ n)\"", "lemma le_m1_iff_lt: \"(x > (0 :: 'a :: len word)) = ((y \\<le> x - 1) = (y < x))\"", "lemma gt0_iff_gem1:\n  \\<open>0 < x \\<longleftrightarrow> x - 1 < x\\<close>\n  for x :: \\<open>'a::len word\\<close>", "lemma power_2_ge_iff:\n  \\<open>2 ^ n - (1 :: 'a::len word) < 2 ^ n \\<longleftrightarrow> n < LENGTH('a)\\<close>", "lemma le_mask_iff_lt_2n:\n  \"n < len_of TYPE ('a) = (((w :: 'a :: len word) \\<le> mask n) = (w < 2 ^ n))\"", "lemma mask_lt_2pn:\n  \\<open>n < LENGTH('a) \\<Longrightarrow> mask n < (2 :: 'a::len word) ^ n\\<close>", "lemma word_unat_power:\n  \"(2 :: 'a :: len word) ^ n = of_nat (2 ^ n)\"", "lemma of_nat_mono_maybe:\n  assumes xlt: \"x < 2 ^ len_of TYPE ('a)\"\n  shows   \"y < x \\<Longrightarrow> of_nat y < (of_nat x :: 'a :: len word)\"", "lemma word_and_max_word:\n  fixes a::\"'a::len word\"\n  shows \"x = max_word \\<Longrightarrow> a AND x = a\"", "lemma word_and_full_mask_simp:\n  \\<open>x AND mask LENGTH('a) = x\\<close> for x :: \\<open>'a::len word\\<close>", "lemma of_int_uint:\n  \"of_int (uint x) = x\"", "lemma nat_mask_eq:\n  \\<open>nat (mask n) = mask n\\<close>", "lemma unat_mask_eq:\n  \\<open>unat (mask n :: 'a::len word) = mask (min LENGTH('a) n)\\<close>", "lemma word_plus_mono_left:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>y \\<le> z; x \\<le> x + z\\<rbrakk> \\<Longrightarrow> y + x \\<le> z + x\"", "lemma less_Suc_unat_less_bound:\n  \"n < Suc (unat (x :: 'a :: len word)) \\<Longrightarrow> n < 2 ^ LENGTH('a)\"", "lemma up_ucast_inj:\n  \"\\<lbrakk> ucast x = (ucast y::'b::len word); LENGTH('a) \\<le> len_of TYPE ('b) \\<rbrakk> \\<Longrightarrow> x = (y::'a::len word)\"", "lemmas ucast_up_inj = up_ucast_inj", "lemma up_ucast_inj_eq:\n  \"LENGTH('a) \\<le> len_of TYPE ('b) \\<Longrightarrow> (ucast x = (ucast y::'b::len word)) = (x = (y::'a::len word))\"", "lemma no_plus_overflow_neg:\n  \"(x :: 'a :: len word) < -y \\<Longrightarrow> x \\<le> x + y\"", "lemma ucast_ucast_eq:\n  \"\\<lbrakk> ucast x = (ucast (ucast y::'a word)::'c::len word); LENGTH('a) \\<le> LENGTH('b);\n     LENGTH('b) \\<le> LENGTH('c) \\<rbrakk> \\<Longrightarrow>\n   x = ucast y\" for x :: \"'a::len word\" and y :: \"'b::len word\"", "lemma ucast_0_I:\n  \"x = 0 \\<Longrightarrow> ucast x = 0\"", "lemma word_add_offset_less:\n  fixes x :: \"'a :: len word\"\n  assumes yv: \"y < 2 ^ n\"\n  and     xv: \"x < 2 ^ m\"\n  and     mnv: \"sz < LENGTH('a :: len)\"\n  and    xv': \"x < 2 ^ (LENGTH('a :: len) - n)\"\n  and     mn: \"sz = m + n\"\n  shows   \"x * 2 ^ n + y < 2 ^ sz\"", "lemma word_less_power_trans:\n  fixes n :: \"'a :: len word\"\n  assumes nv: \"n < 2 ^ (m - k)\"\n  and     kv: \"k \\<le> m\"\n  and     mv: \"m < len_of TYPE ('a)\"\n  shows \"2 ^ k * n < 2 ^ m\"", "lemma  word_less_power_trans2:\n  fixes n :: \"'a::len word\"\n  shows \"\\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk> \\<Longrightarrow> n * 2 ^ k < 2 ^ m\"", "lemma Suc_unat_diff_1:\n  fixes x :: \"'a :: len word\"\n  assumes lt: \"1 \\<le> x\"\n  shows \"Suc (unat (x - 1)) = unat x\"", "lemma word_eq_unatI:\n  \\<open>v = w\\<close> if \\<open>unat v = unat w\\<close>", "lemma word_div_sub:\n  fixes x :: \"'a :: len word\"\n  assumes yx: \"y \\<le> x\"\n  and     y0: \"0 < y\"\n  shows \"(x - y) div y = x div y - 1\"", "lemma word_mult_less_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i < j\"\n  and    knz: \"0 < k\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i * k < j * k\"", "lemma word_mult_less_dest:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i * k < j * k\"\n  and    uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i < j\"", "lemma word_mult_less_cancel:\n  fixes k :: \"'a :: len word\"\n  assumes knz: \"0 < k\"\n  and    uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows \"(i * k < j * k) = (i < j)\"", "lemma Suc_div_unat_helper:\n  assumes szv: \"sz < LENGTH('a :: len)\"\n  and   usszv: \"us \\<le> sz\"\n  shows \"2 ^ (sz - us) = Suc (unat (((2::'a :: len word) ^ sz - 1) div 2 ^ us))\"", "lemma enum_word_nth_eq:\n  \\<open>(Enum.enum :: 'a::len word list) ! n = word_of_nat n\\<close>\n    if \\<open>n < 2 ^ LENGTH('a)\\<close>\n    for n", "lemma length_enum_word_eq:\n  \\<open>length (Enum.enum :: 'a::len word list) = 2 ^ LENGTH('a)\\<close>", "lemma unat_lt2p [iff]:\n  \\<open>unat x < 2 ^ LENGTH('a)\\<close> for x :: \\<open>'a::len word\\<close>", "lemma of_nat_unat [simp]:\n  \"of_nat \\<circ> unat = id\"", "lemma Suc_unat_minus_one [simp]:\n  \"x \\<noteq> 0 \\<Longrightarrow> Suc (unat (x - 1)) = unat x\"", "lemma word_add_le_dest:\n  fixes i :: \"'a :: len word\"\n  assumes le: \"i + k \\<le> j + k\"\n  and    uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i \\<le> j\"", "lemma word_add_le_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i \\<le> j\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i + k \\<le> j + k\"", "lemma word_add_le_mono2:\n  fixes i :: \"'a :: len word\"\n  shows \"\\<lbrakk>i \\<le> j; unat j + unat k < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow> k + i \\<le> k + j\"", "lemma word_add_le_iff:\n  fixes i :: \"'a :: len word\"\n  assumes uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i + k \\<le> j + k) = (i \\<le> j)\"", "lemma word_add_less_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i < j\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i + k < j + k\"", "lemma word_add_less_dest:\n  fixes i :: \"'a :: len word\"\n  assumes le: \"i + k < j + k\"\n  and    uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i < j\"", "lemma word_add_less_iff:\n  fixes i :: \"'a :: len word\"\n  assumes uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i + k < j + k) = (i < j)\"", "lemma word_mult_less_iff:\n  fixes i :: \"'a :: len word\"\n  assumes knz: \"0 < k\"\n  and     uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i * k < j * k) = (i < j)\"", "lemma word_le_imp_diff_le:\n  fixes n :: \"'a::len word\"\n  shows \"\\<lbrakk>k \\<le> n; n \\<le> m\\<rbrakk> \\<Longrightarrow> n - k \\<le> m\"", "lemma word_less_imp_diff_less:\n  fixes n :: \"'a::len word\"\n  shows \"\\<lbrakk>k \\<le> n; n < m\\<rbrakk> \\<Longrightarrow> n - k < m\"", "lemma word_mult_le_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i \\<le> j\"\n  and    knz: \"0 < k\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i * k \\<le> j * k\"", "lemma word_mult_le_iff:\n  fixes i :: \"'a :: len word\"\n  assumes knz: \"0 < k\"\n  and     uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i * k \\<le> j * k) = (i \\<le> j)\"", "lemma word_diff_less:\n  fixes n :: \"'a :: len word\"\n  shows \"\\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk> \\<Longrightarrow> m - n < m\"", "lemma word_add_increasing:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> p + w \\<le> x; p \\<le> p + w \\<rbrakk> \\<Longrightarrow> p \\<le> x\"", "lemma word_random:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> p \\<le> p + x'; x \\<le> x' \\<rbrakk> \\<Longrightarrow> p \\<le> p + x\"", "lemma word_sub_mono:\n  \"\\<lbrakk> a \\<le> c; d \\<le> b; a - b \\<le> a; c - d \\<le> c \\<rbrakk>\n    \\<Longrightarrow> (a - b) \\<le> (c - d :: 'a :: len word)\"", "lemma power_not_zero:\n  \"n < LENGTH('a::len) \\<Longrightarrow> (2 :: 'a word) ^ n \\<noteq> 0\"", "lemma word_gt_a_gt_0:\n  \"a < n \\<Longrightarrow> (0 :: 'a::len word) < n\"", "lemma word_power_less_1 [simp]:\n  \"sz < LENGTH('a::len) \\<Longrightarrow> (2::'a word) ^ sz - 1 < 2 ^ sz\"", "lemma word_sub_1_le:\n  \"x \\<noteq> 0 \\<Longrightarrow> x - 1 \\<le> (x :: ('a :: len) word)\"", "lemma push_bit_word_eq_nonzero:\n  \\<open>push_bit n w \\<noteq> 0\\<close> if \\<open>w < 2 ^ m\\<close> \\<open>m + n < LENGTH('a)\\<close> \\<open>w \\<noteq> 0\\<close>\n    for w :: \\<open>'a::len word\\<close>", "lemma unat_less_power:\n  fixes k :: \"'a::len word\"\n  assumes szv: \"sz < LENGTH('a)\"\n  and     kv:  \"k < 2 ^ sz\"\n  shows   \"unat k < 2 ^ sz\"", "lemma unat_mult_power_lem:\n  assumes kv: \"k < 2 ^ (LENGTH('a::len) - sz)\"\n  shows \"unat (2 ^ sz * of_nat k :: (('a::len) word)) = 2 ^ sz * k\"", "lemma word_plus_mcs_4:\n  \"\\<lbrakk>v + x \\<le> w + x; x \\<le> v + x\\<rbrakk> \\<Longrightarrow> v \\<le> (w::'a::len word)\"", "lemma word_plus_mcs_3:\n  \"\\<lbrakk>v \\<le> w; x \\<le> w + x\\<rbrakk> \\<Longrightarrow> v + x \\<le> w + (x::'a::len word)\"", "lemma word_le_minus_one_leq:\n  \"x < y \\<Longrightarrow> x \\<le> y - 1\" for x :: \"'a :: len word\"", "lemma word_less_sub_le[simp]:\n  fixes x :: \"'a :: len word\"\n  assumes nv: \"n < LENGTH('a)\"\n  shows \"(x \\<le> 2 ^ n - 1) = (x < 2 ^ n)\"", "lemma unat_of_nat_len:\n  \"x < 2 ^ LENGTH('a) \\<Longrightarrow> unat (of_nat x :: 'a::len word) = x\"", "lemma unat_of_nat_eq:\n  \"x < 2 ^ LENGTH('a) \\<Longrightarrow> unat (of_nat x ::'a::len word) = x\"", "lemma unat_eq_of_nat:\n  \"n < 2 ^ LENGTH('a) \\<Longrightarrow> (unat (x :: 'a::len word) = n) = (x = of_nat n)\"", "lemma alignUp_div_helper:\n  fixes a :: \"'a::len word\"\n  assumes kv: \"k < 2 ^ (LENGTH('a) - n)\"\n  and     xk: \"x = 2 ^ n * of_nat k\"\n  and    le: \"a \\<le> x\"\n  and    sz: \"n < LENGTH('a)\"\n  and   anz: \"a mod 2 ^ n \\<noteq> 0\"\n  shows \"a div 2 ^ n < of_nat k\"", "lemma mask_out_sub_mask:\n  \"(x AND NOT (mask n)) = x - (x AND (mask n))\"\n  for x :: \\<open>'a::len word\\<close>", "lemma subtract_mask:\n  \"p - (p AND mask n) = (p AND NOT (mask n))\"\n  \"p - (p AND NOT (mask n)) = (p AND mask n)\"\n  for p :: \\<open>'a::len word\\<close>", "lemma take_bit_word_eq_self_iff:\n  \\<open>take_bit n w = w \\<longleftrightarrow> n \\<ge> LENGTH('a) \\<or> w < 2 ^ n\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma word_power_increasing:\n  assumes x: \"2 ^ x < (2 ^ y::'a::len word)\" \"x < LENGTH('a::len)\" \"y < LENGTH('a::len)\"\n  shows \"x < y\"", "lemma mask_twice:\n  \"(x AND mask n) AND mask m = x AND mask (min m n)\"\n  for x :: \\<open>'a::len word\\<close>", "lemma plus_one_helper[elim!]:\n  \"x < n + (1 :: 'a :: len word) \\<Longrightarrow> x \\<le> n\"", "lemma plus_one_helper2:\n  \"\\<lbrakk> x \\<le> n; n + 1 \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x < n + (1 :: 'a :: len word)\"", "lemma less_x_plus_1:\n  fixes x :: \"'a :: len word\" shows\n  \"x \\<noteq> max_word \\<Longrightarrow> (y < (x + 1)) = (y < x \\<or> y = x)\"", "lemma word_Suc_leq:\n  fixes k::\"'a::len word\" shows \"k \\<noteq> max_word \\<Longrightarrow> x < k + 1 \\<longleftrightarrow> x \\<le> k\"", "lemma word_Suc_le:\n   fixes k::\"'a::len word\" shows \"x \\<noteq> max_word \\<Longrightarrow> x + 1 \\<le> k \\<longleftrightarrow> x < k\"", "lemma word_lessThan_Suc_atMost:\n  \\<open>{..< k + 1} = {..k}\\<close> if \\<open>k \\<noteq> - 1\\<close> for k :: \\<open>'a::len word\\<close>", "lemma word_atLeastLessThan_Suc_atLeastAtMost:\n  \\<open>{l ..< u + 1} = {l..u}\\<close> if \\<open>u \\<noteq> - 1\\<close> for l :: \\<open>'a::len word\\<close>", "lemma word_atLeastAtMost_Suc_greaterThanAtMost:\n  \\<open>{m<..u} = {m + 1..u}\\<close> if \\<open>m \\<noteq> - 1\\<close> for m :: \\<open>'a::len word\\<close>", "lemma word_atLeastLessThan_Suc_atLeastAtMost_union:\n  fixes l::\"'a::len word\"\n  assumes \"m \\<noteq> max_word\" and \"l \\<le> m\" and \"m \\<le> u\"\n  shows \"{l..m} \\<union> {m+1..u} = {l..u}\"", "lemma max_word_less_eq_iff [simp]:\n  \\<open>- 1 \\<le> w \\<longleftrightarrow> w = - 1\\<close> for w :: \\<open>'a::len word\\<close>", "lemma word_or_zero:\n  \"(a OR b = 0) = (a = 0 \\<and> b = 0)\"\n  for a b :: \\<open>'a::len word\\<close>", "lemma word_2p_mult_inc:\n  assumes x: \"2 * 2 ^ n < (2::'a::len word) * 2 ^ m\"\n  assumes suc_n: \"Suc n < LENGTH('a::len)\"\n  shows \"2^n < (2::'a::len word)^m\"", "lemma power_overflow:\n  \"n \\<ge> LENGTH('a) \\<Longrightarrow> 2 ^ n = (0 :: 'a::len word)\"", "lemmas extra_sle_sless_unfolds [simp] =\n    word_sle_eq[where a=0 and b=1]\n    word_sle_eq[where a=0 and b=\"numeral n\"]\n    word_sle_eq[where a=1 and b=0]\n    word_sle_eq[where a=1 and b=\"numeral n\"]\n    word_sle_eq[where a=\"numeral n\" and b=0]\n    word_sle_eq[where a=\"numeral n\" and b=1]\n    word_sless_alt[where a=0 and b=1]\n    word_sless_alt[where a=0 and b=\"numeral n\"]\n    word_sless_alt[where a=1 and b=0]\n    word_sless_alt[where a=1 and b=\"numeral n\"]\n    word_sless_alt[where a=\"numeral n\" and b=0]\n    word_sless_alt[where a=\"numeral n\" and b=1]\n  for n", "lemma word_sint_1:\n  \"sint (1::'a::len word) = (if LENGTH('a) = 1 then -1 else 1)\"", "lemma ucast_of_nat:\n  \"is_down (ucast :: 'a :: len word \\<Rightarrow> 'b :: len word)\n    \\<Longrightarrow> ucast (of_nat n :: 'a word) = (of_nat n :: 'b word)\"", "lemma scast_1':\n  \"(scast (1::'a::len word) :: 'b::len word) =\n   (word_of_int (signed_take_bit (LENGTH('a::len) - Suc 0) (1::int)))\"", "lemma scast_1:\n  \"(scast (1::'a::len word) :: 'b::len word) = (if LENGTH('a) = 1 then -1 else 1)\"", "lemma unat_minus_one_word:\n  \"unat (-1 :: 'a :: len word) = 2 ^ LENGTH('a) - 1\"", "lemmas word_diff_ls'' = word_diff_ls [where xa=x and x=x for x]", "lemmas word_diff_ls' = word_diff_ls'' [simplified]", "lemmas word_l_diffs' = word_l_diffs [where xa=x and x=x for x]", "lemmas word_l_diffs = word_l_diffs' [simplified]", "lemma two_power_increasing:\n  \"\\<lbrakk> n \\<le> m; m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 :: 'a :: len word) ^ n \\<le> 2 ^ m\"", "lemma word_leq_le_minus_one:\n  \"\\<lbrakk> x \\<le> y; x \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x - 1 < (y :: 'a :: len word)\"", "lemma neg_mask_combine:\n  \"NOT(mask a) AND NOT(mask b) = NOT(mask (max a b) :: 'a::len word)\"", "lemma neg_mask_twice:\n  \"x AND NOT(mask n) AND NOT(mask m) = x AND NOT(mask (max n m))\"\n  for x :: \\<open>'a::len word\\<close>", "lemma multiple_mask_trivia:\n  \"n \\<ge> m \\<Longrightarrow> (x AND NOT(mask n)) + (x AND mask n AND NOT(mask m)) = x AND NOT(mask m)\"\n  for x :: \\<open>'a::len word\\<close>", "lemma word_of_nat_less:\n  \"\\<lbrakk> n < unat x \\<rbrakk> \\<Longrightarrow> of_nat n < x\"", "lemma unat_mask:\n  \"unat (mask n :: 'a :: len word) = 2 ^ (min n (LENGTH('a))) - 1\"", "lemma mask_over_length:\n  \"LENGTH('a) \\<le> n \\<Longrightarrow> mask n = (-1::'a::len word)\"", "lemma Suc_2p_unat_mask:\n  \"n < LENGTH('a) \\<Longrightarrow> Suc (2 ^ n * k + unat (mask n :: 'a::len word)) = 2 ^ n * (k+1)\"", "lemma sint_of_nat_ge_zero:\n  \"x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> sint (of_nat x :: 'a :: len word) \\<ge> 0\"", "lemma int_eq_sint:\n  \"x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> sint (of_nat x :: 'a :: len word) = int x\"", "lemma sint_of_nat_le:\n  \"\\<lbrakk> b < 2 ^ (LENGTH('a) - 1); a \\<le> b \\<rbrakk>\n   \\<Longrightarrow> sint (of_nat a :: 'a :: len word) \\<le> sint (of_nat b :: 'a :: len word)\"", "lemma word_le_not_less:\n  \"((b::'a::len word) \\<le> a) = (\\<not>(a < b))\"", "lemma less_is_non_zero_p1:\n  fixes a :: \"'a :: len word\"\n  shows \"a < k \\<Longrightarrow> a + 1 \\<noteq> 0\"", "lemma unat_add_lem':\n  \"(unat x + unat y < 2 ^ LENGTH('a)) \\<Longrightarrow>\n    (unat (x + y :: 'a :: len word) = unat x + unat y)\"", "lemma word_less_two_pow_divI:\n  \"\\<lbrakk> (x :: 'a::len word) < 2 ^ (n - m); m \\<le> n; n < LENGTH('a) \\<rbrakk> \\<Longrightarrow> x < 2 ^ n div 2 ^ m\"", "lemma word_less_two_pow_divD:\n  \"\\<lbrakk> (x :: 'a::len word) < 2 ^ n div 2 ^ m \\<rbrakk>\n     \\<Longrightarrow> n \\<ge> m \\<and> (x < 2 ^ (n - m))\"", "lemma of_nat_less_two_pow_div_set:\n  \"\\<lbrakk> n < LENGTH('a) \\<rbrakk> \\<Longrightarrow>\n   {x. x < (2 ^ n div 2 ^ m :: 'a::len word)}\n      = of_nat ` {k. k < 2 ^ n div 2 ^ m}\"", "lemma ucast_less:\n  \"LENGTH('b) < LENGTH('a) \\<Longrightarrow>\n   (ucast (x :: 'b :: len word) :: ('a :: len word)) < 2 ^ LENGTH('b)\"", "lemma ucast_range_less:\n  \"LENGTH('a :: len) < LENGTH('b :: len) \\<Longrightarrow>\n   range (ucast :: 'a word \\<Rightarrow> 'b word) = {x. x < 2 ^ len_of TYPE ('a)}\"", "lemma word_power_less_diff:\n  \"\\<lbrakk>2 ^ n * q < (2::'a::len word) ^ m; q < 2 ^ (LENGTH('a) - n)\\<rbrakk> \\<Longrightarrow> q < 2 ^ (m - n)\"", "lemma word_less_sub_1:\n  \"x < (y :: 'a :: len word) \\<Longrightarrow> x \\<le> y - 1\"", "lemma word_sub_mono2:\n  \"\\<lbrakk> a + b \\<le> c + d; c \\<le> a; b \\<le> a + b; d \\<le> c + d \\<rbrakk>\n    \\<Longrightarrow> b \\<le> (d :: 'a :: len word)\"", "lemma word_not_le:\n  \"(\\<not> x \\<le> (y :: 'a :: len word)) = (y < x)\"", "lemma word_subset_less:\n  \"\\<lbrakk> {x .. x + r - 1} \\<subseteq> {y .. y + s - 1};\n     x \\<le> x + r - 1; y \\<le> y + (s :: 'a :: len word) - 1;\n     s \\<noteq> 0 \\<rbrakk>\n     \\<Longrightarrow> r \\<le> s\"", "lemma uint_power_lower:\n  \"n < LENGTH('a) \\<Longrightarrow> uint (2 ^ n :: 'a :: len word) = (2 ^ n :: int)\"", "lemma power_le_mono:\n  \"\\<lbrakk>2 ^ n \\<le> (2::'a::len word) ^ m; n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> n \\<le> m\"", "lemma two_power_eq:\n  \"\\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> ((2::'a::len word) ^ n = 2 ^ m) = (n = m)\"", "lemma unat_less_helper:\n  \"x < of_nat n \\<Longrightarrow> unat x < n\"", "lemma nat_uint_less_helper:\n  \"nat (uint y) = z \\<Longrightarrow> x < y \\<Longrightarrow> nat (uint x) < z\"", "lemma of_nat_0:\n  \"\\<lbrakk>of_nat n = (0::'a::len word); n < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow> n = 0\"", "lemma of_nat_inj:\n  \"\\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow>\n   (of_nat x = (of_nat y :: 'a :: len word)) = (x = y)\"", "lemma div_to_mult_word_lt:\n  \"\\<lbrakk> (x :: 'a :: len word) \\<le> y div z \\<rbrakk> \\<Longrightarrow> x * z \\<le> y\"", "lemma ucast_ucast_mask:\n  \"(ucast :: 'a :: len word \\<Rightarrow> 'b :: len word) (ucast x) = x AND mask (len_of TYPE ('a))\"", "lemma ucast_ucast_len:\n  \"\\<lbrakk> x < 2 ^ LENGTH('b) \\<rbrakk> \\<Longrightarrow> ucast (ucast x::'b::len word) = (x::'a::len word)\"", "lemma ucast_ucast_id:\n  \"LENGTH('a) < LENGTH('b) \\<Longrightarrow> ucast (ucast (x::'a::len word)::'b::len word) = x\"", "lemma unat_ucast:\n  \"unat (ucast x :: ('a :: len) word) = unat x mod 2 ^ (LENGTH('a))\"", "lemma ucast_less_ucast:\n  \"LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n   (ucast x < ((ucast (y :: 'a::len word)) :: 'b::len word)) = (x < y)\"", "lemmas ucast_less_ucast_weak = ucast_less_ucast[OF order.strict_implies_order]", "lemma unat_Suc2:\n  fixes n :: \"'a :: len word\"\n  shows\n  \"n \\<noteq> -1 \\<Longrightarrow> unat (n + 1) = Suc (unat n)\"", "lemma word_div_1:\n  \"(n :: 'a :: len word) div 1 = n\"", "lemma word_minus_one_le:\n  \"-1 \\<le> (x :: 'a :: len word) = (x = -1)\"", "lemma up_scast_inj:\n      \"\\<lbrakk> scast x = (scast y :: 'b :: len word); size x \\<le> LENGTH('b) \\<rbrakk>\n         \\<Longrightarrow> x = y\"", "lemma up_scast_inj_eq:\n  \"LENGTH('a) \\<le> len_of TYPE ('b) \\<Longrightarrow>\n  (scast x = (scast y::'b::len word)) = (x = (y::'a::len word))\"", "lemma word_le_add:\n  fixes x :: \"'a :: len word\"\n  shows \"x \\<le> y \\<Longrightarrow> \\<exists>n. y = x + of_nat n\"", "lemma word_plus_mcs_4':\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>x + v \\<le> x + w; x \\<le> x + v\\<rbrakk> \\<Longrightarrow> v \\<le> w\"", "lemma unat_eq_1:\n  \\<open>unat x = Suc 0 \\<longleftrightarrow> x = 1\\<close>", "lemma word_unat_Rep_inject1:\n  \\<open>unat x = unat 1 \\<longleftrightarrow> x = 1\\<close>", "lemma and_not_mask_twice:\n  \"(w AND NOT (mask n)) AND NOT (mask m) = w AND NOT (mask (max m n))\"\n  for w :: \\<open>'a::len word\\<close>", "lemma word_less_cases:\n  \"x < y \\<Longrightarrow> x = y - 1 \\<or> x < y - (1 ::'a::len word)\"", "lemma mask_and_mask:\n  \"mask a AND mask b = (mask (min a b) :: 'a::len word)\"", "lemma mask_eq_0_eq_x:\n  \"(x AND w = 0) = (x AND NOT w = x)\"\n  for x w :: \\<open>'a::len word\\<close>", "lemma mask_eq_x_eq_0:\n  \"(x AND w = x) = (x AND NOT w = 0)\"\n  for x w :: \\<open>'a::len word\\<close>", "lemma compl_of_1: \"NOT 1 = (-2 :: 'a :: len word)\"", "lemma split_word_eq_on_mask:\n  \"(x = y) = (x AND m = y AND m \\<and> x AND NOT m = y AND NOT m)\"\n  for x y m :: \\<open>'a::len word\\<close>", "lemma word_FF_is_mask:\n  \"0xFF = (mask 8 :: 'a::len word)\"", "lemma word_1FF_is_mask:\n  \"0x1FF = (mask 9 :: 'a::len word)\"", "lemma ucast_of_nat_small:\n  \"x < 2 ^ LENGTH('a) \\<Longrightarrow> ucast (of_nat x :: 'a :: len word) = (of_nat x :: 'b :: len word)\"", "lemma word_le_make_less:\n  fixes x :: \"'a :: len word\"\n  shows \"y \\<noteq> -1 \\<Longrightarrow> (x \\<le> y) = (x < (y + 1))\"", "lemmas finite_word = finite [where 'a=\"'a::len word\"]", "lemma word_to_1_set:\n  \"{0 ..< (1 :: 'a :: len word)} = {0}\"", "lemma word_leq_minus_one_le:\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk>y \\<noteq> 0; x \\<le> y - 1 \\<rbrakk> \\<Longrightarrow> x < y\"", "lemma word_count_from_top:\n  \"n \\<noteq> 0 \\<Longrightarrow> {0 ..< n :: 'a :: len word} = {0 ..< n - 1} \\<union> {n - 1}\"", "lemma word_minus_one_le_leq:\n  \"\\<lbrakk> x - 1 < y \\<rbrakk> \\<Longrightarrow> x \\<le> (y :: 'a :: len word)\"", "lemma word_div_less:\n  \"m < n \\<Longrightarrow> m div n = 0\" for m :: \"'a :: len word\"", "lemma word_must_wrap:\n  \"\\<lbrakk> x \\<le> n - 1; n \\<le> x \\<rbrakk> \\<Longrightarrow> n = (0 :: 'a :: len word)\"", "lemma range_subset_card:\n  \"\\<lbrakk> {a :: 'a :: len word .. b} \\<subseteq> {c .. d}; b \\<ge> a \\<rbrakk> \\<Longrightarrow> d \\<ge> c \\<and> d - c \\<ge> b - a\"", "lemma less_1_simp:\n  \"n - 1 < m = (n \\<le> (m :: 'a :: len word) \\<and> n \\<noteq> 0)\"", "lemma word_power_mod_div:\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk> n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> x mod 2 ^ n div 2 ^ m = x div 2 ^ m mod 2 ^ (n - m)\"", "lemma word_range_minus_1':\n  fixes a :: \"'a :: len word\"\n  shows \"a \\<noteq> 0 \\<Longrightarrow> {a - 1<..b} = {a..b}\"", "lemma word_range_minus_1:\n  fixes a :: \"'a :: len word\"\n  shows \"b \\<noteq> 0 \\<Longrightarrow> {a..b - 1} = {a..<b}\"", "lemma ucast_nat_def:\n  \"of_nat (unat x) = (ucast :: 'a :: len word \\<Rightarrow> 'b :: len word) x\"", "lemma overflow_plus_one_self:\n  \"(1 + p \\<le> p) = (p = (-1 :: 'a :: len word))\"", "lemma plus_1_less:\n  \"(x + 1 \\<le> (x :: 'a :: len word)) = (x = -1)\"", "lemma pos_mult_pos_ge:\n  \"[|x > (0::int); n>=0 |] ==> n * x >= n*1\"", "lemma word_plus_strict_mono_right:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>y < z; x \\<le> x + z\\<rbrakk> \\<Longrightarrow> x + y < x + z\"", "lemma word_div_mult:\n  \"0 < c \\<Longrightarrow> a < b * c \\<Longrightarrow> a div c < b\" for a b c :: \"'a::len word\"", "lemma word_less_power_trans_ofnat:\n  \"\\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> of_nat n * 2 ^ k < (2::'a::len word) ^ m\"", "lemma word_1_le_power:\n  \"n < LENGTH('a) \\<Longrightarrow> (1 :: 'a :: len word) \\<le> 2 ^ n\"", "lemma unat_1_0:\n  \"1 \\<le> (x::'a::len word) = (0 < unat x)\"", "lemma x_less_2_0_1':\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk> \\<Longrightarrow> x = 0 \\<or> x = 1\"", "lemmas word_add_le_iff2 = word_add_le_iff [folded no_olen_add_nat]", "lemma of_nat_power:\n  shows \"\\<lbrakk> p < 2 ^ x; x < len_of TYPE ('a) \\<rbrakk> \\<Longrightarrow> of_nat p < (2 :: 'a :: len word) ^ x\"", "lemma of_nat_n_less_equal_power_2:\n  \"n < LENGTH('a::len) \\<Longrightarrow> ((of_nat n)::'a word) < 2 ^ n\"", "lemma eq_mask_less:\n  fixes w :: \"'a::len word\"\n  assumes eqm: \"w = w AND mask n\"\n  and      sz: \"n < len_of TYPE ('a)\"\n  shows \"w < (2::'a word) ^ n\"", "lemma of_nat_mono_maybe':\n  fixes Y :: \"nat\"\n  assumes xlt: \"x < 2 ^ len_of TYPE ('a)\"\n  assumes ylt: \"y < 2 ^ len_of TYPE ('a)\"\n  shows   \"(y < x) = (of_nat y < (of_nat x :: 'a :: len word))\"", "lemma of_nat_mono_maybe_le:\n  \"\\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow>\n  (y \\<le> x) = ((of_nat y :: 'a :: len word) \\<le> of_nat x)\"", "lemma mask_AND_NOT_mask:\n  \"(w AND NOT (mask n)) AND mask n = 0\"\n  for w :: \\<open>'a::len word\\<close>", "lemma AND_NOT_mask_plus_AND_mask_eq:\n  \"(w AND NOT (mask n)) + (w AND mask n) = w\"\n  for w :: \\<open>'a::len word\\<close>", "lemma mask_eqI:\n  fixes x :: \"'a :: len word\"\n  assumes m1: \"x AND mask n = y AND mask n\"\n  and     m2: \"x AND NOT (mask n) = y AND NOT (mask n)\"\n  shows \"x = y\"", "lemma neq_0_no_wrap:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> x \\<le> x + y; x \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x + y \\<noteq> 0\"", "lemma unatSuc2:\n  fixes n :: \"'a :: len word\"\n  shows \"n + 1 \\<noteq> 0 \\<Longrightarrow> unat (n + 1) = Suc (unat n)\"", "lemma word_of_nat_le:\n  \"n \\<le> unat x \\<Longrightarrow> of_nat n \\<le> x\"", "lemma word_unat_less_le:\n  \"a \\<le> of_nat b \\<Longrightarrow> unat a \\<le> b\"", "lemma mask_Suc_0 : \"mask (Suc 0) = (1 :: 'a::len word)\"", "lemma bool_mask':\n  fixes x :: \"'a :: len word\"\n  shows \"2 < LENGTH('a) \\<Longrightarrow> (0 < x AND 1) = (x AND 1 = 1)\"", "lemma ucast_ucast_add:\n  fixes x :: \"'a :: len word\"\n  fixes y :: \"'b :: len word\"\n  shows\n  \"LENGTH('b) \\<ge> LENGTH('a) \\<Longrightarrow>\n    ucast (ucast x + y) = x + ucast y\"", "lemma lt1_neq0:\n  fixes x :: \"'a :: len word\"\n  shows \"(1 \\<le> x) = (x \\<noteq> 0)\"", "lemma word_plus_one_nonzero:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>x \\<le> x + y; y \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x + 1 \\<noteq> 0\"", "lemma word_sub_plus_one_nonzero:\n  fixes n :: \"'a :: len word\"\n  shows \"\\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk> \\<Longrightarrow> (n - n') + 1 \\<noteq> 0\"", "lemma word_le_minus_mono_right:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> z \\<le> y; y \\<le> x; z \\<le> x \\<rbrakk> \\<Longrightarrow> x - y \\<le> x - z\"", "lemma word_0_sle_from_less:\n  \\<open>0 \\<le>s x\\<close> if \\<open>x < 2 ^ (LENGTH('a) - 1)\\<close> for x :: \\<open>'a::len word\\<close>", "lemma ucast_sub_ucast:\n  fixes x :: \"'a::len word\"\n  assumes \"y \\<le> x\"\n  assumes T: \"LENGTH('a) \\<le> LENGTH('b)\"\n  shows \"ucast (x - y) = (ucast x - ucast y :: 'b::len word)\"", "lemma word_1_0:\n  \"\\<lbrakk>a + (1::('a::len) word) \\<le> b; a < of_nat x\\<rbrakk> \\<Longrightarrow> a < b\"", "lemma unat_of_nat_less:\"\\<lbrakk> a < b; unat b = c \\<rbrakk> \\<Longrightarrow> a < of_nat c\"", "lemma word_le_plus_1: \"\\<lbrakk> (y::('a::len) word) < y + n; a < n \\<rbrakk> \\<Longrightarrow> y + a \\<le> y + a + 1\"", "lemma word_le_plus:\"\\<lbrakk>(a::('a::len) word) < a + b; c < b\\<rbrakk> \\<Longrightarrow> a \\<le> a + c\"", "lemma sint_minus1 [simp]: \"(sint x = -1) = (x = -1)\"", "lemma sint_0 [simp]: \"(sint x = 0) = (x = 0)\"", "lemma sint_1_cases:\n  P if \\<open>\\<lbrakk> len_of TYPE ('a::len) = 1; (a::'a word) = 0; sint a = 0 \\<rbrakk> \\<Longrightarrow> P\\<close>\n     \\<open>\\<lbrakk> len_of TYPE ('a) = 1; a = 1; sint (1 :: 'a word) = -1 \\<rbrakk> \\<Longrightarrow> P\\<close>\n     \\<open>\\<lbrakk> len_of TYPE ('a) > 1; sint (1 :: 'a word) = 1 \\<rbrakk> \\<Longrightarrow> P\\<close>", "lemma sint_int_min:\n  \"sint (- (2 ^ (LENGTH('a) - Suc 0)) :: ('a::len) word) = - (2 ^ (LENGTH('a) - Suc 0))\"", "lemma sint_int_max_plus_1:\n  \"sint (2 ^ (LENGTH('a) - Suc 0) :: ('a::len) word) = - (2 ^ (LENGTH('a) - Suc 0))\"", "lemma uint_range':\n  \\<open>0 \\<le> uint x \\<and> uint x < 2 ^ LENGTH('a)\\<close>\n  for x :: \\<open>'a::len word\\<close>", "lemma sint_of_int_eq:\n  \"\\<lbrakk> - (2 ^ (LENGTH('a) - 1)) \\<le> x; x < 2 ^ (LENGTH('a) - 1) \\<rbrakk> \\<Longrightarrow> sint (of_int x :: ('a::len) word) = x\"", "lemma of_int_sint:\n  \"of_int (sint a) = a\"", "lemma sint_ucast_eq_uint:\n    \"\\<lbrakk> \\<not> is_down (ucast :: ('a::len word \\<Rightarrow> 'b::len word)) \\<rbrakk>\n            \\<Longrightarrow> sint ((ucast :: ('a::len word \\<Rightarrow> 'b::len word)) x) = uint x\"", "lemma word_less_nowrapI':\n  \"(x :: 'a :: len word) \\<le> z - k \\<Longrightarrow> k \\<le> z \\<Longrightarrow> 0 < k \\<Longrightarrow> x < x + k\"", "lemma mask_plus_1:\n  \"mask n + 1 = (2 ^ n :: 'a::len word)\"", "lemma unat_inj: \"inj unat\"", "lemma unat_ucast_upcast:\n  \"is_up (ucast :: 'b word \\<Rightarrow> 'a word)\n      \\<Longrightarrow> unat (ucast x :: ('a::len) word) = unat (x :: ('b::len) word)\"", "lemma ucast_mono:\n  \"\\<lbrakk> (x :: 'b :: len word) < y; y < 2 ^ LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> ucast x < ((ucast y) :: 'a :: len word)\"", "lemma ucast_mono_le:\n  \"\\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk> \\<Longrightarrow> (ucast (x :: 'a :: len word) :: 'b :: len word) \\<le> ucast y\"", "lemma ucast_mono_le':\n  \"\\<lbrakk> unat y < 2 ^ LENGTH('b); LENGTH('b::len) < LENGTH('a::len); x \\<le> y \\<rbrakk>\n   \\<Longrightarrow> ucast x \\<le> (ucast y :: 'b word)\" for x y :: \\<open>'a::len word\\<close>", "lemma neg_mask_add_mask:\n  \"((x:: 'a :: len word) AND NOT (mask n)) + (2 ^ n - 1) = x OR mask n\"", "lemma le_step_down_word:\"\\<lbrakk>(i::('a::len) word) \\<le> n; i = n \\<longrightarrow> P; i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma le_step_down_word_2:\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk>x \\<le>  y; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> x \\<le> y - 1\"", "lemma NOT_mask_AND_mask[simp]: \"(w AND mask n) AND NOT (mask n) = 0\"", "lemma and_and_not[simp]:\"(a AND b) AND NOT b = 0\"\n  for a b :: \\<open>'a::len word\\<close>", "lemma ex_mask_1[simp]: \"(\\<exists>x. mask x = (1 :: 'a::len word))\"", "lemma not_switch:\"NOT a = x \\<Longrightarrow> a = NOT x\""], "translations": [["", "lemma unat_power_lower [simp]:\n  \"unat ((2::'a::len word) ^ n) = 2 ^ n\" if \"n < LENGTH('a::len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ n) = 2 ^ n", "using that"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (2 ^ n) = 2 ^ n", "by transfer simp"], ["", "lemma unat_p2: \"n < LENGTH('a :: len) \\<Longrightarrow> unat (2 ^ n :: 'a word) = 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> unat (2 ^ n) = 2 ^ n", "by (fact unat_power_lower)"], ["", "lemma word_div_lt_eq_0:\n  \"x < y \\<Longrightarrow> x div y = 0\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> x div y = 0", "by transfer simp"], ["", "lemma word_div_eq_1_iff: \"n div m = 1 \\<longleftrightarrow> n \\<ge> m \\<and> unat n < 2 * unat (m :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div m = 1) = (m \\<le> n \\<and> unat n < 2 * unat m)", "apply (simp only: word_arith_nat_defs word_le_nat_alt word_of_nat_eq_iff flip: nat_div_eq_Suc_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take_bit LENGTH('a) (unat n div unat m) =\n     take_bit LENGTH('a) (Suc 0)) =\n    (unat n div unat m = Suc 0)", "apply (simp flip: unat_div unsigned_take_bit_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shiftl_power:\n  \"(shiftl1 ^^ x) (y::'a::len word) = 2 ^ x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shiftl1 ^^ x) y = 2 ^ x * y", "apply (induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (shiftl1 ^^ 0) y = 2 ^ 0 * y\n 2. \\<And>x.\n       (shiftl1 ^^ x) y = 2 ^ x * y \\<Longrightarrow>\n       (shiftl1 ^^ Suc x) y = 2 ^ Suc x * y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (shiftl1 ^^ x) y = 2 ^ x * y \\<Longrightarrow>\n       (shiftl1 ^^ Suc x) y = 2 ^ Suc x * y", "apply (simp add: shiftl1_2t)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AND_twice [simp]:\n  \"(w AND m) AND m = w AND m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND m) AND m = w AND m", "by (fact and.right_idem)"], ["", "lemma word_combine_masks:\n  \"w AND m = z \\<Longrightarrow> w AND m' = z' \\<Longrightarrow> w AND (m OR m') = (z OR z')\"\n  for w m m' z z' :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w AND m = z; w AND m' = z'\\<rbrakk>\n    \\<Longrightarrow> w AND (m OR m') = z OR z'", "by (simp add: bit.conj_disj_distrib)"], ["", "lemma p2_gt_0:\n  \"(0 < (2 ^ n :: 'a :: len word)) = (n < LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < 2 ^ n) = (n < LENGTH('a))", "by (simp add : word_gt_0 not_le)"], ["", "lemma uint_2p_alt:\n  \\<open>n < LENGTH('a::len) \\<Longrightarrow> uint ((2::'a::len word) ^ n) = 2 ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> uint (2 ^ n) = 2 ^ n", "using p2_gt_0 [of n, where ?'a = 'a]"], ["proof (prove)\nusing this:\n  (0 < 2 ^ n) = (n < LENGTH('a))\n\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> uint (2 ^ n) = 2 ^ n", "by (simp add: uint_2p)"], ["", "lemma p2_eq_0:\n  \\<open>(2::'a::len word) ^ n = 0 \\<longleftrightarrow> LENGTH('a::len) \\<le> n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ n = 0) = (LENGTH('a) \\<le> n)", "by (fact exp_eq_zero_iff)"], ["", "lemma p2len:\n  \\<open>(2 :: 'a word) ^ LENGTH('a::len) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('a) = 0", "by simp"], ["", "lemma neg_mask_is_div:\n  \"w AND NOT (mask n) = (w div 2^n) * 2^n\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND NOT (mask n) = w div 2 ^ n * 2 ^ n", "by (rule bit_word_eqI)\n    (auto simp add: bit_simps simp flip: push_bit_eq_mult drop_bit_eq_div)"], ["", "lemma neg_mask_is_div':\n  \"n < size w \\<Longrightarrow> w AND NOT (mask n) = ((w div (2 ^ n)) * (2 ^ n))\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < size w \\<Longrightarrow> w AND NOT (mask n) = w div 2 ^ n * 2 ^ n", "by (rule neg_mask_is_div)"], ["", "lemma and_mask_arith:\n  \"w AND mask n = (w * 2^(size w - n)) div 2^(size w - n)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND mask n = w * 2 ^ (size w - n) div 2 ^ (size w - n)", "by (rule bit_word_eqI)\n    (auto simp add: bit_simps word_size simp flip: push_bit_eq_mult drop_bit_eq_div)"], ["", "lemma and_mask_arith':\n  \"0 < n \\<Longrightarrow> w AND mask n = (w * 2^(size w - n)) div 2^(size w - n)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    w AND mask n = w * 2 ^ (size w - n) div 2 ^ (size w - n)", "by (rule and_mask_arith)"], ["", "lemma mask_2pm1: \"mask n = 2 ^ n - (1 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n = 2 ^ n - 1", "by (fact mask_eq_decr_exp)"], ["", "lemma add_mask_fold:\n  \"x + 2 ^ n - 1 = x + mask n\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 2 ^ n - 1 = x + mask n", "by (simp add: mask_eq_decr_exp)"], ["", "lemma word_and_mask_le_2pm1: \"w AND mask n \\<le> 2 ^ n - 1\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND mask n \\<le> 2 ^ n - 1", "by (simp add: mask_2pm1[symmetric] word_and_le1)"], ["", "lemma is_aligned_AND_less_0:\n  \"u AND mask n = 0 \\<Longrightarrow> v < 2^n \\<Longrightarrow> u AND v = 0\"\n  for u v :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u AND mask n = 0; v < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> u AND v = 0", "apply (drule less_mask_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u AND mask n = 0; v AND mask n = v\\<rbrakk>\n    \\<Longrightarrow> u AND v = 0", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take_bit n u = 0; take_bit n v = v\\<rbrakk>\n    \\<Longrightarrow> u AND v = 0", "apply (simp add: bit_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>na. \\<not> bit (take_bit n u) na;\n     \\<forall>na. bit (take_bit n v) na = bit v na\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> bit (u AND v) n", "apply (auto simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_shiftr1:\n  \\<open>shiftr1 u \\<le> shiftr1 v\\<close> if \\<open>u \\<le> v\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. shiftr1 u \\<le> shiftr1 v", "using that"], ["proof (prove)\nusing this:\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. shiftr1 u \\<le> shiftr1 v", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       take_bit LENGTH('a) u \\<le> take_bit LENGTH('a) v \\<Longrightarrow>\n       take_bit LENGTH('a) (take_bit LENGTH('a) u div 2)\n       \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) v div 2)", "fix k l :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       take_bit LENGTH('a) u \\<le> take_bit LENGTH('a) v \\<Longrightarrow>\n       take_bit LENGTH('a) (take_bit LENGTH('a) u div 2)\n       \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) v div 2)", "assume \\<open>take_bit LENGTH('a) k \\<le> take_bit LENGTH('a) l\\<close>"], ["proof (state)\nthis:\n  take_bit LENGTH('a) k \\<le> take_bit LENGTH('a) l\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       take_bit LENGTH('a) u \\<le> take_bit LENGTH('a) v \\<Longrightarrow>\n       take_bit LENGTH('a) (take_bit LENGTH('a) u div 2)\n       \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) v div 2)", "then"], ["proof (chain)\npicking this:\n  take_bit LENGTH('a) k \\<le> take_bit LENGTH('a) l", "have \\<open>take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) k))\n    \\<le> take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) l))\\<close>"], ["proof (prove)\nusing this:\n  take_bit LENGTH('a) k \\<le> take_bit LENGTH('a) l\n\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) k))\n    \\<le> take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) l))", "apply (simp add: take_bit_drop_bit min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) k \\<le> take_bit LENGTH('a) l \\<Longrightarrow>\n    drop_bit (Suc 0) (take_bit LENGTH('a) k)\n    \\<le> drop_bit (Suc 0) (take_bit LENGTH('a) l)", "apply (simp add: drop_bit_eq_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) k))\n  \\<le> take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) l))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       take_bit LENGTH('a) u \\<le> take_bit LENGTH('a) v \\<Longrightarrow>\n       take_bit LENGTH('a) (take_bit LENGTH('a) u div 2)\n       \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) v div 2)", "then"], ["proof (chain)\npicking this:\n  take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) k))\n  \\<le> take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) l))", "show \\<open>take_bit LENGTH('a) (take_bit LENGTH('a) k div 2)\n    \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) l div 2)\\<close>"], ["proof (prove)\nusing this:\n  take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) k))\n  \\<le> take_bit LENGTH('a) (drop_bit 1 (take_bit LENGTH('a) l))\n\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) (take_bit LENGTH('a) k div 2)\n    \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) l div 2)", "by (simp add: drop_bit_eq_div)"], ["proof (state)\nthis:\n  take_bit LENGTH('a) (take_bit LENGTH('a) k div 2)\n  \\<le> take_bit LENGTH('a) (take_bit LENGTH('a) l div 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma and_mask_eq_iff_le_mask:\n  \\<open>w AND mask n = w \\<longleftrightarrow> w \\<le> mask n\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND mask n = w) = (w \\<le> mask n)", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take_bit n w = w) = (w \\<le> mask n)", "apply (cases \\<open>n \\<ge> LENGTH('a)\\<close>; transfer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       LENGTH('a) \\<le> n \\<Longrightarrow>\n       (take_bit LENGTH('a) (take_bit (min LENGTH('a) n) w) =\n        take_bit LENGTH('a) w) =\n       (take_bit LENGTH('a) w \\<le> take_bit LENGTH('a) (mask n))\n 2. \\<And>n w.\n       \\<not> LENGTH('a) \\<le> n \\<Longrightarrow>\n       (take_bit LENGTH('a) (take_bit (min LENGTH('a) n) w) =\n        take_bit LENGTH('a) w) =\n       (take_bit LENGTH('a) w \\<le> take_bit LENGTH('a) (mask n))", "apply (simp_all add: not_le min_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       LENGTH('a) \\<le> n \\<Longrightarrow>\n       take_bit LENGTH('a) w \\<le> mask LENGTH('a)\n 2. \\<And>n w.\n       n < LENGTH('a) \\<Longrightarrow>\n       (take_bit n w = take_bit LENGTH('a) w) =\n       (take_bit LENGTH('a) w \\<le> mask n)", "apply (simp_all add: mask_eq_exp_minus_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w.\n       n < LENGTH('a) \\<Longrightarrow>\n       (take_bit n w = take_bit LENGTH('a) w) =\n       (take_bit LENGTH('a) w < 2 ^ n)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>n < LENGTH('a);\n        take_bit n w = take_bit LENGTH('a) w\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) w < 2 ^ n\n 2. \\<And>n w.\n       \\<lbrakk>n < LENGTH('a); take_bit LENGTH('a) w < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> take_bit n w = take_bit LENGTH('a) w", "apply (metis take_bit_int_less_exp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w.\n       \\<lbrakk>n < LENGTH('a); take_bit LENGTH('a) w < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> take_bit n w = take_bit LENGTH('a) w", "apply (metis min_def nat_less_le take_bit_int_eq_self_iff take_bit_take_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma less_eq_mask_iff_take_bit_eq_self:\n  \\<open>w \\<le> mask n \\<longleftrightarrow> take_bit n w = w\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<le> mask n) = (take_bit n w = w)", "by (simp add: and_mask_eq_iff_le_mask take_bit_eq_mask)"], ["", "lemma NOT_eq:\n  \"NOT (x :: 'a :: len word) = - x - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT x = - x - 1", "apply (cut_tac x = \"x\" in word_add_not)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + NOT x = - 1 \\<Longrightarrow> NOT x = - x - 1", "apply (drule add.commute [THEN trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT x + x = - 1 \\<Longrightarrow> NOT x = - x - 1", "apply (drule eq_diff_eq [THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT x = - 1 - x \\<Longrightarrow> NOT x = - x - 1", "by simp"], ["", "lemma NOT_mask: \"NOT (mask n :: 'a::len word) = - (2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (mask n) = - (2 ^ n)", "by (simp add : NOT_eq mask_2pm1)"], ["", "lemma le_m1_iff_lt: \"(x > (0 :: 'a :: len word)) = ((y \\<le> x - 1) = (y < x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x) = ((y \\<le> x - 1) = (y < x))", "by uint_arith"], ["", "lemma gt0_iff_gem1:\n  \\<open>0 < x \\<longleftrightarrow> x - 1 < x\\<close>\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x) = (x - 1 < x)", "by (metis add.right_neutral diff_add_cancel less_irrefl measure_unat unat_arith_simps(2) word_neq_0_conv word_sub_less_iff)"], ["", "lemma power_2_ge_iff:\n  \\<open>2 ^ n - (1 :: 'a::len word) < 2 ^ n \\<longleftrightarrow> n < LENGTH('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ n - 1 < 2 ^ n) = (n < LENGTH('a))", "using gt0_iff_gem1 p2_gt_0"], ["proof (prove)\nusing this:\n  (0 < ?x) = (?x - 1 < ?x)\n  (0 < 2 ^ ?n) = (?n < LENGTH(?'a))\n\ngoal (1 subgoal):\n 1. (2 ^ n - 1 < 2 ^ n) = (n < LENGTH('a))", "by blast"], ["", "lemma le_mask_iff_lt_2n:\n  \"n < len_of TYPE ('a) = (((w :: 'a :: len word) \\<le> mask n) = (w < 2 ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < LENGTH('a)) = ((w \\<le> mask n) = (w < 2 ^ n))", "unfolding mask_2pm1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < LENGTH('a)) = ((w \\<le> 2 ^ n - 1) = (w < 2 ^ n))", "by (rule trans [OF p2_gt_0 [THEN sym] le_m1_iff_lt])"], ["", "lemma mask_lt_2pn:\n  \\<open>n < LENGTH('a) \\<Longrightarrow> mask n < (2 :: 'a::len word) ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> mask n < 2 ^ n", "by (simp add: mask_eq_exp_minus_1 power_2_ge_iff)"], ["", "lemma word_unat_power:\n  \"(2 :: 'a :: len word) ^ n = of_nat (2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n = word_of_nat (2 ^ n)", "by simp"], ["", "lemma of_nat_mono_maybe:\n  assumes xlt: \"x < 2 ^ len_of TYPE ('a)\"\n  shows   \"y < x \\<Longrightarrow> of_nat y < (of_nat x :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow> word_of_nat y < word_of_nat x", "apply (subst word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow> unat (word_of_nat y) < unat (word_of_nat x)", "apply (subst unat_of_nat)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow> y mod 2 ^ LENGTH('a) < x mod 2 ^ LENGTH('a)", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y < x \\<Longrightarrow> y < 2 ^ LENGTH('a)\n 2. y < x \\<Longrightarrow> y < x mod 2 ^ LENGTH('a)", "apply (erule order_less_trans [OF _ xlt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow> y < x mod 2 ^ LENGTH('a)", "apply (subst mod_less [OF xlt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow> y < x", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_and_max_word:\n  fixes a::\"'a::len word\"\n  shows \"x = max_word \\<Longrightarrow> a AND x = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = - 1 \\<Longrightarrow> a AND x = a", "by simp"], ["", "lemma word_and_full_mask_simp:\n  \\<open>x AND mask LENGTH('a) = x\\<close> for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND mask LENGTH('a) = x", "proof (rule bit_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       2 ^ n \\<noteq> 0 \\<Longrightarrow>\n       bit (x AND mask LENGTH('a)) n = bit x n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       2 ^ n \\<noteq> 0 \\<Longrightarrow>\n       bit (x AND mask LENGTH('a)) n = bit x n", "assume \\<open>2 ^ n \\<noteq> (0 :: 'a word)\\<close>"], ["proof (state)\nthis:\n  2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       2 ^ n \\<noteq> 0 \\<Longrightarrow>\n       bit (x AND mask LENGTH('a)) n = bit x n", "then"], ["proof (chain)\npicking this:\n  2 ^ n \\<noteq> 0", "have \\<open>n < LENGTH('a)\\<close>"], ["proof (prove)\nusing this:\n  2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n < LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       2 ^ n \\<noteq> 0 \\<Longrightarrow>\n       bit (x AND mask LENGTH('a)) n = bit x n", "then"], ["proof (chain)\npicking this:\n  n < LENGTH('a)", "show \\<open>bit (x AND Bit_Operations.mask LENGTH('a)) n \\<longleftrightarrow> bit x n\\<close>"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. bit (x AND mask LENGTH('a)) n = bit x n", "by (simp add: bit_and_iff bit_mask_iff)"], ["proof (state)\nthis:\n  bit (x AND mask LENGTH('a)) n = bit x n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_int_uint:\n  \"of_int (uint x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (uint x) = x", "by (fact word_of_int_uint)"], ["", "corollary word_plus_and_or_coroll:\n  \"x AND y = 0 \\<Longrightarrow> x + y = x OR y\"\n  for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y = 0 \\<Longrightarrow> x + y = x OR y", "using word_plus_and_or[where x=x and y=y]"], ["proof (prove)\nusing this:\n  (x AND y) + (x OR y) = x + y\n\ngoal (1 subgoal):\n 1. x AND y = 0 \\<Longrightarrow> x + y = x OR y", "by simp"], ["", "corollary word_plus_and_or_coroll2:\n  \"(x AND w) + (x AND NOT w) = x\"\n  for x w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND w) + (x AND NOT w) = x", "apply (subst disjunctive_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. \\<not> bit (x AND w) n \\<or> \\<not> bit (x AND NOT w) n\n 2. x AND w OR x AND NOT w = x", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND w OR x AND NOT w = x", "apply (simp flip: bit.conj_disj_distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nat_mask_eq:\n  \\<open>nat (mask n) = mask n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (mask n) = mask n", "by (simp add: nat_eq_iff of_nat_mask_eq)"], ["", "lemma unat_mask_eq:\n  \\<open>unat (mask n :: 'a::len word) = mask (min LENGTH('a) n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (mask n) = mask (min LENGTH('a) n)", "by transfer (simp add: nat_mask_eq)"], ["", "lemma word_plus_mono_left:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>y \\<le> z; x \\<le> x + z\\<rbrakk> \\<Longrightarrow> y + x \\<le> z + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<le> z; x \\<le> x + z\\<rbrakk>\n    \\<Longrightarrow> y + x \\<le> z + x", "by unat_arith"], ["", "lemma less_Suc_unat_less_bound:\n  \"n < Suc (unat (x :: 'a :: len word)) \\<Longrightarrow> n < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < Suc (unat x) \\<Longrightarrow> n < 2 ^ LENGTH('a)", "by (auto elim!: order_less_le_trans intro: Suc_leI)"], ["", "lemma up_ucast_inj:\n  \"\\<lbrakk> ucast x = (ucast y::'b::len word); LENGTH('a) \\<le> len_of TYPE ('b) \\<rbrakk> \\<Longrightarrow> x = (y::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ucast x = ucast y; LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> x = y", "by transfer (simp add: min_def split: if_splits)"], ["", "lemmas ucast_up_inj = up_ucast_inj"], ["", "lemma up_ucast_inj_eq:\n  \"LENGTH('a) \\<le> len_of TYPE ('b) \\<Longrightarrow> (ucast x = (ucast y::'b::len word)) = (x = (y::'a::len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (ucast x = ucast y) = (x = y)", "by (fastforce dest: up_ucast_inj)"], ["", "lemma no_plus_overflow_neg:\n  \"(x :: 'a :: len word) < -y \\<Longrightarrow> x \\<le> x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < - y \\<Longrightarrow> x \\<le> x + y", "by (metis diff_minus_eq_add less_imp_le sub_wrap_lt)"], ["", "lemma ucast_ucast_eq:\n  \"\\<lbrakk> ucast x = (ucast (ucast y::'a word)::'c::len word); LENGTH('a) \\<le> LENGTH('b);\n     LENGTH('b) \\<le> LENGTH('c) \\<rbrakk> \\<Longrightarrow>\n   x = ucast y\" for x :: \"'a::len word\" and y :: \"'b::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ucast x = ucast (ucast y); LENGTH('a) \\<le> LENGTH('b);\n     LENGTH('b) \\<le> LENGTH('c)\\<rbrakk>\n    \\<Longrightarrow> x = ucast y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>take_bit LENGTH('c) (take_bit LENGTH('a) x) =\n                take_bit LENGTH('c)\n                 (take_bit LENGTH('a) (take_bit LENGTH('b) y));\n        LENGTH('a) \\<le> LENGTH('b); LENGTH('b) \\<le> LENGTH('c)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x =\n                         take_bit LENGTH('a) (take_bit LENGTH('b) y)", "apply (cases \\<open>LENGTH('c) = LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>take_bit LENGTH('c) (take_bit LENGTH('a) x) =\n                take_bit LENGTH('c)\n                 (take_bit LENGTH('a) (take_bit LENGTH('b) y));\n        LENGTH('a) \\<le> LENGTH('b); LENGTH('b) \\<le> LENGTH('c);\n        LENGTH('c) = LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x =\n                         take_bit LENGTH('a) (take_bit LENGTH('b) y)\n 2. \\<And>x y.\n       \\<lbrakk>take_bit LENGTH('c) (take_bit LENGTH('a) x) =\n                take_bit LENGTH('c)\n                 (take_bit LENGTH('a) (take_bit LENGTH('b) y));\n        LENGTH('a) \\<le> LENGTH('b); LENGTH('b) \\<le> LENGTH('c);\n        LENGTH('c) \\<noteq> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x =\n                         take_bit LENGTH('a) (take_bit LENGTH('b) y)", "apply (auto simp add: min_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_0_I:\n  \"x = 0 \\<Longrightarrow> ucast x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> ucast x = 0", "by simp"], ["", "lemma word_add_offset_less:\n  fixes x :: \"'a :: len word\"\n  assumes yv: \"y < 2 ^ n\"\n  and     xv: \"x < 2 ^ m\"\n  and     mnv: \"sz < LENGTH('a :: len)\"\n  and    xv': \"x < 2 ^ (LENGTH('a :: len) - n)\"\n  and     mn: \"sz = m + n\"\n  shows   \"x * 2 ^ n + y < 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 2 ^ n + y < 2 ^ sz", "proof (subst mn)"], ["proof (state)\ngoal (1 subgoal):\n 1. x * 2 ^ n + y < 2 ^ (m + n)", "from mnv mn"], ["proof (chain)\npicking this:\n  sz < LENGTH('a)\n  sz = m + n", "have nv: \"n < LENGTH('a)\" and mv: \"m < LENGTH('a)\""], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n  sz = m + n\n\ngoal (1 subgoal):\n 1. n < LENGTH('a) &&& m < LENGTH('a)", "by auto"], ["proof (state)\nthis:\n  n < LENGTH('a)\n  m < LENGTH('a)\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y < 2 ^ (m + n)", "have uy: \"unat y < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat y < 2 ^ n", "by (rule order_less_le_trans [OF unat_mono [OF yv] order_eq_refl],\n        rule unat_power_lower[OF nv])"], ["proof (state)\nthis:\n  unat y < 2 ^ n\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y < 2 ^ (m + n)", "have ux: \"unat x < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ m", "by (rule order_less_le_trans [OF unat_mono [OF xv] order_eq_refl],\n        rule unat_power_lower[OF mv])"], ["proof (state)\nthis:\n  unat x < 2 ^ m\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y < 2 ^ (m + n)", "then"], ["proof (chain)\npicking this:\n  unat x < 2 ^ m", "show \"x * 2 ^ n + y < 2 ^ (m + n)\""], ["proof (prove)\nusing this:\n  unat x < 2 ^ m\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y < 2 ^ (m + n)", "using ux uy nv mnv xv'"], ["proof (prove)\nusing this:\n  unat x < 2 ^ m\n  unat x < 2 ^ m\n  unat y < 2 ^ n\n  n < LENGTH('a)\n  sz < LENGTH('a)\n  x < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y < 2 ^ (m + n)", "apply (subst word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat (x * 2 ^ n + y) < unat (2 ^ (m + n))", "apply (subst unat_word_ariths)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * unat (2 ^ n) mod 2 ^ LENGTH('a) +\n                       unat y) mod\n                      2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * unat (2 ^ n) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * unat (2 ^ n) + unat y) mod 2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ n < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * unat (2 ^ n) + unat y) mod 2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply (subst mult.commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * unat x < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * unat (2 ^ n) + unat y) mod 2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply (rule nat_less_power_trans [OF _ order_less_imp_le [OF nv]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x < 2 ^ (LENGTH('a) - n)\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * unat (2 ^ n) + unat y) mod 2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply (rule order_less_le_trans [OF unat_mono [OF xv']])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ (LENGTH('a) - n)) \\<le> 2 ^ (LENGTH('a) - n)\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * unat (2 ^ n) + unat y) mod 2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply (cases \"n = 0\"; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * unat (2 ^ n) + unat y) mod 2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply (subst unat_power_lower[OF nv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> (unat x * 2 ^ n + unat y) mod 2 ^ LENGTH('a)\n                      < unat (2 ^ (m + n))", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ n + unat y < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ n + unat y < unat (2 ^ (m + n))", "apply (erule order_less_le_trans [OF nat_add_offset_less], assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> ?sz23 = m + n\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ ?sz23 \\<le> 2 ^ LENGTH('a)\n 3. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ n + unat y < unat (2 ^ (m + n))", "apply (rule mn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ sz \\<le> 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ n + unat y < unat (2 ^ (m + n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ m; unat x < 2 ^ m; unat y < 2 ^ n; n < LENGTH('a);\n     sz < LENGTH('a); x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ n + unat y < unat (2 ^ (m + n))", "apply (simp add: mn mnv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ m; unat y < 2 ^ n; m + n < LENGTH('a);\n     x < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat x * 2 ^ n + unat y < 2 ^ (m + n)", "apply (erule nat_add_offset_less; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x * 2 ^ n + y < 2 ^ (m + n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_less_power_trans:\n  fixes n :: \"'a :: len word\"\n  assumes nv: \"n < 2 ^ (m - k)\"\n  and     kv: \"k \\<le> m\"\n  and     mv: \"m < len_of TYPE ('a)\"\n  shows \"2 ^ k * n < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ k * n < 2 ^ m", "using nv kv mv"], ["proof (prove)\nusing this:\n  n < 2 ^ (m - k)\n  k \\<le> m\n  m < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ k * n < 2 ^ m", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ k * n < 2 ^ m", "apply (subst word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k * n) < unat (2 ^ m)", "apply (subst unat_word_ariths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n mod 2 ^ LENGTH('a)\n                      < unat (2 ^ m)", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n < 2 ^ LENGTH('a)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n < unat (2 ^ m)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ k * unat n < 2 ^ LENGTH('a)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n < unat (2 ^ m)", "apply (rule nat_less_power_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat n < 2 ^ (LENGTH('a) - k)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> LENGTH('a)\n 3. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n < unat (2 ^ m)", "apply (erule order_less_trans [OF unat_mono])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ (m - k)) < 2 ^ (LENGTH('a) - k)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> LENGTH('a)\n 3. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n < unat (2 ^ m)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> LENGTH('a)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n < unat (2 ^ m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ k) * unat n < unat (2 ^ m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ k * unat n < 2 ^ m", "apply (rule nat_less_power_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat n < 2 ^ (m - k)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> m", "apply (subst unat_power_lower[where 'a = 'a, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m - k < LENGTH('a)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat n < unat (2 ^ (m - k))\n 3. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> m", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat n < unat (2 ^ (m - k))\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> m", "apply (erule unat_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  word_less_power_trans2:\n  fixes n :: \"'a::len word\"\n  shows \"\\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk> \\<Longrightarrow> n * 2 ^ k < 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n * 2 ^ k < 2 ^ m", "by (subst field_simps, rule word_less_power_trans)"], ["", "lemma Suc_unat_diff_1:\n  fixes x :: \"'a :: len word\"\n  assumes lt: \"1 \\<le> x\"\n  shows \"Suc (unat (x - 1)) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (unat (x - 1)) = unat x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (unat (x - 1)) = unat x", "have \"0 < unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < unat x", "by (rule order_less_le_trans [where y = 1], simp, subst unat_1 [symmetric],\n        rule iffD1 [OF word_le_nat_alt lt])"], ["proof (state)\nthis:\n  0 < unat x\n\ngoal (1 subgoal):\n 1. Suc (unat (x - 1)) = unat x", "then"], ["proof (chain)\npicking this:\n  0 < unat x", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < unat x\n\ngoal (1 subgoal):\n 1. Suc (unat (x - 1)) = unat x", "by ((subst unat_sub [OF lt])+, simp only:  unat_1)"], ["proof (state)\nthis:\n  Suc (unat (x - 1)) = unat x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_eq_unatI:\n  \\<open>v = w\\<close> if \\<open>unat v = unat w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "using that"], ["proof (prove)\nusing this:\n  unat v = unat w\n\ngoal (1 subgoal):\n 1. v = w", "by transfer (simp add: nat_eq_iff)"], ["", "lemma word_div_sub:\n  fixes x :: \"'a :: len word\"\n  assumes yx: \"y \\<le> x\"\n  and     y0: \"0 < y\"\n  shows \"(x - y) div y = x div y - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - y) div y = x div y - 1", "apply (rule word_eq_unatI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ((x - y) div y) = unat (x div y - 1)", "apply (subst unat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (x - y) div unat y = unat (x div y - 1)", "apply (subst unat_sub [OF yx])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat x - unat y) div unat y = unat (x div y - 1)", "apply (subst unat_sub)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 \\<le> x div y\n 2. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply (subst word_le_nat_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. unat 1 \\<le> unat (x div y)\n 2. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply (subst unat_div)"], ["proof (prove)\ngoal (2 subgoals):\n 1. unat 1 \\<le> unat x div unat y\n 2. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply (subst le_div_geq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < unat y\n 2. unat y \\<le> unat x\n 3. unat 1 \\<le> Suc ((unat x - unat y) div unat y)\n 4. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply (rule order_le_less_trans [OF _ unat_mono [OF y0]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> unat 0\n 2. unat y \\<le> unat x\n 3. unat 1 \\<le> Suc ((unat x - unat y) div unat y)\n 4. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. unat y \\<le> unat x\n 2. unat 1 \\<le> Suc ((unat x - unat y) div unat y)\n 3. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply (subst word_le_nat_alt [symmetric], rule yx)"], ["proof (prove)\ngoal (2 subgoals):\n 1. unat 1 \\<le> Suc ((unat x - unat y) div unat y)\n 2. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat x - unat y) div unat y = unat (x div y) - unat 1", "apply (subst unat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat x - unat y) div unat y = unat x div unat y - unat 1", "apply (subst le_div_geq [OF _ iffD1 [OF word_le_nat_alt yx]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < unat y\n 2. (unat x - unat y) div unat y =\n    Suc ((unat x - unat y) div unat y) - unat 1", "apply (rule order_le_less_trans [OF _ unat_mono [OF y0]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> unat 0\n 2. (unat x - unat y) div unat y =\n    Suc ((unat x - unat y) div unat y) - unat 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat x - unat y) div unat y =\n    Suc ((unat x - unat y) div unat y) - unat 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_mult_less_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i < j\"\n  and    knz: \"0 < k\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i * k < j * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i * k < j * k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i * k < j * k", "from ij ujk knz"], ["proof (chain)\npicking this:\n  i < j\n  unat j * unat k < 2 ^ LENGTH('a)\n  0 < k", "have jk: \"unat i * unat k < 2 ^ len_of TYPE ('a)\""], ["proof (prove)\nusing this:\n  i < j\n  unat j * unat k < 2 ^ LENGTH('a)\n  0 < k\n\ngoal (1 subgoal):\n 1. unat i * unat k < 2 ^ LENGTH('a)", "by (auto intro: order_less_subst2 simp: word_less_nat_alt elim: mult_less_mono1)"], ["proof (state)\nthis:\n  unat i * unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i * k < j * k", "then"], ["proof (chain)\npicking this:\n  unat i * unat k < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  unat i * unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i * k < j * k", "using ujk knz ij"], ["proof (prove)\nusing this:\n  unat i * unat k < 2 ^ LENGTH('a)\n  unat j * unat k < 2 ^ LENGTH('a)\n  0 < k\n  i < j\n\ngoal (1 subgoal):\n 1. i * k < j * k", "by (auto simp: word_less_nat_alt iffD1 [OF unat_mult_lem])"], ["proof (state)\nthis:\n  i * k < j * k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_mult_less_dest:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i * k < j * k\"\n  and    uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "using uik ujk ij"], ["proof (prove)\nusing this:\n  unat i * unat k < 2 ^ LENGTH('a)\n  unat j * unat k < 2 ^ LENGTH('a)\n  i * k < j * k\n\ngoal (1 subgoal):\n 1. i < j", "by (auto simp: word_less_nat_alt iffD1 [OF unat_mult_lem] elim: mult_less_mono1)"], ["", "lemma word_mult_less_cancel:\n  fixes k :: \"'a :: len word\"\n  assumes knz: \"0 < k\"\n  and    uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows \"(i * k < j * k) = (i < j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i * k < j * k) = (i < j)", "by (rule iffI [OF word_mult_less_dest [OF _ uik ujk] word_mult_less_mono1 [OF _ knz ujk]])"], ["", "lemma Suc_div_unat_helper:\n  assumes szv: \"sz < LENGTH('a :: len)\"\n  and   usszv: \"us \\<le> sz\"\n  shows \"2 ^ (sz - us) = Suc (unat (((2::'a :: len word) ^ sz - 1) div 2 ^ us))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "note usv = order_le_less_trans [OF usszv szv]"], ["proof (state)\nthis:\n  us < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "from usszv"], ["proof (chain)\npicking this:\n  us \\<le> sz", "obtain q where qv: \"sz = us + q\""], ["proof (prove)\nusing this:\n  us \\<le> sz\n\ngoal (1 subgoal):\n 1. (\\<And>q. sz = us + q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: le_iff_add)"], ["proof (state)\nthis:\n  sz = us + q\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "have \"Suc (unat (((2:: 'a word) ^ sz - 1) div 2 ^ us)) =\n    (2 ^ us + unat ((2:: 'a word) ^ sz - 1)) div 2 ^ us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (unat ((2 ^ sz - 1) div 2 ^ us)) =\n    (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us", "apply (subst unat_div unat_power_lower[OF usv])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (unat (2 ^ sz - 1) div 2 ^ us) =\n    (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us", "apply (subst div_add_self1, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Suc (unat ((2 ^ sz - 1) div 2 ^ us)) =\n  (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "also"], ["proof (state)\nthis:\n  Suc (unat ((2 ^ sz - 1) div 2 ^ us)) =\n  (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "have \"\\<dots> = ((2 ^ us - 1) + 2 ^ sz) div 2 ^ us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us =\n    (2 ^ us - 1 + 2 ^ sz) div 2 ^ us", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us =\n    (2 ^ us - 1 + 2 ^ sz) div 2 ^ us", "by (simp add: unat_minus_one)"], ["proof (state)\nthis:\n  (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us = (2 ^ us - 1 + 2 ^ sz) div 2 ^ us\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "also"], ["proof (state)\nthis:\n  (2 ^ us + unat (2 ^ sz - 1)) div 2 ^ us = (2 ^ us - 1 + 2 ^ sz) div 2 ^ us\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "have \"\\<dots> = 2 ^ q + ((2 ^ us - 1) div 2 ^ us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ us - 1 + 2 ^ sz) div 2 ^ us = 2 ^ q + (2 ^ us - 1) div 2 ^ us", "apply (subst qv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ us - 1 + 2 ^ (us + q)) div 2 ^ us = 2 ^ q + (2 ^ us - 1) div 2 ^ us", "apply (subst power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ us - 1 + 2 ^ us * 2 ^ q) div 2 ^ us =\n    2 ^ q + (2 ^ us - 1) div 2 ^ us", "apply (subst div_mult_self2; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (2 ^ us - 1 + 2 ^ sz) div 2 ^ us = 2 ^ q + (2 ^ us - 1) div 2 ^ us\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "also"], ["proof (state)\nthis:\n  (2 ^ us - 1 + 2 ^ sz) div 2 ^ us = 2 ^ q + (2 ^ us - 1) div 2 ^ us\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "have \"\\<dots> = 2 ^ (sz - us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ q + (2 ^ us - 1) div 2 ^ us = 2 ^ (sz - us)", "using qv"], ["proof (prove)\nusing this:\n  sz = us + q\n\ngoal (1 subgoal):\n 1. 2 ^ q + (2 ^ us - 1) div 2 ^ us = 2 ^ (sz - us)", "by simp"], ["proof (state)\nthis:\n  2 ^ q + (2 ^ us - 1) div 2 ^ us = 2 ^ (sz - us)\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", "finally"], ["proof (chain)\npicking this:\n  Suc (unat ((2 ^ sz - 1) div 2 ^ us)) = 2 ^ (sz - us)", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc (unat ((2 ^ sz - 1) div 2 ^ us)) = 2 ^ (sz - us)\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))", ".."], ["proof (state)\nthis:\n  2 ^ (sz - us) = Suc (unat ((2 ^ sz - 1) div 2 ^ us))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enum_word_nth_eq:\n  \\<open>(Enum.enum :: 'a::len word list) ! n = word_of_nat n\\<close>\n    if \\<open>n < 2 ^ LENGTH('a)\\<close>\n    for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum ! n = word_of_nat n", "using that"], ["proof (prove)\nusing this:\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. enum_class.enum ! n = word_of_nat n", "by (simp add: enum_word_def)"], ["", "lemma length_enum_word_eq:\n  \\<open>length (Enum.enum :: 'a::len word list) = 2 ^ LENGTH('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length enum_class.enum = 2 ^ LENGTH('a)", "by (simp add: enum_word_def)"], ["", "lemma unat_lt2p [iff]:\n  \\<open>unat x < 2 ^ LENGTH('a)\\<close> for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ LENGTH('a)", "by transfer simp"], ["", "lemma of_nat_unat [simp]:\n  \"of_nat \\<circ> unat = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat \\<circ> unat = id", "by (rule ext, simp)"], ["", "lemma Suc_unat_minus_one [simp]:\n  \"x \\<noteq> 0 \\<Longrightarrow> Suc (unat (x - 1)) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> Suc (unat (x - 1)) = unat x", "by (metis Suc_diff_1 unat_gt_0 unat_minus_one)"], ["", "lemma word_add_le_dest:\n  fixes i :: \"'a :: len word\"\n  assumes le: \"i + k \\<le> j + k\"\n  and    uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j", "using uik ujk le"], ["proof (prove)\nusing this:\n  unat i + unat k < 2 ^ LENGTH('a)\n  unat j + unat k < 2 ^ LENGTH('a)\n  i + k \\<le> j + k\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by (auto simp: word_le_nat_alt iffD1 [OF unat_add_lem] elim: add_le_mono1)"], ["", "lemma word_add_le_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i \\<le> j\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i + k \\<le> j + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + k \\<le> j + k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i + k \\<le> j + k", "from ij ujk"], ["proof (chain)\npicking this:\n  i \\<le> j\n  unat j + unat k < 2 ^ LENGTH('a)", "have jk: \"unat i + unat k < 2 ^ len_of TYPE ('a)\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  unat j + unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat i + unat k < 2 ^ LENGTH('a)", "by (auto elim: order_le_less_subst2 simp: word_le_nat_alt elim: add_le_mono1)"], ["proof (state)\nthis:\n  unat i + unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i + k \\<le> j + k", "then"], ["proof (chain)\npicking this:\n  unat i + unat k < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  unat i + unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i + k \\<le> j + k", "using ujk ij"], ["proof (prove)\nusing this:\n  unat i + unat k < 2 ^ LENGTH('a)\n  unat j + unat k < 2 ^ LENGTH('a)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i + k \\<le> j + k", "by (auto simp: word_le_nat_alt iffD1 [OF unat_add_lem])"], ["proof (state)\nthis:\n  i + k \\<le> j + k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_add_le_mono2:\n  fixes i :: \"'a :: len word\"\n  shows \"\\<lbrakk>i \\<le> j; unat j + unat k < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow> k + i \\<le> k + j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; unat j + unat k < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k + i \\<le> k + j", "by (subst field_simps, subst field_simps, erule (1) word_add_le_mono1)"], ["", "lemma word_add_le_iff:\n  fixes i :: \"'a :: len word\"\n  assumes uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i + k \\<le> j + k) = (i \\<le> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i + k \\<le> j + k) = (i \\<le> j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i + k \\<le> j + k \\<Longrightarrow> i \\<le> j\n 2. i \\<le> j \\<Longrightarrow> i + k \\<le> j + k", "assume \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. i + k \\<le> j + k \\<Longrightarrow> i \\<le> j\n 2. i \\<le> j \\<Longrightarrow> i + k \\<le> j + k", "show \"i + k \\<le> j + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + k \\<le> j + k", "by (rule word_add_le_mono1) fact+"], ["proof (state)\nthis:\n  i + k \\<le> j + k\n\ngoal (1 subgoal):\n 1. i + k \\<le> j + k \\<Longrightarrow> i \\<le> j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i + k \\<le> j + k \\<Longrightarrow> i \\<le> j", "assume \"i + k \\<le> j + k\""], ["proof (state)\nthis:\n  i + k \\<le> j + k\n\ngoal (1 subgoal):\n 1. i + k \\<le> j + k \\<Longrightarrow> i \\<le> j", "show \"i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j", "by (rule word_add_le_dest) fact+"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_add_less_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i < j\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i + k < j + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + k < j + k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i + k < j + k", "from ij ujk"], ["proof (chain)\npicking this:\n  i < j\n  unat j + unat k < 2 ^ LENGTH('a)", "have jk: \"unat i + unat k < 2 ^ len_of TYPE ('a)\""], ["proof (prove)\nusing this:\n  i < j\n  unat j + unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat i + unat k < 2 ^ LENGTH('a)", "by (auto elim: order_le_less_subst2 simp: word_less_nat_alt elim: add_less_mono1)"], ["proof (state)\nthis:\n  unat i + unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i + k < j + k", "then"], ["proof (chain)\npicking this:\n  unat i + unat k < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  unat i + unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i + k < j + k", "using ujk ij"], ["proof (prove)\nusing this:\n  unat i + unat k < 2 ^ LENGTH('a)\n  unat j + unat k < 2 ^ LENGTH('a)\n  i < j\n\ngoal (1 subgoal):\n 1. i + k < j + k", "by (auto simp: word_less_nat_alt iffD1 [OF unat_add_lem])"], ["proof (state)\nthis:\n  i + k < j + k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_add_less_dest:\n  fixes i :: \"'a :: len word\"\n  assumes le: \"i + k < j + k\"\n  and    uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and    ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "using uik ujk le"], ["proof (prove)\nusing this:\n  unat i + unat k < 2 ^ LENGTH('a)\n  unat j + unat k < 2 ^ LENGTH('a)\n  i + k < j + k\n\ngoal (1 subgoal):\n 1. i < j", "by (auto simp: word_less_nat_alt iffD1 [OF unat_add_lem] elim: add_less_mono1)"], ["", "lemma word_add_less_iff:\n  fixes i :: \"'a :: len word\"\n  assumes uik: \"unat i + unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j + unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i + k < j + k) = (i < j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i + k < j + k) = (i < j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i + k < j + k \\<Longrightarrow> i < j\n 2. i < j \\<Longrightarrow> i + k < j + k", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i + k < j + k \\<Longrightarrow> i < j\n 2. i < j \\<Longrightarrow> i + k < j + k", "show \"i + k < j + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + k < j + k", "by (rule word_add_less_mono1) fact+"], ["proof (state)\nthis:\n  i + k < j + k\n\ngoal (1 subgoal):\n 1. i + k < j + k \\<Longrightarrow> i < j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i + k < j + k \\<Longrightarrow> i < j", "assume \"i + k < j + k\""], ["proof (state)\nthis:\n  i + k < j + k\n\ngoal (1 subgoal):\n 1. i + k < j + k \\<Longrightarrow> i < j", "show \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "by (rule word_add_less_dest) fact+"], ["proof (state)\nthis:\n  i < j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_mult_less_iff:\n  fixes i :: \"'a :: len word\"\n  assumes knz: \"0 < k\"\n  and     uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i * k < j * k) = (i < j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i * k < j * k) = (i < j)", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  unat i * unat k < 2 ^ LENGTH('a)\n  unat j * unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (i * k < j * k) = (i < j)", "by (rule word_mult_less_cancel)"], ["", "lemma word_le_imp_diff_le:\n  fixes n :: \"'a::len word\"\n  shows \"\\<lbrakk>k \\<le> n; n \\<le> m\\<rbrakk> \\<Longrightarrow> n - k \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> n; n \\<le> m\\<rbrakk> \\<Longrightarrow> n - k \\<le> m", "by (auto simp: unat_sub word_le_nat_alt)"], ["", "lemma word_less_imp_diff_less:\n  fixes n :: \"'a::len word\"\n  shows \"\\<lbrakk>k \\<le> n; n < m\\<rbrakk> \\<Longrightarrow> n - k < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> n; n < m\\<rbrakk> \\<Longrightarrow> n - k < m", "by (clarsimp simp: unat_sub word_less_nat_alt\n             intro!: less_imp_diff_less)"], ["", "lemma word_mult_le_mono1:\n  fixes i :: \"'a :: len word\"\n  assumes ij: \"i \\<le> j\"\n  and    knz: \"0 < k\"\n  and    ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"i * k \\<le> j * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i * k \\<le> j * k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i * k \\<le> j * k", "from ij ujk knz"], ["proof (chain)\npicking this:\n  i \\<le> j\n  unat j * unat k < 2 ^ LENGTH('a)\n  0 < k", "have jk: \"unat i * unat k < 2 ^ len_of TYPE ('a)\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  unat j * unat k < 2 ^ LENGTH('a)\n  0 < k\n\ngoal (1 subgoal):\n 1. unat i * unat k < 2 ^ LENGTH('a)", "by (auto elim: order_le_less_subst2 simp: word_le_nat_alt elim: mult_le_mono1)"], ["proof (state)\nthis:\n  unat i * unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i * k \\<le> j * k", "then"], ["proof (chain)\npicking this:\n  unat i * unat k < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  unat i * unat k < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. i * k \\<le> j * k", "using ujk knz ij"], ["proof (prove)\nusing this:\n  unat i * unat k < 2 ^ LENGTH('a)\n  unat j * unat k < 2 ^ LENGTH('a)\n  0 < k\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i * k \\<le> j * k", "by (auto simp: word_le_nat_alt iffD1 [OF unat_mult_lem])"], ["proof (state)\nthis:\n  i * k \\<le> j * k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_mult_le_iff:\n  fixes i :: \"'a :: len word\"\n  assumes knz: \"0 < k\"\n  and     uik: \"unat i * unat k < 2 ^ len_of TYPE ('a)\"\n  and     ujk: \"unat j * unat k < 2 ^ len_of TYPE ('a)\"\n  shows  \"(i * k \\<le> j * k) = (i \\<le> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i * k \\<le> j * k) = (i \\<le> j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i * k \\<le> j * k \\<Longrightarrow> i \\<le> j\n 2. i \\<le> j \\<Longrightarrow> i * k \\<le> j * k", "assume \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. i * k \\<le> j * k \\<Longrightarrow> i \\<le> j\n 2. i \\<le> j \\<Longrightarrow> i * k \\<le> j * k", "show \"i * k \\<le> j * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i * k \\<le> j * k", "by (rule word_mult_le_mono1) fact+"], ["proof (state)\nthis:\n  i * k \\<le> j * k\n\ngoal (1 subgoal):\n 1. i * k \\<le> j * k \\<Longrightarrow> i \\<le> j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i * k \\<le> j * k \\<Longrightarrow> i \\<le> j", "assume p: \"i * k \\<le> j * k\""], ["proof (state)\nthis:\n  i * k \\<le> j * k\n\ngoal (1 subgoal):\n 1. i * k \\<le> j * k \\<Longrightarrow> i \\<le> j", "have \"0 < unat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < unat k", "using knz"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. 0 < unat k", "by (simp add: word_less_nat_alt)"], ["proof (state)\nthis:\n  0 < unat k\n\ngoal (1 subgoal):\n 1. i * k \\<le> j * k \\<Longrightarrow> i \\<le> j", "then"], ["proof (chain)\npicking this:\n  0 < unat k", "show \"i \\<le> j\""], ["proof (prove)\nusing this:\n  0 < unat k\n\ngoal (1 subgoal):\n 1. i \\<le> j", "using p"], ["proof (prove)\nusing this:\n  0 < unat k\n  i * k \\<le> j * k\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by (clarsimp simp: word_le_nat_alt iffD1 [OF unat_mult_lem uik]\n      iffD1 [OF unat_mult_lem ujk])"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_diff_less:\n  fixes n :: \"'a :: len word\"\n  shows \"\\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk> \\<Longrightarrow> m - n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk> \\<Longrightarrow> m - n < m", "apply (subst word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> unat (m - n) < unat m", "apply (subst unat_sub)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk> \\<Longrightarrow> n \\<le> m\n 2. \\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> unat m - unat n < unat m", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> unat m - unat n < unat m", "apply (rule diff_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk> \\<Longrightarrow> 0 < unat n\n 2. \\<lbrakk>0 < n; 0 < m; n \\<le> m\\<rbrakk> \\<Longrightarrow> 0 < unat m", "apply (simp_all add: word_less_nat_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_add_increasing:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> p + w \\<le> x; p \\<le> p + w \\<rbrakk> \\<Longrightarrow> p \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p + w \\<le> x; p \\<le> p + w\\<rbrakk>\n    \\<Longrightarrow> p \\<le> x", "by unat_arith"], ["", "lemma word_random:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> p \\<le> p + x'; x \\<le> x' \\<rbrakk> \\<Longrightarrow> p \\<le> p + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> p + x'; x \\<le> x'\\<rbrakk>\n    \\<Longrightarrow> p \\<le> p + x", "by unat_arith"], ["", "lemma word_sub_mono:\n  \"\\<lbrakk> a \\<le> c; d \\<le> b; a - b \\<le> a; c - d \\<le> c \\<rbrakk>\n    \\<Longrightarrow> (a - b) \\<le> (c - d :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> c; d \\<le> b; a - b \\<le> a; c - d \\<le> c\\<rbrakk>\n    \\<Longrightarrow> a - b \\<le> c - d", "by unat_arith"], ["", "lemma power_not_zero:\n  \"n < LENGTH('a::len) \\<Longrightarrow> (2 :: 'a word) ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> 2 ^ n \\<noteq> 0", "by (metis p2_gt_0 word_neq_0_conv)"], ["", "lemma word_gt_a_gt_0:\n  \"a < n \\<Longrightarrow> (0 :: 'a::len word) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < n \\<Longrightarrow> 0 < n", "apply (case_tac \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a < n; n = 0\\<rbrakk> \\<Longrightarrow> 0 < n\n 2. \\<lbrakk>a < n; n \\<noteq> 0\\<rbrakk> \\<Longrightarrow> 0 < n", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < n; n \\<noteq> 0\\<rbrakk> \\<Longrightarrow> 0 < n", "apply (clarsimp simp: word_neq_0_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_power_less_1 [simp]:\n  \"sz < LENGTH('a::len) \\<Longrightarrow> (2::'a word) ^ sz - 1 < 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> 2 ^ sz - 1 < 2 ^ sz", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> unat (2 ^ sz - 1) < 2 ^ sz", "apply (subst unat_minus_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> 2 ^ sz \\<noteq> 0\n 2. sz < LENGTH('a) \\<Longrightarrow> unat (2 ^ sz) - 1 < 2 ^ sz", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sub_1_le:\n  \"x \\<noteq> 0 \\<Longrightarrow> x - 1 \\<le> (x :: ('a :: len) word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> x - 1 \\<le> x", "apply (subst no_ulen_sub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> uint 1 \\<le> uint x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 1 \\<le> uint x", "apply (cases \"uint x = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> 0; uint x = 0\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> uint x\n 2. \\<lbrakk>x \\<noteq> 0; uint x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> uint x", "apply (simp add: uint_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; uint x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> uint x", "apply (insert uint_ge_0[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; uint x \\<noteq> 0; 0 \\<le> uint x\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> uint x", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma push_bit_word_eq_nonzero:\n  \\<open>push_bit n w \\<noteq> 0\\<close> if \\<open>w < 2 ^ m\\<close> \\<open>m + n < LENGTH('a)\\<close> \\<open>w \\<noteq> 0\\<close>\n    for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n w \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  w < 2 ^ m\n  m + n < LENGTH('a)\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. push_bit n w \\<noteq> 0", "apply (simp only: word_neq_0_conv word_less_nat_alt\n                    mod_0 unat_word_ariths\n                    unat_power_lower word_le_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat w < 2 ^ m; m + n < LENGTH('a); 0 < unat w\\<rbrakk>\n    \\<Longrightarrow> 0 < unat (push_bit n w)", "apply (metis add_diff_cancel_right' gr0I gr_implies_not0 less_or_eq_imp_le min_def push_bit_eq_0_iff take_bit_nat_eq_self_iff take_bit_push_bit take_bit_take_bit unsigned_push_bit_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_less_power:\n  fixes k :: \"'a::len word\"\n  assumes szv: \"sz < LENGTH('a)\"\n  and     kv:  \"k < 2 ^ sz\"\n  shows   \"unat k < 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat k < 2 ^ sz", "using szv unat_mono [OF kv]"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n  unat k < unat (2 ^ sz)\n\ngoal (1 subgoal):\n 1. unat k < 2 ^ sz", "by simp"], ["", "lemma unat_mult_power_lem:\n  assumes kv: \"k < 2 ^ (LENGTH('a::len) - sz)\"\n  shows \"unat (2 ^ sz * of_nat k :: (('a::len) word)) = 2 ^ sz * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "proof (cases \\<open>sz < LENGTH('a)\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k\n 2. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "case True"], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k\n 2. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "with assms"], ["proof (chain)\npicking this:\n  k < 2 ^ (LENGTH('a) - sz)\n  sz < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  k < 2 ^ (LENGTH('a) - sz)\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "by (simp add: unat_word_ariths take_bit_eq_mod mod_simps)\n      (simp add: take_bit_nat_eq_self_iff nat_less_power_trans flip: take_bit_eq_mod)"], ["proof (state)\nthis:\n  unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "case False"], ["proof (state)\nthis:\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "with assms"], ["proof (chain)\npicking this:\n  k < 2 ^ (LENGTH('a) - sz)\n  \\<not> sz < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  k < 2 ^ (LENGTH('a) - sz)\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k", "by simp"], ["proof (state)\nthis:\n  unat (2 ^ sz * word_of_nat k) = 2 ^ sz * k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_plus_mcs_4:\n  \"\\<lbrakk>v + x \\<le> w + x; x \\<le> v + x\\<rbrakk> \\<Longrightarrow> v \\<le> (w::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v + x \\<le> w + x; x \\<le> v + x\\<rbrakk>\n    \\<Longrightarrow> v \\<le> w", "by uint_arith"], ["", "lemma word_plus_mcs_3:\n  \"\\<lbrakk>v \\<le> w; x \\<le> w + x\\<rbrakk> \\<Longrightarrow> v + x \\<le> w + (x::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<le> w; x \\<le> w + x\\<rbrakk>\n    \\<Longrightarrow> v + x \\<le> w + x", "by unat_arith"], ["", "lemma word_le_minus_one_leq:\n  \"x < y \\<Longrightarrow> x \\<le> y - 1\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> x \\<le> y - 1", "by transfer (metis le_less_trans less_irrefl take_bit_decr_eq take_bit_nonnegative zle_diff1_eq)"], ["", "lemma word_less_sub_le[simp]:\n  fixes x :: \"'a :: len word\"\n  assumes nv: \"n < LENGTH('a)\"\n  shows \"(x \\<le> 2 ^ n - 1) = (x < 2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> 2 ^ n - 1) = (x < 2 ^ n)", "using le_less_trans word_le_minus_one_leq nv power_2_ge_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y - 1\n  n < LENGTH('a)\n  (2 ^ ?n - 1 < 2 ^ ?n) = (?n < LENGTH(?'a))\n\ngoal (1 subgoal):\n 1. (x \\<le> 2 ^ n - 1) = (x < 2 ^ n)", "by blast"], ["", "lemma unat_of_nat_len:\n  \"x < 2 ^ LENGTH('a) \\<Longrightarrow> unat (of_nat x :: 'a::len word) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ LENGTH('a) \\<Longrightarrow> unat (word_of_nat x) = x", "by (simp add: take_bit_nat_eq_self_iff)"], ["", "lemma unat_of_nat_eq:\n  \"x < 2 ^ LENGTH('a) \\<Longrightarrow> unat (of_nat x ::'a::len word) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ LENGTH('a) \\<Longrightarrow> unat (word_of_nat x) = x", "by (rule unat_of_nat_len)"], ["", "lemma unat_eq_of_nat:\n  \"n < 2 ^ LENGTH('a) \\<Longrightarrow> (unat (x :: 'a::len word) = n) = (x = of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 2 ^ LENGTH('a) \\<Longrightarrow> (unat x = n) = (x = word_of_nat n)", "by transfer\n    (auto simp add: take_bit_of_nat nat_eq_iff take_bit_nat_eq_self_iff intro: sym)"], ["", "lemma alignUp_div_helper:\n  fixes a :: \"'a::len word\"\n  assumes kv: \"k < 2 ^ (LENGTH('a) - n)\"\n  and     xk: \"x = 2 ^ n * of_nat k\"\n  and    le: \"a \\<le> x\"\n  and    sz: \"n < LENGTH('a)\"\n  and   anz: \"a mod 2 ^ n \\<noteq> 0\"\n  shows \"a div 2 ^ n < of_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "have kn: \"unat (of_nat k :: 'a word) * unat ((2::'a word) ^ n) < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (word_of_nat k) * unat (2 ^ n) < 2 ^ LENGTH('a)", "using xk kv sz"], ["proof (prove)\nusing this:\n  x = 2 ^ n * word_of_nat k\n  k < 2 ^ (LENGTH('a) - n)\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (word_of_nat k) * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply (subst unat_of_nat_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (LENGTH('a) - n) \\<le> 2 ^ LENGTH('a)\n 2. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply (subst unat_power_lower, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k * 2 ^ n < 2 ^ LENGTH('a)", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * k < 2 ^ LENGTH('a)", "apply (rule nat_less_power_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k < 2 ^ (LENGTH('a) - n)\n 2. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n \\<le> LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n \\<le> LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat (word_of_nat k) * unat (2 ^ n) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "have \"unat a div 2 ^ n * 2 ^ n \\<noteq> unat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n \\<noteq> unat a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n \\<noteq> unat a", "have \"unat a = unat a div 2 ^ n * 2 ^ n + unat a mod 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a = unat a div 2 ^ n * 2 ^ n + unat a mod 2 ^ n", "by (simp add: div_mult_mod_eq)"], ["proof (state)\nthis:\n  unat a = unat a div 2 ^ n * 2 ^ n + unat a mod 2 ^ n\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n \\<noteq> unat a", "also"], ["proof (state)\nthis:\n  unat a = unat a div 2 ^ n * 2 ^ n + unat a mod 2 ^ n\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n \\<noteq> unat a", "have \"\\<dots> \\<noteq> unat a div 2 ^ n * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n + unat a mod 2 ^ n \\<noteq>\n    unat a div 2 ^ n * 2 ^ n", "using sz anz"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n + unat a mod 2 ^ n \\<noteq>\n    unat a div 2 ^ n * 2 ^ n", "by (simp add: unat_arith_simps)"], ["proof (state)\nthis:\n  unat a div 2 ^ n * 2 ^ n + unat a mod 2 ^ n \\<noteq>\n  unat a div 2 ^ n * 2 ^ n\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n \\<noteq> unat a", "finally"], ["proof (chain)\npicking this:\n  unat a \\<noteq> unat a div 2 ^ n * 2 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  unat a \\<noteq> unat a div 2 ^ n * 2 ^ n\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n * 2 ^ n \\<noteq> unat a", ".."], ["proof (state)\nthis:\n  unat a div 2 ^ n * 2 ^ n \\<noteq> unat a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat a div 2 ^ n * 2 ^ n \\<noteq> unat a\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "then"], ["proof (chain)\npicking this:\n  unat a div 2 ^ n * 2 ^ n \\<noteq> unat a", "have \"a div 2 ^ n * 2 ^ n < a\""], ["proof (prove)\nusing this:\n  unat a div 2 ^ n * 2 ^ n \\<noteq> unat a\n\ngoal (1 subgoal):\n 1. a div 2 ^ n * 2 ^ n < a", "using sz anz"], ["proof (prove)\nusing this:\n  unat a div 2 ^ n * 2 ^ n \\<noteq> unat a\n  n < LENGTH('a)\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a div 2 ^ n * 2 ^ n < a", "apply (subst word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a div 2 ^ n * 2 ^ n \\<noteq> unat a; n < LENGTH('a);\n     a mod 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (a div 2 ^ n * 2 ^ n) < unat a", "apply (subst unat_word_ariths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a div 2 ^ n * 2 ^ n \\<noteq> unat a; n < LENGTH('a);\n     a mod 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (a div 2 ^ n) * unat (2 ^ n) mod 2 ^ LENGTH('a)\n                      < unat a", "apply (subst unat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a div 2 ^ n * 2 ^ n \\<noteq> unat a; n < LENGTH('a);\n     a mod 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat a div unat (2 ^ n) * unat (2 ^ n) mod\n                      2 ^ LENGTH('a)\n                      < unat a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a div 2 ^ n * 2 ^ n \\<noteq> unat a; n < LENGTH('a);\n     a mod 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat a div 2 ^ n * 2 ^ n mod 2 ^ LENGTH('a) < unat a", "apply (rule order_le_less_trans [OF mod_less_eq_dividend])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat a div 2 ^ n * 2 ^ n \\<noteq> unat a; n < LENGTH('a);\n     a mod 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat a div 2 ^ n * 2 ^ n < unat a", "apply (erule order_le_neq_trans [OF div_mult_le])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a div 2 ^ n * 2 ^ n < a\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "also"], ["proof (state)\nthis:\n  a div 2 ^ n * 2 ^ n < a\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "from xk le"], ["proof (chain)\npicking this:\n  x = 2 ^ n * word_of_nat k\n  a \\<le> x", "have \"\\<dots> \\<le> of_nat k * 2 ^ n\""], ["proof (prove)\nusing this:\n  x = 2 ^ n * word_of_nat k\n  a \\<le> x\n\ngoal (1 subgoal):\n 1. a \\<le> word_of_nat k * 2 ^ n", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  a \\<le> word_of_nat k * 2 ^ n\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "finally"], ["proof (chain)\npicking this:\n  a div 2 ^ n * 2 ^ n < word_of_nat k * 2 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  a div 2 ^ n * 2 ^ n < word_of_nat k * 2 ^ n\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "using sz kv"], ["proof (prove)\nusing this:\n  a div 2 ^ n * 2 ^ n < word_of_nat k * 2 ^ n\n  n < LENGTH('a)\n  k < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a div 2 ^ n * 2 ^ n < word_of_nat k * 2 ^ n; n < LENGTH('a);\n     k < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> a div 2 ^ n < word_of_nat k", "apply (erule word_mult_less_dest [OF _ _ kn])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); k < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat (a div 2 ^ n) * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply (simp add: unat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); k < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat a div 2 ^ n * 2 ^ n < 2 ^ LENGTH('a)", "apply (rule order_le_less_trans [OF div_mult_le])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); k < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> unat a < 2 ^ LENGTH('a)", "apply (rule unat_lt2p)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a div 2 ^ n < word_of_nat k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mask_out_sub_mask:\n  \"(x AND NOT (mask n)) = x - (x AND (mask n))\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND NOT (mask n) = x - (x AND mask n)", "by (simp add: field_simps word_plus_and_or_coroll2)"], ["", "lemma subtract_mask:\n  \"p - (p AND mask n) = (p AND NOT (mask n))\"\n  \"p - (p AND NOT (mask n)) = (p AND mask n)\"\n  for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - (p AND mask n) = p AND NOT (mask n) &&&\n    p - (p AND NOT (mask n)) = p AND mask n", "by (simp add: field_simps word_plus_and_or_coroll2)+"], ["", "lemma take_bit_word_eq_self_iff:\n  \\<open>take_bit n w = w \\<longleftrightarrow> n \\<ge> LENGTH('a) \\<or> w < 2 ^ n\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take_bit n w = w) = (LENGTH('a) \\<le> n \\<or> w < 2 ^ n)", "using take_bit_int_eq_self_iff [of n \\<open>take_bit LENGTH('a) (uint w)\\<close>]"], ["proof (prove)\nusing this:\n  (take_bit n (take_bit LENGTH('a) (uint w)) =\n   take_bit LENGTH('a) (uint w)) =\n  (0 \\<le> take_bit LENGTH('a) (uint w) \\<and>\n   take_bit LENGTH('a) (uint w) < 2 ^ n)\n\ngoal (1 subgoal):\n 1. (take_bit n w = w) = (LENGTH('a) \\<le> n \\<or> w < 2 ^ n)", "by (transfer fixing: n) auto"], ["", "lemma word_power_increasing:\n  assumes x: \"2 ^ x < (2 ^ y::'a::len word)\" \"x < LENGTH('a::len)\" \"y < LENGTH('a::len)\"\n  shows \"x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "using x"], ["proof (prove)\nusing this:\n  2 ^ x < 2 ^ y\n  x < LENGTH('a)\n  y < LENGTH('a)\n\ngoal (1 subgoal):\n 1. x < y", "using assms"], ["proof (prove)\nusing this:\n  2 ^ x < 2 ^ y\n  x < LENGTH('a)\n  y < LENGTH('a)\n  2 ^ x < 2 ^ y\n  x < LENGTH('a)\n  y < LENGTH('a)\n\ngoal (1 subgoal):\n 1. x < y", "by transfer simp"], ["", "lemma mask_twice:\n  \"(x AND mask n) AND mask m = x AND mask (min m n)\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND mask n) AND mask m = x AND mask (min m n)", "by (simp flip: take_bit_eq_mask)"], ["", "lemma plus_one_helper[elim!]:\n  \"x < n + (1 :: 'a :: len word) \\<Longrightarrow> x \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < n + 1 \\<Longrightarrow> x \\<le> n", "apply (simp add: word_less_nat_alt word_le_nat_alt field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < unat (1 + n) \\<Longrightarrow> unat x \\<le> unat n", "apply (case_tac \"1 + n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < unat (1 + n); 1 + n = 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat n\n 2. \\<lbrakk>unat x < unat (1 + n); 1 + n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat n", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < unat (1 + n); 1 + n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat n", "apply (subst(asm) unatSuc, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < Suc (unat n); 1 + n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat n", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma plus_one_helper2:\n  \"\\<lbrakk> x \\<le> n; n + 1 \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x < n + (1 :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n; n + 1 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x < n + 1", "by (simp add: word_less_nat_alt word_le_nat_alt field_simps\n                unatSuc)"], ["", "lemma less_x_plus_1:\n  fixes x :: \"'a :: len word\" shows\n  \"x \\<noteq> max_word \\<Longrightarrow> (y < (x + 1)) = (y < x \\<or> y = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> - 1 \\<Longrightarrow> (y < x + 1) = (y < x \\<or> y = x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> - 1; y < x + 1\\<rbrakk>\n    \\<Longrightarrow> y < x \\<or> y = x\n 2. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x\\<rbrakk>\n    \\<Longrightarrow> y < x + 1", "apply (rule disjCI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> - 1; y < x + 1; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> y < x\n 2. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x\\<rbrakk>\n    \\<Longrightarrow> y < x + 1", "apply (drule plus_one_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> - 1; y \\<noteq> x; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y < x\n 2. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x\\<rbrakk>\n    \\<Longrightarrow> y < x + 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x\\<rbrakk>\n    \\<Longrightarrow> y < x + 1", "apply (subgoal_tac \"x < x + 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x; x < x + 1\\<rbrakk>\n    \\<Longrightarrow> y < x + 1\n 2. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x\\<rbrakk>\n    \\<Longrightarrow> x < x + 1", "apply (erule disjE, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x\\<rbrakk>\n    \\<Longrightarrow> x < x + 1", "apply (rule plus_one_helper2 [OF order_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0", "apply (rule notI, drule max_word_wrap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> - 1; y < x \\<or> y = x; x = - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_Suc_leq:\n  fixes k::\"'a::len word\" shows \"k \\<noteq> max_word \\<Longrightarrow> x < k + 1 \\<longleftrightarrow> x \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> - 1 \\<Longrightarrow> (x < k + 1) = (x \\<le> k)", "using less_x_plus_1 word_le_less_eq"], ["proof (prove)\nusing this:\n  ?x \\<noteq> - 1 \\<Longrightarrow> (?y < ?x + 1) = (?y < ?x \\<or> ?y = ?x)\n  (?x \\<le> ?y) = (?x = ?y \\<or> ?x < ?y)\n\ngoal (1 subgoal):\n 1. k \\<noteq> - 1 \\<Longrightarrow> (x < k + 1) = (x \\<le> k)", "by auto"], ["", "lemma word_Suc_le:\n   fixes k::\"'a::len word\" shows \"x \\<noteq> max_word \\<Longrightarrow> x + 1 \\<le> k \\<longleftrightarrow> x < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> - 1 \\<Longrightarrow> (x + 1 \\<le> k) = (x < k)", "by (meson not_less word_Suc_leq)"], ["", "lemma word_lessThan_Suc_atMost:\n  \\<open>{..< k + 1} = {..k}\\<close> if \\<open>k \\<noteq> - 1\\<close> for k :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<k + 1} = {..k}", "using that"], ["proof (prove)\nusing this:\n  k \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. {..<k + 1} = {..k}", "by (simp add: lessThan_def atMost_def word_Suc_leq)"], ["", "lemma word_atLeastLessThan_Suc_atLeastAtMost:\n  \\<open>{l ..< u + 1} = {l..u}\\<close> if \\<open>u \\<noteq> - 1\\<close> for l :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l..<u + 1} = {l..u}", "using that"], ["proof (prove)\nusing this:\n  u \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. {l..<u + 1} = {l..u}", "by (simp add: atLeastAtMost_def atLeastLessThan_def word_lessThan_Suc_atMost)"], ["", "lemma word_atLeastAtMost_Suc_greaterThanAtMost:\n  \\<open>{m<..u} = {m + 1..u}\\<close> if \\<open>m \\<noteq> - 1\\<close> for m :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {m<..u} = {m + 1..u}", "using that"], ["proof (prove)\nusing this:\n  m \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. {m<..u} = {m + 1..u}", "by (simp add: greaterThanAtMost_def greaterThan_def atLeastAtMost_def atLeast_def word_Suc_le)"], ["", "lemma word_atLeastLessThan_Suc_atLeastAtMost_union:\n  fixes l::\"'a::len word\"\n  assumes \"m \\<noteq> max_word\" and \"l \\<le> m\" and \"m \\<le> u\"\n  shows \"{l..m} \\<union> {m+1..u} = {l..u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l..m} \\<union> {m + 1..u} = {l..u}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {l..m} \\<union> {m + 1..u} = {l..u}", "from ivl_disj_un_two(8)[OF assms(2) assms(3)]"], ["proof (chain)\npicking this:\n  {l..m} \\<union> {m<..u} = {l..u}", "have \"{l..u} = {l..m} \\<union> {m<..u}\""], ["proof (prove)\nusing this:\n  {l..m} \\<union> {m<..u} = {l..u}\n\ngoal (1 subgoal):\n 1. {l..u} = {l..m} \\<union> {m<..u}", "by blast"], ["proof (state)\nthis:\n  {l..u} = {l..m} \\<union> {m<..u}\n\ngoal (1 subgoal):\n 1. {l..m} \\<union> {m + 1..u} = {l..u}", "with assms"], ["proof (chain)\npicking this:\n  m \\<noteq> - 1\n  l \\<le> m\n  m \\<le> u\n  {l..u} = {l..m} \\<union> {m<..u}", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<noteq> - 1\n  l \\<le> m\n  m \\<le> u\n  {l..u} = {l..m} \\<union> {m<..u}\n\ngoal (1 subgoal):\n 1. {l..m} \\<union> {m + 1..u} = {l..u}", "by(simp add: word_atLeastAtMost_Suc_greaterThanAtMost)"], ["proof (state)\nthis:\n  {l..m} \\<union> {m + 1..u} = {l..u}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_word_less_eq_iff [simp]:\n  \\<open>- 1 \\<le> w \\<longleftrightarrow> w = - 1\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1 \\<le> w) = (w = - 1)", "by (fact word_order.extremum_unique)"], ["", "lemma word_or_zero:\n  \"(a OR b = 0) = (a = 0 \\<and> b = 0)\"\n  for a b :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a OR b = 0) = (a = 0 \\<and> b = 0)", "by (fact or_eq_0_iff)"], ["", "lemma word_2p_mult_inc:\n  assumes x: \"2 * 2 ^ n < (2::'a::len word) * 2 ^ m\"\n  assumes suc_n: \"Suc n < LENGTH('a::len)\"\n  shows \"2^n < (2::'a::len word)^m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n < 2 ^ m", "by (smt suc_n le_less_trans lessI nat_less_le nat_mult_less_cancel_disj p2_gt_0\n          power_Suc power_Suc unat_power_lower word_less_nat_alt x)"], ["", "lemma power_overflow:\n  \"n \\<ge> LENGTH('a) \\<Longrightarrow> 2 ^ n = (0 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> 2 ^ n = 0", "by simp"], ["", "lemmas extra_sle_sless_unfolds [simp] =\n    word_sle_eq[where a=0 and b=1]\n    word_sle_eq[where a=0 and b=\"numeral n\"]\n    word_sle_eq[where a=1 and b=0]\n    word_sle_eq[where a=1 and b=\"numeral n\"]\n    word_sle_eq[where a=\"numeral n\" and b=0]\n    word_sle_eq[where a=\"numeral n\" and b=1]\n    word_sless_alt[where a=0 and b=1]\n    word_sless_alt[where a=0 and b=\"numeral n\"]\n    word_sless_alt[where a=1 and b=0]\n    word_sless_alt[where a=1 and b=\"numeral n\"]\n    word_sless_alt[where a=\"numeral n\" and b=0]\n    word_sless_alt[where a=\"numeral n\" and b=1]\n  for n"], ["", "lemma word_sint_1:\n  \"sint (1::'a::len word) = (if LENGTH('a) = 1 then -1 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint 1 = (if LENGTH('a) = 1 then - 1 else 1)", "by (fact signed_1)"], ["", "lemma ucast_of_nat:\n  \"is_down (ucast :: 'a :: len word \\<Rightarrow> 'b :: len word)\n    \\<Longrightarrow> ucast (of_nat n :: 'a word) = (of_nat n :: 'b word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_down ucast \\<Longrightarrow> ucast (word_of_nat n) = word_of_nat n", "by transfer simp"], ["", "lemma scast_1':\n  \"(scast (1::'a::len word) :: 'b::len word) =\n   (word_of_int (signed_take_bit (LENGTH('a::len) - Suc 0) (1::int)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scast 1 = word_of_int (signed_take_bit (LENGTH('a) - Suc 0) 1)", "by transfer simp"], ["", "lemma scast_1:\n  \"(scast (1::'a::len word) :: 'b::len word) = (if LENGTH('a) = 1 then -1 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scast 1 = (if LENGTH('a) = 1 then - 1 else 1)", "by (fact signed_1)"], ["", "lemma unat_minus_one_word:\n  \"unat (-1 :: 'a :: len word) = 2 ^ LENGTH('a) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (- 1) = 2 ^ LENGTH('a) - 1", "apply (simp only: flip: mask_eq_exp_minus_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (- 1) = mask LENGTH('a)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat \\<circ> take_bit LENGTH('a)) (- 1) = mask LENGTH('a)", "apply (simp add: take_bit_minus_one_eq_mask nat_mask_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_diff_ls'' = word_diff_ls [where xa=x and x=x for x]"], ["", "lemmas word_diff_ls' = word_diff_ls'' [simplified]"], ["", "lemmas word_l_diffs' = word_l_diffs [where xa=x and x=x for x]"], ["", "lemmas word_l_diffs = word_l_diffs' [simplified]"], ["", "lemma two_power_increasing:\n  \"\\<lbrakk> n \\<le> m; m < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (2 :: 'a :: len word) ^ n \\<le> 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n \\<le> 2 ^ m", "by (simp add: word_le_nat_alt)"], ["", "lemma word_leq_le_minus_one:\n  \"\\<lbrakk> x \\<le> y; x \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x - 1 < (y :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x - 1 < y", "apply (simp add: word_less_nat_alt word_le_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x \\<le> unat y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (x - 1) < unat y", "apply (subst unat_minus_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x \\<le> unat y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> 0\n 2. \\<lbrakk>unat x \\<le> unat y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x - 1 < unat y", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x \\<le> unat y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x - 1 < unat y", "apply (cases \"unat x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x \\<le> unat y; x \\<noteq> 0; unat x = 0\\<rbrakk>\n    \\<Longrightarrow> unat x - 1 < unat y\n 2. \\<And>nat.\n       \\<lbrakk>unat x \\<le> unat y; x \\<noteq> 0; unat x = Suc nat\\<rbrakk>\n       \\<Longrightarrow> unat x - 1 < unat y", "apply (simp add: unat_eq_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>unat x \\<le> unat y; x \\<noteq> 0; unat x = Suc nat\\<rbrakk>\n       \\<Longrightarrow> unat x - 1 < unat y", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma neg_mask_combine:\n  \"NOT(mask a) AND NOT(mask b) = NOT(mask (max a b) :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (mask a) AND NOT (mask b) = NOT (mask (max a b))", "by (rule bit_word_eqI) (auto simp add: bit_simps)"], ["", "lemma neg_mask_twice:\n  \"x AND NOT(mask n) AND NOT(mask m) = x AND NOT(mask (max n m))\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND NOT (mask n) AND NOT (mask m) = x AND NOT (mask (max n m))", "by (rule bit_word_eqI) (auto simp add: bit_simps)"], ["", "lemma multiple_mask_trivia:\n  \"n \\<ge> m \\<Longrightarrow> (x AND NOT(mask n)) + (x AND mask n AND NOT(mask m)) = x AND NOT(mask m)\"\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    (x AND NOT (mask n)) + (x AND mask n AND NOT (mask m)) =\n    x AND NOT (mask m)", "apply (rule trans[rotated], rule_tac w=\"mask n\" in word_plus_and_or_coroll2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    (x AND NOT (mask n)) + (x AND mask n AND NOT (mask m)) =\n    ((x AND NOT (mask m)) AND mask n) +\n    ((x AND NOT (mask m)) AND NOT (mask n))", "apply (simp add: word_bw_assocs word_bw_comms word_bw_lcs neg_mask_twice\n                   max_absorb2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_of_nat_less:\n  \"\\<lbrakk> n < unat x \\<rbrakk> \\<Longrightarrow> of_nat n < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < unat x \\<Longrightarrow> word_of_nat n < x", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < unat x \\<Longrightarrow> take_bit LENGTH('a) n < unat x", "apply (erule order_le_less_trans[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) n \\<le> n", "apply (simp add: take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_mask:\n  \"unat (mask n :: 'a :: len word) = 2 ^ (min n (LENGTH('a))) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (mask n) = 2 ^ min n LENGTH('a) - 1", "apply (subst min.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (mask n) = 2 ^ min LENGTH('a) n - 1", "apply (simp add: mask_eq_decr_exp not_less min_def  split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LENGTH('a) \\<le> n \\<longrightarrow>\n     unat (2 ^ n - 1) = 2 ^ LENGTH('a) - Suc 0) \\<and>\n    (\\<not> LENGTH('a) \\<le> n \\<longrightarrow>\n     unat (2 ^ n - 1) = 2 ^ n - Suc 0)", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow>\n    unat (2 ^ n - 1) = 2 ^ LENGTH('a) - Suc 0\n 2. \\<not> LENGTH('a) \\<le> n \\<Longrightarrow>\n    unat (2 ^ n - 1) = 2 ^ n - Suc 0", "apply (simp add: unat_sub_if_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow>\n    (Suc 0 \\<le> unat (2 ^ n) \\<longrightarrow>\n     unat (2 ^ n) - Suc 0 = 2 ^ LENGTH('a) - Suc 0) \\<and>\n    (\\<not> Suc 0 \\<le> unat (2 ^ n) \\<longrightarrow>\n     unat (2 ^ n) + 2 ^ size (2 ^ n) - Suc 0 = 2 ^ LENGTH('a) - Suc 0)\n 2. \\<not> LENGTH('a) \\<le> n \\<Longrightarrow>\n    unat (2 ^ n - 1) = 2 ^ n - Suc 0", "apply (simp add: power_overflow word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) \\<le> n \\<Longrightarrow>\n    unat (2 ^ n - 1) = 2 ^ n - Suc 0", "apply (simp add: unat_sub_if_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_over_length:\n  \"LENGTH('a) \\<le> n \\<Longrightarrow> mask n = (-1::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> mask n = - 1", "by (simp add: mask_eq_decr_exp)"], ["", "lemma Suc_2p_unat_mask:\n  \"n < LENGTH('a) \\<Longrightarrow> Suc (2 ^ n * k + unat (mask n :: 'a::len word)) = 2 ^ n * (k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    Suc (2 ^ n * k + unat (mask n)) = 2 ^ n * (k + 1)", "by (simp add: unat_mask)"], ["", "lemma sint_of_nat_ge_zero:\n  \"x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> sint (of_nat x :: 'a :: len word) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> 0 \\<le> sint (word_of_nat x)", "by (simp add: bit_iff_odd)"], ["", "lemma int_eq_sint:\n  \"x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> sint (of_nat x :: 'a :: len word) = int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow> sint (word_of_nat x) = int x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow>\n       signed_take_bit (LENGTH('a) - Suc 0) (int x) = int x", "apply (rule signed_take_bit_int_eq_self)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow>\n       - (2 ^ (LENGTH('a) - Suc 0)) \\<le> int x\n 2. \\<And>x.\n       x < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow>\n       int x < 2 ^ (LENGTH('a) - Suc 0)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n       - (2 ^ (LENGTH('a) - Suc 0)) \\<le> int x", "apply (metis negative_zle numeral_power_eq_of_nat_cancel_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sint_of_nat_le:\n  \"\\<lbrakk> b < 2 ^ (LENGTH('a) - 1); a \\<le> b \\<rbrakk>\n   \\<Longrightarrow> sint (of_nat a :: 'a :: len word) \\<le> sint (of_nat b :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 2 ^ (LENGTH('a) - 1); a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> sint (word_of_nat a) \\<le> sint (word_of_nat b)", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b < 2 ^ (LENGTH('a) - 1); a \\<le> b; LENGTH('a) = 0\\<rbrakk>\n    \\<Longrightarrow> sint (word_of_nat a) \\<le> sint (word_of_nat b)\n 2. \\<And>nat.\n       \\<lbrakk>b < 2 ^ (LENGTH('a) - 1); a \\<le> b;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> sint (word_of_nat a) \\<le> sint (word_of_nat b)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> signed_take_bit nat (int a)\n                         \\<le> signed_take_bit nat (int b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> signed_take_bit nat (int a)\n                         \\<le> signed_take_bit nat (int b)", "apply (subst signed_take_bit_eq_if_positive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit (int a) nat\n 2. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit nat (int a)\n                         \\<le> signed_take_bit nat (int b)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit a nat\n 2. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit nat (int a)\n                         \\<le> signed_take_bit nat (int b)", "apply (metis bit_take_bit_iff nat_less_le order_less_le_trans take_bit_nat_eq_self_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit nat (int a)\n                         \\<le> signed_take_bit nat (int b)", "apply (subst signed_take_bit_eq_if_positive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit (int b) nat\n 2. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit nat (int a) \\<le> take_bit nat (int b)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit b nat\n 2. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit nat (int a) \\<le> take_bit nat (int b)", "apply (metis bit_take_bit_iff nat_less_le take_bit_nat_eq_self_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat b a.\n       \\<lbrakk>b < 2 ^ nat; a \\<le> b; LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit nat (int a) \\<le> take_bit nat (int b)", "apply (simp flip: of_nat_take_bit add: take_bit_nat_eq_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_le_not_less:\n  \"((b::'a::len word) \\<le> a) = (\\<not>(a < b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<le> a) = (\\<not> a < b)", "by fastforce"], ["", "lemma less_is_non_zero_p1:\n  fixes a :: \"'a :: len word\"\n  shows \"a < k \\<Longrightarrow> a + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < k \\<Longrightarrow> a + 1 \\<noteq> 0", "apply (erule contrapos_pn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 = 0 \\<Longrightarrow> \\<not> a < k", "apply (drule max_word_wrap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = - 1 \\<Longrightarrow> \\<not> a < k", "apply (simp add: not_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_add_lem':\n  \"(unat x + unat y < 2 ^ LENGTH('a)) \\<Longrightarrow>\n    (unat (x + y :: 'a :: len word) = unat x + unat y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    unat (x + y) = unat x + unat y", "by (subst unat_add_lem[symmetric], assumption)"], ["", "lemma word_less_two_pow_divI:\n  \"\\<lbrakk> (x :: 'a::len word) < 2 ^ (n - m); m \\<le> n; n < LENGTH('a) \\<rbrakk> \\<Longrightarrow> x < 2 ^ n div 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ n div 2 ^ m", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x < unat (2 ^ n div 2 ^ m)", "apply (subst unat_word_ariths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x\n                      < unat (2 ^ n) div unat (2 ^ m) mod 2 ^ LENGTH('a)", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) div unat (2 ^ m) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x < unat (2 ^ n) div unat (2 ^ m)", "apply (rule order_le_less_trans [OF div_le_dividend])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x < unat (2 ^ n) div unat (2 ^ m)", "apply (rule unat_lt2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x < 2 ^ (n - m); m \\<le> n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x < unat (2 ^ n) div unat (2 ^ m)", "apply (simp add: power_sub)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_less_two_pow_divD:\n  \"\\<lbrakk> (x :: 'a::len word) < 2 ^ n div 2 ^ m \\<rbrakk>\n     \\<Longrightarrow> n \\<ge> m \\<and> (x < 2 ^ (n - m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ n div 2 ^ m \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (cases \"n < LENGTH('a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 2. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (cases \"m < LENGTH('a)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 2. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a);\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 3. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>unat x < unat (2 ^ n div 2 ^ m); n < LENGTH('a);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> unat x < 2 ^ (n - m)\n 2. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a);\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 3. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (subst(asm) unat_word_ariths)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>unat x < unat (2 ^ n) div unat (2 ^ m) mod 2 ^ LENGTH('a);\n     n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> unat x < 2 ^ (n - m)\n 2. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a);\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 3. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (subst(asm) mod_less)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) div unat (2 ^ m) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < unat (2 ^ n) div unat (2 ^ m); n < LENGTH('a);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> unat x < 2 ^ (n - m)\n 3. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a);\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 4. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (rule order_le_less_trans [OF div_le_dividend])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat x < unat (2 ^ n) div unat (2 ^ m); n < LENGTH('a);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> unat x < 2 ^ (n - m)\n 3. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a);\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 4. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (rule unat_lt2p)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>unat x < unat (2 ^ n) div unat (2 ^ m); n < LENGTH('a);\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> unat x < 2 ^ (n - m)\n 2. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a);\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 3. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (clarsimp dest!: less_two_pow_divD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ n div 2 ^ m; n < LENGTH('a);\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)\n 2. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (simp add: power_overflow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ n div 2 ^ m; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (simp add: word_div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < word_of_int (uint (2 ^ n) div uint (2 ^ m));\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n \\<and> x < 2 ^ (n - m)", "apply (simp add: power_overflow word_div_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_nat_less_two_pow_div_set:\n  \"\\<lbrakk> n < LENGTH('a) \\<rbrakk> \\<Longrightarrow>\n   {x. x < (2 ^ n div 2 ^ m :: 'a::len word)}\n      = of_nat ` {k. k < 2 ^ n div 2 ^ m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    {x. x < 2 ^ n div 2 ^ m} = word_of_nat ` {k. k < 2 ^ n div 2 ^ m}", "apply (simp add: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    {x. x < 2 ^ n div 2 ^ m} =\n    {y. \\<exists>x<2 ^ n div 2 ^ m. y = word_of_nat x}", "apply (safe dest!: word_less_two_pow_divD less_two_pow_divD\n             intro!: word_less_two_pow_divI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; x < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa<2 ^ n div 2 ^ m. x = word_of_nat xa\n 2. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa < 2 ^ (n - m)", "apply (rule_tac x=\"unat x\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; x < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> unat x < 2 ^ n div 2 ^ m \\<and>\n                         x = word_of_nat (unat x)\n 2. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa < 2 ^ (n - m)", "apply (simp add: power_sub[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; x < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> unat x < 2 ^ (n - m)\n 2. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa < 2 ^ (n - m)", "apply (subst unat_power_lower[symmetric, where 'a='a])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; x < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> n - m < LENGTH('a)\n 2. \\<And>x.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; x < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> unat x < unat (2 ^ (n - m))\n 3. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa < 2 ^ (n - m)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; x < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> unat x < unat (2 ^ (n - m))\n 2. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa < 2 ^ (n - m)", "apply (erule unat_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa < 2 ^ (n - m)", "apply (subst word_unat_power)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa < word_of_nat (2 ^ (n - m))", "apply (rule of_nat_mono_maybe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (n - m) < 2 ^ LENGTH('a)\n 2. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ (n - m)", "apply (rule power_strict_increasing)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> n - m < LENGTH('a)\n 2. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> 1 < 2\n 3. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ (n - m)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> 1 < 2\n 2. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ (n - m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>n < LENGTH('a); m \\<le> n; xa < 2 ^ (n - m)\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ (n - m)", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_less:\n  \"LENGTH('b) < LENGTH('a) \\<Longrightarrow>\n   (ucast (x :: 'b :: len word) :: ('a :: len word)) < 2 ^ LENGTH('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('b) < LENGTH('a) \\<Longrightarrow> ucast x < 2 ^ LENGTH('b)", "by transfer simp"], ["", "lemma ucast_range_less:\n  \"LENGTH('a :: len) < LENGTH('b :: len) \\<Longrightarrow>\n   range (ucast :: 'a word \\<Rightarrow> 'b word) = {x. x < 2 ^ len_of TYPE ('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) < LENGTH('b) \\<Longrightarrow>\n    range ucast = {x. x < 2 ^ LENGTH('a)}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>LENGTH('a) < LENGTH('b); xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> ucast xa < 2 ^ LENGTH('a)\n 2. \\<And>x.\n       \\<lbrakk>LENGTH('a) < LENGTH('b); x < 2 ^ LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range ucast", "apply (erule ucast_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>LENGTH('a) < LENGTH('b); x < 2 ^ LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range ucast", "apply (simp add: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>LENGTH('a) < LENGTH('b); x < 2 ^ LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = ucast xa", "apply (rule_tac x=\"ucast x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>LENGTH('a) < LENGTH('b); x < 2 ^ LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> x = ucast (ucast x)", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>LENGTH('a) < LENGTH('b); x < 2 ^ LENGTH('a);\n        n < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> bit x n = bit (ucast (ucast x)) n", "apply (auto simp add: bit_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>x < 2 ^ LENGTH('a); n < LENGTH('b); bit x n;\n        LENGTH('a) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis bit_take_bit_iff less_mask_eq not_less take_bit_eq_mask)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_power_less_diff:\n  \"\\<lbrakk>2 ^ n * q < (2::'a::len word) ^ m; q < 2 ^ (LENGTH('a) - n)\\<rbrakk> \\<Longrightarrow> q < 2 ^ (m - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)", "apply (case_tac \"m \\<ge> LENGTH('a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     LENGTH('a) \\<le> m\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)\n 2. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)", "apply (simp add: power_overflow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)", "apply (case_tac \"n \\<ge> LENGTH('a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)\n 2. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)", "apply (simp add: power_overflow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)", "apply (cases \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n; n = 0\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)\n 2. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> q < 2 ^ (m - n)", "apply (subst word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat q < unat (2 ^ (m - n))", "apply (subst unat_power_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> m - n < LENGTH('a)\n 2. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat q < 2 ^ (m - n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat q < 2 ^ (m - n)", "apply (rule nat_power_less_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n * q < 2 ^ m; q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * unat q < 2 ^ m", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (2 ^ n * q) < 2 ^ m; unat q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * unat q < 2 ^ m", "apply (subst (asm) iffD1 [OF unat_mult_lem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat q < 2 ^ (LENGTH('a) - n); \\<not> LENGTH('a) \\<le> m;\n     \\<not> LENGTH('a) \\<le> n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) * unat q < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat (2 ^ n) * unat q < 2 ^ m; unat q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * unat q < 2 ^ m", "apply (simp add:nat_less_power_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (2 ^ n) * unat q < 2 ^ m; unat q < 2 ^ (LENGTH('a) - n);\n     \\<not> LENGTH('a) \\<le> m; \\<not> LENGTH('a) \\<le> n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * unat q < 2 ^ m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_less_sub_1:\n  \"x < (y :: 'a :: len word) \\<Longrightarrow> x \\<le> y - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> x \\<le> y - 1", "by (fact word_le_minus_one_leq)"], ["", "lemma word_sub_mono2:\n  \"\\<lbrakk> a + b \\<le> c + d; c \\<le> a; b \\<le> a + b; d \\<le> c + d \\<rbrakk>\n    \\<Longrightarrow> b \\<le> (d :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + b \\<le> c + d; c \\<le> a; b \\<le> a + b;\n     d \\<le> c + d\\<rbrakk>\n    \\<Longrightarrow> b \\<le> d", "apply (drule(1) word_sub_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c \\<le> a; b \\<le> a + b; d \\<le> c + d\\<rbrakk>\n    \\<Longrightarrow> a + b - a \\<le> a + b\n 2. \\<lbrakk>c \\<le> a; b \\<le> a + b; d \\<le> c + d\\<rbrakk>\n    \\<Longrightarrow> c + d - c \\<le> c + d\n 3. \\<lbrakk>c \\<le> a; b \\<le> a + b; d \\<le> c + d;\n     a + b - a \\<le> c + d - c\\<rbrakk>\n    \\<Longrightarrow> b \\<le> d", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c \\<le> a; b \\<le> a + b; d \\<le> c + d\\<rbrakk>\n    \\<Longrightarrow> c + d - c \\<le> c + d\n 2. \\<lbrakk>c \\<le> a; b \\<le> a + b; d \\<le> c + d;\n     a + b - a \\<le> c + d - c\\<rbrakk>\n    \\<Longrightarrow> b \\<le> d", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<le> a; b \\<le> a + b; d \\<le> c + d;\n     a + b - a \\<le> c + d - c\\<rbrakk>\n    \\<Longrightarrow> b \\<le> d", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_not_le:\n  \"(\\<not> x \\<le> (y :: 'a :: len word)) = (y < x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> x \\<le> y) = (y < x)", "by fastforce"], ["", "lemma word_subset_less:\n  \"\\<lbrakk> {x .. x + r - 1} \\<subseteq> {y .. y + s - 1};\n     x \\<le> x + r - 1; y \\<le> y + (s :: 'a :: len word) - 1;\n     s \\<noteq> 0 \\<rbrakk>\n     \\<Longrightarrow> r \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x..x + r - 1} \\<subseteq> {y..y + s - 1}; x \\<le> x + r - 1;\n     y \\<le> y + s - 1; s \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply (frule subsetD[where c=x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{x..x + r - 1} \\<subseteq> {y..y + s - 1}; x \\<le> x + r - 1;\n     y \\<le> y + s - 1; s \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {x..x + r - 1}\n 2. \\<lbrakk>{x..x + r - 1} \\<subseteq> {y..y + s - 1}; x \\<le> x + r - 1;\n     y \\<le> y + s - 1; s \\<noteq> 0; x \\<in> {y..y + s - 1}\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x..x + r - 1} \\<subseteq> {y..y + s - 1}; x \\<le> x + r - 1;\n     y \\<le> y + s - 1; s \\<noteq> 0; x \\<in> {y..y + s - 1}\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply (drule subsetD[where c=\"x + r - 1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> x + r - 1; y \\<le> y + s - 1; s \\<noteq> 0;\n     x \\<in> {y..y + s - 1}\\<rbrakk>\n    \\<Longrightarrow> x + r - 1 \\<in> {x..x + r - 1}\n 2. \\<lbrakk>x \\<le> x + r - 1; y \\<le> y + s - 1; s \\<noteq> 0;\n     x \\<in> {y..y + s - 1}; x + r - 1 \\<in> {y..y + s - 1}\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + r - 1; y \\<le> y + s - 1; s \\<noteq> 0;\n     x \\<in> {y..y + s - 1}; x + r - 1 \\<in> {y..y + s - 1}\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply (clarsimp simp: add_diff_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + (r - 1); y \\<le> y + (s - 1); s \\<noteq> 0;\n     y \\<le> x; x \\<le> y + (s - 1); y \\<le> x + (r - 1);\n     x + (r - 1) \\<le> y + (s - 1)\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply (drule(1) word_sub_mono2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> x + (r - 1); y \\<le> y + (s - 1); s \\<noteq> 0;\n     y \\<le> x; x \\<le> y + (s - 1); y \\<le> x + (r - 1)\\<rbrakk>\n    \\<Longrightarrow> r - 1 \\<le> x + (r - 1)\n 2. \\<lbrakk>x \\<le> x + (r - 1); y \\<le> y + (s - 1); s \\<noteq> 0;\n     y \\<le> x; x \\<le> y + (s - 1); y \\<le> x + (r - 1)\\<rbrakk>\n    \\<Longrightarrow> s - 1 \\<le> y + (s - 1)\n 3. \\<lbrakk>x \\<le> x + (r - 1); y \\<le> y + (s - 1); s \\<noteq> 0;\n     y \\<le> x; x \\<le> y + (s - 1); y \\<le> x + (r - 1);\n     r - 1 \\<le> s - 1\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply (simp_all add: olen_add_eqv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + (r - 1); y \\<le> y + (s - 1); s \\<noteq> 0;\n     y \\<le> x; x \\<le> y + (s - 1); y \\<le> x + (r - 1);\n     r - 1 \\<le> s - 1\\<rbrakk>\n    \\<Longrightarrow> r \\<le> s", "apply (erule word_le_minus_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + (r - 1); y \\<le> y + (s - 1); s \\<noteq> 0;\n     y \\<le> x; x \\<le> y + (s - 1); y \\<le> x + (r - 1)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> s", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + (r - 1); y \\<le> y + (s - 1); s \\<noteq> 0;\n     y \\<le> x; x \\<le> y + (s - 1); y \\<le> x + (r - 1);\n     \\<not> 1 \\<le> s\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: word_not_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma uint_power_lower:\n  \"n < LENGTH('a) \\<Longrightarrow> uint (2 ^ n :: 'a :: len word) = (2 ^ n :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> uint (2 ^ n) = 2 ^ n", "by (rule uint_2p_alt)"], ["", "lemma power_le_mono:\n  \"\\<lbrakk>2 ^ n \\<le> (2::'a::len word) ^ m; n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> n \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n \\<le> 2 ^ m; n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n \\<le> m", "apply (clarsimp simp add: le_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ n < 2 ^ m \\<or> 2 ^ n = 2 ^ m; n < LENGTH('a);\n     m < LENGTH('a); n \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> n < m", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a); n \\<noteq> m;\n     2 ^ n < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> n < m\n 2. \\<lbrakk>n < LENGTH('a); m < LENGTH('a); n \\<noteq> m;\n     2 ^ n = 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> n < m", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a); n \\<noteq> m;\n     2 ^ n = 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> n < m", "apply (simp only: uint_arith_simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a); n \\<noteq> m;\n     uint (2 ^ n) = uint (2 ^ m)\\<rbrakk>\n    \\<Longrightarrow> n < m", "apply (drule uint_power_lower)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> m; uint (2 ^ n) = uint (2 ^ m);\n     uint (2 ^ n) = 2 ^ n; uint (2 ^ m) = 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> n < m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma two_power_eq:\n  \"\\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> ((2::'a::len word) ^ n = 2 ^ m) = (n = m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (2 ^ n = 2 ^ m) = (n = m)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a); 2 ^ n = 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> n = m", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a); 2 ^ n = 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> n \\<le> m\n 2. \\<lbrakk>n < LENGTH('a); m < LENGTH('a); 2 ^ n = 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> m \\<le> n", "apply (simp add: power_le_mono[where 'a='a])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_less_helper:\n  \"x < of_nat n \\<Longrightarrow> unat x < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < word_of_nat n \\<Longrightarrow> unat x < n", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < take_bit LENGTH('a) n \\<Longrightarrow> unat x < n", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) n \\<le> n", "apply (simp add: take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nat_uint_less_helper:\n  \"nat (uint y) = z \\<Longrightarrow> x < y \\<Longrightarrow> nat (uint x) < z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat (uint y) = z; x < y\\<rbrakk>\n    \\<Longrightarrow> nat (uint x) < z", "apply (erule subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> nat (uint x) < nat (uint y)", "apply (subst unat_eq_nat_uint [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> unat x < nat (uint y)", "apply (subst unat_eq_nat_uint [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> unat x < unat y", "by (simp add: unat_mono)"], ["", "lemma of_nat_0:\n  \"\\<lbrakk>of_nat n = (0::'a::len word); n < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_of_nat n = 0; n < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n = 0", "by transfer (simp add: take_bit_eq_mod)"], ["", "lemma of_nat_inj:\n  \"\\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow>\n   (of_nat x = (of_nat y :: 'a :: len word)) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (word_of_nat x = word_of_nat y) = (x = y)", "by (metis unat_of_nat_len)"], ["", "lemma div_to_mult_word_lt:\n  \"\\<lbrakk> (x :: 'a :: len word) \\<le> y div z \\<rbrakk> \\<Longrightarrow> x * z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y div z \\<Longrightarrow> x * z \\<le> y", "apply (cases \"z = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y div z; z = 0\\<rbrakk> \\<Longrightarrow> x * z \\<le> y\n 2. \\<lbrakk>x \\<le> y div z; z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x * z \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y div z; z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x * z \\<le> y", "apply (simp add: word_neq_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y div z; 0 < z\\<rbrakk> \\<Longrightarrow> x * z \\<le> y", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y div z; 0 < z\\<rbrakk>\n    \\<Longrightarrow> x * z \\<le> ?y1\n 2. \\<lbrakk>x \\<le> y div z; 0 < z\\<rbrakk> \\<Longrightarrow> ?y1 \\<le> y", "apply (erule(1) word_mult_le_mono1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < z \\<Longrightarrow> unat (y div z) * unat z < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x \\<le> y div z; 0 < z\\<rbrakk>\n    \\<Longrightarrow> y div z * z \\<le> y", "apply (simp add: unat_div)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < z \\<Longrightarrow> unat y div unat z * unat z < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x \\<le> y div z; 0 < z\\<rbrakk>\n    \\<Longrightarrow> y div z * z \\<le> y", "apply (rule order_le_less_trans [OF div_mult_le])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < z \\<Longrightarrow> unat y < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x \\<le> y div z; 0 < z\\<rbrakk>\n    \\<Longrightarrow> y div z * z \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y div z; 0 < z\\<rbrakk>\n    \\<Longrightarrow> y div z * z \\<le> y", "apply (rule word_div_mult_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_ucast_mask:\n  \"(ucast :: 'a :: len word \\<Rightarrow> 'b :: len word) (ucast x) = x AND mask (len_of TYPE ('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ucast (ucast x) = x AND mask LENGTH('a)", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ucast (ucast x) = take_bit LENGTH('a) x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       take_bit LENGTH('b) (take_bit LENGTH('a) (take_bit LENGTH('b) x)) =\n       take_bit LENGTH('b) (take_bit (min LENGTH('b) LENGTH('a)) x)", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_ucast_len:\n  \"\\<lbrakk> x < 2 ^ LENGTH('b) \\<rbrakk> \\<Longrightarrow> ucast (ucast x::'b::len word) = (x::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ LENGTH('b) \\<Longrightarrow> ucast (ucast x) = x", "apply (subst ucast_ucast_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ LENGTH('b) \\<Longrightarrow> x AND mask LENGTH('b) = x", "apply (erule less_mask_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_ucast_id:\n  \"LENGTH('a) < LENGTH('b) \\<Longrightarrow> ucast (ucast (x::'a::len word)::'b::len word) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) < LENGTH('b) \\<Longrightarrow> ucast (ucast x) = x", "by (auto intro: ucast_up_ucast_id simp: is_up_def source_size_def target_size_def word_size)"], ["", "lemma unat_ucast:\n  \"unat (ucast x :: ('a :: len) word) = unat x mod 2 ^ (LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (ucast x) = unat x mod 2 ^ LENGTH('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unat (ucast x) = unat x mod 2 ^ LENGTH('a)", "have \\<open>2 ^ LENGTH('a) = nat (2 ^ LENGTH('a))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('a) = nat (2 ^ LENGTH('a))", "by simp"], ["proof (state)\nthis:\n  2 ^ LENGTH('a) = nat (2 ^ LENGTH('a))\n\ngoal (1 subgoal):\n 1. unat (ucast x) = unat x mod 2 ^ LENGTH('a)", "moreover"], ["proof (state)\nthis:\n  2 ^ LENGTH('a) = nat (2 ^ LENGTH('a))\n\ngoal (1 subgoal):\n 1. unat (ucast x) = unat x mod 2 ^ LENGTH('a)", "have \\<open>unat (ucast x :: 'a word) = unat x mod nat (2 ^ LENGTH('a))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (ucast x) = unat x mod nat (2 ^ LENGTH('a))", "by transfer (simp flip: nat_mod_distrib take_bit_eq_mod)"], ["proof (state)\nthis:\n  unat (ucast x) = unat x mod nat (2 ^ LENGTH('a))\n\ngoal (1 subgoal):\n 1. unat (ucast x) = unat x mod 2 ^ LENGTH('a)", "ultimately"], ["proof (chain)\npicking this:\n  2 ^ LENGTH('a) = nat (2 ^ LENGTH('a))\n  unat (ucast x) = unat x mod nat (2 ^ LENGTH('a))", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ LENGTH('a) = nat (2 ^ LENGTH('a))\n  unat (ucast x) = unat x mod nat (2 ^ LENGTH('a))\n\ngoal (1 subgoal):\n 1. unat (ucast x) = unat x mod 2 ^ LENGTH('a)", "by (simp only:)"], ["proof (state)\nthis:\n  unat (ucast x) = unat x mod 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ucast_less_ucast:\n  \"LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n   (ucast x < ((ucast (y :: 'a::len word)) :: 'b::len word)) = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (ucast x < ucast y) = (x < y)", "apply (simp add: word_less_nat_alt unat_ucast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (unat x mod 2 ^ LENGTH('b) < unat y mod 2 ^ LENGTH('b)) =\n    (unat x < unat y)", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow> unat x < 2 ^ LENGTH('b)\n 2. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (unat x < unat y mod 2 ^ LENGTH('b)) = (unat x < unat y)", "apply(rule less_le_trans[OF unat_lt2p], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (unat x < unat y mod 2 ^ LENGTH('b)) = (unat x < unat y)", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow> unat y < 2 ^ LENGTH('b)\n 2. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (unat x < unat y) = (unat x < unat y)", "apply(rule less_le_trans[OF unat_lt2p], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (unat x < unat y) = (unat x < unat y)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>This weaker version was previously called @{text ucast_less_ucast}. We retain it to\n    support existing proofs.\\<close>"], ["", "lemmas ucast_less_ucast_weak = ucast_less_ucast[OF order.strict_implies_order]"], ["", "lemma unat_Suc2:\n  fixes n :: \"'a :: len word\"\n  shows\n  \"n \\<noteq> -1 \\<Longrightarrow> unat (n + 1) = Suc (unat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> - 1 \\<Longrightarrow> unat (n + 1) = Suc (unat n)", "apply (subst add.commute, rule unatSuc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> - 1 \\<Longrightarrow> 1 + n \\<noteq> 0", "apply (subst eq_diff_eq[symmetric], simp add: minus_equation_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_div_1:\n  \"(n :: 'a :: len word) div 1 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div 1 = n", "by (fact bits_div_by_1)"], ["", "lemma word_minus_one_le:\n  \"-1 \\<le> (x :: 'a :: len word) = (x = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1 \\<le> x) = (x = - 1)", "by (fact word_order.extremum_unique)"], ["", "lemma up_scast_inj:\n      \"\\<lbrakk> scast x = (scast y :: 'b :: len word); size x \\<le> LENGTH('b) \\<rbrakk>\n         \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>scast x = scast y; size x \\<le> LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>take_bit LENGTH('b)\n                 (signed_take_bit (LENGTH('a) - Suc 0) x) =\n                take_bit LENGTH('b)\n                 (signed_take_bit (LENGTH('a) - Suc 0) y);\n        LENGTH('a) \\<le> LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x = take_bit LENGTH('a) y", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>take_bit LENGTH('b)\n                 (signed_take_bit (LENGTH('a) - Suc 0) x) =\n                take_bit LENGTH('b)\n                 (signed_take_bit (LENGTH('a) - Suc 0) y);\n        LENGTH('a) \\<le> LENGTH('b); LENGTH('a) = 0\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x = take_bit LENGTH('a) y\n 2. \\<And>x y nat.\n       \\<lbrakk>take_bit LENGTH('b)\n                 (signed_take_bit (LENGTH('a) - Suc 0) x) =\n                take_bit LENGTH('b)\n                 (signed_take_bit (LENGTH('a) - Suc 0) y);\n        LENGTH('a) \\<le> LENGTH('b); LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x = take_bit LENGTH('a) y", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y nat.\n       \\<lbrakk>take_bit LENGTH('b) (signed_take_bit nat x) =\n                take_bit LENGTH('b) (signed_take_bit nat y);\n        Suc nat \\<le> LENGTH('b); LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> take_bit (Suc nat) x = take_bit (Suc nat) y", "apply (metis order_refl take_bit_signed_take_bit take_bit_tightened)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma up_scast_inj_eq:\n  \"LENGTH('a) \\<le> len_of TYPE ('b) \\<Longrightarrow>\n  (scast x = (scast y::'b::len word)) = (x = (y::'a::len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    (scast x = scast y) = (x = y)", "by (fastforce dest: up_scast_inj simp: word_size)"], ["", "lemma word_le_add:\n  fixes x :: \"'a :: len word\"\n  shows \"x \\<le> y \\<Longrightarrow> \\<exists>n. y = x + of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> \\<exists>n. y = x + word_of_nat n", "by (rule exI [where x = \"unat (y - x)\"]) simp"], ["", "lemma word_plus_mcs_4':\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>x + v \\<le> x + w; x \\<le> x + v\\<rbrakk> \\<Longrightarrow> v \\<le> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + v \\<le> x + w; x \\<le> x + v\\<rbrakk>\n    \\<Longrightarrow> v \\<le> w", "apply (rule word_plus_mcs_4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x + v \\<le> x + w; x \\<le> x + v\\<rbrakk>\n    \\<Longrightarrow> v + ?x \\<le> w + ?x\n 2. \\<lbrakk>x + v \\<le> x + w; x \\<le> x + v\\<rbrakk>\n    \\<Longrightarrow> ?x \\<le> v + ?x", "apply (simp add: add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + v \\<le> x + w; x \\<le> x + v\\<rbrakk>\n    \\<Longrightarrow> x \\<le> v + x", "apply (simp add: add.commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_eq_1:\n  \\<open>unat x = Suc 0 \\<longleftrightarrow> x = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat x = Suc 0) = (x = 1)", "by (auto intro!: unsigned_word_eqI [where ?'a = nat])"], ["", "lemma word_unat_Rep_inject1:\n  \\<open>unat x = unat 1 \\<longleftrightarrow> x = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat x = unat 1) = (x = 1)", "by (simp add: unat_eq_1)"], ["", "lemma and_not_mask_twice:\n  \"(w AND NOT (mask n)) AND NOT (mask m) = w AND NOT (mask (max m n))\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND NOT (mask n)) AND NOT (mask m) = w AND NOT (mask (max m n))", "by (rule bit_word_eqI) (auto simp add: bit_simps)"], ["", "lemma word_less_cases:\n  \"x < y \\<Longrightarrow> x = y - 1 \\<or> x < y - (1 ::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> x = y - 1 \\<or> x < y - 1", "apply (drule word_less_sub_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y - 1 \\<Longrightarrow> x = y - 1 \\<or> x < y - 1", "apply (drule order_le_imp_less_or_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y - 1 \\<or> x = y - 1 \\<Longrightarrow> x = y - 1 \\<or> x < y - 1", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_and_mask:\n  \"mask a AND mask b = (mask (min a b) :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask a AND mask b = mask (min a b)", "by (simp flip: take_bit_eq_mask ac_simps)"], ["", "lemma mask_eq_0_eq_x:\n  \"(x AND w = 0) = (x AND NOT w = x)\"\n  for x w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND w = 0) = (x AND NOT w = x)", "using word_plus_and_or_coroll2[where x=x and w=w]"], ["proof (prove)\nusing this:\n  (x AND w) + (x AND NOT w) = x\n\ngoal (1 subgoal):\n 1. (x AND w = 0) = (x AND NOT w = x)", "by auto"], ["", "lemma mask_eq_x_eq_0:\n  \"(x AND w = x) = (x AND NOT w = 0)\"\n  for x w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND w = x) = (x AND NOT w = 0)", "using word_plus_and_or_coroll2[where x=x and w=w]"], ["proof (prove)\nusing this:\n  (x AND w) + (x AND NOT w) = x\n\ngoal (1 subgoal):\n 1. (x AND w = x) = (x AND NOT w = 0)", "by auto"], ["", "lemma compl_of_1: \"NOT 1 = (-2 :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT 1 = - 2", "by (fact not_one)"], ["", "lemma split_word_eq_on_mask:\n  \"(x = y) = (x AND m = y AND m \\<and> x AND NOT m = y AND NOT m)\"\n  for x y m :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (x AND m = y AND m \\<and> x AND NOT m = y AND NOT m)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y m.\n       (take_bit LENGTH('a) x = take_bit LENGTH('a) y) =\n       (take_bit LENGTH('a) (x AND m) = take_bit LENGTH('a) (y AND m) \\<and>\n        take_bit LENGTH('a) (x AND NOT m) =\n        take_bit LENGTH('a) (y AND NOT m))", "apply (simp add: bit_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y m.\n       (\\<forall>n.\n           bit (take_bit LENGTH('a) x) n = bit (take_bit LENGTH('a) y) n) =\n       ((\\<forall>n.\n            bit (take_bit LENGTH('a) x AND take_bit LENGTH('a) m) n =\n            bit (take_bit LENGTH('a) y AND take_bit LENGTH('a) m) n) \\<and>\n        (\\<forall>n.\n            bit (take_bit LENGTH('a) x AND take_bit LENGTH('a) (NOT m)) n =\n            bit (take_bit LENGTH('a) y AND take_bit LENGTH('a) (NOT m)) n))", "apply (auto simp add: bit_simps ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_FF_is_mask:\n  \"0xFF = (mask 8 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 255 = mask 8", "by (simp add: mask_eq_decr_exp)"], ["", "lemma word_1FF_is_mask:\n  \"0x1FF = (mask 9 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 511 = mask 9", "by (simp add: mask_eq_decr_exp)"], ["", "lemma ucast_of_nat_small:\n  \"x < 2 ^ LENGTH('a) \\<Longrightarrow> ucast (of_nat x :: 'a :: len word) = (of_nat x :: 'b :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ LENGTH('a) \\<Longrightarrow>\n    ucast (word_of_nat x) = word_of_nat x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < 2 ^ LENGTH('a) \\<Longrightarrow>\n       take_bit LENGTH('b) (take_bit LENGTH('a) (int x)) =\n       take_bit LENGTH('b) (int x)", "apply (auto simp add: take_bit_of_nat min_def not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < 2 ^ LENGTH('a); LENGTH('a) < LENGTH('b)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x = take_bit LENGTH('b) x", "apply (metis linorder_not_less min_def take_bit_nat_eq_self take_bit_take_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_le_make_less:\n  fixes x :: \"'a :: len word\"\n  shows \"y \\<noteq> -1 \\<Longrightarrow> (x \\<le> y) = (x < (y + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> - 1 \\<Longrightarrow> (x \\<le> y) = (x < y + 1)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> - 1; x \\<le> y\\<rbrakk> \\<Longrightarrow> x < y + 1", "apply (erule plus_one_helper2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> - 1 \\<Longrightarrow> y + 1 \\<noteq> 0", "apply (simp add: eq_diff_eq[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas finite_word = finite [where 'a=\"'a::len word\"]"], ["", "lemma word_to_1_set:\n  \"{0 ..< (1 :: 'a :: len word)} = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<1} = {0}", "by fastforce"], ["", "lemma word_leq_minus_one_le:\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk>y \\<noteq> 0; x \\<le> y - 1 \\<rbrakk> \\<Longrightarrow> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> 0; x \\<le> y - 1\\<rbrakk> \\<Longrightarrow> x < y", "using le_m1_iff_lt word_neq_0_conv"], ["proof (prove)\nusing this:\n  (0 < ?x) = ((?y \\<le> ?x - 1) = (?y < ?x))\n  (?w \\<noteq> 0) = (0 < ?w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> 0; x \\<le> y - 1\\<rbrakk> \\<Longrightarrow> x < y", "by blast"], ["", "lemma word_count_from_top:\n  \"n \\<noteq> 0 \\<Longrightarrow> {0 ..< n :: 'a :: len word} = {0 ..< n - 1} \\<union> {n - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> {0..<n} = {0..<n - 1} \\<union> {n - 1}", "apply (rule set_eqI, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<in> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {0..<n - 1} \\<union> {n - 1}\n 2. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<in> {0..<n - 1} \\<union> {n - 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {0..<n}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x < n\\<rbrakk>\n       \\<Longrightarrow> x = n - 1 \\<or> x < n - 1\n 2. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<in> {0..<n - 1} \\<union> {n - 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {0..<n}", "apply (drule word_le_minus_one_leq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<le> n - 1\\<rbrakk>\n       \\<Longrightarrow> x = n - 1 \\<or> x < n - 1\n 2. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<in> {0..<n - 1} \\<union> {n - 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {0..<n}", "apply (rule disjCI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<le> n - 1; \\<not> x < n - 1\\<rbrakk>\n       \\<Longrightarrow> x = n - 1\n 2. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<in> {0..<n - 1} \\<union> {n - 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {0..<n}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x \\<in> {0..<n - 1} \\<union> {n - 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {0..<n}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n \\<noteq> 0; x = n - 1 \\<or> x < n - 1\\<rbrakk>\n       \\<Longrightarrow> x < n", "apply (erule word_leq_minus_one_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x = n - 1 \\<or> x < n - 1 \\<Longrightarrow> x \\<le> n - 1", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_minus_one_le_leq:\n  \"\\<lbrakk> x - 1 < y \\<rbrakk> \\<Longrightarrow> x \\<le> (y :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - 1 < y \\<Longrightarrow> x \\<le> y", "apply (cases \"x = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x - 1 < y; x = 0\\<rbrakk> \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>x - 1 < y; x \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x - 1 < y; x \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x \\<le> y", "apply (simp add: word_less_nat_alt word_le_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat (x - 1) < unat y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply (subst(asm) unat_minus_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0\n 2. \\<lbrakk>unat x - 1 < unat y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat x - 1 < unat y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply (cases \"unat x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat x - 1 < unat y; x \\<noteq> 0; unat x = 0\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y\n 2. \\<And>nat.\n       \\<lbrakk>unat x - 1 < unat y; x \\<noteq> 0; unat x = Suc nat\\<rbrakk>\n       \\<Longrightarrow> unat x \\<le> unat y", "apply (simp add: unat_eq_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>unat x - 1 < unat y; x \\<noteq> 0; unat x = Suc nat\\<rbrakk>\n       \\<Longrightarrow> unat x \\<le> unat y", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_div_less:\n  \"m < n \\<Longrightarrow> m div n = 0\" for m :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> m div n = 0", "by (simp add: unat_mono word_arith_nat_defs(6))"], ["", "lemma word_must_wrap:\n  \"\\<lbrakk> x \\<le> n - 1; n \\<le> x \\<rbrakk> \\<Longrightarrow> n = (0 :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n - 1; n \\<le> x\\<rbrakk> \\<Longrightarrow> n = 0", "using dual_order.trans sub_wrap word_less_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  (?x \\<le> ?x - ?z) = (?z = 0 \\<or> ?x < ?z)\n  (?x < 1) = (?x = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n - 1; n \\<le> x\\<rbrakk> \\<Longrightarrow> n = 0", "by blast"], ["", "lemma range_subset_card:\n  \"\\<lbrakk> {a :: 'a :: len word .. b} \\<subseteq> {c .. d}; b \\<ge> a \\<rbrakk> \\<Longrightarrow> d \\<ge> c \\<and> d - c \\<ge> b - a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> c \\<le> d \\<and> b - a \\<le> d - c", "using word_sub_le word_sub_mono"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?x - ?y \\<le> ?x\n  \\<lbrakk>?a \\<le> ?c; ?d \\<le> ?b; ?a - ?b \\<le> ?a;\n   ?c - ?d \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a - ?b \\<le> ?c - ?d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{a..b} \\<subseteq> {c..d}; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> c \\<le> d \\<and> b - a \\<le> d - c", "by fastforce"], ["", "lemma less_1_simp:\n  \"n - 1 < m = (n \\<le> (m :: 'a :: len word) \\<and> n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n - 1 < m) = (n \\<le> m \\<and> n \\<noteq> 0)", "by unat_arith"], ["", "lemma word_power_mod_div:\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk> n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> x mod 2 ^ n div 2 ^ m = x div 2 ^ m mod 2 ^ (n - m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x mod 2 ^ n div 2 ^ m = x div 2 ^ m mod 2 ^ (n - m)", "apply (simp add: word_arith_nat_div unat_mod power_mod_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (unat x div 2 ^ m mod 2 ^ (n - m)) =\n                      word_of_nat (unat x div 2 ^ m) mod 2 ^ (n - m)", "apply (subst unat_arith_simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat\n                       (word_of_nat (unat x div 2 ^ m mod 2 ^ (n - m))) =\n                      unat (word_of_nat (unat x div 2 ^ m) mod 2 ^ (n - m))", "apply (subst unat_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat\n                       (word_of_nat (unat x div 2 ^ m mod 2 ^ (n - m))) =\n                      unat (word_of_nat (unat x div 2 ^ m)) mod\n                      unat (2 ^ (n - m))", "apply (subst unat_of_nat)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a); m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x div 2 ^ m mod 2 ^ (n - m) mod 2 ^ LENGTH('a) =\n                      unat x div 2 ^ m mod 2 ^ LENGTH('a) mod\n                      unat (2 ^ (n - m))", "apply (simp add: mod_mod_power min.commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_range_minus_1':\n  fixes a :: \"'a :: len word\"\n  shows \"a \\<noteq> 0 \\<Longrightarrow> {a - 1<..b} = {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> {a - 1<..b} = {a..b}", "by (simp add: greaterThanAtMost_def atLeastAtMost_def greaterThan_def atLeast_def less_1_simp)"], ["", "lemma word_range_minus_1:\n  fixes a :: \"'a :: len word\"\n  shows \"b \\<noteq> 0 \\<Longrightarrow> {a..b - 1} = {a..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> {a..b - 1} = {a..<b}", "apply (simp add: atLeastLessThan_def atLeastAtMost_def atMost_def lessThan_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    {a..} \\<inter> {x. x \\<le> b - 1} = {a..} \\<inter> {x. x < b}", "apply (rule arg_cong [where f = \"\\<lambda>x. {a..} \\<inter> x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> {x. x \\<le> b - 1} = {x. x < b}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<noteq> 0 \\<Longrightarrow> {x. x \\<le> b - 1} \\<subseteq> {x. x < b}\n 2. b \\<noteq> 0 \\<Longrightarrow> {x. x < b} \\<subseteq> {x. x \\<le> b - 1}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>b \\<noteq> 0; x \\<le> b - 1\\<rbrakk> \\<Longrightarrow> x < b\n 2. b \\<noteq> 0 \\<Longrightarrow> {x. x < b} \\<subseteq> {x. x \\<le> b - 1}", "apply (erule contrapos_pp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> b - 1; \\<not> x < b\\<rbrakk>\n       \\<Longrightarrow> \\<not> b \\<noteq> 0\n 2. b \\<noteq> 0 \\<Longrightarrow> {x. x < b} \\<subseteq> {x. x \\<le> b - 1}", "apply (simp add: linorder_not_less linorder_not_le word_must_wrap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> {x. x < b} \\<subseteq> {x. x \\<le> b - 1}", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b \\<noteq> 0; x < b\\<rbrakk> \\<Longrightarrow> x \\<le> b - 1", "apply (drule word_le_minus_one_leq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b \\<noteq> 0; x \\<le> b - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> b - 1", "apply (auto simp: word_less_sub_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_nat_def:\n  \"of_nat (unat x) = (ucast :: 'a :: len word \\<Rightarrow> 'b :: len word) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat (unat x) = ucast x", "by transfer simp"], ["", "lemma overflow_plus_one_self:\n  \"(1 + p \\<le> p) = (p = (-1 :: 'a :: len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + p \\<le> p) = (p = - 1)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 + p \\<le> p \\<Longrightarrow> p = - 1\n 2. p = - 1 \\<Longrightarrow> 1 + p \\<le> p", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 + p \\<le> p; p \\<noteq> - 1\\<rbrakk> \\<Longrightarrow> False\n 2. p = - 1 \\<Longrightarrow> 1 + p \\<le> p", "apply (drule plus_one_helper2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. p \\<noteq> - 1 \\<Longrightarrow> p + 1 \\<noteq> 0\n 2. \\<lbrakk>p \\<noteq> - 1; 1 + p < p + 1\\<rbrakk> \\<Longrightarrow> False\n 3. p = - 1 \\<Longrightarrow> 1 + p \\<le> p", "apply (rule notI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p \\<noteq> - 1; p + 1 = 0\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>p \\<noteq> - 1; 1 + p < p + 1\\<rbrakk> \\<Longrightarrow> False\n 3. p = - 1 \\<Longrightarrow> 1 + p \\<le> p", "apply (drule arg_cong[where f=\"\\<lambda>x. x - 1\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p \\<noteq> - 1; p + 1 - 1 = 0 - 1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>p \\<noteq> - 1; 1 + p < p + 1\\<rbrakk> \\<Longrightarrow> False\n 3. p = - 1 \\<Longrightarrow> 1 + p \\<le> p", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> - 1; 1 + p < p + 1\\<rbrakk> \\<Longrightarrow> False\n 2. p = - 1 \\<Longrightarrow> 1 + p \\<le> p", "apply (simp add: field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = - 1 \\<Longrightarrow> 1 + p \\<le> p", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma plus_1_less:\n  \"(x + 1 \\<le> (x :: 'a :: len word)) = (x = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + 1 \\<le> x) = (x = - 1)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x + 1 \\<le> x \\<Longrightarrow> x = - 1\n 2. x = - 1 \\<Longrightarrow> x + 1 \\<le> x", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x + 1 \\<le> x; x \\<noteq> - 1\\<rbrakk> \\<Longrightarrow> False\n 2. x = - 1 \\<Longrightarrow> x + 1 \\<le> x", "apply (cut_tac plus_one_helper2[where x=x, OF order_refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x + 1 \\<le> x; x \\<noteq> - 1; x < x + 1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x + 1 \\<le> x; x \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0\n 3. x = - 1 \\<Longrightarrow> x + 1 \\<le> x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x + 1 \\<le> x; x \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0\n 2. x = - 1 \\<Longrightarrow> x + 1 \\<le> x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> - 1; x + 1 = 0\\<rbrakk> \\<Longrightarrow> False\n 2. x = - 1 \\<Longrightarrow> x + 1 \\<le> x", "apply (drule arg_cong[where f=\"\\<lambda>x. x - 1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> - 1; x + 1 - 1 = 0 - 1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. x = - 1 \\<Longrightarrow> x + 1 \\<le> x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = - 1 \\<Longrightarrow> x + 1 \\<le> x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pos_mult_pos_ge:\n  \"[|x > (0::int); n>=0 |] ==> n * x >= n*1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; 0 \\<le> n\\<rbrakk> \\<Longrightarrow> n * 1 \\<le> n * x", "apply (simp only: mult_left_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_plus_strict_mono_right:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>y < z; x \\<le> x + z\\<rbrakk> \\<Longrightarrow> x + y < x + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < z; x \\<le> x + z\\<rbrakk> \\<Longrightarrow> x + y < x + z", "by unat_arith"], ["", "lemma word_div_mult:\n  \"0 < c \\<Longrightarrow> a < b * c \\<Longrightarrow> a div c < b\" for a b c :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; a < b * c\\<rbrakk> \\<Longrightarrow> a div c < b", "by (rule classical)\n     (use div_to_mult_word_lt [of b a c] in\n      \\<open>auto simp add: word_less_nat_alt word_le_nat_alt unat_div\\<close>)"], ["", "lemma word_less_power_trans_ofnat:\n  \"\\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> of_nat n * 2 ^ k < (2::'a::len word) ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat n * 2 ^ k < 2 ^ m", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ k * word_of_nat n < 2 ^ m", "apply (rule word_less_power_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat n < 2 ^ (m - k)\n 2. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> m\n 3. \\<lbrakk>n < 2 ^ (m - k); k \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m < LENGTH('a)", "apply (simp_all add: word_less_nat_alt less_le_trans take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_1_le_power:\n  \"n < LENGTH('a) \\<Longrightarrow> (1 :: 'a :: len word) \\<le> 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> 1 \\<le> 2 ^ n", "by (rule inc_le[where i=0, simplified], erule iffD2[OF p2_gt_0])"], ["", "lemma unat_1_0:\n  \"1 \\<le> (x::'a::len word) = (0 < unat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<le> x) = (0 < unat x)", "by (auto simp add: word_le_nat_alt)"], ["", "lemma x_less_2_0_1':\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk> \\<Longrightarrow> x = 0 \\<or> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply (cases \\<open>2 \\<le> LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2; 2 \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1\n 2. \\<lbrakk>LENGTH('a) \\<noteq> 1; x < 2;\n     \\<not> 2 \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2; 2 \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x = 0 \\<or> x = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>take_bit LENGTH('a) x < take_bit LENGTH('a) 2;\n        2 \\<le> LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x = take_bit LENGTH('a) 0 \\<or>\n                         take_bit LENGTH('a) x = take_bit LENGTH('a) 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>take_bit LENGTH('a) x < 2; 2 \\<le> LENGTH('a);\n        take_bit LENGTH('a) x \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) x = 0", "apply (metis add.commute add.right_neutral even_two_times_div_two mod_div_trivial mod_pos_pos_trivial mult.commute mult_zero_left not_less not_take_bit_negative odd_two_times_div_two_succ)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_add_le_iff2 = word_add_le_iff [folded no_olen_add_nat]"], ["", "lemma of_nat_power:\n  shows \"\\<lbrakk> p < 2 ^ x; x < len_of TYPE ('a) \\<rbrakk> \\<Longrightarrow> of_nat p < (2 :: 'a :: len word) ^ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat p < 2 ^ x", "apply (rule order_less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat p < ?y\n 2. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> 2 ^ x", "apply (rule of_nat_mono_maybe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ?x3 < 2 ^ LENGTH('a)\n 2. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk> \\<Longrightarrow> p < ?x3\n 3. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat ?x3 \\<le> 2 ^ x", "apply (erule power_strict_increasing)"], ["proof (prove)\ngoal (3 subgoals):\n 1. p < 2 ^ x \\<Longrightarrow> 1 < 2\n 2. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk> \\<Longrightarrow> p < 2 ^ x\n 3. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (2 ^ x) \\<le> 2 ^ x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk> \\<Longrightarrow> p < 2 ^ x\n 2. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (2 ^ x) \\<le> 2 ^ x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p < 2 ^ x; x < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (2 ^ x) \\<le> 2 ^ x", "apply (simp add: word_unat_power del: of_nat_power)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_nat_n_less_equal_power_2:\n  \"n < LENGTH('a::len) \\<Longrightarrow> ((of_nat n)::'a word) < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow> word_of_nat n < 2 ^ n", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < LENGTH('a) \\<Longrightarrow> word_of_nat 0 < 2 ^ 0\n 2. \\<And>n.\n       \\<lbrakk>n < LENGTH('a) \\<Longrightarrow> word_of_nat n < 2 ^ n;\n        Suc n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat (Suc n) < 2 ^ Suc n", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < LENGTH('a) \\<Longrightarrow> word_of_nat n < 2 ^ n;\n        Suc n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat (Suc n) < 2 ^ Suc n", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>word_of_nat n < 2 ^ n; Suc n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> 1 + word_of_nat n < 2 * 2 ^ n", "apply (metis of_nat_power n_less_equal_power_2 of_nat_Suc power_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eq_mask_less:\n  fixes w :: \"'a::len word\"\n  assumes eqm: \"w = w AND mask n\"\n  and      sz: \"n < len_of TYPE ('a)\"\n  shows \"w < (2::'a word) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w < 2 ^ n", "by (subst eqm, rule and_mask_less' [OF sz])"], ["", "lemma of_nat_mono_maybe':\n  fixes Y :: \"nat\"\n  assumes xlt: \"x < 2 ^ len_of TYPE ('a)\"\n  assumes ylt: \"y < 2 ^ len_of TYPE ('a)\"\n  shows   \"(y < x) = (of_nat y < (of_nat x :: 'a :: len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y < x) = (word_of_nat y < word_of_nat x)", "apply (subst word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y < x) = (unat (word_of_nat y) < unat (word_of_nat x))", "apply (subst unat_of_nat)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y < x) = (y mod 2 ^ LENGTH('a) < x mod 2 ^ LENGTH('a))", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y < 2 ^ LENGTH('a)\n 2. (y < x) = (y < x mod 2 ^ LENGTH('a))", "apply (rule ylt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y < x) = (y < x mod 2 ^ LENGTH('a))", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < 2 ^ LENGTH('a)\n 2. (y < x) = (y < x)", "apply (rule xlt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y < x) = (y < x)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_nat_mono_maybe_le:\n  \"\\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk> \\<Longrightarrow>\n  (y \\<le> x) = ((of_nat y :: 'a :: len word) \\<le> of_nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (y \\<le> x) = (word_of_nat y \\<le> word_of_nat x)", "apply (clarsimp simp: le_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (y < x \\<or> y = x) =\n                      (word_of_nat y < word_of_nat x \\<or>\n                       word_of_nat y = word_of_nat x)", "apply (rule disj_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (y < x) = (word_of_nat y < word_of_nat x)\n 2. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a);\n     \\<not> word_of_nat y < word_of_nat x\\<rbrakk>\n    \\<Longrightarrow> (y = x) = (word_of_nat y = word_of_nat x)", "apply (rule of_nat_mono_maybe', assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a);\n     \\<not> word_of_nat y < word_of_nat x\\<rbrakk>\n    \\<Longrightarrow> (y = x) = (word_of_nat y = word_of_nat x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a);\n     word_of_nat y = word_of_nat x\\<rbrakk>\n    \\<Longrightarrow> y = x", "using of_nat_inj"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < 2 ^ LENGTH(?'a); ?y < 2 ^ LENGTH(?'a)\\<rbrakk>\n  \\<Longrightarrow> (word_of_nat ?x = word_of_nat ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ LENGTH('a); y < 2 ^ LENGTH('a);\n     word_of_nat y = word_of_nat x\\<rbrakk>\n    \\<Longrightarrow> y = x", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_AND_NOT_mask:\n  \"(w AND NOT (mask n)) AND mask n = 0\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND NOT (mask n)) AND mask n = 0", "by (rule bit_word_eqI) (simp add: bit_simps)"], ["", "lemma AND_NOT_mask_plus_AND_mask_eq:\n  \"(w AND NOT (mask n)) + (w AND mask n) = w\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND NOT (mask n)) + (w AND mask n) = w", "apply (subst disjunctive_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<not> bit (w AND NOT (mask n)) na \\<or> \\<not> bit (w AND mask n) na\n 2. w AND NOT (mask n) OR w AND mask n = w", "apply (auto simp add: bit_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND NOT (mask n) OR w AND mask n = w", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (w AND NOT (mask n) OR w AND mask n) na = bit w na", "apply (auto simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_eqI:\n  fixes x :: \"'a :: len word\"\n  assumes m1: \"x AND mask n = y AND mask n\"\n  and     m2: \"x AND NOT (mask n) = y AND NOT (mask n)\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have *: \\<open>x = x AND mask n OR x AND NOT (mask n)\\<close> for x :: \\<open>'a word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x AND mask n OR x AND NOT (mask n)", "by (rule bit_word_eqI) (auto simp add: bit_simps)"], ["proof (state)\nthis:\n  ?x = ?x AND mask n OR ?x AND NOT (mask n)\n\ngoal (1 subgoal):\n 1. x = y", "from assms * [of x] * [of y]"], ["proof (chain)\npicking this:\n  x AND mask n = y AND mask n\n  x AND NOT (mask n) = y AND NOT (mask n)\n  x = x AND mask n OR x AND NOT (mask n)\n  y = y AND mask n OR y AND NOT (mask n)", "show ?thesis"], ["proof (prove)\nusing this:\n  x AND mask n = y AND mask n\n  x AND NOT (mask n) = y AND NOT (mask n)\n  x = x AND mask n OR x AND NOT (mask n)\n  y = y AND mask n OR y AND NOT (mask n)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neq_0_no_wrap:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> x \\<le> x + y; x \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x + y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + y \\<noteq> 0", "by clarsimp"], ["", "lemma unatSuc2:\n  fixes n :: \"'a :: len word\"\n  shows \"n + 1 \\<noteq> 0 \\<Longrightarrow> unat (n + 1) = Suc (unat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 \\<noteq> 0 \\<Longrightarrow> unat (n + 1) = Suc (unat n)", "by (simp add: add.commute unatSuc)"], ["", "lemma word_of_nat_le:\n  \"n \\<le> unat x \\<Longrightarrow> of_nat n \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> unat x \\<Longrightarrow> word_of_nat n \\<le> x", "apply (simp add: word_le_nat_alt unat_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> unat x \\<Longrightarrow> take_bit LENGTH('a) n \\<le> unat x", "apply (erule order_trans[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) n \\<le> n", "apply (simp add: take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_unat_less_le:\n  \"a \\<le> of_nat b \\<Longrightarrow> unat a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> word_of_nat b \\<Longrightarrow> unat a \\<le> b", "by (metis eq_iff le_cases le_unat_uoi word_of_nat_le)"], ["", "lemma mask_Suc_0 : \"mask (Suc 0) = (1 :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc 0) = 1", "by (simp add: mask_eq_decr_exp)"], ["", "lemma bool_mask':\n  fixes x :: \"'a :: len word\"\n  shows \"2 < LENGTH('a) \\<Longrightarrow> (0 < x AND 1) = (x AND 1 = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < LENGTH('a) \\<Longrightarrow> (0 < x AND 1) = (x AND 1 = 1)", "by (simp add: and_one_eq mod_2_eq_odd)"], ["", "lemma ucast_ucast_add:\n  fixes x :: \"'a :: len word\"\n  fixes y :: \"'b :: len word\"\n  shows\n  \"LENGTH('b) \\<ge> LENGTH('a) \\<Longrightarrow>\n    ucast (ucast x + y) = x + ucast y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n    ucast (ucast x + y) = x + ucast y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n       take_bit LENGTH('a)\n        (take_bit LENGTH('b) (take_bit LENGTH('a) x + y)) =\n       take_bit LENGTH('a) (x + take_bit LENGTH('b) y)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n       take_bit LENGTH('a) (take_bit LENGTH('a) x + y) =\n       take_bit LENGTH('a) (x + take_bit LENGTH('b) y)", "apply (subst (2) take_bit_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n       take_bit LENGTH('a) (take_bit LENGTH('a) x + y) =\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a) x +\n         take_bit LENGTH('a) (take_bit LENGTH('b) y))", "apply (subst take_bit_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       LENGTH('a) \\<le> LENGTH('b) \\<Longrightarrow>\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a) (take_bit LENGTH('a) x) +\n         take_bit LENGTH('a) y) =\n       take_bit LENGTH('a)\n        (take_bit LENGTH('a) x +\n         take_bit LENGTH('a) (take_bit LENGTH('b) y))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lt1_neq0:\n  fixes x :: \"'a :: len word\"\n  shows \"(1 \\<le> x) = (x \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<le> x) = (x \\<noteq> 0)", "by unat_arith"], ["", "lemma word_plus_one_nonzero:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk>x \\<le> x + y; y \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + y; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0", "apply (subst lt1_neq0 [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + y; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> x + 1", "apply (subst olen_add_eqv [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x + y; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + 1", "apply (erule word_random)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> 1 \\<le> y", "apply (simp add: lt1_neq0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_sub_plus_one_nonzero:\n  fixes n :: \"'a :: len word\"\n  shows \"\\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk> \\<Longrightarrow> (n - n') + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> n - n' + 1 \\<noteq> 0", "apply (subst lt1_neq0 [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> n - n' + 1", "apply (subst olen_add_eqv [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> n - n' \\<le> n - n' + 1", "apply (rule word_random [where x' = n'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> n - n' \\<le> n - n' + n'\n 2. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk> \\<Longrightarrow> 1 \\<le> n'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> n - n' \\<le> n\n 2. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk> \\<Longrightarrow> 1 \\<le> n'", "apply (erule word_sub_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; n' \\<noteq> 0\\<rbrakk> \\<Longrightarrow> 1 \\<le> n'", "apply (simp add: lt1_neq0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_le_minus_mono_right:\n  fixes x :: \"'a :: len word\"\n  shows \"\\<lbrakk> z \\<le> y; y \\<le> x; z \\<le> x \\<rbrakk> \\<Longrightarrow> x - y \\<le> x - z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - y \\<le> x - z", "apply (rule word_sub_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x\n 2. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> z \\<le> y\n 3. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - y \\<le> x\n 4. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - z \\<le> x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> z \\<le> y\n 2. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - y \\<le> x\n 3. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - z \\<le> x", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - y \\<le> x\n 2. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - z \\<le> x", "apply (erule word_sub_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<le> y; y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - z \\<le> x", "apply (erule word_sub_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_0_sle_from_less:\n  \\<open>0 \\<le>s x\\<close> if \\<open>x < 2 ^ (LENGTH('a) - 1)\\<close> for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le>s x", "using that"], ["proof (prove)\nusing this:\n  x < 2 ^ (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. 0 \\<le>s x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       take_bit LENGTH('a) x\n       < take_bit LENGTH('a) (2 ^ (LENGTH('a) - 1)) \\<Longrightarrow>\n       signed_take_bit (LENGTH('a) - Suc 0) 0\n       \\<le> signed_take_bit (LENGTH('a) - Suc 0) x", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>take_bit LENGTH('a) x\n                < take_bit LENGTH('a) (2 ^ (LENGTH('a) - 1));\n        LENGTH('a) = 0\\<rbrakk>\n       \\<Longrightarrow> signed_take_bit (LENGTH('a) - Suc 0) 0\n                         \\<le> signed_take_bit (LENGTH('a) - Suc 0) x\n 2. \\<And>x nat.\n       \\<lbrakk>take_bit LENGTH('a) x\n                < take_bit LENGTH('a) (2 ^ (LENGTH('a) - 1));\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> signed_take_bit (LENGTH('a) - Suc 0) 0\n                         \\<le> signed_take_bit (LENGTH('a) - Suc 0) x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x nat.\n       \\<lbrakk>take_bit (Suc nat) x < 2 ^ nat;\n        LENGTH('a) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit x nat", "apply (metis bit_take_bit_iff min_def nat_less_le not_less_eq take_bit_int_eq_self_iff take_bit_take_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_sub_ucast:\n  fixes x :: \"'a::len word\"\n  assumes \"y \\<le> x\"\n  assumes T: \"LENGTH('a) \\<le> LENGTH('b)\"\n  shows \"ucast (x - y) = (ucast x - ucast y :: 'b::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ucast (x - y) = ucast x - ucast y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ucast (x - y) = ucast x - ucast y", "from T"], ["proof (chain)\npicking this:\n  LENGTH('a) \\<le> LENGTH('b)", "have P: \"unat x < 2 ^ LENGTH('b)\" \"unat y < 2 ^ LENGTH('b)\""], ["proof (prove)\nusing this:\n  LENGTH('a) \\<le> LENGTH('b)\n\ngoal (1 subgoal):\n 1. unat x < 2 ^ LENGTH('b) &&& unat y < 2 ^ LENGTH('b)", "by (fastforce intro!: less_le_trans[OF unat_lt2p])+"], ["proof (state)\nthis:\n  unat x < 2 ^ LENGTH('b)\n  unat y < 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. ucast (x - y) = ucast x - ucast y", "then"], ["proof (chain)\npicking this:\n  unat x < 2 ^ LENGTH('b)\n  unat y < 2 ^ LENGTH('b)", "show ?thesis"], ["proof (prove)\nusing this:\n  unat x < 2 ^ LENGTH('b)\n  unat y < 2 ^ LENGTH('b)\n\ngoal (1 subgoal):\n 1. ucast (x - y) = ucast x - ucast y", "by (simp add: unat_arith_simps unat_ucast assms[simplified unat_arith_simps])"], ["proof (state)\nthis:\n  ucast (x - y) = ucast x - ucast y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_1_0:\n  \"\\<lbrakk>a + (1::('a::len) word) \\<le> b; a < of_nat x\\<rbrakk> \\<Longrightarrow> a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + 1 \\<le> b; a < word_of_nat x\\<rbrakk>\n    \\<Longrightarrow> a < b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>take_bit LENGTH('a) (a + 1) \\<le> take_bit LENGTH('a) b;\n        take_bit LENGTH('a) a < take_bit LENGTH('a) (int x)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) a < take_bit LENGTH('a) b", "apply (subst (asm) take_bit_incr_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       take_bit LENGTH('a) a < take_bit LENGTH('a) (int x) \\<Longrightarrow>\n       take_bit LENGTH('a) a \\<noteq> 2 ^ LENGTH('a) - 1\n 2. \\<And>a b x.\n       \\<lbrakk>1 + take_bit LENGTH('a) a \\<le> take_bit LENGTH('a) b;\n        take_bit LENGTH('a) a < take_bit LENGTH('a) (int x)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) a < take_bit LENGTH('a) b", "apply (auto simp add: diff_less_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>2 ^ LENGTH('a) \\<le> take_bit LENGTH('a) (int x);\n        take_bit LENGTH('a) a = 2 ^ LENGTH('a) - 1\\<rbrakk>\n       \\<Longrightarrow> False", "using take_bit_int_less_exp le_less_trans"], ["proof (prove)\nusing this:\n  take_bit ?n ?k < 2 ^ ?n\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>2 ^ LENGTH('a) \\<le> take_bit LENGTH('a) (int x);\n        take_bit LENGTH('a) a = 2 ^ LENGTH('a) - 1\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["", "lemma unat_of_nat_less:\"\\<lbrakk> a < b; unat b = c \\<rbrakk> \\<Longrightarrow> a < of_nat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < b; unat b = c\\<rbrakk> \\<Longrightarrow> a < word_of_nat c", "by fastforce"], ["", "lemma word_le_plus_1: \"\\<lbrakk> (y::('a::len) word) < y + n; a < n \\<rbrakk> \\<Longrightarrow> y + a \\<le> y + a + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < y + n; a < n\\<rbrakk>\n    \\<Longrightarrow> y + a \\<le> y + a + 1", "by unat_arith"], ["", "lemma word_le_plus:\"\\<lbrakk>(a::('a::len) word) < a + b; c < b\\<rbrakk> \\<Longrightarrow> a \\<le> a + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < a + b; c < b\\<rbrakk> \\<Longrightarrow> a \\<le> a + c", "by (metis order_less_imp_le word_random)"], ["", "lemma sint_minus1 [simp]: \"(sint x = -1) = (x = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint x = - 1) = (x = - 1)", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) = 0 \\<Longrightarrow> (sint x = - 1) = (x = - 1)\n 2. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow> (sint x = - 1) = (x = - 1)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow> (sint x = - 1) = (x = - 1)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat x.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       (signed_take_bit (LENGTH('a) - Suc 0) x = - 1) =\n       (take_bit LENGTH('a) x = take_bit LENGTH('a) (- 1))", "apply (simp flip: signed_take_bit_eq_iff_take_bit_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sint_0 [simp]: \"(sint x = 0) = (x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint x = 0) = (x = 0)", "by (fact signed_eq_0_iff)"], ["", "(* It is not always that case that \"sint 1 = 1\", because of 1-bit word sizes.\n * This lemma produces the different cases. *)"], ["", "lemma sint_1_cases:\n  P if \\<open>\\<lbrakk> len_of TYPE ('a::len) = 1; (a::'a word) = 0; sint a = 0 \\<rbrakk> \\<Longrightarrow> P\\<close>\n     \\<open>\\<lbrakk> len_of TYPE ('a) = 1; a = 1; sint (1 :: 'a word) = -1 \\<rbrakk> \\<Longrightarrow> P\\<close>\n     \\<open>\\<lbrakk> len_of TYPE ('a) > 1; sint (1 :: 'a word) = 1 \\<rbrakk> \\<Longrightarrow> P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases \\<open>LENGTH('a) = 1\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. LENGTH('a) = 1 \\<Longrightarrow> P\n 2. LENGTH('a) \\<noteq> 1 \\<Longrightarrow> P", "case True"], ["proof (state)\nthis:\n  LENGTH('a) = 1\n\ngoal (2 subgoals):\n 1. LENGTH('a) = 1 \\<Longrightarrow> P\n 2. LENGTH('a) \\<noteq> 1 \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  LENGTH('a) = 1", "have \\<open>a = 0 \\<or> a = 1\\<close>"], ["proof (prove)\nusing this:\n  LENGTH('a) = 1\n\ngoal (1 subgoal):\n 1. a = 0 \\<or> a = 1", "by transfer auto"], ["proof (state)\nthis:\n  a = 0 \\<or> a = 1\n\ngoal (2 subgoals):\n 1. LENGTH('a) = 1 \\<Longrightarrow> P\n 2. LENGTH('a) \\<noteq> 1 \\<Longrightarrow> P", "with True that"], ["proof (chain)\npicking this:\n  LENGTH('a) = 1\n  \\<lbrakk>LENGTH('a) = 1; a = 0; sint a = 0\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>LENGTH('a) = 1; a = 1; sint 1 = - 1\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>1 < LENGTH('a); sint 1 = 1\\<rbrakk> \\<Longrightarrow> P\n  a = 0 \\<or> a = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  LENGTH('a) = 1\n  \\<lbrakk>LENGTH('a) = 1; a = 0; sint a = 0\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>LENGTH('a) = 1; a = 1; sint 1 = - 1\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>1 < LENGTH('a); sint 1 = 1\\<rbrakk> \\<Longrightarrow> P\n  a = 0 \\<or> a = 1\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. LENGTH('a) \\<noteq> 1 \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<noteq> 1 \\<Longrightarrow> P", "case False"], ["proof (state)\nthis:\n  LENGTH('a) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. LENGTH('a) \\<noteq> 1 \\<Longrightarrow> P", "with that"], ["proof (chain)\npicking this:\n  \\<lbrakk>LENGTH('a) = 1; a = 0; sint a = 0\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>LENGTH('a) = 1; a = 1; sint 1 = - 1\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>1 < LENGTH('a); sint 1 = 1\\<rbrakk> \\<Longrightarrow> P\n  LENGTH('a) \\<noteq> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>LENGTH('a) = 1; a = 0; sint a = 0\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>LENGTH('a) = 1; a = 1; sint 1 = - 1\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>1 < LENGTH('a); sint 1 = 1\\<rbrakk> \\<Longrightarrow> P\n  LENGTH('a) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. P", "by (simp add: less_le Suc_le_eq)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sint_int_min:\n  \"sint (- (2 ^ (LENGTH('a) - Suc 0)) :: ('a::len) word) = - (2 ^ (LENGTH('a) - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint (- (2 ^ (LENGTH('a) - Suc 0))) = - (2 ^ (LENGTH('a) - Suc 0))", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) = 0 \\<Longrightarrow>\n    sint (- (2 ^ (LENGTH('a) - Suc 0))) = - (2 ^ (LENGTH('a) - Suc 0))\n 2. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       sint (- (2 ^ (LENGTH('a) - Suc 0))) = - (2 ^ (LENGTH('a) - Suc 0))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       sint (- (2 ^ nat)) = - (2 ^ nat)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       signed_take_bit (LENGTH('a) - Suc 0) (- (2 ^ nat)) = - (2 ^ nat)", "apply (simp add: signed_take_bit_int_eq_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sint_int_max_plus_1:\n  \"sint (2 ^ (LENGTH('a) - Suc 0) :: ('a::len) word) = - (2 ^ (LENGTH('a) - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sint (2 ^ (LENGTH('a) - Suc 0)) = - (2 ^ (LENGTH('a) - Suc 0))", "apply (cases \\<open>LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LENGTH('a) = 0 \\<Longrightarrow>\n    sint (2 ^ (LENGTH('a) - Suc 0)) = - (2 ^ (LENGTH('a) - Suc 0))\n 2. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       sint (2 ^ (LENGTH('a) - Suc 0)) = - (2 ^ (LENGTH('a) - Suc 0))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow> sint (2 ^ nat) = - (2 ^ nat)", "apply (subst word_of_int_2p [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       sint (word_of_int (2 ^ nat)) = - (2 ^ nat)", "apply (subst int_word_sint)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       LENGTH('a) = Suc nat \\<Longrightarrow>\n       (2 ^ nat + 2 ^ (LENGTH('a) - 1)) mod 2 ^ LENGTH('a) -\n       2 ^ (LENGTH('a) - 1) =\n       - (2 ^ nat)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma uint_range':\n  \\<open>0 \\<le> uint x \\<and> uint x < 2 ^ LENGTH('a)\\<close>\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> uint x \\<and> uint x < 2 ^ LENGTH('a)", "by transfer simp"], ["", "lemma sint_of_int_eq:\n  \"\\<lbrakk> - (2 ^ (LENGTH('a) - 1)) \\<le> x; x < 2 ^ (LENGTH('a) - 1) \\<rbrakk> \\<Longrightarrow> sint (of_int x :: ('a::len) word) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- (2 ^ (LENGTH('a) - 1)) \\<le> x;\n     x < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n    \\<Longrightarrow> sint (word_of_int x) = x", "by (simp add: signed_take_bit_int_eq_self)"], ["", "lemma of_int_sint:\n  \"of_int (sint a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (sint a) = a", "by simp"], ["", "lemma sint_ucast_eq_uint:\n    \"\\<lbrakk> \\<not> is_down (ucast :: ('a::len word \\<Rightarrow> 'b::len word)) \\<rbrakk>\n            \\<Longrightarrow> sint ((ucast :: ('a::len word \\<Rightarrow> 'b::len word)) x) = uint x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_down ucast \\<Longrightarrow> sint (ucast x) = uint x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n       signed_take_bit (LENGTH('b) - Suc 0) (take_bit LENGTH('a) x) =\n       take_bit LENGTH('a) x", "apply (simp add: signed_take_bit_take_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_less_nowrapI':\n  \"(x :: 'a :: len word) \\<le> z - k \\<Longrightarrow> k \\<le> z \\<Longrightarrow> 0 < k \\<Longrightarrow> x < x + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> z - k; k \\<le> z; 0 < k\\<rbrakk>\n    \\<Longrightarrow> x < x + k", "by uint_arith"], ["", "lemma mask_plus_1:\n  \"mask n + 1 = (2 ^ n :: 'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n + 1 = 2 ^ n", "by (clarsimp simp: mask_eq_decr_exp)"], ["", "lemma unat_inj: \"inj unat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj unat", "by (metis eq_iff injI word_le_nat_alt)"], ["", "lemma unat_ucast_upcast:\n  \"is_up (ucast :: 'b word \\<Rightarrow> 'a word)\n      \\<Longrightarrow> unat (ucast x :: ('a::len) word) = unat (x :: ('b::len) word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_up ucast \\<Longrightarrow> unat (ucast x) = unat x", "unfolding ucast_eq unat_eq_nat_uint"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_up (\\<lambda>w. word_of_int (uint w)) \\<Longrightarrow>\n    nat (uint (word_of_int (uint x))) = nat (uint x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       LENGTH('b) \\<le> LENGTH('a) \\<Longrightarrow>\n       nat (take_bit LENGTH('a) (take_bit LENGTH('b) x)) =\n       nat (take_bit LENGTH('b) x)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_mono:\n  \"\\<lbrakk> (x :: 'b :: len word) < y; y < 2 ^ LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> ucast x < ((ucast y) :: 'a :: len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ucast x < ucast y", "apply (simp only: flip: ucast_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (unat x) < word_of_nat (unat y)", "apply (rule of_nat_mono_maybe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < y; y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat y < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x < y; y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x < unat y", "apply (rule unat_less_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < y; y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y < word_of_nat (2 ^ LENGTH('a))\n 2. \\<lbrakk>x < y; y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x < unat y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat x < unat y", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_mono_le:\n  \"\\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk> \\<Longrightarrow> (ucast (x :: 'a :: len word) :: 'b :: len word) \\<le> ucast y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> ucast x \\<le> ucast y", "apply (simp only: flip: ucast_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (unat x) \\<le> word_of_nat (unat y)", "apply (subst of_nat_mono_maybe_le[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat y < 2 ^ LENGTH('b)\n 2. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x < 2 ^ LENGTH('b)\n 3. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply (rule unat_less_helper)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> y < word_of_nat (2 ^ LENGTH('b))\n 2. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x < 2 ^ LENGTH('b)\n 3. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x < 2 ^ LENGTH('b)\n 2. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply (rule unat_less_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> x < word_of_nat (2 ^ LENGTH('b))\n 2. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply (erule le_less_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y < 2 ^ LENGTH('b) \\<Longrightarrow> y < word_of_nat (2 ^ LENGTH('b))\n 2. \\<lbrakk>x \\<le> y; y < 2 ^ LENGTH('b)\\<rbrakk>\n    \\<Longrightarrow> unat x \\<le> unat y", "apply (simp_all add: word_le_nat_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ucast_mono_le':\n  \"\\<lbrakk> unat y < 2 ^ LENGTH('b); LENGTH('b::len) < LENGTH('a::len); x \\<le> y \\<rbrakk>\n   \\<Longrightarrow> ucast x \\<le> (ucast y :: 'b word)\" for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unat y < 2 ^ LENGTH('b); LENGTH('b) < LENGTH('a);\n     x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ucast x \\<le> ucast y", "by (auto simp: word_less_nat_alt intro: ucast_mono_le)"], ["", "lemma neg_mask_add_mask:\n  \"((x:: 'a :: len word) AND NOT (mask n)) + (2 ^ n - 1) = x OR mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND NOT (mask n)) + (2 ^ n - 1) = x OR mask n", "unfolding mask_2pm1 [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND NOT (mask n)) + mask n = x OR mask n", "apply (subst word_plus_and_or_coroll; rule bit_word_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit ((x AND NOT (mask n)) AND mask n) na = bit 0 na\n 2. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (x AND NOT (mask n) OR mask n) na = bit (x OR mask n) na", "apply (auto simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_step_down_word:\"\\<lbrakk>(i::('a::len) word) \\<le> n; i = n \\<longrightarrow> P; i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> n; i = n \\<longrightarrow> P;\n     i \\<le> n - 1 \\<longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by unat_arith"], ["", "lemma le_step_down_word_2:\n  fixes x :: \"'a::len word\"\n  shows \"\\<lbrakk>x \\<le>  y; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> x \\<le> y - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 1", "by (subst (asm) word_le_less_eq,\n      clarsimp,\n      simp add: word_le_minus_one_leq)"], ["", "lemma NOT_mask_AND_mask[simp]: \"(w AND mask n) AND NOT (mask n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND mask n) AND NOT (mask n) = (0::'a)", "by (clarsimp simp add: mask_eq_decr_exp Parity.bit_eq_iff bit_and_iff bit_not_iff bit_mask_iff)"], ["", "lemma and_and_not[simp]:\"(a AND b) AND NOT b = 0\"\n  for a b :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a AND b) AND NOT b = 0", "apply (subst word_bw_assocs(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. a AND b AND NOT b = 0", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_mask_1[simp]: \"(\\<exists>x. mask x = (1 :: 'a::len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = 1", "apply (rule_tac x=1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask 1 = 1", "apply (simp add:mask_eq_decr_exp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_switch:\"NOT a = x \\<Longrightarrow> a = NOT x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT a = x \\<Longrightarrow> a = NOT x", "by auto"], ["", "end"]]}