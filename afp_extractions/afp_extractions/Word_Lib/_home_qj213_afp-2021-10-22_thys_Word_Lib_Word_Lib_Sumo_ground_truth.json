{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Word_Lib_Sumo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemmas of_int_and_nat = unsigned_of_nat unsigned_of_int signed_of_int signed_of_nat", "lemmas bshiftr1_def = bshiftr1_eq", "lemmas is_down_def = is_down_eq", "lemmas is_up_def = is_up_eq", "lemmas mask_def = mask_eq", "lemmas scast_def = scast_eq", "lemmas shiftl1_def = shiftl1_eq", "lemmas shiftr1_def = shiftr1_eq", "lemmas sshiftr1_def = sshiftr1_eq", "lemmas sshiftr_def = sshiftr_eq_funpow_sshiftr1", "lemmas to_bl_def = to_bl_eq", "lemmas ucast_def = ucast_eq", "lemmas unat_def = unat_eq_nat_uint", "lemmas word_cat_def = word_cat_eq", "lemmas word_reverse_def = word_reverse_eq_of_bl_rev_to_bl", "lemmas word_roti_def = word_roti_eq_word_rotr_word_rotl", "lemmas word_rotl_def = word_rotl_eq", "lemmas word_rotr_def = word_rotr_eq", "lemmas word_sle_def = word_sle_eq", "lemmas word_sless_def = word_sless_eq", "lemmas uint_0 = uint_nonnegative", "lemmas uint_lt = uint_bounded", "lemmas uint_mod_same = uint_idem", "lemmas of_nth_def = word_set_bits_def", "lemmas of_nat_word_eq_iff = word_of_nat_eq_iff", "lemmas of_nat_word_eq_0_iff = word_of_nat_eq_0_iff", "lemmas of_int_word_eq_iff = word_of_int_eq_iff", "lemmas of_int_word_eq_0_iff = word_of_int_eq_0_iff", "lemmas word_next_def = word_next_unfold", "lemmas word_prev_def = word_prev_unfold", "lemmas is_aligned_def = is_aligned_iff_dvd_nat", "lemma shiftl_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_word ===> (=) ===> pcr_word) (<<) (<<)\"", "lemmas word_and_max_simps =\n  word8_and_max_simp\n  word16_and_max_simp\n  word32_and_max_simp", "lemma distinct_lemma: \"f x \\<noteq> f y \\<Longrightarrow> x \\<noteq> y\"", "lemmas and_bang = word_and_nth", "lemmas sdiv_int_def = signed_divide_int_def", "lemmas smod_int_def = signed_modulo_int_def", "lemma word_fixed_sint_1[simp]:\n  \"sint (1::8 word) = 1\"\n  \"sint (1::16 word) = 1\"\n  \"sint (1::32 word) = 1\"\n  \"sint (1::64 word) = 1\"", "lemmas cast_simps = cast_simps ucast_down_bl", "lemma nth_ucast:\n  \"(ucast (w::'a::len word)::'b::len word) !! n =\n   (w !! n \\<and> n < min LENGTH('a) LENGTH('b))\""], "translations": [["", "lemmas of_int_and_nat = unsigned_of_nat unsigned_of_int signed_of_int signed_of_nat"], ["", "bundle no_take_bit\nbegin"], ["", "declare of_int_and_nat[simp del]"], ["", "end"], ["", "lemmas bshiftr1_def = bshiftr1_eq"], ["", "lemmas is_down_def = is_down_eq"], ["", "lemmas is_up_def = is_up_eq"], ["", "lemmas mask_def = mask_eq"], ["", "lemmas scast_def = scast_eq"], ["", "lemmas shiftl1_def = shiftl1_eq"], ["", "lemmas shiftr1_def = shiftr1_eq"], ["", "lemmas sshiftr1_def = sshiftr1_eq"], ["", "lemmas sshiftr_def = sshiftr_eq_funpow_sshiftr1"], ["", "lemmas to_bl_def = to_bl_eq"], ["", "lemmas ucast_def = ucast_eq"], ["", "lemmas unat_def = unat_eq_nat_uint"], ["", "lemmas word_cat_def = word_cat_eq"], ["", "lemmas word_reverse_def = word_reverse_eq_of_bl_rev_to_bl"], ["", "lemmas word_roti_def = word_roti_eq_word_rotr_word_rotl"], ["", "lemmas word_rotl_def = word_rotl_eq"], ["", "lemmas word_rotr_def = word_rotr_eq"], ["", "lemmas word_sle_def = word_sle_eq"], ["", "lemmas word_sless_def = word_sless_eq"], ["", "lemmas uint_0 = uint_nonnegative"], ["", "lemmas uint_lt = uint_bounded"], ["", "lemmas uint_mod_same = uint_idem"], ["", "lemmas of_nth_def = word_set_bits_def"], ["", "lemmas of_nat_word_eq_iff = word_of_nat_eq_iff"], ["", "lemmas of_nat_word_eq_0_iff = word_of_nat_eq_0_iff"], ["", "lemmas of_int_word_eq_iff = word_of_int_eq_iff"], ["", "lemmas of_int_word_eq_0_iff = word_of_int_eq_0_iff"], ["", "lemmas word_next_def = word_next_unfold"], ["", "lemmas word_prev_def = word_prev_unfold"], ["", "lemmas is_aligned_def = is_aligned_iff_dvd_nat"], ["", "lemma shiftl_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_word ===> (=) ===> pcr_word) (<<) (<<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_word ===> (=) ===> pcr_word) (<<) (<<)", "by (unfold shiftl_eq_push_bit) transfer_prover"], ["", "lemmas word_and_max_simps =\n  word8_and_max_simp\n  word16_and_max_simp\n  word32_and_max_simp"], ["", "lemma distinct_lemma: \"f x \\<noteq> f y \\<Longrightarrow> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<noteq> f y \\<Longrightarrow> x \\<noteq> y", "by auto"], ["", "lemmas and_bang = word_and_nth"], ["", "lemmas sdiv_int_def = signed_divide_int_def"], ["", "lemmas smod_int_def = signed_modulo_int_def"], ["", "(* shortcut for some specific lengths *)"], ["", "lemma word_fixed_sint_1[simp]:\n  \"sint (1::8 word) = 1\"\n  \"sint (1::16 word) = 1\"\n  \"sint (1::32 word) = 1\"\n  \"sint (1::64 word) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint 1 = 1 &&& sint 1 = 1) &&& sint 1 = 1 &&& sint 1 = 1", "by (auto simp: sint_word_ariths)"], ["", "declare of_nat_diff [simp]"], ["", "(* Haskellish names/syntax *)"], ["", "notation (input)\n  test_bit (\"testBit\")"], ["", "lemmas cast_simps = cast_simps ucast_down_bl"], ["", "(* shadows the slightly weaker Word.nth_ucast *)"], ["", "lemma nth_ucast:\n  \"(ucast (w::'a::len word)::'b::len word) !! n =\n   (w !! n \\<and> n < min LENGTH('a) LENGTH('b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST('a \\<rightarrow> 'b) w !! n =\n    (w !! n \\<and> n < min LENGTH('a) LENGTH('b))", "by transfer (simp add: bit_take_bit_iff ac_simps)"], ["", "end"]]}